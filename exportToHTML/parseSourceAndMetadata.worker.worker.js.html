<html>
<head>
<title>parseSourceAndMetadata.worker.worker.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #cc7832;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #4646f1;}
.s5 { color: #6a8759;}
.s6 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
parseSourceAndMetadata.worker.worker.js</font>
</center></td></tr></table>
<pre><span class="s0">(()=&gt;{</span><span class="s1">var </span><span class="s0">e={</span><span class="s2">785</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">397</span><span class="s0">);Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.codeFrameColumns=l,t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t,r,i={}){</span><span class="s1">if</span><span class="s0">(!a){a=!</span><span class="s2">0</span><span class="s0">;const e=</span><span class="s3">&quot;Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.&quot;</span><span class="s0">;n.emitWarning?n.emitWarning(e,</span><span class="s3">&quot;DeprecationWarning&quot;</span><span class="s0">):(</span><span class="s1">new </span><span class="s0">Error(e).name=</span><span class="s3">&quot;DeprecationWarning&quot;</span><span class="s0">,console.warn(</span><span class="s1">new </span><span class="s0">Error(e)))}</span><span class="s1">return </span><span class="s0">l(e,{start:{column:r=Math.max(r,</span><span class="s2">0</span><span class="s0">),line:t}},i)};</span><span class="s1">var </span><span class="s0">i=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=s();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,i)){</span><span class="s1">var </span><span class="s0">a=n?Object.getOwnPropertyDescriptor(e,i):</span><span class="s1">null</span><span class="s0">;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,i,a):r[i]=e[i]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">7012</span><span class="s0">));</span><span class="s1">function </span><span class="s0">s(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">s=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}let a=!</span><span class="s2">1</span><span class="s0">;const o=/\r\n|[\n\r\u2028\u2029]/;</span><span class="s1">function </span><span class="s0">l(e,t,r={}){const n=(r.highlightCode||r.forceColor)&amp;&amp;(</span><span class="s2">0</span><span class="s0">,i.shouldHighlight)(r),s=(</span><span class="s2">0</span><span class="s0">,i.getChalk)(r),a=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">{gutter:e.grey,marker:e.red.bold,message:e.red.bold}}(s),l=(e,t)=&gt;n?e(t):t,p=e.split(o),{start:c,end:u,markerLines:d}=</span><span class="s1">function</span><span class="s0">(e,t,r){const n=Object.assign({column:</span><span class="s2">0</span><span class="s0">,line:-</span><span class="s2">1</span><span class="s0">},e.start),i=Object.assign({},n,e.end),{linesAbove:s=</span><span class="s2">2</span><span class="s0">,linesBelow:a=</span><span class="s2">3</span><span class="s0">}=r||{},o=n.line,l=n.column,p=i.line,c=i.column;let u=Math.max(o-(s+</span><span class="s2">1</span><span class="s0">),</span><span class="s2">0</span><span class="s0">),d=Math.min(t.length,p+a);-</span><span class="s2">1</span><span class="s0">===o&amp;&amp;(u=</span><span class="s2">0</span><span class="s0">),-</span><span class="s2">1</span><span class="s0">===p&amp;&amp;(d=t.length);const h=p-o,f={};</span><span class="s1">if</span><span class="s0">(h)</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">;e&lt;=h;e++){const r=e+o;</span><span class="s1">if</span><span class="s0">(l)</span><span class="s1">if</span><span class="s0">(</span><span class="s2">0</span><span class="s0">===e){const e=t[r-1].length;f[r]=[l,e-l+</span><span class="s2">1</span><span class="s0">]}</span><span class="s1">else if</span><span class="s0">(e===h)f[r]=[</span><span class="s2">0</span><span class="s0">,c];</span><span class="s1">else</span><span class="s0">{const n=t[r-e].length;f[r]=[</span><span class="s2">0</span><span class="s0">,n]}</span><span class="s1">else </span><span class="s0">f[r]=!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">else </span><span class="s0">f[o]=l===c?!l||[l,</span><span class="s2">0</span><span class="s0">]:[l,c-l];</span><span class="s1">return</span><span class="s0">{start:u,end:d,markerLines:f}}(t,p,r),h=t.start&amp;&amp;</span><span class="s3">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t.start.column,f=String(u).length;let m=(n?(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(e,r):e).split(o).slice(c,u).map(((e,t)=&gt;{const n=c+</span><span class="s2">1</span><span class="s0">+t,i=` ${` ${n}`.slice(-f)} |`,s=d[n],o=!d[n+</span><span class="s2">1</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(s){let t=</span><span class="s3">&quot;&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(Array.isArray(s)){const n=e.slice(</span><span class="s2">0</span><span class="s0">,Math.max(s[</span><span class="s2">0</span><span class="s0">]-</span><span class="s2">1</span><span class="s0">,</span><span class="s2">0</span><span class="s0">)).replace(/[^\t]/g,</span><span class="s3">&quot; &quot;</span><span class="s0">),p=s[</span><span class="s2">1</span><span class="s0">]||</span><span class="s2">1</span><span class="s0">;t=[</span><span class="s3">&quot;</span><span class="s4">\n </span><span class="s3">&quot;</span><span class="s0">,l(a.gutter,i.replace(/\d/g,</span><span class="s3">&quot; &quot;</span><span class="s0">)),</span><span class="s3">&quot; &quot;</span><span class="s0">,n,l(a.marker,</span><span class="s3">&quot;^&quot;</span><span class="s0">).repeat(p)].join(</span><span class="s3">&quot;&quot;</span><span class="s0">),o&amp;&amp;r.message&amp;&amp;(t+=</span><span class="s3">&quot; &quot;</span><span class="s0">+l(a.message,r.message))}</span><span class="s1">return</span><span class="s0">[l(a.marker,</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">),l(a.gutter,i),e.length&gt;</span><span class="s2">0</span><span class="s0">?` ${e}`:</span><span class="s3">&quot;&quot;</span><span class="s0">,t].join(</span><span class="s3">&quot;&quot;</span><span class="s0">)}</span><span class="s1">return</span><span class="s0">` ${l(a.gutter,i)}${e.length&gt;</span><span class="s2">0</span><span class="s0">?` ${e}`:</span><span class="s3">&quot;&quot;</span><span class="s0">}`})).join(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r.message&amp;&amp;!h&amp;&amp;(m=`${</span><span class="s3">&quot; &quot;</span><span class="s0">.repeat(f+</span><span class="s2">1</span><span class="s0">)}${r.message}\n${m}`),n?s.reset(m):m}},</span><span class="s2">6163</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">({node:e,parent:t,scope:r,id:i},a=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(e.id)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!s.isObjectProperty(t)&amp;&amp;!s.isObjectMethod(t,{kind:</span><span class="s3">&quot;method&quot;</span><span class="s0">})||t.computed&amp;&amp;!s.isLiteral(t.key)){</span><span class="s1">if</span><span class="s0">(s.isVariableDeclarator(t)){</span><span class="s1">if</span><span class="s0">(i=t.id,s.isIdentifier(i)&amp;&amp;!a){const t=r.parent.getBinding(i.name);</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.constant&amp;&amp;r.getBinding(i.name)===t)</span><span class="s1">return </span><span class="s0">e.id=s.cloneNode(i),</span><span class="s1">void</span><span class="s0">(e.id[s.NOT_LOCAL_BINDING]=!</span><span class="s2">0</span><span class="s0">)}}</span><span class="s1">else if</span><span class="s0">(s.isAssignmentExpression(t,{operator:</span><span class="s3">&quot;=&quot;</span><span class="s0">}))i=t.left;</span><span class="s1">else if</span><span class="s0">(!i)</span><span class="s1">return</span><span class="s0">}</span><span class="s1">else </span><span class="s0">i=t.key;let o;</span><span class="s1">return </span><span class="s0">i&amp;&amp;s.isLiteral(i)?o=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">s.isNullLiteral(e)?</span><span class="s3">&quot;null&quot;</span><span class="s0">:s.isRegExpLiteral(e)?`_${e.pattern}_${e.flags}`:s.isTemplateLiteral(e)?e.quasis.map((e=&gt;e.value.raw)).join(</span><span class="s3">&quot;&quot;</span><span class="s0">):</span><span class="s1">void </span><span class="s2">0</span><span class="s0">!==e.value?e.value+</span><span class="s3">&quot;&quot;</span><span class="s0">:</span><span class="s3">&quot;&quot;</span><span class="s0">}(i):i&amp;&amp;s.isIdentifier(i)&amp;&amp;(o=i.name),</span><span class="s1">void </span><span class="s2">0</span><span class="s0">!==o?(o=s.toBindingIdentifierName(o),(i=s.identifier(o))[s.NOT_LOCAL_BINDING]=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">if</span><span class="s0">(e.selfReference){</span><span class="s1">if</span><span class="s0">(!i.hasBinding(r.name)||i.hasGlobal(r.name)){</span><span class="s1">if</span><span class="s0">(!s.isFunction(t))</span><span class="s1">return</span><span class="s0">;let e=l;t.generator&amp;&amp;(e=p);const a=e({FUNCTION:t,FUNCTION_ID:r,FUNCTION_KEY:i.generateUidIdentifier(r.name)}).expression,o=a.callee.body.body[</span><span class="s2">0</span><span class="s0">].params;</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">,r=(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(t);e&lt;r;e++)o.push(i.generateUidIdentifier(</span><span class="s3">&quot;x&quot;</span><span class="s0">));</span><span class="s1">return </span><span class="s0">a}i.rename(r.name)}t.id=r,i.getProgramParent().references[r.name]=!</span><span class="s2">0</span><span class="s0">}(</span><span class="s1">function</span><span class="s0">(e,t,r){const n={selfAssignment:!</span><span class="s2">1</span><span class="s0">,selfReference:!</span><span class="s2">1</span><span class="s0">,outerDeclar:r.getBindingIdentifier(t),references:[],name:t},i=r.getOwnBinding(t);</span><span class="s1">return </span><span class="s0">i?</span><span class="s3">&quot;param&quot;</span><span class="s0">===i.kind&amp;&amp;(n.selfReference=!</span><span class="s2">0</span><span class="s0">):(n.outerDeclar||r.hasGlobal(t))&amp;&amp;r.traverse(e,c,n),n}(e,o,r),e,i,r)||e):</span><span class="s1">void </span><span class="s2">0</span><span class="s0">};</span><span class="s1">var </span><span class="s0">n=o(r(</span><span class="s2">2442</span><span class="s0">)),i=o(r(</span><span class="s2">6205</span><span class="s0">)),s=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=a();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,i)){</span><span class="s1">var </span><span class="s0">s=n?Object.getOwnPropertyDescriptor(e,i):</span><span class="s1">null</span><span class="s0">;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">17</span><span class="s0">));</span><span class="s1">function </span><span class="s0">a(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">a=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}</span><span class="s1">function </span><span class="s0">o(e){</span><span class="s1">return </span><span class="s0">e&amp;&amp;e.__esModule?e:{</span><span class="s1">default</span><span class="s0">:e}}const l=(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;</span><span class="s4">\n  </span><span class="s3">(function (FUNCTION_KEY) {</span><span class="s4">\n    </span><span class="s3">function FUNCTION_ID() {</span><span class="s4">\n      </span><span class="s3">return FUNCTION_KEY.apply(this, arguments);</span><span class="s4">\n    </span><span class="s3">}</span><span class="s4">\n\n    </span><span class="s3">FUNCTION_ID.toString = function () {</span><span class="s4">\n      </span><span class="s3">return FUNCTION_KEY.toString();</span><span class="s4">\n    </span><span class="s3">}</span><span class="s4">\n\n    </span><span class="s3">return FUNCTION_ID;</span><span class="s4">\n  </span><span class="s3">})(FUNCTION)</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">),p=(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;</span><span class="s4">\n  </span><span class="s3">(function (FUNCTION_KEY) {</span><span class="s4">\n    </span><span class="s3">function* FUNCTION_ID() {</span><span class="s4">\n      </span><span class="s3">return yield* FUNCTION_KEY.apply(this, arguments);</span><span class="s4">\n    </span><span class="s3">}</span><span class="s4">\n\n    </span><span class="s3">FUNCTION_ID.toString = function () {</span><span class="s4">\n      </span><span class="s3">return FUNCTION_KEY.toString();</span><span class="s4">\n    </span><span class="s3">};</span><span class="s4">\n\n    </span><span class="s3">return FUNCTION_ID;</span><span class="s4">\n  </span><span class="s3">})(FUNCTION)</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">),c={</span><span class="s3">&quot;ReferencedIdentifier|BindingIdentifier&quot;</span><span class="s0">(e,t){e.node.name===t.name&amp;&amp;e.scope.getBindingIdentifier(t.name)===t.outerDeclar&amp;&amp;(t.selfReference=!</span><span class="s2">0</span><span class="s0">,e.stop())}}},</span><span class="s2">2442</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){const t=e.params;</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">;e&lt;t.length;e++){const r=t[e];</span><span class="s1">if</span><span class="s0">(n.isAssignmentPattern(r)||n.isRestElement(r))</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">return </span><span class="s0">t.length};</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=i();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">s </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,s)){</span><span class="s1">var </span><span class="s0">a=n?Object.getOwnPropertyDescriptor(e,s):</span><span class="s1">null</span><span class="s0">;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">17</span><span class="s0">));</span><span class="s1">function </span><span class="s0">i(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">i=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}},</span><span class="s2">7224</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(!e.isExportDeclaration())</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Only export declarations can be split.&quot;</span><span class="s0">);const t=e.isExportDefaultDeclaration(),r=e.get(</span><span class="s3">&quot;declaration&quot;</span><span class="s0">),i=r.isClassDeclaration();</span><span class="s1">if</span><span class="s0">(t){const t=r.isFunctionDeclaration()||i,s=r.isScope()?r.scope.parent:r.scope;let a=r.node.id,o=!</span><span class="s2">1</span><span class="s0">;a||(o=!</span><span class="s2">0</span><span class="s0">,a=s.generateUidIdentifier(</span><span class="s3">&quot;default&quot;</span><span class="s0">),(t||r.isFunctionExpression()||r.isClassExpression())&amp;&amp;(r.node.id=n.cloneNode(a)));const l=t?r:n.variableDeclaration(</span><span class="s3">&quot;var&quot;</span><span class="s0">,[n.variableDeclarator(n.cloneNode(a),r.node)]),p=n.exportNamedDeclaration(</span><span class="s1">null</span><span class="s0">,[n.exportSpecifier(n.cloneNode(a),n.identifier(</span><span class="s3">&quot;default&quot;</span><span class="s0">))]);</span><span class="s1">return </span><span class="s0">e.insertAfter(p),e.replaceWith(l),o&amp;&amp;s.registerDeclaration(e),e}</span><span class="s1">if</span><span class="s0">(e.get(</span><span class="s3">&quot;specifiers&quot;</span><span class="s0">).length&gt;</span><span class="s2">0</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;It doesn't make sense to split exported specifiers.&quot;</span><span class="s0">);const s=r.getOuterBindingIdentifiers(),a=Object.keys(s).map((e=&gt;n.exportSpecifier(n.identifier(e),n.identifier(e)))),o=n.exportNamedDeclaration(</span><span class="s1">null</span><span class="s0">,a);</span><span class="s1">return </span><span class="s0">e.insertAfter(o),e.replaceWith(r.node),e};</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=i();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">s </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,s)){</span><span class="s1">var </span><span class="s0">a=n?Object.getOwnPropertyDescriptor(e,s):</span><span class="s1">null</span><span class="s0">;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">17</span><span class="s0">));</span><span class="s1">function </span><span class="s0">i(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">i=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}},</span><span class="s2">9104</span><span class="s0">:(e,t)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.isIdentifierStart=p,t.isIdentifierChar=c,t.isIdentifierName=</span><span class="s1">function</span><span class="s0">(e){let t=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s2">0</span><span class="s0">;r&lt;e.length;r++){let n=e.charCodeAt(r);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">55296</span><span class="s0">==(</span><span class="s2">64512</span><span class="s0">&amp;n)&amp;&amp;r+</span><span class="s2">1</span><span class="s0">&lt;e.length){const t=e.charCodeAt(++r);</span><span class="s2">56320</span><span class="s0">==(</span><span class="s2">64512</span><span class="s0">&amp;t)&amp;&amp;(n=</span><span class="s2">65536</span><span class="s0">+((</span><span class="s2">1023</span><span class="s0">&amp;n)&lt;&lt;</span><span class="s2">10</span><span class="s0">)+(</span><span class="s2">1023</span><span class="s0">&amp;t))}</span><span class="s1">if</span><span class="s0">(t){</span><span class="s1">if</span><span class="s0">(t=!</span><span class="s2">1</span><span class="s0">,!p(n))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(!c(n))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!t};let r=</span><span class="s3">&quot;ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-ꟊꟵ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ&quot;</span><span class="s0">,n=</span><span class="s3">&quot;‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿᫀᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿&quot;</span><span class="s0">;const i=</span><span class="s1">new </span><span class="s0">RegExp(</span><span class="s3">&quot;[&quot;</span><span class="s0">+r+</span><span class="s3">&quot;]&quot;</span><span class="s0">),s=</span><span class="s1">new </span><span class="s0">RegExp(</span><span class="s3">&quot;[&quot;</span><span class="s0">+r+n+</span><span class="s3">&quot;]&quot;</span><span class="s0">);r=n=</span><span class="s1">null</span><span class="s0">;const a=[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">25</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">122</span><span class="s0">,</span><span class="s2">70</span><span class="s0">,</span><span class="s2">52</span><span class="s0">,</span><span class="s2">268</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">48</span><span class="s0">,</span><span class="s2">48</span><span class="s0">,</span><span class="s2">31</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">37</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">157</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">39</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">51</span><span class="s0">,</span><span class="s2">157</span><span class="s0">,</span><span class="s2">310</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">153</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">66</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">25</span><span class="s0">,</span><span class="s2">71</span><span class="s0">,</span><span class="s2">55</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">65</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">36</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">27</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">53</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">111</span><span class="s0">,</span><span class="s2">72</span><span class="s0">,</span><span class="s2">56</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">349</span><span class="s0">,</span><span class="s2">41</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">79</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">107</span><span class="s0">,</span><span class="s2">20</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">52</span><span class="s0">,</span><span class="s2">76</span><span class="s0">,</span><span class="s2">44</span><span class="s0">,</span><span class="s2">33</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">27</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">34</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">36</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">85</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">46</span><span class="s0">,</span><span class="s2">39</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">159</span><span class="s0">,</span><span class="s2">52</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">31</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">185</span><span class="s0">,</span><span class="s2">46</span><span class="s0">,</span><span class="s2">42</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">37</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">60</span><span class="s0">,</span><span class="s2">42</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">72</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">230</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">117</span><span class="s0">,</span><span class="s2">63</span><span class="s0">,</span><span class="s2">32</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">23</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">95</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">38</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">39</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">45</span><span class="s0">,</span><span class="s2">20</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">56</span><span class="s0">,</span><span class="s2">264</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">36</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">113</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">37</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">31</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">328</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">190</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">80</span><span class="s0">,</span><span class="s2">921</span><span class="s0">,</span><span class="s2">103</span><span class="s0">,</span><span class="s2">110</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">195</span><span class="s0">,</span><span class="s2">2749</span><span class="s0">,</span><span class="s2">1070</span><span class="s0">,</span><span class="s2">4050</span><span class="s0">,</span><span class="s2">582</span><span class="s0">,</span><span class="s2">8634</span><span class="s0">,</span><span class="s2">568</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">114</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">32</span><span class="s0">,</span><span class="s2">20</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">689</span><span class="s0">,</span><span class="s2">63</span><span class="s0">,</span><span class="s2">129</span><span class="s0">,</span><span class="s2">74</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">67</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">65</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">6135</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">1237</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">8952</span><span class="s0">,</span><span class="s2">286</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">395</span><span class="s0">,</span><span class="s2">2309</span><span class="s0">,</span><span class="s2">106</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">5991</span><span class="s0">,</span><span class="s2">84</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">70</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">64</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">27</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">339</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2357</span><span class="s0">,</span><span class="s2">44</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">370</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">1301</span><span class="s0">,</span><span class="s2">196</span><span class="s0">,</span><span class="s2">60</span><span class="s0">,</span><span class="s2">67</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1205</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">4421</span><span class="s0">,</span><span class="s2">42717</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">4148</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">221</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">5761</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">7472</span><span class="s0">,</span><span class="s2">3104</span><span class="s0">,</span><span class="s2">541</span><span class="s0">,</span><span class="s2">1507</span><span class="s0">,</span><span class="s2">4938</span><span class="s0">],o=[</span><span class="s2">509</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">227</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">150</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">294</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">1368</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">41</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">166</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">574</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">370</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">154</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">176</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">32</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">46</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">37</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">45</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">49</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">83</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">161</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">56</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">193</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">82</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">214</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">83</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">82</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">84</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">243</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">166</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">71</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">120</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">41</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">406</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">57</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">123</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">49</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">330</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">19306</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">135</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">60</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">1014</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">82</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">19628</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">5319</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">31</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">149</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1418</span><span class="s0">,</span><span class="s2">49</span><span class="s0">,</span><span class="s2">513</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">49</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">23</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">1361</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">262</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">419</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">1495</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">110</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">4759</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">787719</span><span class="s0">,</span><span class="s2">239</span><span class="s0">];</span><span class="s1">function </span><span class="s0">l(e,t){let r=</span><span class="s2">65536</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let n=</span><span class="s2">0</span><span class="s0">,i=t.length;n&lt;i;n+=</span><span class="s2">2</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(r+=t[n],r&gt;e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(r+=t[n+</span><span class="s2">1</span><span class="s0">],r&gt;=e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}</span><span class="s1">function </span><span class="s0">p(e){</span><span class="s1">return </span><span class="s0">e&lt;</span><span class="s2">65</span><span class="s0">?</span><span class="s2">36</span><span class="s0">===e:e&lt;=</span><span class="s2">90</span><span class="s0">||(e&lt;</span><span class="s2">97</span><span class="s0">?</span><span class="s2">95</span><span class="s0">===e:e&lt;=</span><span class="s2">122</span><span class="s0">||(e&lt;=</span><span class="s2">65535</span><span class="s0">?e&gt;=</span><span class="s2">170</span><span class="s0">&amp;&amp;i.test(String.fromCharCode(e)):l(e,a)))}</span><span class="s1">function </span><span class="s0">c(e){</span><span class="s1">return </span><span class="s0">e&lt;</span><span class="s2">48</span><span class="s0">?</span><span class="s2">36</span><span class="s0">===e:e&lt;</span><span class="s2">58</span><span class="s0">||!(e&lt;</span><span class="s2">65</span><span class="s0">)&amp;&amp;(e&lt;=</span><span class="s2">90</span><span class="s0">||(e&lt;</span><span class="s2">97</span><span class="s0">?</span><span class="s2">95</span><span class="s0">===e:e&lt;=</span><span class="s2">122</span><span class="s0">||(e&lt;=</span><span class="s2">65535</span><span class="s0">?e&gt;=</span><span class="s2">170</span><span class="s0">&amp;&amp;s.test(String.fromCharCode(e)):l(e,a)||l(e,o))))}},</span><span class="s2">7075</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),Object.defineProperty(t,</span><span class="s3">&quot;isIdentifierName&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.isIdentifierName}}),Object.defineProperty(t,</span><span class="s3">&quot;isIdentifierChar&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.isIdentifierChar}}),Object.defineProperty(t,</span><span class="s3">&quot;isIdentifierStart&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.isIdentifierStart}}),Object.defineProperty(t,</span><span class="s3">&quot;isReservedWord&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.isReservedWord}}),Object.defineProperty(t,</span><span class="s3">&quot;isStrictBindOnlyReservedWord&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.isStrictBindOnlyReservedWord}}),Object.defineProperty(t,</span><span class="s3">&quot;isStrictBindReservedWord&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.isStrictBindReservedWord}}),Object.defineProperty(t,</span><span class="s3">&quot;isStrictReservedWord&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.isStrictReservedWord}}),Object.defineProperty(t,</span><span class="s3">&quot;isKeyword&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.isKeyword}});</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">9104</span><span class="s0">),i=r(</span><span class="s2">4400</span><span class="s0">)},</span><span class="s2">4400</span><span class="s0">:(e,t)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.isReservedWord=s,t.isStrictReservedWord=a,t.isStrictBindOnlyReservedWord=o,t.isStrictBindReservedWord=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">a(e,t)||o(e)},t.isKeyword=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">r.has(e)};const r=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">&quot;break&quot;</span><span class="s0">,</span><span class="s3">&quot;case&quot;</span><span class="s0">,</span><span class="s3">&quot;catch&quot;</span><span class="s0">,</span><span class="s3">&quot;continue&quot;</span><span class="s0">,</span><span class="s3">&quot;debugger&quot;</span><span class="s0">,</span><span class="s3">&quot;default&quot;</span><span class="s0">,</span><span class="s3">&quot;do&quot;</span><span class="s0">,</span><span class="s3">&quot;else&quot;</span><span class="s0">,</span><span class="s3">&quot;finally&quot;</span><span class="s0">,</span><span class="s3">&quot;for&quot;</span><span class="s0">,</span><span class="s3">&quot;function&quot;</span><span class="s0">,</span><span class="s3">&quot;if&quot;</span><span class="s0">,</span><span class="s3">&quot;return&quot;</span><span class="s0">,</span><span class="s3">&quot;switch&quot;</span><span class="s0">,</span><span class="s3">&quot;throw&quot;</span><span class="s0">,</span><span class="s3">&quot;try&quot;</span><span class="s0">,</span><span class="s3">&quot;var&quot;</span><span class="s0">,</span><span class="s3">&quot;const&quot;</span><span class="s0">,</span><span class="s3">&quot;while&quot;</span><span class="s0">,</span><span class="s3">&quot;with&quot;</span><span class="s0">,</span><span class="s3">&quot;new&quot;</span><span class="s0">,</span><span class="s3">&quot;this&quot;</span><span class="s0">,</span><span class="s3">&quot;super&quot;</span><span class="s0">,</span><span class="s3">&quot;class&quot;</span><span class="s0">,</span><span class="s3">&quot;extends&quot;</span><span class="s0">,</span><span class="s3">&quot;export&quot;</span><span class="s0">,</span><span class="s3">&quot;import&quot;</span><span class="s0">,</span><span class="s3">&quot;null&quot;</span><span class="s0">,</span><span class="s3">&quot;true&quot;</span><span class="s0">,</span><span class="s3">&quot;false&quot;</span><span class="s0">,</span><span class="s3">&quot;in&quot;</span><span class="s0">,</span><span class="s3">&quot;instanceof&quot;</span><span class="s0">,</span><span class="s3">&quot;typeof&quot;</span><span class="s0">,</span><span class="s3">&quot;void&quot;</span><span class="s0">,</span><span class="s3">&quot;delete&quot;</span><span class="s0">]),n=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">&quot;implements&quot;</span><span class="s0">,</span><span class="s3">&quot;interface&quot;</span><span class="s0">,</span><span class="s3">&quot;let&quot;</span><span class="s0">,</span><span class="s3">&quot;package&quot;</span><span class="s0">,</span><span class="s3">&quot;private&quot;</span><span class="s0">,</span><span class="s3">&quot;protected&quot;</span><span class="s0">,</span><span class="s3">&quot;public&quot;</span><span class="s0">,</span><span class="s3">&quot;static&quot;</span><span class="s0">,</span><span class="s3">&quot;yield&quot;</span><span class="s0">]),i=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">&quot;eval&quot;</span><span class="s0">,</span><span class="s3">&quot;arguments&quot;</span><span class="s0">]);</span><span class="s1">function </span><span class="s0">s(e,t){</span><span class="s1">return </span><span class="s0">t&amp;&amp;</span><span class="s3">&quot;await&quot;</span><span class="s0">===e||</span><span class="s3">&quot;enum&quot;</span><span class="s0">===e}</span><span class="s1">function </span><span class="s0">a(e,t){</span><span class="s1">return </span><span class="s0">s(e,t)||n.has(e)}</span><span class="s1">function </span><span class="s0">o(e){</span><span class="s1">return </span><span class="s0">i.has(e)}},</span><span class="s2">7012</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.shouldHighlight=c,t.getChalk=u,t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t={}){</span><span class="s1">if</span><span class="s0">(c(t)){</span><span class="s1">return function</span><span class="s0">(e,t){let r=</span><span class="s3">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const{type:n,value:i}of p(t)){const t=e[n];r+=t?i.split(o).map((e=&gt;t(e))).join(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">):i}</span><span class="s1">return </span><span class="s0">r}({keyword:(r=u(t)).cyan,capitalized:r.yellow,jsxIdentifier:r.yellow,punctuator:r.yellow,number:r.magenta,string:r.green,regex:r.magenta,comment:r.grey,invalid:r.white.bgRed.bold},e)}</span><span class="s1">var </span><span class="s0">r;</span><span class="s1">return </span><span class="s0">e};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">7075</span><span class="s0">);const i=r(</span><span class="s2">8631</span><span class="s0">),s=r(</span><span class="s2">1859</span><span class="s0">),a=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">&quot;as&quot;</span><span class="s0">,</span><span class="s3">&quot;async&quot;</span><span class="s0">,</span><span class="s3">&quot;from&quot;</span><span class="s0">,</span><span class="s3">&quot;get&quot;</span><span class="s0">,</span><span class="s3">&quot;of&quot;</span><span class="s0">,</span><span class="s3">&quot;set&quot;</span><span class="s0">]),o=/\r\n|[\n\r\u2028\u2029]/,l=/^[()[\]{}]$/;let p;{const e=/^[a-z][\w-]*$/i,t=</span><span class="s1">function</span><span class="s0">(t,r,i){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;name&quot;</span><span class="s0">===t.type){</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isKeyword)(t.value)||(</span><span class="s2">0</span><span class="s0">,n.isStrictReservedWord)(t.value,!</span><span class="s2">0</span><span class="s0">)||a.has(t.value))</span><span class="s1">return</span><span class="s3">&quot;keyword&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e.test(t.value)&amp;&amp;(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">===i[r-1]||</span><span class="s3">&quot;&lt;/&quot;</span><span class="s0">==i.substr(r-2,</span><span class="s2">2</span><span class="s0">)))</span><span class="s1">return</span><span class="s3">&quot;jsxIdentifier&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(t.value[</span><span class="s2">0</span><span class="s0">]!==t.value[</span><span class="s2">0</span><span class="s0">].toLowerCase())</span><span class="s1">return</span><span class="s3">&quot;capitalized&quot;</span><span class="s0">}</span><span class="s1">return</span><span class="s3">&quot;punctuator&quot;</span><span class="s0">===t.type&amp;&amp;l.test(t.value)?</span><span class="s3">&quot;bracket&quot;</span><span class="s0">:</span><span class="s3">&quot;invalid&quot;</span><span class="s0">!==t.type||</span><span class="s3">&quot;@&quot;</span><span class="s0">!==t.value&amp;&amp;</span><span class="s3">&quot;#&quot;</span><span class="s0">!==t.value?t.type:</span><span class="s3">&quot;punctuator&quot;</span><span class="s0">};p=</span><span class="s1">function</span><span class="s0">*(e){let r;</span><span class="s1">for</span><span class="s0">(;r=i.</span><span class="s1">default</span><span class="s0">.exec(e);){const n=i.matchToToken(r);yield{type:t(n,r.index,e),value:n.value}}}}</span><span class="s1">function </span><span class="s0">c(e){</span><span class="s1">return</span><span class="s0">!!s.supportsColor||e.forceColor}</span><span class="s1">function </span><span class="s0">u(e){</span><span class="s1">return </span><span class="s0">e.forceColor?</span><span class="s1">new </span><span class="s0">s.constructor({enabled:!</span><span class="s2">0</span><span class="s0">,level:</span><span class="s2">1</span><span class="s0">}):s}},</span><span class="s2">5332</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;e=r.nmd(e);const n=r(</span><span class="s2">5536</span><span class="s0">),i=(e,t)=&gt;</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">`[${e.apply(n,arguments)+t}m`},s=(e,t)=&gt;</span><span class="s1">function</span><span class="s0">(){const r=e.apply(n,arguments);</span><span class="s1">return</span><span class="s0">`[${</span><span class="s2">38</span><span class="s0">+t};</span><span class="s2">5</span><span class="s0">;${r}m`},a=(e,t)=&gt;</span><span class="s1">function</span><span class="s0">(){const r=e.apply(n,arguments);</span><span class="s1">return</span><span class="s0">`[${</span><span class="s2">38</span><span class="s0">+t};</span><span class="s2">2</span><span class="s0">;${r[</span><span class="s2">0</span><span class="s0">]};${r[</span><span class="s2">1</span><span class="s0">]};${r[</span><span class="s2">2</span><span class="s0">]}m`};Object.defineProperty(e,</span><span class="s3">&quot;exports&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){const e=</span><span class="s1">new </span><span class="s0">Map,t={modifier:{reset:[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">],bold:[</span><span class="s2">1</span><span class="s0">,</span><span class="s2">22</span><span class="s0">],dim:[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">22</span><span class="s0">],italic:[</span><span class="s2">3</span><span class="s0">,</span><span class="s2">23</span><span class="s0">],underline:[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">24</span><span class="s0">],inverse:[</span><span class="s2">7</span><span class="s0">,</span><span class="s2">27</span><span class="s0">],hidden:[</span><span class="s2">8</span><span class="s0">,</span><span class="s2">28</span><span class="s0">],strikethrough:[</span><span class="s2">9</span><span class="s0">,</span><span class="s2">29</span><span class="s0">]},color:{black:[</span><span class="s2">30</span><span class="s0">,</span><span class="s2">39</span><span class="s0">],red:[</span><span class="s2">31</span><span class="s0">,</span><span class="s2">39</span><span class="s0">],green:[</span><span class="s2">32</span><span class="s0">,</span><span class="s2">39</span><span class="s0">],yellow:[</span><span class="s2">33</span><span class="s0">,</span><span class="s2">39</span><span class="s0">],blue:[</span><span class="s2">34</span><span class="s0">,</span><span class="s2">39</span><span class="s0">],magenta:[</span><span class="s2">35</span><span class="s0">,</span><span class="s2">39</span><span class="s0">],cyan:[</span><span class="s2">36</span><span class="s0">,</span><span class="s2">39</span><span class="s0">],white:[</span><span class="s2">37</span><span class="s0">,</span><span class="s2">39</span><span class="s0">],gray:[</span><span class="s2">90</span><span class="s0">,</span><span class="s2">39</span><span class="s0">],redBright:[</span><span class="s2">91</span><span class="s0">,</span><span class="s2">39</span><span class="s0">],greenBright:[</span><span class="s2">92</span><span class="s0">,</span><span class="s2">39</span><span class="s0">],yellowBright:[</span><span class="s2">93</span><span class="s0">,</span><span class="s2">39</span><span class="s0">],blueBright:[</span><span class="s2">94</span><span class="s0">,</span><span class="s2">39</span><span class="s0">],magentaBright:[</span><span class="s2">95</span><span class="s0">,</span><span class="s2">39</span><span class="s0">],cyanBright:[</span><span class="s2">96</span><span class="s0">,</span><span class="s2">39</span><span class="s0">],whiteBright:[</span><span class="s2">97</span><span class="s0">,</span><span class="s2">39</span><span class="s0">]},bgColor:{bgBlack:[</span><span class="s2">40</span><span class="s0">,</span><span class="s2">49</span><span class="s0">],bgRed:[</span><span class="s2">41</span><span class="s0">,</span><span class="s2">49</span><span class="s0">],bgGreen:[</span><span class="s2">42</span><span class="s0">,</span><span class="s2">49</span><span class="s0">],bgYellow:[</span><span class="s2">43</span><span class="s0">,</span><span class="s2">49</span><span class="s0">],bgBlue:[</span><span class="s2">44</span><span class="s0">,</span><span class="s2">49</span><span class="s0">],bgMagenta:[</span><span class="s2">45</span><span class="s0">,</span><span class="s2">49</span><span class="s0">],bgCyan:[</span><span class="s2">46</span><span class="s0">,</span><span class="s2">49</span><span class="s0">],bgWhite:[</span><span class="s2">47</span><span class="s0">,</span><span class="s2">49</span><span class="s0">],bgBlackBright:[</span><span class="s2">100</span><span class="s0">,</span><span class="s2">49</span><span class="s0">],bgRedBright:[</span><span class="s2">101</span><span class="s0">,</span><span class="s2">49</span><span class="s0">],bgGreenBright:[</span><span class="s2">102</span><span class="s0">,</span><span class="s2">49</span><span class="s0">],bgYellowBright:[</span><span class="s2">103</span><span class="s0">,</span><span class="s2">49</span><span class="s0">],bgBlueBright:[</span><span class="s2">104</span><span class="s0">,</span><span class="s2">49</span><span class="s0">],bgMagentaBright:[</span><span class="s2">105</span><span class="s0">,</span><span class="s2">49</span><span class="s0">],bgCyanBright:[</span><span class="s2">106</span><span class="s0">,</span><span class="s2">49</span><span class="s0">],bgWhiteBright:[</span><span class="s2">107</span><span class="s0">,</span><span class="s2">49</span><span class="s0">]}};t.color.grey=t.color.gray;</span><span class="s1">for</span><span class="s0">(const r of Object.keys(t)){const n=t[r];</span><span class="s1">for</span><span class="s0">(const r of Object.keys(n)){const i=n[r];t[r]={open:`[${i[</span><span class="s2">0</span><span class="s0">]}m`,close:`[${i[</span><span class="s2">1</span><span class="s0">]}m`},n[r]=t[r],e.set(i[</span><span class="s2">0</span><span class="s0">],i[</span><span class="s2">1</span><span class="s0">])}Object.defineProperty(t,r,{value:n,enumerable:!</span><span class="s2">1</span><span class="s0">}),Object.defineProperty(t,</span><span class="s3">&quot;codes&quot;</span><span class="s0">,{value:e,enumerable:!</span><span class="s2">1</span><span class="s0">})}const r=e=&gt;e,o=(e,t,r)=&gt;[e,t,r];t.color.close=</span><span class="s3">&quot;[39m&quot;</span><span class="s0">,t.bgColor.close=</span><span class="s3">&quot;[49m&quot;</span><span class="s0">,t.color.ansi={ansi:i(r,</span><span class="s2">0</span><span class="s0">)},t.color.ansi256={ansi256:s(r,</span><span class="s2">0</span><span class="s0">)},t.color.ansi16m={rgb:a(o,</span><span class="s2">0</span><span class="s0">)},t.bgColor.ansi={ansi:i(r,</span><span class="s2">10</span><span class="s0">)},t.bgColor.ansi256={ansi256:s(r,</span><span class="s2">10</span><span class="s0">)},t.bgColor.ansi16m={rgb:a(o,</span><span class="s2">10</span><span class="s0">)};</span><span class="s1">for</span><span class="s0">(let e of Object.keys(n)){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">n[e])</span><span class="s1">continue</span><span class="s0">;const r=n[e];</span><span class="s3">&quot;ansi16&quot;</span><span class="s0">===e&amp;&amp;(e=</span><span class="s3">&quot;ansi&quot;</span><span class="s0">),</span><span class="s3">&quot;ansi16&quot;</span><span class="s1">in </span><span class="s0">r&amp;&amp;(t.color.ansi[e]=i(r.ansi16,</span><span class="s2">0</span><span class="s0">),t.bgColor.ansi[e]=i(r.ansi16,</span><span class="s2">10</span><span class="s0">)),</span><span class="s3">&quot;ansi256&quot;</span><span class="s1">in </span><span class="s0">r&amp;&amp;(t.color.ansi256[e]=s(r.ansi256,</span><span class="s2">0</span><span class="s0">),t.bgColor.ansi256[e]=s(r.ansi256,</span><span class="s2">10</span><span class="s0">)),</span><span class="s3">&quot;rgb&quot;</span><span class="s1">in </span><span class="s0">r&amp;&amp;(t.color.ansi16m[e]=a(r.rgb,</span><span class="s2">0</span><span class="s0">),t.bgColor.ansi16m[e]=a(r.rgb,</span><span class="s2">10</span><span class="s0">))}</span><span class="s1">return </span><span class="s0">t}})},</span><span class="s2">1859</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">397</span><span class="s0">);const i=r(</span><span class="s2">1014</span><span class="s0">),s=r(</span><span class="s2">5332</span><span class="s0">),a=r(</span><span class="s2">3182</span><span class="s0">).stdout,o=r(</span><span class="s2">6805</span><span class="s0">),l=</span><span class="s3">&quot;win32&quot;</span><span class="s0">===n.platform&amp;&amp;!(n.env.TERM||</span><span class="s3">&quot;&quot;</span><span class="s0">).toLowerCase().startsWith(</span><span class="s3">&quot;xterm&quot;</span><span class="s0">),p=[</span><span class="s3">&quot;ansi&quot;</span><span class="s0">,</span><span class="s3">&quot;ansi&quot;</span><span class="s0">,</span><span class="s3">&quot;ansi256&quot;</span><span class="s0">,</span><span class="s3">&quot;ansi16m&quot;</span><span class="s0">],c=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">&quot;gray&quot;</span><span class="s0">]),u=Object.create(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">function </span><span class="s0">d(e,t){t=t||{};const r=a?a.level:</span><span class="s2">0</span><span class="s0">;e.level=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t.level?r:t.level,e.enabled=</span><span class="s3">&quot;enabled&quot;</span><span class="s1">in </span><span class="s0">t?t.enabled:e.level&gt;</span><span class="s2">0</span><span class="s0">}</span><span class="s1">function </span><span class="s0">h(e){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">||!(</span><span class="s1">this instanceof </span><span class="s0">h)||</span><span class="s1">this</span><span class="s0">.template){const t={};</span><span class="s1">return </span><span class="s0">d(t,e),t.template=</span><span class="s1">function</span><span class="s0">(){const e=[].slice.call(arguments);</span><span class="s1">return </span><span class="s0">T.apply(</span><span class="s1">null</span><span class="s0">,[t.template].concat(e))},Object.setPrototypeOf(t,h.prototype),Object.setPrototypeOf(t.template,t),t.template.constructor=h,t.template}d(</span><span class="s1">this</span><span class="s0">,e)}l&amp;&amp;(s.blue.open=</span><span class="s3">&quot;[94m&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const e of Object.keys(s))s[e].closeRe=</span><span class="s1">new </span><span class="s0">RegExp(i(s[e].close),</span><span class="s3">&quot;g&quot;</span><span class="s0">),u[e]={get(){const t=s[e];</span><span class="s1">return </span><span class="s0">m.call(</span><span class="s1">this</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._styles?</span><span class="s1">this</span><span class="s0">._styles.concat(t):[t],</span><span class="s1">this</span><span class="s0">._empty,e)}};u.visible={get(){</span><span class="s1">return </span><span class="s0">m.call(</span><span class="s1">this</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._styles||[],!</span><span class="s2">0</span><span class="s0">,</span><span class="s3">&quot;visible&quot;</span><span class="s0">)}},s.color.closeRe=</span><span class="s1">new </span><span class="s0">RegExp(i(s.color.close),</span><span class="s3">&quot;g&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const e of Object.keys(s.color.ansi))c.has(e)||(u[e]={get(){const t=</span><span class="s1">this</span><span class="s0">.level;</span><span class="s1">return function</span><span class="s0">(){const r={open:s.color[p[t]][e].apply(</span><span class="s1">null</span><span class="s0">,arguments),close:s.color.close,closeRe:s.color.closeRe};</span><span class="s1">return </span><span class="s0">m.call(</span><span class="s1">this</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._styles?</span><span class="s1">this</span><span class="s0">._styles.concat(r):[r],</span><span class="s1">this</span><span class="s0">._empty,e)}}});s.bgColor.closeRe=</span><span class="s1">new </span><span class="s0">RegExp(i(s.bgColor.close),</span><span class="s3">&quot;g&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const e of Object.keys(s.bgColor.ansi))c.has(e)||(u[</span><span class="s3">&quot;bg&quot;</span><span class="s0">+e[</span><span class="s2">0</span><span class="s0">].toUpperCase()+e.slice(</span><span class="s2">1</span><span class="s0">)]={get(){const t=</span><span class="s1">this</span><span class="s0">.level;</span><span class="s1">return function</span><span class="s0">(){const r={open:s.bgColor[p[t]][e].apply(</span><span class="s1">null</span><span class="s0">,arguments),close:s.bgColor.close,closeRe:s.bgColor.closeRe};</span><span class="s1">return </span><span class="s0">m.call(</span><span class="s1">this</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._styles?</span><span class="s1">this</span><span class="s0">._styles.concat(r):[r],</span><span class="s1">this</span><span class="s0">._empty,e)}}});const f=Object.defineProperties((()=&gt;{}),u);</span><span class="s1">function </span><span class="s0">m(e,t,r){const n=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">y.apply(n,arguments)};n._styles=e,n._empty=t;const i=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">return </span><span class="s0">Object.defineProperty(n,</span><span class="s3">&quot;level&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:()=&gt;i.level,set(e){i.level=e}}),Object.defineProperty(n,</span><span class="s3">&quot;enabled&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:()=&gt;i.enabled,set(e){i.enabled=e}}),n.hasGrey=</span><span class="s1">this</span><span class="s0">.hasGrey||</span><span class="s3">&quot;gray&quot;</span><span class="s0">===r||</span><span class="s3">&quot;grey&quot;</span><span class="s0">===r,n.__proto__=f,n}</span><span class="s1">function </span><span class="s0">y(){const e=arguments,t=e.length;let r=String(arguments[</span><span class="s2">0</span><span class="s0">]);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">0</span><span class="s0">===t)</span><span class="s1">return</span><span class="s3">&quot;&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(t&gt;</span><span class="s2">1</span><span class="s0">)</span><span class="s1">for</span><span class="s0">(let n=</span><span class="s2">1</span><span class="s0">;n&lt;t;n++)r+=</span><span class="s3">&quot; &quot;</span><span class="s0">+e[n];</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.enabled||</span><span class="s1">this</span><span class="s0">.level&lt;=</span><span class="s2">0</span><span class="s0">||!r)</span><span class="s1">return this</span><span class="s0">._empty?</span><span class="s3">&quot;&quot;</span><span class="s0">:r;const n=s.dim.open;l&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasGrey&amp;&amp;(s.dim.open=</span><span class="s3">&quot;&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const e of </span><span class="s1">this</span><span class="s0">._styles.slice().reverse())r=e.open+r.replace(e.closeRe,e.open)+e.close,r=r.replace(/\r?\n/g,`${e.close}$&amp;${e.open}`);</span><span class="s1">return </span><span class="s0">s.dim.open=n,r}</span><span class="s1">function </span><span class="s0">T(e,t){</span><span class="s1">if</span><span class="s0">(!Array.isArray(t))</span><span class="s1">return</span><span class="s0">[].slice.call(arguments,</span><span class="s2">1</span><span class="s0">).join(</span><span class="s3">&quot; &quot;</span><span class="s0">);const r=[].slice.call(arguments,</span><span class="s2">2</span><span class="s0">),n=[t.raw[</span><span class="s2">0</span><span class="s0">]];</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">1</span><span class="s0">;e&lt;t.length;e++)n.push(String(r[e-1]).replace(/[{}\\]/g,</span><span class="s3">&quot;</span><span class="s4">\\</span><span class="s3">$&amp;&quot;</span><span class="s0">)),n.push(String(t.raw[e]));</span><span class="s1">return </span><span class="s0">o(e,n.join(</span><span class="s3">&quot;&quot;</span><span class="s0">))}Object.defineProperties(h.prototype,u),e.exports=h(),e.exports.supportsColor=a,e.exports.</span><span class="s1">default</span><span class="s0">=e.exports},</span><span class="s2">6805</span><span class="s0">:e=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;const t=/(?:\\(u[a-f\d]{</span><span class="s2">4</span><span class="s0">}|x[a-f\d]{</span><span class="s2">2</span><span class="s0">}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,r=/(?:^|\.)(\w+)(?:\(([^)]*)\))?/g,n=/^([</span><span class="s3">'&quot;])((?:</span><span class="s4">\\</span><span class="s3">.|(?!</span><span class="s4">\1</span><span class="s3">)[^</span><span class="s4">\\</span><span class="s3">])*)</span><span class="s4">\1</span><span class="s3">$/,i=/</span><span class="s4">\\</span><span class="s3">(u[a-f</span><span class="s5">\d</span><span class="s3">]{4}|x[a-f</span><span class="s5">\d</span><span class="s3">]{2}|.)|([^</span><span class="s4">\\</span><span class="s3">])/gi,s=new Map([[&quot;n&quot;,&quot;</span><span class="s4">\n</span><span class="s3">&quot;],[&quot;r&quot;,&quot;</span><span class="s4">\r</span><span class="s3">&quot;],[&quot;t&quot;,&quot;</span><span class="s4">\t</span><span class="s3">&quot;],[&quot;b&quot;,&quot;</span><span class="s4">\b</span><span class="s3">&quot;],[&quot;f&quot;,&quot;</span><span class="s4">\f</span><span class="s3">&quot;],[&quot;v&quot;,&quot;</span><span class="s5">\v</span><span class="s3">&quot;],[&quot;0&quot;,&quot;</span><span class="s4">\0</span><span class="s3">&quot;],[&quot;</span><span class="s4">\\</span><span class="s3">&quot;,&quot;</span><span class="s4">\\</span><span class="s3">&quot;],[&quot;e&quot;,&quot;&quot;],[&quot;a&quot;,&quot;&quot;]]);function a(e){return&quot;u&quot;===e[0]&amp;&amp;5===e.length||&quot;x&quot;===e[0]&amp;&amp;3===e.length?String.fromCharCode(parseInt(e.slice(1),16)):s.get(e)||e}function o(e,t){const r=[],s=t.trim().split(/</span><span class="s5">\s</span><span class="s3">*,</span><span class="s5">\s</span><span class="s3">*/g);let o;for(const t of s)if(isNaN(t)){if(!(o=t.match(n)))throw new Error(`Invalid Chalk template style argument: ${t} (in style '</span><span class="s0">${e}</span><span class="s3">')`);r.push(o[2].replace(i,((e,t,r)=&gt;t?a(t):r)))}else r.push(Number(t));return r}function l(e){r.lastIndex=0;const t=[];let n;for(;null!==(n=r.exec(e));){const e=n[1];if(n[2]){const r=o(e,n[2]);t.push([e].concat(r))}else t.push([e])}return t}function p(e,t){const r={};for(const e of t)for(const t of e.styles)r[t[0]]=e.inverse?null:t.slice(1);let n=e;for(const e of Object.keys(r))if(Array.isArray(r[e])){if(!(e in n))throw new Error(`Unknown Chalk style: ${e}`);n=r[e].length&gt;0?n[e].apply(n,r[e]):n[e]}return n}e.exports=(e,r)=&gt;{const n=[],i=[];let s=[];if(r.replace(t,((t,r,o,c,u,d)=&gt;{if(r)s.push(a(r));else if(c){const t=s.join(&quot;&quot;);s=[],i.push(0===n.length?t:p(e,n)(t)),n.push({inverse:o,styles:l(c)})}else if(u){if(0===n.length)throw new Error(&quot;Found extraneous } in Chalk template literal&quot;);i.push(p(e,n)(s.join(&quot;&quot;))),s=[],n.pop()}else s.push(d)})),i.push(s.join(&quot;&quot;)),n.length&gt;0){const e=`Chalk template literal is missing ${n.length} closing bracket${1===n.length?&quot;&quot;:&quot;s&quot;} (</span><span class="s5">\`</span><span class="s3">}</span><span class="s5">\`</span><span class="s3">)`;throw new Error(e)}return i.join(&quot;&quot;)}},8325:(e,t,r)=&gt;{var n=r(4730),i={};for(var s in n)n.hasOwnProperty(s)&amp;&amp;(i[n[s]]=s);var a=e.exports={rgb:{channels:3,labels:&quot;rgb&quot;},hsl:{channels:3,labels:&quot;hsl&quot;},hsv:{channels:3,labels:&quot;hsv&quot;},hwb:{channels:3,labels:&quot;hwb&quot;},cmyk:{channels:4,labels:&quot;cmyk&quot;},xyz:{channels:3,labels:&quot;xyz&quot;},lab:{channels:3,labels:&quot;lab&quot;},lch:{channels:3,labels:&quot;lch&quot;},hex:{channels:1,labels:[&quot;hex&quot;]},keyword:{channels:1,labels:[&quot;keyword&quot;]},ansi16:{channels:1,labels:[&quot;ansi16&quot;]},ansi256:{channels:1,labels:[&quot;ansi256&quot;]},hcg:{channels:3,labels:[&quot;h&quot;,&quot;c&quot;,&quot;g&quot;]},apple:{channels:3,labels:[&quot;r16&quot;,&quot;g16&quot;,&quot;b16&quot;]},gray:{channels:1,labels:[&quot;gray&quot;]}};for(var o in a)if(a.hasOwnProperty(o)){if(!(&quot;channels&quot;in a[o]))throw new Error(&quot;missing channels property: &quot;+o);if(!(&quot;labels&quot;in a[o]))throw new Error(&quot;missing channel labels property: &quot;+o);if(a[o].labels.length!==a[o].channels)throw new Error(&quot;channel and label counts mismatch: &quot;+o);var l=a[o].channels,p=a[o].labels;delete a[o].channels,delete a[o].labels,Object.defineProperty(a[o],&quot;channels&quot;,{value:l}),Object.defineProperty(a[o],&quot;labels&quot;,{value:p})}a.rgb.hsl=function(e){var t,r,n=e[0]/255,i=e[1]/255,s=e[2]/255,a=Math.min(n,i,s),o=Math.max(n,i,s),l=o-a;return o===a?t=0:n===o?t=(i-s)/l:i===o?t=2+(s-n)/l:s===o&amp;&amp;(t=4+(n-i)/l),(t=Math.min(60*t,360))&lt;0&amp;&amp;(t+=360),r=(a+o)/2,[t,100*(o===a?0:r&lt;=.5?l/(o+a):l/(2-o-a)),100*r]},a.rgb.hsv=function(e){var t,r,n,i,s,a=e[0]/255,o=e[1]/255,l=e[2]/255,p=Math.max(a,o,l),c=p-Math.min(a,o,l),u=function(e){return(p-e)/6/c+.5};return 0===c?i=s=0:(s=c/p,t=u(a),r=u(o),n=u(l),a===p?i=n-r:o===p?i=1/3+t-n:l===p&amp;&amp;(i=2/3+r-t),i&lt;0?i+=1:i&gt;1&amp;&amp;(i-=1)),[360*i,100*s,100*p]},a.rgb.hwb=function(e){var t=e[0],r=e[1],n=e[2];return[a.rgb.hsl(e)[0],1/255*Math.min(t,Math.min(r,n))*100,100*(n=1-1/255*Math.max(t,Math.max(r,n)))]},a.rgb.cmyk=function(e){var t,r=e[0]/255,n=e[1]/255,i=e[2]/255;return[100*((1-r-(t=Math.min(1-r,1-n,1-i)))/(1-t)||0),100*((1-n-t)/(1-t)||0),100*((1-i-t)/(1-t)||0),100*t]},a.rgb.keyword=function(e){var t=i[e];if(t)return t;var r,s,a,o=1/0;for(var l in n)if(n.hasOwnProperty(l)){var p=(s=e,a=n[l],Math.pow(s[0]-a[0],2)+Math.pow(s[1]-a[1],2)+Math.pow(s[2]-a[2],2));p&lt;o&amp;&amp;(o=p,r=l)}return r},a.keyword.rgb=function(e){return n[e]},a.rgb.xyz=function(e){var t=e[0]/255,r=e[1]/255,n=e[2]/255;return[100*(.4124*(t=t&gt;.04045?Math.pow((t+.055)/1.055,2.4):t/12.92)+.3576*(r=r&gt;.04045?Math.pow((r+.055)/1.055,2.4):r/12.92)+.1805*(n=n&gt;.04045?Math.pow((n+.055)/1.055,2.4):n/12.92)),100*(.2126*t+.7152*r+.0722*n),100*(.0193*t+.1192*r+.9505*n)]},a.rgb.lab=function(e){var t=a.rgb.xyz(e),r=t[0],n=t[1],i=t[2];return n/=100,i/=108.883,r=(r/=95.047)&gt;.008856?Math.pow(r,1/3):7.787*r+16/116,[116*(n=n&gt;.008856?Math.pow(n,1/3):7.787*n+16/116)-16,500*(r-n),200*(n-(i=i&gt;.008856?Math.pow(i,1/3):7.787*i+16/116))]},a.hsl.rgb=function(e){var t,r,n,i,s,a=e[0]/360,o=e[1]/100,l=e[2]/100;if(0===o)return[s=255*l,s,s];t=2*l-(r=l&lt;.5?l*(1+o):l+o-l*o),i=[0,0,0];for(var p=0;p&lt;3;p++)(n=a+1/3*-(p-1))&lt;0&amp;&amp;n++,n&gt;1&amp;&amp;n--,s=6*n&lt;1?t+6*(r-t)*n:2*n&lt;1?r:3*n&lt;2?t+(r-t)*(2/3-n)*6:t,i[p]=255*s;return i},a.hsl.hsv=function(e){var t=e[0],r=e[1]/100,n=e[2]/100,i=r,s=Math.max(n,.01);return r*=(n*=2)&lt;=1?n:2-n,i*=s&lt;=1?s:2-s,[t,100*(0===n?2*i/(s+i):2*r/(n+r)),(n+r)/2*100]},a.hsv.rgb=function(e){var t=e[0]/60,r=e[1]/100,n=e[2]/100,i=Math.floor(t)%6,s=t-Math.floor(t),a=255*n*(1-r),o=255*n*(1-r*s),l=255*n*(1-r*(1-s));switch(n*=255,i){case 0:return[n,l,a];case 1:return[o,n,a];case 2:return[a,n,l];case 3:return[a,o,n];case 4:return[l,a,n];case 5:return[n,a,o]}},a.hsv.hsl=function(e){var t,r,n,i=e[0],s=e[1]/100,a=e[2]/100,o=Math.max(a,.01);return n=(2-s)*a,r=s*o,[i,100*(r=(r/=(t=(2-s)*o)&lt;=1?t:2-t)||0),100*(n/=2)]},a.hwb.rgb=function(e){var t,r,n,i,s,a,o,l=e[0]/360,p=e[1]/100,c=e[2]/100,u=p+c;switch(u&gt;1&amp;&amp;(p/=u,c/=u),n=6*l-(t=Math.floor(6*l)),0!=(1&amp;t)&amp;&amp;(n=1-n),i=p+n*((r=1-c)-p),t){default:case 6:case 0:s=r,a=i,o=p;break;case 1:s=i,a=r,o=p;break;case 2:s=p,a=r,o=i;break;case 3:s=p,a=i,o=r;break;case 4:s=i,a=p,o=r;break;case 5:s=r,a=p,o=i}return[255*s,255*a,255*o]},a.cmyk.rgb=function(e){var t=e[0]/100,r=e[1]/100,n=e[2]/100,i=e[3]/100;return[255*(1-Math.min(1,t*(1-i)+i)),255*(1-Math.min(1,r*(1-i)+i)),255*(1-Math.min(1,n*(1-i)+i))]},a.xyz.rgb=function(e){var t,r,n,i=e[0]/100,s=e[1]/100,a=e[2]/100;return r=-.9689*i+1.8758*s+.0415*a,n=.0557*i+-.204*s+1.057*a,t=(t=3.2406*i+-1.5372*s+-.4986*a)&gt;.0031308?1.055*Math.pow(t,1/2.4)-.055:12.92*t,r=r&gt;.0031308?1.055*Math.pow(r,1/2.4)-.055:12.92*r,n=n&gt;.0031308?1.055*Math.pow(n,1/2.4)-.055:12.92*n,[255*(t=Math.min(Math.max(0,t),1)),255*(r=Math.min(Math.max(0,r),1)),255*(n=Math.min(Math.max(0,n),1))]},a.xyz.lab=function(e){var t=e[0],r=e[1],n=e[2];return r/=100,n/=108.883,t=(t/=95.047)&gt;.008856?Math.pow(t,1/3):7.787*t+16/116,[116*(r=r&gt;.008856?Math.pow(r,1/3):7.787*r+16/116)-16,500*(t-r),200*(r-(n=n&gt;.008856?Math.pow(n,1/3):7.787*n+16/116))]},a.lab.xyz=function(e){var t,r,n,i=e[0];t=e[1]/500+(r=(i+16)/116),n=r-e[2]/200;var s=Math.pow(r,3),a=Math.pow(t,3),o=Math.pow(n,3);return r=s&gt;.008856?s:(r-16/116)/7.787,t=a&gt;.008856?a:(t-16/116)/7.787,n=o&gt;.008856?o:(n-16/116)/7.787,[t*=95.047,r*=100,n*=108.883]},a.lab.lch=function(e){var t,r=e[0],n=e[1],i=e[2];return(t=360*Math.atan2(i,n)/2/Math.PI)&lt;0&amp;&amp;(t+=360),[r,Math.sqrt(n*n+i*i),t]},a.lch.lab=function(e){var t,r=e[0],n=e[1];return t=e[2]/360*2*Math.PI,[r,n*Math.cos(t),n*Math.sin(t)]},a.rgb.ansi16=function(e){var t=e[0],r=e[1],n=e[2],i=1 in arguments?arguments[1]:a.rgb.hsv(e)[2];if(0===(i=Math.round(i/50)))return 30;var s=30+(Math.round(n/255)&lt;&lt;2|Math.round(r/255)&lt;&lt;1|Math.round(t/255));return 2===i&amp;&amp;(s+=60),s},a.hsv.ansi16=function(e){return a.rgb.ansi16(a.hsv.rgb(e),e[2])},a.rgb.ansi256=function(e){var t=e[0],r=e[1],n=e[2];return t===r&amp;&amp;r===n?t&lt;8?16:t&gt;248?231:Math.round((t-8)/247*24)+232:16+36*Math.round(t/255*5)+6*Math.round(r/255*5)+Math.round(n/255*5)},a.ansi16.rgb=function(e){var t=e%10;if(0===t||7===t)return e&gt;50&amp;&amp;(t+=3.5),[t=t/10.5*255,t,t];var r=.5*(1+~~(e&gt;50));return[(1&amp;t)*r*255,(t&gt;&gt;1&amp;1)*r*255,(t&gt;&gt;2&amp;1)*r*255]},a.ansi256.rgb=function(e){if(e&gt;=232){var t=10*(e-232)+8;return[t,t,t]}var r;return e-=16,[Math.floor(e/36)/5*255,Math.floor((r=e%36)/6)/5*255,r%6/5*255]},a.rgb.hex=function(e){var t=(((255&amp;Math.round(e[0]))&lt;&lt;16)+((255&amp;Math.round(e[1]))&lt;&lt;8)+(255&amp;Math.round(e[2]))).toString(16).toUpperCase();return&quot;000000&quot;.substring(t.length)+t},a.hex.rgb=function(e){var t=e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!t)return[0,0,0];var r=t[0];3===t[0].length&amp;&amp;(r=r.split(&quot;&quot;).map((function(e){return e+e})).join(&quot;&quot;));var n=parseInt(r,16);return[n&gt;&gt;16&amp;255,n&gt;&gt;8&amp;255,255&amp;n]},a.rgb.hcg=function(e){var t,r=e[0]/255,n=e[1]/255,i=e[2]/255,s=Math.max(Math.max(r,n),i),a=Math.min(Math.min(r,n),i),o=s-a;return t=o&lt;=0?0:s===r?(n-i)/o%6:s===n?2+(i-r)/o:4+(r-n)/o+4,t/=6,[360*(t%=1),100*o,100*(o&lt;1?a/(1-o):0)]},a.hsl.hcg=function(e){var t,r=e[1]/100,n=e[2]/100,i=0;return(t=n&lt;.5?2*r*n:2*r*(1-n))&lt;1&amp;&amp;(i=(n-.5*t)/(1-t)),[e[0],100*t,100*i]},a.hsv.hcg=function(e){var t=e[1]/100,r=e[2]/100,n=t*r,i=0;return n&lt;1&amp;&amp;(i=(r-n)/(1-n)),[e[0],100*n,100*i]},a.hcg.rgb=function(e){var t=e[0]/360,r=e[1]/100,n=e[2]/100;if(0===r)return[255*n,255*n,255*n];var i,s=[0,0,0],a=t%1*6,o=a%1,l=1-o;switch(Math.floor(a)){case 0:s[0]=1,s[1]=o,s[2]=0;break;case 1:s[0]=l,s[1]=1,s[2]=0;break;case 2:s[0]=0,s[1]=1,s[2]=o;break;case 3:s[0]=0,s[1]=l,s[2]=1;break;case 4:s[0]=o,s[1]=0,s[2]=1;break;default:s[0]=1,s[1]=0,s[2]=l}return i=(1-r)*n,[255*(r*s[0]+i),255*(r*s[1]+i),255*(r*s[2]+i)]},a.hcg.hsv=function(e){var t=e[1]/100,r=t+e[2]/100*(1-t),n=0;return r&gt;0&amp;&amp;(n=t/r),[e[0],100*n,100*r]},a.hcg.hsl=function(e){var t=e[1]/100,r=e[2]/100*(1-t)+.5*t,n=0;return r&gt;0&amp;&amp;r&lt;.5?n=t/(2*r):r&gt;=.5&amp;&amp;r&lt;1&amp;&amp;(n=t/(2*(1-r))),[e[0],100*n,100*r]},a.hcg.hwb=function(e){var t=e[1]/100,r=t+e[2]/100*(1-t);return[e[0],100*(r-t),100*(1-r)]},a.hwb.hcg=function(e){var t=e[1]/100,r=1-e[2]/100,n=r-t,i=0;return n&lt;1&amp;&amp;(i=(r-n)/(1-n)),[e[0],100*n,100*i]},a.apple.rgb=function(e){return[e[0]/65535*255,e[1]/65535*255,e[2]/65535*255]},a.rgb.apple=function(e){return[e[0]/255*65535,e[1]/255*65535,e[2]/255*65535]},a.gray.rgb=function(e){return[e[0]/100*255,e[0]/100*255,e[0]/100*255]},a.gray.hsl=a.gray.hsv=function(e){return[0,0,e[0]]},a.gray.hwb=function(e){return[0,100,e[0]]},a.gray.cmyk=function(e){return[0,0,0,e[0]]},a.gray.lab=function(e){return[e[0],0,0]},a.gray.hex=function(e){var t=255&amp;Math.round(e[0]/100*255),r=((t&lt;&lt;16)+(t&lt;&lt;8)+t).toString(16).toUpperCase();return&quot;000000&quot;.substring(r.length)+r},a.rgb.gray=function(e){return[(e[0]+e[1]+e[2])/3/255*100]}},5536:(e,t,r)=&gt;{var n=r(8325),i=r(6094),s={};Object.keys(n).forEach((function(e){s[e]={},Object.defineProperty(s[e],&quot;channels&quot;,{value:n[e].channels}),Object.defineProperty(s[e],&quot;labels&quot;,{value:n[e].labels});var t=i(e);Object.keys(t).forEach((function(r){var n=t[r];s[e][r]=function(e){var t=function(t){if(null==t)return t;arguments.length&gt;1&amp;&amp;(t=Array.prototype.slice.call(arguments));var r=e(t);if(&quot;object&quot;==typeof r)for(var n=r.length,i=0;i&lt;n;i++)r[i]=Math.round(r[i]);return r};return&quot;conversion&quot;in e&amp;&amp;(t.conversion=e.conversion),t}(n),s[e][r].raw=function(e){var t=function(t){return null==t?t:(arguments.length&gt;1&amp;&amp;(t=Array.prototype.slice.call(arguments)),e(t))};return&quot;conversion&quot;in e&amp;&amp;(t.conversion=e.conversion),t}(n)}))})),e.exports=s},6094:(e,t,r)=&gt;{var n=r(8325);function i(e,t){return function(r){return t(e(r))}}function s(e,t){for(var r=[t[e].parent,e],s=n[t[e].parent][e],a=t[e].parent;t[a].parent;)r.unshift(t[a].parent),s=i(n[t[a].parent][a],s),a=t[a].parent;return s.conversion=r,s}e.exports=function(e){for(var t=function(e){var t=function(){for(var e={},t=Object.keys(n),r=t.length,i=0;i&lt;r;i++)e[t[i]]={distance:-1,parent:null};return e}(),r=[e];for(t[e].distance=0;r.length;)for(var i=r.pop(),s=Object.keys(n[i]),a=s.length,o=0;o&lt;a;o++){var l=s[o],p=t[l];-1===p.distance&amp;&amp;(p.distance=t[i].distance+1,p.parent=i,r.unshift(l))}return t}(e),r={},i=Object.keys(t),a=i.length,o=0;o&lt;a;o++){var l=i[o];null!==t[l].parent&amp;&amp;(r[l]=s(l,t))}return r}},4730:e=&gt;{&quot;use strict&quot;;e.exports={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]}},3182:(e,t,r)=&gt;{&quot;use strict&quot;;var n=r(397);const i=r(2037),s=r(9341),a=n.env;let o;function l(e){const t=function(e){if(!1===o)return 0;if(s(&quot;color=16m&quot;)||s(&quot;color=full&quot;)||s(&quot;color=truecolor&quot;))return 3;if(s(&quot;color=256&quot;))return 2;if(e&amp;&amp;!e.isTTY&amp;&amp;!0!==o)return 0;const t=o?1:0;if(&quot;win32&quot;===n.platform){const e=i.release().split(&quot;.&quot;);return Number(n.versions.node.split(&quot;.&quot;)[0])&gt;=8&amp;&amp;Number(e[0])&gt;=10&amp;&amp;Number(e[2])&gt;=10586?Number(e[2])&gt;=14931?3:2:1}if(&quot;CI&quot;in a)return[&quot;TRAVIS&quot;,&quot;CIRCLECI&quot;,&quot;APPVEYOR&quot;,&quot;GITLAB_CI&quot;].some((e=&gt;e in a))||&quot;codeship&quot;===a.CI_NAME?1:t;if(&quot;TEAMCITY_VERSION&quot;in a)return/^(9</span><span class="s5">\.</span><span class="s3">(0*[1-9]</span><span class="s5">\d</span><span class="s3">*)</span><span class="s5">\.</span><span class="s3">|</span><span class="s5">\d</span><span class="s3">{2,}</span><span class="s5">\.</span><span class="s3">)/.test(a.TEAMCITY_VERSION)?1:0;if(&quot;truecolor&quot;===a.COLORTERM)return 3;if(&quot;TERM_PROGRAM&quot;in a){const e=parseInt((a.TERM_PROGRAM_VERSION||&quot;&quot;).split(&quot;.&quot;)[0],10);switch(a.TERM_PROGRAM){case&quot;iTerm.app&quot;:return e&gt;=3?3:2;case&quot;Apple_Terminal&quot;:return 2}}return/-256(color)?$/i.test(a.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(a.TERM)||&quot;COLORTERM&quot;in a?1:(a.TERM,t)}(e);return function(e){return 0!==e&amp;&amp;{level:e,hasBasic:!0,has256:e&gt;=2,has16m:e&gt;=3}}(t)}s(&quot;no-color&quot;)||s(&quot;no-colors&quot;)||s(&quot;color=false&quot;)?o=!1:(s(&quot;color&quot;)||s(&quot;colors&quot;)||s(&quot;color=true&quot;)||s(&quot;color=always&quot;))&amp;&amp;(o=!0),&quot;FORCE_COLOR&quot;in a&amp;&amp;(o=0===a.FORCE_COLOR.length||0!==parseInt(a.FORCE_COLOR,10)),e.exports={supportsColor:l,stdout:l(n.stdout),stderr:l(n.stderr)}},4494:(e,t)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0});const r=!0,n=!0,i=!0,s=!0;class a{constructor(e,t={}){this.label=void 0,this.keyword=void 0,this.beforeExpr=void 0,this.startsExpr=void 0,this.rightAssociative=void 0,this.isLoop=void 0,this.isAssign=void 0,this.prefix=void 0,this.postfix=void 0,this.binop=void 0,this.updateContext=void 0,this.label=e,this.keyword=t.keyword,this.beforeExpr=!!t.beforeExpr,this.startsExpr=!!t.startsExpr,this.rightAssociative=!!t.rightAssociative,this.isLoop=!!t.isLoop,this.isAssign=!!t.isAssign,this.prefix=!!t.prefix,this.postfix=!!t.postfix,this.binop=null!=t.binop?t.binop:null,this.updateContext=null}}const o=new Map;function l(e,t={}){t.keyword=e;const r=new a(e,t);return o.set(e,r),r}function p(e,t){return new a(e,{beforeExpr:r,binop:t})}const c={num:new a(&quot;num&quot;,{startsExpr:n}),bigint:new a(&quot;bigint&quot;,{startsExpr:n}),decimal:new a(&quot;decimal&quot;,{startsExpr:n}),regexp:new a(&quot;regexp&quot;,{startsExpr:n}),string:new a(&quot;string&quot;,{startsExpr:n}),name:new a(&quot;name&quot;,{startsExpr:n}),privateName:new a(&quot;#name&quot;,{startsExpr:n}),eof:new a(&quot;eof&quot;),bracketL:new a(&quot;[&quot;,{beforeExpr:r,startsExpr:n}),bracketHashL:new a(&quot;#[&quot;,{beforeExpr:r,startsExpr:n}),bracketBarL:new a(&quot;[|&quot;,{beforeExpr:r,startsExpr:n}),bracketR:new a(&quot;]&quot;),bracketBarR:new a(&quot;|]&quot;),braceL:new a(&quot;{&quot;,{beforeExpr:r,startsExpr:n}),braceBarL:new a(&quot;{|&quot;,{beforeExpr:r,startsExpr:n}),braceHashL:new a(&quot;#{&quot;,{beforeExpr:r,startsExpr:n}),braceR:new a(&quot;}&quot;),braceBarR:new a(&quot;|}&quot;),parenL:new a(&quot;(&quot;,{beforeExpr:r,startsExpr:n}),parenR:new a(&quot;)&quot;),comma:new a(&quot;,&quot;,{beforeExpr:r}),semi:new a(&quot;;&quot;,{beforeExpr:r}),colon:new a(&quot;:&quot;,{beforeExpr:r}),doubleColon:new a(&quot;::&quot;,{beforeExpr:r}),dot:new a(&quot;.&quot;),question:new a(&quot;?&quot;,{beforeExpr:r}),questionDot:new a(&quot;?.&quot;),arrow:new a(&quot;=&gt;&quot;,{beforeExpr:r}),template:new a(&quot;template&quot;),ellipsis:new a(&quot;...&quot;,{beforeExpr:r}),backQuote:new a(&quot;`&quot;,{startsExpr:n}),dollarBraceL:new a(&quot;${&quot;,{beforeExpr:r,startsExpr:n}),at:new a(&quot;@&quot;),hash:new a(&quot;#&quot;,{startsExpr:n}),interpreterDirective:new a(&quot;#!...&quot;),eq:new a(&quot;=&quot;,{beforeExpr:r,isAssign:!0}),assign:new a(&quot;_=&quot;,{beforeExpr:r,isAssign:!0}),incDec:new a(&quot;++/--&quot;,{prefix:s,postfix:!0,startsExpr:n}),bang:new a(&quot;!&quot;,{beforeExpr:r,prefix:s,startsExpr:n}),tilde:new a(&quot;~&quot;,{beforeExpr:r,prefix:s,startsExpr:n}),pipeline:p(&quot;|&gt;&quot;,0),nullishCoalescing:p(&quot;??&quot;,1),logicalOR:p(&quot;||&quot;,1),logicalAND:p(&quot;&amp;&amp;&quot;,2),bitwiseOR:p(&quot;|&quot;,3),bitwiseXOR:p(&quot;^&quot;,4),bitwiseAND:p(&quot;&amp;&quot;,5),equality:p(&quot;==/!=/===/!==&quot;,6),relational:p(&quot;&lt;/&gt;/&lt;=/&gt;=&quot;,7),bitShift:p(&quot;&lt;&lt;/&gt;&gt;/&gt;&gt;&gt;&quot;,8),plusMin:new a(&quot;+/-&quot;,{beforeExpr:r,binop:9,prefix:s,startsExpr:n}),modulo:new a(&quot;%&quot;,{beforeExpr:r,binop:10,startsExpr:n}),star:new a(&quot;*&quot;,{binop:10}),slash:p(&quot;/&quot;,10),exponent:new a(&quot;**&quot;,{beforeExpr:r,binop:11,rightAssociative:!0}),_break:l(&quot;break&quot;),_case:l(&quot;case&quot;,{beforeExpr:r}),_catch:l(&quot;catch&quot;),_continue:l(&quot;continue&quot;),_debugger:l(&quot;debugger&quot;),_default:l(&quot;default&quot;,{beforeExpr:r}),_do:l(&quot;do&quot;,{isLoop:i,beforeExpr:r}),_else:l(&quot;else&quot;,{beforeExpr:r}),_finally:l(&quot;finally&quot;),_for:l(&quot;for&quot;,{isLoop:i}),_function:l(&quot;function&quot;,{startsExpr:n}),_if:l(&quot;if&quot;),_return:l(&quot;return&quot;,{beforeExpr:r}),_switch:l(&quot;switch&quot;),_throw:l(&quot;throw&quot;,{beforeExpr:r,prefix:s,startsExpr:n}),_try:l(&quot;try&quot;),_var:l(&quot;var&quot;),_const:l(&quot;const&quot;),_while:l(&quot;while&quot;,{isLoop:i}),_with:l(&quot;with&quot;),_new:l(&quot;new&quot;,{beforeExpr:r,startsExpr:n}),_this:l(&quot;this&quot;,{startsExpr:n}),_super:l(&quot;super&quot;,{startsExpr:n}),_class:l(&quot;class&quot;,{startsExpr:n}),_extends:l(&quot;extends&quot;,{beforeExpr:r}),_export:l(&quot;export&quot;),_import:l(&quot;import&quot;,{startsExpr:n}),_null:l(&quot;null&quot;,{startsExpr:n}),_true:l(&quot;true&quot;,{startsExpr:n}),_false:l(&quot;false&quot;,{startsExpr:n}),_in:l(&quot;in&quot;,{beforeExpr:r,binop:7}),_instanceof:l(&quot;instanceof&quot;,{beforeExpr:r,binop:7}),_typeof:l(&quot;typeof&quot;,{beforeExpr:r,prefix:s,startsExpr:n}),_void:l(&quot;void&quot;,{beforeExpr:r,prefix:s,startsExpr:n}),_delete:l(&quot;delete&quot;,{beforeExpr:r,prefix:s,startsExpr:n})},u=/</span><span class="s4">\r\n</span><span class="s3">?|[</span><span class="s4">\n\u2028\u2029</span><span class="s3">]/,d=new RegExp(u.source,&quot;g&quot;);function h(e){switch(e){case 10:case 13:case 8232:case 8233:return!0;default:return!1}}const f=/(?:</span><span class="s5">\s</span><span class="s3">|</span><span class="s5">\/\/</span><span class="s3">.*|</span><span class="s5">\/\*</span><span class="s3">[^]*?</span><span class="s5">\*\/</span><span class="s3">)*/g;function m(e){switch(e){case 9:case 11:case 12:case 32:case 160:case 5760:case 8192:case 8193:case 8194:case 8195:case 8196:case 8197:case 8198:case 8199:case 8200:case 8201:case 8202:case 8239:case 8287:case 12288:case 65279:return!0;default:return!1}}class y{constructor(e,t){this.line=void 0,this.column=void 0,this.line=e,this.column=t}}class T{constructor(e,t){this.start=void 0,this.end=void 0,this.filename=void 0,this.identifierName=void 0,this.start=e,this.end=t}}class b{constructor(){this.sawUnambiguousESM=!1,this.ambiguousScriptDifferentAst=!1}hasPlugin(e){return this.plugins.has(e)}getPluginOption(e,t){if(this.hasPlugin(e))return this.plugins.get(e)[t]}}function g(e){return e[e.length-1]}class S extends b{addComment(e){this.filename&amp;&amp;(e.loc.filename=this.filename),this.state.trailingComments.push(e),this.state.leadingComments.push(e)}adjustCommentsAfterTrailingComma(e,t,r){if(0===this.state.leadingComments.length)return;let n=null,i=t.length;for(;null===n&amp;&amp;i&gt;0;)n=t[--i];if(null===n)return;for(let e=0;e&lt;this.state.leadingComments.length;e++)this.state.leadingComments[e].end&lt;this.state.commentPreviousNode.end&amp;&amp;(this.state.leadingComments.splice(e,1),e--);const s=[];for(let t=0;t&lt;this.state.leadingComments.length;t++){const n=this.state.leadingComments[t];n.end&lt;e.end?(s.push(n),r||(this.state.leadingComments.splice(t,1),t--)):(void 0===e.trailingComments&amp;&amp;(e.trailingComments=[]),e.trailingComments.push(n))}r&amp;&amp;(this.state.leadingComments=[]),s.length&gt;0?n.trailingComments=s:void 0!==n.trailingComments&amp;&amp;(n.trailingComments=[])}processComment(e){if(&quot;Program&quot;===e.type&amp;&amp;e.body.length&gt;0)return;const t=this.state.commentStack;let r,n,i,s,a;if(this.state.trailingComments.length&gt;0)this.state.trailingComments[0].start&gt;=e.end?(i=this.state.trailingComments,this.state.trailingComments=[]):this.state.trailingComments.length=0;else if(t.length&gt;0){const r=g(t);r.trailingComments&amp;&amp;r.trailingComments[0].start&gt;=e.end&amp;&amp;(i=r.trailingComments,delete r.trailingComments)}for(t.length&gt;0&amp;&amp;g(t).start&gt;=e.start&amp;&amp;(r=t.pop());t.length&gt;0&amp;&amp;g(t).start&gt;=e.start;)n=t.pop();if(!n&amp;&amp;r&amp;&amp;(n=r),r)switch(e.type){case&quot;ObjectExpression&quot;:this.adjustCommentsAfterTrailingComma(e,e.properties);break;case&quot;ObjectPattern&quot;:this.adjustCommentsAfterTrailingComma(e,e.properties,!0);break;case&quot;CallExpression&quot;:this.adjustCommentsAfterTrailingComma(e,e.arguments);break;case&quot;ArrayExpression&quot;:this.adjustCommentsAfterTrailingComma(e,e.elements);break;case&quot;ArrayPattern&quot;:this.adjustCommentsAfterTrailingComma(e,e.elements,!0)}else this.state.commentPreviousNode&amp;&amp;(&quot;ImportSpecifier&quot;===this.state.commentPreviousNode.type&amp;&amp;&quot;ImportSpecifier&quot;!==e.type||&quot;ExportSpecifier&quot;===this.state.commentPreviousNode.type&amp;&amp;&quot;ExportSpecifier&quot;!==e.type)&amp;&amp;this.adjustCommentsAfterTrailingComma(e,[this.state.commentPreviousNode]);if(n){if(n.leadingComments)if(n!==e&amp;&amp;n.leadingComments.length&gt;0&amp;&amp;g(n.leadingComments).end&lt;=e.start)e.leadingComments=n.leadingComments,delete n.leadingComments;else for(s=n.leadingComments.length-2;s&gt;=0;--s)if(n.leadingComments[s].end&lt;=e.start){e.leadingComments=n.leadingComments.splice(0,s+1);break}}else if(this.state.leadingComments.length&gt;0)if(g(this.state.leadingComments).end&lt;=e.start){if(this.state.commentPreviousNode)for(a=0;a&lt;this.state.leadingComments.length;a++)this.state.leadingComments[a].end&lt;this.state.commentPreviousNode.end&amp;&amp;(this.state.leadingComments.splice(a,1),a--);this.state.leadingComments.length&gt;0&amp;&amp;(e.leadingComments=this.state.leadingComments,this.state.leadingComments=[])}else{for(s=0;s&lt;this.state.leadingComments.length&amp;&amp;!(this.state.leadingComments[s].end&gt;e.start);s++);const t=this.state.leadingComments.slice(0,s);t.length&amp;&amp;(e.leadingComments=t),i=this.state.leadingComments.slice(s),0===i.length&amp;&amp;(i=null)}if(this.state.commentPreviousNode=e,i)if(i.length&amp;&amp;i[0].start&gt;=e.start&amp;&amp;g(i).end&lt;=e.end)e.innerComments=i;else{const t=i.findIndex((t=&gt;t.end&gt;=e.end));t&gt;0?(e.innerComments=i.slice(0,t),e.trailingComments=i.slice(t)):e.trailingComments=i}t.push(e)}}const x=Object.freeze({SyntaxError:&quot;BABEL_PARSER_SYNTAX_ERROR&quot;,SourceTypeModuleError:&quot;BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED&quot;}),E=v({AccessorIsGenerator:&quot;A %0ter cannot be a generator.&quot;,ArgumentsInClass:&quot;'</span><span class="s0">arguments</span><span class="s3">' is only allowed in functions and class methods.&quot;,AsyncFunctionInSingleStatementContext:&quot;Async functions can only be declared at the top level or inside a block.&quot;,AwaitBindingIdentifier:&quot;Can not use '</span><span class="s0">await</span><span class="s3">' as identifier inside an async function.&quot;,AwaitBindingIdentifierInStaticBlock:&quot;Can not use '</span><span class="s0">await</span><span class="s3">' as identifier inside a static block.&quot;,AwaitExpressionFormalParameter:&quot;'</span><span class="s0">await</span><span class="s3">' is not allowed in async function parameters.&quot;,AwaitNotInAsyncContext:&quot;'</span><span class="s0">await</span><span class="s3">' is only allowed within async functions and at the top levels of modules.&quot;,AwaitNotInAsyncFunction:&quot;'</span><span class="s0">await</span><span class="s3">' is only allowed within async functions.&quot;,BadGetterArity:&quot;A '</span><span class="s0">get</span><span class="s3">' accesor must not have any formal parameters.&quot;,BadSetterArity:&quot;A '</span><span class="s0">set</span><span class="s3">' accesor must have exactly one formal parameter.&quot;,BadSetterRestParameter:&quot;A '</span><span class="s0">set</span><span class="s3">' accesor function argument must not be a rest parameter.&quot;,ConstructorClassField:&quot;Classes may not have a field named '</span><span class="s0">constructor</span><span class="s3">'.&quot;,ConstructorClassPrivateField:&quot;Classes may not have a private field named '</span><span class="s0">#constructor</span><span class="s3">'.&quot;,ConstructorIsAccessor:&quot;Class constructor may not be an accessor.&quot;,ConstructorIsAsync:&quot;Constructor can'</span><span class="s0">t be an async </span><span class="s1">function</span><span class="s0">.</span><span class="s3">&quot;,ConstructorIsGenerator:&quot;</span><span class="s0">Constructor can</span><span class="s3">'t be a generator.&quot;,DeclarationMissingInitializer:&quot;'</span><span class="s0">%</span><span class="s2">0</span><span class="s3">' require an initialization value.&quot;,DecoratorBeforeExport:&quot;Decorators must be placed *before* the '</span><span class="s0">export</span><span class="s3">' keyword. You can set the '</span><span class="s0">decoratorsBeforeExport</span><span class="s3">' option to false to use the '</span><span class="s0">export @decorator class {}</span><span class="s3">' syntax.&quot;,DecoratorConstructor:&quot;Decorators can'</span><span class="s0">t be used </span><span class="s1">with </span><span class="s0">a constructor. Did you mean </span><span class="s3">'@dec class { ... }'</span><span class="s0">?</span><span class="s3">&quot;,DecoratorExportClass:&quot;</span><span class="s0">Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.</span><span class="s3">&quot;,DecoratorSemicolon:&quot;</span><span class="s0">Decorators must not be followed by a semicolon.</span><span class="s3">&quot;,DecoratorStaticBlock:&quot;</span><span class="s0">Decorators can</span><span class="s3">'t be used with a static block.&quot;,DeletePrivateField:&quot;Deleting a private field is not allowed.&quot;,DestructureNamedImport:&quot;ES2015 named imports do not destructure. Use another statement for destructuring after the import.&quot;,DuplicateConstructor:&quot;Duplicate constructor in the same class.&quot;,DuplicateDefaultExport:&quot;Only one default export allowed per module.&quot;,DuplicateExport:&quot;`%0` has already been exported. Exported identifiers must be unique.&quot;,DuplicateProto:&quot;Redefinition of __proto__ property.&quot;,DuplicateRegExpFlags:&quot;Duplicate regular expression flag.&quot;,ElementAfterRest:&quot;Rest element must be last element.&quot;,EscapedCharNotAnIdentifier:&quot;Invalid Unicode escape.&quot;,ExportBindingIsString:&quot;A string literal cannot be used as an exported binding without `from`.</span><span class="s4">\n</span><span class="s3">- Did you mean `export { '</span><span class="s0">%</span><span class="s2">0</span><span class="s3">' as '</span><span class="s0">%</span><span class="s2">1</span><span class="s3">' } from '</span><span class="s0">some-module</span><span class="s3">'`?&quot;,ExportDefaultFromAsIdentifier:&quot;'</span><span class="s0">from</span><span class="s3">' is not allowed as an identifier after '</span><span class="s0">export </span><span class="s1">default</span><span class="s3">'.&quot;,ForInOfLoopInitializer:&quot;'</span><span class="s0">%</span><span class="s2">0</span><span class="s3">' loop variable declaration may not have an initializer.&quot;,ForOfAsync:&quot;The left-hand side of a for-of loop may not be '</span><span class="s0">async</span><span class="s3">'.&quot;,ForOfLet:&quot;The left-hand side of a for-of loop may not start with '</span><span class="s0">let</span><span class="s3">'.&quot;,GeneratorInSingleStatementContext:&quot;Generators can only be declared at the top level or inside a block.&quot;,IllegalBreakContinue:&quot;Unsyntactic %0.&quot;,IllegalLanguageModeDirective:&quot;Illegal '</span><span class="s0">use strict</span><span class="s3">' directive in function with non-simple parameter list.&quot;,IllegalReturn:&quot;'</span><span class="s1">return</span><span class="s3">' outside of function.&quot;,ImportBindingIsString:'</span><span class="s0">A string literal cannot be used as an imported binding.\n- Did you mean `import { </span><span class="s3">&quot;%0&quot; </span><span class="s0">as foo }`?</span><span class="s3">',ImportCallArgumentTrailingComma:&quot;Trailing comma is disallowed inside import(...) arguments.&quot;,ImportCallArity:&quot;`import()` requires exactly %0.&quot;,ImportCallNotNewExpression:&quot;Cannot use new with import(...).&quot;,ImportCallSpreadArgument:&quot;`...` is not allowed in `import()`.&quot;,InvalidBigIntLiteral:&quot;Invalid BigIntLiteral.&quot;,InvalidCodePoint:&quot;Code point out of bounds.&quot;,InvalidDecimal:&quot;Invalid decimal.&quot;,InvalidDigit:&quot;Expected number in radix %0.&quot;,InvalidEscapeSequence:&quot;Bad character escape sequence.&quot;,InvalidEscapeSequenceTemplate:&quot;Invalid escape sequence in template.&quot;,InvalidEscapedReservedWord:&quot;Escape sequence in keyword %0.&quot;,InvalidIdentifier:&quot;Invalid identifier %0.&quot;,InvalidLhs:&quot;Invalid left-hand side in %0.&quot;,InvalidLhsBinding:&quot;Binding invalid left-hand side in %0.&quot;,InvalidNumber:&quot;Invalid number.&quot;,InvalidOrMissingExponent:&quot;Floating-point numbers require a valid exponent after the '</span><span class="s0">e</span><span class="s3">'.&quot;,InvalidOrUnexpectedToken:&quot;Unexpected character '</span><span class="s0">%</span><span class="s2">0</span><span class="s3">'.&quot;,InvalidParenthesizedAssignment:&quot;Invalid parenthesized assignment pattern.&quot;,InvalidPrivateFieldResolution:&quot;Private name #%0 is not defined.&quot;,InvalidPropertyBindingPattern:&quot;Binding member expression.&quot;,InvalidRecordProperty:&quot;Only properties and spread elements are allowed in record definitions.&quot;,InvalidRestAssignmentPattern:&quot;Invalid rest operator'</span><span class="s0">s argument.</span><span class="s3">&quot;,LabelRedeclaration:&quot;</span><span class="s0">Label </span><span class="s3">'%0' </span><span class="s0">is already declared.</span><span class="s3">&quot;,LetInLexicalBinding:&quot;'let' </span><span class="s0">is not allowed to be used as a name </span><span class="s1">in </span><span class="s3">'let' </span><span class="s0">or </span><span class="s3">'const' </span><span class="s0">declarations.</span><span class="s3">&quot;,LineTerminatorBeforeArrow:&quot;</span><span class="s0">No line </span><span class="s1">break </span><span class="s0">is allowed before </span><span class="s3">'=&gt;'</span><span class="s0">.</span><span class="s3">&quot;,MalformedRegExpFlags:&quot;</span><span class="s0">Invalid regular expression flag.</span><span class="s3">&quot;,MissingClassName:&quot;</span><span class="s0">A class name is required.</span><span class="s3">&quot;,MissingEqInAssignment:&quot;</span><span class="s0">Only </span><span class="s3">'=' </span><span class="s0">operator can be used </span><span class="s1">for </span><span class="s0">specifying </span><span class="s1">default </span><span class="s0">value.</span><span class="s3">&quot;,MissingSemicolon:&quot;</span><span class="s0">Missing semicolon.</span><span class="s3">&quot;,MissingUnicodeEscape:&quot;</span><span class="s0">Expecting Unicode escape sequence \\uXXXX.</span><span class="s3">&quot;,MixingCoalesceWithLogical:&quot;</span><span class="s0">Nullish coalescing operator(??) requires parens when mixing </span><span class="s1">with </span><span class="s0">logical operators.</span><span class="s3">&quot;,ModuleAttributeDifferentFromType:&quot;</span><span class="s0">The only accepted module attribute is `type`.</span><span class="s3">&quot;,ModuleAttributeInvalidValue:&quot;</span><span class="s0">Only string literals are allowed as module attribute values.</span><span class="s3">&quot;,ModuleAttributesWithDuplicateKeys:'Duplicate key &quot;</span><span class="s0">%</span><span class="s2">0</span><span class="s3">&quot; is not allowed in module attributes.',ModuleExportNameHasLoneSurrogate:&quot;</span><span class="s0">An export name cannot include a lone surrogate, found </span><span class="s3">'</span><span class="s4">\\</span><span class="s3">u%0'</span><span class="s0">.</span><span class="s3">&quot;,ModuleExportUndefined:&quot;</span><span class="s0">Export </span><span class="s3">'%0' </span><span class="s0">is not defined.</span><span class="s3">&quot;,MultipleDefaultsInSwitch:&quot;</span><span class="s0">Multiple </span><span class="s1">default </span><span class="s0">clauses.</span><span class="s3">&quot;,NewlineAfterThrow:&quot;</span><span class="s0">Illegal newline after </span><span class="s1">throw</span><span class="s0">.</span><span class="s3">&quot;,NoCatchOrFinally:&quot;</span><span class="s0">Missing </span><span class="s1">catch </span><span class="s0">or </span><span class="s1">finally </span><span class="s0">clause.</span><span class="s3">&quot;,NumberIdentifier:&quot;</span><span class="s0">Identifier directly after number.</span><span class="s3">&quot;,NumericSeparatorInEscapeSequence:&quot;</span><span class="s0">Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.</span><span class="s3">&quot;,ObsoleteAwaitStar:&quot;'await*' </span><span class="s0">has been removed from the async functions proposal. Use Promise.all() instead.</span><span class="s3">&quot;,OptionalChainingNoNew:&quot;</span><span class="s0">Constructors </span><span class="s1">in</span><span class="s0">/after an Optional Chain are not allowed.</span><span class="s3">&quot;,OptionalChainingNoTemplate:&quot;</span><span class="s0">Tagged Template Literals are not allowed </span><span class="s1">in </span><span class="s0">optionalChain.</span><span class="s3">&quot;,OverrideOnConstructor:&quot;'override' </span><span class="s0">modifier cannot appear on a constructor declaration.</span><span class="s3">&quot;,ParamDupe:&quot;</span><span class="s0">Argument name clash.</span><span class="s3">&quot;,PatternHasAccessor:&quot;</span><span class="s0">Object pattern can</span><span class="s3">'t contain getter or setter.&quot;,PatternHasMethod:&quot;Object pattern can'</span><span class="s0">t contain methods.</span><span class="s3">&quot;,PipelineBodyNoArrow:'Unexpected arrow &quot;</span><span class="s0">=&gt;</span><span class="s3">&quot; after pipeline body; arrow function in pipeline body must be parenthesized.',PipelineBodySequenceExpression:&quot;</span><span class="s0">Pipeline body may not be a comma-separated sequence expression.</span><span class="s3">&quot;,PipelineHeadSequenceExpression:&quot;</span><span class="s0">Pipeline head should not be a comma-separated sequence expression.</span><span class="s3">&quot;,PipelineTopicUnused:&quot;</span><span class="s0">Pipeline is </span><span class="s1">in </span><span class="s0">topic style but does not use topic reference.</span><span class="s3">&quot;,PrimaryTopicNotAllowed:&quot;</span><span class="s0">Topic reference was used </span><span class="s1">in </span><span class="s0">a lexical context without topic binding.</span><span class="s3">&quot;,PrimaryTopicRequiresSmartPipeline:&quot;</span><span class="s0">Primary Topic Reference found but pipelineOperator not passed </span><span class="s3">'smart' </span><span class="s1">for </span><span class="s3">'proposal' </span><span class="s0">option.</span><span class="s3">&quot;,PrivateInExpectedIn:&quot;</span><span class="s0">Private names are only allowed </span><span class="s1">in </span><span class="s0">property accesses (`obj.#%</span><span class="s2">0</span><span class="s0">`) or </span><span class="s1">in </span><span class="s0">`</span><span class="s1">in</span><span class="s0">` expressions (`#%</span><span class="s2">0 </span><span class="s1">in </span><span class="s0">obj`).</span><span class="s3">&quot;,PrivateNameRedeclaration:&quot;</span><span class="s0">Duplicate private name #%</span><span class="s2">0</span><span class="s0">.</span><span class="s3">&quot;,RecordExpressionBarIncorrectEndSyntaxType:&quot;</span><span class="s0">Record expressions ending </span><span class="s1">with </span><span class="s3">'|}' </span><span class="s0">are only allowed when the </span><span class="s3">'syntaxType' </span><span class="s0">option of the </span><span class="s3">'recordAndTuple' </span><span class="s0">plugin is set to </span><span class="s3">'bar'</span><span class="s0">.</span><span class="s3">&quot;,RecordExpressionBarIncorrectStartSyntaxType:&quot;</span><span class="s0">Record expressions starting </span><span class="s1">with </span><span class="s3">'{|' </span><span class="s0">are only allowed when the </span><span class="s3">'syntaxType' </span><span class="s0">option of the </span><span class="s3">'recordAndTuple' </span><span class="s0">plugin is set to </span><span class="s3">'bar'</span><span class="s0">.</span><span class="s3">&quot;,RecordExpressionHashIncorrectStartSyntaxType:&quot;</span><span class="s0">Record expressions starting </span><span class="s1">with </span><span class="s3">'#{' </span><span class="s0">are only allowed when the </span><span class="s3">'syntaxType' </span><span class="s0">option of the </span><span class="s3">'recordAndTuple' </span><span class="s0">plugin is set to </span><span class="s3">'hash'</span><span class="s0">.</span><span class="s3">&quot;,RecordNoProto:&quot;'__proto__' </span><span class="s0">is not allowed </span><span class="s1">in </span><span class="s0">Record expressions.</span><span class="s3">&quot;,RestTrailingComma:&quot;</span><span class="s0">Unexpected trailing comma after rest element.</span><span class="s3">&quot;,SloppyFunction:&quot;</span><span class="s0">In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an </span><span class="s1">if </span><span class="s0">statement.</span><span class="s3">&quot;,StaticPrototype:&quot;</span><span class="s0">Classes may not have static property named prototype.</span><span class="s3">&quot;,StrictDelete:&quot;</span><span class="s0">Deleting local variable </span><span class="s1">in </span><span class="s0">strict mode.</span><span class="s3">&quot;,StrictEvalArguments:&quot;</span><span class="s0">Assigning to </span><span class="s3">'%0' </span><span class="s1">in </span><span class="s0">strict mode.</span><span class="s3">&quot;,StrictEvalArgumentsBinding:&quot;</span><span class="s0">Binding </span><span class="s3">'%0' </span><span class="s1">in </span><span class="s0">strict mode.</span><span class="s3">&quot;,StrictFunction:&quot;</span><span class="s0">In strict mode code, functions can only be declared at top level or inside a block.</span><span class="s3">&quot;,StrictNumericEscape:&quot;</span><span class="s0">The only valid numeric escape </span><span class="s1">in </span><span class="s0">strict mode is </span><span class="s3">'</span><span class="s4">\\</span><span class="s3">0'</span><span class="s0">.</span><span class="s3">&quot;,StrictOctalLiteral:&quot;</span><span class="s0">Legacy octal literals are not allowed </span><span class="s1">in </span><span class="s0">strict mode.</span><span class="s3">&quot;,StrictWith:&quot;'with' </span><span class="s1">in </span><span class="s0">strict mode.</span><span class="s3">&quot;,SuperNotAllowed:&quot;</span><span class="s0">`super()` is only valid inside a class constructor of a subclass. Maybe a typo </span><span class="s1">in </span><span class="s0">the method name (</span><span class="s3">'constructor'</span><span class="s0">) or not extending another class?</span><span class="s3">&quot;,SuperPrivateField:&quot;</span><span class="s0">Private fields can</span><span class="s3">'t be accessed on super.&quot;,TrailingDecorator:&quot;Decorators must be attached to a class element.&quot;,TupleExpressionBarIncorrectEndSyntaxType:&quot;Tuple expressions ending with '</span><span class="s0">|]</span><span class="s3">' are only allowed when the '</span><span class="s0">syntaxType</span><span class="s3">' option of the '</span><span class="s0">recordAndTuple</span><span class="s3">' plugin is set to '</span><span class="s0">bar</span><span class="s3">'.&quot;,TupleExpressionBarIncorrectStartSyntaxType:&quot;Tuple expressions starting with '</span><span class="s0">[|</span><span class="s3">' are only allowed when the '</span><span class="s0">syntaxType</span><span class="s3">' option of the '</span><span class="s0">recordAndTuple</span><span class="s3">' plugin is set to '</span><span class="s0">bar</span><span class="s3">'.&quot;,TupleExpressionHashIncorrectStartSyntaxType:&quot;Tuple expressions starting with '</span><span class="s0">#[</span><span class="s3">' are only allowed when the '</span><span class="s0">syntaxType</span><span class="s3">' option of the '</span><span class="s0">recordAndTuple</span><span class="s3">' plugin is set to '</span><span class="s0">hash</span><span class="s3">'.&quot;,UnexpectedArgumentPlaceholder:&quot;Unexpected argument placeholder.&quot;,UnexpectedAwaitAfterPipelineBody:'</span><span class="s0">Unexpected </span><span class="s3">&quot;await&quot; </span><span class="s0">after pipeline body; await must have parentheses </span><span class="s1">in </span><span class="s0">minimal proposal.</span><span class="s3">',UnexpectedDigitAfterHash:&quot;Unexpected digit after hash token.&quot;,UnexpectedImportExport:&quot;'</span><span class="s0">import</span><span class="s3">' and '</span><span class="s0">export</span><span class="s3">' may only appear at the top level.&quot;,UnexpectedKeyword:&quot;Unexpected keyword '</span><span class="s0">%</span><span class="s2">0</span><span class="s3">'.&quot;,UnexpectedLeadingDecorator:&quot;Leading decorators must be attached to a class declaration.&quot;,UnexpectedLexicalDeclaration:&quot;Lexical declaration cannot appear in a single-statement context.&quot;,UnexpectedNewTarget:&quot;`new.target` can only be used in functions or class properties.&quot;,UnexpectedNumericSeparator:&quot;A numeric separator is only allowed between two digits.&quot;,UnexpectedPrivateField:&quot;Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )</span><span class="s4">\n </span><span class="s3">or a property of member expression (i.e. this.#p).&quot;,UnexpectedReservedWord:&quot;Unexpected reserved word '</span><span class="s0">%</span><span class="s2">0</span><span class="s3">'.&quot;,UnexpectedSuper:&quot;'</span><span class="s0">super</span><span class="s3">' is only allowed in object methods and classes.&quot;,UnexpectedToken:&quot;Unexpected token '</span><span class="s0">%</span><span class="s2">0</span><span class="s3">'.&quot;,UnexpectedTokenUnaryExponentiation:&quot;Illegal expression. Wrap left hand side or entire exponentiation in parentheses.&quot;,UnsupportedBind:&quot;Binding should be performed on object property.&quot;,UnsupportedDecoratorExport:&quot;A decorated export must export a class declaration.&quot;,UnsupportedDefaultExport:&quot;Only expressions, functions or classes are allowed as the `default` export.&quot;,UnsupportedImport:&quot;`import` can only be used in `import()` or `import.meta`.&quot;,UnsupportedMetaProperty:&quot;The only valid meta property for %0 is %0.%1.&quot;,UnsupportedParameterDecorator:&quot;Decorators cannot be used to decorate parameters.&quot;,UnsupportedPropertyDecorator:&quot;Decorators cannot be used to decorate object literal properties.&quot;,UnsupportedSuper:&quot;'</span><span class="s0">super</span><span class="s3">' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).&quot;,UnterminatedComment:&quot;Unterminated comment.&quot;,UnterminatedRegExp:&quot;Unterminated regular expression.&quot;,UnterminatedString:&quot;Unterminated string constant.&quot;,UnterminatedTemplate:&quot;Unterminated template.&quot;,VarRedeclaration:&quot;Identifier '</span><span class="s0">%</span><span class="s2">0</span><span class="s3">' has already been declared.&quot;,YieldBindingIdentifier:&quot;Can not use '</span><span class="s0">yield</span><span class="s3">' as identifier inside a generator.&quot;,YieldInParameter:&quot;Yield expression is not allowed in formal parameters.&quot;,ZeroDigitNumericSeparator:&quot;Numeric separator can not be used after leading 0.&quot;},x.SyntaxError),P=v({ImportMetaOutsideModule:&quot;import.meta may appear only with '</span><span class="s0">sourceType: \</span><span class="s3">&quot;module</span><span class="s4">\&quot;</span><span class="s3">'&quot;</span><span class="s0">,ImportOutsideModule:</span><span class="s3">&quot;'import' and 'export' may appear only with 'sourceType: </span><span class="s4">\&quot;</span><span class="s3">module</span><span class="s4">\&quot;</span><span class="s3">'&quot;</span><span class="s0">},x.SourceTypeModuleError);</span><span class="s1">function </span><span class="s0">v(e,t){const r={};</span><span class="s1">return </span><span class="s0">Object.keys(e).forEach((n=&gt;{r[n]=Object.freeze({code:t,reasonCode:n,template:e[n]})})),Object.freeze(r)}class A extends S{getLocationForPosition(e){let t;</span><span class="s1">return </span><span class="s0">t=e===</span><span class="s1">this</span><span class="s0">.state.start?</span><span class="s1">this</span><span class="s0">.state.startLoc:e===</span><span class="s1">this</span><span class="s0">.state.lastTokStart?</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc:e===</span><span class="s1">this</span><span class="s0">.state.end?</span><span class="s1">this</span><span class="s0">.state.endLoc:e===</span><span class="s1">this</span><span class="s0">.state.lastTokEnd?</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc:</span><span class="s1">function</span><span class="s0">(e,t){let r,n=</span><span class="s2">1</span><span class="s0">,i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(d.lastIndex=</span><span class="s2">0</span><span class="s0">;(r=d.exec(e))&amp;&amp;r.index&lt;t;)n++,i=d.lastIndex;</span><span class="s1">return new </span><span class="s0">y(n,t-i)}(</span><span class="s1">this</span><span class="s0">.input,e),t}raise(e,{code:t,reasonCode:r,template:n},...i){</span><span class="s1">return this</span><span class="s0">.raiseWithData(e,{code:t,reasonCode:r},n,...i)}raiseOverwrite(e,{code:t,template:r},...n){const i=</span><span class="s1">this</span><span class="s0">.getLocationForPosition(e),s=r.replace(/%(\d+)/g,((e,t)=&gt;n[t]))+` (${i.line}:${i.column})`;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.options.errorRecovery){const t=</span><span class="s1">this</span><span class="s0">.state.errors;</span><span class="s1">for</span><span class="s0">(let r=t.length-1;r&gt;=</span><span class="s2">0</span><span class="s0">;r--){const n=t[r];</span><span class="s1">if</span><span class="s0">(n.pos===e)</span><span class="s1">return </span><span class="s0">Object.assign(n,{message:s});</span><span class="s1">if</span><span class="s0">(n.pos&lt;e)</span><span class="s1">break</span><span class="s0">}}</span><span class="s1">return this</span><span class="s0">._raise({code:t,loc:i,pos:e},s)}raiseWithData(e,t,r,...n){const i=</span><span class="s1">this</span><span class="s0">.getLocationForPosition(e),s=r.replace(/%(\d+)/g,((e,t)=&gt;n[t]))+` (${i.line}:${i.column})`;</span><span class="s1">return this</span><span class="s0">._raise(Object.assign({loc:i,pos:e},t),s)}_raise(e,t){const r=</span><span class="s1">new </span><span class="s0">SyntaxError(t);</span><span class="s1">if</span><span class="s0">(Object.assign(r,e),</span><span class="s1">this</span><span class="s0">.options.errorRecovery)</span><span class="s1">return this</span><span class="s0">.isLookahead||</span><span class="s1">this</span><span class="s0">.state.errors.push(r),r;</span><span class="s1">throw </span><span class="s0">r}}class w{constructor(e,t,r,n){</span><span class="s1">this</span><span class="s0">.token=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isExpr=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.preserveSpace=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.override=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.token=e,</span><span class="s1">this</span><span class="s0">.isExpr=!!t,</span><span class="s1">this</span><span class="s0">.preserveSpace=!!r,</span><span class="s1">this</span><span class="s0">.override=n}}const O={braceStatement:</span><span class="s1">new </span><span class="s0">w(</span><span class="s3">&quot;{&quot;</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),braceExpression:</span><span class="s1">new </span><span class="s0">w(</span><span class="s3">&quot;{&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),recordExpression:</span><span class="s1">new </span><span class="s0">w(</span><span class="s3">&quot;#{&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),templateQuasi:</span><span class="s1">new </span><span class="s0">w(</span><span class="s3">&quot;${&quot;</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),parenStatement:</span><span class="s1">new </span><span class="s0">w(</span><span class="s3">&quot;(&quot;</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),parenExpression:</span><span class="s1">new </span><span class="s0">w(</span><span class="s3">&quot;(&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),template:</span><span class="s1">new </span><span class="s0">w(</span><span class="s3">&quot;`&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">,(e=&gt;e.readTmplToken())),functionExpression:</span><span class="s1">new </span><span class="s0">w(</span><span class="s3">&quot;function&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),functionStatement:</span><span class="s1">new </span><span class="s0">w(</span><span class="s3">&quot;function&quot;</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">)};c.parenR.updateContext=c.braceR.updateContext=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.context.length)</span><span class="s1">return void</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">0</span><span class="s0">);let e=</span><span class="s1">this</span><span class="s0">.state.context.pop();e===O.braceStatement&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.curContext().token&amp;&amp;(e=</span><span class="s1">this</span><span class="s0">.state.context.pop()),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!e.isExpr},c.name.updateContext=</span><span class="s1">function</span><span class="s0">(e){let t=!</span><span class="s2">1</span><span class="s0">;e!==c.dot&amp;&amp;(</span><span class="s3">&quot;of&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.state.value||</span><span class="s1">this</span><span class="s0">.state.exprAllowed||e===c._function||e===c._class||(t=!</span><span class="s2">0</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=t},c.braceL.updateContext=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">this</span><span class="s0">.state.context.push(</span><span class="s1">this</span><span class="s0">.braceIsBlock(e)?O.braceStatement:O.braceExpression),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">0</span><span class="s0">},c.dollarBraceL.updateContext=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">.state.context.push(O.templateQuasi),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">0</span><span class="s0">},c.parenL.updateContext=</span><span class="s1">function</span><span class="s0">(e){const t=e===c._if||e===c._for||e===c._with||e===c._while;</span><span class="s1">this</span><span class="s0">.state.context.push(t?O.parenStatement:O.parenExpression),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">0</span><span class="s0">},c.incDec.updateContext=</span><span class="s1">function</span><span class="s0">(){},c._function.updateContext=c._class.updateContext=</span><span class="s1">function</span><span class="s0">(e){!e.beforeExpr||e===c.semi||e===c._else||e===c._return&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()||(e===c.colon||e===c.braceL)&amp;&amp;</span><span class="s1">this</span><span class="s0">.curContext()===O.b_stat?</span><span class="s1">this</span><span class="s0">.state.context.push(O.functionStatement):</span><span class="s1">this</span><span class="s0">.state.context.push(O.functionExpression),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">},c.backQuote.updateContext=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">.curContext()===O.template?</span><span class="s1">this</span><span class="s0">.state.context.pop():</span><span class="s1">this</span><span class="s0">.state.context.push(O.template),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">},c.braceHashL.updateContext=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">.state.context.push(O.recordExpression),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">0</span><span class="s0">};let I=</span><span class="s3">&quot;ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-ꟊꟵ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ&quot;</span><span class="s0">,N=</span><span class="s3">&quot;‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿᫀᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿&quot;</span><span class="s0">;const C=</span><span class="s1">new </span><span class="s0">RegExp(</span><span class="s3">&quot;[&quot;</span><span class="s0">+I+</span><span class="s3">&quot;]&quot;</span><span class="s0">),k=</span><span class="s1">new </span><span class="s0">RegExp(</span><span class="s3">&quot;[&quot;</span><span class="s0">+I+N+</span><span class="s3">&quot;]&quot;</span><span class="s0">);I=N=</span><span class="s1">null</span><span class="s0">;const D=[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">25</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">122</span><span class="s0">,</span><span class="s2">70</span><span class="s0">,</span><span class="s2">52</span><span class="s0">,</span><span class="s2">268</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">48</span><span class="s0">,</span><span class="s2">48</span><span class="s0">,</span><span class="s2">31</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">37</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">157</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">39</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">51</span><span class="s0">,</span><span class="s2">157</span><span class="s0">,</span><span class="s2">310</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">153</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">66</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">25</span><span class="s0">,</span><span class="s2">71</span><span class="s0">,</span><span class="s2">55</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">65</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">36</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">27</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">53</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">111</span><span class="s0">,</span><span class="s2">72</span><span class="s0">,</span><span class="s2">56</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">349</span><span class="s0">,</span><span class="s2">41</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">79</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">107</span><span class="s0">,</span><span class="s2">20</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">52</span><span class="s0">,</span><span class="s2">76</span><span class="s0">,</span><span class="s2">44</span><span class="s0">,</span><span class="s2">33</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">27</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">34</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">36</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">85</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">46</span><span class="s0">,</span><span class="s2">39</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">159</span><span class="s0">,</span><span class="s2">52</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">31</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">185</span><span class="s0">,</span><span class="s2">46</span><span class="s0">,</span><span class="s2">42</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">37</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">60</span><span class="s0">,</span><span class="s2">42</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">72</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">230</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">117</span><span class="s0">,</span><span class="s2">63</span><span class="s0">,</span><span class="s2">32</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">23</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">95</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">38</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">39</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">45</span><span class="s0">,</span><span class="s2">20</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">56</span><span class="s0">,</span><span class="s2">264</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">36</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">113</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">37</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">31</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">328</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">190</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">80</span><span class="s0">,</span><span class="s2">921</span><span class="s0">,</span><span class="s2">103</span><span class="s0">,</span><span class="s2">110</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">195</span><span class="s0">,</span><span class="s2">2749</span><span class="s0">,</span><span class="s2">1070</span><span class="s0">,</span><span class="s2">4050</span><span class="s0">,</span><span class="s2">582</span><span class="s0">,</span><span class="s2">8634</span><span class="s0">,</span><span class="s2">568</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">114</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">32</span><span class="s0">,</span><span class="s2">20</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">689</span><span class="s0">,</span><span class="s2">63</span><span class="s0">,</span><span class="s2">129</span><span class="s0">,</span><span class="s2">74</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">67</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">65</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">6135</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">1237</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">8952</span><span class="s0">,</span><span class="s2">286</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">395</span><span class="s0">,</span><span class="s2">2309</span><span class="s0">,</span><span class="s2">106</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">5991</span><span class="s0">,</span><span class="s2">84</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">70</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">64</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">27</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">339</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2357</span><span class="s0">,</span><span class="s2">44</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">370</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">1301</span><span class="s0">,</span><span class="s2">196</span><span class="s0">,</span><span class="s2">60</span><span class="s0">,</span><span class="s2">67</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1205</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">4421</span><span class="s0">,</span><span class="s2">42717</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">4148</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">221</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">5761</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">7472</span><span class="s0">,</span><span class="s2">3104</span><span class="s0">,</span><span class="s2">541</span><span class="s0">,</span><span class="s2">1507</span><span class="s0">,</span><span class="s2">4938</span><span class="s0">],_=[</span><span class="s2">509</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">227</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">150</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">294</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">1368</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">41</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">166</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">574</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">370</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">154</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">176</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">32</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">46</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">37</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">45</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">49</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">83</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">161</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">56</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">193</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">82</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">214</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">83</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">82</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">84</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">243</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">166</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">71</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">120</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">41</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">406</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">57</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">123</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">49</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">330</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">19306</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">135</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">60</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">1014</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">82</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">19628</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">5319</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">31</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">149</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1418</span><span class="s0">,</span><span class="s2">49</span><span class="s0">,</span><span class="s2">513</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">49</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">23</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">1361</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">262</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">419</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">1495</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">110</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">4759</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">787719</span><span class="s0">,</span><span class="s2">239</span><span class="s0">];</span><span class="s1">function </span><span class="s0">L(e,t){let r=</span><span class="s2">65536</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let n=</span><span class="s2">0</span><span class="s0">,i=t.length;n&lt;i;n+=</span><span class="s2">2</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(r+=t[n],r&gt;e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(r+=t[n+</span><span class="s2">1</span><span class="s0">],r&gt;=e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}</span><span class="s1">function </span><span class="s0">M(e){</span><span class="s1">return </span><span class="s0">e&lt;</span><span class="s2">65</span><span class="s0">?</span><span class="s2">36</span><span class="s0">===e:e&lt;=</span><span class="s2">90</span><span class="s0">||(e&lt;</span><span class="s2">97</span><span class="s0">?</span><span class="s2">95</span><span class="s0">===e:e&lt;=</span><span class="s2">122</span><span class="s0">||(e&lt;=</span><span class="s2">65535</span><span class="s0">?e&gt;=</span><span class="s2">170</span><span class="s0">&amp;&amp;C.test(String.fromCharCode(e)):L(e,D)))}</span><span class="s1">function </span><span class="s0">j(e){</span><span class="s1">return </span><span class="s0">e&lt;</span><span class="s2">48</span><span class="s0">?</span><span class="s2">36</span><span class="s0">===e:e&lt;</span><span class="s2">58</span><span class="s0">||!(e&lt;</span><span class="s2">65</span><span class="s0">)&amp;&amp;(e&lt;=</span><span class="s2">90</span><span class="s0">||(e&lt;</span><span class="s2">97</span><span class="s0">?</span><span class="s2">95</span><span class="s0">===e:e&lt;=</span><span class="s2">122</span><span class="s0">||(e&lt;=</span><span class="s2">65535</span><span class="s0">?e&gt;=</span><span class="s2">170</span><span class="s0">&amp;&amp;k.test(String.fromCharCode(e)):L(e,D)||L(e,_))))}const F=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">&quot;break&quot;</span><span class="s0">,</span><span class="s3">&quot;case&quot;</span><span class="s0">,</span><span class="s3">&quot;catch&quot;</span><span class="s0">,</span><span class="s3">&quot;continue&quot;</span><span class="s0">,</span><span class="s3">&quot;debugger&quot;</span><span class="s0">,</span><span class="s3">&quot;default&quot;</span><span class="s0">,</span><span class="s3">&quot;do&quot;</span><span class="s0">,</span><span class="s3">&quot;else&quot;</span><span class="s0">,</span><span class="s3">&quot;finally&quot;</span><span class="s0">,</span><span class="s3">&quot;for&quot;</span><span class="s0">,</span><span class="s3">&quot;function&quot;</span><span class="s0">,</span><span class="s3">&quot;if&quot;</span><span class="s0">,</span><span class="s3">&quot;return&quot;</span><span class="s0">,</span><span class="s3">&quot;switch&quot;</span><span class="s0">,</span><span class="s3">&quot;throw&quot;</span><span class="s0">,</span><span class="s3">&quot;try&quot;</span><span class="s0">,</span><span class="s3">&quot;var&quot;</span><span class="s0">,</span><span class="s3">&quot;const&quot;</span><span class="s0">,</span><span class="s3">&quot;while&quot;</span><span class="s0">,</span><span class="s3">&quot;with&quot;</span><span class="s0">,</span><span class="s3">&quot;new&quot;</span><span class="s0">,</span><span class="s3">&quot;this&quot;</span><span class="s0">,</span><span class="s3">&quot;super&quot;</span><span class="s0">,</span><span class="s3">&quot;class&quot;</span><span class="s0">,</span><span class="s3">&quot;extends&quot;</span><span class="s0">,</span><span class="s3">&quot;export&quot;</span><span class="s0">,</span><span class="s3">&quot;import&quot;</span><span class="s0">,</span><span class="s3">&quot;null&quot;</span><span class="s0">,</span><span class="s3">&quot;true&quot;</span><span class="s0">,</span><span class="s3">&quot;false&quot;</span><span class="s0">,</span><span class="s3">&quot;in&quot;</span><span class="s0">,</span><span class="s3">&quot;instanceof&quot;</span><span class="s0">,</span><span class="s3">&quot;typeof&quot;</span><span class="s0">,</span><span class="s3">&quot;void&quot;</span><span class="s0">,</span><span class="s3">&quot;delete&quot;</span><span class="s0">]),B=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">&quot;implements&quot;</span><span class="s0">,</span><span class="s3">&quot;interface&quot;</span><span class="s0">,</span><span class="s3">&quot;let&quot;</span><span class="s0">,</span><span class="s3">&quot;package&quot;</span><span class="s0">,</span><span class="s3">&quot;private&quot;</span><span class="s0">,</span><span class="s3">&quot;protected&quot;</span><span class="s0">,</span><span class="s3">&quot;public&quot;</span><span class="s0">,</span><span class="s3">&quot;static&quot;</span><span class="s0">,</span><span class="s3">&quot;yield&quot;</span><span class="s0">]),R=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">&quot;eval&quot;</span><span class="s0">,</span><span class="s3">&quot;arguments&quot;</span><span class="s0">]);</span><span class="s1">function </span><span class="s0">U(e,t){</span><span class="s1">return </span><span class="s0">t&amp;&amp;</span><span class="s3">&quot;await&quot;</span><span class="s0">===e||</span><span class="s3">&quot;enum&quot;</span><span class="s0">===e}</span><span class="s1">function </span><span class="s0">V(e,t){</span><span class="s1">return </span><span class="s0">U(e,t)||B.has(e)}</span><span class="s1">function </span><span class="s0">K(e){</span><span class="s1">return </span><span class="s0">R.has(e)}</span><span class="s1">function </span><span class="s0">q(e,t){</span><span class="s1">return </span><span class="s0">V(e,t)||K(e)}</span><span class="s1">function </span><span class="s0">Y(e){</span><span class="s1">return </span><span class="s0">F.has(e)}const W=/^</span><span class="s1">in</span><span class="s0">(stanceof)?$/;class X{constructor(e){</span><span class="s1">this</span><span class="s0">.flags=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.</span><span class="s1">var</span><span class="s0">=[],</span><span class="s1">this</span><span class="s0">.lexical=[],</span><span class="s1">this</span><span class="s0">.functions=[],</span><span class="s1">this</span><span class="s0">.flags=e}}class J{constructor(e,t){</span><span class="s1">this</span><span class="s0">.scopeStack=[],</span><span class="s1">this</span><span class="s0">.undefinedExports=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.undefinedPrivateNames=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.raise=e,</span><span class="s1">this</span><span class="s0">.inModule=t}get inFunction(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">2</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentVarScope().flags)&gt;</span><span class="s2">0</span><span class="s0">}get allowSuper(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">16</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentThisScope().flags)&gt;</span><span class="s2">0</span><span class="s0">}get allowDirectSuper(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">32</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentThisScope().flags)&gt;</span><span class="s2">0</span><span class="s0">}get inClass(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">64</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentThisScope().flags)&gt;</span><span class="s2">0</span><span class="s0">}get inStaticBlock(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">128</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentThisScope().flags)&gt;</span><span class="s2">0</span><span class="s0">}get inNonArrowFunction(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">2</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentThisScope().flags)&gt;</span><span class="s2">0</span><span class="s0">}get treatFunctionsAsVar(){</span><span class="s1">return this</span><span class="s0">.treatFunctionsAsVarInScope(</span><span class="s1">this</span><span class="s0">.currentScope())}createScope(e){</span><span class="s1">return new </span><span class="s0">X(e)}enter(e){</span><span class="s1">this</span><span class="s0">.scopeStack.push(</span><span class="s1">this</span><span class="s0">.createScope(e))}exit(){</span><span class="s1">this</span><span class="s0">.scopeStack.pop()}treatFunctionsAsVarInScope(e){</span><span class="s1">return</span><span class="s0">!!(</span><span class="s2">2</span><span class="s0">&amp;e.flags||!</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;</span><span class="s2">1</span><span class="s0">&amp;e.flags)}declareName(e,t,r){let n=</span><span class="s1">this</span><span class="s0">.currentScope();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">8</span><span class="s0">&amp;t||</span><span class="s2">16</span><span class="s0">&amp;t)</span><span class="s1">this</span><span class="s0">.checkRedeclarationInScope(n,e,t,r),</span><span class="s2">16</span><span class="s0">&amp;t?n.functions.push(e):n.lexical.push(e),</span><span class="s2">8</span><span class="s0">&amp;t&amp;&amp;</span><span class="s1">this</span><span class="s0">.maybeExportDefined(n,e);</span><span class="s1">else if</span><span class="s0">(</span><span class="s2">4</span><span class="s0">&amp;t)</span><span class="s1">for</span><span class="s0">(let i=</span><span class="s1">this</span><span class="s0">.scopeStack.length-1;i&gt;=</span><span class="s2">0</span><span class="s0">&amp;&amp;(n=</span><span class="s1">this</span><span class="s0">.scopeStack[i],</span><span class="s1">this</span><span class="s0">.checkRedeclarationInScope(n,e,t,r),n.</span><span class="s1">var</span><span class="s0">.push(e),</span><span class="s1">this</span><span class="s0">.maybeExportDefined(n,e),!(</span><span class="s2">259</span><span class="s0">&amp;n.flags));--i);</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;</span><span class="s2">1</span><span class="s0">&amp;n.flags&amp;&amp;</span><span class="s1">this</span><span class="s0">.undefinedExports.</span><span class="s1">delete</span><span class="s0">(e)}maybeExportDefined(e,t){</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;</span><span class="s2">1</span><span class="s0">&amp;e.flags&amp;&amp;</span><span class="s1">this</span><span class="s0">.undefinedExports.</span><span class="s1">delete</span><span class="s0">(t)}checkRedeclarationInScope(e,t,r,n){</span><span class="s1">this</span><span class="s0">.isRedeclaredInScope(e,t,r)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(n,E.VarRedeclaration,t)}isRedeclaredInScope(e,t,r){</span><span class="s1">return</span><span class="s0">!!(</span><span class="s2">1</span><span class="s0">&amp;r)&amp;&amp;(</span><span class="s2">8</span><span class="s0">&amp;r?e.lexical.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">||e.functions.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">||e.</span><span class="s1">var</span><span class="s0">.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">:</span><span class="s2">16</span><span class="s0">&amp;r?e.lexical.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">||!</span><span class="s1">this</span><span class="s0">.treatFunctionsAsVarInScope(e)&amp;&amp;e.</span><span class="s1">var</span><span class="s0">.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">:e.lexical.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;!(</span><span class="s2">8</span><span class="s0">&amp;e.flags&amp;&amp;e.lexical[</span><span class="s2">0</span><span class="s0">]===t)||!</span><span class="s1">this</span><span class="s0">.treatFunctionsAsVarInScope(e)&amp;&amp;e.functions.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">)}checkLocalExport(e){-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.scopeStack[</span><span class="s2">0</span><span class="s0">].lexical.indexOf(e.name)&amp;&amp;-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.scopeStack[</span><span class="s2">0</span><span class="s0">].</span><span class="s1">var</span><span class="s0">.indexOf(e.name)&amp;&amp;-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.scopeStack[</span><span class="s2">0</span><span class="s0">].functions.indexOf(e.name)&amp;&amp;</span><span class="s1">this</span><span class="s0">.undefinedExports.set(e.name,e.start)}currentScope(){</span><span class="s1">return this</span><span class="s0">.scopeStack[</span><span class="s1">this</span><span class="s0">.scopeStack.length-1]}currentVarScope(){</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s1">this</span><span class="s0">.scopeStack.length-1;;e--){const t=</span><span class="s1">this</span><span class="s0">.scopeStack[e];</span><span class="s1">if</span><span class="s0">(</span><span class="s2">259</span><span class="s0">&amp;t.flags)</span><span class="s1">return </span><span class="s0">t}}currentThisScope(){</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s1">this</span><span class="s0">.scopeStack.length-1;;e--){const t=</span><span class="s1">this</span><span class="s0">.scopeStack[e];</span><span class="s1">if</span><span class="s0">((</span><span class="s2">259</span><span class="s0">&amp;t.flags||</span><span class="s2">64</span><span class="s0">&amp;t.flags)&amp;&amp;!(</span><span class="s2">4</span><span class="s0">&amp;t.flags))</span><span class="s1">return </span><span class="s0">t}}}class H extends X{constructor(...e){super(...e),</span><span class="s1">this</span><span class="s0">.declareFunctions=[]}}class G extends J{createScope(e){</span><span class="s1">return new </span><span class="s0">H(e)}declareName(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.currentScope();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">2048</span><span class="s0">&amp;t)</span><span class="s1">return this</span><span class="s0">.checkRedeclarationInScope(n,e,t,r),</span><span class="s1">this</span><span class="s0">.maybeExportDefined(n,e),</span><span class="s1">void </span><span class="s0">n.declareFunctions.push(e);super.declareName(...arguments)}isRedeclaredInScope(e,t,r){</span><span class="s1">return</span><span class="s0">!!super.isRedeclaredInScope(...arguments)||!!(</span><span class="s2">2048</span><span class="s0">&amp;r)&amp;&amp;!e.declareFunctions.includes(t)&amp;&amp;(e.lexical.includes(t)||e.functions.includes(t))}checkLocalExport(e){-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.scopeStack[</span><span class="s2">0</span><span class="s0">].declareFunctions.indexOf(e.name)&amp;&amp;super.checkLocalExport(e)}}const z=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">&quot;_&quot;</span><span class="s0">,</span><span class="s3">&quot;any&quot;</span><span class="s0">,</span><span class="s3">&quot;bool&quot;</span><span class="s0">,</span><span class="s3">&quot;boolean&quot;</span><span class="s0">,</span><span class="s3">&quot;empty&quot;</span><span class="s0">,</span><span class="s3">&quot;extends&quot;</span><span class="s0">,</span><span class="s3">&quot;false&quot;</span><span class="s0">,</span><span class="s3">&quot;interface&quot;</span><span class="s0">,</span><span class="s3">&quot;mixed&quot;</span><span class="s0">,</span><span class="s3">&quot;null&quot;</span><span class="s0">,</span><span class="s3">&quot;number&quot;</span><span class="s0">,</span><span class="s3">&quot;static&quot;</span><span class="s0">,</span><span class="s3">&quot;string&quot;</span><span class="s0">,</span><span class="s3">&quot;true&quot;</span><span class="s0">,</span><span class="s3">&quot;typeof&quot;</span><span class="s0">,</span><span class="s3">&quot;void&quot;</span><span class="s0">]),$=v({AmbiguousConditionalArrow:</span><span class="s3">&quot;Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.&quot;</span><span class="s0">,AmbiguousDeclareModuleKind:</span><span class="s3">&quot;Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.&quot;</span><span class="s0">,AssignReservedType:</span><span class="s3">&quot;Cannot overwrite reserved type %0.&quot;</span><span class="s0">,DeclareClassElement:</span><span class="s3">&quot;The `declare` modifier can only appear on class fields.&quot;</span><span class="s0">,DeclareClassFieldInitializer:</span><span class="s3">&quot;Initializers are not allowed in fields with the `declare` modifier.&quot;</span><span class="s0">,DuplicateDeclareModuleExports:</span><span class="s3">&quot;Duplicate `declare module.exports` statement.&quot;</span><span class="s0">,EnumBooleanMemberNotInitialized:</span><span class="s3">&quot;Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.&quot;</span><span class="s0">,EnumDuplicateMemberName:</span><span class="s3">&quot;Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.&quot;</span><span class="s0">,EnumInconsistentMemberValues:</span><span class="s3">&quot;Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.&quot;</span><span class="s0">,EnumInvalidExplicitType:</span><span class="s3">&quot;Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.&quot;</span><span class="s0">,EnumInvalidExplicitTypeUnknownSupplied:</span><span class="s3">&quot;Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.&quot;</span><span class="s0">,EnumInvalidMemberInitializerPrimaryType:</span><span class="s3">&quot;Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.&quot;</span><span class="s0">,EnumInvalidMemberInitializerSymbolType:</span><span class="s3">&quot;Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.&quot;</span><span class="s0">,EnumInvalidMemberInitializerUnknownType:</span><span class="s3">&quot;The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.&quot;</span><span class="s0">,EnumInvalidMemberName:</span><span class="s3">&quot;Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.&quot;</span><span class="s0">,EnumNumberMemberNotInitialized:</span><span class="s3">&quot;Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.&quot;</span><span class="s0">,EnumStringMemberInconsistentlyInitailized:</span><span class="s3">&quot;String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.&quot;</span><span class="s0">,GetterMayNotHaveThisParam:</span><span class="s3">&quot;A getter cannot have a `this` parameter.&quot;</span><span class="s0">,ImportTypeShorthandOnlyInPureImport:</span><span class="s3">&quot;The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.&quot;</span><span class="s0">,InexactInsideExact:</span><span class="s3">&quot;Explicit inexact syntax cannot appear inside an explicit exact object type.&quot;</span><span class="s0">,InexactInsideNonObject:</span><span class="s3">&quot;Explicit inexact syntax cannot appear in class or interface definitions.&quot;</span><span class="s0">,InexactVariance:</span><span class="s3">&quot;Explicit inexact syntax cannot have variance.&quot;</span><span class="s0">,InvalidNonTypeImportInDeclareModule:</span><span class="s3">&quot;Imports within a `declare module` body must always be `import type` or `import typeof`.&quot;</span><span class="s0">,MissingTypeParamDefault:</span><span class="s3">&quot;Type parameter declaration needs a default, since a preceding type parameter declaration has a default.&quot;</span><span class="s0">,NestedDeclareModule:</span><span class="s3">&quot;`declare module` cannot be used inside another `declare module`.&quot;</span><span class="s0">,NestedFlowComment:</span><span class="s3">&quot;Cannot have a flow comment inside another flow comment.&quot;</span><span class="s0">,OptionalBindingPattern:</span><span class="s3">&quot;A binding pattern parameter cannot be optional in an implementation signature.&quot;</span><span class="s0">,SetterMayNotHaveThisParam:</span><span class="s3">&quot;A setter cannot have a `this` parameter.&quot;</span><span class="s0">,SpreadVariance:</span><span class="s3">&quot;Spread properties cannot have variance.&quot;</span><span class="s0">,ThisParamAnnotationRequired:</span><span class="s3">&quot;A type annotation is required for the `this` parameter.&quot;</span><span class="s0">,ThisParamBannedInConstructor:</span><span class="s3">&quot;Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.&quot;</span><span class="s0">,ThisParamMayNotBeOptional:</span><span class="s3">&quot;The `this` parameter cannot be optional.&quot;</span><span class="s0">,ThisParamMustBeFirst:</span><span class="s3">&quot;The `this` parameter must be the first function parameter.&quot;</span><span class="s0">,ThisParamNoDefault:</span><span class="s3">&quot;The `this` parameter may not have a default value.&quot;</span><span class="s0">,TypeBeforeInitializer:</span><span class="s3">&quot;Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.&quot;</span><span class="s0">,TypeCastInPattern:</span><span class="s3">&quot;The type cast expression is expected to be wrapped with parenthesis.&quot;</span><span class="s0">,UnexpectedExplicitInexactInObject:</span><span class="s3">&quot;Explicit inexact syntax must appear at the end of an inexact object.&quot;</span><span class="s0">,UnexpectedReservedType:</span><span class="s3">&quot;Unexpected reserved type %0.&quot;</span><span class="s0">,UnexpectedReservedUnderscore:</span><span class="s3">&quot;`_` is only allowed as a type argument to call or new.&quot;</span><span class="s0">,UnexpectedSpaceBetweenModuloChecks:</span><span class="s3">&quot;Spaces between `%` and `checks` are not allowed here.&quot;</span><span class="s0">,UnexpectedSpreadType:</span><span class="s3">&quot;Spread operator cannot appear in class or interface definitions.&quot;</span><span class="s0">,UnexpectedSubtractionOperand:</span><span class="s3">'Unexpected token, expected &quot;number&quot; or &quot;bigint&quot;.'</span><span class="s0">,UnexpectedTokenAfterTypeParameter:</span><span class="s3">&quot;Expected an arrow function after this type parameter declaration.&quot;</span><span class="s0">,UnexpectedTypeParameterBeforeAsyncArrowFunction:</span><span class="s3">&quot;Type parameters must come after the async keyword, e.g. instead of `&lt;T&gt; async () =&gt; {}`, use `async &lt;T&gt;() =&gt; {}`.&quot;</span><span class="s0">,UnsupportedDeclareExportKind:</span><span class="s3">&quot;`declare export %0` is not supported. Use `%1` instead.&quot;</span><span class="s0">,UnsupportedStatementInDeclareModule:</span><span class="s3">&quot;Only declares and type imports are allowed inside declare module.&quot;</span><span class="s0">,UnterminatedFlowComment:</span><span class="s3">&quot;Unterminated flow-comment.&quot;</span><span class="s0">},x.SyntaxError);</span><span class="s1">function </span><span class="s0">Q(e){</span><span class="s1">return</span><span class="s3">&quot;type&quot;</span><span class="s0">===e.importKind||</span><span class="s3">&quot;typeof&quot;</span><span class="s0">===e.importKind}</span><span class="s1">function </span><span class="s0">Z(e){</span><span class="s1">return</span><span class="s0">(e.type===c.name||!!e.type.keyword)&amp;&amp;</span><span class="s3">&quot;from&quot;</span><span class="s0">!==e.value}const ee={const:</span><span class="s3">&quot;declare export var&quot;</span><span class="s0">,let:</span><span class="s3">&quot;declare export var&quot;</span><span class="s0">,type:</span><span class="s3">&quot;export type&quot;</span><span class="s0">,interface:</span><span class="s3">&quot;export interface&quot;</span><span class="s0">},te=/\*?\s*@((?:no)?flow)\b/,re={quot:</span><span class="s3">'&quot;'</span><span class="s0">,amp:</span><span class="s3">&quot;&amp;&quot;</span><span class="s0">,apos:</span><span class="s3">&quot;'&quot;</span><span class="s0">,lt:</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">,gt:</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">,nbsp:</span><span class="s3">&quot; &quot;</span><span class="s0">,iexcl:</span><span class="s3">&quot;¡&quot;</span><span class="s0">,cent:</span><span class="s3">&quot;¢&quot;</span><span class="s0">,pound:</span><span class="s3">&quot;£&quot;</span><span class="s0">,curren:</span><span class="s3">&quot;¤&quot;</span><span class="s0">,yen:</span><span class="s3">&quot;¥&quot;</span><span class="s0">,brvbar:</span><span class="s3">&quot;¦&quot;</span><span class="s0">,sect:</span><span class="s3">&quot;§&quot;</span><span class="s0">,uml:</span><span class="s3">&quot;¨&quot;</span><span class="s0">,copy:</span><span class="s3">&quot;©&quot;</span><span class="s0">,ordf:</span><span class="s3">&quot;ª&quot;</span><span class="s0">,laquo:</span><span class="s3">&quot;«&quot;</span><span class="s0">,not:</span><span class="s3">&quot;¬&quot;</span><span class="s0">,shy:</span><span class="s3">&quot;­&quot;</span><span class="s0">,reg:</span><span class="s3">&quot;®&quot;</span><span class="s0">,macr:</span><span class="s3">&quot;¯&quot;</span><span class="s0">,deg:</span><span class="s3">&quot;°&quot;</span><span class="s0">,plusmn:</span><span class="s3">&quot;±&quot;</span><span class="s0">,sup2:</span><span class="s3">&quot;²&quot;</span><span class="s0">,sup3:</span><span class="s3">&quot;³&quot;</span><span class="s0">,acute:</span><span class="s3">&quot;´&quot;</span><span class="s0">,micro:</span><span class="s3">&quot;µ&quot;</span><span class="s0">,para:</span><span class="s3">&quot;¶&quot;</span><span class="s0">,middot:</span><span class="s3">&quot;·&quot;</span><span class="s0">,cedil:</span><span class="s3">&quot;¸&quot;</span><span class="s0">,sup1:</span><span class="s3">&quot;¹&quot;</span><span class="s0">,ordm:</span><span class="s3">&quot;º&quot;</span><span class="s0">,raquo:</span><span class="s3">&quot;»&quot;</span><span class="s0">,frac14:</span><span class="s3">&quot;¼&quot;</span><span class="s0">,frac12:</span><span class="s3">&quot;½&quot;</span><span class="s0">,frac34:</span><span class="s3">&quot;¾&quot;</span><span class="s0">,iquest:</span><span class="s3">&quot;¿&quot;</span><span class="s0">,Agrave:</span><span class="s3">&quot;À&quot;</span><span class="s0">,Aacute:</span><span class="s3">&quot;Á&quot;</span><span class="s0">,Acirc:</span><span class="s3">&quot;Â&quot;</span><span class="s0">,Atilde:</span><span class="s3">&quot;Ã&quot;</span><span class="s0">,Auml:</span><span class="s3">&quot;Ä&quot;</span><span class="s0">,Aring:</span><span class="s3">&quot;Å&quot;</span><span class="s0">,AElig:</span><span class="s3">&quot;Æ&quot;</span><span class="s0">,Ccedil:</span><span class="s3">&quot;Ç&quot;</span><span class="s0">,Egrave:</span><span class="s3">&quot;È&quot;</span><span class="s0">,Eacute:</span><span class="s3">&quot;É&quot;</span><span class="s0">,Ecirc:</span><span class="s3">&quot;Ê&quot;</span><span class="s0">,Euml:</span><span class="s3">&quot;Ë&quot;</span><span class="s0">,Igrave:</span><span class="s3">&quot;Ì&quot;</span><span class="s0">,Iacute:</span><span class="s3">&quot;Í&quot;</span><span class="s0">,Icirc:</span><span class="s3">&quot;Î&quot;</span><span class="s0">,Iuml:</span><span class="s3">&quot;Ï&quot;</span><span class="s0">,ETH:</span><span class="s3">&quot;Ð&quot;</span><span class="s0">,Ntilde:</span><span class="s3">&quot;Ñ&quot;</span><span class="s0">,Ograve:</span><span class="s3">&quot;Ò&quot;</span><span class="s0">,Oacute:</span><span class="s3">&quot;Ó&quot;</span><span class="s0">,Ocirc:</span><span class="s3">&quot;Ô&quot;</span><span class="s0">,Otilde:</span><span class="s3">&quot;Õ&quot;</span><span class="s0">,Ouml:</span><span class="s3">&quot;Ö&quot;</span><span class="s0">,times:</span><span class="s3">&quot;×&quot;</span><span class="s0">,Oslash:</span><span class="s3">&quot;Ø&quot;</span><span class="s0">,Ugrave:</span><span class="s3">&quot;Ù&quot;</span><span class="s0">,Uacute:</span><span class="s3">&quot;Ú&quot;</span><span class="s0">,Ucirc:</span><span class="s3">&quot;Û&quot;</span><span class="s0">,Uuml:</span><span class="s3">&quot;Ü&quot;</span><span class="s0">,Yacute:</span><span class="s3">&quot;Ý&quot;</span><span class="s0">,THORN:</span><span class="s3">&quot;Þ&quot;</span><span class="s0">,szlig:</span><span class="s3">&quot;ß&quot;</span><span class="s0">,agrave:</span><span class="s3">&quot;à&quot;</span><span class="s0">,aacute:</span><span class="s3">&quot;á&quot;</span><span class="s0">,acirc:</span><span class="s3">&quot;â&quot;</span><span class="s0">,atilde:</span><span class="s3">&quot;ã&quot;</span><span class="s0">,auml:</span><span class="s3">&quot;ä&quot;</span><span class="s0">,aring:</span><span class="s3">&quot;å&quot;</span><span class="s0">,aelig:</span><span class="s3">&quot;æ&quot;</span><span class="s0">,ccedil:</span><span class="s3">&quot;ç&quot;</span><span class="s0">,egrave:</span><span class="s3">&quot;è&quot;</span><span class="s0">,eacute:</span><span class="s3">&quot;é&quot;</span><span class="s0">,ecirc:</span><span class="s3">&quot;ê&quot;</span><span class="s0">,euml:</span><span class="s3">&quot;ë&quot;</span><span class="s0">,igrave:</span><span class="s3">&quot;ì&quot;</span><span class="s0">,iacute:</span><span class="s3">&quot;í&quot;</span><span class="s0">,icirc:</span><span class="s3">&quot;î&quot;</span><span class="s0">,iuml:</span><span class="s3">&quot;ï&quot;</span><span class="s0">,eth:</span><span class="s3">&quot;ð&quot;</span><span class="s0">,ntilde:</span><span class="s3">&quot;ñ&quot;</span><span class="s0">,ograve:</span><span class="s3">&quot;ò&quot;</span><span class="s0">,oacute:</span><span class="s3">&quot;ó&quot;</span><span class="s0">,ocirc:</span><span class="s3">&quot;ô&quot;</span><span class="s0">,otilde:</span><span class="s3">&quot;õ&quot;</span><span class="s0">,ouml:</span><span class="s3">&quot;ö&quot;</span><span class="s0">,divide:</span><span class="s3">&quot;÷&quot;</span><span class="s0">,oslash:</span><span class="s3">&quot;ø&quot;</span><span class="s0">,ugrave:</span><span class="s3">&quot;ù&quot;</span><span class="s0">,uacute:</span><span class="s3">&quot;ú&quot;</span><span class="s0">,ucirc:</span><span class="s3">&quot;û&quot;</span><span class="s0">,uuml:</span><span class="s3">&quot;ü&quot;</span><span class="s0">,yacute:</span><span class="s3">&quot;ý&quot;</span><span class="s0">,thorn:</span><span class="s3">&quot;þ&quot;</span><span class="s0">,yuml:</span><span class="s3">&quot;ÿ&quot;</span><span class="s0">,OElig:</span><span class="s3">&quot;Œ&quot;</span><span class="s0">,oelig:</span><span class="s3">&quot;œ&quot;</span><span class="s0">,Scaron:</span><span class="s3">&quot;Š&quot;</span><span class="s0">,scaron:</span><span class="s3">&quot;š&quot;</span><span class="s0">,Yuml:</span><span class="s3">&quot;Ÿ&quot;</span><span class="s0">,fnof:</span><span class="s3">&quot;ƒ&quot;</span><span class="s0">,circ:</span><span class="s3">&quot;ˆ&quot;</span><span class="s0">,tilde:</span><span class="s3">&quot;˜&quot;</span><span class="s0">,Alpha:</span><span class="s3">&quot;Α&quot;</span><span class="s0">,Beta:</span><span class="s3">&quot;Β&quot;</span><span class="s0">,Gamma:</span><span class="s3">&quot;Γ&quot;</span><span class="s0">,Delta:</span><span class="s3">&quot;Δ&quot;</span><span class="s0">,Epsilon:</span><span class="s3">&quot;Ε&quot;</span><span class="s0">,Zeta:</span><span class="s3">&quot;Ζ&quot;</span><span class="s0">,Eta:</span><span class="s3">&quot;Η&quot;</span><span class="s0">,Theta:</span><span class="s3">&quot;Θ&quot;</span><span class="s0">,Iota:</span><span class="s3">&quot;Ι&quot;</span><span class="s0">,Kappa:</span><span class="s3">&quot;Κ&quot;</span><span class="s0">,Lambda:</span><span class="s3">&quot;Λ&quot;</span><span class="s0">,Mu:</span><span class="s3">&quot;Μ&quot;</span><span class="s0">,Nu:</span><span class="s3">&quot;Ν&quot;</span><span class="s0">,Xi:</span><span class="s3">&quot;Ξ&quot;</span><span class="s0">,Omicron:</span><span class="s3">&quot;Ο&quot;</span><span class="s0">,Pi:</span><span class="s3">&quot;Π&quot;</span><span class="s0">,Rho:</span><span class="s3">&quot;Ρ&quot;</span><span class="s0">,Sigma:</span><span class="s3">&quot;Σ&quot;</span><span class="s0">,Tau:</span><span class="s3">&quot;Τ&quot;</span><span class="s0">,Upsilon:</span><span class="s3">&quot;Υ&quot;</span><span class="s0">,Phi:</span><span class="s3">&quot;Φ&quot;</span><span class="s0">,Chi:</span><span class="s3">&quot;Χ&quot;</span><span class="s0">,Psi:</span><span class="s3">&quot;Ψ&quot;</span><span class="s0">,Omega:</span><span class="s3">&quot;Ω&quot;</span><span class="s0">,alpha:</span><span class="s3">&quot;α&quot;</span><span class="s0">,beta:</span><span class="s3">&quot;β&quot;</span><span class="s0">,gamma:</span><span class="s3">&quot;γ&quot;</span><span class="s0">,delta:</span><span class="s3">&quot;δ&quot;</span><span class="s0">,epsilon:</span><span class="s3">&quot;ε&quot;</span><span class="s0">,zeta:</span><span class="s3">&quot;ζ&quot;</span><span class="s0">,eta:</span><span class="s3">&quot;η&quot;</span><span class="s0">,theta:</span><span class="s3">&quot;θ&quot;</span><span class="s0">,iota:</span><span class="s3">&quot;ι&quot;</span><span class="s0">,kappa:</span><span class="s3">&quot;κ&quot;</span><span class="s0">,lambda:</span><span class="s3">&quot;λ&quot;</span><span class="s0">,mu:</span><span class="s3">&quot;μ&quot;</span><span class="s0">,nu:</span><span class="s3">&quot;ν&quot;</span><span class="s0">,xi:</span><span class="s3">&quot;ξ&quot;</span><span class="s0">,omicron:</span><span class="s3">&quot;ο&quot;</span><span class="s0">,pi:</span><span class="s3">&quot;π&quot;</span><span class="s0">,rho:</span><span class="s3">&quot;ρ&quot;</span><span class="s0">,sigmaf:</span><span class="s3">&quot;ς&quot;</span><span class="s0">,sigma:</span><span class="s3">&quot;σ&quot;</span><span class="s0">,tau:</span><span class="s3">&quot;τ&quot;</span><span class="s0">,upsilon:</span><span class="s3">&quot;υ&quot;</span><span class="s0">,phi:</span><span class="s3">&quot;φ&quot;</span><span class="s0">,chi:</span><span class="s3">&quot;χ&quot;</span><span class="s0">,psi:</span><span class="s3">&quot;ψ&quot;</span><span class="s0">,omega:</span><span class="s3">&quot;ω&quot;</span><span class="s0">,thetasym:</span><span class="s3">&quot;ϑ&quot;</span><span class="s0">,upsih:</span><span class="s3">&quot;ϒ&quot;</span><span class="s0">,piv:</span><span class="s3">&quot;ϖ&quot;</span><span class="s0">,ensp:</span><span class="s3">&quot; &quot;</span><span class="s0">,emsp:</span><span class="s3">&quot; &quot;</span><span class="s0">,thinsp:</span><span class="s3">&quot; &quot;</span><span class="s0">,zwnj:</span><span class="s3">&quot;‌&quot;</span><span class="s0">,zwj:</span><span class="s3">&quot;‍&quot;</span><span class="s0">,lrm:</span><span class="s3">&quot;‎&quot;</span><span class="s0">,rlm:</span><span class="s3">&quot;‏&quot;</span><span class="s0">,ndash:</span><span class="s3">&quot;–&quot;</span><span class="s0">,mdash:</span><span class="s3">&quot;—&quot;</span><span class="s0">,lsquo:</span><span class="s3">&quot;‘&quot;</span><span class="s0">,rsquo:</span><span class="s3">&quot;’&quot;</span><span class="s0">,sbquo:</span><span class="s3">&quot;‚&quot;</span><span class="s0">,ldquo:</span><span class="s3">&quot;“&quot;</span><span class="s0">,rdquo:</span><span class="s3">&quot;”&quot;</span><span class="s0">,bdquo:</span><span class="s3">&quot;„&quot;</span><span class="s0">,dagger:</span><span class="s3">&quot;†&quot;</span><span class="s0">,Dagger:</span><span class="s3">&quot;‡&quot;</span><span class="s0">,bull:</span><span class="s3">&quot;•&quot;</span><span class="s0">,hellip:</span><span class="s3">&quot;…&quot;</span><span class="s0">,permil:</span><span class="s3">&quot;‰&quot;</span><span class="s0">,prime:</span><span class="s3">&quot;′&quot;</span><span class="s0">,Prime:</span><span class="s3">&quot;″&quot;</span><span class="s0">,lsaquo:</span><span class="s3">&quot;‹&quot;</span><span class="s0">,rsaquo:</span><span class="s3">&quot;›&quot;</span><span class="s0">,oline:</span><span class="s3">&quot;‾&quot;</span><span class="s0">,frasl:</span><span class="s3">&quot;⁄&quot;</span><span class="s0">,euro:</span><span class="s3">&quot;€&quot;</span><span class="s0">,image:</span><span class="s3">&quot;ℑ&quot;</span><span class="s0">,weierp:</span><span class="s3">&quot;℘&quot;</span><span class="s0">,real:</span><span class="s3">&quot;ℜ&quot;</span><span class="s0">,trade:</span><span class="s3">&quot;™&quot;</span><span class="s0">,alefsym:</span><span class="s3">&quot;ℵ&quot;</span><span class="s0">,larr:</span><span class="s3">&quot;←&quot;</span><span class="s0">,uarr:</span><span class="s3">&quot;↑&quot;</span><span class="s0">,rarr:</span><span class="s3">&quot;→&quot;</span><span class="s0">,darr:</span><span class="s3">&quot;↓&quot;</span><span class="s0">,harr:</span><span class="s3">&quot;↔&quot;</span><span class="s0">,crarr:</span><span class="s3">&quot;↵&quot;</span><span class="s0">,lArr:</span><span class="s3">&quot;⇐&quot;</span><span class="s0">,uArr:</span><span class="s3">&quot;⇑&quot;</span><span class="s0">,rArr:</span><span class="s3">&quot;⇒&quot;</span><span class="s0">,dArr:</span><span class="s3">&quot;⇓&quot;</span><span class="s0">,hArr:</span><span class="s3">&quot;⇔&quot;</span><span class="s0">,forall:</span><span class="s3">&quot;∀&quot;</span><span class="s0">,part:</span><span class="s3">&quot;∂&quot;</span><span class="s0">,exist:</span><span class="s3">&quot;∃&quot;</span><span class="s0">,empty:</span><span class="s3">&quot;∅&quot;</span><span class="s0">,nabla:</span><span class="s3">&quot;∇&quot;</span><span class="s0">,isin:</span><span class="s3">&quot;∈&quot;</span><span class="s0">,notin:</span><span class="s3">&quot;∉&quot;</span><span class="s0">,ni:</span><span class="s3">&quot;∋&quot;</span><span class="s0">,prod:</span><span class="s3">&quot;∏&quot;</span><span class="s0">,sum:</span><span class="s3">&quot;∑&quot;</span><span class="s0">,minus:</span><span class="s3">&quot;−&quot;</span><span class="s0">,lowast:</span><span class="s3">&quot;∗&quot;</span><span class="s0">,radic:</span><span class="s3">&quot;√&quot;</span><span class="s0">,prop:</span><span class="s3">&quot;∝&quot;</span><span class="s0">,infin:</span><span class="s3">&quot;∞&quot;</span><span class="s0">,ang:</span><span class="s3">&quot;∠&quot;</span><span class="s0">,and:</span><span class="s3">&quot;∧&quot;</span><span class="s0">,or:</span><span class="s3">&quot;∨&quot;</span><span class="s0">,cap:</span><span class="s3">&quot;∩&quot;</span><span class="s0">,cup:</span><span class="s3">&quot;∪&quot;</span><span class="s0">,int:</span><span class="s3">&quot;∫&quot;</span><span class="s0">,there4:</span><span class="s3">&quot;∴&quot;</span><span class="s0">,sim:</span><span class="s3">&quot;∼&quot;</span><span class="s0">,cong:</span><span class="s3">&quot;≅&quot;</span><span class="s0">,asymp:</span><span class="s3">&quot;≈&quot;</span><span class="s0">,ne:</span><span class="s3">&quot;≠&quot;</span><span class="s0">,equiv:</span><span class="s3">&quot;≡&quot;</span><span class="s0">,le:</span><span class="s3">&quot;≤&quot;</span><span class="s0">,ge:</span><span class="s3">&quot;≥&quot;</span><span class="s0">,sub:</span><span class="s3">&quot;⊂&quot;</span><span class="s0">,sup:</span><span class="s3">&quot;⊃&quot;</span><span class="s0">,nsub:</span><span class="s3">&quot;⊄&quot;</span><span class="s0">,sube:</span><span class="s3">&quot;⊆&quot;</span><span class="s0">,supe:</span><span class="s3">&quot;⊇&quot;</span><span class="s0">,oplus:</span><span class="s3">&quot;⊕&quot;</span><span class="s0">,otimes:</span><span class="s3">&quot;⊗&quot;</span><span class="s0">,perp:</span><span class="s3">&quot;⊥&quot;</span><span class="s0">,sdot:</span><span class="s3">&quot;⋅&quot;</span><span class="s0">,lceil:</span><span class="s3">&quot;⌈&quot;</span><span class="s0">,rceil:</span><span class="s3">&quot;⌉&quot;</span><span class="s0">,lfloor:</span><span class="s3">&quot;⌊&quot;</span><span class="s0">,rfloor:</span><span class="s3">&quot;⌋&quot;</span><span class="s0">,lang:</span><span class="s3">&quot;〈&quot;</span><span class="s0">,rang:</span><span class="s3">&quot;〉&quot;</span><span class="s0">,loz:</span><span class="s3">&quot;◊&quot;</span><span class="s0">,spades:</span><span class="s3">&quot;♠&quot;</span><span class="s0">,clubs:</span><span class="s3">&quot;♣&quot;</span><span class="s0">,hearts:</span><span class="s3">&quot;♥&quot;</span><span class="s0">,diams:</span><span class="s3">&quot;♦&quot;</span><span class="s0">},ne=/^[\da-fA-F]+$/,ie=/^\d+$/,se=v({AttributeIsEmpty:</span><span class="s3">&quot;JSX attributes must only be assigned a non-empty expression.&quot;</span><span class="s0">,MissingClosingTagElement:</span><span class="s3">&quot;Expected corresponding JSX closing tag for &lt;%0&gt;.&quot;</span><span class="s0">,MissingClosingTagFragment:</span><span class="s3">&quot;Expected corresponding JSX closing tag for &lt;&gt;.&quot;</span><span class="s0">,UnexpectedSequenceExpression:</span><span class="s3">&quot;Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?&quot;</span><span class="s0">,UnsupportedJsxValue:</span><span class="s3">&quot;JSX value should be either an expression or a quoted JSX text.&quot;</span><span class="s0">,UnterminatedJsxContent:</span><span class="s3">&quot;Unterminated JSX contents.&quot;</span><span class="s0">,UnwrappedAdjacentJSXElements:</span><span class="s3">&quot;Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment &lt;&gt;...&lt;/&gt;?&quot;</span><span class="s0">},x.SyntaxError);</span><span class="s1">function </span><span class="s0">ae(e){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXOpeningFragment&quot;</span><span class="s0">===e.type||</span><span class="s3">&quot;JSXClosingFragment&quot;</span><span class="s0">===e.type)}</span><span class="s1">function </span><span class="s0">oe(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">===e.type)</span><span class="s1">return </span><span class="s0">e.name;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">===e.type)</span><span class="s1">return </span><span class="s0">e.namespace.name+</span><span class="s3">&quot;:&quot;</span><span class="s0">+e.name.name;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s0">===e.type)</span><span class="s1">return </span><span class="s0">oe(e.object)+</span><span class="s3">&quot;.&quot;</span><span class="s0">+oe(e.property);</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Node had unexpected type: &quot;</span><span class="s0">+e.type)}O.j_oTag=</span><span class="s1">new </span><span class="s0">w(</span><span class="s3">&quot;&lt;tag&quot;</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),O.j_cTag=</span><span class="s1">new </span><span class="s0">w(</span><span class="s3">&quot;&lt;/tag&quot;</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),O.j_expr=</span><span class="s1">new </span><span class="s0">w(</span><span class="s3">&quot;&lt;tag&gt;...&lt;/tag&gt;&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),c.jsxName=</span><span class="s1">new </span><span class="s0">a(</span><span class="s3">&quot;jsxName&quot;</span><span class="s0">),c.jsxText=</span><span class="s1">new </span><span class="s0">a(</span><span class="s3">&quot;jsxText&quot;</span><span class="s0">,{beforeExpr:!</span><span class="s2">0</span><span class="s0">}),c.jsxTagStart=</span><span class="s1">new </span><span class="s0">a(</span><span class="s3">&quot;jsxTagStart&quot;</span><span class="s0">,{startsExpr:!</span><span class="s2">0</span><span class="s0">}),c.jsxTagEnd=</span><span class="s1">new </span><span class="s0">a(</span><span class="s3">&quot;jsxTagEnd&quot;</span><span class="s0">),c.jsxTagStart.updateContext=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">.state.context.push(O.j_expr),</span><span class="s1">this</span><span class="s0">.state.context.push(O.j_oTag),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">},c.jsxTagEnd.updateContext=</span><span class="s1">function</span><span class="s0">(e){const t=</span><span class="s1">this</span><span class="s0">.state.context.pop();t===O.j_oTag&amp;&amp;e===c.slash||t===O.j_cTag?(</span><span class="s1">this</span><span class="s0">.state.context.pop(),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=</span><span class="s1">this</span><span class="s0">.curContext()===O.j_expr):</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">0</span><span class="s0">};class le extends X{constructor(...e){super(...e),</span><span class="s1">this</span><span class="s0">.types=[],</span><span class="s1">this</span><span class="s0">.enums=[],</span><span class="s1">this</span><span class="s0">.constEnums=[],</span><span class="s1">this</span><span class="s0">.classes=[],</span><span class="s1">this</span><span class="s0">.exportOnlyBindings=[]}}class pe extends J{createScope(e){</span><span class="s1">return new </span><span class="s0">le(e)}declareName(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.currentScope();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">1024</span><span class="s0">&amp;t)</span><span class="s1">return this</span><span class="s0">.maybeExportDefined(n,e),</span><span class="s1">void </span><span class="s0">n.exportOnlyBindings.push(e);super.declareName(...arguments),</span><span class="s2">2</span><span class="s0">&amp;t&amp;&amp;(</span><span class="s2">1</span><span class="s0">&amp;t||(</span><span class="s1">this</span><span class="s0">.checkRedeclarationInScope(n,e,t,r),</span><span class="s1">this</span><span class="s0">.maybeExportDefined(n,e)),n.types.push(e)),</span><span class="s2">256</span><span class="s0">&amp;t&amp;&amp;n.enums.push(e),</span><span class="s2">512</span><span class="s0">&amp;t&amp;&amp;n.constEnums.push(e),</span><span class="s2">128</span><span class="s0">&amp;t&amp;&amp;n.classes.push(e)}isRedeclaredInScope(e,t,r){</span><span class="s1">return </span><span class="s0">e.enums.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">?!(</span><span class="s2">256</span><span class="s0">&amp;r)||!!(</span><span class="s2">512</span><span class="s0">&amp;r)!=e.constEnums.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">:</span><span class="s2">128</span><span class="s0">&amp;r&amp;&amp;e.classes.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">?e.lexical.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;!!(</span><span class="s2">1</span><span class="s0">&amp;r):!!(</span><span class="s2">2</span><span class="s0">&amp;r&amp;&amp;e.types.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">)||super.isRedeclaredInScope(...arguments)}checkLocalExport(e){-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.scopeStack[</span><span class="s2">0</span><span class="s0">].types.indexOf(e.name)&amp;&amp;-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.scopeStack[</span><span class="s2">0</span><span class="s0">].exportOnlyBindings.indexOf(e.name)&amp;&amp;super.checkLocalExport(e)}}class ce{constructor(){</span><span class="s1">this</span><span class="s0">.stacks=[]}enter(e){</span><span class="s1">this</span><span class="s0">.stacks.push(e)}exit(){</span><span class="s1">this</span><span class="s0">.stacks.pop()}currentFlags(){</span><span class="s1">return this</span><span class="s0">.stacks[</span><span class="s1">this</span><span class="s0">.stacks.length-1]}get hasAwait(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">2</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentFlags())&gt;</span><span class="s2">0</span><span class="s0">}get hasYield(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">1</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentFlags())&gt;</span><span class="s2">0</span><span class="s0">}get hasReturn(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">4</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentFlags())&gt;</span><span class="s2">0</span><span class="s0">}get hasIn(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">8</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentFlags())&gt;</span><span class="s2">0</span><span class="s0">}}</span><span class="s1">function </span><span class="s0">ue(e,t){</span><span class="s1">return</span><span class="s0">(e?</span><span class="s2">2</span><span class="s0">:</span><span class="s2">0</span><span class="s0">)|(t?</span><span class="s2">1</span><span class="s0">:</span><span class="s2">0</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">de(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==e)</span><span class="s1">throw new </span><span class="s0">Error(`Unexpected ${e} value.`);</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">function </span><span class="s0">he(e){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Assert fail&quot;</span><span class="s0">)}const fe=v({AbstractMethodHasImplementation:</span><span class="s3">&quot;Method '%0' cannot have an implementation because it is marked abstract.&quot;</span><span class="s0">,AccesorCannotDeclareThisParameter:</span><span class="s3">&quot;'get' and 'set' accessors cannot declare 'this' parameters.&quot;</span><span class="s0">,AccesorCannotHaveTypeParameters:</span><span class="s3">&quot;An accessor cannot have type parameters.&quot;</span><span class="s0">,ClassMethodHasDeclare:</span><span class="s3">&quot;Class methods cannot have the 'declare' modifier.&quot;</span><span class="s0">,ClassMethodHasReadonly:</span><span class="s3">&quot;Class methods cannot have the 'readonly' modifier.&quot;</span><span class="s0">,ConstructorHasTypeParameters:</span><span class="s3">&quot;Type parameters cannot appear on a constructor declaration.&quot;</span><span class="s0">,DeclareAccessor:</span><span class="s3">&quot;'declare' is not allowed in %0ters.&quot;</span><span class="s0">,DeclareClassFieldHasInitializer:</span><span class="s3">&quot;Initializers are not allowed in ambient contexts.&quot;</span><span class="s0">,DeclareFunctionHasImplementation:</span><span class="s3">&quot;An implementation cannot be declared in ambient contexts.&quot;</span><span class="s0">,DuplicateAccessibilityModifier:</span><span class="s3">&quot;Accessibility modifier already seen.&quot;</span><span class="s0">,DuplicateModifier:</span><span class="s3">&quot;Duplicate modifier: '%0'.&quot;</span><span class="s0">,EmptyHeritageClauseType:</span><span class="s3">&quot;'%0' list cannot be empty.&quot;</span><span class="s0">,EmptyTypeArguments:</span><span class="s3">&quot;Type argument list cannot be empty.&quot;</span><span class="s0">,EmptyTypeParameters:</span><span class="s3">&quot;Type parameter list cannot be empty.&quot;</span><span class="s0">,ExpectedAmbientAfterExportDeclare:</span><span class="s3">&quot;'export declare' must be followed by an ambient declaration.&quot;</span><span class="s0">,ImportAliasHasImportType:</span><span class="s3">&quot;An import alias can not use 'import type'.&quot;</span><span class="s0">,IncompatibleModifiers:</span><span class="s3">&quot;'%0' modifier cannot be used with '%1' modifier.&quot;</span><span class="s0">,IndexSignatureHasAbstract:</span><span class="s3">&quot;Index signatures cannot have the 'abstract' modifier.&quot;</span><span class="s0">,IndexSignatureHasAccessibility:</span><span class="s3">&quot;Index signatures cannot have an accessibility modifier ('%0').&quot;</span><span class="s0">,IndexSignatureHasDeclare:</span><span class="s3">&quot;Index signatures cannot have the 'declare' modifier.&quot;</span><span class="s0">,IndexSignatureHasOverride:</span><span class="s3">&quot;'override' modifier cannot appear on an index signature.&quot;</span><span class="s0">,IndexSignatureHasStatic:</span><span class="s3">&quot;Index signatures cannot have the 'static' modifier.&quot;</span><span class="s0">,InvalidModifierOnTypeMember:</span><span class="s3">&quot;'%0' modifier cannot appear on a type member.&quot;</span><span class="s0">,InvalidModifiersOrder:</span><span class="s3">&quot;'%0' modifier must precede '%1' modifier.&quot;</span><span class="s0">,InvalidTupleMemberLabel:</span><span class="s3">&quot;Tuple members must be labeled with a simple identifier.&quot;</span><span class="s0">,MixedLabeledAndUnlabeledElements:</span><span class="s3">&quot;Tuple members must all have names or all not have names.&quot;</span><span class="s0">,NonAbstractClassHasAbstractMethod:</span><span class="s3">&quot;Abstract methods can only appear within an abstract class.&quot;</span><span class="s0">,NonClassMethodPropertyHasAbstractModifer:</span><span class="s3">&quot;'abstract' modifier can only appear on a class, method, or property declaration.&quot;</span><span class="s0">,OptionalTypeBeforeRequired:</span><span class="s3">&quot;A required element cannot follow an optional element.&quot;</span><span class="s0">,OverrideNotInSubClass:</span><span class="s3">&quot;This member cannot have an 'override' modifier because its containing class does not extend another class.&quot;</span><span class="s0">,PatternIsOptional:</span><span class="s3">&quot;A binding pattern parameter cannot be optional in an implementation signature.&quot;</span><span class="s0">,PrivateElementHasAbstract:</span><span class="s3">&quot;Private elements cannot have the 'abstract' modifier.&quot;</span><span class="s0">,PrivateElementHasAccessibility:</span><span class="s3">&quot;Private elements cannot have an accessibility modifier ('%0').&quot;</span><span class="s0">,ReadonlyForMethodSignature:</span><span class="s3">&quot;'readonly' modifier can only appear on a property declaration or index signature.&quot;</span><span class="s0">,SetAccesorCannotHaveOptionalParameter:</span><span class="s3">&quot;A 'set' accessor cannot have an optional parameter.&quot;</span><span class="s0">,SetAccesorCannotHaveRestParameter:</span><span class="s3">&quot;A 'set' accessor cannot have rest parameter.&quot;</span><span class="s0">,SetAccesorCannotHaveReturnType:</span><span class="s3">&quot;A 'set' accessor cannot have a return type annotation.&quot;</span><span class="s0">,StaticBlockCannotHaveModifier:</span><span class="s3">&quot;Static class blocks cannot have any modifier.&quot;</span><span class="s0">,TypeAnnotationAfterAssign:</span><span class="s3">&quot;Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.&quot;</span><span class="s0">,TypeImportCannotSpecifyDefaultAndNamed:</span><span class="s3">&quot;A type-only import can specify a default import or named bindings, but not both.&quot;</span><span class="s0">,UnexpectedParameterModifier:</span><span class="s3">&quot;A parameter property is only allowed in a constructor implementation.&quot;</span><span class="s0">,UnexpectedReadonly:</span><span class="s3">&quot;'readonly' type modifier is only permitted on array and tuple literal types.&quot;</span><span class="s0">,UnexpectedTypeAnnotation:</span><span class="s3">&quot;Did not expect a type annotation here.&quot;</span><span class="s0">,UnexpectedTypeCastInParameter:</span><span class="s3">&quot;Unexpected type cast in parameter position.&quot;</span><span class="s0">,UnsupportedImportTypeArgument:</span><span class="s3">&quot;Argument in a type import must be a string literal.&quot;</span><span class="s0">,UnsupportedParameterPropertyKind:</span><span class="s3">&quot;A parameter property may not be declared using a binding pattern.&quot;</span><span class="s0">,UnsupportedSignatureParameterKind:</span><span class="s3">&quot;Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0.&quot;</span><span class="s0">},x.SyntaxError);</span><span class="s1">function </span><span class="s0">me(e){</span><span class="s1">return</span><span class="s3">&quot;private&quot;</span><span class="s0">===e||</span><span class="s3">&quot;public&quot;</span><span class="s0">===e||</span><span class="s3">&quot;protected&quot;</span><span class="s0">===e}c.placeholder=</span><span class="s1">new </span><span class="s0">a(</span><span class="s3">&quot;%%&quot;</span><span class="s0">,{startsExpr:!</span><span class="s2">0</span><span class="s0">});const ye=v({ClassNameIsRequired:</span><span class="s3">&quot;A class name is required.&quot;</span><span class="s0">},x.SyntaxError);</span><span class="s1">function </span><span class="s0">Te(e,t){</span><span class="s1">return </span><span class="s0">e.some((e=&gt;Array.isArray(e)?e[</span><span class="s2">0</span><span class="s0">]===t:e===t))}</span><span class="s1">function </span><span class="s0">be(e,t,r){const n=e.find((e=&gt;Array.isArray(e)?e[</span><span class="s2">0</span><span class="s0">]===t:e===t));</span><span class="s1">return </span><span class="s0">n&amp;&amp;Array.isArray(n)?n[</span><span class="s2">1</span><span class="s0">][r]:</span><span class="s1">null</span><span class="s0">}const ge=[</span><span class="s3">&quot;minimal&quot;</span><span class="s0">,</span><span class="s3">&quot;smart&quot;</span><span class="s0">,</span><span class="s3">&quot;fsharp&quot;</span><span class="s0">],Se=[</span><span class="s3">&quot;hash&quot;</span><span class="s0">,</span><span class="s3">&quot;bar&quot;</span><span class="s0">],xe={estree:e=&gt;class extends e{estreeParseRegExpLiteral({pattern:e,flags:t}){let r=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{r=</span><span class="s1">new </span><span class="s0">RegExp(e,t)}</span><span class="s1">catch</span><span class="s0">(e){}const n=</span><span class="s1">this</span><span class="s0">.estreeParseLiteral(r);</span><span class="s1">return </span><span class="s0">n.regex={pattern:e,flags:t},n}estreeParseBigIntLiteral(e){let t;</span><span class="s1">try</span><span class="s0">{t=BigInt(e)}</span><span class="s1">catch</span><span class="s0">(e){t=</span><span class="s1">null</span><span class="s0">}const r=</span><span class="s1">this</span><span class="s0">.estreeParseLiteral(t);</span><span class="s1">return </span><span class="s0">r.bigint=String(r.value||e),r}estreeParseDecimalLiteral(e){const t=</span><span class="s1">this</span><span class="s0">.estreeParseLiteral(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">return </span><span class="s0">t.decimal=String(t.value||e),t}estreeParseLiteral(e){</span><span class="s1">return this</span><span class="s0">.parseLiteral(e,</span><span class="s3">&quot;Literal&quot;</span><span class="s0">)}directiveToStmt(e){const t=e.value,r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e.start,e.loc.start),n=</span><span class="s1">this</span><span class="s0">.startNodeAt(t.start,t.loc.start);</span><span class="s1">return </span><span class="s0">n.value=t.extra.expressionValue,n.raw=t.extra.raw,r.expression=</span><span class="s1">this</span><span class="s0">.finishNodeAt(n,</span><span class="s3">&quot;Literal&quot;</span><span class="s0">,t.end,t.loc.end),r.directive=t.extra.raw.slice(</span><span class="s2">1</span><span class="s0">,-</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNodeAt(r,</span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s0">,e.end,e.loc.end)}initFunction(e,t){super.initFunction(e,t),e.expression=!</span><span class="s2">1</span><span class="s0">}checkDeclaration(e){</span><span class="s1">null</span><span class="s0">!=e&amp;&amp;</span><span class="s1">this</span><span class="s0">.isObjectProperty(e)?</span><span class="s1">this</span><span class="s0">.checkDeclaration(e.value):super.checkDeclaration(e)}getObjectOrClassMethodParams(e){</span><span class="s1">return </span><span class="s0">e.value.params}isValidDirective(e){</span><span class="s1">var </span><span class="s0">t;</span><span class="s1">return</span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;Literal&quot;</span><span class="s0">===e.expression.type&amp;&amp;</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.expression.value&amp;&amp;!(</span><span class="s1">null</span><span class="s0">!=(t=e.expression.extra)&amp;&amp;t.parenthesized)}stmtToDirective(e){const t=super.stmtToDirective(e),r=e.expression.value;</span><span class="s1">return this</span><span class="s0">.addExtra(t.value,</span><span class="s3">&quot;expressionValue&quot;</span><span class="s0">,r),t}parseBlockBody(e,...t){super.parseBlockBody(e,...t);const r=e.directives.map((e=&gt;</span><span class="s1">this</span><span class="s0">.directiveToStmt(e)));e.body=r.concat(e.body),</span><span class="s1">delete </span><span class="s0">e.directives}pushClassMethod(e,t,r,n,i,s){</span><span class="s1">this</span><span class="s0">.parseMethod(t,r,n,i,s,</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),t.typeParameters&amp;&amp;(t.value.typeParameters=t.typeParameters,</span><span class="s1">delete </span><span class="s0">t.typeParameters),e.body.push(t)}parseExprAtom(e){</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c.num:</span><span class="s1">case </span><span class="s0">c.string:</span><span class="s1">return this</span><span class="s0">.estreeParseLiteral(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">case </span><span class="s0">c.regexp:</span><span class="s1">return this</span><span class="s0">.estreeParseRegExpLiteral(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">case </span><span class="s0">c.bigint:</span><span class="s1">return this</span><span class="s0">.estreeParseBigIntLiteral(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">case </span><span class="s0">c.decimal:</span><span class="s1">return this</span><span class="s0">.estreeParseDecimalLiteral(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">case </span><span class="s0">c._null:</span><span class="s1">return this</span><span class="s0">.estreeParseLiteral(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._true:</span><span class="s1">return this</span><span class="s0">.estreeParseLiteral(!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._false:</span><span class="s1">return this</span><span class="s0">.estreeParseLiteral(!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return </span><span class="s0">super.parseExprAtom(e)}}parseMaybePrivateName(...e){const t=super.parseMaybePrivateName(...e);</span><span class="s1">return</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">===t.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;estree&quot;</span><span class="s0">,</span><span class="s3">&quot;classFeatures&quot;</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.convertPrivateNameToPrivateIdentifier(t):t}convertPrivateNameToPrivateIdentifier(e){const t=super.getPrivateNameSV(e);</span><span class="s1">return delete </span><span class="s0">e.id,e.name=t,e.type=</span><span class="s3">&quot;PrivateIdentifier&quot;</span><span class="s0">,e}isPrivateName(e){</span><span class="s1">return this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;estree&quot;</span><span class="s0">,</span><span class="s3">&quot;classFeatures&quot;</span><span class="s0">)?</span><span class="s3">&quot;PrivateIdentifier&quot;</span><span class="s0">===e.type:super.isPrivateName(e)}getPrivateNameSV(e){</span><span class="s1">return this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;estree&quot;</span><span class="s0">,</span><span class="s3">&quot;classFeatures&quot;</span><span class="s0">)?e.name:super.getPrivateNameSV(e)}parseLiteral(e,t,r,n){const i=super.parseLiteral(e,t,r,n);</span><span class="s1">return </span><span class="s0">i.raw=i.extra.raw,</span><span class="s1">delete </span><span class="s0">i.extra,i}parseFunctionBody(e,t,r=!</span><span class="s2">1</span><span class="s0">){super.parseFunctionBody(e,t,r),e.expression=</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">!==e.body.type}parseMethod(e,t,r,n,i,s,a=!</span><span class="s2">1</span><span class="s0">){let o=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">o.kind=e.kind,o=super.parseMethod(o,t,r,n,i,s,a),o.type=</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">,</span><span class="s1">delete </span><span class="s0">o.kind,e.value=o,</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">===s&amp;&amp;(e.computed=!</span><span class="s2">1</span><span class="s0">),s=</span><span class="s3">&quot;MethodDefinition&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,s)}parseClassProperty(...e){const t=super.parseClassProperty(...e);</span><span class="s1">return this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;estree&quot;</span><span class="s0">,</span><span class="s3">&quot;classFeatures&quot;</span><span class="s0">)&amp;&amp;(t.type=</span><span class="s3">&quot;PropertyDefinition&quot;</span><span class="s0">),t}parseClassPrivateProperty(...e){const t=super.parseClassPrivateProperty(...e);</span><span class="s1">return this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;estree&quot;</span><span class="s0">,</span><span class="s3">&quot;classFeatures&quot;</span><span class="s0">)&amp;&amp;(t.type=</span><span class="s3">&quot;PropertyDefinition&quot;</span><span class="s0">,t.computed=!</span><span class="s2">1</span><span class="s0">),t}parseObjectMethod(e,t,r,n,i){const s=super.parseObjectMethod(e,t,r,n,i);</span><span class="s1">return </span><span class="s0">s&amp;&amp;(s.type=</span><span class="s3">&quot;Property&quot;</span><span class="s0">,</span><span class="s3">&quot;method&quot;</span><span class="s0">===s.kind&amp;&amp;(s.kind=</span><span class="s3">&quot;init&quot;</span><span class="s0">),s.shorthand=!</span><span class="s2">1</span><span class="s0">),s}parseObjectProperty(e,t,r,n,i){const s=super.parseObjectProperty(e,t,r,n,i);</span><span class="s1">return </span><span class="s0">s&amp;&amp;(s.kind=</span><span class="s3">&quot;init&quot;</span><span class="s0">,s.type=</span><span class="s3">&quot;Property&quot;</span><span class="s0">),s}toAssignable(e,t=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">return null</span><span class="s0">!=e&amp;&amp;</span><span class="s1">this</span><span class="s0">.isObjectProperty(e)?(</span><span class="s1">this</span><span class="s0">.toAssignable(e.value,t),e):super.toAssignable(e,t)}toAssignableObjectExpressionProp(e,...t){</span><span class="s3">&quot;get&quot;</span><span class="s0">===e.kind||</span><span class="s3">&quot;set&quot;</span><span class="s0">===e.kind?</span><span class="s1">this</span><span class="s0">.raise(e.key.start,E.PatternHasAccessor):e.method?</span><span class="s1">this</span><span class="s0">.raise(e.key.start,E.PatternHasMethod):super.toAssignableObjectExpressionProp(e,...t)}finishCallExpression(e,t){</span><span class="s1">var </span><span class="s0">r;(super.finishCallExpression(e,t),</span><span class="s3">&quot;Import&quot;</span><span class="s0">===e.callee.type)&amp;&amp;(e.type=</span><span class="s3">&quot;ImportExpression&quot;</span><span class="s0">,e.source=e.arguments[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;importAssertions&quot;</span><span class="s0">)&amp;&amp;(e.attributes=</span><span class="s1">null</span><span class="s0">!=(r=e.arguments[</span><span class="s2">1</span><span class="s0">])?r:</span><span class="s1">null</span><span class="s0">),</span><span class="s1">delete </span><span class="s0">e.arguments,</span><span class="s1">delete </span><span class="s0">e.callee);</span><span class="s1">return </span><span class="s0">e}toReferencedArguments(e){</span><span class="s3">&quot;ImportExpression&quot;</span><span class="s0">!==e.type&amp;&amp;super.toReferencedArguments(e)}parseExport(e){</span><span class="s1">switch</span><span class="s0">(super.parseExport(e),e.type){</span><span class="s1">case</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">:e.exported=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">:</span><span class="s2">1</span><span class="s0">===e.specifiers.length&amp;&amp;</span><span class="s3">&quot;ExportNamespaceSpecifier&quot;</span><span class="s0">===e.specifiers[</span><span class="s2">0</span><span class="s0">].type&amp;&amp;(e.type=</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">,e.exported=e.specifiers[</span><span class="s2">0</span><span class="s0">].exported,</span><span class="s1">delete </span><span class="s0">e.specifiers)}</span><span class="s1">return </span><span class="s0">e}parseSubscript(e,t,r,n,i){const s=super.parseSubscript(e,t,r,n,i);</span><span class="s1">if</span><span class="s0">(i.optionalChainMember){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">!==s.type&amp;&amp;</span><span class="s3">&quot;OptionalCallExpression&quot;</span><span class="s0">!==s.type||(s.type=s.type.substring(</span><span class="s2">8</span><span class="s0">)),i.stop){const e=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(s);</span><span class="s1">return </span><span class="s0">e.expression=s,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ChainExpression&quot;</span><span class="s0">)}}</span><span class="s1">else</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">!==s.type&amp;&amp;</span><span class="s3">&quot;CallExpression&quot;</span><span class="s0">!==s.type||(s.optional=!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">return </span><span class="s0">s}hasPropertyAsPrivateName(e){</span><span class="s1">return</span><span class="s3">&quot;ChainExpression&quot;</span><span class="s0">===e.type&amp;&amp;(e=e.expression),super.hasPropertyAsPrivateName(e)}isOptionalChain(e){</span><span class="s1">return</span><span class="s3">&quot;ChainExpression&quot;</span><span class="s0">===e.type}isObjectProperty(e){</span><span class="s1">return</span><span class="s3">&quot;Property&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;init&quot;</span><span class="s0">===e.kind&amp;&amp;!e.method}isObjectMethod(e){</span><span class="s1">return </span><span class="s0">e.method||</span><span class="s3">&quot;get&quot;</span><span class="s0">===e.kind||</span><span class="s3">&quot;set&quot;</span><span class="s0">===e.kind}},jsx:e=&gt;class extends e{jsxReadToken(){let e=</span><span class="s3">&quot;&quot;</span><span class="s0">,t=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">for</span><span class="s0">(;;){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos&gt;=</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,se.UnterminatedJsxContent);const r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">switch</span><span class="s0">(r){</span><span class="s1">case </span><span class="s2">60</span><span class="s0">:</span><span class="s1">case </span><span class="s2">123</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.state.pos===</span><span class="s1">this</span><span class="s0">.state.start?</span><span class="s2">60</span><span class="s0">===r&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.exprAllowed?(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.jsxTagStart)):super.getTokenFromCode(r):(e+=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos),</span><span class="s1">this</span><span class="s0">.finishToken(c.jsxText,e));</span><span class="s1">case </span><span class="s2">38</span><span class="s0">:e+=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos),e+=</span><span class="s1">this</span><span class="s0">.jsxReadEntity(),t=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:h(r)?(e+=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos),e+=</span><span class="s1">this</span><span class="s0">.jsxReadNewLine(!</span><span class="s2">0</span><span class="s0">),t=</span><span class="s1">this</span><span class="s0">.state.pos):++</span><span class="s1">this</span><span class="s0">.state.pos}}}jsxReadNewLine(e){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);let r;</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s2">13</span><span class="s0">===t&amp;&amp;</span><span class="s2">10</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)?(++</span><span class="s1">this</span><span class="s0">.state.pos,r=e?</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">:</span><span class="s3">&quot;</span><span class="s4">\r\n</span><span class="s3">&quot;</span><span class="s0">):r=String.fromCharCode(t),++</span><span class="s1">this</span><span class="s0">.state.curLine,</span><span class="s1">this</span><span class="s0">.state.lineStart=</span><span class="s1">this</span><span class="s0">.state.pos,r}jsxReadString(e){let t=</span><span class="s3">&quot;&quot;</span><span class="s0">,r=++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">for</span><span class="s0">(;;){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos&gt;=</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.UnterminatedString);const n=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(n===e)</span><span class="s1">break</span><span class="s0">;</span><span class="s2">38</span><span class="s0">===n?(t+=</span><span class="s1">this</span><span class="s0">.input.slice(r,</span><span class="s1">this</span><span class="s0">.state.pos),t+=</span><span class="s1">this</span><span class="s0">.jsxReadEntity(),r=</span><span class="s1">this</span><span class="s0">.state.pos):h(n)?(t+=</span><span class="s1">this</span><span class="s0">.input.slice(r,</span><span class="s1">this</span><span class="s0">.state.pos),t+=</span><span class="s1">this</span><span class="s0">.jsxReadNewLine(!</span><span class="s2">1</span><span class="s0">),r=</span><span class="s1">this</span><span class="s0">.state.pos):++</span><span class="s1">this</span><span class="s0">.state.pos}</span><span class="s1">return </span><span class="s0">t+=</span><span class="s1">this</span><span class="s0">.input.slice(r,</span><span class="s1">this</span><span class="s0">.state.pos++),</span><span class="s1">this</span><span class="s0">.finishToken(c.string,t)}jsxReadEntity(){let e,t=</span><span class="s3">&quot;&quot;</span><span class="s0">,r=</span><span class="s2">0</span><span class="s0">,n=</span><span class="s1">this</span><span class="s0">.input[</span><span class="s1">this</span><span class="s0">.state.pos];const i=++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length&amp;&amp;r++&lt;</span><span class="s2">10</span><span class="s0">;){</span><span class="s1">if</span><span class="s0">(n=</span><span class="s1">this</span><span class="s0">.input[</span><span class="s1">this</span><span class="s0">.state.pos++],</span><span class="s3">&quot;;&quot;</span><span class="s0">===n){</span><span class="s3">&quot;#&quot;</span><span class="s0">===t[</span><span class="s2">0</span><span class="s0">]?</span><span class="s3">&quot;x&quot;</span><span class="s0">===t[</span><span class="s2">1</span><span class="s0">]?(t=t.substr(</span><span class="s2">2</span><span class="s0">),ne.test(t)&amp;&amp;(e=String.fromCodePoint(parseInt(t,</span><span class="s2">16</span><span class="s0">)))):(t=t.substr(</span><span class="s2">1</span><span class="s0">),ie.test(t)&amp;&amp;(e=String.fromCodePoint(parseInt(t,</span><span class="s2">10</span><span class="s0">)))):e=re[t];</span><span class="s1">break</span><span class="s0">}t+=n}</span><span class="s1">return </span><span class="s0">e||(</span><span class="s1">this</span><span class="s0">.state.pos=i,</span><span class="s3">&quot;&amp;&quot;</span><span class="s0">)}jsxReadWord(){let e;const t=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">do</span><span class="s0">{e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(++</span><span class="s1">this</span><span class="s0">.state.pos)}</span><span class="s1">while</span><span class="s0">(j(e)||</span><span class="s2">45</span><span class="s0">===e);</span><span class="s1">return this</span><span class="s0">.finishToken(c.jsxName,</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos))}jsxParseIdentifier(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.match(c.jsxName)?e.name=</span><span class="s1">this</span><span class="s0">.state.value:</span><span class="s1">this</span><span class="s0">.state.type.keyword?e.name=</span><span class="s1">this</span><span class="s0">.state.type.keyword:</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">)}jsxParseNamespacedName(){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc,r=</span><span class="s1">this</span><span class="s0">.jsxParseIdentifier();</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.eat(c.colon))</span><span class="s1">return </span><span class="s0">r;const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);</span><span class="s1">return </span><span class="s0">n.namespace=r,n.name=</span><span class="s1">this</span><span class="s0">.jsxParseIdentifier(),</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">)}jsxParseElementName(){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc;let r=</span><span class="s1">this</span><span class="s0">.jsxParseNamespacedName();</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">===r.type)</span><span class="s1">return </span><span class="s0">r;</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.eat(c.dot);){const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);n.object=r,n.property=</span><span class="s1">this</span><span class="s0">.jsxParseIdentifier(),r=</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">r}jsxParseAttributeValue(){let e;</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c.braceL:</span><span class="s1">return </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.next(),e=</span><span class="s1">this</span><span class="s0">.jsxParseExpressionContainer(e),</span><span class="s3">&quot;JSXEmptyExpression&quot;</span><span class="s0">===e.expression.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,se.AttributeIsEmpty),e;</span><span class="s1">case </span><span class="s0">c.jsxTagStart:</span><span class="s1">case </span><span class="s0">c.string:</span><span class="s1">return this</span><span class="s0">.parseExprAtom();</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,se.UnsupportedJsxValue)}}jsxParseEmptyExpression(){const e=</span><span class="s1">this</span><span class="s0">.startNodeAt(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc);</span><span class="s1">return this</span><span class="s0">.finishNodeAt(e,</span><span class="s3">&quot;JSXEmptyExpression&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.start,</span><span class="s1">this</span><span class="s0">.state.startLoc)}jsxParseSpreadChild(e){</span><span class="s1">return this</span><span class="s0">.next(),e.expression=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;JSXSpreadChild&quot;</span><span class="s0">)}jsxParseExpressionContainer(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.braceR))e.expression=</span><span class="s1">this</span><span class="s0">.jsxParseEmptyExpression();</span><span class="s1">else</span><span class="s0">{const t=</span><span class="s1">this</span><span class="s0">.parseExpression();e.expression=t}</span><span class="s1">return this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;JSXExpressionContainer&quot;</span><span class="s0">)}jsxParseAttribute(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.eat(c.braceL)?(</span><span class="s1">this</span><span class="s0">.expect(c.ellipsis),e.argument=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;JSXSpreadAttribute&quot;</span><span class="s0">)):(e.name=</span><span class="s1">this</span><span class="s0">.jsxParseNamespacedName(),e.value=</span><span class="s1">this</span><span class="s0">.eat(c.eq)?</span><span class="s1">this</span><span class="s0">.jsxParseAttributeValue():</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;JSXAttribute&quot;</span><span class="s0">))}jsxParseOpeningElementAt(e,t){const r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);</span><span class="s1">return this</span><span class="s0">.match(c.jsxTagEnd)?(</span><span class="s1">this</span><span class="s0">.expect(c.jsxTagEnd),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;JSXOpeningFragment&quot;</span><span class="s0">)):(r.name=</span><span class="s1">this</span><span class="s0">.jsxParseElementName(),</span><span class="s1">this</span><span class="s0">.jsxParseOpeningElementAfterName(r))}jsxParseOpeningElementAfterName(e){const t=[];</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.match(c.slash)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.jsxTagEnd);)t.push(</span><span class="s1">this</span><span class="s0">.jsxParseAttribute());</span><span class="s1">return </span><span class="s0">e.attributes=t,e.selfClosing=</span><span class="s1">this</span><span class="s0">.eat(c.slash),</span><span class="s1">this</span><span class="s0">.expect(c.jsxTagEnd),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;JSXOpeningElement&quot;</span><span class="s0">)}jsxParseClosingElementAt(e,t){const r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);</span><span class="s1">return this</span><span class="s0">.match(c.jsxTagEnd)?(</span><span class="s1">this</span><span class="s0">.expect(c.jsxTagEnd),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;JSXClosingFragment&quot;</span><span class="s0">)):(r.name=</span><span class="s1">this</span><span class="s0">.jsxParseElementName(),</span><span class="s1">this</span><span class="s0">.expect(c.jsxTagEnd),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;JSXClosingElement&quot;</span><span class="s0">))}jsxParseElementAt(e,t){const r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t),n=[],i=</span><span class="s1">this</span><span class="s0">.jsxParseOpeningElementAt(e,t);let s=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!i.selfClosing){e:</span><span class="s1">for</span><span class="s0">(;;)</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c.jsxTagStart:</span><span class="s1">if</span><span class="s0">(e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.eat(c.slash)){s=</span><span class="s1">this</span><span class="s0">.jsxParseClosingElementAt(e,t);</span><span class="s1">break </span><span class="s0">e}n.push(</span><span class="s1">this</span><span class="s0">.jsxParseElementAt(e,t));</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">c.jsxText:n.push(</span><span class="s1">this</span><span class="s0">.parseExprAtom());</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">c.braceL:{const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.ellipsis)?n.push(</span><span class="s1">this</span><span class="s0">.jsxParseSpreadChild(e)):n.push(</span><span class="s1">this</span><span class="s0">.jsxParseExpressionContainer(e));</span><span class="s1">break</span><span class="s0">}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw this</span><span class="s0">.unexpected()}ae(i)&amp;&amp;!ae(s)?</span><span class="s1">this</span><span class="s0">.raise(s.start,se.MissingClosingTagFragment):!ae(i)&amp;&amp;ae(s)?</span><span class="s1">this</span><span class="s0">.raise(s.start,se.MissingClosingTagElement,oe(i.name)):ae(i)||ae(s)||oe(s.name)!==oe(i.name)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(s.start,se.MissingClosingTagElement,oe(i.name))}</span><span class="s1">if</span><span class="s0">(ae(i)?(r.openingFragment=i,r.closingFragment=s):(r.openingElement=i,r.closingElement=s),r.children=n,</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,se.UnwrappedAdjacentJSXElements);</span><span class="s1">return </span><span class="s0">ae(i)?</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;JSXFragment&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;JSXElement&quot;</span><span class="s0">)}jsxParseElement(){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.jsxParseElementAt(e,t)}parseExprAtom(e){</span><span class="s1">return this</span><span class="s0">.match(c.jsxText)?</span><span class="s1">this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;JSXText&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.match(c.jsxTagStart)?</span><span class="s1">this</span><span class="s0">.jsxParseElement():</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">33</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)?(</span><span class="s1">this</span><span class="s0">.finishToken(c.jsxTagStart),</span><span class="s1">this</span><span class="s0">.jsxParseElement()):super.parseExprAtom(e)}getTokenFromCode(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.inPropertyName)</span><span class="s1">return </span><span class="s0">super.getTokenFromCode(e);const t=</span><span class="s1">this</span><span class="s0">.curContext();</span><span class="s1">if</span><span class="s0">(t===O.j_expr)</span><span class="s1">return this</span><span class="s0">.jsxReadToken();</span><span class="s1">if</span><span class="s0">(t===O.j_oTag||t===O.j_cTag){</span><span class="s1">if</span><span class="s0">(M(e))</span><span class="s1">return this</span><span class="s0">.jsxReadWord();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">62</span><span class="s0">===e)</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.jsxTagEnd);</span><span class="s1">if</span><span class="s0">((</span><span class="s2">34</span><span class="s0">===e||</span><span class="s2">39</span><span class="s0">===e)&amp;&amp;t===O.j_oTag)</span><span class="s1">return this</span><span class="s0">.jsxReadString(e)}</span><span class="s1">return </span><span class="s2">60</span><span class="s0">===e&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.exprAllowed&amp;&amp;</span><span class="s2">33</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)?(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.jsxTagStart)):super.getTokenFromCode(e)}updateContext(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.braceL)){const t=</span><span class="s1">this</span><span class="s0">.curContext();t===O.j_oTag?</span><span class="s1">this</span><span class="s0">.state.context.push(O.braceExpression):t===O.j_expr?</span><span class="s1">this</span><span class="s0">.state.context.push(O.templateQuasi):super.updateContext(e),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c.slash)||e!==c.jsxTagStart)</span><span class="s1">return </span><span class="s0">super.updateContext(e);</span><span class="s1">this</span><span class="s0">.state.context.length-=</span><span class="s2">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.context.push(O.j_cTag),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">}}},flow:e=&gt;class extends e{constructor(...e){super(...e),</span><span class="s1">this</span><span class="s0">.flowPragma=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">}getScopeHandler(){</span><span class="s1">return </span><span class="s0">G}shouldParseTypes(){</span><span class="s1">return this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;flow&quot;</span><span class="s0">,</span><span class="s3">&quot;all&quot;</span><span class="s0">)||</span><span class="s3">&quot;flow&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.flowPragma}shouldParseEnums(){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;flow&quot;</span><span class="s0">,</span><span class="s3">&quot;enums&quot;</span><span class="s0">)}finishToken(e,t){</span><span class="s1">return </span><span class="s0">e!==c.string&amp;&amp;e!==c.semi&amp;&amp;e!==c.interpreterDirective&amp;&amp;</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.flowPragma&amp;&amp;(</span><span class="s1">this</span><span class="s0">.flowPragma=</span><span class="s1">null</span><span class="s0">),super.finishToken(e,t)}addComment(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.flowPragma){const t=te.exec(e.value);</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;flow&quot;</span><span class="s0">===t[</span><span class="s2">1</span><span class="s0">])</span><span class="s1">this</span><span class="s0">.flowPragma=</span><span class="s3">&quot;flow&quot;</span><span class="s0">;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;noflow&quot;</span><span class="s0">!==t[</span><span class="s2">1</span><span class="s0">])</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Unexpected flow pragma&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.flowPragma=</span><span class="s3">&quot;noflow&quot;</span><span class="s0">}}</span><span class="s1">return </span><span class="s0">super.addComment(e)}flowParseTypeInitialiser(e){const t=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(e||c.colon);const r=</span><span class="s1">this</span><span class="s0">.flowParseType();</span><span class="s1">return this</span><span class="s0">.state.inType=t,r}flowParsePredicate(){const e=</span><span class="s1">this</span><span class="s0">.startNode(),t=</span><span class="s1">this</span><span class="s0">.state.start;</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;checks&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.lastTokStart&gt;t+</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,$.UnexpectedSpaceBetweenModuloChecks),</span><span class="s1">this</span><span class="s0">.eat(c.parenL)?(e.value=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.expect(c.parenR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclaredPredicate&quot;</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;InferredPredicate&quot;</span><span class="s0">)}flowParseTypeAndPredicateInitialiser(){const e=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(c.colon);let t=</span><span class="s1">null</span><span class="s0">,r=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.match(c.modulo)?(</span><span class="s1">this</span><span class="s0">.state.inType=e,r=</span><span class="s1">this</span><span class="s0">.flowParsePredicate()):(t=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.state.inType=e,</span><span class="s1">this</span><span class="s0">.match(c.modulo)&amp;&amp;(r=</span><span class="s1">this</span><span class="s0">.flowParsePredicate())),[t,r]}flowParseDeclareClass(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseInterfaceish(e,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclareClass&quot;</span><span class="s0">)}flowParseDeclareFunction(e){</span><span class="s1">this</span><span class="s0">.next();const t=e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),r=</span><span class="s1">this</span><span class="s0">.startNode(),n=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)?r.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration():r.typeParameters=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(c.parenL);const i=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParams();</span><span class="s1">return </span><span class="s0">r.params=i.params,r.rest=i.rest,r.</span><span class="s1">this</span><span class="s0">=i._this,</span><span class="s1">this</span><span class="s0">.expect(c.parenR),[r.returnType,e.predicate]=</span><span class="s1">this</span><span class="s0">.flowParseTypeAndPredicateInitialiser(),n.typeAnnotation=</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">),t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.resetEndLocation(t),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.scope.declareName(e.id.name,</span><span class="s2">2048</span><span class="s0">,e.id.start),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclareFunction&quot;</span><span class="s0">)}flowParseDeclare(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._class))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareClass(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._function))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareFunction(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._var))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareVariable(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;module&quot;</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.match(c.dot)?</span><span class="s1">this</span><span class="s0">.flowParseDeclareModuleExports(e):(t&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,$.NestedDeclareModule),</span><span class="s1">this</span><span class="s0">.flowParseDeclareModule(e));</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareTypeAlias(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;opaque&quot;</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareOpaqueType(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;interface&quot;</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareInterface(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._export))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareExportDeclaration(e,t);</span><span class="s1">throw this</span><span class="s0">.unexpected()}flowParseDeclareVariable(e){</span><span class="s1">return this</span><span class="s0">.next(),e.id=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotatableIdentifier(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.declareName(e.id.name,</span><span class="s2">5</span><span class="s0">,e.id.start),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclareVariable&quot;</span><span class="s0">)}flowParseDeclareModule(e){</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(c.string)?e.id=</span><span class="s1">this</span><span class="s0">.parseExprAtom():e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier();const t=e.body=</span><span class="s1">this</span><span class="s0">.startNode(),r=t.body=[];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.braceL);!</span><span class="s1">this</span><span class="s0">.match(c.braceR);){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.match(c._import)?(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(c._typeof)||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,$.InvalidNonTypeImportInDeclareModule),</span><span class="s1">this</span><span class="s0">.parseImport(e)):(</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;declare&quot;</span><span class="s0">,$.UnsupportedStatementInDeclareModule),e=</span><span class="s1">this</span><span class="s0">.flowParseDeclare(e,!</span><span class="s2">0</span><span class="s0">)),r.push(e)}</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">);let n=</span><span class="s1">null</span><span class="s0">,i=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">return </span><span class="s0">r.forEach((e=&gt;{!</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s3">&quot;DeclareExportAllDeclaration&quot;</span><span class="s0">===e.type||</span><span class="s3">&quot;DeclareExportDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(!e.declaration||</span><span class="s3">&quot;TypeAlias&quot;</span><span class="s0">!==e.declaration.type&amp;&amp;</span><span class="s3">&quot;InterfaceDeclaration&quot;</span><span class="s0">!==e.declaration.type)}(e)?</span><span class="s3">&quot;DeclareModuleExports&quot;</span><span class="s0">===e.type&amp;&amp;(i&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,$.DuplicateDeclareModuleExports),</span><span class="s3">&quot;ES&quot;</span><span class="s0">===n&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,$.AmbiguousDeclareModuleKind),n=</span><span class="s3">&quot;CommonJS&quot;</span><span class="s0">,i=!</span><span class="s2">0</span><span class="s0">):(</span><span class="s3">&quot;CommonJS&quot;</span><span class="s0">===n&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,$.AmbiguousDeclareModuleKind),n=</span><span class="s3">&quot;ES&quot;</span><span class="s0">)})),e.kind=n||</span><span class="s3">&quot;CommonJS&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclareModule&quot;</span><span class="s0">)}flowParseDeclareExportDeclaration(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c._export),</span><span class="s1">this</span><span class="s0">.eat(c._default))</span><span class="s1">return this</span><span class="s0">.match(c._function)||</span><span class="s1">this</span><span class="s0">.match(c._class)?e.declaration=</span><span class="s1">this</span><span class="s0">.flowParseDeclare(</span><span class="s1">this</span><span class="s0">.startNode()):(e.declaration=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.semicolon()),e.</span><span class="s1">default</span><span class="s0">=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclareExportDeclaration&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._const)||</span><span class="s1">this</span><span class="s0">.isLet()||(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;interface&quot;</span><span class="s0">))&amp;&amp;!t){const e=</span><span class="s1">this</span><span class="s0">.state.value,t=ee[e];</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,$.UnsupportedDeclareExportKind,e,t)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._var)||</span><span class="s1">this</span><span class="s0">.match(c._function)||</span><span class="s1">this</span><span class="s0">.match(c._class)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;opaque&quot;</span><span class="s0">))</span><span class="s1">return </span><span class="s0">e.declaration=</span><span class="s1">this</span><span class="s0">.flowParseDeclare(</span><span class="s1">this</span><span class="s0">.startNode()),e.</span><span class="s1">default</span><span class="s0">=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclareExportDeclaration&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.star)||</span><span class="s1">this</span><span class="s0">.match(c.braceL)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;interface&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;opaque&quot;</span><span class="s0">))</span><span class="s1">return</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">===(e=</span><span class="s1">this</span><span class="s0">.parseExport(e)).type&amp;&amp;(e.type=</span><span class="s3">&quot;ExportDeclaration&quot;</span><span class="s0">,e.</span><span class="s1">default</span><span class="s0">=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">delete </span><span class="s0">e.exportKind),e.type=</span><span class="s3">&quot;Declare&quot;</span><span class="s0">+e.type,e;</span><span class="s1">throw this</span><span class="s0">.unexpected()}flowParseDeclareModuleExports(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;exports&quot;</span><span class="s0">),e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclareModuleExports&quot;</span><span class="s0">)}flowParseDeclareTypeAlias(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseTypeAlias(e),e.type=</span><span class="s3">&quot;DeclareTypeAlias&quot;</span><span class="s0">,e}flowParseDeclareOpaqueType(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseOpaqueType(e,!</span><span class="s2">0</span><span class="s0">),e.type=</span><span class="s3">&quot;DeclareOpaqueType&quot;</span><span class="s0">,e}flowParseDeclareInterface(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseInterfaceish(e),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclareInterface&quot;</span><span class="s0">)}flowParseInterfaceish(e,t=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(e.id=</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!t,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.declareName(e.id.name,t?</span><span class="s2">17</span><span class="s0">:</span><span class="s2">9</span><span class="s0">,e.id.start),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)?e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration():e.typeParameters=</span><span class="s1">null</span><span class="s0">,e.extends=[],e.implements=[],e.mixins=[],</span><span class="s1">this</span><span class="s0">.eat(c._extends))</span><span class="s1">do</span><span class="s0">{e.extends.push(</span><span class="s1">this</span><span class="s0">.flowParseInterfaceExtends())}</span><span class="s1">while</span><span class="s0">(!t&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.comma));</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;mixins&quot;</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.next();</span><span class="s1">do</span><span class="s0">{e.mixins.push(</span><span class="s1">this</span><span class="s0">.flowParseInterfaceExtends())}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.comma))}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;implements&quot;</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.next();</span><span class="s1">do</span><span class="s0">{e.implements.push(</span><span class="s1">this</span><span class="s0">.flowParseInterfaceExtends())}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.comma))}e.body=</span><span class="s1">this</span><span class="s0">.flowParseObjectType({allowStatic:t,allowExact:!</span><span class="s2">1</span><span class="s0">,allowSpread:!</span><span class="s2">1</span><span class="s0">,allowProto:t,allowInexact:!</span><span class="s2">1</span><span class="s0">})}flowParseInterfaceExtends(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.id=</span><span class="s1">this</span><span class="s0">.flowParseQualifiedTypeIdentifier(),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)?e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiation():e.typeParameters=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;InterfaceExtends&quot;</span><span class="s0">)}flowParseInterface(e){</span><span class="s1">return this</span><span class="s0">.flowParseInterfaceish(e),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;InterfaceDeclaration&quot;</span><span class="s0">)}checkNotUnderscore(e){</span><span class="s3">&quot;_&quot;</span><span class="s0">===e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,$.UnexpectedReservedUnderscore)}checkReservedType(e,t,r){z.has(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,r?$.AssignReservedType:$.UnexpectedReservedType,e)}flowParseRestrictedIdentifier(e,t){</span><span class="s1">return this</span><span class="s0">.checkReservedType(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.state.start,t),</span><span class="s1">this</span><span class="s0">.parseIdentifier(e)}flowParseTypeAlias(e){</span><span class="s1">return </span><span class="s0">e.id=</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.declareName(e.id.name,</span><span class="s2">9</span><span class="s0">,e.id.start),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)?e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration():e.typeParameters=</span><span class="s1">null</span><span class="s0">,e.right=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(c.eq),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TypeAlias&quot;</span><span class="s0">)}flowParseOpaqueType(e,t){</span><span class="s1">return this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">),e.id=</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.declareName(e.id.name,</span><span class="s2">9</span><span class="s0">,e.id.start),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)?e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration():e.typeParameters=</span><span class="s1">null</span><span class="s0">,e.supertype=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(c.colon)&amp;&amp;(e.supertype=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(c.colon)),e.impltype=</span><span class="s1">null</span><span class="s0">,t||(e.impltype=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(c.eq)),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;OpaqueType&quot;</span><span class="s0">)}flowParseTypeParameter(e=!</span><span class="s2">1</span><span class="s0">){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.startNode(),n=</span><span class="s1">this</span><span class="s0">.flowParseVariance(),i=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotatableIdentifier();</span><span class="s1">return </span><span class="s0">r.name=i.name,r.variance=n,r.bound=i.typeAnnotation,</span><span class="s1">this</span><span class="s0">.match(c.eq)?(</span><span class="s1">this</span><span class="s0">.eat(c.eq),r.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">this</span><span class="s0">.flowParseType()):e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,$.MissingTypeParamDefault),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;TypeParameter&quot;</span><span class="s0">)}flowParseTypeParameterDeclaration(){const e=</span><span class="s1">this</span><span class="s0">.state.inType,t=</span><span class="s1">this</span><span class="s0">.startNode();t.params=[],</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(c.jsxTagStart)?</span><span class="s1">this</span><span class="s0">.next():</span><span class="s1">this</span><span class="s0">.unexpected();let r=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{const e=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameter(r);t.params.push(e),e.</span><span class="s1">default</span><span class="s0">&amp;&amp;(r=!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expect(c.comma)}</span><span class="s1">while</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">));</span><span class="s1">return this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.inType=e,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">)}flowParseTypeParameterInstantiation(){const e=</span><span class="s1">this</span><span class="s0">.startNode(),t=</span><span class="s1">this</span><span class="s0">.state.inType;e.params=[],</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">);const r=</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=!</span><span class="s2">1</span><span class="s0">;!</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">);)e.params.push(</span><span class="s1">this</span><span class="s0">.flowParseType()),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expect(c.comma);</span><span class="s1">return this</span><span class="s0">.state.noAnonFunctionType=r,</span><span class="s1">this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.inType=t,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">)}flowParseTypeParameterInstantiationCallOrNew(){const e=</span><span class="s1">this</span><span class="s0">.startNode(),t=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">for</span><span class="s0">(e.params=[],</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">);!</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">);)e.params.push(</span><span class="s1">this</span><span class="s0">.flowParseTypeOrImplicitInstantiation()),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expect(c.comma);</span><span class="s1">return this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.inType=t,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">)}flowParseInterfaceType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;interface&quot;</span><span class="s0">),e.extends=[],</span><span class="s1">this</span><span class="s0">.eat(c._extends))</span><span class="s1">do</span><span class="s0">{e.extends.push(</span><span class="s1">this</span><span class="s0">.flowParseInterfaceExtends())}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.comma));</span><span class="s1">return </span><span class="s0">e.body=</span><span class="s1">this</span><span class="s0">.flowParseObjectType({allowStatic:!</span><span class="s2">1</span><span class="s0">,allowExact:!</span><span class="s2">1</span><span class="s0">,allowSpread:!</span><span class="s2">1</span><span class="s0">,allowProto:!</span><span class="s2">1</span><span class="s0">,allowInexact:!</span><span class="s2">1</span><span class="s0">}),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;InterfaceTypeAnnotation&quot;</span><span class="s0">)}flowParseObjectPropertyKey(){</span><span class="s1">return this</span><span class="s0">.match(c.num)||</span><span class="s1">this</span><span class="s0">.match(c.string)?</span><span class="s1">this</span><span class="s0">.parseExprAtom():</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">)}flowParseObjectTypeIndexer(e,t,r){</span><span class="s1">return </span><span class="s0">e.static=t,</span><span class="s1">this</span><span class="s0">.lookahead().type===c.colon?(e.id=</span><span class="s1">this</span><span class="s0">.flowParseObjectPropertyKey(),e.key=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser()):(e.id=</span><span class="s1">null</span><span class="s0">,e.key=</span><span class="s1">this</span><span class="s0">.flowParseType()),</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),e.value=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(),e.variance=r,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ObjectTypeIndexer&quot;</span><span class="s0">)}flowParseObjectTypeInternalSlot(e,t){</span><span class="s1">return </span><span class="s0">e.static=t,e.id=</span><span class="s1">this</span><span class="s0">.flowParseObjectPropertyKey(),</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(c.parenL)?(e.method=!</span><span class="s2">0</span><span class="s0">,e.optional=!</span><span class="s2">1</span><span class="s0">,e.value=</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeMethodish(</span><span class="s1">this</span><span class="s0">.startNodeAt(e.start,e.loc.start))):(e.method=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(e.optional=!</span><span class="s2">0</span><span class="s0">),e.value=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ObjectTypeInternalSlot&quot;</span><span class="s0">)}flowParseObjectTypeMethodish(e){</span><span class="s1">for</span><span class="s0">(e.params=[],e.rest=</span><span class="s1">null</span><span class="s0">,e.typeParameters=</span><span class="s1">null</span><span class="s0">,e.</span><span class="s1">this</span><span class="s0">=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration()),</span><span class="s1">this</span><span class="s0">.expect(c.parenL),</span><span class="s1">this</span><span class="s0">.match(c._this)&amp;&amp;(e.</span><span class="s1">this</span><span class="s0">=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParam(!</span><span class="s2">0</span><span class="s0">),e.</span><span class="s1">this</span><span class="s0">.name=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(c.parenR)||</span><span class="s1">this</span><span class="s0">.expect(c.comma));!</span><span class="s1">this</span><span class="s0">.match(c.parenR)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.ellipsis);)e.params.push(</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParam(!</span><span class="s2">1</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.match(c.parenR)||</span><span class="s1">this</span><span class="s0">.expect(c.comma);</span><span class="s1">return this</span><span class="s0">.eat(c.ellipsis)&amp;&amp;(e.rest=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParam(!</span><span class="s2">1</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.expect(c.parenR),e.returnType=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">)}flowParseObjectTypeCallProperty(e,t){const r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.static=t,e.value=</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeMethodish(r),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ObjectTypeCallProperty&quot;</span><span class="s0">)}flowParseObjectType({allowStatic:e,allowExact:t,allowSpread:r,allowProto:n,allowInexact:i}){const s=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s2">0</span><span class="s0">;const a=</span><span class="s1">this</span><span class="s0">.startNode();let o,l;a.callProperties=[],a.properties=[],a.indexers=[],a.internalSlots=[];let p=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(t&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.braceBarL)?(</span><span class="s1">this</span><span class="s0">.expect(c.braceBarL),o=c.braceBarR,l=!</span><span class="s2">0</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.expect(c.braceL),o=c.braceR,l=!</span><span class="s2">1</span><span class="s0">),a.exact=l;!</span><span class="s1">this</span><span class="s0">.match(o);){let t=!</span><span class="s2">1</span><span class="s0">,s=</span><span class="s1">null</span><span class="s0">,o=</span><span class="s1">null</span><span class="s0">;const u=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(n&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;proto&quot;</span><span class="s0">)){const t=</span><span class="s1">this</span><span class="s0">.lookahead();t.type!==c.colon&amp;&amp;t.type!==c.question&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),s=</span><span class="s1">this</span><span class="s0">.state.start,e=!</span><span class="s2">1</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(e&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;static&quot;</span><span class="s0">)){const e=</span><span class="s1">this</span><span class="s0">.lookahead();e.type!==c.colon&amp;&amp;e.type!==c.question&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),t=!</span><span class="s2">0</span><span class="s0">)}const d=</span><span class="s1">this</span><span class="s0">.flowParseVariance();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.bracketL))</span><span class="s1">null</span><span class="s0">!=s&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(s),</span><span class="s1">this</span><span class="s0">.eat(c.bracketL)?(d&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(d.start),a.internalSlots.push(</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeInternalSlot(u,t))):a.indexers.push(</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeIndexer(u,t,d));</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">))</span><span class="s1">null</span><span class="s0">!=s&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(s),d&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(d.start),a.callProperties.push(</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeCallProperty(u,t));</span><span class="s1">else</span><span class="s0">{let e=</span><span class="s3">&quot;init&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;get&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;set&quot;</span><span class="s0">)){const t=</span><span class="s1">this</span><span class="s0">.lookahead();t.type!==c.name&amp;&amp;t.type!==c.string&amp;&amp;t.type!==c.num||(e=</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.next())}const n=</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeProperty(u,t,s,d,e,r,</span><span class="s1">null</span><span class="s0">!=i?i:!l);</span><span class="s1">null</span><span class="s0">===n?(p=!</span><span class="s2">0</span><span class="s0">,o=</span><span class="s1">this</span><span class="s0">.state.lastTokStart):a.properties.push(n)}</span><span class="s1">this</span><span class="s0">.flowObjectTypeSemicolon(),!o||</span><span class="s1">this</span><span class="s0">.match(c.braceR)||</span><span class="s1">this</span><span class="s0">.match(c.braceBarR)||</span><span class="s1">this</span><span class="s0">.raise(o,$.UnexpectedExplicitInexactInObject)}</span><span class="s1">this</span><span class="s0">.expect(o),r&amp;&amp;(a.inexact=p);const u=</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s3">&quot;ObjectTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.state.inType=s,u}flowParseObjectTypeProperty(e,t,r,n,i,s,a){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.ellipsis))</span><span class="s1">return this</span><span class="s0">.match(c.comma)||</span><span class="s1">this</span><span class="s0">.match(c.semi)||</span><span class="s1">this</span><span class="s0">.match(c.braceR)||</span><span class="s1">this</span><span class="s0">.match(c.braceBarR)?(s?a||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,$.InexactInsideExact):</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,$.InexactInsideNonObject),n&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(n.start,$.InexactVariance),</span><span class="s1">null</span><span class="s0">):(s||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,$.UnexpectedSpreadType),</span><span class="s1">null</span><span class="s0">!=r&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(r),n&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(n.start,$.SpreadVariance),e.argument=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ObjectTypeSpreadProperty&quot;</span><span class="s0">));{e.key=</span><span class="s1">this</span><span class="s0">.flowParseObjectPropertyKey(),e.static=t,e.proto=</span><span class="s1">null</span><span class="s0">!=r,e.kind=i;let a=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(c.parenL)?(e.method=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">null</span><span class="s0">!=r&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(r),n&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(n.start),e.value=</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeMethodish(</span><span class="s1">this</span><span class="s0">.startNodeAt(e.start,e.loc.start)),</span><span class="s3">&quot;get&quot;</span><span class="s0">!==i&amp;&amp;</span><span class="s3">&quot;set&quot;</span><span class="s0">!==i||</span><span class="s1">this</span><span class="s0">.flowCheckGetterSetterParams(e),!s&amp;&amp;</span><span class="s3">&quot;constructor&quot;</span><span class="s0">===e.key.name&amp;&amp;e.value.</span><span class="s1">this</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.value.</span><span class="s1">this</span><span class="s0">.start,$.ThisParamBannedInConstructor)):(</span><span class="s3">&quot;init&quot;</span><span class="s0">!==i&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),e.method=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(a=!</span><span class="s2">0</span><span class="s0">),e.value=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(),e.variance=n),e.optional=a,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ObjectTypeProperty&quot;</span><span class="s0">)}}flowCheckGetterSetterParams(e){const t=</span><span class="s3">&quot;get&quot;</span><span class="s0">===e.kind?</span><span class="s2">0</span><span class="s0">:</span><span class="s2">1</span><span class="s0">,r=e.start,n=e.value.params.length+(e.value.rest?</span><span class="s2">1</span><span class="s0">:</span><span class="s2">0</span><span class="s0">);e.value.</span><span class="s1">this</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.value.</span><span class="s1">this</span><span class="s0">.start,</span><span class="s3">&quot;get&quot;</span><span class="s0">===e.kind?$.GetterMayNotHaveThisParam:$.SetterMayNotHaveThisParam),n!==t&amp;&amp;(</span><span class="s3">&quot;get&quot;</span><span class="s0">===e.kind?</span><span class="s1">this</span><span class="s0">.raise(r,E.BadGetterArity):</span><span class="s1">this</span><span class="s0">.raise(r,E.BadSetterArity)),</span><span class="s3">&quot;set&quot;</span><span class="s0">===e.kind&amp;&amp;e.value.rest&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r,E.BadSetterRestParameter)}flowObjectTypeSemicolon(){</span><span class="s1">this</span><span class="s0">.eat(c.semi)||</span><span class="s1">this</span><span class="s0">.eat(c.comma)||</span><span class="s1">this</span><span class="s0">.match(c.braceR)||</span><span class="s1">this</span><span class="s0">.match(c.braceBarR)||</span><span class="s1">this</span><span class="s0">.unexpected()}flowParseQualifiedTypeIdentifier(e,t,r){e=e||</span><span class="s1">this</span><span class="s0">.state.start,t=t||</span><span class="s1">this</span><span class="s0">.state.startLoc;let n=r||</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.eat(c.dot);){const r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);r.qualification=n,r.id=</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s2">0</span><span class="s0">),n=</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;QualifiedTypeIdentifier&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">n}flowParseGenericType(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);</span><span class="s1">return </span><span class="s0">n.typeParameters=</span><span class="s1">null</span><span class="s0">,n.id=</span><span class="s1">this</span><span class="s0">.flowParseQualifiedTypeIdentifier(e,t,r),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(n.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiation()),</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;GenericTypeAnnotation&quot;</span><span class="s0">)}flowParseTypeofType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(c._typeof),e.argument=</span><span class="s1">this</span><span class="s0">.flowParsePrimaryType(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TypeofTypeAnnotation&quot;</span><span class="s0">)}flowParseTupleType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">for</span><span class="s0">(e.types=[],</span><span class="s1">this</span><span class="s0">.expect(c.bracketL);</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.bracketR)&amp;&amp;(e.types.push(</span><span class="s1">this</span><span class="s0">.flowParseType()),!</span><span class="s1">this</span><span class="s0">.match(c.bracketR));)</span><span class="s1">this</span><span class="s0">.expect(c.comma);</span><span class="s1">return this</span><span class="s0">.expect(c.bracketR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TupleTypeAnnotation&quot;</span><span class="s0">)}flowParseFunctionTypeParam(e){let t=</span><span class="s1">null</span><span class="s0">,r=!</span><span class="s2">1</span><span class="s0">,n=</span><span class="s1">null</span><span class="s0">;const i=</span><span class="s1">this</span><span class="s0">.startNode(),s=</span><span class="s1">this</span><span class="s0">.lookahead(),a=</span><span class="s1">this</span><span class="s0">.state.type===c._this;</span><span class="s1">return </span><span class="s0">s.type===c.colon||s.type===c.question?(a&amp;&amp;!e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(i.start,$.ThisParamMustBeFirst),t=</span><span class="s1">this</span><span class="s0">.parseIdentifier(a),</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(r=!</span><span class="s2">0</span><span class="s0">,a&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(i.start,$.ThisParamMayNotBeOptional)),n=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser()):n=</span><span class="s1">this</span><span class="s0">.flowParseType(),i.name=t,i.optional=r,i.typeAnnotation=n,</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s3">&quot;FunctionTypeParam&quot;</span><span class="s0">)}reinterpretTypeAsFunctionTypeParam(e){const t=</span><span class="s1">this</span><span class="s0">.startNodeAt(e.start,e.loc.start);</span><span class="s1">return </span><span class="s0">t.name=</span><span class="s1">null</span><span class="s0">,t.optional=!</span><span class="s2">1</span><span class="s0">,t.typeAnnotation=e,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;FunctionTypeParam&quot;</span><span class="s0">)}flowParseFunctionTypeParams(e=[]){let t=</span><span class="s1">null</span><span class="s0">,r=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._this)&amp;&amp;(r=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParam(!</span><span class="s2">0</span><span class="s0">),r.name=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(c.parenR)||</span><span class="s1">this</span><span class="s0">.expect(c.comma));!</span><span class="s1">this</span><span class="s0">.match(c.parenR)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.ellipsis);)e.push(</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParam(!</span><span class="s2">1</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.match(c.parenR)||</span><span class="s1">this</span><span class="s0">.expect(c.comma);</span><span class="s1">return this</span><span class="s0">.eat(c.ellipsis)&amp;&amp;(t=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParam(!</span><span class="s2">1</span><span class="s0">)),{params:e,rest:t,_this:r}}flowIdentToTypeAnnotation(e,t,r,n){</span><span class="s1">switch</span><span class="s0">(n.name){</span><span class="s1">case</span><span class="s3">&quot;any&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;AnyTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;bool&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;boolean&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;BooleanTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;mixed&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;MixedTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;empty&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;EmptyTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;number&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;NumberTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;string&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;StringTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;symbol&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;SymbolTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.checkNotUnderscore(n.name),</span><span class="s1">this</span><span class="s0">.flowParseGenericType(e,t,n)}}flowParsePrimaryType(){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc,r=</span><span class="s1">this</span><span class="s0">.startNode();let n,i,s=!</span><span class="s2">1</span><span class="s0">;const a=</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType;</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c.name:</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;interface&quot;</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.flowParseInterfaceType():</span><span class="s1">this</span><span class="s0">.flowIdentToTypeAnnotation(e,t,r,</span><span class="s1">this</span><span class="s0">.parseIdentifier());</span><span class="s1">case </span><span class="s0">c.braceL:</span><span class="s1">return this</span><span class="s0">.flowParseObjectType({allowStatic:!</span><span class="s2">1</span><span class="s0">,allowExact:!</span><span class="s2">1</span><span class="s0">,allowSpread:!</span><span class="s2">0</span><span class="s0">,allowProto:!</span><span class="s2">1</span><span class="s0">,allowInexact:!</span><span class="s2">0</span><span class="s0">});</span><span class="s1">case </span><span class="s0">c.braceBarL:</span><span class="s1">return this</span><span class="s0">.flowParseObjectType({allowStatic:!</span><span class="s2">1</span><span class="s0">,allowExact:!</span><span class="s2">0</span><span class="s0">,allowSpread:!</span><span class="s2">0</span><span class="s0">,allowProto:!</span><span class="s2">1</span><span class="s0">,allowInexact:!</span><span class="s2">1</span><span class="s0">});</span><span class="s1">case </span><span class="s0">c.bracketL:</span><span class="s1">return this</span><span class="s0">.state.noAnonFunctionType=!</span><span class="s2">1</span><span class="s0">,i=</span><span class="s1">this</span><span class="s0">.flowParseTupleType(),</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=a,i;</span><span class="s1">case </span><span class="s0">c.relational:</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value)</span><span class="s1">return </span><span class="s0">r.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration(),</span><span class="s1">this</span><span class="s0">.expect(c.parenL),n=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParams(),r.params=n.params,r.rest=n.rest,r.</span><span class="s1">this</span><span class="s0">=n._this,</span><span class="s1">this</span><span class="s0">.expect(c.parenR),</span><span class="s1">this</span><span class="s0">.expect(c.arrow),r.returnType=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">c.parenL:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),!</span><span class="s1">this</span><span class="s0">.match(c.parenR)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.ellipsis))</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.name)||</span><span class="s1">this</span><span class="s0">.match(c._this)){const e=</span><span class="s1">this</span><span class="s0">.lookahead().type;s=e!==c.question&amp;&amp;e!==c.colon}</span><span class="s1">else </span><span class="s0">s=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(s){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=!</span><span class="s2">1</span><span class="s0">,i=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=a,</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType||!(</span><span class="s1">this</span><span class="s0">.match(c.comma)||</span><span class="s1">this</span><span class="s0">.match(c.parenR)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookahead().type===c.arrow))</span><span class="s1">return this</span><span class="s0">.expect(c.parenR),i;</span><span class="s1">this</span><span class="s0">.eat(c.comma)}</span><span class="s1">return </span><span class="s0">n=i?</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParams([</span><span class="s1">this</span><span class="s0">.reinterpretTypeAsFunctionTypeParam(i)]):</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParams(),r.params=n.params,r.rest=n.rest,r.</span><span class="s1">this</span><span class="s0">=n._this,</span><span class="s1">this</span><span class="s0">.expect(c.parenR),</span><span class="s1">this</span><span class="s0">.expect(c.arrow),r.returnType=</span><span class="s1">this</span><span class="s0">.flowParseType(),r.typeParameters=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.string:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;StringLiteralTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._true:</span><span class="s1">case </span><span class="s0">c._false:</span><span class="s1">return </span><span class="s0">r.value=</span><span class="s1">this</span><span class="s0">.match(c._true),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;BooleanLiteralTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.plusMin:</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;-&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.num))</span><span class="s1">return this</span><span class="s0">.parseLiteral(-</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;NumberLiteralTypeAnnotation&quot;</span><span class="s0">,r.start,r.loc.start);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.bigint))</span><span class="s1">return this</span><span class="s0">.parseLiteral(-</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;BigIntLiteralTypeAnnotation&quot;</span><span class="s0">,r.start,r.loc.start);</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,$.UnexpectedSubtractionOperand)}</span><span class="s1">throw this</span><span class="s0">.unexpected();</span><span class="s1">case </span><span class="s0">c.num:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;NumberLiteralTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.bigint:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;BigIntLiteralTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._void:</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;VoidTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._null:</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;NullLiteralTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._this:</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;ThisTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.star:</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;ExistsTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;typeof&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.type.keyword)</span><span class="s1">return this</span><span class="s0">.flowParseTypeofType();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type.keyword){const e=</span><span class="s1">this</span><span class="s0">.state.type.label;</span><span class="s1">return this</span><span class="s0">.next(),super.createIdentifier(r,e)}}</span><span class="s1">throw this</span><span class="s0">.unexpected()}flowParsePostfixType(){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc;let r=</span><span class="s1">this</span><span class="s0">.flowParsePrimaryType(),n=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;(</span><span class="s1">this</span><span class="s0">.match(c.bracketL)||</span><span class="s1">this</span><span class="s0">.match(c.questionDot))&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon();){const i=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t),s=</span><span class="s1">this</span><span class="s0">.eat(c.questionDot);n=n||s,</span><span class="s1">this</span><span class="s0">.expect(c.bracketL),!s&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.bracketR)?(i.elementType=r,</span><span class="s1">this</span><span class="s0">.next(),r=</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s3">&quot;ArrayTypeAnnotation&quot;</span><span class="s0">)):(i.objectType=r,i.indexType=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),n?(i.optional=s,r=</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s3">&quot;OptionalIndexedAccessType&quot;</span><span class="s0">)):r=</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s3">&quot;IndexedAccessType&quot;</span><span class="s0">))}</span><span class="s1">return </span><span class="s0">r}flowParsePrefixType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.eat(c.question)?(e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParsePrefixType(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;NullableTypeAnnotation&quot;</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.flowParsePostfixType()}flowParseAnonFunctionWithoutParens(){const e=</span><span class="s1">this</span><span class="s0">.flowParsePrefixType();</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.arrow)){const t=</span><span class="s1">this</span><span class="s0">.startNodeAt(e.start,e.loc.start);</span><span class="s1">return </span><span class="s0">t.params=[</span><span class="s1">this</span><span class="s0">.reinterpretTypeAsFunctionTypeParam(e)],t.rest=</span><span class="s1">null</span><span class="s0">,t.</span><span class="s1">this</span><span class="s0">=</span><span class="s1">null</span><span class="s0">,t.returnType=</span><span class="s1">this</span><span class="s0">.flowParseType(),t.typeParameters=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}flowParseIntersectionType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.eat(c.bitwiseAND);const t=</span><span class="s1">this</span><span class="s0">.flowParseAnonFunctionWithoutParens();</span><span class="s1">for</span><span class="s0">(e.types=[t];</span><span class="s1">this</span><span class="s0">.eat(c.bitwiseAND);)e.types.push(</span><span class="s1">this</span><span class="s0">.flowParseAnonFunctionWithoutParens());</span><span class="s1">return </span><span class="s2">1</span><span class="s0">===e.types.length?t:</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;IntersectionTypeAnnotation&quot;</span><span class="s0">)}flowParseUnionType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.eat(c.bitwiseOR);const t=</span><span class="s1">this</span><span class="s0">.flowParseIntersectionType();</span><span class="s1">for</span><span class="s0">(e.types=[t];</span><span class="s1">this</span><span class="s0">.eat(c.bitwiseOR);)e.types.push(</span><span class="s1">this</span><span class="s0">.flowParseIntersectionType());</span><span class="s1">return </span><span class="s2">1</span><span class="s0">===e.types.length?t:</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;UnionTypeAnnotation&quot;</span><span class="s0">)}flowParseType(){const e=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s2">0</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.flowParseUnionType();</span><span class="s1">return this</span><span class="s0">.state.inType=e,</span><span class="s1">this</span><span class="s0">.state.exprAllowed=</span><span class="s1">this</span><span class="s0">.state.exprAllowed||</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType,t}flowParseTypeOrImplicitInstantiation(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type===c.name&amp;&amp;</span><span class="s3">&quot;_&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc,r=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">return this</span><span class="s0">.flowParseGenericType(e,t,r)}</span><span class="s1">return this</span><span class="s0">.flowParseType()}flowParseTypeAnnotation(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">)}flowParseTypeAnnotatableIdentifier(e){const t=e?</span><span class="s1">this</span><span class="s0">.parseIdentifier():</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier();</span><span class="s1">return this</span><span class="s0">.match(c.colon)&amp;&amp;(t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.resetEndLocation(t)),t}typeCastToParameter(e){</span><span class="s1">return </span><span class="s0">e.expression.typeAnnotation=e.typeAnnotation,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e.expression,e.typeAnnotation.end,e.typeAnnotation.loc.end),e.expression}flowParseVariance(){let e=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.match(c.plusMin)&amp;&amp;(e=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s3">&quot;+&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value?e.kind=</span><span class="s3">&quot;plus&quot;</span><span class="s0">:e.kind=</span><span class="s3">&quot;minus&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;Variance&quot;</span><span class="s0">)),e}parseFunctionBody(e,t,r=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">return </span><span class="s0">t?</span><span class="s1">this</span><span class="s0">.forwardNoArrowParamsConversionAt(e,(()=&gt;super.parseFunctionBody(e,!</span><span class="s2">0</span><span class="s0">,r))):super.parseFunctionBody(e,!</span><span class="s2">1</span><span class="s0">,r)}parseFunctionBodyAndFinish(e,t,r=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.colon)){const t=</span><span class="s1">this</span><span class="s0">.startNode();[t.typeAnnotation,e.predicate]=</span><span class="s1">this</span><span class="s0">.flowParseTypeAndPredicateInitialiser(),e.returnType=t.typeAnnotation?</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">):</span><span class="s1">null</span><span class="s0">}super.parseFunctionBodyAndFinish(e,t,r)}parseStatement(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.name)&amp;&amp;</span><span class="s3">&quot;interface&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value){const e=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s1">if</span><span class="s0">(e.type===c.name||Y(e.value)){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseInterface(e)}}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.shouldParseEnums()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;enum&quot;</span><span class="s0">)){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseEnumDeclaration(e)}const r=super.parseStatement(e,t);</span><span class="s1">return void </span><span class="s2">0</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.flowPragma||</span><span class="s1">this</span><span class="s0">.isValidDirective(r)||(</span><span class="s1">this</span><span class="s0">.flowPragma=</span><span class="s1">null</span><span class="s0">),r}parseExpressionStatement(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===t.type)</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;declare&quot;</span><span class="s0">===t.name){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._class)||</span><span class="s1">this</span><span class="s0">.match(c.name)||</span><span class="s1">this</span><span class="s0">.match(c._function)||</span><span class="s1">this</span><span class="s0">.match(c._var)||</span><span class="s1">this</span><span class="s0">.match(c._export))</span><span class="s1">return this</span><span class="s0">.flowParseDeclare(e)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.name)){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;interface&quot;</span><span class="s0">===t.name)</span><span class="s1">return this</span><span class="s0">.flowParseInterface(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;type&quot;</span><span class="s0">===t.name)</span><span class="s1">return this</span><span class="s0">.flowParseTypeAlias(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;opaque&quot;</span><span class="s0">===t.name)</span><span class="s1">return this</span><span class="s0">.flowParseOpaqueType(e,!</span><span class="s2">1</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">super.parseExpressionStatement(e,t)}shouldParseExportDeclaration(){</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;interface&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;opaque&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.shouldParseEnums()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;enum&quot;</span><span class="s0">)||super.shouldParseExportDeclaration()}isExportDefaultSpecifier(){</span><span class="s1">return</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c.name)||!(</span><span class="s3">&quot;type&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value||</span><span class="s3">&quot;interface&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value||</span><span class="s3">&quot;opaque&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value||</span><span class="s1">this</span><span class="s0">.shouldParseEnums()&amp;&amp;</span><span class="s3">&quot;enum&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value))&amp;&amp;super.isExportDefaultSpecifier()}parseExportDefaultExpression(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.shouldParseEnums()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;enum&quot;</span><span class="s0">)){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseEnumDeclaration(e)}</span><span class="s1">return </span><span class="s0">super.parseExportDefaultExpression()}parseConditional(e,t,r,n){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c.question))</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(n){const i=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;super.parseConditional(e,t,r)));</span><span class="s1">return </span><span class="s0">i.node?(i.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=i.failState),i.node):(n.start=i.error.pos||</span><span class="s1">this</span><span class="s0">.state.start,e)}</span><span class="s1">this</span><span class="s0">.expect(c.question);const i=</span><span class="s1">this</span><span class="s0">.state.clone(),s=</span><span class="s1">this</span><span class="s0">.state.noArrowAt,a=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);let{consequent:o,failed:l}=</span><span class="s1">this</span><span class="s0">.tryParseConditionalConsequent(),[p,u]=</span><span class="s1">this</span><span class="s0">.getArrowLikeExpressions(o);</span><span class="s1">if</span><span class="s0">(l||u.length&gt;</span><span class="s2">0</span><span class="s0">){const e=[...s];</span><span class="s1">if</span><span class="s0">(u.length&gt;</span><span class="s2">0</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.state=i,</span><span class="s1">this</span><span class="s0">.state.noArrowAt=e;</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">;t&lt;u.length;t++)e.push(u[t].start);({consequent:o,failed:l}=</span><span class="s1">this</span><span class="s0">.tryParseConditionalConsequent()),[p,u]=</span><span class="s1">this</span><span class="s0">.getArrowLikeExpressions(o)}l&amp;&amp;p.length&gt;</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(i.start,$.AmbiguousConditionalArrow),l&amp;&amp;</span><span class="s2">1</span><span class="s0">===p.length&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=i,</span><span class="s1">this</span><span class="s0">.state.noArrowAt=e.concat(p[</span><span class="s2">0</span><span class="s0">].start),({consequent:o,failed:l}=</span><span class="s1">this</span><span class="s0">.tryParseConditionalConsequent()))}</span><span class="s1">return this</span><span class="s0">.getArrowLikeExpressions(o,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.noArrowAt=s,</span><span class="s1">this</span><span class="s0">.expect(c.colon),a.test=e,a.consequent=o,a.alternate=</span><span class="s1">this</span><span class="s0">.forwardNoArrowParamsConversionAt(a,(()=&gt;</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">))),</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s0">)}tryParseConditionalConsequent(){</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.push(</span><span class="s1">this</span><span class="s0">.state.start);const e=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),t=!</span><span class="s1">this</span><span class="s0">.match(c.colon);</span><span class="s1">return this</span><span class="s0">.state.noArrowParamsConversionAt.pop(),{consequent:e,failed:t}}getArrowLikeExpressions(e,t){const r=[e],n=[];</span><span class="s1">for</span><span class="s0">(;</span><span class="s2">0</span><span class="s0">!==r.length;){const e=r.pop();</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">===e.type?(e.typeParameters||!e.returnType?</span><span class="s1">this</span><span class="s0">.finishArrowValidation(e):n.push(e),r.push(e.body)):</span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s0">===e.type&amp;&amp;(r.push(e.consequent),r.push(e.alternate))}</span><span class="s1">return </span><span class="s0">t?(n.forEach((e=&gt;</span><span class="s1">this</span><span class="s0">.finishArrowValidation(e))),[n,[]]):</span><span class="s1">function</span><span class="s0">(e,t){const r=[],n=[];</span><span class="s1">for</span><span class="s0">(let i=</span><span class="s2">0</span><span class="s0">;i&lt;e.length;i++)(t(e[i])?r:n).push(e[i]);</span><span class="s1">return</span><span class="s0">[r,n]}(n,(e=&gt;e.params.every((e=&gt;</span><span class="s1">this</span><span class="s0">.isAssignable(e,!</span><span class="s2">0</span><span class="s0">)))))}finishArrowValidation(e){</span><span class="s1">var </span><span class="s0">t;</span><span class="s1">this</span><span class="s0">.toAssignableList(e.params,</span><span class="s1">null</span><span class="s0">==(t=e.extra)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.trailingComma,!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">6</span><span class="s0">),super.checkParams(e,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.exit()}forwardNoArrowParamsConversionAt(e,t){let r;</span><span class="s1">return</span><span class="s0">-</span><span class="s2">1</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.indexOf(e.start)?(</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.push(</span><span class="s1">this</span><span class="s0">.state.start),r=t(),</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.pop()):r=t(),r}parseParenItem(e,t,r){</span><span class="s1">if</span><span class="s0">(e=super.parseParenItem(e,t,r),</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(e.optional=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e)),</span><span class="s1">this</span><span class="s0">.match(c.colon)){const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">n.expression=e,n.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}assertModuleNodeAllowed(e){</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s3">&quot;type&quot;</span><span class="s0">===e.importKind||</span><span class="s3">&quot;typeof&quot;</span><span class="s0">===e.importKind)||</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;type&quot;</span><span class="s0">===e.exportKind||</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;type&quot;</span><span class="s0">===e.exportKind||super.assertModuleNodeAllowed(e)}parseExport(e){const t=super.parseExport(e);</span><span class="s1">return</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">!==t.type&amp;&amp;</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">!==t.type||(t.exportKind=t.exportKind||</span><span class="s3">&quot;value&quot;</span><span class="s0">),t}parseExportDeclaration(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)){e.exportKind=</span><span class="s3">&quot;type&quot;</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.braceL)?(e.specifiers=</span><span class="s1">this</span><span class="s0">.parseExportSpecifiers(),</span><span class="s1">this</span><span class="s0">.parseExportFrom(e),</span><span class="s1">null</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.flowParseTypeAlias(t)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;opaque&quot;</span><span class="s0">)){e.exportKind=</span><span class="s3">&quot;type&quot;</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseOpaqueType(t,!</span><span class="s2">1</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;interface&quot;</span><span class="s0">)){e.exportKind=</span><span class="s3">&quot;type&quot;</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseInterface(t)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.shouldParseEnums()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;enum&quot;</span><span class="s0">)){e.exportKind=</span><span class="s3">&quot;value&quot;</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseEnumDeclaration(t)}</span><span class="s1">return </span><span class="s0">super.parseExportDeclaration(e)}eatExportStar(e){</span><span class="s1">return</span><span class="s0">!!super.eatExportStar(...arguments)||!(!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.lookahead().type!==c.star)&amp;&amp;(e.exportKind=</span><span class="s3">&quot;type&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.next(),!</span><span class="s2">0</span><span class="s0">)}maybeParseExportNamespaceSpecifier(e){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=super.maybeParseExportNamespaceSpecifier(e);</span><span class="s1">return </span><span class="s0">r&amp;&amp;</span><span class="s3">&quot;type&quot;</span><span class="s0">===e.exportKind&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(t),r}parseClassId(e,t,r){super.parseClassId(e,t,r),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration())}parseClassMember(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.state.start;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;declare&quot;</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parseClassMemberFromModifier(e,t))</span><span class="s1">return</span><span class="s0">;t.declare=!</span><span class="s2">0</span><span class="s0">}super.parseClassMember(e,t,r),t.declare&amp;&amp;(</span><span class="s3">&quot;ClassProperty&quot;</span><span class="s0">!==t.type&amp;&amp;</span><span class="s3">&quot;ClassPrivateProperty&quot;</span><span class="s0">!==t.type&amp;&amp;</span><span class="s3">&quot;PropertyDefinition&quot;</span><span class="s0">!==t.type?</span><span class="s1">this</span><span class="s0">.raise(n,$.DeclareClassElement):t.value&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.value.start,$.DeclareClassFieldInitializer))}isIterator(e){</span><span class="s1">return</span><span class="s3">&quot;iterator&quot;</span><span class="s0">===e||</span><span class="s3">&quot;asyncIterator&quot;</span><span class="s0">===e}readIterator(){const e=super.readWord1(),t=</span><span class="s3">&quot;@@&quot;</span><span class="s0">+e;</span><span class="s1">this</span><span class="s0">.isIterator(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.inType||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.InvalidIdentifier,t),</span><span class="s1">this</span><span class="s0">.finishToken(c.name,t)}getTokenFromCode(e){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">return </span><span class="s2">123</span><span class="s0">===e&amp;&amp;</span><span class="s2">124</span><span class="s0">===t?</span><span class="s1">this</span><span class="s0">.finishOp(c.braceBarL,</span><span class="s2">2</span><span class="s0">):!</span><span class="s1">this</span><span class="s0">.state.inType||</span><span class="s2">62</span><span class="s0">!==e&amp;&amp;</span><span class="s2">60</span><span class="s0">!==e?</span><span class="s1">this</span><span class="s0">.state.inType&amp;&amp;</span><span class="s2">63</span><span class="s0">===e?</span><span class="s2">46</span><span class="s0">===t?</span><span class="s1">this</span><span class="s0">.finishOp(c.questionDot,</span><span class="s2">2</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(c.question,</span><span class="s2">1</span><span class="s0">):</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s2">64</span><span class="s0">===e&amp;&amp;</span><span class="s2">64</span><span class="s0">===t}(e,t)?(</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.readIterator()):super.getTokenFromCode(e):</span><span class="s1">this</span><span class="s0">.finishOp(c.relational,</span><span class="s2">1</span><span class="s0">)}isAssignable(e,t){</span><span class="s1">switch</span><span class="s0">(e.type){</span><span class="s1">case</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s0">:{const t=e.properties.length-1;</span><span class="s1">return </span><span class="s0">e.properties.every(((e,r)=&gt;</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">!==e.type&amp;&amp;(r===t||</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">===e.type)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isAssignable(e)))}</span><span class="s1">case</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.isAssignable(e.value);</span><span class="s1">case</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.isAssignable(e.argument);</span><span class="s1">case</span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.elements.every((e=&gt;</span><span class="s1">this</span><span class="s0">.isAssignable(e)));</span><span class="s1">case</span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;=&quot;</span><span class="s0">===e.operator;</span><span class="s1">case</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.isAssignable(e.expression);</span><span class="s1">case</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!t;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}}toAssignable(e,t=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">return</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">===e.type?super.toAssignable(</span><span class="s1">this</span><span class="s0">.typeCastToParameter(e),t):super.toAssignable(e,t)}toAssignableList(e,t,r){</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">;t&lt;e.length;t++){const r=e[t];</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">===(</span><span class="s1">null</span><span class="s0">==r?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.type)&amp;&amp;(e[t]=</span><span class="s1">this</span><span class="s0">.typeCastToParameter(r))}</span><span class="s1">return </span><span class="s0">super.toAssignableList(e,t,r)}toReferencedList(e,t){</span><span class="s1">for</span><span class="s0">(let n=</span><span class="s2">0</span><span class="s0">;n&lt;e.length;n++){</span><span class="s1">var </span><span class="s0">r;const i=e[n];!i||</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">!==i.type||</span><span class="s1">null</span><span class="s0">!=(r=i.extra)&amp;&amp;r.parenthesized||!(e.length&gt;</span><span class="s2">1</span><span class="s0">)&amp;&amp;t||</span><span class="s1">this</span><span class="s0">.raise(i.typeAnnotation.start,$.TypeCastInPattern)}</span><span class="s1">return </span><span class="s0">e}parseArrayLike(e,t,r,n){const i=super.parseArrayLike(e,t,r,n);</span><span class="s1">return </span><span class="s0">t&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters&amp;&amp;</span><span class="s1">this</span><span class="s0">.toReferencedList(i.elements),i}checkLVal(e,...t){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">!==e.type)</span><span class="s1">return </span><span class="s0">super.checkLVal(e,...t)}parseClassProperty(e){</span><span class="s1">return this</span><span class="s0">.match(c.colon)&amp;&amp;(e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation()),super.parseClassProperty(e)}parseClassPrivateProperty(e){</span><span class="s1">return this</span><span class="s0">.match(c.colon)&amp;&amp;(e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation()),super.parseClassPrivateProperty(e)}isClassMethod(){</span><span class="s1">return this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)||super.isClassMethod()}isClassProperty(){</span><span class="s1">return this</span><span class="s0">.match(c.colon)||super.isClassProperty()}isNonstaticConstructor(e){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.match(c.colon)&amp;&amp;super.isNonstaticConstructor(e)}pushClassMethod(e,t,r,n,i,s){</span><span class="s1">if</span><span class="s0">(t.variance&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(t.variance.start),</span><span class="s1">delete </span><span class="s0">t.variance,</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(t.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration()),super.pushClassMethod(e,t,r,n,i,s),t.params&amp;&amp;i){const e=t.params;e.length&gt;</span><span class="s2">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.isThisParam(e[</span><span class="s2">0</span><span class="s0">])&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,$.ThisParamBannedInConstructor)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;MethodDefinition&quot;</span><span class="s0">===t.type&amp;&amp;i&amp;&amp;t.value.params){const e=t.value.params;e.length&gt;</span><span class="s2">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.isThisParam(e[</span><span class="s2">0</span><span class="s0">])&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,$.ThisParamBannedInConstructor)}}pushClassPrivateMethod(e,t,r,n){t.variance&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(t.variance.start),</span><span class="s1">delete </span><span class="s0">t.variance,</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(t.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration()),super.pushClassPrivateMethod(e,t,r,n)}parseClassSuper(e){</span><span class="s1">if</span><span class="s0">(super.parseClassSuper(e),e.superClass&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(e.superTypeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiation()),</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;implements&quot;</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.next();const t=e.implements=[];</span><span class="s1">do</span><span class="s0">{const e=</span><span class="s1">this</span><span class="s0">.startNode();e.id=</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)?e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiation():e.typeParameters=</span><span class="s1">null</span><span class="s0">,t.push(</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ClassImplements&quot;</span><span class="s0">))}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.comma))}}checkGetterSetterParams(e){super.checkGetterSetterParams(e);const t=</span><span class="s1">this</span><span class="s0">.getObjectOrClassMethodParams(e);</span><span class="s1">if</span><span class="s0">(t.length&gt;</span><span class="s2">0</span><span class="s0">){const r=t[</span><span class="s2">0</span><span class="s0">];</span><span class="s1">this</span><span class="s0">.isThisParam(r)&amp;&amp;</span><span class="s3">&quot;get&quot;</span><span class="s0">===e.kind?</span><span class="s1">this</span><span class="s0">.raise(r.start,$.GetterMayNotHaveThisParam):</span><span class="s1">this</span><span class="s0">.isThisParam(r)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r.start,$.SetterMayNotHaveThisParam)}}parsePropertyName(e,t){const r=</span><span class="s1">this</span><span class="s0">.flowParseVariance(),n=super.parsePropertyName(e,t);</span><span class="s1">return </span><span class="s0">e.variance=r,n}parseObjPropValue(e,t,r,n,i,s,a,o){let l;e.variance&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(e.variance.start),</span><span class="s1">delete </span><span class="s0">e.variance,</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;!a&amp;&amp;(l=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration(),</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.unexpected()),super.parseObjPropValue(e,t,r,n,i,s,a,o),l&amp;&amp;((e.value||e).typeParameters=l)}parseAssignableListItemTypes(e){</span><span class="s1">return this</span><span class="s0">.eat(c.question)&amp;&amp;(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,$.OptionalBindingPattern),</span><span class="s1">this</span><span class="s0">.isThisParam(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,$.ThisParamMayNotBeOptional),e.optional=!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(c.colon)?e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation():</span><span class="s1">this</span><span class="s0">.isThisParam(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,$.ThisParamAnnotationRequired),</span><span class="s1">this</span><span class="s0">.match(c.eq)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isThisParam(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,$.ThisParamNoDefault),</span><span class="s1">this</span><span class="s0">.resetEndLocation(e),e}parseMaybeDefault(e,t,r){const n=super.parseMaybeDefault(e,t,r);</span><span class="s1">return</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">===n.type&amp;&amp;n.typeAnnotation&amp;&amp;n.right.start&lt;n.typeAnnotation.start&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(n.typeAnnotation.start,$.TypeBeforeInitializer),n}shouldParseDefaultImport(e){</span><span class="s1">return </span><span class="s0">Q(e)?Z(</span><span class="s1">this</span><span class="s0">.state):super.shouldParseDefaultImport(e)}parseImportSpecifierLocal(e,t,r,n){t.local=Q(e)?</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkLVal(t.local,n,</span><span class="s2">9</span><span class="s0">),e.specifiers.push(</span><span class="s1">this</span><span class="s0">.finishNode(t,r))}maybeParseDefaultImportSpecifier(e){e.importKind=</span><span class="s3">&quot;value&quot;</span><span class="s0">;let t=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._typeof)?t=</span><span class="s3">&quot;typeof&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)&amp;&amp;(t=</span><span class="s3">&quot;type&quot;</span><span class="s0">),t){const r=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s3">&quot;type&quot;</span><span class="s0">===t&amp;&amp;r.type===c.star&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(r.start),(Z(r)||r.type===c.braceL||r.type===c.star)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),e.importKind=t)}</span><span class="s1">return </span><span class="s0">super.maybeParseDefaultImportSpecifier(e)}parseImportSpecifier(e){const t=</span><span class="s1">this</span><span class="s0">.startNode(),r=</span><span class="s1">this</span><span class="s0">.state.start,n=</span><span class="s1">this</span><span class="s0">.parseModuleExportName();let i=</span><span class="s1">null</span><span class="s0">;</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===n.type&amp;&amp;(</span><span class="s3">&quot;type&quot;</span><span class="s0">===n.name?i=</span><span class="s3">&quot;type&quot;</span><span class="s0">:</span><span class="s3">&quot;typeof&quot;</span><span class="s0">===n.name&amp;&amp;(i=</span><span class="s3">&quot;typeof&quot;</span><span class="s0">));let s=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isLookaheadContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">)){const e=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">null</span><span class="s0">===i||</span><span class="s1">this</span><span class="s0">.match(c.name)||</span><span class="s1">this</span><span class="s0">.state.type.keyword?(t.imported=n,t.importKind=</span><span class="s1">null</span><span class="s0">,t.local=</span><span class="s1">this</span><span class="s0">.parseIdentifier()):(t.imported=e,t.importKind=i,t.local=e.__clone())}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!==i&amp;&amp;(</span><span class="s1">this</span><span class="s0">.match(c.name)||</span><span class="s1">this</span><span class="s0">.state.type.keyword))t.imported=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),t.importKind=i,</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">)?t.local=</span><span class="s1">this</span><span class="s0">.parseIdentifier():(s=!</span><span class="s2">0</span><span class="s0">,t.local=t.imported.__clone());</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===n.type)</span><span class="s1">throw this</span><span class="s0">.raise(t.start,E.ImportBindingIsString,n.value);s=!</span><span class="s2">0</span><span class="s0">,t.imported=n,t.importKind=</span><span class="s1">null</span><span class="s0">,t.local=t.imported.__clone()}const a=Q(e),o=Q(t);a&amp;&amp;o&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r,$.ImportTypeShorthandOnlyInPureImport),(a||o)&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkReservedType(t.local.name,t.local.start,!</span><span class="s2">0</span><span class="s0">),!s||a||o||</span><span class="s1">this</span><span class="s0">.checkReservedWord(t.local.name,t.start,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.checkLVal(t.local,</span><span class="s3">&quot;import specifier&quot;</span><span class="s0">,</span><span class="s2">9</span><span class="s0">),e.specifiers.push(</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s0">))}parseBindingAtom(){</span><span class="s1">return this</span><span class="s0">.state.type===c._this?</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">):super.parseBindingAtom()}parseFunctionParams(e,t){const r=e.kind;</span><span class="s3">&quot;get&quot;</span><span class="s0">!==r&amp;&amp;</span><span class="s3">&quot;set&quot;</span><span class="s0">!==r&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration()),super.parseFunctionParams(e,t)}parseVarId(e,t){super.parseVarId(e,t),</span><span class="s1">this</span><span class="s0">.match(c.colon)&amp;&amp;(e.id.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.resetEndLocation(e.id))}parseAsyncArrowFromCallExpression(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.colon)){const t=</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType;</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=!</span><span class="s2">0</span><span class="s0">,e.returnType=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=t}</span><span class="s1">return </span><span class="s0">super.parseAsyncArrowFromCallExpression(e,t)}shouldParseAsyncArrow(){</span><span class="s1">return this</span><span class="s0">.match(c.colon)||super.shouldParseAsyncArrow()}parseMaybeAssign(e,t,r){</span><span class="s1">var </span><span class="s0">n;let i,s=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;jsx&quot;</span><span class="s0">)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.match(c.jsxTagStart)||</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">))){</span><span class="s1">if</span><span class="s0">(s=</span><span class="s1">this</span><span class="s0">.state.clone(),i=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;super.parseMaybeAssign(e,t,r)),s),!i.error)</span><span class="s1">return </span><span class="s0">i.node;const{context:n}=</span><span class="s1">this</span><span class="s0">.state;n[n.length-1]===O.j_oTag?n.length-=</span><span class="s2">2</span><span class="s0">:n[n.length-1]===O.j_expr&amp;&amp;(n.length-=</span><span class="s2">1</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=(n=i)&amp;&amp;n.error||</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)){</span><span class="s1">var </span><span class="s0">a,o;let n;s=s||</span><span class="s1">this</span><span class="s0">.state.clone();const l=</span><span class="s1">this</span><span class="s0">.tryParse((i=&gt;{</span><span class="s1">var </span><span class="s0">s;n=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration();const a=</span><span class="s1">this</span><span class="s0">.forwardNoArrowParamsConversionAt(n,(()=&gt;{const i=super.parseMaybeAssign(e,t,r);</span><span class="s1">return this</span><span class="s0">.resetStartLocationFromNode(i,n),i}));</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">!==a.type&amp;&amp;</span><span class="s1">null</span><span class="s0">!=(s=a.extra)&amp;&amp;s.parenthesized&amp;&amp;i();const o=</span><span class="s1">this</span><span class="s0">.maybeUnwrapTypeCastExpression(a);</span><span class="s1">return </span><span class="s0">o.typeParameters=n,</span><span class="s1">this</span><span class="s0">.resetStartLocationFromNode(o,n),a}),s);let p=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(l.node&amp;&amp;</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.maybeUnwrapTypeCastExpression(l.node).type){</span><span class="s1">if</span><span class="s0">(!l.error&amp;&amp;!l.aborted)</span><span class="s1">return </span><span class="s0">l.node.async&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(n.start,$.UnexpectedTypeParameterBeforeAsyncArrowFunction),l.node;p=l.node}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=(a=i)&amp;&amp;a.node)</span><span class="s1">return this</span><span class="s0">.state=i.failState,i.node;</span><span class="s1">if</span><span class="s0">(p)</span><span class="s1">return this</span><span class="s0">.state=l.failState,p;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=(o=i)&amp;&amp;o.thrown)</span><span class="s1">throw </span><span class="s0">i.error;</span><span class="s1">if</span><span class="s0">(l.thrown)</span><span class="s1">throw </span><span class="s0">l.error;</span><span class="s1">throw this</span><span class="s0">.raise(n.start,$.UnexpectedTokenAfterTypeParameter)}</span><span class="s1">return </span><span class="s0">super.parseMaybeAssign(e,t,r)}parseArrow(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.colon)){const t=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;{const t=</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType;</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=!</span><span class="s2">0</span><span class="s0">;const r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return</span><span class="s0">[r.typeAnnotation,e.predicate]=</span><span class="s1">this</span><span class="s0">.flowParseTypeAndPredicateInitialiser(),</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=t,</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.match(c.arrow)||</span><span class="s1">this</span><span class="s0">.unexpected(),r}));</span><span class="s1">if</span><span class="s0">(t.thrown)</span><span class="s1">return null</span><span class="s0">;t.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=t.failState),e.returnType=t.node.typeAnnotation?</span><span class="s1">this</span><span class="s0">.finishNode(t.node,</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">):</span><span class="s1">null</span><span class="s0">}</span><span class="s1">return </span><span class="s0">super.parseArrow(e)}shouldParseArrow(){</span><span class="s1">return this</span><span class="s0">.match(c.colon)||super.shouldParseArrow()}setArrowFunctionParameters(e,t){-</span><span class="s2">1</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.indexOf(e.start)?e.params=t:super.setArrowFunctionParameters(e,t)}checkParams(e,t,r){</span><span class="s1">if</span><span class="s0">(!r||-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.indexOf(e.start)){</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">;t&lt;e.params.length;t++)</span><span class="s1">this</span><span class="s0">.isThisParam(e.params[t])&amp;&amp;t&gt;</span><span class="s2">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.params[t].start,$.ThisParamMustBeFirst);</span><span class="s1">return </span><span class="s0">super.checkParams(...arguments)}}parseParenAndDistinguishExpression(e){</span><span class="s1">return </span><span class="s0">super.parseParenAndDistinguishExpression(e&amp;&amp;-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.noArrowAt.indexOf(</span><span class="s1">this</span><span class="s0">.state.start))}parseSubscripts(e,t,r,n){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;async&quot;</span><span class="s0">===e.name&amp;&amp;-</span><span class="s2">1</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.state.noArrowAt.indexOf(t)){</span><span class="s1">this</span><span class="s0">.next();const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);n.callee=e,n.arguments=</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(c.parenR,!</span><span class="s2">1</span><span class="s0">),e=</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;CallExpression&quot;</span><span class="s0">)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;async&quot;</span><span class="s0">===e.name&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)){const i=</span><span class="s1">this</span><span class="s0">.state.clone(),s=</span><span class="s1">this</span><span class="s0">.tryParse((e=&gt;</span><span class="s1">this</span><span class="s0">.parseAsyncArrowWithTypeParameters(t,r)||e()),i);</span><span class="s1">if</span><span class="s0">(!s.error&amp;&amp;!s.aborted)</span><span class="s1">return </span><span class="s0">s.node;const a=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;super.parseSubscripts(e,t,r,n)),i);</span><span class="s1">if</span><span class="s0">(a.node&amp;&amp;!a.error)</span><span class="s1">return </span><span class="s0">a.node;</span><span class="s1">if</span><span class="s0">(s.node)</span><span class="s1">return this</span><span class="s0">.state=s.failState,s.node;</span><span class="s1">if</span><span class="s0">(a.node)</span><span class="s1">return this</span><span class="s0">.state=a.failState,a.node;</span><span class="s1">throw </span><span class="s0">s.error||a.error}</span><span class="s1">return </span><span class="s0">super.parseSubscripts(e,t,r,n)}parseSubscript(e,t,r,n,i){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.questionDot)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isLookaheadToken_lt()){</span><span class="s1">if</span><span class="s0">(i.optionalChainMember=!</span><span class="s2">0</span><span class="s0">,n)</span><span class="s1">return </span><span class="s0">i.stop=!</span><span class="s2">0</span><span class="s0">,e;</span><span class="s1">this</span><span class="s0">.next();const s=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">s.callee=e,s.typeArguments=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiation(),</span><span class="s1">this</span><span class="s0">.expect(c.parenL),s.arguments=</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(c.parenR,!</span><span class="s2">1</span><span class="s0">),s.optional=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishCallExpression(s,!</span><span class="s2">0</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(!n&amp;&amp;</span><span class="s1">this</span><span class="s0">.shouldParseTypes()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)){const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);n.callee=e;const s=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;(n.typeArguments=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiationCallOrNew(),</span><span class="s1">this</span><span class="s0">.expect(c.parenL),n.arguments=</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(c.parenR,!</span><span class="s2">1</span><span class="s0">),i.optionalChainMember&amp;&amp;(n.optional=!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishCallExpression(n,i.optionalChainMember))));</span><span class="s1">if</span><span class="s0">(s.node)</span><span class="s1">return </span><span class="s0">s.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=s.failState),s.node}</span><span class="s1">return </span><span class="s0">super.parseSubscript(e,t,r,n,i)}parseNewArguments(e){let t=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.shouldParseTypes()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(t=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiationCallOrNew())).node),e.typeArguments=t,super.parseNewArguments(e)}parseAsyncArrowWithTypeParameters(e,t){const r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parseFunctionParams(r),</span><span class="s1">this</span><span class="s0">.parseArrow(r))</span><span class="s1">return this</span><span class="s0">.parseArrowExpression(r,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">)}readToken_mult_modulo(e){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">42</span><span class="s0">===e&amp;&amp;</span><span class="s2">47</span><span class="s0">===t&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.hasFlowComment)</span><span class="s1">return this</span><span class="s0">.state.hasFlowComment=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">,</span><span class="s1">void this</span><span class="s0">.nextToken();super.readToken_mult_modulo(e)}readToken_pipe_amp(e){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);</span><span class="s2">124</span><span class="s0">!==e||</span><span class="s2">125</span><span class="s0">!==t?super.readToken_pipe_amp(e):</span><span class="s1">this</span><span class="s0">.finishOp(c.braceBarR,</span><span class="s2">2</span><span class="s0">)}parseTopLevel(e,t){const r=super.parseTopLevel(e,t);</span><span class="s1">return this</span><span class="s0">.state.hasFlowComment&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,$.UnterminatedFlowComment),r}skipBlockComment(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;flowComments&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.skipFlowComment())</span><span class="s1">return this</span><span class="s0">.state.hasFlowComment&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,$.NestedFlowComment),</span><span class="s1">this</span><span class="s0">.hasFlowCommentCompletion(),</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s1">this</span><span class="s0">.skipFlowComment(),</span><span class="s1">void</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.hasFlowComment=!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.hasFlowComment){const e=</span><span class="s1">this</span><span class="s0">.input.indexOf(</span><span class="s3">&quot;*-/&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(-</span><span class="s2">1</span><span class="s0">===e)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos-2,E.UnterminatedComment);</span><span class="s1">this</span><span class="s0">.state.pos=e+</span><span class="s2">3</span><span class="s0">}</span><span class="s1">else </span><span class="s0">super.skipBlockComment()}skipFlowComment(){const{pos:e}=</span><span class="s1">this</span><span class="s0">.state;let t=</span><span class="s2">2</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;[</span><span class="s2">32</span><span class="s0">,</span><span class="s2">9</span><span class="s0">].includes(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e+t));)t++;const r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(t+e),n=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(t+e+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">return </span><span class="s2">58</span><span class="s0">===r&amp;&amp;</span><span class="s2">58</span><span class="s0">===n?t+</span><span class="s2">2</span><span class="s0">:</span><span class="s3">&quot;flow-include&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.slice(t+e,t+e+</span><span class="s2">12</span><span class="s0">)?t+</span><span class="s2">12</span><span class="s0">:</span><span class="s2">58</span><span class="s0">===r&amp;&amp;</span><span class="s2">58</span><span class="s0">!==n&amp;&amp;t}hasFlowCommentCompletion(){</span><span class="s1">if</span><span class="s0">(-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.indexOf(</span><span class="s3">&quot;*/&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.UnterminatedComment)}flowEnumErrorBooleanMemberNotInitialized(e,{enumName:t,memberName:r}){</span><span class="s1">this</span><span class="s0">.raise(e,$.EnumBooleanMemberNotInitialized,r,t)}flowEnumErrorInvalidMemberName(e,{enumName:t,memberName:r}){const n=r[</span><span class="s2">0</span><span class="s0">].toUpperCase()+r.slice(</span><span class="s2">1</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.raise(e,$.EnumInvalidMemberName,r,n,t)}flowEnumErrorDuplicateMemberName(e,{enumName:t,memberName:r}){</span><span class="s1">this</span><span class="s0">.raise(e,$.EnumDuplicateMemberName,r,t)}flowEnumErrorInconsistentMemberValues(e,{enumName:t}){</span><span class="s1">this</span><span class="s0">.raise(e,$.EnumInconsistentMemberValues,t)}flowEnumErrorInvalidExplicitType(e,{enumName:t,suppliedType:r}){</span><span class="s1">return this</span><span class="s0">.raise(e,</span><span class="s1">null</span><span class="s0">===r?$.EnumInvalidExplicitTypeUnknownSupplied:$.EnumInvalidExplicitType,t,r)}flowEnumErrorInvalidMemberInitializer(e,{enumName:t,explicitType:r,memberName:n}){let i=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">switch</span><span class="s0">(r){</span><span class="s1">case</span><span class="s3">&quot;boolean&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;number&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;string&quot;</span><span class="s0">:i=$.EnumInvalidMemberInitializerPrimaryType;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;symbol&quot;</span><span class="s0">:i=$.EnumInvalidMemberInitializerSymbolType;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:i=$.EnumInvalidMemberInitializerUnknownType}</span><span class="s1">return this</span><span class="s0">.raise(e,i,t,n,r)}flowEnumErrorNumberMemberNotInitialized(e,{enumName:t,memberName:r}){</span><span class="s1">this</span><span class="s0">.raise(e,$.EnumNumberMemberNotInitialized,t,r)}flowEnumErrorStringMemberInconsistentlyInitailized(e,{enumName:t}){</span><span class="s1">this</span><span class="s0">.raise(e,$.EnumStringMemberInconsistentlyInitailized,t)}flowEnumMemberInit(){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=()=&gt;</span><span class="s1">this</span><span class="s0">.match(c.comma)||</span><span class="s1">this</span><span class="s0">.match(c.braceR);</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c.num:{const r=</span><span class="s1">this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">t()?{type:</span><span class="s3">&quot;number&quot;</span><span class="s0">,pos:r.start,value:r}:{type:</span><span class="s3">&quot;invalid&quot;</span><span class="s0">,pos:e}}</span><span class="s1">case </span><span class="s0">c.string:{const r=</span><span class="s1">this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">t()?{type:</span><span class="s3">&quot;string&quot;</span><span class="s0">,pos:r.start,value:r}:{type:</span><span class="s3">&quot;invalid&quot;</span><span class="s0">,pos:e}}</span><span class="s1">case </span><span class="s0">c._true:</span><span class="s1">case </span><span class="s0">c._false:{const r=</span><span class="s1">this</span><span class="s0">.parseBooleanLiteral();</span><span class="s1">return </span><span class="s0">t()?{type:</span><span class="s3">&quot;boolean&quot;</span><span class="s0">,pos:r.start,value:r}:{type:</span><span class="s3">&quot;invalid&quot;</span><span class="s0">,pos:e}}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">{type:</span><span class="s3">&quot;invalid&quot;</span><span class="s0">,pos:e}}}flowEnumMemberRaw(){const e=</span><span class="s1">this</span><span class="s0">.state.start;</span><span class="s1">return</span><span class="s0">{id:</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),init:</span><span class="s1">this</span><span class="s0">.eat(c.eq)?</span><span class="s1">this</span><span class="s0">.flowEnumMemberInit():{type:</span><span class="s3">&quot;none&quot;</span><span class="s0">,pos:e}}}flowEnumCheckExplicitTypeMismatch(e,t,r){const{explicitType:n}=t;</span><span class="s1">null</span><span class="s0">!==n&amp;&amp;n!==r&amp;&amp;</span><span class="s1">this</span><span class="s0">.flowEnumErrorInvalidMemberInitializer(e,t)}flowEnumMembers({enumName:e,explicitType:t}){const r=</span><span class="s1">new </span><span class="s0">Set,n={booleanMembers:[],numberMembers:[],stringMembers:[],defaultedMembers:[]};let i=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.match(c.braceR);){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.ellipsis)){i=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">break</span><span class="s0">}const s=</span><span class="s1">this</span><span class="s0">.startNode(),{id:a,init:o}=</span><span class="s1">this</span><span class="s0">.flowEnumMemberRaw(),l=a.name;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;&quot;</span><span class="s0">===l)</span><span class="s1">continue</span><span class="s0">;/^[a-z]/.test(l)&amp;&amp;</span><span class="s1">this</span><span class="s0">.flowEnumErrorInvalidMemberName(a.start,{enumName:e,memberName:l}),r.has(l)&amp;&amp;</span><span class="s1">this</span><span class="s0">.flowEnumErrorDuplicateMemberName(a.start,{enumName:e,memberName:l}),r.add(l);const p={enumName:e,explicitType:t,memberName:l};</span><span class="s1">switch</span><span class="s0">(s.id=a,o.type){</span><span class="s1">case</span><span class="s3">&quot;boolean&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.flowEnumCheckExplicitTypeMismatch(o.pos,p,</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),s.init=o.value,n.booleanMembers.push(</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s3">&quot;EnumBooleanMember&quot;</span><span class="s0">));</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;number&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.flowEnumCheckExplicitTypeMismatch(o.pos,p,</span><span class="s3">&quot;number&quot;</span><span class="s0">),s.init=o.value,n.numberMembers.push(</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s3">&quot;EnumNumberMember&quot;</span><span class="s0">));</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;string&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.flowEnumCheckExplicitTypeMismatch(o.pos,p,</span><span class="s3">&quot;string&quot;</span><span class="s0">),s.init=o.value,n.stringMembers.push(</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s3">&quot;EnumStringMember&quot;</span><span class="s0">));</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;invalid&quot;</span><span class="s0">:</span><span class="s1">throw this</span><span class="s0">.flowEnumErrorInvalidMemberInitializer(o.pos,p);</span><span class="s1">case</span><span class="s3">&quot;none&quot;</span><span class="s0">:</span><span class="s1">switch</span><span class="s0">(t){</span><span class="s1">case</span><span class="s3">&quot;boolean&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.flowEnumErrorBooleanMemberNotInitialized(o.pos,p);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;number&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.flowEnumErrorNumberMemberNotInitialized(o.pos,p);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:n.defaultedMembers.push(</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s3">&quot;EnumDefaultedMember&quot;</span><span class="s0">))}}</span><span class="s1">this</span><span class="s0">.match(c.braceR)||</span><span class="s1">this</span><span class="s0">.expect(c.comma)}</span><span class="s1">return</span><span class="s0">{members:n,hasUnknownMembers:i}}flowEnumStringMembers(e,t,{enumName:r}){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">0</span><span class="s0">===e.length)</span><span class="s1">return </span><span class="s0">t;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">0</span><span class="s0">===t.length)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(t.length&gt;e.length){</span><span class="s1">for</span><span class="s0">(const t of e)</span><span class="s1">this</span><span class="s0">.flowEnumErrorStringMemberInconsistentlyInitailized(t.start,{enumName:r});</span><span class="s1">return </span><span class="s0">t}</span><span class="s1">for</span><span class="s0">(const e of t)</span><span class="s1">this</span><span class="s0">.flowEnumErrorStringMemberInconsistentlyInitailized(e.start,{enumName:r});</span><span class="s1">return </span><span class="s0">e}flowEnumParseExplicitType({enumName:e}){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;of&quot;</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c.name))</span><span class="s1">throw this</span><span class="s0">.flowEnumErrorInvalidExplicitType(</span><span class="s1">this</span><span class="s0">.state.start,{enumName:e,suppliedType:</span><span class="s1">null</span><span class="s0">});const{value:t}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s3">&quot;boolean&quot;</span><span class="s0">!==t&amp;&amp;</span><span class="s3">&quot;number&quot;</span><span class="s0">!==t&amp;&amp;</span><span class="s3">&quot;string&quot;</span><span class="s0">!==t&amp;&amp;</span><span class="s3">&quot;symbol&quot;</span><span class="s0">!==t&amp;&amp;</span><span class="s1">this</span><span class="s0">.flowEnumErrorInvalidExplicitType(</span><span class="s1">this</span><span class="s0">.state.start,{enumName:e,suppliedType:t}),t}</span><span class="s1">return null</span><span class="s0">}flowEnumBody(e,{enumName:t,nameLoc:r}){const n=</span><span class="s1">this</span><span class="s0">.flowEnumParseExplicitType({enumName:t});</span><span class="s1">this</span><span class="s0">.expect(c.braceL);const{members:i,hasUnknownMembers:s}=</span><span class="s1">this</span><span class="s0">.flowEnumMembers({enumName:t,explicitType:n});</span><span class="s1">switch</span><span class="s0">(e.hasUnknownMembers=s,n){</span><span class="s1">case</span><span class="s3">&quot;boolean&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.explicitType=!</span><span class="s2">0</span><span class="s0">,e.members=i.booleanMembers,</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumBooleanBody&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;number&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.explicitType=!</span><span class="s2">0</span><span class="s0">,e.members=i.numberMembers,</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumNumberBody&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;string&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.explicitType=!</span><span class="s2">0</span><span class="s0">,e.members=</span><span class="s1">this</span><span class="s0">.flowEnumStringMembers(i.stringMembers,i.defaultedMembers,{enumName:t}),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumStringBody&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;symbol&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.members=i.defaultedMembers,</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumSymbolBody&quot;</span><span class="s0">);</span><span class="s1">default</span><span class="s0">:{const n=()=&gt;(e.members=[],</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumStringBody&quot;</span><span class="s0">));e.explicitType=!</span><span class="s2">1</span><span class="s0">;const s=i.booleanMembers.length,a=i.numberMembers.length,o=i.stringMembers.length,l=i.defaultedMembers.length;</span><span class="s1">if</span><span class="s0">(s||a||o||l){</span><span class="s1">if</span><span class="s0">(s||a){</span><span class="s1">if</span><span class="s0">(!a&amp;&amp;!o&amp;&amp;s&gt;=l){</span><span class="s1">for</span><span class="s0">(const e of i.defaultedMembers)</span><span class="s1">this</span><span class="s0">.flowEnumErrorBooleanMemberNotInitialized(e.start,{enumName:t,memberName:e.id.name});</span><span class="s1">return </span><span class="s0">e.members=i.booleanMembers,</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumBooleanBody&quot;</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(!s&amp;&amp;!o&amp;&amp;a&gt;=l){</span><span class="s1">for</span><span class="s0">(const e of i.defaultedMembers)</span><span class="s1">this</span><span class="s0">.flowEnumErrorNumberMemberNotInitialized(e.start,{enumName:t,memberName:e.id.name});</span><span class="s1">return </span><span class="s0">e.members=i.numberMembers,</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumNumberBody&quot;</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.flowEnumErrorInconsistentMemberValues(r,{enumName:t}),n()}</span><span class="s1">return </span><span class="s0">e.members=</span><span class="s1">this</span><span class="s0">.flowEnumStringMembers(i.stringMembers,i.defaultedMembers,{enumName:t}),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumStringBody&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">n()}}}flowParseEnumDeclaration(e){const t=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">return </span><span class="s0">e.id=t,e.body=</span><span class="s1">this</span><span class="s0">.flowEnumBody(</span><span class="s1">this</span><span class="s0">.startNode(),{enumName:t.name,nameLoc:t.start}),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumDeclaration&quot;</span><span class="s0">)}updateContext(e){</span><span class="s1">this</span><span class="s0">.match(c.name)&amp;&amp;</span><span class="s3">&quot;of&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value&amp;&amp;e===c.name&amp;&amp;</span><span class="s3">&quot;interface&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.slice(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,</span><span class="s1">this</span><span class="s0">.state.lastTokEnd)?</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">:super.updateContext(e)}isLookaheadToken_lt(){const e=</span><span class="s1">this</span><span class="s0">.nextTokenStart();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">60</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e)){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">return </span><span class="s2">60</span><span class="s0">!==t&amp;&amp;</span><span class="s2">61</span><span class="s0">!==t}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}maybeUnwrapTypeCastExpression(e){</span><span class="s1">return</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">===e.type?e.expression:e}},typescript:e=&gt;class extends e{getScopeHandler(){</span><span class="s1">return </span><span class="s0">pe}tsIsIdentifier(){</span><span class="s1">return this</span><span class="s0">.match(c.name)}tsTokenCanFollowModifier(){</span><span class="s1">return</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.bracketL)||</span><span class="s1">this</span><span class="s0">.match(c.braceL)||</span><span class="s1">this</span><span class="s0">.match(c.star)||</span><span class="s1">this</span><span class="s0">.match(c.ellipsis)||</span><span class="s1">this</span><span class="s0">.match(c.privateName)||</span><span class="s1">this</span><span class="s0">.isLiteralPropertyName())&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()}tsNextTokenCanFollowModifier(){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.tsTokenCanFollowModifier()}tsParseModifier(e){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c.name))</span><span class="s1">return</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">return</span><span class="s0">-</span><span class="s2">1</span><span class="s0">!==e.indexOf(t)&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsTryParse(</span><span class="s1">this</span><span class="s0">.tsNextTokenCanFollowModifier.bind(</span><span class="s1">this</span><span class="s0">))?t:</span><span class="s1">void </span><span class="s2">0</span><span class="s0">}tsParseModifiers(e,t,r,n){const i=(t,r,n,i)=&gt;{r===n&amp;&amp;e[i]&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,fe.InvalidModifiersOrder,n,i)},s=(t,r,n,i)=&gt;{(e[n]&amp;&amp;r===i||e[i]&amp;&amp;r===n)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,fe.IncompatibleModifiers,n,i)};</span><span class="s1">for</span><span class="s0">(;;){const a=</span><span class="s1">this</span><span class="s0">.state.start,o=</span><span class="s1">this</span><span class="s0">.tsParseModifier(t.concat(</span><span class="s1">null</span><span class="s0">!=r?r:[]));</span><span class="s1">if</span><span class="s0">(!o)</span><span class="s1">break</span><span class="s0">;me(o)?e.accessibility?</span><span class="s1">this</span><span class="s0">.raise(a,fe.DuplicateAccessibilityModifier):(i(a,o,o,</span><span class="s3">&quot;override&quot;</span><span class="s0">),i(a,o,o,</span><span class="s3">&quot;static&quot;</span><span class="s0">),e.accessibility=o):(Object.hasOwnProperty.call(e,o)?</span><span class="s1">this</span><span class="s0">.raise(a,fe.DuplicateModifier,o):(i(a,o,</span><span class="s3">&quot;static&quot;</span><span class="s0">,</span><span class="s3">&quot;readonly&quot;</span><span class="s0">),i(a,o,</span><span class="s3">&quot;static&quot;</span><span class="s0">,</span><span class="s3">&quot;override&quot;</span><span class="s0">),i(a,o,</span><span class="s3">&quot;override&quot;</span><span class="s0">,</span><span class="s3">&quot;readonly&quot;</span><span class="s0">),i(a,o,</span><span class="s3">&quot;abstract&quot;</span><span class="s0">,</span><span class="s3">&quot;override&quot;</span><span class="s0">),s(a,o,</span><span class="s3">&quot;declare&quot;</span><span class="s0">,</span><span class="s3">&quot;override&quot;</span><span class="s0">),s(a,o,</span><span class="s3">&quot;static&quot;</span><span class="s0">,</span><span class="s3">&quot;abstract&quot;</span><span class="s0">)),e[o]=!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">null</span><span class="s0">!=r&amp;&amp;r.includes(o)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(a,n,o)}}tsIsListTerminator(e){</span><span class="s1">switch</span><span class="s0">(e){</span><span class="s1">case</span><span class="s3">&quot;EnumMembers&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TypeMembers&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.match(c.braceR);</span><span class="s1">case</span><span class="s3">&quot;HeritageClauseElement&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.match(c.braceL);</span><span class="s1">case</span><span class="s3">&quot;TupleElementTypes&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.match(c.bracketR);</span><span class="s1">case</span><span class="s3">&quot;TypeParametersOrArguments&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">)}</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Unreachable&quot;</span><span class="s0">)}tsParseList(e,t){const r=[];</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.tsIsListTerminator(e);)r.push(t());</span><span class="s1">return </span><span class="s0">r}tsParseDelimitedList(e,t){</span><span class="s1">return </span><span class="s0">de(</span><span class="s1">this</span><span class="s0">.tsParseDelimitedListWorker(e,t,!</span><span class="s2">0</span><span class="s0">))}tsParseDelimitedListWorker(e,t,r){const n=[];</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.tsIsListTerminator(e);){const i=t();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==i)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(n.push(i),!</span><span class="s1">this</span><span class="s0">.eat(c.comma)){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsIsListTerminator(e))</span><span class="s1">break</span><span class="s0">;</span><span class="s1">return void</span><span class="s0">(r&amp;&amp;</span><span class="s1">this</span><span class="s0">.expect(c.comma))}}</span><span class="s1">return </span><span class="s0">n}tsParseBracketedList(e,t,r,n){n||(r?</span><span class="s1">this</span><span class="s0">.expect(c.bracketL):</span><span class="s1">this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">));const i=</span><span class="s1">this</span><span class="s0">.tsParseDelimitedList(e,t);</span><span class="s1">return </span><span class="s0">r?</span><span class="s1">this</span><span class="s0">.expect(c.bracketR):</span><span class="s1">this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">),i}tsParseImportType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(c._import),</span><span class="s1">this</span><span class="s0">.expect(c.parenL),</span><span class="s1">this</span><span class="s0">.match(c.string)||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,fe.UnsupportedImportTypeArgument),e.argument=</span><span class="s1">this</span><span class="s0">.parseExprAtom(),</span><span class="s1">this</span><span class="s0">.expect(c.parenR),</span><span class="s1">this</span><span class="s0">.eat(c.dot)&amp;&amp;(e.qualifier=</span><span class="s1">this</span><span class="s0">.tsParseEntityName(!</span><span class="s2">0</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSImportType&quot;</span><span class="s0">)}tsParseEntityName(e){let t=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.eat(c.dot);){const r=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(t);r.left=t,r.right=</span><span class="s1">this</span><span class="s0">.parseIdentifier(e),t=</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;TSQualifiedName&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">t}tsParseTypeReference(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.typeName=</span><span class="s1">this</span><span class="s0">.tsParseEntityName(!</span><span class="s2">1</span><span class="s0">),!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeReference&quot;</span><span class="s0">)}tsParseThisTypePredicate(e){</span><span class="s1">this</span><span class="s0">.next();const t=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e);</span><span class="s1">return </span><span class="s0">t.parameterName=e,t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation(!</span><span class="s2">1</span><span class="s0">),t.asserts=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSTypePredicate&quot;</span><span class="s0">)}tsParseThisTypeNode(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSThisType&quot;</span><span class="s0">)}tsParseTypeQuery(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(c._typeof),</span><span class="s1">this</span><span class="s0">.match(c._import)?e.exprName=</span><span class="s1">this</span><span class="s0">.tsParseImportType():e.exprName=</span><span class="s1">this</span><span class="s0">.tsParseEntityName(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeQuery&quot;</span><span class="s0">)}tsParseTypeParameter(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.name=</span><span class="s1">this</span><span class="s0">.parseIdentifierName(e.start),e.constraint=</span><span class="s1">this</span><span class="s0">.tsEatThenParseType(c._extends),e.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">this</span><span class="s0">.tsEatThenParseType(c.eq),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeParameter&quot;</span><span class="s0">)}tsTryParseTypeParameters(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.tsParseTypeParameters()}tsParseTypeParameters(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(c.jsxTagStart)?</span><span class="s1">this</span><span class="s0">.next():</span><span class="s1">this</span><span class="s0">.unexpected(),e.params=</span><span class="s1">this</span><span class="s0">.tsParseBracketedList(</span><span class="s3">&quot;TypeParametersOrArguments&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseTypeParameter.bind(</span><span class="s1">this</span><span class="s0">),!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s2">0</span><span class="s0">===e.params.length&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,fe.EmptyTypeParameters),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeParameterDeclaration&quot;</span><span class="s0">)}tsTryNextParseConstantContext(){</span><span class="s1">return this</span><span class="s0">.lookahead().type===c._const?(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.tsParseTypeReference()):</span><span class="s1">null</span><span class="s0">}tsFillSignature(e,t){const r=e===c.arrow;t.typeParameters=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters(),</span><span class="s1">this</span><span class="s0">.expect(c.parenL),t.parameters=</span><span class="s1">this</span><span class="s0">.tsParseBindingListForSignature(),(r||</span><span class="s1">this</span><span class="s0">.match(e))&amp;&amp;(t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseTypeOrTypePredicateAnnotation(e))}tsParseBindingListForSignature(){</span><span class="s1">return this</span><span class="s0">.parseBindingList(c.parenR,</span><span class="s2">41</span><span class="s0">).map((e=&gt;(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,fe.UnsupportedSignatureParameterKind,e.type),e)))}tsParseTypeMemberSemicolon(){</span><span class="s1">this</span><span class="s0">.eat(c.comma)||</span><span class="s1">this</span><span class="s0">.isLineTerminator()||</span><span class="s1">this</span><span class="s0">.expect(c.semi)}tsParseSignatureMember(e,t){</span><span class="s1">return this</span><span class="s0">.tsFillSignature(c.colon,t),</span><span class="s1">this</span><span class="s0">.tsParseTypeMemberSemicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(t,e)}tsIsUnambiguouslyIndexSignature(){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.eat(c.name)&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.colon)}tsTryParseIndexSignature(e){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c.bracketL)||!</span><span class="s1">this</span><span class="s0">.tsLookAhead(</span><span class="s1">this</span><span class="s0">.tsIsUnambiguouslyIndexSignature.bind(</span><span class="s1">this</span><span class="s0">)))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.expect(c.bracketL);const t=</span><span class="s1">this</span><span class="s0">.parseIdentifier();t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.resetEndLocation(t),</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),e.parameters=[t];const r=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();</span><span class="s1">return </span><span class="s0">r&amp;&amp;(e.typeAnnotation=r),</span><span class="s1">this</span><span class="s0">.tsParseTypeMemberSemicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSIndexSignature&quot;</span><span class="s0">)}tsParsePropertyOrMethodSignature(e,t){</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(e.optional=!</span><span class="s2">0</span><span class="s0">);const r=e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)){t&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,fe.ReadonlyForMethodSignature);const n=r;</span><span class="s1">if</span><span class="s0">(n.kind&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,fe.AccesorCannotHaveTypeParameters),</span><span class="s1">this</span><span class="s0">.tsFillSignature(c.colon,n),</span><span class="s1">this</span><span class="s0">.tsParseTypeMemberSemicolon(),</span><span class="s3">&quot;get&quot;</span><span class="s0">===n.kind)n.parameters.length&gt;</span><span class="s2">0</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.BadGetterArity),</span><span class="s1">this</span><span class="s0">.isThisParam(n.parameters[</span><span class="s2">0</span><span class="s0">])&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,fe.AccesorCannotDeclareThisParameter));</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;set&quot;</span><span class="s0">===n.kind){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">1</span><span class="s0">!==n.parameters.length)</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.BadSetterArity);</span><span class="s1">else</span><span class="s0">{const e=n.parameters[</span><span class="s2">0</span><span class="s0">];</span><span class="s1">this</span><span class="s0">.isThisParam(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,fe.AccesorCannotDeclareThisParameter),</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type&amp;&amp;e.optional&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,fe.SetAccesorCannotHaveOptionalParameter),</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,fe.SetAccesorCannotHaveRestParameter)}n.typeAnnotation&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(n.typeAnnotation.start,fe.SetAccesorCannotHaveReturnType)}</span><span class="s1">else </span><span class="s0">n.kind=</span><span class="s3">&quot;method&quot;</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;TSMethodSignature&quot;</span><span class="s0">)}{const e=r;t&amp;&amp;(e.readonly=!</span><span class="s2">0</span><span class="s0">);const n=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();</span><span class="s1">return </span><span class="s0">n&amp;&amp;(e.typeAnnotation=n),</span><span class="s1">this</span><span class="s0">.tsParseTypeMemberSemicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSPropertySignature&quot;</span><span class="s0">)}}tsParseTypeMember(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.tsParseSignatureMember(</span><span class="s3">&quot;TSCallSignatureDeclaration&quot;</span><span class="s0">,e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._new)){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.tsParseSignatureMember(</span><span class="s3">&quot;TSConstructSignatureDeclaration&quot;</span><span class="s0">,e):(e.key=</span><span class="s1">this</span><span class="s0">.createIdentifier(t,</span><span class="s3">&quot;new&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsParsePropertyOrMethodSignature(e,!</span><span class="s2">1</span><span class="s0">))}</span><span class="s1">this</span><span class="s0">.tsParseModifiers(e,[</span><span class="s3">&quot;readonly&quot;</span><span class="s0">],[</span><span class="s3">&quot;declare&quot;</span><span class="s0">,</span><span class="s3">&quot;abstract&quot;</span><span class="s0">,</span><span class="s3">&quot;private&quot;</span><span class="s0">,</span><span class="s3">&quot;protected&quot;</span><span class="s0">,</span><span class="s3">&quot;public&quot;</span><span class="s0">,</span><span class="s3">&quot;static&quot;</span><span class="s0">,</span><span class="s3">&quot;override&quot;</span><span class="s0">],fe.InvalidModifierOnTypeMember);</span><span class="s1">return this</span><span class="s0">.tsTryParseIndexSignature(e)||(</span><span class="s1">this</span><span class="s0">.parsePropertyName(e,!</span><span class="s2">1</span><span class="s0">),e.computed||</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==e.key.type||</span><span class="s3">&quot;get&quot;</span><span class="s0">!==e.key.name&amp;&amp;</span><span class="s3">&quot;set&quot;</span><span class="s0">!==e.key.name||!</span><span class="s1">this</span><span class="s0">.tsTokenCanFollowModifier()||(e.kind=e.key.name,</span><span class="s1">this</span><span class="s0">.parsePropertyName(e,!</span><span class="s2">1</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.tsParsePropertyOrMethodSignature(e,!!e.readonly))}tsParseTypeLiteral(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.members=</span><span class="s1">this</span><span class="s0">.tsParseObjectTypeMembers(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeLiteral&quot;</span><span class="s0">)}tsParseObjectTypeMembers(){</span><span class="s1">this</span><span class="s0">.expect(c.braceL);const e=</span><span class="s1">this</span><span class="s0">.tsParseList(</span><span class="s3">&quot;TypeMembers&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseTypeMember.bind(</span><span class="s1">this</span><span class="s0">));</span><span class="s1">return this</span><span class="s0">.expect(c.braceR),e}tsIsStartOfMappedType(){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.eat(c.plusMin)?</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;readonly&quot;</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;readonly&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.next(),!!</span><span class="s1">this</span><span class="s0">.match(c.bracketL)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),!!</span><span class="s1">this</span><span class="s0">.tsIsIdentifier()&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c._in))))}tsParseMappedTypeParameter(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.name=</span><span class="s1">this</span><span class="s0">.parseIdentifierName(e.start),e.constraint=</span><span class="s1">this</span><span class="s0">.tsExpectThenParseType(c._in),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeParameter&quot;</span><span class="s0">)}tsParseMappedType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(c.braceL),</span><span class="s1">this</span><span class="s0">.match(c.plusMin)?(e.readonly=</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;readonly&quot;</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;readonly&quot;</span><span class="s0">)&amp;&amp;(e.readonly=!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.bracketL),e.typeParameter=</span><span class="s1">this</span><span class="s0">.tsParseMappedTypeParameter(),e.nameType=</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.tsParseType():</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),</span><span class="s1">this</span><span class="s0">.match(c.plusMin)?(e.optional=</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expect(c.question)):</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(e.optional=!</span><span class="s2">0</span><span class="s0">),e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsTryParseType(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSMappedType&quot;</span><span class="s0">)}tsParseTupleType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();e.elementTypes=</span><span class="s1">this</span><span class="s0">.tsParseBracketedList(</span><span class="s3">&quot;TupleElementTypes&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseTupleElementType.bind(</span><span class="s1">this</span><span class="s0">),!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">);let t=!</span><span class="s2">1</span><span class="s0">,r=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.elementTypes.forEach((e=&gt;{</span><span class="s1">var </span><span class="s0">n;let{type:i}=e;!t||</span><span class="s3">&quot;TSRestType&quot;</span><span class="s0">===i||</span><span class="s3">&quot;TSOptionalType&quot;</span><span class="s0">===i||</span><span class="s3">&quot;TSNamedTupleMember&quot;</span><span class="s0">===i&amp;&amp;e.optional||</span><span class="s1">this</span><span class="s0">.raise(e.start,fe.OptionalTypeBeforeRequired),t=t||</span><span class="s3">&quot;TSNamedTupleMember&quot;</span><span class="s0">===i&amp;&amp;e.optional||</span><span class="s3">&quot;TSOptionalType&quot;</span><span class="s0">===i,</span><span class="s3">&quot;TSRestType&quot;</span><span class="s0">===i&amp;&amp;(i=(e=e.typeAnnotation).type);const s=</span><span class="s3">&quot;TSNamedTupleMember&quot;</span><span class="s0">===i;r=</span><span class="s1">null</span><span class="s0">!=(n=r)?n:s,r!==s&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,fe.MixedLabeledAndUnlabeledElements)})),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTupleType&quot;</span><span class="s0">)}tsParseTupleElementType(){const{start:e,startLoc:t}=</span><span class="s1">this</span><span class="s0">.state,r=</span><span class="s1">this</span><span class="s0">.eat(c.ellipsis);let n=</span><span class="s1">this</span><span class="s0">.tsParseType();const i=</span><span class="s1">this</span><span class="s0">.eat(c.question);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.colon)){const e=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(n);e.optional=i,</span><span class="s3">&quot;TSTypeReference&quot;</span><span class="s0">!==n.type||n.typeParameters||</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==n.typeName.type?(</span><span class="s1">this</span><span class="s0">.raise(n.start,fe.InvalidTupleMemberLabel),e.label=n):e.label=n.typeName,e.elementType=</span><span class="s1">this</span><span class="s0">.tsParseType(),n=</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSNamedTupleMember&quot;</span><span class="s0">)}</span><span class="s1">else if</span><span class="s0">(i){const e=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(n);e.typeAnnotation=n,n=</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSOptionalType&quot;</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(r){const r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);r.typeAnnotation=n,n=</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;TSRestType&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">n}tsParseParenthesizedType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(c.parenL),e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseType(),</span><span class="s1">this</span><span class="s0">.expect(c.parenR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSParenthesizedType&quot;</span><span class="s0">)}tsParseFunctionOrConstructorType(e,t){const r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return</span><span class="s3">&quot;TSConstructorType&quot;</span><span class="s0">===e&amp;&amp;(r.abstract=!!t,t&amp;&amp;</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.next()),</span><span class="s1">this</span><span class="s0">.tsFillSignature(c.arrow,r),</span><span class="s1">this</span><span class="s0">.finishNode(r,e)}tsParseLiteralTypeNode(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.literal=(()=&gt;{</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c.num:</span><span class="s1">case </span><span class="s0">c.bigint:</span><span class="s1">case </span><span class="s0">c.string:</span><span class="s1">case </span><span class="s0">c._true:</span><span class="s1">case </span><span class="s0">c._false:</span><span class="s1">return this</span><span class="s0">.parseExprAtom();</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw this</span><span class="s0">.unexpected()}})(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSLiteralType&quot;</span><span class="s0">)}tsParseTemplateLiteralType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.literal=</span><span class="s1">this</span><span class="s0">.parseTemplate(!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSLiteralType&quot;</span><span class="s0">)}parseTemplateSubstitution(){</span><span class="s1">return this</span><span class="s0">.state.inType?</span><span class="s1">this</span><span class="s0">.tsParseType():super.parseTemplateSubstitution()}tsParseThisTypeOrThisTypePredicate(){const e=</span><span class="s1">this</span><span class="s0">.tsParseThisTypeNode();</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;is&quot;</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()?</span><span class="s1">this</span><span class="s0">.tsParseThisTypePredicate(e):e}tsParseNonArrayType(){</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c.name:</span><span class="s1">case </span><span class="s0">c._void:</span><span class="s1">case </span><span class="s0">c._null:{const e=</span><span class="s1">this</span><span class="s0">.match(c._void)?</span><span class="s3">&quot;TSVoidKeyword&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.match(c._null)?</span><span class="s3">&quot;TSNullKeyword&quot;</span><span class="s0">:</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">switch</span><span class="s0">(e){</span><span class="s1">case</span><span class="s3">&quot;any&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSAnyKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;boolean&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSBooleanKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;bigint&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSBigIntKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;never&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSNeverKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;number&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSNumberKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;object&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSObjectKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;string&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSStringKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;symbol&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSSymbolKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;undefined&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSUndefinedKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;unknown&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSUnknownKeyword&quot;</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">}}(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">!==e&amp;&amp;</span><span class="s2">46</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(t,e)}</span><span class="s1">return this</span><span class="s0">.tsParseTypeReference()}</span><span class="s1">case </span><span class="s0">c.string:</span><span class="s1">case </span><span class="s0">c.num:</span><span class="s1">case </span><span class="s0">c.bigint:</span><span class="s1">case </span><span class="s0">c._true:</span><span class="s1">case </span><span class="s0">c._false:</span><span class="s1">return this</span><span class="s0">.tsParseLiteralTypeNode();</span><span class="s1">case </span><span class="s0">c.plusMin:</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;-&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value){const e=</span><span class="s1">this</span><span class="s0">.startNode(),t=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s1">if</span><span class="s0">(t.type!==c.num&amp;&amp;t.type!==c.bigint)</span><span class="s1">throw this</span><span class="s0">.unexpected();</span><span class="s1">return </span><span class="s0">e.literal=</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSLiteralType&quot;</span><span class="s0">)}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">c._this:</span><span class="s1">return this</span><span class="s0">.tsParseThisTypeOrThisTypePredicate();</span><span class="s1">case </span><span class="s0">c._typeof:</span><span class="s1">return this</span><span class="s0">.tsParseTypeQuery();</span><span class="s1">case </span><span class="s0">c._import:</span><span class="s1">return this</span><span class="s0">.tsParseImportType();</span><span class="s1">case </span><span class="s0">c.braceL:</span><span class="s1">return this</span><span class="s0">.tsLookAhead(</span><span class="s1">this</span><span class="s0">.tsIsStartOfMappedType.bind(</span><span class="s1">this</span><span class="s0">))?</span><span class="s1">this</span><span class="s0">.tsParseMappedType():</span><span class="s1">this</span><span class="s0">.tsParseTypeLiteral();</span><span class="s1">case </span><span class="s0">c.bracketL:</span><span class="s1">return this</span><span class="s0">.tsParseTupleType();</span><span class="s1">case </span><span class="s0">c.parenL:</span><span class="s1">return this</span><span class="s0">.tsParseParenthesizedType();</span><span class="s1">case </span><span class="s0">c.backQuote:</span><span class="s1">return this</span><span class="s0">.tsParseTemplateLiteralType()}</span><span class="s1">throw this</span><span class="s0">.unexpected()}tsParseArrayTypeOrHigher(){let e=</span><span class="s1">this</span><span class="s0">.tsParseNonArrayType();</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.bracketL);)</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.bracketR)){const t=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e);t.elementType=e,</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),e=</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSArrayType&quot;</span><span class="s0">)}</span><span class="s1">else</span><span class="s0">{const t=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e);t.objectType=e,t.indexType=</span><span class="s1">this</span><span class="s0">.tsParseType(),</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),e=</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSIndexedAccessType&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}tsParseTypeOperator(e){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expectContextual(e),t.operator=e,t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseTypeOperatorOrHigher(),</span><span class="s3">&quot;readonly&quot;</span><span class="s0">===e&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsCheckTypeAnnotationForReadOnly(t),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSTypeOperator&quot;</span><span class="s0">)}tsCheckTypeAnnotationForReadOnly(e){</span><span class="s1">switch</span><span class="s0">(e.typeAnnotation.type){</span><span class="s1">case</span><span class="s3">&quot;TSTupleType&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TSArrayType&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.raise(e.start,fe.UnexpectedReadonly)}}tsParseInferType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;infer&quot;</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">t.name=</span><span class="s1">this</span><span class="s0">.parseIdentifierName(t.start),e.typeParameter=</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSTypeParameter&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSInferType&quot;</span><span class="s0">)}tsParseTypeOperatorOrHigher(){const e=[</span><span class="s3">&quot;keyof&quot;</span><span class="s0">,</span><span class="s3">&quot;unique&quot;</span><span class="s0">,</span><span class="s3">&quot;readonly&quot;</span><span class="s0">].find((e=&gt;</span><span class="s1">this</span><span class="s0">.isContextual(e)));</span><span class="s1">return </span><span class="s0">e?</span><span class="s1">this</span><span class="s0">.tsParseTypeOperator(e):</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;infer&quot;</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.tsParseInferType():</span><span class="s1">this</span><span class="s0">.tsParseArrayTypeOrHigher()}tsParseUnionOrIntersectionType(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.startNode(),i=</span><span class="s1">this</span><span class="s0">.eat(r),s=[];</span><span class="s1">do</span><span class="s0">{s.push(t())}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(r));</span><span class="s1">return </span><span class="s2">1</span><span class="s0">!==s.length||i?(n.types=s,</span><span class="s1">this</span><span class="s0">.finishNode(n,e)):s[</span><span class="s2">0</span><span class="s0">]}tsParseIntersectionTypeOrHigher(){</span><span class="s1">return this</span><span class="s0">.tsParseUnionOrIntersectionType(</span><span class="s3">&quot;TSIntersectionType&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseTypeOperatorOrHigher.bind(</span><span class="s1">this</span><span class="s0">),c.bitwiseAND)}tsParseUnionTypeOrHigher(){</span><span class="s1">return this</span><span class="s0">.tsParseUnionOrIntersectionType(</span><span class="s3">&quot;TSUnionType&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseIntersectionTypeOrHigher.bind(</span><span class="s1">this</span><span class="s0">),c.bitwiseOR)}tsIsStartOfFunctionType(){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(c.parenL)&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsLookAhead(</span><span class="s1">this</span><span class="s0">.tsIsUnambiguouslyStartOfFunctionType.bind(</span><span class="s1">this</span><span class="s0">))}tsSkipParameterStart(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.name)||</span><span class="s1">this</span><span class="s0">.match(c._this))</span><span class="s1">return this</span><span class="s0">.next(),!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.braceL)){let e=</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next();e&gt;</span><span class="s2">0</span><span class="s0">;)</span><span class="s1">this</span><span class="s0">.match(c.braceL)?++e:</span><span class="s1">this</span><span class="s0">.match(c.braceR)&amp;&amp;--e,</span><span class="s1">this</span><span class="s0">.next();</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.bracketL)){let e=</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next();e&gt;</span><span class="s2">0</span><span class="s0">;)</span><span class="s1">this</span><span class="s0">.match(c.bracketL)?++e:</span><span class="s1">this</span><span class="s0">.match(c.bracketR)&amp;&amp;--e,</span><span class="s1">this</span><span class="s0">.next();</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}tsIsUnambiguouslyStartOfFunctionType(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.parenR)||</span><span class="s1">this</span><span class="s0">.match(c.ellipsis))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsSkipParameterStart()){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.colon)||</span><span class="s1">this</span><span class="s0">.match(c.comma)||</span><span class="s1">this</span><span class="s0">.match(c.question)||</span><span class="s1">this</span><span class="s0">.match(c.eq))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.parenR)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.arrow)))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}tsParseTypeOrTypePredicateAnnotation(e){</span><span class="s1">return this</span><span class="s0">.tsInType((()=&gt;{const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.expect(e);const r=</span><span class="s1">this</span><span class="s0">.startNode(),n=!!</span><span class="s1">this</span><span class="s0">.tsTryParse(</span><span class="s1">this</span><span class="s0">.tsParseTypePredicateAsserts.bind(</span><span class="s1">this</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(n&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c._this)){let e=</span><span class="s1">this</span><span class="s0">.tsParseThisTypeOrThisTypePredicate();</span><span class="s1">return</span><span class="s3">&quot;TSThisType&quot;</span><span class="s0">===e.type?(r.parameterName=e,r.asserts=!</span><span class="s2">0</span><span class="s0">,e=</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;TSTypePredicate&quot;</span><span class="s0">)):(</span><span class="s1">this</span><span class="s0">.resetStartLocationFromNode(e,r),e.asserts=!</span><span class="s2">0</span><span class="s0">),t.typeAnnotation=e,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">)}const i=</span><span class="s1">this</span><span class="s0">.tsIsIdentifier()&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsTryParse(</span><span class="s1">this</span><span class="s0">.tsParseTypePredicatePrefix.bind(</span><span class="s1">this</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(!i)</span><span class="s1">return </span><span class="s0">n?(r.parameterName=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),r.asserts=n,t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;TSTypePredicate&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation(!</span><span class="s2">1</span><span class="s0">,t);const s=</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation(!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r.parameterName=i,r.typeAnnotation=s,r.asserts=n,t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;TSTypePredicate&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">)}))}tsTryParseTypeOrTypePredicateAnnotation(){</span><span class="s1">return this</span><span class="s0">.match(c.colon)?</span><span class="s1">this</span><span class="s0">.tsParseTypeOrTypePredicateAnnotation(c.colon):</span><span class="s1">void </span><span class="s2">0</span><span class="s0">}tsTryParseTypeAnnotation(){</span><span class="s1">return this</span><span class="s0">.match(c.colon)?</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation():</span><span class="s1">void </span><span class="s2">0</span><span class="s0">}tsTryParseType(){</span><span class="s1">return this</span><span class="s0">.tsEatThenParseType(c.colon)}tsParseTypePredicatePrefix(){const e=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;is&quot;</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak())</span><span class="s1">return this</span><span class="s0">.next(),e}tsParseTypePredicateAsserts(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c.name)||</span><span class="s3">&quot;asserts&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.state.value||</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak())</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const e=</span><span class="s1">this</span><span class="s0">.state.containsEsc;</span><span class="s1">return this</span><span class="s0">.next(),!(!</span><span class="s1">this</span><span class="s0">.match(c.name)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c._this)||(e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,E.InvalidEscapedReservedWord,</span><span class="s3">&quot;asserts&quot;</span><span class="s0">),</span><span class="s2">0</span><span class="s0">))}tsParseTypeAnnotation(e=!</span><span class="s2">0</span><span class="s0">,t=</span><span class="s1">this</span><span class="s0">.startNode()){</span><span class="s1">return this</span><span class="s0">.tsInType((()=&gt;{e&amp;&amp;</span><span class="s1">this</span><span class="s0">.expect(c.colon),t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseType()})),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">)}tsParseType(){he(</span><span class="s1">this</span><span class="s0">.state.inType);const e=</span><span class="s1">this</span><span class="s0">.tsParseNonConditionalType();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()||!</span><span class="s1">this</span><span class="s0">.eat(c._extends))</span><span class="s1">return </span><span class="s0">e;const t=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e);</span><span class="s1">return </span><span class="s0">t.checkType=e,t.extendsType=</span><span class="s1">this</span><span class="s0">.tsParseNonConditionalType(),</span><span class="s1">this</span><span class="s0">.expect(c.question),t.trueType=</span><span class="s1">this</span><span class="s0">.tsParseType(),</span><span class="s1">this</span><span class="s0">.expect(c.colon),t.falseType=</span><span class="s1">this</span><span class="s0">.tsParseType(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSConditionalType&quot;</span><span class="s0">)}isAbstractConstructorSignature(){</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;abstract&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookahead().type===c._new}tsParseNonConditionalType(){</span><span class="s1">return this</span><span class="s0">.tsIsStartOfFunctionType()?</span><span class="s1">this</span><span class="s0">.tsParseFunctionOrConstructorType(</span><span class="s3">&quot;TSFunctionType&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.match(c._new)?</span><span class="s1">this</span><span class="s0">.tsParseFunctionOrConstructorType(</span><span class="s3">&quot;TSConstructorType&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.isAbstractConstructorSignature()?</span><span class="s1">this</span><span class="s0">.tsParseFunctionOrConstructorType(</span><span class="s3">&quot;TSConstructorType&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.tsParseUnionTypeOrHigher()}tsParseTypeAssertion(){const e=</span><span class="s1">this</span><span class="s0">.startNode(),t=</span><span class="s1">this</span><span class="s0">.tsTryNextParseConstantContext();</span><span class="s1">return </span><span class="s0">e.typeAnnotation=t||</span><span class="s1">this</span><span class="s0">.tsNextThenParseType(),</span><span class="s1">this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">),e.expression=</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeAssertion&quot;</span><span class="s0">)}tsParseHeritageClause(e){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.tsParseDelimitedList(</span><span class="s3">&quot;HeritageClauseElement&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseExpressionWithTypeArguments.bind(</span><span class="s1">this</span><span class="s0">));</span><span class="s1">return </span><span class="s0">r.length||</span><span class="s1">this</span><span class="s0">.raise(t,fe.EmptyHeritageClauseType,e),r}tsParseExpressionWithTypeArguments(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.expression=</span><span class="s1">this</span><span class="s0">.tsParseEntityName(!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSExpressionWithTypeArguments&quot;</span><span class="s0">)}tsParseInterfaceDeclaration(e){e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,</span><span class="s3">&quot;typescript interface declaration&quot;</span><span class="s0">,</span><span class="s2">130</span><span class="s0">),e.typeParameters=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters(),</span><span class="s1">this</span><span class="s0">.eat(c._extends)&amp;&amp;(e.extends=</span><span class="s1">this</span><span class="s0">.tsParseHeritageClause(</span><span class="s3">&quot;extends&quot;</span><span class="s0">));const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">t.body=</span><span class="s1">this</span><span class="s0">.tsInType(</span><span class="s1">this</span><span class="s0">.tsParseObjectTypeMembers.bind(</span><span class="s1">this</span><span class="s0">)),e.body=</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSInterfaceBody&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSInterfaceDeclaration&quot;</span><span class="s0">)}tsParseTypeAliasDeclaration(e){</span><span class="s1">return </span><span class="s0">e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,</span><span class="s3">&quot;typescript type alias&quot;</span><span class="s0">,</span><span class="s2">2</span><span class="s0">),e.typeParameters=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters(),e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsInType((()=&gt;{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.eq),</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;intrinsic&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookahead().type!==c.dot){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSIntrinsicKeyword&quot;</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.tsParseType()})),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeAliasDeclaration&quot;</span><span class="s0">)}tsInNoContext(e){const t=</span><span class="s1">this</span><span class="s0">.state.context;</span><span class="s1">this</span><span class="s0">.state.context=[t[</span><span class="s2">0</span><span class="s0">]];</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.context=t}}tsInType(e){const t=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.inType=t}}tsEatThenParseType(e){</span><span class="s1">return this</span><span class="s0">.match(e)?</span><span class="s1">this</span><span class="s0">.tsNextThenParseType():</span><span class="s1">void </span><span class="s2">0</span><span class="s0">}tsExpectThenParseType(e){</span><span class="s1">return this</span><span class="s0">.tsDoThenParseType((()=&gt;</span><span class="s1">this</span><span class="s0">.expect(e)))}tsNextThenParseType(){</span><span class="s1">return this</span><span class="s0">.tsDoThenParseType((()=&gt;</span><span class="s1">this</span><span class="s0">.next()))}tsDoThenParseType(e){</span><span class="s1">return this</span><span class="s0">.tsInType((()=&gt;(e(),</span><span class="s1">this</span><span class="s0">.tsParseType())))}tsParseEnumMember(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.id=</span><span class="s1">this</span><span class="s0">.match(c.string)?</span><span class="s1">this</span><span class="s0">.parseExprAtom():</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.eat(c.eq)&amp;&amp;(e.initializer=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSEnumMember&quot;</span><span class="s0">)}tsParseEnumDeclaration(e,t){</span><span class="s1">return </span><span class="s0">t&amp;&amp;(e.const=!</span><span class="s2">0</span><span class="s0">),e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,</span><span class="s3">&quot;typescript enum declaration&quot;</span><span class="s0">,t?</span><span class="s2">779</span><span class="s0">:</span><span class="s2">267</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.braceL),e.members=</span><span class="s1">this</span><span class="s0">.tsParseDelimitedList(</span><span class="s3">&quot;EnumMembers&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseEnumMember.bind(</span><span class="s1">this</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSEnumDeclaration&quot;</span><span class="s0">)}tsParseModuleBlock(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.scope.enter(</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.braceL),</span><span class="s1">this</span><span class="s0">.parseBlockOrModuleBlockBody(e.body=[],</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">,c.braceR),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSModuleBlock&quot;</span><span class="s0">)}tsParseModuleOrNamespaceDeclaration(e,t=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),t||</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,</span><span class="s3">&quot;module or namespace declaration&quot;</span><span class="s0">,</span><span class="s2">1024</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.eat(c.dot)){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.tsParseModuleOrNamespaceDeclaration(t,!</span><span class="s2">0</span><span class="s0">),e.body=t}</span><span class="s1">else this</span><span class="s0">.scope.enter(</span><span class="s2">256</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.enter(</span><span class="s2">0</span><span class="s0">),e.body=</span><span class="s1">this</span><span class="s0">.tsParseModuleBlock(),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit();</span><span class="s1">return this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSModuleDeclaration&quot;</span><span class="s0">)}tsParseAmbientExternalModuleDeclaration(e){</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;global&quot;</span><span class="s0">)?(e.global=!</span><span class="s2">0</span><span class="s0">,e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier()):</span><span class="s1">this</span><span class="s0">.match(c.string)?e.id=</span><span class="s1">this</span><span class="s0">.parseExprAtom():</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.match(c.braceL)?(</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">256</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.enter(</span><span class="s2">0</span><span class="s0">),e.body=</span><span class="s1">this</span><span class="s0">.tsParseModuleBlock(),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit()):</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSModuleDeclaration&quot;</span><span class="s0">)}tsParseImportEqualsDeclaration(e,t){e.isExport=t||!</span><span class="s2">1</span><span class="s0">,e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,</span><span class="s3">&quot;import equals declaration&quot;</span><span class="s0">,</span><span class="s2">9</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.eq);const r=</span><span class="s1">this</span><span class="s0">.tsParseModuleReference();</span><span class="s1">return</span><span class="s3">&quot;type&quot;</span><span class="s0">===e.importKind&amp;&amp;</span><span class="s3">&quot;TSExternalModuleReference&quot;</span><span class="s0">!==r.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r.start,fe.ImportAliasHasImportType),e.moduleReference=r,</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSImportEqualsDeclaration&quot;</span><span class="s0">)}tsIsExternalModuleReference(){</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;require&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">40</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()}tsParseModuleReference(){</span><span class="s1">return this</span><span class="s0">.tsIsExternalModuleReference()?</span><span class="s1">this</span><span class="s0">.tsParseExternalModuleReference():</span><span class="s1">this</span><span class="s0">.tsParseEntityName(!</span><span class="s2">1</span><span class="s0">)}tsParseExternalModuleReference(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;require&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.parenL),!</span><span class="s1">this</span><span class="s0">.match(c.string))</span><span class="s1">throw this</span><span class="s0">.unexpected();</span><span class="s1">return </span><span class="s0">e.expression=</span><span class="s1">this</span><span class="s0">.parseExprAtom(),</span><span class="s1">this</span><span class="s0">.expect(c.parenR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSExternalModuleReference&quot;</span><span class="s0">)}tsLookAhead(e){const t=</span><span class="s1">this</span><span class="s0">.state.clone(),r=e();</span><span class="s1">return this</span><span class="s0">.state=t,r}tsTryParseAndCatch(e){const t=</span><span class="s1">this</span><span class="s0">.tryParse((t=&gt;e()||t()));</span><span class="s1">if</span><span class="s0">(!t.aborted&amp;&amp;t.node)</span><span class="s1">return </span><span class="s0">t.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=t.failState),t.node}tsTryParse(e){const t=</span><span class="s1">this</span><span class="s0">.state.clone(),r=e();</span><span class="s1">return void </span><span class="s2">0</span><span class="s0">!==r&amp;&amp;!</span><span class="s2">1</span><span class="s0">!==r?r:</span><span class="s1">void</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state=t)}tsTryParseDeclare(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isLineTerminator())</span><span class="s1">return</span><span class="s0">;let t,r=</span><span class="s1">this</span><span class="s0">.state.type;</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;let&quot;</span><span class="s0">)&amp;&amp;(r=c._var,t=</span><span class="s3">&quot;let&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsInAmbientContext((()=&gt;{</span><span class="s1">switch</span><span class="s0">(r){</span><span class="s1">case </span><span class="s0">c._function:</span><span class="s1">return </span><span class="s0">e.declare=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseFunctionStatement(e,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._class:</span><span class="s1">return </span><span class="s0">e.declare=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseClass(e,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._const:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._const)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isLookaheadContextual(</span><span class="s3">&quot;enum&quot;</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.expect(c._const),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;enum&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsParseEnumDeclaration(e,!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._var:</span><span class="s1">return </span><span class="s0">t=t||</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.parseVarStatement(e,t);</span><span class="s1">case </span><span class="s0">c.name:{const t=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">return</span><span class="s3">&quot;global&quot;</span><span class="s0">===t?</span><span class="s1">this</span><span class="s0">.tsParseAmbientExternalModuleDeclaration(e):</span><span class="s1">this</span><span class="s0">.tsParseDeclaration(e,t,!</span><span class="s2">0</span><span class="s0">)}}}))}tsTryParseExportDeclaration(){</span><span class="s1">return this</span><span class="s0">.tsParseDeclaration(</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.state.value,!</span><span class="s2">0</span><span class="s0">)}tsParseExpressionStatement(e,t){</span><span class="s1">switch</span><span class="s0">(t.name){</span><span class="s1">case</span><span class="s3">&quot;declare&quot;</span><span class="s0">:{const t=</span><span class="s1">this</span><span class="s0">.tsTryParseDeclare(e);</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return </span><span class="s0">t.declare=!</span><span class="s2">0</span><span class="s0">,t;</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case</span><span class="s3">&quot;global&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.braceL)){</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">256</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.enter(</span><span class="s2">0</span><span class="s0">);const r=e;</span><span class="s1">return </span><span class="s0">r.global=!</span><span class="s2">0</span><span class="s0">,r.id=t,r.body=</span><span class="s1">this</span><span class="s0">.tsParseModuleBlock(),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;TSModuleDeclaration&quot;</span><span class="s0">)}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.tsParseDeclaration(e,t.name,!</span><span class="s2">1</span><span class="s0">)}}tsParseDeclaration(e,t,r){</span><span class="s1">switch</span><span class="s0">(t){</span><span class="s1">case</span><span class="s3">&quot;abstract&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsCheckLineTerminator(r)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.match(c._class)||</span><span class="s1">this</span><span class="s0">.match(c.name)))</span><span class="s1">return this</span><span class="s0">.tsParseAbstractDeclaration(e);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;enum&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(r||</span><span class="s1">this</span><span class="s0">.match(c.name))</span><span class="s1">return </span><span class="s0">r&amp;&amp;</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.tsParseEnumDeclaration(e,!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;interface&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsCheckLineTerminator(r)&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.name))</span><span class="s1">return this</span><span class="s0">.tsParseInterfaceDeclaration(e);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;module&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsCheckLineTerminator(r)){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.string))</span><span class="s1">return this</span><span class="s0">.tsParseAmbientExternalModuleDeclaration(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.name))</span><span class="s1">return this</span><span class="s0">.tsParseModuleOrNamespaceDeclaration(e)}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;namespace&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsCheckLineTerminator(r)&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.name))</span><span class="s1">return this</span><span class="s0">.tsParseModuleOrNamespaceDeclaration(e);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;type&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsCheckLineTerminator(r)&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.name))</span><span class="s1">return this</span><span class="s0">.tsParseTypeAliasDeclaration(e)}}tsCheckLineTerminator(e){</span><span class="s1">return </span><span class="s0">e?!</span><span class="s1">this</span><span class="s0">.hasFollowingLineBreak()&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),!</span><span class="s2">0</span><span class="s0">):!</span><span class="s1">this</span><span class="s0">.isLineTerminator()}tsTryParseGenericAsyncArrowFunction(e,t){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">))</span><span class="s1">return</span><span class="s0">;const r=</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters;</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s2">0</span><span class="s0">;const n=</span><span class="s1">this</span><span class="s0">.tsTryParseAndCatch((()=&gt;{const r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);</span><span class="s1">return </span><span class="s0">r.typeParameters=</span><span class="s1">this</span><span class="s0">.tsParseTypeParameters(),super.parseFunctionParams(r),r.returnType=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeOrTypePredicateAnnotation(),</span><span class="s1">this</span><span class="s0">.expect(c.arrow),r}));</span><span class="s1">return this</span><span class="s0">.state.maybeInArrowParameters=r,n?</span><span class="s1">this</span><span class="s0">.parseArrowExpression(n,</span><span class="s1">null</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">):</span><span class="s1">void </span><span class="s2">0</span><span class="s0">}tsParseTypeArguments(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.params=</span><span class="s1">this</span><span class="s0">.tsInType((()=&gt;</span><span class="s1">this</span><span class="s0">.tsInNoContext((()=&gt;(</span><span class="s1">this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsParseDelimitedList(</span><span class="s3">&quot;TypeParametersOrArguments&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseType.bind(</span><span class="s1">this</span><span class="s0">))))))),</span><span class="s2">0</span><span class="s0">===e.params.length&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,fe.EmptyTypeArguments),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">)}tsIsDeclarationStart(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.name))</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.value){</span><span class="s1">case</span><span class="s3">&quot;abstract&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;declare&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;enum&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;interface&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;module&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;namespace&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;type&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}isExportDefaultSpecifier(){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.tsIsDeclarationStart()&amp;&amp;super.isExportDefaultSpecifier()}parseAssignableListItem(e,t){const r=</span><span class="s1">this</span><span class="s0">.state.start,n=</span><span class="s1">this</span><span class="s0">.state.startLoc;let i,s=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">void </span><span class="s2">0</span><span class="s0">!==e&amp;&amp;(i=</span><span class="s1">this</span><span class="s0">.parseAccessModifier(),s=!!</span><span class="s1">this</span><span class="s0">.tsParseModifier([</span><span class="s3">&quot;readonly&quot;</span><span class="s0">]),!</span><span class="s2">1</span><span class="s0">===e&amp;&amp;(i||s)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r,fe.UnexpectedParameterModifier));const a=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault();</span><span class="s1">this</span><span class="s0">.parseAssignableListItemTypes(a);const o=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault(a.start,a.loc.start,a);</span><span class="s1">if</span><span class="s0">(i||s){const e=</span><span class="s1">this</span><span class="s0">.startNodeAt(r,n);</span><span class="s1">return </span><span class="s0">t.length&amp;&amp;(e.decorators=t),i&amp;&amp;(e.accessibility=i),s&amp;&amp;(e.readonly=s),</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==o.type&amp;&amp;</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">!==o.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,fe.UnsupportedParameterPropertyKind),e.parameter=o,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSParameterProperty&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">t.length&amp;&amp;(a.decorators=t),o}parseFunctionBodyAndFinish(e,t,r=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.match(c.colon)&amp;&amp;(e.returnType=</span><span class="s1">this</span><span class="s0">.tsParseTypeOrTypePredicateAnnotation(c.colon));const n=</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">===t?</span><span class="s3">&quot;TSDeclareFunction&quot;</span><span class="s0">:</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">===t?</span><span class="s3">&quot;TSDeclareMethod&quot;</span><span class="s0">:</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;n&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.braceL)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isLineTerminator()?</span><span class="s1">this</span><span class="s0">.finishNode(e,n):</span><span class="s3">&quot;TSDeclareFunction&quot;</span><span class="s0">===n&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.isAmbientContext&amp;&amp;(</span><span class="s1">this</span><span class="s0">.raise(e.start,fe.DeclareFunctionHasImplementation),e.declare)?super.parseFunctionBodyAndFinish(e,n,r):super.parseFunctionBodyAndFinish(e,t,r)}registerFunctionStatementId(e){!e.body&amp;&amp;e.id?</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,</span><span class="s3">&quot;function name&quot;</span><span class="s0">,</span><span class="s2">1024</span><span class="s0">):super.registerFunctionStatementId(...arguments)}tsCheckForInvalidTypeCasts(e){e.forEach((e=&gt;{</span><span class="s3">&quot;TSTypeCastExpression&quot;</span><span class="s0">===(</span><span class="s1">null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:e.type)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.typeAnnotation.start,fe.UnexpectedTypeAnnotation)}))}toReferencedList(e,t){</span><span class="s1">return this</span><span class="s0">.tsCheckForInvalidTypeCasts(e),e}parseArrayLike(...e){const t=super.parseArrayLike(...e);</span><span class="s1">return</span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s0">===t.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsCheckForInvalidTypeCasts(t.elements),t}parseSubscript(e,t,r,n,i){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.bang)){</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next();const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">n.expression=e,</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;TSNonNullExpression&quot;</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)){const s=</span><span class="s1">this</span><span class="s0">.tsTryParseAndCatch((()=&gt;{</span><span class="s1">if</span><span class="s0">(!n&amp;&amp;</span><span class="s1">this</span><span class="s0">.atPossibleAsyncArrow(e)){const e=</span><span class="s1">this</span><span class="s0">.tsTryParseGenericAsyncArrowFunction(t,r);</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">return </span><span class="s0">e}const s=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);s.callee=e;const a=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments();</span><span class="s1">if</span><span class="s0">(a){</span><span class="s1">if</span><span class="s0">(!n&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.parenL))</span><span class="s1">return </span><span class="s0">s.arguments=</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(c.parenR,!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsCheckForInvalidTypeCasts(s.arguments),s.typeParameters=a,i.optionalChainMember&amp;&amp;(s.optional=!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishCallExpression(s,i.optionalChainMember);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.backQuote)){const n=</span><span class="s1">this</span><span class="s0">.parseTaggedTemplateExpression(e,t,r,i);</span><span class="s1">return </span><span class="s0">n.typeParameters=a,n}}</span><span class="s1">this</span><span class="s0">.unexpected()}));</span><span class="s1">if</span><span class="s0">(s)</span><span class="s1">return </span><span class="s0">s}</span><span class="s1">return </span><span class="s0">super.parseSubscript(e,t,r,n,i)}parseNewArguments(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)){const t=</span><span class="s1">this</span><span class="s0">.tsTryParseAndCatch((()=&gt;{const e=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments();</span><span class="s1">return this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.unexpected(),e}));t&amp;&amp;(e.typeParameters=t)}super.parseNewArguments(e)}parseExprOp(e,t,r,n){</span><span class="s1">if</span><span class="s0">(de(c._in.binop)&gt;n&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">)){const i=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);i.expression=e;const s=</span><span class="s1">this</span><span class="s0">.tsTryNextParseConstantContext();</span><span class="s1">return </span><span class="s0">i.typeAnnotation=s||</span><span class="s1">this</span><span class="s0">.tsNextThenParseType(),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s3">&quot;TSAsExpression&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.reScan_lt_gt(),</span><span class="s1">this</span><span class="s0">.parseExprOp(i,t,r,n)}</span><span class="s1">return </span><span class="s0">super.parseExprOp(e,t,r,n)}checkReservedWord(e,t,r,n){}checkDuplicateExports(){}parseImport(e){</span><span class="s1">if</span><span class="s0">(e.importKind=</span><span class="s3">&quot;value&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(c.name)||</span><span class="s1">this</span><span class="s0">.match(c.star)||</span><span class="s1">this</span><span class="s0">.match(c.braceL)){let t=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)||t.type===c.comma||t.type===c.name&amp;&amp;</span><span class="s3">&quot;from&quot;</span><span class="s0">===t.value||t.type===c.eq||(e.importKind=</span><span class="s3">&quot;type&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next(),t=</span><span class="s1">this</span><span class="s0">.lookahead()),</span><span class="s1">this</span><span class="s0">.match(c.name)&amp;&amp;t.type===c.eq)</span><span class="s1">return this</span><span class="s0">.tsParseImportEqualsDeclaration(e)}const t=super.parseImport(e);</span><span class="s1">return</span><span class="s3">&quot;type&quot;</span><span class="s0">===t.importKind&amp;&amp;t.specifiers.length&gt;</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">===t.specifiers[</span><span class="s2">0</span><span class="s0">].type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,fe.TypeImportCannotSpecifyDefaultAndNamed),t}parseExport(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._import))</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">61</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()?(e.importKind=</span><span class="s3">&quot;type&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next()):e.importKind=</span><span class="s3">&quot;value&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseImportEqualsDeclaration(e,!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.eq)){const t=e;</span><span class="s1">return </span><span class="s0">t.expression=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSExportAssignment&quot;</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">)){const t=e;</span><span class="s1">return this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;namespace&quot;</span><span class="s0">),t.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSNamespaceExportDeclaration&quot;</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookahead().type===c.braceL?(</span><span class="s1">this</span><span class="s0">.next(),e.exportKind=</span><span class="s3">&quot;type&quot;</span><span class="s0">):e.exportKind=</span><span class="s3">&quot;value&quot;</span><span class="s0">,super.parseExport(e)}isAbstractClass(){</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;abstract&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookahead().type===c._class}parseExportDefaultExpression(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isAbstractClass()){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),e.abstract=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseClass(e,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),e}</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;interface&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value){const e=</span><span class="s1">this</span><span class="s0">.tsParseDeclaration(</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.state.value,!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">return </span><span class="s0">super.parseExportDefaultExpression()}parseStatementContent(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type===c._const){const e=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s1">if</span><span class="s0">(e.type===c.name&amp;&amp;</span><span class="s3">&quot;enum&quot;</span><span class="s0">===e.value){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(c._const),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;enum&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsParseEnumDeclaration(e,!</span><span class="s2">0</span><span class="s0">)}}</span><span class="s1">return </span><span class="s0">super.parseStatementContent(e,t)}parseAccessModifier(){</span><span class="s1">return this</span><span class="s0">.tsParseModifier([</span><span class="s3">&quot;public&quot;</span><span class="s0">,</span><span class="s3">&quot;protected&quot;</span><span class="s0">,</span><span class="s3">&quot;private&quot;</span><span class="s0">])}tsHasSomeModifiers(e,t){</span><span class="s1">return </span><span class="s0">t.some((t=&gt;me(t)?e.accessibility===t:!!e[t]))}parseClassMember(e,t,r){const n=[</span><span class="s3">&quot;declare&quot;</span><span class="s0">,</span><span class="s3">&quot;private&quot;</span><span class="s0">,</span><span class="s3">&quot;public&quot;</span><span class="s0">,</span><span class="s3">&quot;protected&quot;</span><span class="s0">,</span><span class="s3">&quot;override&quot;</span><span class="s0">,</span><span class="s3">&quot;abstract&quot;</span><span class="s0">,</span><span class="s3">&quot;readonly&quot;</span><span class="s0">];</span><span class="s1">this</span><span class="s0">.tsParseModifiers(t,n.concat([</span><span class="s3">&quot;static&quot;</span><span class="s0">]));const i=()=&gt;{const i=!!t.static;i&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.braceL)?(</span><span class="s1">this</span><span class="s0">.tsHasSomeModifiers(t,n)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,fe.StaticBlockCannotHaveModifier),</span><span class="s1">this</span><span class="s0">.parseClassStaticBlock(e,t)):</span><span class="s1">this</span><span class="s0">.parseClassMemberWithIsStatic(e,t,r,i)};t.declare?</span><span class="s1">this</span><span class="s0">.tsInAmbientContext(i):i()}parseClassMemberWithIsStatic(e,t,r,n){const i=</span><span class="s1">this</span><span class="s0">.tsTryParseIndexSignature(t);</span><span class="s1">if</span><span class="s0">(i)</span><span class="s1">return </span><span class="s0">e.body.push(i),t.abstract&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,fe.IndexSignatureHasAbstract),t.accessibility&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,fe.IndexSignatureHasAccessibility,t.accessibility),t.declare&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,fe.IndexSignatureHasDeclare),</span><span class="s1">void</span><span class="s0">(t.override&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,fe.IndexSignatureHasOverride));!</span><span class="s1">this</span><span class="s0">.state.inAbstractClass&amp;&amp;t.abstract&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,fe.NonAbstractClassHasAbstractMethod),t.override&amp;&amp;(r.hadSuperClass||</span><span class="s1">this</span><span class="s0">.raise(t.start,fe.OverrideNotInSubClass)),super.parseClassMemberWithIsStatic(e,t,r,n)}parsePostMemberNameModifiers(e){</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(e.optional=!</span><span class="s2">0</span><span class="s0">),e.readonly&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.parenL)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,fe.ClassMethodHasReadonly),e.declare&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.parenL)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,fe.ClassMethodHasDeclare)}parseExpressionStatement(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===t.type?</span><span class="s1">this</span><span class="s0">.tsParseExpressionStatement(e,t):</span><span class="s1">void </span><span class="s2">0</span><span class="s0">)||super.parseExpressionStatement(e,t)}shouldParseExportDeclaration(){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.tsIsDeclarationStart()||super.shouldParseExportDeclaration()}parseConditional(e,t,r,n){</span><span class="s1">if</span><span class="s0">(!n||!</span><span class="s1">this</span><span class="s0">.match(c.question))</span><span class="s1">return </span><span class="s0">super.parseConditional(e,t,r,n);const i=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;super.parseConditional(e,t,r)));</span><span class="s1">return </span><span class="s0">i.node?(i.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=i.failState),i.node):(n.start=i.error.pos||</span><span class="s1">this</span><span class="s0">.state.start,e)}parseParenItem(e,t,r){</span><span class="s1">if</span><span class="s0">(e=super.parseParenItem(e,t,r),</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(e.optional=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e)),</span><span class="s1">this</span><span class="s0">.match(c.colon)){const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">n.expression=e,n.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;TSTypeCastExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}parseExportDeclaration(e){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.state.startLoc,n=</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;declare&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(n&amp;&amp;(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;declare&quot;</span><span class="s0">)||!</span><span class="s1">this</span><span class="s0">.shouldParseExportDeclaration()))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,fe.ExpectedAmbientAfterExportDeclare);let i;</span><span class="s1">return this</span><span class="s0">.match(c.name)&amp;&amp;(i=</span><span class="s1">this</span><span class="s0">.tsTryParseExportDeclaration()),i||(i=super.parseExportDeclaration(e)),i&amp;&amp;(</span><span class="s3">&quot;TSInterfaceDeclaration&quot;</span><span class="s0">===i.type||</span><span class="s3">&quot;TSTypeAliasDeclaration&quot;</span><span class="s0">===i.type||n)&amp;&amp;(e.exportKind=</span><span class="s3">&quot;type&quot;</span><span class="s0">),i&amp;&amp;n&amp;&amp;(</span><span class="s1">this</span><span class="s0">.resetStartLocation(i,t,r),i.declare=!</span><span class="s2">0</span><span class="s0">),i}parseClassId(e,t,r){</span><span class="s1">if</span><span class="s0">((!t||r)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;implements&quot;</span><span class="s0">))</span><span class="s1">return</span><span class="s0">;super.parseClassId(e,t,r,e.declare?</span><span class="s2">1024</span><span class="s0">:</span><span class="s2">139</span><span class="s0">);const n=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters();n&amp;&amp;(e.typeParameters=n)}parseClassPropertyAnnotation(e){!e.optional&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.bang)&amp;&amp;(e.definite=!</span><span class="s2">0</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();t&amp;&amp;(e.typeAnnotation=t)}parseClassProperty(e){</span><span class="s1">return this</span><span class="s0">.parseClassPropertyAnnotation(e),</span><span class="s1">this</span><span class="s0">.state.isAmbientContext&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.eq)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,fe.DeclareClassFieldHasInitializer),super.parseClassProperty(e)}parseClassPrivateProperty(e){</span><span class="s1">return </span><span class="s0">e.abstract&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,fe.PrivateElementHasAbstract),e.accessibility&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,fe.PrivateElementHasAccessibility,e.accessibility),</span><span class="s1">this</span><span class="s0">.parseClassPropertyAnnotation(e),super.parseClassPrivateProperty(e)}pushClassMethod(e,t,r,n,i,s){const a=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters();a&amp;&amp;i&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(a.start,fe.ConstructorHasTypeParameters),!t.declare||</span><span class="s3">&quot;get&quot;</span><span class="s0">!==t.kind&amp;&amp;</span><span class="s3">&quot;set&quot;</span><span class="s0">!==t.kind||</span><span class="s1">this</span><span class="s0">.raise(t.start,fe.DeclareAccessor,t.kind),a&amp;&amp;(t.typeParameters=a),super.pushClassMethod(e,t,r,n,i,s)}pushClassPrivateMethod(e,t,r,n){const i=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters();i&amp;&amp;(t.typeParameters=i),super.pushClassPrivateMethod(e,t,r,n)}parseClassSuper(e){super.parseClassSuper(e),e.superClass&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(e.superTypeParameters=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments()),</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;implements&quot;</span><span class="s0">)&amp;&amp;(e.implements=</span><span class="s1">this</span><span class="s0">.tsParseHeritageClause(</span><span class="s3">&quot;implements&quot;</span><span class="s0">))}parseObjPropValue(e,...t){const r=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters();r&amp;&amp;(e.typeParameters=r),super.parseObjPropValue(e,...t)}parseFunctionParams(e,t){const r=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters();r&amp;&amp;(e.typeParameters=r),super.parseFunctionParams(e,t)}parseVarId(e,t){super.parseVarId(e,t),</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.id.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.bang)&amp;&amp;(e.definite=!</span><span class="s2">0</span><span class="s0">);const r=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();r&amp;&amp;(e.id.typeAnnotation=r,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e.id))}parseAsyncArrowFromCallExpression(e,t){</span><span class="s1">return this</span><span class="s0">.match(c.colon)&amp;&amp;(e.returnType=</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation()),super.parseAsyncArrowFromCallExpression(e,t)}parseMaybeAssign(...e){</span><span class="s1">var </span><span class="s0">t,r,n,i,s,a,o;let l,p,u,d;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;jsx&quot;</span><span class="s0">)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.match(c.jsxTagStart)||</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">))){</span><span class="s1">if</span><span class="s0">(l=</span><span class="s1">this</span><span class="s0">.state.clone(),p=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;super.parseMaybeAssign(...e)),l),!p.error)</span><span class="s1">return </span><span class="s0">p.node;const{context:t}=</span><span class="s1">this</span><span class="s0">.state;t[t.length-1]===O.j_oTag?t.length-=</span><span class="s2">2</span><span class="s0">:t[t.length-1]===O.j_expr&amp;&amp;(t.length-=</span><span class="s2">1</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(!(</span><span class="s1">null</span><span class="s0">!=(t=p)&amp;&amp;t.error||</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)))</span><span class="s1">return </span><span class="s0">super.parseMaybeAssign(...e);l=l||</span><span class="s1">this</span><span class="s0">.state.clone();const h=</span><span class="s1">this</span><span class="s0">.tryParse((t=&gt;{</span><span class="s1">var </span><span class="s0">r,n;d=</span><span class="s1">this</span><span class="s0">.tsParseTypeParameters();const i=super.parseMaybeAssign(...e);</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">!==i.type||</span><span class="s1">null</span><span class="s0">!=(r=i.extra)&amp;&amp;r.parenthesized)&amp;&amp;t(),</span><span class="s2">0</span><span class="s0">!==(</span><span class="s1">null</span><span class="s0">==(n=d)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:n.params.length)&amp;&amp;</span><span class="s1">this</span><span class="s0">.resetStartLocationFromNode(i,d),i.typeParameters=d,i}),l);</span><span class="s1">if</span><span class="s0">(!h.error&amp;&amp;!h.aborted)</span><span class="s1">return </span><span class="s0">h.node;</span><span class="s1">if</span><span class="s0">(!p&amp;&amp;(he(!</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;jsx&quot;</span><span class="s0">)),u=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;super.parseMaybeAssign(...e)),l),!u.error))</span><span class="s1">return </span><span class="s0">u.node;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=(r=p)&amp;&amp;r.node)</span><span class="s1">return this</span><span class="s0">.state=p.failState,p.node;</span><span class="s1">if</span><span class="s0">(h.node)</span><span class="s1">return this</span><span class="s0">.state=h.failState,h.node;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=(n=u)&amp;&amp;n.node)</span><span class="s1">return this</span><span class="s0">.state=u.failState,u.node;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=(i=p)&amp;&amp;i.thrown)</span><span class="s1">throw </span><span class="s0">p.error;</span><span class="s1">if</span><span class="s0">(h.thrown)</span><span class="s1">throw </span><span class="s0">h.error;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=(s=u)&amp;&amp;s.thrown)</span><span class="s1">throw </span><span class="s0">u.error;</span><span class="s1">throw</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==(a=p)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:a.error)||h.error||(</span><span class="s1">null</span><span class="s0">==(o=u)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:o.error)}parseMaybeUnary(e){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;jsx&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.tsParseTypeAssertion():super.parseMaybeUnary(e)}parseArrow(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.colon)){const t=</span><span class="s1">this</span><span class="s0">.tryParse((e=&gt;{const t=</span><span class="s1">this</span><span class="s0">.tsParseTypeOrTypePredicateAnnotation(c.colon);</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.arrow)||e(),t}));</span><span class="s1">if</span><span class="s0">(t.aborted)</span><span class="s1">return</span><span class="s0">;t.thrown||(t.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=t.failState),e.returnType=t.node)}</span><span class="s1">return </span><span class="s0">super.parseArrow(e)}parseAssignableListItemTypes(e){</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type||</span><span class="s1">this</span><span class="s0">.state.isAmbientContext||</span><span class="s1">this</span><span class="s0">.state.inType||</span><span class="s1">this</span><span class="s0">.raise(e.start,fe.PatternIsOptional),e.optional=!</span><span class="s2">0</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();</span><span class="s1">return </span><span class="s0">t&amp;&amp;(e.typeAnnotation=t),</span><span class="s1">this</span><span class="s0">.resetEndLocation(e),e}toAssignable(e,t=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">switch</span><span class="s0">(e.type){</span><span class="s1">case</span><span class="s3">&quot;TSTypeCastExpression&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">super.toAssignable(</span><span class="s1">this</span><span class="s0">.typeCastToParameter(e),t);</span><span class="s1">case</span><span class="s3">&quot;TSParameterProperty&quot;</span><span class="s0">:</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return </span><span class="s0">super.toAssignable(e,t);</span><span class="s1">case</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.toAssignableParenthesizedExpression(e,t);</span><span class="s1">case</span><span class="s3">&quot;TSAsExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TSNonNullExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TSTypeAssertion&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.expression=</span><span class="s1">this</span><span class="s0">.toAssignable(e.expression,t),e}}toAssignableParenthesizedExpression(e,t){</span><span class="s1">switch</span><span class="s0">(e.expression.type){</span><span class="s1">case</span><span class="s3">&quot;TSAsExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TSNonNullExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TSTypeAssertion&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.expression=</span><span class="s1">this</span><span class="s0">.toAssignable(e.expression,t),e;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return </span><span class="s0">super.toAssignable(e,t)}}checkLVal(e,t,...r){</span><span class="s1">var </span><span class="s0">n;</span><span class="s1">switch</span><span class="s0">(e.type){</span><span class="s1">case</span><span class="s3">&quot;TSTypeCastExpression&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;TSParameterProperty&quot;</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.checkLVal(e.parameter,</span><span class="s3">&quot;parameter property&quot;</span><span class="s0">,...r);</span><span class="s1">case</span><span class="s3">&quot;TSAsExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TSTypeAssertion&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(!(r[</span><span class="s2">0</span><span class="s0">]||</span><span class="s3">&quot;parenthesized expression&quot;</span><span class="s0">===t||</span><span class="s1">null</span><span class="s0">!=(n=e.extra)&amp;&amp;n.parenthesized)){</span><span class="s1">this</span><span class="s0">.raise(e.start,E.InvalidLhs,t);</span><span class="s1">break</span><span class="s0">}</span><span class="s1">return void this</span><span class="s0">.checkLVal(e.expression,</span><span class="s3">&quot;parenthesized expression&quot;</span><span class="s0">,...r);</span><span class="s1">case</span><span class="s3">&quot;TSNonNullExpression&quot;</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.checkLVal(e.expression,t,...r);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return void </span><span class="s0">super.checkLVal(e,t,...r)}}parseBindingAtom(){</span><span class="s1">return this</span><span class="s0">.state.type===c._this?</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">):super.parseBindingAtom()}parseMaybeDecoratorArguments(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)){const t=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.parenL)){const r=super.parseMaybeDecoratorArguments(e);</span><span class="s1">return </span><span class="s0">r.typeParameters=t,r}</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">this</span><span class="s0">.state.start,c.parenL)}</span><span class="s1">return </span><span class="s0">super.parseMaybeDecoratorArguments(e)}checkCommaAfterRest(e){</span><span class="s1">this</span><span class="s0">.state.isAmbientContext&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.comma)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()===e?</span><span class="s1">this</span><span class="s0">.next():super.checkCommaAfterRest(e)}isClassMethod(){</span><span class="s1">return this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)||super.isClassMethod()}isClassProperty(){</span><span class="s1">return this</span><span class="s0">.match(c.bang)||</span><span class="s1">this</span><span class="s0">.match(c.colon)||super.isClassProperty()}parseMaybeDefault(...e){const t=super.parseMaybeDefault(...e);</span><span class="s1">return</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">===t.type&amp;&amp;t.typeAnnotation&amp;&amp;t.right.start&lt;t.typeAnnotation.start&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.typeAnnotation.start,fe.TypeAnnotationAfterAssign),t}getTokenFromCode(e){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.state.inType||</span><span class="s2">62</span><span class="s0">!==e&amp;&amp;</span><span class="s2">60</span><span class="s0">!==e?super.getTokenFromCode(e):</span><span class="s1">this</span><span class="s0">.finishOp(c.relational,</span><span class="s2">1</span><span class="s0">)}reScan_lt_gt(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.relational)){const e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.start);</span><span class="s2">60</span><span class="s0">!==e&amp;&amp;</span><span class="s2">62</span><span class="s0">!==e||(</span><span class="s1">this</span><span class="s0">.state.pos-=</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.readToken_lt_gt(e))}}toAssignableList(e){</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">;t&lt;e.length;t++){const r=e[t];</span><span class="s1">if</span><span class="s0">(r)</span><span class="s1">switch</span><span class="s0">(r.type){</span><span class="s1">case</span><span class="s3">&quot;TSTypeCastExpression&quot;</span><span class="s0">:e[t]=</span><span class="s1">this</span><span class="s0">.typeCastToParameter(r);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;TSAsExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TSTypeAssertion&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters?</span><span class="s1">this</span><span class="s0">.raise(r.start,fe.UnexpectedTypeCastInParameter):e[t]=</span><span class="s1">this</span><span class="s0">.typeCastToParameter(r)}}</span><span class="s1">return </span><span class="s0">super.toAssignableList(...arguments)}typeCastToParameter(e){</span><span class="s1">return </span><span class="s0">e.expression.typeAnnotation=e.typeAnnotation,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e.expression,e.typeAnnotation.end,e.typeAnnotation.loc.end),e.expression}shouldParseArrow(){</span><span class="s1">return this</span><span class="s0">.match(c.colon)||super.shouldParseArrow()}shouldParseAsyncArrow(){</span><span class="s1">return this</span><span class="s0">.match(c.colon)||super.shouldParseAsyncArrow()}canHaveLeadingDecorator(){</span><span class="s1">return </span><span class="s0">super.canHaveLeadingDecorator()||</span><span class="s1">this</span><span class="s0">.isAbstractClass()}jsxParseOpeningElementAfterName(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)){const t=</span><span class="s1">this</span><span class="s0">.tsTryParseAndCatch((()=&gt;</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments()));t&amp;&amp;(e.typeParameters=t)}</span><span class="s1">return </span><span class="s0">super.jsxParseOpeningElementAfterName(e)}getGetterSetterExpectedParamCount(e){const t=super.getGetterSetterExpectedParamCount(e),r=</span><span class="s1">this</span><span class="s0">.getObjectOrClassMethodParams(e)[</span><span class="s2">0</span><span class="s0">];</span><span class="s1">return </span><span class="s0">r&amp;&amp;</span><span class="s1">this</span><span class="s0">.isThisParam(r)?t+</span><span class="s2">1</span><span class="s0">:t}parseCatchClauseParam(){const e=super.parseCatchClauseParam(),t=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();</span><span class="s1">return </span><span class="s0">t&amp;&amp;(e.typeAnnotation=t,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e)),e}tsInAmbientContext(e){const t=</span><span class="s1">this</span><span class="s0">.state.isAmbientContext;</span><span class="s1">this</span><span class="s0">.state.isAmbientContext=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.isAmbientContext=t}}parseClass(e,...t){const r=</span><span class="s1">this</span><span class="s0">.state.inAbstractClass;</span><span class="s1">this</span><span class="s0">.state.inAbstractClass=!!e.abstract;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">super.parseClass(e,...t)}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.inAbstractClass=r}}tsParseAbstractDeclaration(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._class))</span><span class="s1">return </span><span class="s0">e.abstract=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseClass(e,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;interface&quot;</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.hasFollowingLineBreak())</span><span class="s1">return </span><span class="s0">e.abstract=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.raise(e.start,fe.NonClassMethodPropertyHasAbstractModifer),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.tsParseInterfaceDeclaration(e)}</span><span class="s1">else this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,c._class)}parseMethod(...e){const t=super.parseMethod(...e);</span><span class="s1">if</span><span class="s0">(t.abstract&amp;&amp;(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;estree&quot;</span><span class="s0">)?t.value.body:t.body)){const{key:e}=t;</span><span class="s1">this</span><span class="s0">.raise(t.start,fe.AbstractMethodHasImplementation,</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type?e.name:`[${</span><span class="s1">this</span><span class="s0">.input.slice(e.start,e.end)}]`)}</span><span class="s1">return </span><span class="s0">t}shouldParseAsAmbientContext(){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;typescript&quot;</span><span class="s0">,</span><span class="s3">&quot;dts&quot;</span><span class="s0">)}parse(){</span><span class="s1">return this</span><span class="s0">.shouldParseAsAmbientContext()&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.isAmbientContext=!</span><span class="s2">0</span><span class="s0">),super.parse()}getExpression(){</span><span class="s1">return this</span><span class="s0">.shouldParseAsAmbientContext()&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.isAmbientContext=!</span><span class="s2">0</span><span class="s0">),super.getExpression()}},v8intrinsic:e=&gt;class extends e{parseV8Intrinsic(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.modulo)){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.modulo),</span><span class="s1">this</span><span class="s0">.match(c.name)){const e=</span><span class="s1">this</span><span class="s0">.parseIdentifierName(</span><span class="s1">this</span><span class="s0">.state.start),r=</span><span class="s1">this</span><span class="s0">.createIdentifier(t,e);</span><span class="s1">if</span><span class="s0">(r.type=</span><span class="s3">&quot;V8IntrinsicIdentifier&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(c.parenL))</span><span class="s1">return </span><span class="s0">r}</span><span class="s1">this</span><span class="s0">.unexpected(e)}}parseExprAtom(){</span><span class="s1">return this</span><span class="s0">.parseV8Intrinsic()||super.parseExprAtom(...arguments)}},placeholders:e=&gt;class extends e{parsePlaceholder(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.placeholder)){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.assertNoSpace(</span><span class="s3">&quot;Unexpected space in placeholder.&quot;</span><span class="s0">),t.name=super.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.assertNoSpace(</span><span class="s3">&quot;Unexpected space in placeholder.&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.placeholder),</span><span class="s1">this</span><span class="s0">.finishPlaceholder(t,e)}}finishPlaceholder(e,t){const r=!(!e.expectedNode||</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">!==e.type);</span><span class="s1">return </span><span class="s0">e.expectedNode=t,r?e:</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">)}getTokenFromCode(e){</span><span class="s1">return </span><span class="s2">37</span><span class="s0">===e&amp;&amp;</span><span class="s2">37</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.finishOp(c.placeholder,</span><span class="s2">2</span><span class="s0">):super.getTokenFromCode(...arguments)}parseExprAtom(){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)||super.parseExprAtom(...arguments)}parseIdentifier(){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)||super.parseIdentifier(...arguments)}checkReservedWord(e){</span><span class="s1">void </span><span class="s2">0</span><span class="s0">!==e&amp;&amp;super.checkReservedWord(...arguments)}parseBindingAtom(){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">)||super.parseBindingAtom(...arguments)}checkLVal(e){</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">!==e.type&amp;&amp;super.checkLVal(...arguments)}toAssignable(e){</span><span class="s1">return </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;Expression&quot;</span><span class="s0">===e.expectedNode?(e.expectedNode=</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">,e):super.toAssignable(...arguments)}isLet(e){</span><span class="s1">return</span><span class="s0">!!super.isLet(e)||!!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;let&quot;</span><span class="s0">)&amp;&amp;(!e&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookahead().type===c.placeholder)}verifyBreakContinue(e){e.label&amp;&amp;</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===e.label.type||super.verifyBreakContinue(...arguments)}parseExpressionStatement(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">!==t.type||t.extra&amp;&amp;t.extra.parenthesized)</span><span class="s1">return </span><span class="s0">super.parseExpressionStatement(...arguments);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.colon)){const r=e;</span><span class="s1">return </span><span class="s0">r.label=</span><span class="s1">this</span><span class="s0">.finishPlaceholder(t,</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),r.body=</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s3">&quot;label&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;LabeledStatement&quot;</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.semicolon(),e.name=t.name,</span><span class="s1">this</span><span class="s0">.finishPlaceholder(e,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)}parseBlock(){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">)||super.parseBlock(...arguments)}parseFunctionId(){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)||super.parseFunctionId(...arguments)}parseClass(e,t,r){const n=t?</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">:</span><span class="s3">&quot;ClassExpression&quot;</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.takeDecorators(e);const i=</span><span class="s1">this</span><span class="s0">.state.strict,s=</span><span class="s1">this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(s)</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._extends)||</span><span class="s1">this</span><span class="s0">.match(c.placeholder)||</span><span class="s1">this</span><span class="s0">.match(c.braceL))e.id=s;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(r||!t)</span><span class="s1">return </span><span class="s0">e.id=</span><span class="s1">null</span><span class="s0">,e.body=</span><span class="s1">this</span><span class="s0">.finishPlaceholder(s,</span><span class="s3">&quot;ClassBody&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,n);</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,ye.ClassNameIsRequired)}</span><span class="s1">else this</span><span class="s0">.parseClassId(e,t,r);</span><span class="s1">return this</span><span class="s0">.parseClassSuper(e),e.body=</span><span class="s1">this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;ClassBody&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.parseClassBody(!!e.superClass,i),</span><span class="s1">this</span><span class="s0">.finishNode(e,n)}parseExport(e){const t=</span><span class="s1">this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return </span><span class="s0">super.parseExport(...arguments);</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;from&quot;</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.comma))</span><span class="s1">return </span><span class="s0">e.specifiers=[],e.source=</span><span class="s1">null</span><span class="s0">,e.declaration=</span><span class="s1">this</span><span class="s0">.finishPlaceholder(t,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;exportDefaultFrom&quot;</span><span class="s0">);const r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">r.exported=t,e.specifiers=[</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;ExportDefaultSpecifier&quot;</span><span class="s0">)],super.parseExport(e)}isExportDefaultSpecifier(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._default)){const e=</span><span class="s1">this</span><span class="s0">.nextTokenStart();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isUnparsedContextual(e,</span><span class="s3">&quot;from&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.input.startsWith(c.placeholder.label,</span><span class="s1">this</span><span class="s0">.nextTokenStartSince(e+</span><span class="s2">4</span><span class="s0">)))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return </span><span class="s0">super.isExportDefaultSpecifier()}maybeParseExportDefaultSpecifier(e){</span><span class="s1">return</span><span class="s0">!!(e.specifiers&amp;&amp;e.specifiers.length&gt;</span><span class="s2">0</span><span class="s0">)||super.maybeParseExportDefaultSpecifier(...arguments)}checkExport(e){const{specifiers:t}=e;</span><span class="s1">null</span><span class="s0">!=t&amp;&amp;t.length&amp;&amp;(e.specifiers=t.filter((e=&gt;</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===e.exported.type))),super.checkExport(e),e.specifiers=t}parseImport(e){const t=</span><span class="s1">this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return </span><span class="s0">super.parseImport(...arguments);</span><span class="s1">if</span><span class="s0">(e.specifiers=[],!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;from&quot;</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.comma))</span><span class="s1">return </span><span class="s0">e.source=</span><span class="s1">this</span><span class="s0">.finishPlaceholder(t,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">);const r=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(t);</span><span class="s1">return </span><span class="s0">r.local=t,</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">),e.specifiers.push(r),</span><span class="s1">this</span><span class="s0">.eat(c.comma)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.maybeParseStarImportSpecifier(e)||</span><span class="s1">this</span><span class="s0">.parseNamedImportSpecifiers(e)),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;from&quot;</span><span class="s0">),e.source=</span><span class="s1">this</span><span class="s0">.parseImportSource(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">)}parseImportSource(){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">)||super.parseImportSource(...arguments)}}},Ee=Object.keys(xe),Pe={sourceType:</span><span class="s3">&quot;script&quot;</span><span class="s0">,sourceFilename:</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,startLine:</span><span class="s2">1</span><span class="s0">,allowAwaitOutsideFunction:!</span><span class="s2">1</span><span class="s0">,allowReturnOutsideFunction:!</span><span class="s2">1</span><span class="s0">,allowImportExportEverywhere:!</span><span class="s2">1</span><span class="s0">,allowSuperOutsideMethod:!</span><span class="s2">1</span><span class="s0">,allowUndeclaredExports:!</span><span class="s2">1</span><span class="s0">,plugins:[],strictMode:</span><span class="s1">null</span><span class="s0">,ranges:!</span><span class="s2">1</span><span class="s0">,tokens:!</span><span class="s2">1</span><span class="s0">,createParenthesizedExpressions:!</span><span class="s2">1</span><span class="s0">,errorRecovery:!</span><span class="s2">1</span><span class="s0">};class ve{constructor(){</span><span class="s1">this</span><span class="s0">.strict=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.curLine=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.startLoc=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.endLoc=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.errors=[],</span><span class="s1">this</span><span class="s0">.potentialArrowAt=-</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.noArrowAt=[],</span><span class="s1">this</span><span class="s0">.noArrowParamsConversionAt=[],</span><span class="s1">this</span><span class="s0">.maybeInArrowParameters=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.inPipeline=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.inType=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.noAnonFunctionType=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.inPropertyName=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.hasFlowComment=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isAmbientContext=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.inAbstractClass=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.topicContext={maxNumOfResolvableTopics:</span><span class="s2">0</span><span class="s0">,maxTopicIndex:</span><span class="s1">null</span><span class="s0">},</span><span class="s1">this</span><span class="s0">.soloAwait=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.inFSharpPipelineDirectBody=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.labels=[],</span><span class="s1">this</span><span class="s0">.decoratorStack=[[]],</span><span class="s1">this</span><span class="s0">.comments=[],</span><span class="s1">this</span><span class="s0">.trailingComments=[],</span><span class="s1">this</span><span class="s0">.leadingComments=[],</span><span class="s1">this</span><span class="s0">.commentStack=[],</span><span class="s1">this</span><span class="s0">.commentPreviousNode=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.pos=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lineStart=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.type=c.eof,</span><span class="s1">this</span><span class="s0">.value=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.start=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.end=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lastTokEndLoc=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lastTokStartLoc=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lastTokStart=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lastTokEnd=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.context=[O.braceStatement],</span><span class="s1">this</span><span class="s0">.exprAllowed=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.containsEsc=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.strictErrors=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.exportedIdentifiers=[],</span><span class="s1">this</span><span class="s0">.tokensLength=</span><span class="s2">0</span><span class="s0">}init(e){</span><span class="s1">this</span><span class="s0">.strict=!</span><span class="s2">1</span><span class="s0">!==e.strictMode&amp;&amp;</span><span class="s3">&quot;module&quot;</span><span class="s0">===e.sourceType,</span><span class="s1">this</span><span class="s0">.curLine=e.startLine,</span><span class="s1">this</span><span class="s0">.startLoc=</span><span class="s1">this</span><span class="s0">.endLoc=</span><span class="s1">this</span><span class="s0">.curPosition()}curPosition(){</span><span class="s1">return new </span><span class="s0">y(</span><span class="s1">this</span><span class="s0">.curLine,</span><span class="s1">this</span><span class="s0">.pos-this.lineStart)}clone(e){const t=</span><span class="s1">new </span><span class="s0">ve,r=Object.keys(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let n=</span><span class="s2">0</span><span class="s0">,i=r.length;n&lt;i;n++){const i=r[n];let s=</span><span class="s1">this</span><span class="s0">[i];!e&amp;&amp;Array.isArray(s)&amp;&amp;(s=s.slice()),t[i]=s}</span><span class="s1">return </span><span class="s0">t}}</span><span class="s1">var </span><span class="s0">Ae=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">e&gt;=</span><span class="s2">48</span><span class="s0">&amp;&amp;e&lt;=</span><span class="s2">57</span><span class="s0">};const we=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">&quot;g&quot;</span><span class="s0">,</span><span class="s3">&quot;m&quot;</span><span class="s0">,</span><span class="s3">&quot;s&quot;</span><span class="s0">,</span><span class="s3">&quot;i&quot;</span><span class="s0">,</span><span class="s3">&quot;y&quot;</span><span class="s0">,</span><span class="s3">&quot;u&quot;</span><span class="s0">]),Oe={decBinOct:[</span><span class="s2">46</span><span class="s0">,</span><span class="s2">66</span><span class="s0">,</span><span class="s2">69</span><span class="s0">,</span><span class="s2">79</span><span class="s0">,</span><span class="s2">95</span><span class="s0">,</span><span class="s2">98</span><span class="s0">,</span><span class="s2">101</span><span class="s0">,</span><span class="s2">111</span><span class="s0">],hex:[</span><span class="s2">46</span><span class="s0">,</span><span class="s2">88</span><span class="s0">,</span><span class="s2">95</span><span class="s0">,</span><span class="s2">120</span><span class="s0">]},Ie={bin:[</span><span class="s2">48</span><span class="s0">,</span><span class="s2">49</span><span class="s0">]};Ie.oct=[...Ie.bin,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">51</span><span class="s0">,</span><span class="s2">52</span><span class="s0">,</span><span class="s2">53</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">55</span><span class="s0">],Ie.dec=[...Ie.oct,</span><span class="s2">56</span><span class="s0">,</span><span class="s2">57</span><span class="s0">],Ie.hex=[...Ie.dec,</span><span class="s2">65</span><span class="s0">,</span><span class="s2">66</span><span class="s0">,</span><span class="s2">67</span><span class="s0">,</span><span class="s2">68</span><span class="s0">,</span><span class="s2">69</span><span class="s0">,</span><span class="s2">70</span><span class="s0">,</span><span class="s2">97</span><span class="s0">,</span><span class="s2">98</span><span class="s0">,</span><span class="s2">99</span><span class="s0">,</span><span class="s2">100</span><span class="s0">,</span><span class="s2">101</span><span class="s0">,</span><span class="s2">102</span><span class="s0">];class Ne{constructor(e){</span><span class="s1">this</span><span class="s0">.type=e.type,</span><span class="s1">this</span><span class="s0">.value=e.value,</span><span class="s1">this</span><span class="s0">.start=e.start,</span><span class="s1">this</span><span class="s0">.end=e.end,</span><span class="s1">this</span><span class="s0">.loc=</span><span class="s1">new </span><span class="s0">T(e.startLoc,e.endLoc)}}class Ce extends A{constructor(e,t){super(),</span><span class="s1">this</span><span class="s0">.isLookahead=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tokens=[],</span><span class="s1">this</span><span class="s0">.state=</span><span class="s1">new </span><span class="s0">ve,</span><span class="s1">this</span><span class="s0">.state.init(e),</span><span class="s1">this</span><span class="s0">.input=t,</span><span class="s1">this</span><span class="s0">.length=t.length,</span><span class="s1">this</span><span class="s0">.isLookahead=!</span><span class="s2">1</span><span class="s0">}pushToken(e){</span><span class="s1">this</span><span class="s0">.tokens.length=</span><span class="s1">this</span><span class="s0">.state.tokensLength,</span><span class="s1">this</span><span class="s0">.tokens.push(e),++</span><span class="s1">this</span><span class="s0">.state.tokensLength}next(){</span><span class="s1">this</span><span class="s0">.isLookahead||(</span><span class="s1">this</span><span class="s0">.checkKeywordEscapes(),</span><span class="s1">this</span><span class="s0">.options.tokens&amp;&amp;</span><span class="s1">this</span><span class="s0">.pushToken(</span><span class="s1">new </span><span class="s0">Ne(</span><span class="s1">this</span><span class="s0">.state))),</span><span class="s1">this</span><span class="s0">.state.lastTokEnd=</span><span class="s1">this</span><span class="s0">.state.end,</span><span class="s1">this</span><span class="s0">.state.lastTokStart=</span><span class="s1">this</span><span class="s0">.state.start,</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc=</span><span class="s1">this</span><span class="s0">.state.endLoc,</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc=</span><span class="s1">this</span><span class="s0">.state.startLoc,</span><span class="s1">this</span><span class="s0">.nextToken()}eat(e){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.match(e)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),!</span><span class="s2">0</span><span class="s0">)}match(e){</span><span class="s1">return this</span><span class="s0">.state.type===e}lookahead(){const e=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">this</span><span class="s0">.state=e.clone(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.isLookahead=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.isLookahead=!</span><span class="s2">1</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">return this</span><span class="s0">.state=e,t}nextTokenStart(){</span><span class="s1">return this</span><span class="s0">.nextTokenStartSince(</span><span class="s1">this</span><span class="s0">.state.pos)}nextTokenStartSince(e){</span><span class="s1">return </span><span class="s0">f.lastIndex=e,e+f.exec(</span><span class="s1">this</span><span class="s0">.input)[</span><span class="s2">0</span><span class="s0">].length}lookaheadCharCode(){</span><span class="s1">return this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.nextTokenStart())}codePointAtPos(e){let t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">55296</span><span class="s0">==(</span><span class="s2">64512</span><span class="s0">&amp;t)&amp;&amp;++e&lt;</span><span class="s1">this</span><span class="s0">.input.length){const r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e);</span><span class="s2">56320</span><span class="s0">==(</span><span class="s2">64512</span><span class="s0">&amp;r)&amp;&amp;(t=</span><span class="s2">65536</span><span class="s0">+((</span><span class="s2">1023</span><span class="s0">&amp;t)&lt;&lt;</span><span class="s2">10</span><span class="s0">)+(</span><span class="s2">1023</span><span class="s0">&amp;r))}</span><span class="s1">return </span><span class="s0">t}setStrict(e){</span><span class="s1">this</span><span class="s0">.state.strict=e,e&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.strictErrors.forEach(((e,t)=&gt;</span><span class="s1">this</span><span class="s0">.raise(t,e))),</span><span class="s1">this</span><span class="s0">.state.strictErrors.clear())}curContext(){</span><span class="s1">return this</span><span class="s0">.state.context[</span><span class="s1">this</span><span class="s0">.state.context.length-1]}nextToken(){const e=</span><span class="s1">this</span><span class="s0">.curContext();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=e&amp;&amp;e.preserveSpace||</span><span class="s1">this</span><span class="s0">.skipSpace(),</span><span class="s1">this</span><span class="s0">.state.start=</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.state.startLoc=</span><span class="s1">this</span><span class="s0">.state.curPosition(),</span><span class="s1">this</span><span class="s0">.state.pos&gt;=</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">return void this</span><span class="s0">.finishToken(c.eof);const t=</span><span class="s1">null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:e.override;t?t(</span><span class="s1">this</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.getTokenFromCode(</span><span class="s1">this</span><span class="s0">.codePointAtPos(</span><span class="s1">this</span><span class="s0">.state.pos))}pushComment(e,t,r,n,i,s){const a={type:e?</span><span class="s3">&quot;CommentBlock&quot;</span><span class="s0">:</span><span class="s3">&quot;CommentLine&quot;</span><span class="s0">,value:t,start:r,end:n,loc:</span><span class="s1">new </span><span class="s0">T(i,s)};</span><span class="s1">this</span><span class="s0">.options.tokens&amp;&amp;</span><span class="s1">this</span><span class="s0">.pushToken(a),</span><span class="s1">this</span><span class="s0">.state.comments.push(a),</span><span class="s1">this</span><span class="s0">.addComment(a)}skipBlockComment(){const e=</span><span class="s1">this</span><span class="s0">.state.curPosition(),t=</span><span class="s1">this</span><span class="s0">.state.pos,r=</span><span class="s1">this</span><span class="s0">.input.indexOf(</span><span class="s3">&quot;*/&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(-</span><span class="s2">1</span><span class="s0">===r)</span><span class="s1">throw this</span><span class="s0">.raise(t,E.UnterminatedComment);let n;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos=r+</span><span class="s2">2</span><span class="s0">,d.lastIndex=t;(n=d.exec(</span><span class="s1">this</span><span class="s0">.input))&amp;&amp;n.index&lt;</span><span class="s1">this</span><span class="s0">.state.pos;)++</span><span class="s1">this</span><span class="s0">.state.curLine,</span><span class="s1">this</span><span class="s0">.state.lineStart=n.index+n[</span><span class="s2">0</span><span class="s0">].length;</span><span class="s1">this</span><span class="s0">.isLookahead||</span><span class="s1">this</span><span class="s0">.pushComment(!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.input.slice(t+</span><span class="s2">2</span><span class="s0">,r),t,</span><span class="s1">this</span><span class="s0">.state.pos,e,</span><span class="s1">this</span><span class="s0">.state.curPosition())}skipLineComment(e){const t=</span><span class="s1">this</span><span class="s0">.state.pos,r=</span><span class="s1">this</span><span class="s0">.state.curPosition();let n=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+=e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">for</span><span class="s0">(;!h(n)&amp;&amp;++</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length;)n=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">this</span><span class="s0">.isLookahead||</span><span class="s1">this</span><span class="s0">.pushComment(!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.input.slice(t+e,</span><span class="s1">this</span><span class="s0">.state.pos),t,</span><span class="s1">this</span><span class="s0">.state.pos,r,</span><span class="s1">this</span><span class="s0">.state.curPosition())}skipSpace(){e:</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length;){const e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">switch</span><span class="s0">(e){</span><span class="s1">case </span><span class="s2">32</span><span class="s0">:</span><span class="s1">case </span><span class="s2">160</span><span class="s0">:</span><span class="s1">case </span><span class="s2">9</span><span class="s0">:++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s2">13</span><span class="s0">:</span><span class="s2">10</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)&amp;&amp;++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">case </span><span class="s2">10</span><span class="s0">:</span><span class="s1">case </span><span class="s2">8232</span><span class="s0">:</span><span class="s1">case </span><span class="s2">8233</span><span class="s0">:++</span><span class="s1">this</span><span class="s0">.state.pos,++</span><span class="s1">this</span><span class="s0">.state.curLine,</span><span class="s1">this</span><span class="s0">.state.lineStart=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s2">47</span><span class="s0">:</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)){</span><span class="s1">case </span><span class="s2">42</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.skipBlockComment();</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s2">47</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.skipLineComment(</span><span class="s2">2</span><span class="s0">);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">break </span><span class="s0">e}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(!m(e))</span><span class="s1">break </span><span class="s0">e;++</span><span class="s1">this</span><span class="s0">.state.pos}}}finishToken(e,t){</span><span class="s1">this</span><span class="s0">.state.end=</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.state.endLoc=</span><span class="s1">this</span><span class="s0">.state.curPosition();const r=</span><span class="s1">this</span><span class="s0">.state.type;</span><span class="s1">this</span><span class="s0">.state.type=e,</span><span class="s1">this</span><span class="s0">.state.value=t,</span><span class="s1">this</span><span class="s0">.isLookahead||</span><span class="s1">this</span><span class="s0">.updateContext(r)}readToken_numberSign(){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.pos&amp;&amp;</span><span class="s1">this</span><span class="s0">.readToken_interpreter())</span><span class="s1">return</span><span class="s0">;const e=</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">,t=</span><span class="s1">this</span><span class="s0">.codePointAtPos(e);</span><span class="s1">if</span><span class="s0">(t&gt;=</span><span class="s2">48</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s2">57</span><span class="s0">)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.UnexpectedDigitAfterHash);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">123</span><span class="s0">===t||</span><span class="s2">91</span><span class="s0">===t&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">),</span><span class="s3">&quot;hash&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s3">&quot;syntaxType&quot;</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s2">123</span><span class="s0">===t?E.RecordExpressionHashIncorrectStartSyntaxType:E.TupleExpressionHashIncorrectStartSyntaxType);</span><span class="s2">123</span><span class="s0">===t?</span><span class="s1">this</span><span class="s0">.finishToken(c.braceHashL):</span><span class="s1">this</span><span class="s0">.finishToken(c.bracketHashL),</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">}</span><span class="s1">else </span><span class="s0">M(t)?(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.privateName,</span><span class="s1">this</span><span class="s0">.readWord1(t))):</span><span class="s2">92</span><span class="s0">===t?(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.privateName,</span><span class="s1">this</span><span class="s0">.readWord1())):</span><span class="s1">this</span><span class="s0">.finishOp(c.hash,</span><span class="s2">1</span><span class="s0">)}readToken_dot(){const e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);e&gt;=</span><span class="s2">48</span><span class="s0">&amp;&amp;e&lt;=</span><span class="s2">57</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.readNumber(!</span><span class="s2">0</span><span class="s0">):</span><span class="s2">46</span><span class="s0">===e&amp;&amp;</span><span class="s2">46</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">)?(</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">3</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishToken(c.ellipsis)):(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.dot))}readToken_slash(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.exprAllowed&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.inType)</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.readRegexp();</span><span class="s2">61</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.finishOp(c.assign,</span><span class="s2">2</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(c.slash,</span><span class="s2">1</span><span class="s0">)}readToken_interpreter(){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">0</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.state.pos||</span><span class="s1">this</span><span class="s0">.length&lt;</span><span class="s2">2</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;let e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">33</span><span class="s0">!==e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">1</span><span class="s0">;!h(e)&amp;&amp;++</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length;)e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);const r=</span><span class="s1">this</span><span class="s0">.input.slice(t+</span><span class="s2">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">return this</span><span class="s0">.finishToken(c.interpreterDirective,r),!</span><span class="s2">0</span><span class="s0">}readToken_mult_modulo(e){let t=</span><span class="s2">42</span><span class="s0">===e?c.star:c.modulo,r=</span><span class="s2">1</span><span class="s0">,n=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);const i=</span><span class="s1">this</span><span class="s0">.state.exprAllowed;</span><span class="s2">42</span><span class="s0">===e&amp;&amp;</span><span class="s2">42</span><span class="s0">===n&amp;&amp;(r++,n=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">),t=c.exponent),</span><span class="s2">61</span><span class="s0">!==n||i||(r++,t=c.assign),</span><span class="s1">this</span><span class="s0">.finishOp(t,r)}readToken_pipe_amp(e){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(t!==e){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">124</span><span class="s0">===e){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">62</span><span class="s0">===t)</span><span class="s1">return void this</span><span class="s0">.finishOp(c.pipeline,</span><span class="s2">2</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">125</span><span class="s0">===t){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;bar&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s3">&quot;syntaxType&quot;</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.RecordExpressionBarIncorrectEndSyntaxType);</span><span class="s1">return void this</span><span class="s0">.finishOp(c.braceBarR,</span><span class="s2">2</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">93</span><span class="s0">===t){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;bar&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s3">&quot;syntaxType&quot;</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.TupleExpressionBarIncorrectEndSyntaxType);</span><span class="s1">return void this</span><span class="s0">.finishOp(c.bracketBarR,</span><span class="s2">2</span><span class="s0">)}}</span><span class="s2">61</span><span class="s0">!==t?</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s2">124</span><span class="s0">===e?c.bitwiseOR:c.bitwiseAND,</span><span class="s2">1</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(c.assign,</span><span class="s2">2</span><span class="s0">)}</span><span class="s1">else </span><span class="s2">61</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.finishOp(c.assign,</span><span class="s2">3</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s2">124</span><span class="s0">===e?c.logicalOR:c.logicalAND,</span><span class="s2">2</span><span class="s0">)}readToken_caret(){</span><span class="s2">61</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.finishOp(c.assign,</span><span class="s2">2</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(c.bitwiseXOR,</span><span class="s2">1</span><span class="s0">)}readToken_plus_min(e){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(t===e)</span><span class="s1">return </span><span class="s2">45</span><span class="s0">!==t||</span><span class="s1">this</span><span class="s0">.inModule||</span><span class="s2">62</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">)||</span><span class="s2">0</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.state.lastTokEnd&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()?</span><span class="s1">void this</span><span class="s0">.finishOp(c.incDec,</span><span class="s2">2</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.skipLineComment(</span><span class="s2">3</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.skipSpace(),</span><span class="s1">void this</span><span class="s0">.nextToken());</span><span class="s2">61</span><span class="s0">===t?</span><span class="s1">this</span><span class="s0">.finishOp(c.assign,</span><span class="s2">2</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(c.plusMin,</span><span class="s2">1</span><span class="s0">)}readToken_lt_gt(e){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);let r=</span><span class="s2">1</span><span class="s0">;</span><span class="s1">return </span><span class="s0">t===e?(r=</span><span class="s2">62</span><span class="s0">===e&amp;&amp;</span><span class="s2">62</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">)?</span><span class="s2">3</span><span class="s0">:</span><span class="s2">2</span><span class="s0">,</span><span class="s2">61</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+r)?</span><span class="s1">void this</span><span class="s0">.finishOp(c.assign,r+</span><span class="s2">1</span><span class="s0">):</span><span class="s1">void this</span><span class="s0">.finishOp(c.bitShift,r)):</span><span class="s2">33</span><span class="s0">!==t||</span><span class="s2">60</span><span class="s0">!==e||</span><span class="s1">this</span><span class="s0">.inModule||</span><span class="s2">45</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">)||</span><span class="s2">45</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">3</span><span class="s0">)?(</span><span class="s2">61</span><span class="s0">===t&amp;&amp;(r=</span><span class="s2">2</span><span class="s0">),</span><span class="s1">void this</span><span class="s0">.finishOp(c.relational,r)):(</span><span class="s1">this</span><span class="s0">.skipLineComment(</span><span class="s2">4</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.skipSpace(),</span><span class="s1">void this</span><span class="s0">.nextToken())}readToken_eq_excl(e){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">61</span><span class="s0">!==t)</span><span class="s1">return </span><span class="s2">61</span><span class="s0">===e&amp;&amp;</span><span class="s2">62</span><span class="s0">===t?(</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">,</span><span class="s1">void this</span><span class="s0">.finishToken(c.arrow)):</span><span class="s1">void this</span><span class="s0">.finishOp(</span><span class="s2">61</span><span class="s0">===e?c.eq:c.bang,</span><span class="s2">1</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.finishOp(c.equality,</span><span class="s2">61</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">)?</span><span class="s2">3</span><span class="s0">:</span><span class="s2">2</span><span class="s0">)}readToken_question(){const e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">),t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">);</span><span class="s2">63</span><span class="s0">===e?</span><span class="s2">61</span><span class="s0">===t?</span><span class="s1">this</span><span class="s0">.finishOp(c.assign,</span><span class="s2">3</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(c.nullishCoalescing,</span><span class="s2">2</span><span class="s0">):</span><span class="s2">46</span><span class="s0">!==e||t&gt;=</span><span class="s2">48</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s2">57</span><span class="s0">?(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.question)):(</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishToken(c.questionDot))}getTokenFromCode(e){</span><span class="s1">switch</span><span class="s0">(e){</span><span class="s1">case </span><span class="s2">46</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_dot();</span><span class="s1">case </span><span class="s2">40</span><span class="s0">:</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.parenL);</span><span class="s1">case </span><span class="s2">41</span><span class="s0">:</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.parenR);</span><span class="s1">case </span><span class="s2">59</span><span class="s0">:</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.semi);</span><span class="s1">case </span><span class="s2">44</span><span class="s0">:</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.comma);</span><span class="s1">case </span><span class="s2">91</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">124</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;bar&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s3">&quot;syntaxType&quot;</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.TupleExpressionBarIncorrectStartSyntaxType);</span><span class="s1">this</span><span class="s0">.finishToken(c.bracketBarL),</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">}</span><span class="s1">else</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.bracketL);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s2">93</span><span class="s0">:</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.bracketR);</span><span class="s1">case </span><span class="s2">123</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">124</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;bar&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s3">&quot;syntaxType&quot;</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.RecordExpressionBarIncorrectStartSyntaxType);</span><span class="s1">this</span><span class="s0">.finishToken(c.braceBarL),</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">}</span><span class="s1">else</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.braceL);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s2">125</span><span class="s0">:</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.braceR);</span><span class="s1">case </span><span class="s2">58</span><span class="s0">:</span><span class="s1">return void</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;functionBind&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">58</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.finishOp(c.doubleColon,</span><span class="s2">2</span><span class="s0">):(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.colon)));</span><span class="s1">case </span><span class="s2">63</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_question();</span><span class="s1">case </span><span class="s2">96</span><span class="s0">:</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.backQuote);</span><span class="s1">case </span><span class="s2">48</span><span class="s0">:{const e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">120</span><span class="s0">===e||</span><span class="s2">88</span><span class="s0">===e)</span><span class="s1">return void this</span><span class="s0">.readRadixNumber(</span><span class="s2">16</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">111</span><span class="s0">===e||</span><span class="s2">79</span><span class="s0">===e)</span><span class="s1">return void this</span><span class="s0">.readRadixNumber(</span><span class="s2">8</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">98</span><span class="s0">===e||</span><span class="s2">66</span><span class="s0">===e)</span><span class="s1">return void this</span><span class="s0">.readRadixNumber(</span><span class="s2">2</span><span class="s0">)}</span><span class="s1">case </span><span class="s2">49</span><span class="s0">:</span><span class="s1">case </span><span class="s2">50</span><span class="s0">:</span><span class="s1">case </span><span class="s2">51</span><span class="s0">:</span><span class="s1">case </span><span class="s2">52</span><span class="s0">:</span><span class="s1">case </span><span class="s2">53</span><span class="s0">:</span><span class="s1">case </span><span class="s2">54</span><span class="s0">:</span><span class="s1">case </span><span class="s2">55</span><span class="s0">:</span><span class="s1">case </span><span class="s2">56</span><span class="s0">:</span><span class="s1">case </span><span class="s2">57</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readNumber(!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">case </span><span class="s2">34</span><span class="s0">:</span><span class="s1">case </span><span class="s2">39</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readString(e);</span><span class="s1">case </span><span class="s2">47</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_slash();</span><span class="s1">case </span><span class="s2">37</span><span class="s0">:</span><span class="s1">case </span><span class="s2">42</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_mult_modulo(e);</span><span class="s1">case </span><span class="s2">124</span><span class="s0">:</span><span class="s1">case </span><span class="s2">38</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_pipe_amp(e);</span><span class="s1">case </span><span class="s2">94</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_caret();</span><span class="s1">case </span><span class="s2">43</span><span class="s0">:</span><span class="s1">case </span><span class="s2">45</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_plus_min(e);</span><span class="s1">case </span><span class="s2">60</span><span class="s0">:</span><span class="s1">case </span><span class="s2">62</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_lt_gt(e);</span><span class="s1">case </span><span class="s2">61</span><span class="s0">:</span><span class="s1">case </span><span class="s2">33</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_eq_excl(e);</span><span class="s1">case </span><span class="s2">126</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.finishOp(c.tilde,</span><span class="s2">1</span><span class="s0">);</span><span class="s1">case </span><span class="s2">64</span><span class="s0">:</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.at);</span><span class="s1">case </span><span class="s2">35</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_numberSign();</span><span class="s1">case </span><span class="s2">92</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readWord();</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(M(e))</span><span class="s1">return void this</span><span class="s0">.readWord(e)}</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.InvalidOrUnexpectedToken,String.fromCodePoint(e))}finishOp(e,t){const r=</span><span class="s1">this</span><span class="s0">.input.slice(</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.state.pos+t);</span><span class="s1">this</span><span class="s0">.state.pos+=t,</span><span class="s1">this</span><span class="s0">.finishToken(e,r)}readRegexp(){const e=</span><span class="s1">this</span><span class="s0">.state.pos;let t,r;</span><span class="s1">for</span><span class="s0">(;;){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos&gt;=</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">throw this</span><span class="s0">.raise(e,E.UnterminatedRegExp);const n=</span><span class="s1">this</span><span class="s0">.input.charAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(u.test(n))</span><span class="s1">throw this</span><span class="s0">.raise(e,E.UnterminatedRegExp);</span><span class="s1">if</span><span class="s0">(t)t=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;[&quot;</span><span class="s0">===n)r=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;]&quot;</span><span class="s0">===n&amp;&amp;r)r=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;/&quot;</span><span class="s0">===n&amp;&amp;!r)</span><span class="s1">break</span><span class="s0">;t=</span><span class="s3">&quot;</span><span class="s4">\\</span><span class="s3">&quot;</span><span class="s0">===n}++</span><span class="s1">this</span><span class="s0">.state.pos}const n=</span><span class="s1">this</span><span class="s0">.input.slice(e,</span><span class="s1">this</span><span class="s0">.state.pos);++</span><span class="s1">this</span><span class="s0">.state.pos;let i=</span><span class="s3">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length;){const e=</span><span class="s1">this</span><span class="s0">.input[</span><span class="s1">this</span><span class="s0">.state.pos],t=</span><span class="s1">this</span><span class="s0">.codePointAtPos(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(we.has(e))i.indexOf(e)&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">,E.DuplicateRegExpFlags);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!j(t)&amp;&amp;</span><span class="s2">92</span><span class="s0">!==t)</span><span class="s1">break</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">,E.MalformedRegExpFlags)}++</span><span class="s1">this</span><span class="s0">.state.pos,i+=e}</span><span class="s1">this</span><span class="s0">.finishToken(c.regexp,{pattern:n,flags:i})}readInt(e,t,r,n=!</span><span class="s2">0</span><span class="s0">){const i=</span><span class="s1">this</span><span class="s0">.state.pos,s=</span><span class="s2">16</span><span class="s0">===e?Oe.hex:Oe.decBinOct,a=</span><span class="s2">16</span><span class="s0">===e?Ie.hex:</span><span class="s2">10</span><span class="s0">===e?Ie.dec:</span><span class="s2">8</span><span class="s0">===e?Ie.oct:Ie.bin;let o=!</span><span class="s2">1</span><span class="s0">,l=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let i=</span><span class="s2">0</span><span class="s0">,p=</span><span class="s1">null</span><span class="s0">==t?</span><span class="s2">1</span><span class="s0">/</span><span class="s2">0</span><span class="s0">:t;i&lt;p;++i){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);let p;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">95</span><span class="s0">!==t){</span><span class="s1">if</span><span class="s0">(p=t&gt;=</span><span class="s2">97</span><span class="s0">?t-97+</span><span class="s2">10</span><span class="s0">:t&gt;=</span><span class="s2">65</span><span class="s0">?t-65+</span><span class="s2">10</span><span class="s0">:Ae(t)?t-48:</span><span class="s2">1</span><span class="s0">/</span><span class="s2">0</span><span class="s0">,p&gt;=e)</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.options.errorRecovery&amp;&amp;p&lt;=</span><span class="s2">9</span><span class="s0">)p=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start+i+</span><span class="s2">2</span><span class="s0">,E.InvalidDigit,e);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!r)</span><span class="s1">break</span><span class="s0">;p=</span><span class="s2">0</span><span class="s0">,o=!</span><span class="s2">0</span><span class="s0">}++</span><span class="s1">this</span><span class="s0">.state.pos,l=l*e+p}</span><span class="s1">else</span><span class="s0">{const e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos-1),t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);(-</span><span class="s2">1</span><span class="s0">===a.indexOf(t)||s.indexOf(e)&gt;-</span><span class="s2">1</span><span class="s0">||s.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">||Number.isNaN(t))&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.UnexpectedNumericSeparator),n||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.NumericSeparatorInEscapeSequence),++</span><span class="s1">this</span><span class="s0">.state.pos}}</span><span class="s1">return this</span><span class="s0">.state.pos===i||</span><span class="s1">null</span><span class="s0">!=t&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.pos-i!==t||o?</span><span class="s1">null</span><span class="s0">:l}readRadixNumber(e){const t=</span><span class="s1">this</span><span class="s0">.state.pos;let r=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">;const n=</span><span class="s1">this</span><span class="s0">.readInt(e);</span><span class="s1">null</span><span class="s0">==n&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start+</span><span class="s2">2</span><span class="s0">,E.InvalidDigit,e);const i=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">110</span><span class="s0">===i)++</span><span class="s1">this</span><span class="s0">.state.pos,r=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s2">109</span><span class="s0">===i)</span><span class="s1">throw this</span><span class="s0">.raise(t,E.InvalidDecimal);</span><span class="s1">if</span><span class="s0">(M(</span><span class="s1">this</span><span class="s0">.codePointAtPos(</span><span class="s1">this</span><span class="s0">.state.pos)))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.NumberIdentifier);</span><span class="s1">if</span><span class="s0">(r){const e=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos).replace(/[_n]/g,</span><span class="s3">&quot;&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.finishToken(c.bigint,e)}</span><span class="s1">else this</span><span class="s0">.finishToken(c.num,n)}readNumber(e){const t=</span><span class="s1">this</span><span class="s0">.state.pos;let r=!</span><span class="s2">1</span><span class="s0">,n=!</span><span class="s2">1</span><span class="s0">,i=!</span><span class="s2">1</span><span class="s0">,s=!</span><span class="s2">1</span><span class="s0">,a=!</span><span class="s2">1</span><span class="s0">;e||</span><span class="s1">null</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.readInt(</span><span class="s2">10</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.raise(t,E.InvalidNumber);const o=</span><span class="s1">this</span><span class="s0">.state.pos-t&gt;=</span><span class="s2">2</span><span class="s0">&amp;&amp;</span><span class="s2">48</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(t);</span><span class="s1">if</span><span class="s0">(o){const e=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.recordStrictModeErrors(t,E.StrictOctalLiteral),!</span><span class="s1">this</span><span class="s0">.state.strict){const r=e.indexOf(</span><span class="s3">&quot;_&quot;</span><span class="s0">);r&gt;</span><span class="s2">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r+t,E.ZeroDigitNumericSeparator)}a=o&amp;&amp;!/[</span><span class="s2">89</span><span class="s0">]/.test(e)}let l=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">46</span><span class="s0">!==l||a||(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.readInt(</span><span class="s2">10</span><span class="s0">),r=!</span><span class="s2">0</span><span class="s0">,l=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)),</span><span class="s2">69</span><span class="s0">!==l&amp;&amp;</span><span class="s2">101</span><span class="s0">!==l||a||(l=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(++</span><span class="s1">this</span><span class="s0">.state.pos),</span><span class="s2">43</span><span class="s0">!==l&amp;&amp;</span><span class="s2">45</span><span class="s0">!==l||++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">null</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.readInt(</span><span class="s2">10</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,E.InvalidOrMissingExponent),r=!</span><span class="s2">0</span><span class="s0">,s=!</span><span class="s2">0</span><span class="s0">,l=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)),</span><span class="s2">110</span><span class="s0">===l&amp;&amp;((r||o)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,E.InvalidBigIntLiteral),++</span><span class="s1">this</span><span class="s0">.state.pos,n=!</span><span class="s2">0</span><span class="s0">),</span><span class="s2">109</span><span class="s0">===l&amp;&amp;(</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;decimal&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos),(s||o)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,E.InvalidDecimal),++</span><span class="s1">this</span><span class="s0">.state.pos,i=!</span><span class="s2">0</span><span class="s0">),M(</span><span class="s1">this</span><span class="s0">.codePointAtPos(</span><span class="s1">this</span><span class="s0">.state.pos)))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.NumberIdentifier);const p=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos).replace(/[_mn]/g,</span><span class="s3">&quot;&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(n)</span><span class="s1">return void this</span><span class="s0">.finishToken(c.bigint,p);</span><span class="s1">if</span><span class="s0">(i)</span><span class="s1">return void this</span><span class="s0">.finishToken(c.decimal,p);const u=a?parseInt(p,</span><span class="s2">8</span><span class="s0">):parseFloat(p);</span><span class="s1">this</span><span class="s0">.finishToken(c.num,u)}readCodePoint(e){let t;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">123</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)){const r=++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">if</span><span class="s0">(t=</span><span class="s1">this</span><span class="s0">.readHexChar(</span><span class="s1">this</span><span class="s0">.input.indexOf(</span><span class="s3">&quot;}&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos)-</span><span class="s1">this</span><span class="s0">.state.pos,!</span><span class="s2">0</span><span class="s0">,e),++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">null</span><span class="s0">!==t&amp;&amp;t&gt;</span><span class="s2">1114111</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.raise(r,E.InvalidCodePoint)}}</span><span class="s1">else </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.readHexChar(</span><span class="s2">4</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,e);</span><span class="s1">return </span><span class="s0">t}readString(e){let t=</span><span class="s3">&quot;&quot;</span><span class="s0">,r=++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">for</span><span class="s0">(;;){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos&gt;=</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.UnterminatedString);const n=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(n===e)</span><span class="s1">break</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">92</span><span class="s0">===n)t+=</span><span class="s1">this</span><span class="s0">.input.slice(r,</span><span class="s1">this</span><span class="s0">.state.pos),t+=</span><span class="s1">this</span><span class="s0">.readEscapedChar(!</span><span class="s2">1</span><span class="s0">),r=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">else if</span><span class="s0">(</span><span class="s2">8232</span><span class="s0">===n||</span><span class="s2">8233</span><span class="s0">===n)++</span><span class="s1">this</span><span class="s0">.state.pos,++</span><span class="s1">this</span><span class="s0">.state.curLine,</span><span class="s1">this</span><span class="s0">.state.lineStart=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(h(n))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.UnterminatedString);++</span><span class="s1">this</span><span class="s0">.state.pos}}t+=</span><span class="s1">this</span><span class="s0">.input.slice(r,</span><span class="s1">this</span><span class="s0">.state.pos++),</span><span class="s1">this</span><span class="s0">.finishToken(c.string,t)}readTmplToken(){let e=</span><span class="s3">&quot;&quot;</span><span class="s0">,t=</span><span class="s1">this</span><span class="s0">.state.pos,r=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;;){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos&gt;=</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.UnterminatedTemplate);const n=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">96</span><span class="s0">===n||</span><span class="s2">36</span><span class="s0">===n&amp;&amp;</span><span class="s2">123</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.state.pos===</span><span class="s1">this</span><span class="s0">.state.start&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.template)?</span><span class="s2">36</span><span class="s0">===n?(</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">,</span><span class="s1">void this</span><span class="s0">.finishToken(c.dollarBraceL)):(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.backQuote)):(e+=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos),</span><span class="s1">void this</span><span class="s0">.finishToken(c.template,r?</span><span class="s1">null</span><span class="s0">:e));</span><span class="s1">if</span><span class="s0">(</span><span class="s2">92</span><span class="s0">===n){e+=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos);const n=</span><span class="s1">this</span><span class="s0">.readEscapedChar(!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">null</span><span class="s0">===n?r=!</span><span class="s2">0</span><span class="s0">:e+=n,t=</span><span class="s1">this</span><span class="s0">.state.pos}</span><span class="s1">else if</span><span class="s0">(h(n)){</span><span class="s1">switch</span><span class="s0">(e+=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos),++</span><span class="s1">this</span><span class="s0">.state.pos,n){</span><span class="s1">case </span><span class="s2">13</span><span class="s0">:</span><span class="s2">10</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)&amp;&amp;++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">case </span><span class="s2">10</span><span class="s0">:e+=</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:e+=String.fromCharCode(n)}++</span><span class="s1">this</span><span class="s0">.state.curLine,</span><span class="s1">this</span><span class="s0">.state.lineStart=</span><span class="s1">this</span><span class="s0">.state.pos,t=</span><span class="s1">this</span><span class="s0">.state.pos}</span><span class="s1">else</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos}}recordStrictModeErrors(e,t){</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.strictErrors.has(e)?</span><span class="s1">this</span><span class="s0">.raise(e,t):</span><span class="s1">this</span><span class="s0">.state.strictErrors.set(e,t)}readEscapedChar(e){const t=!e,r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(++</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">switch</span><span class="s0">(++</span><span class="s1">this</span><span class="s0">.state.pos,r){</span><span class="s1">case </span><span class="s2">110</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">;</span><span class="s1">case </span><span class="s2">114</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;</span><span class="s4">\r</span><span class="s3">&quot;</span><span class="s0">;</span><span class="s1">case </span><span class="s2">120</span><span class="s0">:{const e=</span><span class="s1">this</span><span class="s0">.readHexChar(</span><span class="s2">2</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,t);</span><span class="s1">return null</span><span class="s0">===e?</span><span class="s1">null</span><span class="s0">:String.fromCharCode(e)}</span><span class="s1">case </span><span class="s2">117</span><span class="s0">:{const e=</span><span class="s1">this</span><span class="s0">.readCodePoint(t);</span><span class="s1">return null</span><span class="s0">===e?</span><span class="s1">null</span><span class="s0">:String.fromCodePoint(e)}</span><span class="s1">case </span><span class="s2">116</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;</span><span class="s4">\t</span><span class="s3">&quot;</span><span class="s0">;</span><span class="s1">case </span><span class="s2">98</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;</span><span class="s4">\b</span><span class="s3">&quot;</span><span class="s0">;</span><span class="s1">case </span><span class="s2">118</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;</span><span class="s5">\v</span><span class="s3">&quot;</span><span class="s0">;</span><span class="s1">case </span><span class="s2">102</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;</span><span class="s4">\f</span><span class="s3">&quot;</span><span class="s0">;</span><span class="s1">case </span><span class="s2">13</span><span class="s0">:</span><span class="s2">10</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)&amp;&amp;++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">case </span><span class="s2">10</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.state.lineStart=</span><span class="s1">this</span><span class="s0">.state.pos,++</span><span class="s1">this</span><span class="s0">.state.curLine;</span><span class="s1">case </span><span class="s2">8232</span><span class="s0">:</span><span class="s1">case </span><span class="s2">8233</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;&quot;</span><span class="s0">;</span><span class="s1">case </span><span class="s2">56</span><span class="s0">:</span><span class="s1">case </span><span class="s2">57</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.recordStrictModeErrors(</span><span class="s1">this</span><span class="s0">.state.pos-1,E.StrictNumericEscape);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(r&gt;=</span><span class="s2">48</span><span class="s0">&amp;&amp;r&lt;=</span><span class="s2">55</span><span class="s0">){const t=</span><span class="s1">this</span><span class="s0">.state.pos-1;let r=</span><span class="s1">this</span><span class="s0">.input.substr(</span><span class="s1">this</span><span class="s0">.state.pos-1,</span><span class="s2">3</span><span class="s0">).match(/^[</span><span class="s2">0</span><span class="s0">-</span><span class="s2">7</span><span class="s0">]+/)[</span><span class="s2">0</span><span class="s0">],n=parseInt(r,</span><span class="s2">8</span><span class="s0">);n&gt;</span><span class="s2">255</span><span class="s0">&amp;&amp;(r=r.slice(</span><span class="s2">0</span><span class="s0">,-</span><span class="s2">1</span><span class="s0">),n=parseInt(r,</span><span class="s2">8</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.state.pos+=r.length-1;const i=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;0&quot;</span><span class="s0">!==r||</span><span class="s2">56</span><span class="s0">===i||</span><span class="s2">57</span><span class="s0">===i){</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.recordStrictModeErrors(t,E.StrictNumericEscape)}</span><span class="s1">return </span><span class="s0">String.fromCharCode(n)}</span><span class="s1">return </span><span class="s0">String.fromCharCode(r)}}readHexChar(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.state.pos,i=</span><span class="s1">this</span><span class="s0">.readInt(</span><span class="s2">16</span><span class="s0">,e,t,!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">return null</span><span class="s0">===i&amp;&amp;(r?</span><span class="s1">this</span><span class="s0">.raise(n,E.InvalidEscapeSequence):</span><span class="s1">this</span><span class="s0">.state.pos=n-1),i}readWord1(e){</span><span class="s1">this</span><span class="s0">.state.containsEsc=!</span><span class="s2">1</span><span class="s0">;let t=</span><span class="s3">&quot;&quot;</span><span class="s0">;const r=</span><span class="s1">this</span><span class="s0">.state.pos;let n=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">!==e&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.pos+=e&lt;=</span><span class="s2">65535</span><span class="s0">?</span><span class="s2">1</span><span class="s0">:</span><span class="s2">2</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length;){const e=</span><span class="s1">this</span><span class="s0">.codePointAtPos(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(j(e))</span><span class="s1">this</span><span class="s0">.state.pos+=e&lt;=</span><span class="s2">65535</span><span class="s0">?</span><span class="s2">1</span><span class="s0">:</span><span class="s2">2</span><span class="s0">;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s2">92</span><span class="s0">!==e)</span><span class="s1">break</span><span class="s0">;{</span><span class="s1">this</span><span class="s0">.state.containsEsc=!</span><span class="s2">0</span><span class="s0">,t+=</span><span class="s1">this</span><span class="s0">.input.slice(n,</span><span class="s1">this</span><span class="s0">.state.pos);const e=</span><span class="s1">this</span><span class="s0">.state.pos,i=</span><span class="s1">this</span><span class="s0">.state.pos===r?M:j;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">117</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.input.charCodeAt(++</span><span class="s1">this</span><span class="s0">.state.pos)){</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.MissingUnicodeEscape),n=</span><span class="s1">this</span><span class="s0">.state.pos-1;</span><span class="s1">continue</span><span class="s0">}++</span><span class="s1">this</span><span class="s0">.state.pos;const s=</span><span class="s1">this</span><span class="s0">.readCodePoint(!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">null</span><span class="s0">!==s&amp;&amp;(i(s)||</span><span class="s1">this</span><span class="s0">.raise(e,E.EscapedCharNotAnIdentifier),t+=String.fromCodePoint(s)),n=</span><span class="s1">this</span><span class="s0">.state.pos}}}</span><span class="s1">return </span><span class="s0">t+</span><span class="s1">this</span><span class="s0">.input.slice(n,</span><span class="s1">this</span><span class="s0">.state.pos)}readWord(e){const t=</span><span class="s1">this</span><span class="s0">.readWord1(e),r=o.get(t)||c.name;</span><span class="s1">this</span><span class="s0">.finishToken(r,t)}checkKeywordEscapes(){const e=</span><span class="s1">this</span><span class="s0">.state.type.keyword;e&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.containsEsc&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.InvalidEscapedReservedWord,e)}braceIsBlock(e){const t=</span><span class="s1">this</span><span class="s0">.curContext();</span><span class="s1">return </span><span class="s0">t===O.functionExpression||t===O.functionStatement||(e!==c.colon||t!==O.braceStatement&amp;&amp;t!==O.braceExpression?e===c._return||e===c.name&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.exprAllowed?</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak():e===c._else||e===c.semi||e===c.eof||e===c.parenR||e===c.arrow||(e===c.braceL?t===O.braceStatement:e!==c._var&amp;&amp;e!==c._const&amp;&amp;e!==c.name&amp;&amp;(e===c.relational||!</span><span class="s1">this</span><span class="s0">.state.exprAllowed)):!t.isExpr)}updateContext(e){const t=</span><span class="s1">this</span><span class="s0">.state.type;let r;!t.keyword||e!==c.dot&amp;&amp;e!==c.questionDot?(r=t.updateContext)?r.call(</span><span class="s1">this</span><span class="s0">,e):</span><span class="s1">this</span><span class="s0">.state.exprAllowed=t.beforeExpr:</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">}}class ke{constructor(){</span><span class="s1">this</span><span class="s0">.privateNames=</span><span class="s1">new </span><span class="s0">Set,</span><span class="s1">this</span><span class="s0">.loneAccessors=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.undefinedPrivateNames=</span><span class="s1">new </span><span class="s0">Map}}class De{constructor(e){</span><span class="s1">this</span><span class="s0">.stack=[],</span><span class="s1">this</span><span class="s0">.undefinedPrivateNames=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.raise=e}current(){</span><span class="s1">return this</span><span class="s0">.stack[</span><span class="s1">this</span><span class="s0">.stack.length-1]}enter(){</span><span class="s1">this</span><span class="s0">.stack.push(</span><span class="s1">new </span><span class="s0">ke)}exit(){const e=</span><span class="s1">this</span><span class="s0">.stack.pop(),t=</span><span class="s1">this</span><span class="s0">.current();</span><span class="s1">for</span><span class="s0">(const[r,n]of Array.from(e.undefinedPrivateNames))t?t.undefinedPrivateNames.has(r)||t.undefinedPrivateNames.set(r,n):</span><span class="s1">this</span><span class="s0">.raise(n,E.InvalidPrivateFieldResolution,r)}declarePrivateName(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.current();let i=n.privateNames.has(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">3</span><span class="s0">&amp;t){const r=i&amp;&amp;n.loneAccessors.get(e);r?(i=(</span><span class="s2">3</span><span class="s0">&amp;r)==(</span><span class="s2">3</span><span class="s0">&amp;t)||(</span><span class="s2">4</span><span class="s0">&amp;r)!=(</span><span class="s2">4</span><span class="s0">&amp;t),i||n.loneAccessors.</span><span class="s1">delete</span><span class="s0">(e)):i||n.loneAccessors.set(e,t)}i&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r,E.PrivateNameRedeclaration,e),n.privateNames.add(e),n.undefinedPrivateNames.</span><span class="s1">delete</span><span class="s0">(e)}usePrivateName(e,t){let r;</span><span class="s1">for</span><span class="s0">(r of </span><span class="s1">this</span><span class="s0">.stack)</span><span class="s1">if</span><span class="s0">(r.privateNames.has(e))</span><span class="s1">return</span><span class="s0">;r?r.undefinedPrivateNames.set(e,t):</span><span class="s1">this</span><span class="s0">.raise(t,E.InvalidPrivateFieldResolution,e)}}class _e{constructor(e=</span><span class="s2">0</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.type=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.type=e}canBeArrowParameterDeclaration(){</span><span class="s1">return </span><span class="s2">2</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.type||</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.type}isCertainlyParameterDeclaration(){</span><span class="s1">return </span><span class="s2">3</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.type}}class Le extends _e{constructor(e){super(e),</span><span class="s1">this</span><span class="s0">.errors=</span><span class="s1">new </span><span class="s0">Map}recordDeclarationError(e,t){</span><span class="s1">this</span><span class="s0">.errors.set(e,t)}clearDeclarationError(e){</span><span class="s1">this</span><span class="s0">.errors.</span><span class="s1">delete</span><span class="s0">(e)}iterateErrors(e){</span><span class="s1">this</span><span class="s0">.errors.forEach(e)}}class Me{constructor(e){</span><span class="s1">this</span><span class="s0">.stack=[</span><span class="s1">new </span><span class="s0">_e],</span><span class="s1">this</span><span class="s0">.raise=e}enter(e){</span><span class="s1">this</span><span class="s0">.stack.push(e)}exit(){</span><span class="s1">this</span><span class="s0">.stack.pop()}recordParameterInitializerError(e,t){const{stack:r}=</span><span class="s1">this</span><span class="s0">;let n=r.length-1,i=r[n];</span><span class="s1">for</span><span class="s0">(;!i.isCertainlyParameterDeclaration();){</span><span class="s1">if</span><span class="s0">(!i.canBeArrowParameterDeclaration())</span><span class="s1">return</span><span class="s0">;i.recordDeclarationError(e,t),i=r[--n]}</span><span class="s1">this</span><span class="s0">.raise(e,t)}recordParenthesizedIdentifierError(e,t){const{stack:r}=</span><span class="s1">this</span><span class="s0">,n=r[r.length-1];</span><span class="s1">if</span><span class="s0">(n.isCertainlyParameterDeclaration())</span><span class="s1">this</span><span class="s0">.raise(e,t);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!n.canBeArrowParameterDeclaration())</span><span class="s1">return</span><span class="s0">;n.recordDeclarationError(e,t)}}recordAsyncArrowParametersError(e,t){const{stack:r}=</span><span class="s1">this</span><span class="s0">;let n=r.length-1,i=r[n];</span><span class="s1">for</span><span class="s0">(;i.canBeArrowParameterDeclaration();)</span><span class="s2">2</span><span class="s0">===i.type&amp;&amp;i.recordDeclarationError(e,t),i=r[--n]}validateAsPattern(){const{stack:e}=</span><span class="s1">this</span><span class="s0">,t=e[e.length-1];t.canBeArrowParameterDeclaration()&amp;&amp;t.iterateErrors(((t,r)=&gt;{</span><span class="s1">this</span><span class="s0">.raise(r,t);let n=e.length-2,i=e[n];</span><span class="s1">for</span><span class="s0">(;i.canBeArrowParameterDeclaration();)i.clearDeclarationError(r),i=e[--n]}))}}</span><span class="s1">function </span><span class="s0">je(){</span><span class="s1">return new </span><span class="s0">_e}class Fe extends Ce{addExtra(e,t,r){e&amp;&amp;((e.extra=e.extra||{})[t]=r)}isRelational(e){</span><span class="s1">return this</span><span class="s0">.match(c.relational)&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.value===e}expectRelational(e){</span><span class="s1">this</span><span class="s0">.isRelational(e)?</span><span class="s1">this</span><span class="s0">.next():</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,c.relational)}isContextual(e){</span><span class="s1">return this</span><span class="s0">.match(c.name)&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.value===e&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.containsEsc}isUnparsedContextual(e,t){const r=e+t.length;</span><span class="s1">return this</span><span class="s0">.input.slice(e,r)===t&amp;&amp;(r===</span><span class="s1">this</span><span class="s0">.input.length||!j(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(r)))}isLookaheadContextual(e){const t=</span><span class="s1">this</span><span class="s0">.nextTokenStart();</span><span class="s1">return this</span><span class="s0">.isUnparsedContextual(t,e)}eatContextual(e){</span><span class="s1">return this</span><span class="s0">.isContextual(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.name)}expectContextual(e,t){</span><span class="s1">this</span><span class="s0">.eatContextual(e)||</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,t)}canInsertSemicolon(){</span><span class="s1">return this</span><span class="s0">.match(c.eof)||</span><span class="s1">this</span><span class="s0">.match(c.braceR)||</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()}hasPrecedingLineBreak(){</span><span class="s1">return </span><span class="s0">u.test(</span><span class="s1">this</span><span class="s0">.input.slice(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,</span><span class="s1">this</span><span class="s0">.state.start))}hasFollowingLineBreak(){</span><span class="s1">return </span><span class="s0">u.test(</span><span class="s1">this</span><span class="s0">.input.slice(</span><span class="s1">this</span><span class="s0">.state.end,</span><span class="s1">this</span><span class="s0">.nextTokenStart()))}isLineTerminator(){</span><span class="s1">return this</span><span class="s0">.eat(c.semi)||</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()}semicolon(e=!</span><span class="s2">0</span><span class="s0">){(e?</span><span class="s1">this</span><span class="s0">.isLineTerminator():</span><span class="s1">this</span><span class="s0">.eat(c.semi))||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,E.MissingSemicolon)}expect(e,t){</span><span class="s1">this</span><span class="s0">.eat(e)||</span><span class="s1">this</span><span class="s0">.unexpected(t,e)}assertNoSpace(e=</span><span class="s3">&quot;Unexpected space.&quot;</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.state.start&gt;</span><span class="s1">this</span><span class="s0">.state.lastTokEnd&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,{code:x.SyntaxError,reasonCode:</span><span class="s3">&quot;UnexpectedSpace&quot;</span><span class="s0">,template:e})}unexpected(e,t={code:x.SyntaxError,reasonCode:</span><span class="s3">&quot;UnexpectedToken&quot;</span><span class="s0">,template:</span><span class="s3">&quot;Unexpected token&quot;</span><span class="s0">}){</span><span class="s1">throw </span><span class="s0">t </span><span class="s1">instanceof </span><span class="s0">a&amp;&amp;(t={code:x.SyntaxError,reasonCode:</span><span class="s3">&quot;UnexpectedToken&quot;</span><span class="s0">,template:`Unexpected token, expected </span><span class="s3">&quot;${t.label}&quot;</span><span class="s0">`}),</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">null</span><span class="s0">!=e?e:</span><span class="s1">this</span><span class="s0">.state.start,t)}expectPlugin(e,t){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.hasPlugin(e))</span><span class="s1">throw this</span><span class="s0">.raiseWithData(</span><span class="s1">null</span><span class="s0">!=t?t:</span><span class="s1">this</span><span class="s0">.state.start,{missingPlugin:[e]},`This experimental syntax requires enabling the parser plugin: </span><span class="s3">'${e}'</span><span class="s0">`);</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}expectOnePlugin(e,t){</span><span class="s1">if</span><span class="s0">(!e.some((e=&gt;</span><span class="s1">this</span><span class="s0">.hasPlugin(e))))</span><span class="s1">throw this</span><span class="s0">.raiseWithData(</span><span class="s1">null</span><span class="s0">!=t?t:</span><span class="s1">this</span><span class="s0">.state.start,{missingPlugin:e},`This experimental syntax requires enabling one of the following parser plugin(s): </span><span class="s3">'${e.join(&quot;, &quot;)}'</span><span class="s0">`)}tryParse(e,t=</span><span class="s1">this</span><span class="s0">.state.clone()){const r={node:</span><span class="s1">null</span><span class="s0">};</span><span class="s1">try</span><span class="s0">{const n=e(((e=</span><span class="s1">null</span><span class="s0">)=&gt;{</span><span class="s1">throw </span><span class="s0">r.node=e,r}));</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.errors.length&gt;t.errors.length){const e=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">return this</span><span class="s0">.state=t,</span><span class="s1">this</span><span class="s0">.state.tokensLength=e.tokensLength,{node:n,error:e.errors[t.errors.length],thrown:!</span><span class="s2">1</span><span class="s0">,aborted:!</span><span class="s2">1</span><span class="s0">,failState:e}}</span><span class="s1">return</span><span class="s0">{node:n,error:</span><span class="s1">null</span><span class="s0">,thrown:!</span><span class="s2">1</span><span class="s0">,aborted:!</span><span class="s2">1</span><span class="s0">,failState:</span><span class="s1">null</span><span class="s0">}}</span><span class="s1">catch</span><span class="s0">(e){const n=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state=t,e </span><span class="s1">instanceof </span><span class="s0">SyntaxError)</span><span class="s1">return</span><span class="s0">{node:</span><span class="s1">null</span><span class="s0">,error:e,thrown:!</span><span class="s2">0</span><span class="s0">,aborted:!</span><span class="s2">1</span><span class="s0">,failState:n};</span><span class="s1">if</span><span class="s0">(e===r)</span><span class="s1">return</span><span class="s0">{node:r.node,error:</span><span class="s1">null</span><span class="s0">,thrown:!</span><span class="s2">1</span><span class="s0">,aborted:!</span><span class="s2">0</span><span class="s0">,failState:n};</span><span class="s1">throw </span><span class="s0">e}}checkExpressionErrors(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const{shorthandAssign:r,doubleProto:n}=e;</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return </span><span class="s0">r&gt;=</span><span class="s2">0</span><span class="s0">||n&gt;=</span><span class="s2">0</span><span class="s0">;r&gt;=</span><span class="s2">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(r),n&gt;=</span><span class="s2">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(n,E.DuplicateProto)}isLiteralPropertyName(){</span><span class="s1">return this</span><span class="s0">.match(c.name)||!!</span><span class="s1">this</span><span class="s0">.state.type.keyword||</span><span class="s1">this</span><span class="s0">.match(c.string)||</span><span class="s1">this</span><span class="s0">.match(c.num)||</span><span class="s1">this</span><span class="s0">.match(c.bigint)||</span><span class="s1">this</span><span class="s0">.match(c.decimal)}isPrivateName(e){</span><span class="s1">return</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">===e.type}getPrivateNameSV(e){</span><span class="s1">return </span><span class="s0">e.id.name}hasPropertyAsPrivateName(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">===e.type||</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">===e.type)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isPrivateName(e.property)}isOptionalChain(e){</span><span class="s1">return</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">===e.type||</span><span class="s3">&quot;OptionalCallExpression&quot;</span><span class="s0">===e.type}isObjectProperty(e){</span><span class="s1">return</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">===e.type}isObjectMethod(e){</span><span class="s1">return</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">===e.type}initializeScopes(e=</span><span class="s3">&quot;module&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.options.sourceType){const t=</span><span class="s1">this</span><span class="s0">.state.labels;</span><span class="s1">this</span><span class="s0">.state.labels=[];const r=</span><span class="s1">this</span><span class="s0">.state.exportedIdentifiers;</span><span class="s1">this</span><span class="s0">.state.exportedIdentifiers=[];const n=</span><span class="s1">this</span><span class="s0">.inModule;</span><span class="s1">this</span><span class="s0">.inModule=e;const i=</span><span class="s1">this</span><span class="s0">.scope,s=</span><span class="s1">this</span><span class="s0">.getScopeHandler();</span><span class="s1">this</span><span class="s0">.scope=</span><span class="s1">new </span><span class="s0">s(</span><span class="s1">this</span><span class="s0">.raise.bind(</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.inModule);const a=</span><span class="s1">this</span><span class="s0">.prodParam;</span><span class="s1">this</span><span class="s0">.prodParam=</span><span class="s1">new </span><span class="s0">ce;const o=</span><span class="s1">this</span><span class="s0">.classScope;</span><span class="s1">this</span><span class="s0">.classScope=</span><span class="s1">new </span><span class="s0">De(</span><span class="s1">this</span><span class="s0">.raise.bind(</span><span class="s1">this</span><span class="s0">));const l=</span><span class="s1">this</span><span class="s0">.expressionScope;</span><span class="s1">return this</span><span class="s0">.expressionScope=</span><span class="s1">new </span><span class="s0">Me(</span><span class="s1">this</span><span class="s0">.raise.bind(</span><span class="s1">this</span><span class="s0">)),()=&gt;{</span><span class="s1">this</span><span class="s0">.state.labels=t,</span><span class="s1">this</span><span class="s0">.state.exportedIdentifiers=r,</span><span class="s1">this</span><span class="s0">.inModule=n,</span><span class="s1">this</span><span class="s0">.scope=i,</span><span class="s1">this</span><span class="s0">.prodParam=a,</span><span class="s1">this</span><span class="s0">.classScope=o,</span><span class="s1">this</span><span class="s0">.expressionScope=l}}enterInitialScopes(){let e=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;topLevelAwait&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;(e|=</span><span class="s2">2</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.enter(e)}}class Be{constructor(){</span><span class="s1">this</span><span class="s0">.shorthandAssign=-</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.doubleProto=-</span><span class="s2">1</span><span class="s0">}}class Re{constructor(e,t,r){</span><span class="s1">this</span><span class="s0">.type=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.start=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.end=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.loc=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.range=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.leadingComments=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.trailingComments=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.innerComments=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.extra=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.type=</span><span class="s3">&quot;&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.start=t,</span><span class="s1">this</span><span class="s0">.end=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.loc=</span><span class="s1">new </span><span class="s0">T(r),</span><span class="s1">null</span><span class="s0">!=e&amp;&amp;e.options.ranges&amp;&amp;(</span><span class="s1">this</span><span class="s0">.range=[t,</span><span class="s2">0</span><span class="s0">]),</span><span class="s1">null</span><span class="s0">!=e&amp;&amp;e.filename&amp;&amp;(</span><span class="s1">this</span><span class="s0">.loc.filename=e.filename)}__clone(){const e=</span><span class="s1">new </span><span class="s0">Re,t=Object.keys(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s2">0</span><span class="s0">,n=t.length;r&lt;n;r++){const n=t[r];</span><span class="s3">&quot;leadingComments&quot;</span><span class="s0">!==n&amp;&amp;</span><span class="s3">&quot;trailingComments&quot;</span><span class="s0">!==n&amp;&amp;</span><span class="s3">&quot;innerComments&quot;</span><span class="s0">!==n&amp;&amp;(e[n]=</span><span class="s1">this</span><span class="s0">[n])}</span><span class="s1">return </span><span class="s0">e}}class Ue extends Fe{startNode(){</span><span class="s1">return new </span><span class="s0">Re(</span><span class="s1">this</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.start,</span><span class="s1">this</span><span class="s0">.state.startLoc)}startNodeAt(e,t){</span><span class="s1">return new </span><span class="s0">Re(</span><span class="s1">this</span><span class="s0">,e,t)}startNodeAtNode(e){</span><span class="s1">return this</span><span class="s0">.startNodeAt(e.start,e.loc.start)}finishNode(e,t){</span><span class="s1">return this</span><span class="s0">.finishNodeAt(e,t,</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc)}finishNodeAt(e,t,r,n){</span><span class="s1">return </span><span class="s0">e.type=t,e.end=r,e.loc.end=n,</span><span class="s1">this</span><span class="s0">.options.ranges&amp;&amp;(e.range[</span><span class="s2">1</span><span class="s0">]=r),</span><span class="s1">this</span><span class="s0">.processComment(e),e}resetStartLocation(e,t,r){e.start=t,e.loc.start=r,</span><span class="s1">this</span><span class="s0">.options.ranges&amp;&amp;(e.range[</span><span class="s2">0</span><span class="s0">]=t)}resetEndLocation(e,t=</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,r=</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc){e.end=t,e.loc.end=r,</span><span class="s1">this</span><span class="s0">.options.ranges&amp;&amp;(e.range[</span><span class="s2">1</span><span class="s0">]=t)}resetStartLocationFromNode(e,t){</span><span class="s1">this</span><span class="s0">.resetStartLocation(e,t.start,t.loc.start)}}const Ve=e=&gt;</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">===e.type?Ve(e.expression):e;class Ke extends Ue{toAssignable(e,t=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">var </span><span class="s0">r,n;let i;</span><span class="s1">switch</span><span class="s0">((</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">===e.type||</span><span class="s1">null</span><span class="s0">!=(r=e.extra)&amp;&amp;r.parenthesized)&amp;&amp;(i=Ve(e),t?</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===i.type?</span><span class="s1">this</span><span class="s0">.expressionScope.recordParenthesizedIdentifierError(e.start,E.InvalidParenthesizedAssignment):</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">!==i.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,E.InvalidParenthesizedAssignment):</span><span class="s1">this</span><span class="s0">.raise(e.start,E.InvalidParenthesizedAssignment)),e.type){</span><span class="s1">case</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">:</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s0">:e.type=</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s2">0</span><span class="s0">,n=e.properties.length,i=n-1;r&lt;n;r++){</span><span class="s1">var </span><span class="s0">s;const n=e.properties[r],a=r===i;</span><span class="s1">this</span><span class="s0">.toAssignableObjectExpressionProp(n,a,t),a&amp;&amp;</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">===n.type&amp;&amp;</span><span class="s1">null</span><span class="s0">!=(s=e.extra)&amp;&amp;s.trailingComma&amp;&amp;</span><span class="s1">this</span><span class="s0">.raiseRestNotLast(e.extra.trailingComma)}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.toAssignable(e.value,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">:{</span><span class="s1">this</span><span class="s0">.checkToRestConversion(e),e.type=</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">;const r=e.argument;</span><span class="s1">this</span><span class="s0">.toAssignable(r,t);</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case</span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s0">:e.type=</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.toAssignableList(e.elements,</span><span class="s1">null</span><span class="s0">==(n=e.extra)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:n.trailingComma,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s0">:</span><span class="s3">&quot;=&quot;</span><span class="s0">!==e.operator&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.left.end,E.MissingEqInAssignment),e.type=</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">,</span><span class="s1">delete </span><span class="s0">e.operator,</span><span class="s1">this</span><span class="s0">.toAssignable(e.left,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.toAssignable(i,t)}</span><span class="s1">return </span><span class="s0">e}toAssignableObjectExpressionProp(e,t,r){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">===e.type){const t=</span><span class="s3">&quot;get&quot;</span><span class="s0">===e.kind||</span><span class="s3">&quot;set&quot;</span><span class="s0">===e.kind?E.PatternHasAccessor:E.PatternHasMethod;</span><span class="s1">this</span><span class="s0">.raise(e.key.start,t)}</span><span class="s1">else</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">!==e.type||t?</span><span class="s1">this</span><span class="s0">.toAssignable(e,r):</span><span class="s1">this</span><span class="s0">.raiseRestNotLast(e.start)}toAssignableList(e,t,r){let n=e.length;</span><span class="s1">if</span><span class="s0">(n){const i=e[n-1];</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">===(</span><span class="s1">null</span><span class="s0">==i?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:i.type))--n;</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">===(</span><span class="s1">null</span><span class="s0">==i?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:i.type)){i.type=</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">;let e=i.argument;</span><span class="s1">this</span><span class="s0">.toAssignable(e,r),e=Ve(e),</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(e.start),t&amp;&amp;</span><span class="s1">this</span><span class="s0">.raiseTrailingCommaAfterRest(t),--n}}</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">;t&lt;n;t++){const n=e[t];n&amp;&amp;(</span><span class="s1">this</span><span class="s0">.toAssignable(n,r),</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">===n.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raiseRestNotLast(n.start))}</span><span class="s1">return </span><span class="s0">e}toReferencedList(e,t){</span><span class="s1">return </span><span class="s0">e}toReferencedListDeep(e,t){</span><span class="s1">this</span><span class="s0">.toReferencedList(e,t);</span><span class="s1">for</span><span class="s0">(const t of e)</span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s0">===(</span><span class="s1">null</span><span class="s0">==t?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.type)&amp;&amp;</span><span class="s1">this</span><span class="s0">.toReferencedListDeep(t.elements)}parseSpread(e,t){const r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),r.argument=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(e,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,t),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">)}parseRestBinding(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),e.argument=</span><span class="s1">this</span><span class="s0">.parseBindingAtom(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">)}parseBindingAtom(){</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c.bracketL:{const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),e.elements=</span><span class="s1">this</span><span class="s0">.parseBindingList(c.bracketR,</span><span class="s2">93</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">)}</span><span class="s1">case </span><span class="s0">c.braceL:</span><span class="s1">return this</span><span class="s0">.parseObjectLike(c.braceR,!</span><span class="s2">0</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.parseIdentifier()}parseBindingList(e,t,r,n){const i=[];let s=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.eat(e);)</span><span class="s1">if</span><span class="s0">(s?s=!</span><span class="s2">1</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.expect(c.comma),r&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.comma))i.push(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(e))</span><span class="s1">break</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.ellipsis)){i.push(</span><span class="s1">this</span><span class="s0">.parseAssignableListItemTypes(</span><span class="s1">this</span><span class="s0">.parseRestBinding())),</span><span class="s1">this</span><span class="s0">.checkCommaAfterRest(t),</span><span class="s1">this</span><span class="s0">.expect(e);</span><span class="s1">break</span><span class="s0">}{const e=[];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.at)&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.UnsupportedParameterDecorator);</span><span class="s1">this</span><span class="s0">.match(c.at);)e.push(</span><span class="s1">this</span><span class="s0">.parseDecorator());i.push(</span><span class="s1">this</span><span class="s0">.parseAssignableListItem(n,e))}}</span><span class="s1">return </span><span class="s0">i}parseAssignableListItem(e,t){const r=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault();</span><span class="s1">this</span><span class="s0">.parseAssignableListItemTypes(r);const n=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault(r.start,r.loc.start,r);</span><span class="s1">return </span><span class="s0">t.length&amp;&amp;(r.decorators=t),n}parseAssignableListItemTypes(e){</span><span class="s1">return </span><span class="s0">e}parseMaybeDefault(e,t,r){</span><span class="s1">var </span><span class="s0">n,i,s;</span><span class="s1">if</span><span class="s0">(t=</span><span class="s1">null</span><span class="s0">!=(n=t)?n:</span><span class="s1">this</span><span class="s0">.state.startLoc,e=</span><span class="s1">null</span><span class="s0">!=(i=e)?i:</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">null</span><span class="s0">!=(s=r)?s:</span><span class="s1">this</span><span class="s0">.parseBindingAtom(),!</span><span class="s1">this</span><span class="s0">.eat(c.eq))</span><span class="s1">return </span><span class="s0">r;const a=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);</span><span class="s1">return </span><span class="s0">a.left=r,a.right=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">)}checkLVal(e,t,r=</span><span class="s2">64</span><span class="s0">,n,i,s=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">switch</span><span class="s0">(e.type){</span><span class="s1">case</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">:{const{name:t}=e;</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;(s?q(t,</span><span class="s1">this</span><span class="s0">.inModule):K(t))&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,</span><span class="s2">64</span><span class="s0">===r?E.StrictEvalArguments:E.StrictEvalArgumentsBinding,t),n&amp;&amp;(n.has(t)?</span><span class="s1">this</span><span class="s0">.raise(e.start,E.ParamDupe):n.add(t)),i&amp;&amp;</span><span class="s3">&quot;let&quot;</span><span class="s0">===t&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,E.LetInLexicalBinding),</span><span class="s2">64</span><span class="s0">&amp;r||</span><span class="s1">this</span><span class="s0">.scope.declareName(t,r,e.start);</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">:</span><span class="s2">64</span><span class="s0">!==r&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,E.InvalidPropertyBindingPattern);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">:</span><span class="s1">for</span><span class="s0">(let t of e.properties){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isObjectProperty(t))t=t.value;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isObjectMethod(t))</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.checkLVal(t,</span><span class="s3">&quot;object destructuring pattern&quot;</span><span class="s0">,r,n,i)}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">:</span><span class="s1">for</span><span class="s0">(const t of e.elements)t&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkLVal(t,</span><span class="s3">&quot;array destructuring pattern&quot;</span><span class="s0">,r,n,i);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.checkLVal(e.left,</span><span class="s3">&quot;assignment pattern&quot;</span><span class="s0">,r,n);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.checkLVal(e.argument,</span><span class="s3">&quot;rest element&quot;</span><span class="s0">,r,n);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.checkLVal(e.expression,</span><span class="s3">&quot;parenthesized expression&quot;</span><span class="s0">,r,n);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.raise(e.start,</span><span class="s2">64</span><span class="s0">===r?E.InvalidLhs:E.InvalidLhsBinding,t)}}checkToRestConversion(e){</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==e.argument.type&amp;&amp;</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">!==e.argument.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.argument.start,E.InvalidRestAssignmentPattern)}checkCommaAfterRest(e){</span><span class="s1">this</span><span class="s0">.match(c.comma)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()===e?</span><span class="s1">this</span><span class="s0">.raiseTrailingCommaAfterRest(</span><span class="s1">this</span><span class="s0">.state.start):</span><span class="s1">this</span><span class="s0">.raiseRestNotLast(</span><span class="s1">this</span><span class="s0">.state.start))}raiseRestNotLast(e){</span><span class="s1">throw this</span><span class="s0">.raise(e,E.ElementAfterRest)}raiseTrailingCommaAfterRest(e){</span><span class="s1">this</span><span class="s0">.raise(e,E.RestTrailingComma)}}class qe extends Ke{checkProto(e,t,r,n){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">===e.type||</span><span class="s1">this</span><span class="s0">.isObjectMethod(e)||e.computed||e.shorthand)</span><span class="s1">return</span><span class="s0">;const i=e.key;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;__proto__&quot;</span><span class="s0">===(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===i.type?i.name:i.value)){</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return void this</span><span class="s0">.raise(i.start,E.RecordNoProto);r.used&amp;&amp;(n?-</span><span class="s2">1</span><span class="s0">===n.doubleProto&amp;&amp;(n.doubleProto=i.start):</span><span class="s1">this</span><span class="s0">.raise(i.start,E.DuplicateProto)),r.used=!</span><span class="s2">0</span><span class="s0">}}shouldExitDescending(e,t){</span><span class="s1">return</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">===e.type&amp;&amp;e.start===t}getExpression(){let e=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;topLevelAwait&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;(e|=</span><span class="s2">2</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.enter(e),</span><span class="s1">this</span><span class="s0">.nextToken();const t=</span><span class="s1">this</span><span class="s0">.parseExpression();</span><span class="s1">return this</span><span class="s0">.match(c.eof)||</span><span class="s1">this</span><span class="s0">.unexpected(),t.comments=</span><span class="s1">this</span><span class="s0">.state.comments,t.errors=</span><span class="s1">this</span><span class="s0">.state.errors,</span><span class="s1">this</span><span class="s0">.options.tokens&amp;&amp;(t.tokens=</span><span class="s1">this</span><span class="s0">.tokens),t}parseExpression(e,t){</span><span class="s1">return </span><span class="s0">e?</span><span class="s1">this</span><span class="s0">.disallowInAnd((()=&gt;</span><span class="s1">this</span><span class="s0">.parseExpressionBase(t))):</span><span class="s1">this</span><span class="s0">.allowInAnd((()=&gt;</span><span class="s1">this</span><span class="s0">.parseExpressionBase(t)))}parseExpressionBase(e){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.state.startLoc,n=</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.comma)){const i=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">for</span><span class="s0">(i.expressions=[n];</span><span class="s1">this</span><span class="s0">.eat(c.comma);)i.expressions.push(</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(e));</span><span class="s1">return this</span><span class="s0">.toReferencedList(i.expressions),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">n}parseMaybeAssignDisallowIn(e,t,r){</span><span class="s1">return this</span><span class="s0">.disallowInAnd((()=&gt;</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(e,t,r)))}parseMaybeAssignAllowIn(e,t,r){</span><span class="s1">return this</span><span class="s0">.allowInAnd((()=&gt;</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(e,t,r)))}parseMaybeAssign(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.state.start,i=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;yield&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.prodParam.hasYield){</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">0</span><span class="s0">;let e=</span><span class="s1">this</span><span class="s0">.parseYield();</span><span class="s1">return </span><span class="s0">t&amp;&amp;(e=t.call(</span><span class="s1">this</span><span class="s0">,e,n,i)),e}let s;e?s=!</span><span class="s2">1</span><span class="s0">:(e=</span><span class="s1">new </span><span class="s0">Be,s=!</span><span class="s2">0</span><span class="s0">),(</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.match(c.name))&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt=</span><span class="s1">this</span><span class="s0">.state.start);let a=</span><span class="s1">this</span><span class="s0">.parseMaybeConditional(e,r);</span><span class="s1">if</span><span class="s0">(t&amp;&amp;(a=t.call(</span><span class="s1">this</span><span class="s0">,a,n,i)),</span><span class="s1">this</span><span class="s0">.state.type.isAssign){const t=</span><span class="s1">this</span><span class="s0">.startNodeAt(n,i),r=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">return </span><span class="s0">t.operator=r,</span><span class="s1">this</span><span class="s0">.match(c.eq)?(t.left=</span><span class="s1">this</span><span class="s0">.toAssignable(a,!</span><span class="s2">0</span><span class="s0">),e.doubleProto=-</span><span class="s2">1</span><span class="s0">):t.left=a,e.shorthandAssign&gt;=t.left.start&amp;&amp;(e.shorthandAssign=-</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.checkLVal(a,</span><span class="s3">&quot;assignment expression&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),t.right=</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">s&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkExpressionErrors(e,!</span><span class="s2">0</span><span class="s0">),a}parseMaybeConditional(e,t){const r=</span><span class="s1">this</span><span class="s0">.state.start,n=</span><span class="s1">this</span><span class="s0">.state.startLoc,i=</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt,s=</span><span class="s1">this</span><span class="s0">.parseExprOps(e);</span><span class="s1">return this</span><span class="s0">.shouldExitDescending(s,i)?s:</span><span class="s1">this</span><span class="s0">.parseConditional(s,r,n,t)}parseConditional(e,t,r,n){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.question)){const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">n.test=e,n.consequent=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),</span><span class="s1">this</span><span class="s0">.expect(c.colon),n.alternate=</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(),</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}parseExprOps(e){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.state.startLoc,n=</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt,i=</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(e);</span><span class="s1">return this</span><span class="s0">.shouldExitDescending(i,n)?i:</span><span class="s1">this</span><span class="s0">.parseExprOp(i,t,r,-</span><span class="s2">1</span><span class="s0">)}parseExprOp(e,t,r,n){let i=</span><span class="s1">this</span><span class="s0">.state.type.binop;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=i&amp;&amp;(</span><span class="s1">this</span><span class="s0">.prodParam.hasIn||!</span><span class="s1">this</span><span class="s0">.match(c._in))&amp;&amp;i&gt;n){const s=</span><span class="s1">this</span><span class="s0">.state.type;</span><span class="s1">if</span><span class="s0">(s===c.pipeline){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;pipelineOperator&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">this</span><span class="s0">.state.inPipeline=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.checkPipelineAtInfixOperator(e,t)}const a=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);a.left=e,a.operator=</span><span class="s1">this</span><span class="s0">.state.value;const o=s===c.logicalOR||s===c.logicalAND,l=s===c.nullishCoalescing;</span><span class="s1">if</span><span class="s0">(l&amp;&amp;(i=c.logicalAND.binop),</span><span class="s1">this</span><span class="s0">.next(),s===c.pipeline&amp;&amp;</span><span class="s3">&quot;minimal&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;pipelineOperator&quot;</span><span class="s0">,</span><span class="s3">&quot;proposal&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.name)&amp;&amp;</span><span class="s3">&quot;await&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value&amp;&amp;</span><span class="s1">this</span><span class="s0">.prodParam.hasAwait)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.UnexpectedAwaitAfterPipelineBody);a.right=</span><span class="s1">this</span><span class="s0">.parseExprOpRightExpr(s,i),</span><span class="s1">this</span><span class="s0">.finishNode(a,o||l?</span><span class="s3">&quot;LogicalExpression&quot;</span><span class="s0">:</span><span class="s3">&quot;BinaryExpression&quot;</span><span class="s0">);const p=</span><span class="s1">this</span><span class="s0">.state.type;</span><span class="s1">if</span><span class="s0">(l&amp;&amp;(p===c.logicalOR||p===c.logicalAND)||o&amp;&amp;p===c.nullishCoalescing)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.MixingCoalesceWithLogical);</span><span class="s1">return this</span><span class="s0">.parseExprOp(a,t,r,n)}</span><span class="s1">return </span><span class="s0">e}parseExprOpRightExpr(e,t){const r=</span><span class="s1">this</span><span class="s0">.state.start,n=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">if</span><span class="s0">(e===c.pipeline)</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;pipelineOperator&quot;</span><span class="s0">,</span><span class="s3">&quot;proposal&quot;</span><span class="s0">)){</span><span class="s1">case</span><span class="s3">&quot;smart&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.withTopicPermittingContext((()=&gt;</span><span class="s1">this</span><span class="s0">.parseSmartPipelineBody(</span><span class="s1">this</span><span class="s0">.parseExprOpBaseRightExpr(e,t),r,n)));</span><span class="s1">case</span><span class="s3">&quot;fsharp&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.withSoloAwaitPermittingContext((()=&gt;</span><span class="s1">this</span><span class="s0">.parseFSharpPipelineBody(t)))}</span><span class="s1">return this</span><span class="s0">.parseExprOpBaseRightExpr(e,t)}parseExprOpBaseRightExpr(e,t){const r=</span><span class="s1">this</span><span class="s0">.state.start,n=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">return this</span><span class="s0">.parseExprOp(</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(),r,n,e.rightAssociative?t-1:t)}checkExponentialAfterUnary(e){</span><span class="s1">this</span><span class="s0">.match(c.exponent)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.argument.start,E.UnexpectedTokenUnaryExponentiation)}parseMaybeUnary(e,t){const r=</span><span class="s1">this</span><span class="s0">.state.start,n=</span><span class="s1">this</span><span class="s0">.state.startLoc,i=</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;await&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(i&amp;&amp;</span><span class="s1">this</span><span class="s0">.isAwaitAllowed()){</span><span class="s1">this</span><span class="s0">.next();const e=</span><span class="s1">this</span><span class="s0">.parseAwait(r,n);</span><span class="s1">return </span><span class="s0">t||</span><span class="s1">this</span><span class="s0">.checkExponentialAfterUnary(e),e}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;module&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">123</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasFollowingLineBreak())</span><span class="s1">return this</span><span class="s0">.parseModuleExpression();const s=</span><span class="s1">this</span><span class="s0">.match(c.incDec),a=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type.prefix){a.operator=</span><span class="s1">this</span><span class="s0">.state.value,a.prefix=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(c._throw)&amp;&amp;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;throwExpressions&quot;</span><span class="s0">);const r=</span><span class="s1">this</span><span class="s0">.match(c._delete);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),a.argument=</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(</span><span class="s1">null</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.checkExpressionErrors(e,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;r){const e=a.argument;</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type?</span><span class="s1">this</span><span class="s0">.raise(a.start,E.StrictDelete):</span><span class="s1">this</span><span class="s0">.hasPropertyAsPrivateName(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(a.start,E.DeletePrivateField)}</span><span class="s1">if</span><span class="s0">(!s)</span><span class="s1">return </span><span class="s0">t||</span><span class="s1">this</span><span class="s0">.checkExponentialAfterUnary(a),</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s3">&quot;UnaryExpression&quot;</span><span class="s0">)}const o=</span><span class="s1">this</span><span class="s0">.parseUpdate(a,s,e);</span><span class="s1">return </span><span class="s0">i&amp;&amp;(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;v8intrinsic&quot;</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.state.type.startsExpr:</span><span class="s1">this</span><span class="s0">.state.type.startsExpr&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.modulo))&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isAmbiguousAwait()?(</span><span class="s1">this</span><span class="s0">.raiseOverwrite(r,</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;topLevelAwait&quot;</span><span class="s0">)?E.AwaitNotInAsyncContext:E.AwaitNotInAsyncFunction),</span><span class="s1">this</span><span class="s0">.parseAwait(r,n)):o}parseUpdate(e,t,r){</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return this</span><span class="s0">.checkLVal(e.argument,</span><span class="s3">&quot;prefix operation&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;UpdateExpression&quot;</span><span class="s0">);const n=</span><span class="s1">this</span><span class="s0">.state.start,i=</span><span class="s1">this</span><span class="s0">.state.startLoc;let s=</span><span class="s1">this</span><span class="s0">.parseExprSubscripts(r);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.checkExpressionErrors(r,!</span><span class="s2">1</span><span class="s0">))</span><span class="s1">return </span><span class="s0">s;</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.state.type.postfix&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon();){const e=</span><span class="s1">this</span><span class="s0">.startNodeAt(n,i);e.operator=</span><span class="s1">this</span><span class="s0">.state.value,e.prefix=!</span><span class="s2">1</span><span class="s0">,e.argument=s,</span><span class="s1">this</span><span class="s0">.checkLVal(s,</span><span class="s3">&quot;postfix operation&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),s=</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;UpdateExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">s}parseExprSubscripts(e){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.state.startLoc,n=</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt,i=</span><span class="s1">this</span><span class="s0">.parseExprAtom(e);</span><span class="s1">return this</span><span class="s0">.shouldExitDescending(i,n)?i:</span><span class="s1">this</span><span class="s0">.parseSubscripts(i,t,r)}parseSubscripts(e,t,r,n){const i={optionalChainMember:!</span><span class="s2">1</span><span class="s0">,maybeAsyncArrow:</span><span class="s1">this</span><span class="s0">.atPossibleAsyncArrow(e),stop:!</span><span class="s2">1</span><span class="s0">};</span><span class="s1">do</span><span class="s0">{e=</span><span class="s1">this</span><span class="s0">.parseSubscript(e,t,r,n,i),i.maybeAsyncArrow=!</span><span class="s2">1</span><span class="s0">}</span><span class="s1">while</span><span class="s0">(!i.stop);</span><span class="s1">return </span><span class="s0">e}parseSubscript(e,t,r,n,i){</span><span class="s1">if</span><span class="s0">(!n&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.doubleColon))</span><span class="s1">return this</span><span class="s0">.parseBind(e,t,r,n,i);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.backQuote))</span><span class="s1">return this</span><span class="s0">.parseTaggedTemplateExpression(e,t,r,i);let s=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.questionDot)){</span><span class="s1">if</span><span class="s0">(n&amp;&amp;</span><span class="s2">40</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.lookaheadCharCode())</span><span class="s1">return </span><span class="s0">i.stop=!</span><span class="s2">0</span><span class="s0">,e;i.optionalChainMember=s=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next()}</span><span class="s1">return</span><span class="s0">!n&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.parenL)?</span><span class="s1">this</span><span class="s0">.parseCoverCallAndAsyncArrowHead(e,t,r,i,s):s||</span><span class="s1">this</span><span class="s0">.match(c.bracketL)||</span><span class="s1">this</span><span class="s0">.eat(c.dot)?</span><span class="s1">this</span><span class="s0">.parseMember(e,t,r,i,s):(i.stop=!</span><span class="s2">0</span><span class="s0">,e)}parseMember(e,t,r,n,i){const s=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r),a=</span><span class="s1">this</span><span class="s0">.eat(c.bracketL);s.object=e,s.computed=a;const o=!a&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.privateName)&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.value,l=a?</span><span class="s1">this</span><span class="s0">.parseExpression():o?</span><span class="s1">this</span><span class="s0">.parsePrivateName():</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">!==o&amp;&amp;(</span><span class="s3">&quot;Super&quot;</span><span class="s0">===s.object.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,E.SuperPrivateField),</span><span class="s1">this</span><span class="s0">.classScope.usePrivateName(o,l.start)),s.property=l,a&amp;&amp;</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),n.optionalChainMember?(s.optional=i,</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">)}parseBind(e,t,r,n,i){const s=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">s.object=e,s.callee=</span><span class="s1">this</span><span class="s0">.parseNoCallExpr(),i.stop=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseSubscripts(</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s3">&quot;BindExpression&quot;</span><span class="s0">),t,r,n)}parseCoverCallAndAsyncArrowHead(e,t,r,n,i){const s=</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters;</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next();let a=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">a.callee=e,n.maybeAsyncArrow&amp;&amp;</span><span class="s1">this</span><span class="s0">.expressionScope.enter(</span><span class="s1">new </span><span class="s0">Le(</span><span class="s2">2</span><span class="s0">)),n.optionalChainMember&amp;&amp;(a.optional=i),a.arguments=i?</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(c.parenR,!</span><span class="s2">1</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(c.parenR,n.maybeAsyncArrow,</span><span class="s3">&quot;Import&quot;</span><span class="s0">===e.type,</span><span class="s3">&quot;Super&quot;</span><span class="s0">!==e.type,a),</span><span class="s1">this</span><span class="s0">.finishCallExpression(a,n.optionalChainMember),n.maybeAsyncArrow&amp;&amp;</span><span class="s1">this</span><span class="s0">.shouldParseAsyncArrow()&amp;&amp;!i?(n.stop=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expressionScope.validateAsPattern(),</span><span class="s1">this</span><span class="s0">.expressionScope.exit(),a=</span><span class="s1">this</span><span class="s0">.parseAsyncArrowFromCallExpression(</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r),a)):(n.maybeAsyncArrow&amp;&amp;</span><span class="s1">this</span><span class="s0">.expressionScope.exit(),</span><span class="s1">this</span><span class="s0">.toReferencedArguments(a)),</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=s,a}toReferencedArguments(e,t){</span><span class="s1">this</span><span class="s0">.toReferencedListDeep(e.arguments,t)}parseTaggedTemplateExpression(e,t,r,n){const i=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">i.tag=e,i.quasi=</span><span class="s1">this</span><span class="s0">.parseTemplate(!</span><span class="s2">0</span><span class="s0">),n.optionalChainMember&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,E.OptionalChainingNoTemplate),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s3">&quot;TaggedTemplateExpression&quot;</span><span class="s0">)}atPossibleAsyncArrow(e){</span><span class="s1">return</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;async&quot;</span><span class="s0">===e.name&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.lastTokEnd===e.end&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()&amp;&amp;e.end-e.start==</span><span class="s2">5</span><span class="s0">&amp;&amp;e.start===</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt}finishCallExpression(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;Import&quot;</span><span class="s0">===e.callee.type)</span><span class="s1">if</span><span class="s0">(</span><span class="s2">2</span><span class="s0">===e.arguments.length&amp;&amp;(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;moduleAttributes&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;importAssertions&quot;</span><span class="s0">)),</span><span class="s2">0</span><span class="s0">===e.arguments.length||e.arguments.length&gt;</span><span class="s2">2</span><span class="s0">)</span><span class="s1">this</span><span class="s0">.raise(e.start,E.ImportCallArity,</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;importAssertions&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;moduleAttributes&quot;</span><span class="s0">)?</span><span class="s3">&quot;one or two arguments&quot;</span><span class="s0">:</span><span class="s3">&quot;one argument&quot;</span><span class="s0">);</span><span class="s1">else for</span><span class="s0">(const t of e.arguments)</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">===t.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,E.ImportCallSpreadArgument);</span><span class="s1">return this</span><span class="s0">.finishNode(e,t?</span><span class="s3">&quot;OptionalCallExpression&quot;</span><span class="s0">:</span><span class="s3">&quot;CallExpression&quot;</span><span class="s0">)}parseCallExpressionArguments(e,t,r,n,i){const s=[];let a=!</span><span class="s2">0</span><span class="s0">;const o=</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=!</span><span class="s2">1</span><span class="s0">;!</span><span class="s1">this</span><span class="s0">.eat(e);){</span><span class="s1">if</span><span class="s0">(a)a=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.comma),</span><span class="s1">this</span><span class="s0">.match(e)){!r||</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;importAssertions&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;moduleAttributes&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,E.ImportCallArgumentTrailingComma),i&amp;&amp;</span><span class="s1">this</span><span class="s0">.addExtra(i,</span><span class="s3">&quot;trailingComma&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.lastTokStart),</span><span class="s1">this</span><span class="s0">.next();</span><span class="s1">break</span><span class="s0">}s.push(</span><span class="s1">this</span><span class="s0">.parseExprListItem(!</span><span class="s2">1</span><span class="s0">,t?</span><span class="s1">new </span><span class="s0">Be:</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,t?{start:</span><span class="s2">0</span><span class="s0">}:</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,n))}</span><span class="s1">return this</span><span class="s0">.state.inFSharpPipelineDirectBody=o,s}shouldParseAsyncArrow(){</span><span class="s1">return this</span><span class="s0">.match(c.arrow)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()}parseAsyncArrowFromCallExpression(e,t){</span><span class="s1">var </span><span class="s0">r;</span><span class="s1">return this</span><span class="s0">.expect(c.arrow),</span><span class="s1">this</span><span class="s0">.parseArrowExpression(e,t.arguments,!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">null</span><span class="s0">==(r=t.extra)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.trailingComma),e}parseNoCallExpr(){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">return this</span><span class="s0">.parseSubscripts(</span><span class="s1">this</span><span class="s0">.parseExprAtom(),e,t,!</span><span class="s2">0</span><span class="s0">)}parseExprAtom(e){</span><span class="s1">this</span><span class="s0">.state.type===c.slash&amp;&amp;</span><span class="s1">this</span><span class="s0">.readRegexp();const t=</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt===</span><span class="s1">this</span><span class="s0">.state.start;let r;</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c._super:</span><span class="s1">return this</span><span class="s0">.parseSuper();</span><span class="s1">case </span><span class="s0">c._import:</span><span class="s1">return </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.dot)?</span><span class="s1">this</span><span class="s0">.parseImportMetaProperty(r):(</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,E.UnsupportedImport),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;Import&quot;</span><span class="s0">));</span><span class="s1">case </span><span class="s0">c._this:</span><span class="s1">return </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;ThisExpression&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.name:{const e=</span><span class="s1">this</span><span class="s0">.state.containsEsc,r=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">if</span><span class="s0">(!e&amp;&amp;</span><span class="s3">&quot;async&quot;</span><span class="s0">===r.name&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._function)){const e=</span><span class="s1">this</span><span class="s0">.state.context.length-1;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.context[e]!==O.functionStatement)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Internal error&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.state.context[e]=O.functionExpression,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseFunction(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(r),</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.name))</span><span class="s1">return </span><span class="s2">61</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()?</span><span class="s1">this</span><span class="s0">.parseAsyncArrowUnaryFunction(r):r;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._do))</span><span class="s1">return this</span><span class="s0">.parseDo(!</span><span class="s2">0</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">t&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.arrow)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()?(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseArrowExpression(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(r),[r],!</span><span class="s2">1</span><span class="s0">)):r}</span><span class="s1">case </span><span class="s0">c._do:</span><span class="s1">return this</span><span class="s0">.parseDo(!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.regexp:{const e=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">return </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.parseLiteral(e.value,</span><span class="s3">&quot;RegExpLiteral&quot;</span><span class="s0">),r.pattern=e.pattern,r.flags=e.flags,r}</span><span class="s1">case </span><span class="s0">c.num:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.bigint:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;BigIntLiteral&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.decimal:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;DecimalLiteral&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.string:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._null:</span><span class="s1">return </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;NullLiteral&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._true:</span><span class="s1">case </span><span class="s0">c._false:</span><span class="s1">return this</span><span class="s0">.parseBooleanLiteral();</span><span class="s1">case </span><span class="s0">c.parenL:</span><span class="s1">return this</span><span class="s0">.parseParenAndDistinguishExpression(t);</span><span class="s1">case </span><span class="s0">c.bracketBarL:</span><span class="s1">case </span><span class="s0">c.bracketHashL:</span><span class="s1">return this</span><span class="s0">.parseArrayLike(</span><span class="s1">this</span><span class="s0">.state.type===c.bracketBarL?c.bracketBarR:c.bracketR,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">,e);</span><span class="s1">case </span><span class="s0">c.bracketL:</span><span class="s1">return this</span><span class="s0">.parseArrayLike(c.bracketR,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,e);</span><span class="s1">case </span><span class="s0">c.braceBarL:</span><span class="s1">case </span><span class="s0">c.braceHashL:</span><span class="s1">return this</span><span class="s0">.parseObjectLike(</span><span class="s1">this</span><span class="s0">.state.type===c.braceBarL?c.braceBarR:c.braceR,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">,e);</span><span class="s1">case </span><span class="s0">c.braceL:</span><span class="s1">return this</span><span class="s0">.parseObjectLike(c.braceR,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,e);</span><span class="s1">case </span><span class="s0">c._function:</span><span class="s1">return this</span><span class="s0">.parseFunctionOrFunctionSent();</span><span class="s1">case </span><span class="s0">c.at:</span><span class="s1">this</span><span class="s0">.parseDecorators();</span><span class="s1">case </span><span class="s0">c._class:</span><span class="s1">return </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.takeDecorators(r),</span><span class="s1">this</span><span class="s0">.parseClass(r,!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._new:</span><span class="s1">return this</span><span class="s0">.parseNewOrNewTarget();</span><span class="s1">case </span><span class="s0">c.backQuote:</span><span class="s1">return this</span><span class="s0">.parseTemplate(!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.doubleColon:{r=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.next(),r.object=</span><span class="s1">null</span><span class="s0">;const e=r.callee=</span><span class="s1">this</span><span class="s0">.parseNoCallExpr();</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">===e.type)</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;BindExpression&quot;</span><span class="s0">);</span><span class="s1">throw this</span><span class="s0">.raise(e.start,E.UnsupportedBind)}</span><span class="s1">case </span><span class="s0">c.privateName:{const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">if</span><span class="s0">(r=</span><span class="s1">this</span><span class="s0">.parsePrivateName(),</span><span class="s1">this</span><span class="s0">.match(c._in))</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;privateIn&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.classScope.usePrivateName(t,r.start);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;privateIn&quot;</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.unexpected(e);</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.PrivateInExpectedIn,t)}</span><span class="s1">return </span><span class="s0">r}</span><span class="s1">case </span><span class="s0">c.hash:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.inPipeline)</span><span class="s1">return </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s3">&quot;smart&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;pipelineOperator&quot;</span><span class="s0">,</span><span class="s3">&quot;proposal&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r.start,E.PrimaryTopicRequiresSmartPipeline),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.primaryTopicReferenceIsAllowedInCurrentTopicContext()||</span><span class="s1">this</span><span class="s0">.raise(r.start,E.PrimaryTopicNotAllowed),</span><span class="s1">this</span><span class="s0">.registerTopicReference(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;PipelinePrimaryTopicReference&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.relational:</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value){const e=</span><span class="s1">this</span><span class="s0">.input.codePointAt(</span><span class="s1">this</span><span class="s0">.nextTokenStart());(M(e)||</span><span class="s2">62</span><span class="s0">===e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.expectOnePlugin([</span><span class="s3">&quot;jsx&quot;</span><span class="s0">,</span><span class="s3">&quot;flow&quot;</span><span class="s0">,</span><span class="s3">&quot;typescript&quot;</span><span class="s0">])}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw this</span><span class="s0">.unexpected()}}parseAsyncArrowUnaryFunction(e){const t=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e);</span><span class="s1">this</span><span class="s0">.prodParam.enter(ue(!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.prodParam.hasYield));const r=[</span><span class="s1">this</span><span class="s0">.parseIdentifier()];</span><span class="s1">return this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.LineTerminatorBeforeArrow),</span><span class="s1">this</span><span class="s0">.expect(c.arrow),</span><span class="s1">this</span><span class="s0">.parseArrowExpression(t,r,!</span><span class="s2">0</span><span class="s0">),t}parseDo(e){</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;doExpressions&quot;</span><span class="s0">),e&amp;&amp;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;asyncDoExpressions&quot;</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.startNode();t.async=e,</span><span class="s1">this</span><span class="s0">.next();const r=</span><span class="s1">this</span><span class="s0">.state.labels;</span><span class="s1">return this</span><span class="s0">.state.labels=[],e?(</span><span class="s1">this</span><span class="s0">.prodParam.enter(</span><span class="s2">2</span><span class="s0">),t.body=</span><span class="s1">this</span><span class="s0">.parseBlock(),</span><span class="s1">this</span><span class="s0">.prodParam.exit()):t.body=</span><span class="s1">this</span><span class="s0">.parseBlock(),</span><span class="s1">this</span><span class="s0">.state.labels=r,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;DoExpression&quot;</span><span class="s0">)}parseSuper(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),!</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.scope.allowDirectSuper||</span><span class="s1">this</span><span class="s0">.options.allowSuperOutsideMethod?</span><span class="s1">this</span><span class="s0">.scope.allowSuper||</span><span class="s1">this</span><span class="s0">.options.allowSuperOutsideMethod||</span><span class="s1">this</span><span class="s0">.raise(e.start,E.UnexpectedSuper):</span><span class="s1">this</span><span class="s0">.raise(e.start,E.SuperNotAllowed),</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.match(c.bracketL)||</span><span class="s1">this</span><span class="s0">.match(c.dot)||</span><span class="s1">this</span><span class="s0">.raise(e.start,E.UnsupportedSuper),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;Super&quot;</span><span class="s0">)}parseBooleanLiteral(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.value=</span><span class="s1">this</span><span class="s0">.match(c._true),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;BooleanLiteral&quot;</span><span class="s0">)}parseMaybePrivateName(e){</span><span class="s1">return this</span><span class="s0">.match(c.privateName)?(e||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start+</span><span class="s2">1</span><span class="s0">,E.UnexpectedPrivateField),</span><span class="s1">this</span><span class="s0">.parsePrivateName()):</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">)}parsePrivateName(){const e=</span><span class="s1">this</span><span class="s0">.startNode(),t=</span><span class="s1">this</span><span class="s0">.startNodeAt(</span><span class="s1">this</span><span class="s0">.state.start+</span><span class="s2">1</span><span class="s0">,</span><span class="s1">new </span><span class="s0">y(</span><span class="s1">this</span><span class="s0">.state.curLine,</span><span class="s1">this</span><span class="s0">.state.start+</span><span class="s2">1</span><span class="s0">-</span><span class="s1">this</span><span class="s0">.state.lineStart)),r=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">return this</span><span class="s0">.next(),e.id=</span><span class="s1">this</span><span class="s0">.createIdentifier(t,r),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">)}parseFunctionOrFunctionSent(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.prodParam.hasYield&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.dot)){const t=</span><span class="s1">this</span><span class="s0">.createIdentifier(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e),</span><span class="s3">&quot;function&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseMetaProperty(e,t,</span><span class="s3">&quot;sent&quot;</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.parseFunction(e)}parseMetaProperty(e,t,r){e.meta=t,</span><span class="s3">&quot;function&quot;</span><span class="s0">===t.name&amp;&amp;</span><span class="s3">&quot;sent&quot;</span><span class="s0">===r&amp;&amp;(</span><span class="s1">this</span><span class="s0">.isContextual(r)?</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;functionSent&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;functionSent&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.unexpected());const n=</span><span class="s1">this</span><span class="s0">.state.containsEsc;</span><span class="s1">return </span><span class="s0">e.property=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),(e.property.name!==r||n)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.property.start,E.UnsupportedMetaProperty,t.name,r),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;MetaProperty&quot;</span><span class="s0">)}parseImportMetaProperty(e){const t=</span><span class="s1">this</span><span class="s0">.createIdentifier(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e),</span><span class="s3">&quot;import&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;meta&quot;</span><span class="s0">)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.inModule||</span><span class="s1">this</span><span class="s0">.raise(t.start,P.ImportMetaOutsideModule),</span><span class="s1">this</span><span class="s0">.sawUnambiguousESM=!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parseMetaProperty(e,t,</span><span class="s3">&quot;meta&quot;</span><span class="s0">)}parseLiteral(e,t,r,n){r=r||</span><span class="s1">this</span><span class="s0">.state.start,n=n||</span><span class="s1">this</span><span class="s0">.state.startLoc;const i=</span><span class="s1">this</span><span class="s0">.startNodeAt(r,n);</span><span class="s1">return this</span><span class="s0">.addExtra(i,</span><span class="s3">&quot;rawValue&quot;</span><span class="s0">,e),</span><span class="s1">this</span><span class="s0">.addExtra(i,</span><span class="s3">&quot;raw&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.input.slice(r,</span><span class="s1">this</span><span class="s0">.state.end)),i.value=e,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(i,t)}parseParenAndDistinguishExpression(e){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.state.startLoc;let n;</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expressionScope.enter(</span><span class="s1">new </span><span class="s0">Le(</span><span class="s2">1</span><span class="s0">));const i=</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters,s=</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody;</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=!</span><span class="s2">1</span><span class="s0">;const a=</span><span class="s1">this</span><span class="s0">.state.start,o=</span><span class="s1">this</span><span class="s0">.state.startLoc,l=[],p=</span><span class="s1">new </span><span class="s0">Be,u={start:</span><span class="s2">0</span><span class="s0">};let d,h,f=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.match(c.parenR);){</span><span class="s1">if</span><span class="s0">(f)f=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.comma,u.start||</span><span class="s1">null</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(c.parenR)){h=</span><span class="s1">this</span><span class="s0">.state.start;</span><span class="s1">break</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.ellipsis)){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc;d=</span><span class="s1">this</span><span class="s0">.state.start,l.push(</span><span class="s1">this</span><span class="s0">.parseParenItem(</span><span class="s1">this</span><span class="s0">.parseRestBinding(),e,t)),</span><span class="s1">this</span><span class="s0">.checkCommaAfterRest(</span><span class="s2">41</span><span class="s0">);</span><span class="s1">break</span><span class="s0">}l.push(</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(p,</span><span class="s1">this</span><span class="s0">.parseParenItem,u))}const m=</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,y=</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc;</span><span class="s1">this</span><span class="s0">.expect(c.parenR),</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=i,</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=s;let T=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">if</span><span class="s0">(e&amp;&amp;</span><span class="s1">this</span><span class="s0">.shouldParseArrow()&amp;&amp;(T=</span><span class="s1">this</span><span class="s0">.parseArrow(T)))</span><span class="s1">return this</span><span class="s0">.expressionScope.validateAsPattern(),</span><span class="s1">this</span><span class="s0">.expressionScope.exit(),</span><span class="s1">this</span><span class="s0">.parseArrowExpression(T,l,!</span><span class="s2">1</span><span class="s0">),T;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expressionScope.exit(),l.length||</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">this</span><span class="s0">.state.lastTokStart),h&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(h),d&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(d),</span><span class="s1">this</span><span class="s0">.checkExpressionErrors(p,!</span><span class="s2">0</span><span class="s0">),u.start&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(u.start),</span><span class="s1">this</span><span class="s0">.toReferencedListDeep(l,!</span><span class="s2">0</span><span class="s0">),l.length&gt;</span><span class="s2">1</span><span class="s0">?(n=</span><span class="s1">this</span><span class="s0">.startNodeAt(a,o),n.expressions=l,</span><span class="s1">this</span><span class="s0">.finishNodeAt(n,</span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s0">,m,y)):n=l[</span><span class="s2">0</span><span class="s0">],!</span><span class="s1">this</span><span class="s0">.options.createParenthesizedExpressions)</span><span class="s1">return this</span><span class="s0">.addExtra(n,</span><span class="s3">&quot;parenthesized&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.addExtra(n,</span><span class="s3">&quot;parenStart&quot;</span><span class="s0">,t),n;const b=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">b.expression=n,</span><span class="s1">this</span><span class="s0">.finishNode(b,</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">),b}shouldParseArrow(){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()}parseArrow(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.arrow))</span><span class="s1">return </span><span class="s0">e}parseParenItem(e,t,r){</span><span class="s1">return </span><span class="s0">e}parseNewOrNewTarget(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.dot)){const t=</span><span class="s1">this</span><span class="s0">.createIdentifier(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e),</span><span class="s3">&quot;new&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.next();const r=</span><span class="s1">this</span><span class="s0">.parseMetaProperty(e,t,</span><span class="s3">&quot;target&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.scope.inNonArrowFunction||</span><span class="s1">this</span><span class="s0">.scope.inClass||</span><span class="s1">this</span><span class="s0">.raise(r.start,E.UnexpectedNewTarget),r}</span><span class="s1">return this</span><span class="s0">.parseNew(e)}parseNew(e){</span><span class="s1">return </span><span class="s0">e.callee=</span><span class="s1">this</span><span class="s0">.parseNoCallExpr(),</span><span class="s3">&quot;Import&quot;</span><span class="s0">===e.callee.type?</span><span class="s1">this</span><span class="s0">.raise(e.callee.start,E.ImportCallNotNewExpression):</span><span class="s1">this</span><span class="s0">.isOptionalChain(e.callee)?</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,E.OptionalChainingNoNew):</span><span class="s1">this</span><span class="s0">.eat(c.questionDot)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.OptionalChainingNoNew),</span><span class="s1">this</span><span class="s0">.parseNewArguments(e),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;NewExpression&quot;</span><span class="s0">)}parseNewArguments(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.parenL)){const t=</span><span class="s1">this</span><span class="s0">.parseExprList(c.parenR);</span><span class="s1">this</span><span class="s0">.toReferencedList(t),e.arguments=t}</span><span class="s1">else </span><span class="s0">e.arguments=[]}parseTemplateElement(e){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return null</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value&amp;&amp;(e||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start+</span><span class="s2">1</span><span class="s0">,E.InvalidEscapeSequenceTemplate)),t.value={raw:</span><span class="s1">this</span><span class="s0">.input.slice(</span><span class="s1">this</span><span class="s0">.state.start,</span><span class="s1">this</span><span class="s0">.state.end).replace(/\r\n?/g,</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">),cooked:</span><span class="s1">this</span><span class="s0">.state.value},</span><span class="s1">this</span><span class="s0">.next(),t.tail=</span><span class="s1">this</span><span class="s0">.match(c.backQuote),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TemplateElement&quot;</span><span class="s0">)}parseTemplate(e){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.next(),t.expressions=[];let r=</span><span class="s1">this</span><span class="s0">.parseTemplateElement(e);</span><span class="s1">for</span><span class="s0">(t.quasis=[r];!r.tail;)</span><span class="s1">this</span><span class="s0">.expect(c.dollarBraceL),t.expressions.push(</span><span class="s1">this</span><span class="s0">.parseTemplateSubstitution()),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),t.quasis.push(r=</span><span class="s1">this</span><span class="s0">.parseTemplateElement(e));</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TemplateLiteral&quot;</span><span class="s0">)}parseTemplateSubstitution(){</span><span class="s1">return this</span><span class="s0">.parseExpression()}parseObjectLike(e,t,r,n){r&amp;&amp;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">);const i=</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody;</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=!</span><span class="s2">1</span><span class="s0">;const s=Object.create(</span><span class="s1">null</span><span class="s0">);let a=!</span><span class="s2">0</span><span class="s0">;const o=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">for</span><span class="s0">(o.properties=[],</span><span class="s1">this</span><span class="s0">.next();!</span><span class="s1">this</span><span class="s0">.match(e);){</span><span class="s1">if</span><span class="s0">(a)a=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.comma),</span><span class="s1">this</span><span class="s0">.match(e)){</span><span class="s1">this</span><span class="s0">.addExtra(o,</span><span class="s3">&quot;trailingComma&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.lastTokStart);</span><span class="s1">break</span><span class="s0">}const i=</span><span class="s1">this</span><span class="s0">.parsePropertyDefinition(t,n);t||</span><span class="s1">this</span><span class="s0">.checkProto(i,r,s,n),r&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isObjectProperty(i)&amp;&amp;</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">!==i.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(i.start,E.InvalidRecordProperty),i.shorthand&amp;&amp;</span><span class="s1">this</span><span class="s0">.addExtra(i,</span><span class="s3">&quot;shorthand&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),o.properties.push(i)}</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=i;let l=</span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s0">;</span><span class="s1">return </span><span class="s0">t?l=</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">:r&amp;&amp;(l=</span><span class="s3">&quot;RecordExpression&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(o,l)}maybeAsyncOrAccessorProp(e){</span><span class="s1">return</span><span class="s0">!e.computed&amp;&amp;</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.key.type&amp;&amp;(</span><span class="s1">this</span><span class="s0">.isLiteralPropertyName()||</span><span class="s1">this</span><span class="s0">.match(c.bracketL)||</span><span class="s1">this</span><span class="s0">.match(c.star))}parsePropertyDefinition(e,t){let r=[];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.at))</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.UnsupportedPropertyDecorator);</span><span class="s1">this</span><span class="s0">.match(c.at);)r.push(</span><span class="s1">this</span><span class="s0">.parseDecorator());const n=</span><span class="s1">this</span><span class="s0">.startNode();let i,s,a=!</span><span class="s2">1</span><span class="s0">,o=!</span><span class="s2">1</span><span class="s0">,l=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.ellipsis))</span><span class="s1">return </span><span class="s0">r.length&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),e?(</span><span class="s1">this</span><span class="s0">.next(),n.argument=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkCommaAfterRest(</span><span class="s2">125</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.parseSpread();r.length&amp;&amp;(n.decorators=r,r=[]),n.method=!</span><span class="s2">1</span><span class="s0">,(e||t)&amp;&amp;(i=</span><span class="s1">this</span><span class="s0">.state.start,s=</span><span class="s1">this</span><span class="s0">.state.startLoc),e||(a=</span><span class="s1">this</span><span class="s0">.eat(c.star));const p=</span><span class="s1">this</span><span class="s0">.state.containsEsc,u=</span><span class="s1">this</span><span class="s0">.parsePropertyName(n,!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!e&amp;&amp;!a&amp;&amp;!p&amp;&amp;</span><span class="s1">this</span><span class="s0">.maybeAsyncOrAccessorProp(n)){const e=u.name;</span><span class="s3">&quot;async&quot;</span><span class="s0">!==e||</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()||(o=!</span><span class="s2">0</span><span class="s0">,a=</span><span class="s1">this</span><span class="s0">.eat(c.star),</span><span class="s1">this</span><span class="s0">.parsePropertyName(n,!</span><span class="s2">1</span><span class="s0">)),</span><span class="s3">&quot;get&quot;</span><span class="s0">!==e&amp;&amp;</span><span class="s3">&quot;set&quot;</span><span class="s0">!==e||(l=!</span><span class="s2">0</span><span class="s0">,n.kind=e,</span><span class="s1">this</span><span class="s0">.match(c.star)&amp;&amp;(a=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.AccessorIsGenerator,e),</span><span class="s1">this</span><span class="s0">.next()),</span><span class="s1">this</span><span class="s0">.parsePropertyName(n,!</span><span class="s2">1</span><span class="s0">))}</span><span class="s1">return this</span><span class="s0">.parseObjPropValue(n,i,s,a,o,e,l,t),n}getGetterSetterExpectedParamCount(e){</span><span class="s1">return</span><span class="s3">&quot;get&quot;</span><span class="s0">===e.kind?</span><span class="s2">0</span><span class="s0">:</span><span class="s2">1</span><span class="s0">}getObjectOrClassMethodParams(e){</span><span class="s1">return </span><span class="s0">e.params}checkGetterSetterParams(e){</span><span class="s1">var </span><span class="s0">t;const r=</span><span class="s1">this</span><span class="s0">.getGetterSetterExpectedParamCount(e),n=</span><span class="s1">this</span><span class="s0">.getObjectOrClassMethodParams(e),i=e.start;n.length!==r&amp;&amp;(</span><span class="s3">&quot;get&quot;</span><span class="s0">===e.kind?</span><span class="s1">this</span><span class="s0">.raise(i,E.BadGetterArity):</span><span class="s1">this</span><span class="s0">.raise(i,E.BadSetterArity)),</span><span class="s3">&quot;set&quot;</span><span class="s0">===e.kind&amp;&amp;</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">===(</span><span class="s1">null</span><span class="s0">==(t=n[n.length-1])?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.type)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(i,E.BadSetterRestParameter)}parseObjectMethod(e,t,r,n,i){</span><span class="s1">return </span><span class="s0">i?(</span><span class="s1">this</span><span class="s0">.parseMethod(e,t,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.checkGetterSetterParams(e),e):r||t||</span><span class="s1">this</span><span class="s0">.match(c.parenL)?(n&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),e.kind=</span><span class="s3">&quot;method&quot;</span><span class="s0">,e.method=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseMethod(e,t,r,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">)):</span><span class="s1">void </span><span class="s2">0</span><span class="s0">}parseObjectProperty(e,t,r,n,i){</span><span class="s1">return </span><span class="s0">e.shorthand=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.eat(c.colon)?(e.value=n?</span><span class="s1">this</span><span class="s0">.parseMaybeDefault(</span><span class="s1">this</span><span class="s0">.state.start,</span><span class="s1">this</span><span class="s0">.state.startLoc):</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(i),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">)):e.computed||</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==e.key.type?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:(</span><span class="s1">this</span><span class="s0">.checkReservedWord(e.key.name,e.key.start,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),n?e.value=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault(t,r,e.key.__clone()):</span><span class="s1">this</span><span class="s0">.match(c.eq)&amp;&amp;i?(-</span><span class="s2">1</span><span class="s0">===i.shorthandAssign&amp;&amp;(i.shorthandAssign=</span><span class="s1">this</span><span class="s0">.state.start),e.value=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault(t,r,e.key.__clone())):e.value=e.key.__clone(),e.shorthand=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">))}parseObjPropValue(e,t,r,n,i,s,a,o){const l=</span><span class="s1">this</span><span class="s0">.parseObjectMethod(e,n,i,s,a)||</span><span class="s1">this</span><span class="s0">.parseObjectProperty(e,t,r,s,o);</span><span class="s1">return </span><span class="s0">l||</span><span class="s1">this</span><span class="s0">.unexpected(),l}parsePropertyName(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.bracketL))e.computed=!</span><span class="s2">0</span><span class="s0">,e.key=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),</span><span class="s1">this</span><span class="s0">.expect(c.bracketR);</span><span class="s1">else</span><span class="s0">{const r=</span><span class="s1">this</span><span class="s0">.state.inPropertyName;</span><span class="s1">this</span><span class="s0">.state.inPropertyName=!</span><span class="s2">0</span><span class="s0">;const n=</span><span class="s1">this</span><span class="s0">.state.type;e.key=n===c.num||n===c.string||n===c.bigint||n===c.decimal?</span><span class="s1">this</span><span class="s0">.parseExprAtom():</span><span class="s1">this</span><span class="s0">.parseMaybePrivateName(t),n!==c.privateName&amp;&amp;(e.computed=!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.inPropertyName=r}</span><span class="s1">return </span><span class="s0">e.key}initFunction(e,t){e.id=</span><span class="s1">null</span><span class="s0">,e.generator=!</span><span class="s2">1</span><span class="s0">,e.async=!!t}parseMethod(e,t,r,n,i,s,a=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.initFunction(e,r),e.generator=!!t;const o=n;</span><span class="s1">return this</span><span class="s0">.scope.enter(</span><span class="s2">18</span><span class="s0">|(a?</span><span class="s2">64</span><span class="s0">:</span><span class="s2">0</span><span class="s0">)|(i?</span><span class="s2">32</span><span class="s0">:</span><span class="s2">0</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.prodParam.enter(ue(r,e.generator)),</span><span class="s1">this</span><span class="s0">.parseFunctionParams(e,o),</span><span class="s1">this</span><span class="s0">.parseFunctionBodyAndFinish(e,s,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit(),e}parseArrayLike(e,t,r,n){r&amp;&amp;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">);const i=</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody;</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=!</span><span class="s2">1</span><span class="s0">;const s=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),s.elements=</span><span class="s1">this</span><span class="s0">.parseExprList(e,!r,n,s),</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=i,</span><span class="s1">this</span><span class="s0">.finishNode(s,r?</span><span class="s3">&quot;TupleExpression&quot;</span><span class="s0">:</span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s0">)}parseArrowExpression(e,t,r,n){</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">6</span><span class="s0">);let i=ue(r,!</span><span class="s2">1</span><span class="s0">);!</span><span class="s1">this</span><span class="s0">.match(c.bracketL)&amp;&amp;</span><span class="s1">this</span><span class="s0">.prodParam.hasIn&amp;&amp;(i|=</span><span class="s2">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.enter(i),</span><span class="s1">this</span><span class="s0">.initFunction(e,r);const s=</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters;</span><span class="s1">return </span><span class="s0">t&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.setArrowFunctionParameters(e,t,n)),</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseFunctionBody(e,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=s,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">)}setArrowFunctionParameters(e,t,r){e.params=</span><span class="s1">this</span><span class="s0">.toAssignableList(t,r,!</span><span class="s2">1</span><span class="s0">)}parseFunctionBodyAndFinish(e,t,r=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.parseFunctionBody(e,!</span><span class="s2">1</span><span class="s0">,r),</span><span class="s1">this</span><span class="s0">.finishNode(e,t)}parseFunctionBody(e,t,r=!</span><span class="s2">1</span><span class="s0">){const n=t&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.braceL);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expressionScope.enter(je()),n)e.body=</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(),</span><span class="s1">this</span><span class="s0">.checkParams(e,!</span><span class="s2">1</span><span class="s0">,t,!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">else</span><span class="s0">{const n=</span><span class="s1">this</span><span class="s0">.state.strict,i=</span><span class="s1">this</span><span class="s0">.state.labels;</span><span class="s1">this</span><span class="s0">.state.labels=[],</span><span class="s1">this</span><span class="s0">.prodParam.enter(</span><span class="s2">4</span><span class="s0">|</span><span class="s1">this</span><span class="s0">.prodParam.currentFlags()),e.body=</span><span class="s1">this</span><span class="s0">.parseBlock(!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,(i=&gt;{const s=!</span><span class="s1">this</span><span class="s0">.isSimpleParamList(e.params);</span><span class="s1">if</span><span class="s0">(i&amp;&amp;s){const t=</span><span class="s3">&quot;method&quot;</span><span class="s0">!==e.kind&amp;&amp;</span><span class="s3">&quot;constructor&quot;</span><span class="s0">!==e.kind||!e.key?e.start:e.key.end;</span><span class="s1">this</span><span class="s0">.raise(t,E.IllegalLanguageModeDirective)}const a=!n&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.strict;</span><span class="s1">this</span><span class="s0">.checkParams(e,!(</span><span class="s1">this</span><span class="s0">.state.strict||t||r||s),t,a),</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;e.id&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,</span><span class="s3">&quot;function name&quot;</span><span class="s0">,</span><span class="s2">65</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,a)})),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.expressionScope.exit(),</span><span class="s1">this</span><span class="s0">.state.labels=i}}isSimpleParamList(e){</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">,r=e.length;t&lt;r;t++)</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==e[t].type)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}checkParams(e,t,r,n=!</span><span class="s2">0</span><span class="s0">){const i=</span><span class="s1">new </span><span class="s0">Set;</span><span class="s1">for</span><span class="s0">(const r of e.params)</span><span class="s1">this</span><span class="s0">.checkLVal(r,</span><span class="s3">&quot;function parameter list&quot;</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,t?</span><span class="s1">null</span><span class="s0">:i,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,n)}parseExprList(e,t,r,n){const i=[];let s=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.eat(e);){</span><span class="s1">if</span><span class="s0">(s)s=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.comma),</span><span class="s1">this</span><span class="s0">.match(e)){n&amp;&amp;</span><span class="s1">this</span><span class="s0">.addExtra(n,</span><span class="s3">&quot;trailingComma&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.lastTokStart),</span><span class="s1">this</span><span class="s0">.next();</span><span class="s1">break</span><span class="s0">}i.push(</span><span class="s1">this</span><span class="s0">.parseExprListItem(t,r))}</span><span class="s1">return </span><span class="s0">i}parseExprListItem(e,t,r,n){let i;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.comma))e||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,E.UnexpectedToken,</span><span class="s3">&quot;,&quot;</span><span class="s0">),i=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.ellipsis)){const e=</span><span class="s1">this</span><span class="s0">.state.start,n=</span><span class="s1">this</span><span class="s0">.state.startLoc;i=</span><span class="s1">this</span><span class="s0">.parseParenItem(</span><span class="s1">this</span><span class="s0">.parseSpread(t,r),e,n)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.question)){</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;partialApplication&quot;</span><span class="s0">),n||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.UnexpectedArgumentPlaceholder);const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.next(),i=</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ArgumentPlaceholder&quot;</span><span class="s0">)}</span><span class="s1">else </span><span class="s0">i=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(t,</span><span class="s1">this</span><span class="s0">.parseParenItem,r);</span><span class="s1">return </span><span class="s0">i}parseIdentifier(e){const t=</span><span class="s1">this</span><span class="s0">.startNode(),r=</span><span class="s1">this</span><span class="s0">.parseIdentifierName(t.start,e);</span><span class="s1">return this</span><span class="s0">.createIdentifier(t,r)}createIdentifier(e,t){</span><span class="s1">return </span><span class="s0">e.name=t,e.loc.identifierName=t,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)}parseIdentifierName(e,t){let r;const{start:n,type:i}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">if</span><span class="s0">(i===c.name)r=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!i.keyword)</span><span class="s1">throw this</span><span class="s0">.unexpected();{r=i.keyword;const e=</span><span class="s1">this</span><span class="s0">.curContext();i!==c._class&amp;&amp;i!==c._function||e!==O.functionStatement&amp;&amp;e!==O.functionExpression||</span><span class="s1">this</span><span class="s0">.state.context.pop()}}</span><span class="s1">return </span><span class="s0">t?</span><span class="s1">this</span><span class="s0">.state.type=c.name:</span><span class="s1">this</span><span class="s0">.checkReservedWord(r,n,!!i.keyword,!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),r}checkReservedWord(e,t,r,n){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.prodParam.hasYield&amp;&amp;</span><span class="s3">&quot;yield&quot;</span><span class="s0">===e)</span><span class="s1">this</span><span class="s0">.raise(t,E.YieldBindingIdentifier);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;await&quot;</span><span class="s0">===e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.prodParam.hasAwait)</span><span class="s1">return void this</span><span class="s0">.raise(t,E.AwaitBindingIdentifier);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.scope.inStaticBlock&amp;&amp;!</span><span class="s1">this</span><span class="s0">.scope.inNonArrowFunction)</span><span class="s1">return void this</span><span class="s0">.raise(t,E.AwaitBindingIdentifierInStaticBlock);</span><span class="s1">this</span><span class="s0">.expressionScope.recordAsyncArrowParametersError(t,E.AwaitBindingIdentifier)}!</span><span class="s1">this</span><span class="s0">.scope.inClass||</span><span class="s1">this</span><span class="s0">.scope.inNonArrowFunction||</span><span class="s3">&quot;arguments&quot;</span><span class="s0">!==e?r&amp;&amp;Y(e)?</span><span class="s1">this</span><span class="s0">.raise(t,E.UnexpectedKeyword,e):(</span><span class="s1">this</span><span class="s0">.state.strict?n?q:V:U)(e,</span><span class="s1">this</span><span class="s0">.inModule)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,E.UnexpectedReservedWord,e):</span><span class="s1">this</span><span class="s0">.raise(t,E.ArgumentsInClass)}}isAwaitAllowed(){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.prodParam.hasAwait||!(!</span><span class="s1">this</span><span class="s0">.options.allowAwaitOutsideFunction||</span><span class="s1">this</span><span class="s0">.scope.inFunction)}parseAwait(e,t){const r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);</span><span class="s1">return this</span><span class="s0">.expressionScope.recordParameterInitializerError(r.start,E.AwaitExpressionFormalParameter),</span><span class="s1">this</span><span class="s0">.eat(c.star)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r.start,E.ObsoleteAwaitStar),</span><span class="s1">this</span><span class="s0">.scope.inFunction||</span><span class="s1">this</span><span class="s0">.options.allowAwaitOutsideFunction||(</span><span class="s1">this</span><span class="s0">.isAmbiguousAwait()?</span><span class="s1">this</span><span class="s0">.ambiguousScriptDifferentAst=!</span><span class="s2">0</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.sawUnambiguousESM=!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.soloAwait||(r.argument=</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(</span><span class="s1">null</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;AwaitExpression&quot;</span><span class="s0">)}isAmbiguousAwait(){</span><span class="s1">return this</span><span class="s0">.hasPrecedingLineBreak()||</span><span class="s1">this</span><span class="s0">.match(c.plusMin)||</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.match(c.bracketL)||</span><span class="s1">this</span><span class="s0">.match(c.backQuote)||</span><span class="s1">this</span><span class="s0">.match(c.regexp)||</span><span class="s1">this</span><span class="s0">.match(c.slash)||</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;v8intrinsic&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.modulo)}parseYield(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expressionScope.recordParameterInitializerError(e.start,E.YieldInParameter),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.semi)||!</span><span class="s1">this</span><span class="s0">.match(c.star)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.type.startsExpr||</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()?(e.delegate=!</span><span class="s2">1</span><span class="s0">,e.argument=</span><span class="s1">null</span><span class="s0">):(e.delegate=</span><span class="s1">this</span><span class="s0">.eat(c.star),e.argument=</span><span class="s1">this</span><span class="s0">.parseMaybeAssign()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;YieldExpression&quot;</span><span class="s0">)}checkPipelineAtInfixOperator(e,t){</span><span class="s3">&quot;smart&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;pipelineOperator&quot;</span><span class="s0">,</span><span class="s3">&quot;proposal&quot;</span><span class="s0">)&amp;&amp;</span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,E.PipelineHeadSequenceExpression)}parseSmartPipelineBody(e,t,r){</span><span class="s1">return this</span><span class="s0">.checkSmartPipelineBodyEarlyErrors(e,t),</span><span class="s1">this</span><span class="s0">.parseSmartPipelineBodyInStyle(e,t,r)}checkSmartPipelineBodyEarlyErrors(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.arrow))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.PipelineBodyNoArrow);</span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,E.PipelineBodySequenceExpression)}parseSmartPipelineBodyInStyle(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r),i=</span><span class="s1">this</span><span class="s0">.isSimpleReference(e);</span><span class="s1">return </span><span class="s0">i?n.callee=e:(</span><span class="s1">this</span><span class="s0">.topicReferenceWasUsedInCurrentTopicContext()||</span><span class="s1">this</span><span class="s0">.raise(t,E.PipelineTopicUnused),n.expression=e),</span><span class="s1">this</span><span class="s0">.finishNode(n,i?</span><span class="s3">&quot;PipelineBareFunction&quot;</span><span class="s0">:</span><span class="s3">&quot;PipelineTopicExpression&quot;</span><span class="s0">)}isSimpleReference(e){</span><span class="s1">switch</span><span class="s0">(e.type){</span><span class="s1">case</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!e.computed&amp;&amp;</span><span class="s1">this</span><span class="s0">.isSimpleReference(e.object);</span><span class="s1">case</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}}withTopicPermittingContext(e){const t=</span><span class="s1">this</span><span class="s0">.state.topicContext;</span><span class="s1">this</span><span class="s0">.state.topicContext={maxNumOfResolvableTopics:</span><span class="s2">1</span><span class="s0">,maxTopicIndex:</span><span class="s1">null</span><span class="s0">};</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.topicContext=t}}withTopicForbiddingContext(e){const t=</span><span class="s1">this</span><span class="s0">.state.topicContext;</span><span class="s1">this</span><span class="s0">.state.topicContext={maxNumOfResolvableTopics:</span><span class="s2">0</span><span class="s0">,maxTopicIndex:</span><span class="s1">null</span><span class="s0">};</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.topicContext=t}}withSoloAwaitPermittingContext(e){const t=</span><span class="s1">this</span><span class="s0">.state.soloAwait;</span><span class="s1">this</span><span class="s0">.state.soloAwait=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.soloAwait=t}}allowInAnd(e){const t=</span><span class="s1">this</span><span class="s0">.prodParam.currentFlags();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">8</span><span class="s0">&amp;~t){</span><span class="s1">this</span><span class="s0">.prodParam.enter(</span><span class="s2">8</span><span class="s0">|t);</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.prodParam.exit()}}</span><span class="s1">return </span><span class="s0">e()}disallowInAnd(e){const t=</span><span class="s1">this</span><span class="s0">.prodParam.currentFlags();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">8</span><span class="s0">&amp;t){</span><span class="s1">this</span><span class="s0">.prodParam.enter(-</span><span class="s2">9</span><span class="s0">&amp;t);</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.prodParam.exit()}}</span><span class="s1">return </span><span class="s0">e()}registerTopicReference(){</span><span class="s1">this</span><span class="s0">.state.topicContext.maxTopicIndex=</span><span class="s2">0</span><span class="s0">}primaryTopicReferenceIsAllowedInCurrentTopicContext(){</span><span class="s1">return this</span><span class="s0">.state.topicContext.maxNumOfResolvableTopics&gt;=</span><span class="s2">1</span><span class="s0">}topicReferenceWasUsedInCurrentTopicContext(){</span><span class="s1">return null</span><span class="s0">!=</span><span class="s1">this</span><span class="s0">.state.topicContext.maxTopicIndex&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.topicContext.maxTopicIndex&gt;=</span><span class="s2">0</span><span class="s0">}parseFSharpPipelineBody(e){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt=</span><span class="s1">this</span><span class="s0">.state.start;const n=</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody;</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=!</span><span class="s2">0</span><span class="s0">;const i=</span><span class="s1">this</span><span class="s0">.parseExprOp(</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(),t,r,e);</span><span class="s1">return this</span><span class="s0">.state.inFSharpPipelineDirectBody=n,i}parseModuleExpression(){</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;moduleBlocks&quot;</span><span class="s0">);const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.eat(c.braceL);const t=</span><span class="s1">this</span><span class="s0">.initializeScopes(!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.enterInitialScopes();const r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">try</span><span class="s0">{e.body=</span><span class="s1">this</span><span class="s0">.parseProgram(r,c.braceR,</span><span class="s3">&quot;module&quot;</span><span class="s0">)}</span><span class="s1">finally</span><span class="s0">{t()}</span><span class="s1">return this</span><span class="s0">.eat(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ModuleExpression&quot;</span><span class="s0">)}}const Ye={kind:</span><span class="s3">&quot;loop&quot;</span><span class="s0">},We={kind:</span><span class="s3">&quot;switch&quot;</span><span class="s0">},Xe=/[\uD800-\uDFFF]/u;class Je extends qe{parseTopLevel(e,t){</span><span class="s1">return </span><span class="s0">e.program=</span><span class="s1">this</span><span class="s0">.parseProgram(t),e.comments=</span><span class="s1">this</span><span class="s0">.state.comments,</span><span class="s1">this</span><span class="s0">.options.tokens&amp;&amp;(e.tokens=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">;t&lt;e.length;t++){const r=e[t];</span><span class="s1">if</span><span class="s0">(r.type===c.privateName){const{loc:n,start:i,value:s,end:a}=r,o=i+</span><span class="s2">1</span><span class="s0">,l=</span><span class="s1">new </span><span class="s0">y(n.start.line,n.start.column+</span><span class="s2">1</span><span class="s0">);e.splice(t,</span><span class="s2">1</span><span class="s0">,</span><span class="s1">new </span><span class="s0">Ne({type:c.hash,value:</span><span class="s3">&quot;#&quot;</span><span class="s0">,start:i,end:o,startLoc:n.start,endLoc:l}),</span><span class="s1">new </span><span class="s0">Ne({type:c.name,value:s,start:o,end:a,startLoc:l,endLoc:n.end}))}}</span><span class="s1">return </span><span class="s0">e}(</span><span class="s1">this</span><span class="s0">.tokens)),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;File&quot;</span><span class="s0">)}parseProgram(e,t=c.eof,r=</span><span class="s1">this</span><span class="s0">.options.sourceType){</span><span class="s1">if</span><span class="s0">(e.sourceType=r,e.interpreter=</span><span class="s1">this</span><span class="s0">.parseInterpreterDirective(),</span><span class="s1">this</span><span class="s0">.parseBlockBody(e,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">,t),</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;!</span><span class="s1">this</span><span class="s0">.options.allowUndeclaredExports&amp;&amp;</span><span class="s1">this</span><span class="s0">.scope.undefinedExports.size&gt;</span><span class="s2">0</span><span class="s0">)</span><span class="s1">for</span><span class="s0">(const[e]of Array.from(</span><span class="s1">this</span><span class="s0">.scope.undefinedExports)){const t=</span><span class="s1">this</span><span class="s0">.scope.undefinedExports.get(e);</span><span class="s1">this</span><span class="s0">.raise(t,E.ModuleExportUndefined,e)}</span><span class="s1">return this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;Program&quot;</span><span class="s0">)}stmtToDirective(e){const t=e.expression,r=</span><span class="s1">this</span><span class="s0">.startNodeAt(t.start,t.loc.start),n=</span><span class="s1">this</span><span class="s0">.startNodeAt(e.start,e.loc.start),i=</span><span class="s1">this</span><span class="s0">.input.slice(t.start,t.end),s=r.value=i.slice(</span><span class="s2">1</span><span class="s0">,-</span><span class="s2">1</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.addExtra(r,</span><span class="s3">&quot;raw&quot;</span><span class="s0">,i),</span><span class="s1">this</span><span class="s0">.addExtra(r,</span><span class="s3">&quot;rawValue&quot;</span><span class="s0">,s),n.value=</span><span class="s1">this</span><span class="s0">.finishNodeAt(r,</span><span class="s3">&quot;DirectiveLiteral&quot;</span><span class="s0">,t.end,t.loc.end),</span><span class="s1">this</span><span class="s0">.finishNodeAt(n,</span><span class="s3">&quot;Directive&quot;</span><span class="s0">,e.end,e.loc.end)}parseInterpreterDirective(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c.interpreterDirective))</span><span class="s1">return null</span><span class="s0">;const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.value=</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;InterpreterDirective&quot;</span><span class="s0">)}isLet(e){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;let&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isLetKeyword(e)}isLetKeyword(e){const t=</span><span class="s1">this</span><span class="s0">.nextTokenStart(),r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(t);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">92</span><span class="s0">===r||</span><span class="s2">91</span><span class="s0">===r)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">123</span><span class="s0">===r)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(M(r)){let e=t+</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;j(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e));)++e;const r=</span><span class="s1">this</span><span class="s0">.input.slice(t,e);</span><span class="s1">if</span><span class="s0">(!W.test(r))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}parseStatement(e,t){</span><span class="s1">return this</span><span class="s0">.match(c.at)&amp;&amp;</span><span class="s1">this</span><span class="s0">.parseDecorators(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parseStatementContent(e,t)}parseStatementContent(e,t){let r=</span><span class="s1">this</span><span class="s0">.state.type;const n=</span><span class="s1">this</span><span class="s0">.startNode();let i;</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isLet(e)&amp;&amp;(r=c._var,i=</span><span class="s3">&quot;let&quot;</span><span class="s0">),r){</span><span class="s1">case </span><span class="s0">c._break:</span><span class="s1">case </span><span class="s0">c._continue:</span><span class="s1">return this</span><span class="s0">.parseBreakContinueStatement(n,r.keyword);</span><span class="s1">case </span><span class="s0">c._debugger:</span><span class="s1">return this</span><span class="s0">.parseDebuggerStatement(n);</span><span class="s1">case </span><span class="s0">c._do:</span><span class="s1">return this</span><span class="s0">.parseDoStatement(n);</span><span class="s1">case </span><span class="s0">c._for:</span><span class="s1">return this</span><span class="s0">.parseForStatement(n);</span><span class="s1">case </span><span class="s0">c._function:</span><span class="s1">if</span><span class="s0">(</span><span class="s2">46</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.lookaheadCharCode())</span><span class="s1">break</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.strict?</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.StrictFunction):</span><span class="s3">&quot;if&quot;</span><span class="s0">!==e&amp;&amp;</span><span class="s3">&quot;label&quot;</span><span class="s0">!==e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.SloppyFunction)),</span><span class="s1">this</span><span class="s0">.parseFunctionStatement(n,!</span><span class="s2">1</span><span class="s0">,!e);</span><span class="s1">case </span><span class="s0">c._class:</span><span class="s1">return </span><span class="s0">e&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.parseClass(n,!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._if:</span><span class="s1">return this</span><span class="s0">.parseIfStatement(n);</span><span class="s1">case </span><span class="s0">c._return:</span><span class="s1">return this</span><span class="s0">.parseReturnStatement(n);</span><span class="s1">case </span><span class="s0">c._switch:</span><span class="s1">return this</span><span class="s0">.parseSwitchStatement(n);</span><span class="s1">case </span><span class="s0">c._throw:</span><span class="s1">return this</span><span class="s0">.parseThrowStatement(n);</span><span class="s1">case </span><span class="s0">c._try:</span><span class="s1">return this</span><span class="s0">.parseTryStatement(n);</span><span class="s1">case </span><span class="s0">c._const:</span><span class="s1">case </span><span class="s0">c._var:</span><span class="s1">return </span><span class="s0">i=i||</span><span class="s1">this</span><span class="s0">.state.value,e&amp;&amp;</span><span class="s3">&quot;var&quot;</span><span class="s0">!==i&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.UnexpectedLexicalDeclaration),</span><span class="s1">this</span><span class="s0">.parseVarStatement(n,i);</span><span class="s1">case </span><span class="s0">c._while:</span><span class="s1">return this</span><span class="s0">.parseWhileStatement(n);</span><span class="s1">case </span><span class="s0">c._with:</span><span class="s1">return this</span><span class="s0">.parseWithStatement(n);</span><span class="s1">case </span><span class="s0">c.braceL:</span><span class="s1">return this</span><span class="s0">.parseBlock();</span><span class="s1">case </span><span class="s0">c.semi:</span><span class="s1">return this</span><span class="s0">.parseEmptyStatement(n);</span><span class="s1">case </span><span class="s0">c._import:{const e=</span><span class="s1">this</span><span class="s0">.lookaheadCharCode();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">40</span><span class="s0">===e||</span><span class="s2">46</span><span class="s0">===e)</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case </span><span class="s0">c._export:{let e;</span><span class="s1">return this</span><span class="s0">.options.allowImportExportEverywhere||t||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.UnexpectedImportExport),</span><span class="s1">this</span><span class="s0">.next(),r===c._import?(e=</span><span class="s1">this</span><span class="s0">.parseImport(n),</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">!==e.type||e.importKind&amp;&amp;</span><span class="s3">&quot;value&quot;</span><span class="s0">!==e.importKind||(</span><span class="s1">this</span><span class="s0">.sawUnambiguousESM=!</span><span class="s2">0</span><span class="s0">)):(e=</span><span class="s1">this</span><span class="s0">.parseExport(n),(</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">!==e.type||e.exportKind&amp;&amp;</span><span class="s3">&quot;value&quot;</span><span class="s0">!==e.exportKind)&amp;&amp;(</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">!==e.type||e.exportKind&amp;&amp;</span><span class="s3">&quot;value&quot;</span><span class="s0">!==e.exportKind)&amp;&amp;</span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">!==e.type||(</span><span class="s1">this</span><span class="s0">.sawUnambiguousESM=!</span><span class="s2">0</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.assertModuleNodeAllowed(n),e}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isAsyncFunction())</span><span class="s1">return </span><span class="s0">e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.AsyncFunctionInSingleStatementContext),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseFunctionStatement(n,!</span><span class="s2">0</span><span class="s0">,!e)}const s=</span><span class="s1">this</span><span class="s0">.state.value,a=</span><span class="s1">this</span><span class="s0">.parseExpression();</span><span class="s1">return </span><span class="s0">r===c.name&amp;&amp;</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===a.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.colon)?</span><span class="s1">this</span><span class="s0">.parseLabeledStatement(n,s,a,e):</span><span class="s1">this</span><span class="s0">.parseExpressionStatement(n,a)}assertModuleNodeAllowed(e){</span><span class="s1">this</span><span class="s0">.options.allowImportExportEverywhere||</span><span class="s1">this</span><span class="s0">.inModule||</span><span class="s1">this</span><span class="s0">.raise(e.start,P.ImportOutsideModule)}takeDecorators(e){const t=</span><span class="s1">this</span><span class="s0">.state.decoratorStack[</span><span class="s1">this</span><span class="s0">.state.decoratorStack.length-1];t.length&amp;&amp;(e.decorators=t,</span><span class="s1">this</span><span class="s0">.resetStartLocationFromNode(e,t[</span><span class="s2">0</span><span class="s0">]),</span><span class="s1">this</span><span class="s0">.state.decoratorStack[</span><span class="s1">this</span><span class="s0">.state.decoratorStack.length-1]=[])}canHaveLeadingDecorator(){</span><span class="s1">return this</span><span class="s0">.match(c._class)}parseDecorators(e){const t=</span><span class="s1">this</span><span class="s0">.state.decoratorStack[</span><span class="s1">this</span><span class="s0">.state.decoratorStack.length-1];</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.match(c.at);){const e=</span><span class="s1">this</span><span class="s0">.parseDecorator();t.push(e)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._export))e||</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">,</span><span class="s3">&quot;decoratorsBeforeExport&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.DecoratorExportClass);</span><span class="s1">else if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.canHaveLeadingDecorator())</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.UnexpectedLeadingDecorator)}parseDecorator(){</span><span class="s1">this</span><span class="s0">.expectOnePlugin([</span><span class="s3">&quot;decorators-legacy&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">]);const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.state.decoratorStack.push([]);const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.state.startLoc;let n;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.parenL))n=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.expect(c.parenR);</span><span class="s1">else for</span><span class="s0">(n=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.eat(c.dot);){const e=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);e.object=n,e.property=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),e.computed=!</span><span class="s2">1</span><span class="s0">,n=</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">)}e.expression=</span><span class="s1">this</span><span class="s0">.parseMaybeDecoratorArguments(n),</span><span class="s1">this</span><span class="s0">.state.decoratorStack.pop()}</span><span class="s1">else </span><span class="s0">e.expression=</span><span class="s1">this</span><span class="s0">.parseExprSubscripts();</span><span class="s1">return this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">)}parseMaybeDecoratorArguments(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.parenL)){const t=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e);</span><span class="s1">return </span><span class="s0">t.callee=e,t.arguments=</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(c.parenR,!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.toReferencedList(t.arguments),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;CallExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}parseBreakContinueStatement(e,t){const r=</span><span class="s3">&quot;break&quot;</span><span class="s0">===t;</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.isLineTerminator()?e.label=</span><span class="s1">null</span><span class="s0">:(e.label=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.semicolon()),</span><span class="s1">this</span><span class="s0">.verifyBreakContinue(e,t),</span><span class="s1">this</span><span class="s0">.finishNode(e,r?</span><span class="s3">&quot;BreakStatement&quot;</span><span class="s0">:</span><span class="s3">&quot;ContinueStatement&quot;</span><span class="s0">)}verifyBreakContinue(e,t){const r=</span><span class="s3">&quot;break&quot;</span><span class="s0">===t;let n;</span><span class="s1">for</span><span class="s0">(n=</span><span class="s2">0</span><span class="s0">;n&lt;</span><span class="s1">this</span><span class="s0">.state.labels.length;++n){const t=</span><span class="s1">this</span><span class="s0">.state.labels[n];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==e.label||t.name===e.label.name){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=t.kind&amp;&amp;(r||</span><span class="s3">&quot;loop&quot;</span><span class="s0">===t.kind))</span><span class="s1">break</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e.label&amp;&amp;r)</span><span class="s1">break</span><span class="s0">}}n===</span><span class="s1">this</span><span class="s0">.state.labels.length&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,E.IllegalBreakContinue,t)}parseDebuggerStatement(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DebuggerStatement&quot;</span><span class="s0">)}parseHeaderExpression(){</span><span class="s1">this</span><span class="s0">.expect(c.parenL);const e=</span><span class="s1">this</span><span class="s0">.parseExpression();</span><span class="s1">return this</span><span class="s0">.expect(c.parenR),e}parseDoStatement(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.state.labels.push(Ye),e.body=</span><span class="s1">this</span><span class="s0">.withTopicForbiddingContext((()=&gt;</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s3">&quot;do&quot;</span><span class="s0">))),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),</span><span class="s1">this</span><span class="s0">.expect(c._while),e.test=</span><span class="s1">this</span><span class="s0">.parseHeaderExpression(),</span><span class="s1">this</span><span class="s0">.eat(c.semi),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s0">)}parseForStatement(e){</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.state.labels.push(Ye);let t=-</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isAwaitAllowed()&amp;&amp;</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;await&quot;</span><span class="s0">)&amp;&amp;(t=</span><span class="s1">this</span><span class="s0">.state.lastTokStart),</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.parenL),</span><span class="s1">this</span><span class="s0">.match(c.semi))</span><span class="s1">return </span><span class="s0">t&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(t),</span><span class="s1">this</span><span class="s0">.parseFor(e,</span><span class="s1">null</span><span class="s0">);const r=</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;let&quot;</span><span class="s0">),n=r&amp;&amp;</span><span class="s1">this</span><span class="s0">.isLetKeyword();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._var)||</span><span class="s1">this</span><span class="s0">.match(c._const)||n){const r=</span><span class="s1">this</span><span class="s0">.startNode(),i=n?</span><span class="s3">&quot;let&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseVar(r,!</span><span class="s2">0</span><span class="s0">,i),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">),(</span><span class="s1">this</span><span class="s0">.match(c._in)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;of&quot;</span><span class="s0">))&amp;&amp;</span><span class="s2">1</span><span class="s0">===r.declarations.length?</span><span class="s1">this</span><span class="s0">.parseForIn(e,r,t):(t&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(t),</span><span class="s1">this</span><span class="s0">.parseFor(e,r))}const i=</span><span class="s1">this</span><span class="s0">.match(c.name)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.containsEsc,s=</span><span class="s1">new </span><span class="s0">Be,a=</span><span class="s1">this</span><span class="s0">.parseExpression(!</span><span class="s2">0</span><span class="s0">,s),o=</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;of&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(o&amp;&amp;(r?</span><span class="s1">this</span><span class="s0">.raise(a.start,E.ForOfLet):-</span><span class="s2">1</span><span class="s0">===t&amp;&amp;i&amp;&amp;</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===a.type&amp;&amp;</span><span class="s3">&quot;async&quot;</span><span class="s0">===a.name&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(a.start,E.ForOfAsync)),o||</span><span class="s1">this</span><span class="s0">.match(c._in)){</span><span class="s1">this</span><span class="s0">.toAssignable(a,!</span><span class="s2">0</span><span class="s0">);const r=o?</span><span class="s3">&quot;for-of statement&quot;</span><span class="s0">:</span><span class="s3">&quot;for-in statement&quot;</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.checkLVal(a,r),</span><span class="s1">this</span><span class="s0">.parseForIn(e,a,t)}</span><span class="s1">return this</span><span class="s0">.checkExpressionErrors(s,!</span><span class="s2">0</span><span class="s0">),t&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(t),</span><span class="s1">this</span><span class="s0">.parseFor(e,a)}parseFunctionStatement(e,t,r){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseFunction(e,</span><span class="s2">1</span><span class="s0">|(r?</span><span class="s2">0</span><span class="s0">:</span><span class="s2">2</span><span class="s0">),t)}parseIfStatement(e){</span><span class="s1">return this</span><span class="s0">.next(),e.test=</span><span class="s1">this</span><span class="s0">.parseHeaderExpression(),e.consequent=</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s3">&quot;if&quot;</span><span class="s0">),e.alternate=</span><span class="s1">this</span><span class="s0">.eat(c._else)?</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s3">&quot;if&quot;</span><span class="s0">):</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;IfStatement&quot;</span><span class="s0">)}parseReturnStatement(e){</span><span class="s1">return this</span><span class="s0">.prodParam.hasReturn||</span><span class="s1">this</span><span class="s0">.options.allowReturnOutsideFunction||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.IllegalReturn),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.isLineTerminator()?e.argument=</span><span class="s1">null</span><span class="s0">:(e.argument=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.semicolon()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ReturnStatement&quot;</span><span class="s0">)}parseSwitchStatement(e){</span><span class="s1">this</span><span class="s0">.next(),e.discriminant=</span><span class="s1">this</span><span class="s0">.parseHeaderExpression();const t=e.cases=[];let r;</span><span class="s1">this</span><span class="s0">.expect(c.braceL),</span><span class="s1">this</span><span class="s0">.state.labels.push(We),</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">0</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let e;!</span><span class="s1">this</span><span class="s0">.match(c.braceR);)</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._case)||</span><span class="s1">this</span><span class="s0">.match(c._default)){const n=</span><span class="s1">this</span><span class="s0">.match(c._case);r&amp;&amp;</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;SwitchCase&quot;</span><span class="s0">),t.push(r=</span><span class="s1">this</span><span class="s0">.startNode()),r.consequent=[],</span><span class="s1">this</span><span class="s0">.next(),n?r.test=</span><span class="s1">this</span><span class="s0">.parseExpression():(e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,E.MultipleDefaultsInSwitch),e=!</span><span class="s2">0</span><span class="s0">,r.test=</span><span class="s1">null</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.colon)}</span><span class="s1">else </span><span class="s0">r?r.consequent.push(</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s1">null</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.unexpected();</span><span class="s1">return this</span><span class="s0">.scope.exit(),r&amp;&amp;</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;SwitchCase&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;SwitchStatement&quot;</span><span class="s0">)}parseThrowStatement(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,E.NewlineAfterThrow),e.argument=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ThrowStatement&quot;</span><span class="s0">)}parseCatchClauseParam(){const e=</span><span class="s1">this</span><span class="s0">.parseBindingAtom(),t=</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type;</span><span class="s1">return this</span><span class="s0">.scope.enter(t?</span><span class="s2">8</span><span class="s0">:</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.checkLVal(e,</span><span class="s3">&quot;catch clause&quot;</span><span class="s0">,</span><span class="s2">9</span><span class="s0">),e}parseTryStatement(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),e.block=</span><span class="s1">this</span><span class="s0">.parseBlock(),e.handler=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(c._catch)){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.parenL)?(</span><span class="s1">this</span><span class="s0">.expect(c.parenL),t.param=</span><span class="s1">this</span><span class="s0">.parseCatchClauseParam(),</span><span class="s1">this</span><span class="s0">.expect(c.parenR)):(t.param=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">0</span><span class="s0">)),t.body=</span><span class="s1">this</span><span class="s0">.withTopicForbiddingContext((()=&gt;</span><span class="s1">this</span><span class="s0">.parseBlock(!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">))),</span><span class="s1">this</span><span class="s0">.scope.exit(),e.handler=</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;CatchClause&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e.finalizer=</span><span class="s1">this</span><span class="s0">.eat(c._finally)?</span><span class="s1">this</span><span class="s0">.parseBlock():</span><span class="s1">null</span><span class="s0">,e.handler||e.finalizer||</span><span class="s1">this</span><span class="s0">.raise(e.start,E.NoCatchOrFinally),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TryStatement&quot;</span><span class="s0">)}parseVarStatement(e,t){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseVar(e,!</span><span class="s2">1</span><span class="s0">,t),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">)}parseWhileStatement(e){</span><span class="s1">return this</span><span class="s0">.next(),e.test=</span><span class="s1">this</span><span class="s0">.parseHeaderExpression(),</span><span class="s1">this</span><span class="s0">.state.labels.push(Ye),e.body=</span><span class="s1">this</span><span class="s0">.withTopicForbiddingContext((()=&gt;</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s3">&quot;while&quot;</span><span class="s0">))),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;WhileStatement&quot;</span><span class="s0">)}parseWithStatement(e){</span><span class="s1">return this</span><span class="s0">.state.strict&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.StrictWith),</span><span class="s1">this</span><span class="s0">.next(),e.object=</span><span class="s1">this</span><span class="s0">.parseHeaderExpression(),e.body=</span><span class="s1">this</span><span class="s0">.withTopicForbiddingContext((()=&gt;</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s3">&quot;with&quot;</span><span class="s0">))),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;WithStatement&quot;</span><span class="s0">)}parseEmptyStatement(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EmptyStatement&quot;</span><span class="s0">)}parseLabeledStatement(e,t,r,n){</span><span class="s1">for</span><span class="s0">(const e of </span><span class="s1">this</span><span class="s0">.state.labels)e.name===t&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r.start,E.LabelRedeclaration,t);const i=</span><span class="s1">this</span><span class="s0">.state.type.isLoop?</span><span class="s3">&quot;loop&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.match(c._switch)?</span><span class="s3">&quot;switch&quot;</span><span class="s0">:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s1">this</span><span class="s0">.state.labels.length-1;t&gt;=</span><span class="s2">0</span><span class="s0">;t--){const r=</span><span class="s1">this</span><span class="s0">.state.labels[t];</span><span class="s1">if</span><span class="s0">(r.statementStart!==e.start)</span><span class="s1">break</span><span class="s0">;r.statementStart=</span><span class="s1">this</span><span class="s0">.state.start,r.kind=i}</span><span class="s1">return this</span><span class="s0">.state.labels.push({name:t,kind:i,statementStart:</span><span class="s1">this</span><span class="s0">.state.start}),e.body=</span><span class="s1">this</span><span class="s0">.parseStatement(n?-</span><span class="s2">1</span><span class="s0">===n.indexOf(</span><span class="s3">&quot;label&quot;</span><span class="s0">)?n+</span><span class="s3">&quot;label&quot;</span><span class="s0">:n:</span><span class="s3">&quot;label&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),e.label=r,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;LabeledStatement&quot;</span><span class="s0">)}parseExpressionStatement(e,t){</span><span class="s1">return </span><span class="s0">e.expression=t,</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s0">)}parseBlock(e=!</span><span class="s2">1</span><span class="s0">,t=!</span><span class="s2">0</span><span class="s0">,r){const n=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.strictErrors.clear(),</span><span class="s1">this</span><span class="s0">.expect(c.braceL),t&amp;&amp;</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parseBlockBody(n,e,!</span><span class="s2">1</span><span class="s0">,c.braceR,r),t&amp;&amp;</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">)}isValidDirective(e){</span><span class="s1">return</span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===e.expression.type&amp;&amp;!e.expression.extra.parenthesized}parseBlockBody(e,t,r,n,i){const s=e.body=[],a=e.directives=[];</span><span class="s1">this</span><span class="s0">.parseBlockOrModuleBlockBody(s,t?a:</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,r,n,i)}parseBlockOrModuleBlockBody(e,t,r,n,i){const s=</span><span class="s1">this</span><span class="s0">.state.strict;let a=!</span><span class="s2">1</span><span class="s0">,o=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.match(n);){const n=</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s1">null</span><span class="s0">,r);</span><span class="s1">if</span><span class="s0">(t&amp;&amp;!o){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isValidDirective(n)){const e=</span><span class="s1">this</span><span class="s0">.stmtToDirective(n);t.push(e),a||</span><span class="s3">&quot;use strict&quot;</span><span class="s0">!==e.value.value||(a=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.setStrict(!</span><span class="s2">0</span><span class="s0">));</span><span class="s1">continue</span><span class="s0">}o=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.strictErrors.clear()}e.push(n)}i&amp;&amp;i.call(</span><span class="s1">this</span><span class="s0">,a),s||</span><span class="s1">this</span><span class="s0">.setStrict(!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next()}parseFor(e,t){</span><span class="s1">return </span><span class="s0">e.init=t,</span><span class="s1">this</span><span class="s0">.semicolon(!</span><span class="s2">1</span><span class="s0">),e.test=</span><span class="s1">this</span><span class="s0">.match(c.semi)?</span><span class="s1">null</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.semicolon(!</span><span class="s2">1</span><span class="s0">),e.update=</span><span class="s1">this</span><span class="s0">.match(c.parenR)?</span><span class="s1">null</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.expect(c.parenR),e.body=</span><span class="s1">this</span><span class="s0">.withTopicForbiddingContext((()=&gt;</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s3">&quot;for&quot;</span><span class="s0">))),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ForStatement&quot;</span><span class="s0">)}parseForIn(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.match(c._in);</span><span class="s1">return this</span><span class="s0">.next(),n?r&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(r):e.await=r&gt;-</span><span class="s2">1</span><span class="s0">,</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">!==t.type||</span><span class="s1">null</span><span class="s0">==t.declarations[</span><span class="s2">0</span><span class="s0">].init||n&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;</span><span class="s3">&quot;var&quot;</span><span class="s0">===t.kind&amp;&amp;</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===t.declarations[</span><span class="s2">0</span><span class="s0">].id.type?</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">===t.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,E.InvalidLhs,</span><span class="s3">&quot;for-loop&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.raise(t.start,E.ForInOfLoopInitializer,n?</span><span class="s3">&quot;for-in&quot;</span><span class="s0">:</span><span class="s3">&quot;for-of&quot;</span><span class="s0">),e.left=t,e.right=n?</span><span class="s1">this</span><span class="s0">.parseExpression():</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),</span><span class="s1">this</span><span class="s0">.expect(c.parenR),e.body=</span><span class="s1">this</span><span class="s0">.withTopicForbiddingContext((()=&gt;</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s3">&quot;for&quot;</span><span class="s0">))),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),</span><span class="s1">this</span><span class="s0">.finishNode(e,n?</span><span class="s3">&quot;ForInStatement&quot;</span><span class="s0">:</span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s0">)}parseVar(e,t,r){const n=e.declarations=[],i=</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;typescript&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(e.kind=r;;){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parseVarId(e,r),</span><span class="s1">this</span><span class="s0">.eat(c.eq)?e.init=t?</span><span class="s1">this</span><span class="s0">.parseMaybeAssignDisallowIn():</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn():(</span><span class="s3">&quot;const&quot;</span><span class="s0">!==r||</span><span class="s1">this</span><span class="s0">.match(c._in)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;of&quot;</span><span class="s0">)?</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.id.type||t&amp;&amp;(</span><span class="s1">this</span><span class="s0">.match(c._in)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;of&quot;</span><span class="s0">))||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,E.DeclarationMissingInitializer,</span><span class="s3">&quot;Complex binding patterns&quot;</span><span class="s0">):i||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,E.DeclarationMissingInitializer,</span><span class="s3">&quot;Const declarations&quot;</span><span class="s0">),e.init=</span><span class="s1">null</span><span class="s0">),n.push(</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s0">)),!</span><span class="s1">this</span><span class="s0">.eat(c.comma))</span><span class="s1">break</span><span class="s0">}</span><span class="s1">return </span><span class="s0">e}parseVarId(e,t){e.id=</span><span class="s1">this</span><span class="s0">.parseBindingAtom(),</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,</span><span class="s3">&quot;variable declaration&quot;</span><span class="s0">,</span><span class="s3">&quot;var&quot;</span><span class="s0">===t?</span><span class="s2">5</span><span class="s0">:</span><span class="s2">9</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s3">&quot;var&quot;</span><span class="s0">!==t)}parseFunction(e,t=</span><span class="s2">0</span><span class="s0">,r=!</span><span class="s2">1</span><span class="s0">){const n=</span><span class="s2">1</span><span class="s0">&amp;t,i=</span><span class="s2">2</span><span class="s0">&amp;t,s=!(!n||</span><span class="s2">4</span><span class="s0">&amp;t);</span><span class="s1">this</span><span class="s0">.initFunction(e,r),</span><span class="s1">this</span><span class="s0">.match(c.star)&amp;&amp;i&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.GeneratorInSingleStatementContext),e.generator=</span><span class="s1">this</span><span class="s0">.eat(c.star),n&amp;&amp;(e.id=</span><span class="s1">this</span><span class="s0">.parseFunctionId(s));const a=</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters;</span><span class="s1">return this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">2</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.enter(ue(r,e.generator)),n||(e.id=</span><span class="s1">this</span><span class="s0">.parseFunctionId()),</span><span class="s1">this</span><span class="s0">.parseFunctionParams(e,!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.withTopicForbiddingContext((()=&gt;{</span><span class="s1">this</span><span class="s0">.parseFunctionBodyAndFinish(e,n?</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">:</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">)})),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit(),n&amp;&amp;!i&amp;&amp;</span><span class="s1">this</span><span class="s0">.registerFunctionStatementId(e),</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=a,e}parseFunctionId(e){</span><span class="s1">return </span><span class="s0">e||</span><span class="s1">this</span><span class="s0">.match(c.name)?</span><span class="s1">this</span><span class="s0">.parseIdentifier():</span><span class="s1">null</span><span class="s0">}parseFunctionParams(e,t){</span><span class="s1">this</span><span class="s0">.expect(c.parenL),</span><span class="s1">this</span><span class="s0">.expressionScope.enter(</span><span class="s1">new </span><span class="s0">_e(</span><span class="s2">3</span><span class="s0">)),e.params=</span><span class="s1">this</span><span class="s0">.parseBindingList(c.parenR,</span><span class="s2">41</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,t),</span><span class="s1">this</span><span class="s0">.expressionScope.exit()}registerFunctionStatementId(e){e.id&amp;&amp;</span><span class="s1">this</span><span class="s0">.scope.declareName(e.id.name,</span><span class="s1">this</span><span class="s0">.state.strict||e.generator||e.async?</span><span class="s1">this</span><span class="s0">.scope.treatFunctionsAsVar?</span><span class="s2">5</span><span class="s0">:</span><span class="s2">9</span><span class="s0">:</span><span class="s2">17</span><span class="s0">,e.id.start)}parseClass(e,t,r){</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.takeDecorators(e);const n=</span><span class="s1">this</span><span class="s0">.state.strict;</span><span class="s1">return this</span><span class="s0">.state.strict=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseClassId(e,t,r),</span><span class="s1">this</span><span class="s0">.parseClassSuper(e),e.body=</span><span class="s1">this</span><span class="s0">.parseClassBody(!!e.superClass,n),</span><span class="s1">this</span><span class="s0">.finishNode(e,t?</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">:</span><span class="s3">&quot;ClassExpression&quot;</span><span class="s0">)}isClassProperty(){</span><span class="s1">return this</span><span class="s0">.match(c.eq)||</span><span class="s1">this</span><span class="s0">.match(c.semi)||</span><span class="s1">this</span><span class="s0">.match(c.braceR)}isClassMethod(){</span><span class="s1">return this</span><span class="s0">.match(c.parenL)}isNonstaticConstructor(e){</span><span class="s1">return</span><span class="s0">!(e.computed||e.static||</span><span class="s3">&quot;constructor&quot;</span><span class="s0">!==e.key.name&amp;&amp;</span><span class="s3">&quot;constructor&quot;</span><span class="s0">!==e.key.value)}parseClassBody(e,t){</span><span class="s1">this</span><span class="s0">.classScope.enter();const r={hadConstructor:!</span><span class="s2">1</span><span class="s0">,hadSuperClass:e};let n=[];const i=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(i.body=[],</span><span class="s1">this</span><span class="s0">.expect(c.braceL),</span><span class="s1">this</span><span class="s0">.withTopicForbiddingContext((()=&gt;{</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.match(c.braceR);){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.semi)){</span><span class="s1">if</span><span class="s0">(n.length&gt;</span><span class="s2">0</span><span class="s0">)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,E.DecoratorSemicolon);</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.at)){n.push(</span><span class="s1">this</span><span class="s0">.parseDecorator());</span><span class="s1">continue</span><span class="s0">}const e=</span><span class="s1">this</span><span class="s0">.startNode();n.length&amp;&amp;(e.decorators=n,</span><span class="s1">this</span><span class="s0">.resetStartLocationFromNode(e,n[</span><span class="s2">0</span><span class="s0">]),n=[]),</span><span class="s1">this</span><span class="s0">.parseClassMember(i,e,r),</span><span class="s3">&quot;constructor&quot;</span><span class="s0">===e.kind&amp;&amp;e.decorators&amp;&amp;e.decorators.length&gt;</span><span class="s2">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,E.DecoratorConstructor)}})),</span><span class="s1">this</span><span class="s0">.state.strict=t,</span><span class="s1">this</span><span class="s0">.next(),n.length)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.TrailingDecorator);</span><span class="s1">return this</span><span class="s0">.classScope.exit(),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s3">&quot;ClassBody&quot;</span><span class="s0">)}parseClassMemberFromModifier(e,t){const r=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isClassMethod()){const n=t;</span><span class="s1">return </span><span class="s0">n.kind=</span><span class="s3">&quot;method&quot;</span><span class="s0">,n.computed=!</span><span class="s2">1</span><span class="s0">,n.key=r,n.static=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.pushClassMethod(e,n,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isClassProperty()){const n=t;</span><span class="s1">return </span><span class="s0">n.computed=!</span><span class="s2">1</span><span class="s0">,n.key=r,n.static=!</span><span class="s2">1</span><span class="s0">,e.body.push(</span><span class="s1">this</span><span class="s0">.parseClassProperty(n)),!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}parseClassMember(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;static&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(n){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parseClassMemberFromModifier(e,t))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.braceL))</span><span class="s1">return void this</span><span class="s0">.parseClassStaticBlock(e,t)}</span><span class="s1">this</span><span class="s0">.parseClassMemberWithIsStatic(e,t,r,n)}parseClassMemberWithIsStatic(e,t,r,n){const i=t,s=t,a=t,o=t,l=i,p=i;</span><span class="s1">if</span><span class="s0">(t.static=n,</span><span class="s1">this</span><span class="s0">.eat(c.star)){l.kind=</span><span class="s3">&quot;method&quot;</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.match(c.privateName);</span><span class="s1">return this</span><span class="s0">.parseClassElementName(l),t?</span><span class="s1">void this</span><span class="s0">.pushClassPrivateMethod(e,s,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.isNonstaticConstructor(i)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(i.key.start,E.ConstructorIsGenerator),</span><span class="s1">void this</span><span class="s0">.pushClassMethod(e,i,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">))}const u=</span><span class="s1">this</span><span class="s0">.state.containsEsc,d=</span><span class="s1">this</span><span class="s0">.match(c.privateName),h=</span><span class="s1">this</span><span class="s0">.parseClassElementName(t),f=</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===h.type,m=</span><span class="s1">this</span><span class="s0">.state.start;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parsePostMemberNameModifiers(p),</span><span class="s1">this</span><span class="s0">.isClassMethod()){</span><span class="s1">if</span><span class="s0">(l.kind=</span><span class="s3">&quot;method&quot;</span><span class="s0">,d)</span><span class="s1">return void this</span><span class="s0">.pushClassPrivateMethod(e,s,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">);const n=</span><span class="s1">this</span><span class="s0">.isNonstaticConstructor(i);let a=!</span><span class="s2">1</span><span class="s0">;n&amp;&amp;(i.kind=</span><span class="s3">&quot;constructor&quot;</span><span class="s0">,r.hadConstructor&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;typescript&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(h.start,E.DuplicateConstructor),n&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;typescript&quot;</span><span class="s0">)&amp;&amp;t.override&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(h.start,E.OverrideOnConstructor),r.hadConstructor=!</span><span class="s2">0</span><span class="s0">,a=r.hadSuperClass),</span><span class="s1">this</span><span class="s0">.pushClassMethod(e,i,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,n,a)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isClassProperty())d?</span><span class="s1">this</span><span class="s0">.pushClassPrivateProperty(e,o):</span><span class="s1">this</span><span class="s0">.pushClassProperty(e,a);</span><span class="s1">else if</span><span class="s0">(!f||</span><span class="s3">&quot;async&quot;</span><span class="s0">!==h.name||u||</span><span class="s1">this</span><span class="s0">.isLineTerminator())</span><span class="s1">if</span><span class="s0">(!f||</span><span class="s3">&quot;get&quot;</span><span class="s0">!==h.name&amp;&amp;</span><span class="s3">&quot;set&quot;</span><span class="s0">!==h.name||u||</span><span class="s1">this</span><span class="s0">.match(c.star)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isLineTerminator())</span><span class="s1">this</span><span class="s0">.isLineTerminator()?d?</span><span class="s1">this</span><span class="s0">.pushClassPrivateProperty(e,o):</span><span class="s1">this</span><span class="s0">.pushClassProperty(e,a):</span><span class="s1">this</span><span class="s0">.unexpected();</span><span class="s1">else</span><span class="s0">{l.kind=h.name;const t=</span><span class="s1">this</span><span class="s0">.match(c.privateName);</span><span class="s1">this</span><span class="s0">.parseClassElementName(i),t?</span><span class="s1">this</span><span class="s0">.pushClassPrivateMethod(e,s,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.isNonstaticConstructor(i)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(i.key.start,E.ConstructorIsAccessor),</span><span class="s1">this</span><span class="s0">.pushClassMethod(e,i,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.checkGetterSetterParams(i)}</span><span class="s1">else</span><span class="s0">{const t=</span><span class="s1">this</span><span class="s0">.eat(c.star);p.optional&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(m),l.kind=</span><span class="s3">&quot;method&quot;</span><span class="s0">;const r=</span><span class="s1">this</span><span class="s0">.match(c.privateName);</span><span class="s1">this</span><span class="s0">.parseClassElementName(l),</span><span class="s1">this</span><span class="s0">.parsePostMemberNameModifiers(p),r?</span><span class="s1">this</span><span class="s0">.pushClassPrivateMethod(e,s,t,!</span><span class="s2">0</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.isNonstaticConstructor(i)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(i.key.start,E.ConstructorIsAsync),</span><span class="s1">this</span><span class="s0">.pushClassMethod(e,i,t,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">))}}parseClassElementName(e){const{type:t,value:r,start:n}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">return </span><span class="s0">t!==c.name&amp;&amp;t!==c.string||!e.static||</span><span class="s3">&quot;prototype&quot;</span><span class="s0">!==r||</span><span class="s1">this</span><span class="s0">.raise(n,E.StaticPrototype),t===c.privateName&amp;&amp;</span><span class="s3">&quot;constructor&quot;</span><span class="s0">===r&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(n,E.ConstructorClassPrivateField),</span><span class="s1">this</span><span class="s0">.parsePropertyName(e,!</span><span class="s2">0</span><span class="s0">)}parseClassStaticBlock(e,t){</span><span class="s1">var </span><span class="s0">r;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;classStaticBlock&quot;</span><span class="s0">,t.start),</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">208</span><span class="s0">);const n=</span><span class="s1">this</span><span class="s0">.state.labels;</span><span class="s1">this</span><span class="s0">.state.labels=[],</span><span class="s1">this</span><span class="s0">.prodParam.enter(</span><span class="s2">0</span><span class="s0">);const i=t.body=[];</span><span class="s1">this</span><span class="s0">.parseBlockOrModuleBlockBody(i,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,c.braceR),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.state.labels=n,e.body.push(</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;StaticBlock&quot;</span><span class="s0">)),</span><span class="s1">null</span><span class="s0">!=(r=t.decorators)&amp;&amp;r.length&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,E.DecoratorStaticBlock)}pushClassProperty(e,t){t.computed||</span><span class="s3">&quot;constructor&quot;</span><span class="s0">!==t.key.name&amp;&amp;</span><span class="s3">&quot;constructor&quot;</span><span class="s0">!==t.key.value||</span><span class="s1">this</span><span class="s0">.raise(t.key.start,E.ConstructorClassField),e.body.push(</span><span class="s1">this</span><span class="s0">.parseClassProperty(t))}pushClassPrivateProperty(e,t){const r=</span><span class="s1">this</span><span class="s0">.parseClassPrivateProperty(t);e.body.push(r),</span><span class="s1">this</span><span class="s0">.classScope.declarePrivateName(</span><span class="s1">this</span><span class="s0">.getPrivateNameSV(r.key),</span><span class="s2">0</span><span class="s0">,r.key.start)}pushClassMethod(e,t,r,n,i,s){e.body.push(</span><span class="s1">this</span><span class="s0">.parseMethod(t,r,n,i,s,</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">))}pushClassPrivateMethod(e,t,r,n){const i=</span><span class="s1">this</span><span class="s0">.parseMethod(t,r,n,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">);e.body.push(i);const s=</span><span class="s3">&quot;get&quot;</span><span class="s0">===i.kind?i.static?</span><span class="s2">6</span><span class="s0">:</span><span class="s2">2</span><span class="s0">:</span><span class="s3">&quot;set&quot;</span><span class="s0">===i.kind?i.static?</span><span class="s2">5</span><span class="s0">:</span><span class="s2">1</span><span class="s0">:</span><span class="s2">0</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.classScope.declarePrivateName(</span><span class="s1">this</span><span class="s0">.getPrivateNameSV(i.key),s,i.key.start)}parsePostMemberNameModifiers(e){}parseClassPrivateProperty(e){</span><span class="s1">return this</span><span class="s0">.parseInitializer(e),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ClassPrivateProperty&quot;</span><span class="s0">)}parseClassProperty(e){</span><span class="s1">return this</span><span class="s0">.parseInitializer(e),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ClassProperty&quot;</span><span class="s0">)}parseInitializer(e){</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">80</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expressionScope.enter(je()),</span><span class="s1">this</span><span class="s0">.prodParam.enter(</span><span class="s2">0</span><span class="s0">),e.value=</span><span class="s1">this</span><span class="s0">.eat(c.eq)?</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn():</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expressionScope.exit(),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit()}parseClassId(e,t,r,n=</span><span class="s2">139</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.match(c.name)?(e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),t&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,</span><span class="s3">&quot;class name&quot;</span><span class="s0">,n)):r||!t?e.id=</span><span class="s1">null</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,E.MissingClassName)}parseClassSuper(e){e.superClass=</span><span class="s1">this</span><span class="s0">.eat(c._extends)?</span><span class="s1">this</span><span class="s0">.parseExprSubscripts():</span><span class="s1">null</span><span class="s0">}parseExport(e){const t=</span><span class="s1">this</span><span class="s0">.maybeParseExportDefaultSpecifier(e),r=!t||</span><span class="s1">this</span><span class="s0">.eat(c.comma),n=r&amp;&amp;</span><span class="s1">this</span><span class="s0">.eatExportStar(e),i=n&amp;&amp;</span><span class="s1">this</span><span class="s0">.maybeParseExportNamespaceSpecifier(e),s=r&amp;&amp;(!i||</span><span class="s1">this</span><span class="s0">.eat(c.comma)),a=t||n;</span><span class="s1">if</span><span class="s0">(n&amp;&amp;!i)</span><span class="s1">return </span><span class="s0">t&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.parseExportFrom(e,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">);const o=</span><span class="s1">this</span><span class="s0">.maybeParseExportNamedSpecifiers(e);</span><span class="s1">if</span><span class="s0">(t&amp;&amp;r&amp;&amp;!n&amp;&amp;!o||i&amp;&amp;s&amp;&amp;!o)</span><span class="s1">throw this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,c.braceL);let l;</span><span class="s1">if</span><span class="s0">(a||o?(l=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseExportFrom(e,a)):l=</span><span class="s1">this</span><span class="s0">.maybeParseExportDeclaration(e),a||o||l)</span><span class="s1">return this</span><span class="s0">.checkExport(e,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!!e.source),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c._default))</span><span class="s1">return </span><span class="s0">e.declaration=</span><span class="s1">this</span><span class="s0">.parseExportDefaultExpression(),</span><span class="s1">this</span><span class="s0">.checkExport(e,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">);</span><span class="s1">throw this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,c.braceL)}eatExportStar(e){</span><span class="s1">return this</span><span class="s0">.eat(c.star)}maybeParseExportDefaultSpecifier(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isExportDefaultSpecifier()){</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;exportDefaultFrom&quot;</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">t.exported=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),e.specifiers=[</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;ExportDefaultSpecifier&quot;</span><span class="s0">)],!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}maybeParseExportNamespaceSpecifier(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">)){e.specifiers||(e.specifiers=[]);const t=</span><span class="s1">this</span><span class="s0">.startNodeAt(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc);</span><span class="s1">return this</span><span class="s0">.next(),t.exported=</span><span class="s1">this</span><span class="s0">.parseModuleExportName(),e.specifiers.push(</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;ExportNamespaceSpecifier&quot;</span><span class="s0">)),!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}maybeParseExportNamedSpecifiers(e){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.match(c.braceL)&amp;&amp;(e.specifiers||(e.specifiers=[]),e.specifiers.push(...</span><span class="s1">this</span><span class="s0">.parseExportSpecifiers()),e.source=</span><span class="s1">null</span><span class="s0">,e.declaration=</span><span class="s1">null</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">)}maybeParseExportDeclaration(e){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.shouldParseExportDeclaration()&amp;&amp;(e.specifiers=[],e.source=</span><span class="s1">null</span><span class="s0">,e.declaration=</span><span class="s1">this</span><span class="s0">.parseExportDeclaration(e),!</span><span class="s2">0</span><span class="s0">)}isAsyncFunction(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;async&quot;</span><span class="s0">))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const e=</span><span class="s1">this</span><span class="s0">.nextTokenStart();</span><span class="s1">return</span><span class="s0">!u.test(</span><span class="s1">this</span><span class="s0">.input.slice(</span><span class="s1">this</span><span class="s0">.state.pos,e))&amp;&amp;</span><span class="s1">this</span><span class="s0">.isUnparsedContextual(e,</span><span class="s3">&quot;function&quot;</span><span class="s0">)}parseExportDefaultExpression(){const e=</span><span class="s1">this</span><span class="s0">.startNode(),t=</span><span class="s1">this</span><span class="s0">.isAsyncFunction();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._function)||t)</span><span class="s1">return this</span><span class="s0">.next(),t&amp;&amp;</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseFunction(e,</span><span class="s2">5</span><span class="s0">,t);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._class))</span><span class="s1">return this</span><span class="s0">.parseClass(e,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.at))</span><span class="s1">return this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">,</span><span class="s3">&quot;decoratorsBeforeExport&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.DecoratorBeforeExport),</span><span class="s1">this</span><span class="s0">.parseDecorators(!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parseClass(e,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._const)||</span><span class="s1">this</span><span class="s0">.match(c._var)||</span><span class="s1">this</span><span class="s0">.isLet())</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.UnsupportedDefaultExport);{const e=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn();</span><span class="s1">return this</span><span class="s0">.semicolon(),e}}parseExportDeclaration(e){</span><span class="s1">return this</span><span class="s0">.parseStatement(</span><span class="s1">null</span><span class="s0">)}isExportDefaultSpecifier(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.name)){const e=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;async&quot;</span><span class="s0">===e&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.containsEsc||</span><span class="s3">&quot;let&quot;</span><span class="s0">===e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">((</span><span class="s3">&quot;type&quot;</span><span class="s0">===e||</span><span class="s3">&quot;interface&quot;</span><span class="s0">===e)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.containsEsc){const e=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s1">if</span><span class="s0">(e.type===c.name&amp;&amp;</span><span class="s3">&quot;from&quot;</span><span class="s0">!==e.value||e.type===c.braceL)</span><span class="s1">return this</span><span class="s0">.expectOnePlugin([</span><span class="s3">&quot;flow&quot;</span><span class="s0">,</span><span class="s3">&quot;typescript&quot;</span><span class="s0">]),!</span><span class="s2">1</span><span class="s0">}}</span><span class="s1">else if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c._default))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const e=</span><span class="s1">this</span><span class="s0">.nextTokenStart(),t=</span><span class="s1">this</span><span class="s0">.isUnparsedContextual(e,</span><span class="s3">&quot;from&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">44</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e)||</span><span class="s1">this</span><span class="s0">.match(c.name)&amp;&amp;t)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._default)&amp;&amp;t){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.nextTokenStartSince(e+</span><span class="s2">4</span><span class="s0">));</span><span class="s1">return </span><span class="s2">34</span><span class="s0">===t||</span><span class="s2">39</span><span class="s0">===t}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}parseExportFrom(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;from&quot;</span><span class="s0">)){e.source=</span><span class="s1">this</span><span class="s0">.parseImportSource(),</span><span class="s1">this</span><span class="s0">.checkExport(e);const t=</span><span class="s1">this</span><span class="s0">.maybeParseImportAssertions();t&amp;&amp;(e.assertions=t)}</span><span class="s1">else </span><span class="s0">t?</span><span class="s1">this</span><span class="s0">.unexpected():e.source=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.semicolon()}shouldParseExportDeclaration(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.at)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.expectOnePlugin([</span><span class="s3">&quot;decorators&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators-legacy&quot;</span><span class="s0">]),</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">))){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">,</span><span class="s3">&quot;decoratorsBeforeExport&quot;</span><span class="s0">))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">this</span><span class="s0">.state.start,E.DecoratorBeforeExport)}</span><span class="s1">return</span><span class="s3">&quot;var&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.type.keyword||</span><span class="s3">&quot;const&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.type.keyword||</span><span class="s3">&quot;function&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.type.keyword||</span><span class="s3">&quot;class&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.type.keyword||</span><span class="s1">this</span><span class="s0">.isLet()||</span><span class="s1">this</span><span class="s0">.isAsyncFunction()}checkExport(e,t,r,n){</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">if</span><span class="s0">(r){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.checkDuplicateExports(e,</span><span class="s3">&quot;default&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;exportDefaultFrom&quot;</span><span class="s0">)){</span><span class="s1">var </span><span class="s0">i;const t=e.declaration;</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==t.type||</span><span class="s3">&quot;from&quot;</span><span class="s0">!==t.name||t.end-t.start!=</span><span class="s2">4</span><span class="s0">||</span><span class="s1">null</span><span class="s0">!=(i=t.extra)&amp;&amp;i.parenthesized||</span><span class="s1">this</span><span class="s0">.raise(t.start,E.ExportDefaultFromAsIdentifier)}}</span><span class="s1">else if</span><span class="s0">(e.specifiers&amp;&amp;e.specifiers.length)</span><span class="s1">for</span><span class="s0">(const t of e.specifiers){const{exported:e}=t,r=</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type?e.name:e.value;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.checkDuplicateExports(t,r),!n&amp;&amp;t.local){const{local:e}=t;</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===e.type?</span><span class="s1">this</span><span class="s0">.raise(t.start,E.ExportBindingIsString,e.value,r):(</span><span class="s1">this</span><span class="s0">.checkReservedWord(e.name,e.start,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.checkLocalExport(e))}}</span><span class="s1">else if</span><span class="s0">(e.declaration)</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">===e.declaration.type||</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">===e.declaration.type){const t=e.declaration.id;</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Assertion failure&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.checkDuplicateExports(e,t.name)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">===e.declaration.type)</span><span class="s1">for</span><span class="s0">(const t of e.declaration.declarations)</span><span class="s1">this</span><span class="s0">.checkDeclaration(t.id);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.decoratorStack[</span><span class="s1">this</span><span class="s0">.state.decoratorStack.length-1].length)</span><span class="s1">throw this</span><span class="s0">.raise(e.start,E.UnsupportedDecoratorExport)}checkDeclaration(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type)</span><span class="s1">this</span><span class="s0">.checkDuplicateExports(e,e.name);</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">===e.type)</span><span class="s1">for</span><span class="s0">(const t of e.properties)</span><span class="s1">this</span><span class="s0">.checkDeclaration(t);</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">===e.type)</span><span class="s1">for</span><span class="s0">(const t of e.elements)t&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkDeclaration(t);</span><span class="s1">else</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">===e.type?</span><span class="s1">this</span><span class="s0">.checkDeclaration(e.value):</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">===e.type?</span><span class="s1">this</span><span class="s0">.checkDeclaration(e.argument):</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkDeclaration(e.left)}checkDuplicateExports(e,t){</span><span class="s1">this</span><span class="s0">.state.exportedIdentifiers.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,</span><span class="s3">&quot;default&quot;</span><span class="s0">===t?E.DuplicateDefaultExport:E.DuplicateExport,t),</span><span class="s1">this</span><span class="s0">.state.exportedIdentifiers.push(t)}parseExportSpecifiers(){const e=[];let t=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.braceL);!</span><span class="s1">this</span><span class="s0">.eat(c.braceR);){</span><span class="s1">if</span><span class="s0">(t)t=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.comma),</span><span class="s1">this</span><span class="s0">.eat(c.braceR))</span><span class="s1">break</span><span class="s0">;const r=</span><span class="s1">this</span><span class="s0">.startNode();r.local=</span><span class="s1">this</span><span class="s0">.parseModuleExportName(),r.exported=</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.parseModuleExportName():r.local.__clone(),e.push(</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;ExportSpecifier&quot;</span><span class="s0">))}</span><span class="s1">return </span><span class="s0">e}parseModuleExportName(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.string)){const e=</span><span class="s1">this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">),t=e.value.match(Xe);</span><span class="s1">return </span><span class="s0">t&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,E.ModuleExportNameHasLoneSurrogate,t[</span><span class="s2">0</span><span class="s0">].charCodeAt(</span><span class="s2">0</span><span class="s0">).toString(</span><span class="s2">16</span><span class="s0">)),e}</span><span class="s1">return this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">)}parseImport(e){</span><span class="s1">if</span><span class="s0">(e.specifiers=[],!</span><span class="s1">this</span><span class="s0">.match(c.string)){const t=!</span><span class="s1">this</span><span class="s0">.maybeParseDefaultImportSpecifier(e)||</span><span class="s1">this</span><span class="s0">.eat(c.comma),r=t&amp;&amp;</span><span class="s1">this</span><span class="s0">.maybeParseStarImportSpecifier(e);t&amp;&amp;!r&amp;&amp;</span><span class="s1">this</span><span class="s0">.parseNamedImportSpecifiers(e),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;from&quot;</span><span class="s0">)}e.source=</span><span class="s1">this</span><span class="s0">.parseImportSource();const t=</span><span class="s1">this</span><span class="s0">.maybeParseImportAssertions();</span><span class="s1">if</span><span class="s0">(t)e.assertions=t;</span><span class="s1">else</span><span class="s0">{const t=</span><span class="s1">this</span><span class="s0">.maybeParseModuleAttributes();t&amp;&amp;(e.attributes=t)}</span><span class="s1">return this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">)}parseImportSource(){</span><span class="s1">return this</span><span class="s0">.match(c.string)||</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.parseExprAtom()}shouldParseDefaultImport(e){</span><span class="s1">return this</span><span class="s0">.match(c.name)}parseImportSpecifierLocal(e,t,r,n){t.local=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkLVal(t.local,n,</span><span class="s2">9</span><span class="s0">),e.specifiers.push(</span><span class="s1">this</span><span class="s0">.finishNode(t,r))}parseAssertEntries(){const e=[],t=</span><span class="s1">new </span><span class="s0">Set;</span><span class="s1">do</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.braceR))</span><span class="s1">break</span><span class="s0">;const r=</span><span class="s1">this</span><span class="s0">.startNode(),n=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.string)?r.key=</span><span class="s1">this</span><span class="s0">.parseLiteral(n,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">):r.key=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.colon),</span><span class="s3">&quot;type&quot;</span><span class="s0">!==n&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r.key.start,E.ModuleAttributeDifferentFromType,n),t.has(n)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r.key.start,E.ModuleAttributesWithDuplicateKeys,n),t.add(n),!</span><span class="s1">this</span><span class="s0">.match(c.string))</span><span class="s1">throw this</span><span class="s0">.unexpected(</span><span class="s1">this</span><span class="s0">.state.start,E.ModuleAttributeInvalidValue);r.value=</span><span class="s1">this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;ImportAttribute&quot;</span><span class="s0">),e.push(r)}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.comma));</span><span class="s1">return </span><span class="s0">e}maybeParseModuleAttributes(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c._with)||</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak())</span><span class="s1">return this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;moduleAttributes&quot;</span><span class="s0">)?[]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;moduleAttributes&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next();const e=[],t=</span><span class="s1">new </span><span class="s0">Set;</span><span class="s1">do</span><span class="s0">{const r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(r.key=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),</span><span class="s3">&quot;type&quot;</span><span class="s0">!==r.key.name&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r.key.start,E.ModuleAttributeDifferentFromType,r.key.name),t.has(r.key.name)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r.key.start,E.ModuleAttributesWithDuplicateKeys,r.key.name),t.add(r.key.name),</span><span class="s1">this</span><span class="s0">.expect(c.colon),!</span><span class="s1">this</span><span class="s0">.match(c.string))</span><span class="s1">throw this</span><span class="s0">.unexpected(</span><span class="s1">this</span><span class="s0">.state.start,E.ModuleAttributeInvalidValue);r.value=</span><span class="s1">this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;ImportAttribute&quot;</span><span class="s0">),e.push(r)}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.comma));</span><span class="s1">return </span><span class="s0">e}maybeParseImportAssertions(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;assert&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak())</span><span class="s1">return this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;importAssertions&quot;</span><span class="s0">)?[]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;importAssertions&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.eat(c.braceL);const e=</span><span class="s1">this</span><span class="s0">.parseAssertEntries();</span><span class="s1">return this</span><span class="s0">.eat(c.braceR),e}maybeParseDefaultImportSpecifier(e){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.shouldParseDefaultImport(e)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.parseImportSpecifierLocal(e,</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">,</span><span class="s3">&quot;default import specifier&quot;</span><span class="s0">),!</span><span class="s2">0</span><span class="s0">)}maybeParseStarImportSpecifier(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.star)){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parseImportSpecifierLocal(e,t,</span><span class="s3">&quot;ImportNamespaceSpecifier&quot;</span><span class="s0">,</span><span class="s3">&quot;import namespace specifier&quot;</span><span class="s0">),!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}parseNamedImportSpecifiers(e){let t=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.braceL);!</span><span class="s1">this</span><span class="s0">.eat(c.braceR);){</span><span class="s1">if</span><span class="s0">(t)t=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.colon))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,E.DestructureNamedImport);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.comma),</span><span class="s1">this</span><span class="s0">.eat(c.braceR))</span><span class="s1">break</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.parseImportSpecifier(e)}}parseImportSpecifier(e){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(t.imported=</span><span class="s1">this</span><span class="s0">.parseModuleExportName(),</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">))t.local=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">else</span><span class="s0">{const{imported:e}=t;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===e.type)</span><span class="s1">throw this</span><span class="s0">.raise(t.start,E.ImportBindingIsString,e.value);</span><span class="s1">this</span><span class="s0">.checkReservedWord(e.name,t.start,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),t.local=e.__clone()}</span><span class="s1">this</span><span class="s0">.checkLVal(t.local,</span><span class="s3">&quot;import specifier&quot;</span><span class="s0">,</span><span class="s2">9</span><span class="s0">),e.specifiers.push(</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s0">))}isThisParam(e){</span><span class="s1">return</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;this&quot;</span><span class="s0">===e.name}}class He extends Je{constructor(e,t){super(e=</span><span class="s1">function</span><span class="s0">(e){const t={};</span><span class="s1">for</span><span class="s0">(const r of Object.keys(Pe))t[r]=e&amp;&amp;</span><span class="s1">null</span><span class="s0">!=e[r]?e[r]:Pe[r];</span><span class="s1">return </span><span class="s0">t}(e),t),</span><span class="s1">this</span><span class="s0">.options=e,</span><span class="s1">this</span><span class="s0">.initializeScopes(),</span><span class="s1">this</span><span class="s0">.plugins=</span><span class="s1">function</span><span class="s0">(e){const t=</span><span class="s1">new </span><span class="s0">Map;</span><span class="s1">for</span><span class="s0">(const r of e){const[e,n]=Array.isArray(r)?r:[r,{}];t.has(e)||t.set(e,n||{})}</span><span class="s1">return </span><span class="s0">t}(</span><span class="s1">this</span><span class="s0">.options.plugins),</span><span class="s1">this</span><span class="s0">.filename=e.sourceFilename}getScopeHandler(){</span><span class="s1">return </span><span class="s0">J}parse(){</span><span class="s1">this</span><span class="s0">.enterInitialScopes();const e=</span><span class="s1">this</span><span class="s0">.startNode(),t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.nextToken(),e.errors=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseTopLevel(e,t),e.errors=</span><span class="s1">this</span><span class="s0">.state.errors,e}}</span><span class="s1">function </span><span class="s0">Ge(e,t){let r=He;</span><span class="s1">return null</span><span class="s0">!=e&amp;&amp;e.plugins&amp;&amp;(</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(Te(e,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(Te(e,</span><span class="s3">&quot;decorators-legacy&quot;</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Cannot use the decorators and decorators-legacy plugin together&quot;</span><span class="s0">);const t=be(e,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">,</span><span class="s3">&quot;decoratorsBeforeExport&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==t)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">t)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;'decoratorsBeforeExport' must be a boolean.&quot;</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(Te(e,</span><span class="s3">&quot;flow&quot;</span><span class="s0">)&amp;&amp;Te(e,</span><span class="s3">&quot;typescript&quot;</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Cannot combine flow and typescript plugins.&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(Te(e,</span><span class="s3">&quot;placeholders&quot;</span><span class="s0">)&amp;&amp;Te(e,</span><span class="s3">&quot;v8intrinsic&quot;</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Cannot combine placeholders and v8intrinsic plugins.&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(Te(e,</span><span class="s3">&quot;pipelineOperator&quot;</span><span class="s0">)&amp;&amp;!ge.includes(be(e,</span><span class="s3">&quot;pipelineOperator&quot;</span><span class="s0">,</span><span class="s3">&quot;proposal&quot;</span><span class="s0">)))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;'pipelineOperator' requires 'proposal' option whose value should be one of: &quot;</span><span class="s0">+ge.map((e=&gt;`</span><span class="s3">'${e}'</span><span class="s0">`)).join(</span><span class="s3">&quot;, &quot;</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(Te(e,</span><span class="s3">&quot;moduleAttributes&quot;</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(Te(e,</span><span class="s3">&quot;importAssertions&quot;</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Cannot combine importAssertions and moduleAttributes plugins.&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;may-2020&quot;</span><span class="s0">!==be(e,</span><span class="s3">&quot;moduleAttributes&quot;</span><span class="s0">,</span><span class="s3">&quot;version&quot;</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.&quot;</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(Te(e,</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">)&amp;&amp;!Se.includes(be(e,</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s3">&quot;syntaxType&quot;</span><span class="s0">)))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;'recordAndTuple' requires 'syntaxType' option whose value should be one of: &quot;</span><span class="s0">+Se.map((e=&gt;`</span><span class="s3">'${e}'</span><span class="s0">`)).join(</span><span class="s3">&quot;, &quot;</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(Te(e,</span><span class="s3">&quot;asyncDoExpressions&quot;</span><span class="s0">)&amp;&amp;!Te(e,</span><span class="s3">&quot;doExpressions&quot;</span><span class="s0">)){const e=</span><span class="s1">new </span><span class="s0">Error(</span><span class="s3">&quot;'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.&quot;</span><span class="s0">);</span><span class="s1">throw </span><span class="s0">e.missingPlugins=</span><span class="s3">&quot;doExpressions&quot;</span><span class="s0">,e}}(e.plugins),r=</span><span class="s1">function</span><span class="s0">(e){const t=Ee.filter((t=&gt;Te(e,t))),r=t.join(</span><span class="s3">&quot;/&quot;</span><span class="s0">);let n=ze[r];</span><span class="s1">if</span><span class="s0">(!n){n=He;</span><span class="s1">for</span><span class="s0">(const e of t)n=xe[e](n);ze[r]=n}</span><span class="s1">return </span><span class="s0">n}(e.plugins)),</span><span class="s1">new </span><span class="s0">r(e,t)}const ze={};t.parse=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">var </span><span class="s0">r;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;unambiguous&quot;</span><span class="s0">!==(</span><span class="s1">null</span><span class="s0">==(r=t)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.sourceType))</span><span class="s1">return </span><span class="s0">Ge(t,e).parse();t=Object.assign({},t);</span><span class="s1">try</span><span class="s0">{t.sourceType=</span><span class="s3">&quot;module&quot;</span><span class="s0">;const r=Ge(t,e),n=r.parse();</span><span class="s1">if</span><span class="s0">(r.sawUnambiguousESM)</span><span class="s1">return </span><span class="s0">n;</span><span class="s1">if</span><span class="s0">(r.ambiguousScriptDifferentAst)</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">t.sourceType=</span><span class="s3">&quot;script&quot;</span><span class="s0">,Ge(t,e).parse()}</span><span class="s1">catch</span><span class="s0">(e){}</span><span class="s1">else </span><span class="s0">n.program.sourceType=</span><span class="s3">&quot;script&quot;</span><span class="s0">;</span><span class="s1">return </span><span class="s0">n}</span><span class="s1">catch</span><span class="s0">(r){</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">t.sourceType=</span><span class="s3">&quot;script&quot;</span><span class="s0">,Ge(t,e).parse()}</span><span class="s1">catch</span><span class="s0">(e){}</span><span class="s1">throw </span><span class="s0">r}},t.parseExpression=</span><span class="s1">function</span><span class="s0">(e,t){const r=Ge(t,e);</span><span class="s1">return </span><span class="s0">r.options.strictMode&amp;&amp;(r.state.strict=!</span><span class="s2">0</span><span class="s0">),r.getExpression()},t.tokTypes=c},</span><span class="s2">1619</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function </span><span class="s0">e(t,r){const a=</span><span class="s1">new </span><span class="s0">WeakMap,p=</span><span class="s1">new </span><span class="s0">WeakMap,c=r||(</span><span class="s2">0</span><span class="s0">,n.validate)(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">return </span><span class="s0">Object.assign(((r,...o)=&gt;{</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r){</span><span class="s1">if</span><span class="s0">(o.length&gt;</span><span class="s2">1</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Unexpected extra params.&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">l((</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(t,r,(</span><span class="s2">0</span><span class="s0">,n.merge)(c,(</span><span class="s2">0</span><span class="s0">,n.validate)(o[</span><span class="s2">0</span><span class="s0">]))))}</span><span class="s1">if</span><span class="s0">(Array.isArray(r)){let e=a.get(r);</span><span class="s1">return </span><span class="s0">e||(e=(</span><span class="s2">0</span><span class="s0">,s.</span><span class="s1">default</span><span class="s0">)(t,r,c),a.set(r,e)),l(e(o))}</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r&amp;&amp;r){</span><span class="s1">if</span><span class="s0">(o.length&gt;</span><span class="s2">0</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Unexpected extra params.&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">e(t,(</span><span class="s2">0</span><span class="s0">,n.merge)(c,(</span><span class="s2">0</span><span class="s0">,n.validate)(r)))}</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Unexpected template param &quot;</span><span class="s0">+</span><span class="s1">typeof </span><span class="s0">r)}),{ast:(e,...r)=&gt;{</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e){</span><span class="s1">if</span><span class="s0">(r.length&gt;</span><span class="s2">1</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Unexpected extra params.&quot;</span><span class="s0">);</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(t,e,(</span><span class="s2">0</span><span class="s0">,n.merge)((</span><span class="s2">0</span><span class="s0">,n.merge)(c,(</span><span class="s2">0</span><span class="s0">,n.validate)(r[</span><span class="s2">0</span><span class="s0">])),o))()}</span><span class="s1">if</span><span class="s0">(Array.isArray(e)){let i=p.get(e);</span><span class="s1">return </span><span class="s0">i||(i=(</span><span class="s2">0</span><span class="s0">,s.</span><span class="s1">default</span><span class="s0">)(t,e,(</span><span class="s2">0</span><span class="s0">,n.merge)(c,o)),p.set(e,i)),i(r)()}</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Unexpected template param &quot;</span><span class="s0">+</span><span class="s1">typeof </span><span class="s0">e)}})};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">2123</span><span class="s0">),i=a(r(</span><span class="s2">3046</span><span class="s0">)),s=a(r(</span><span class="s2">3004</span><span class="s0">));</span><span class="s1">function </span><span class="s0">a(e){</span><span class="s1">return </span><span class="s0">e&amp;&amp;e.__esModule?e:{</span><span class="s1">default</span><span class="s0">:e}}const o=(</span><span class="s2">0</span><span class="s0">,n.validate)({placeholderPattern:!</span><span class="s2">1</span><span class="s0">});</span><span class="s1">function </span><span class="s0">l(e){let t=</span><span class="s3">&quot;&quot;</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">throw new </span><span class="s0">Error}</span><span class="s1">catch</span><span class="s0">(e){e.stack&amp;&amp;(t=e.stack.split(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">).slice(</span><span class="s2">3</span><span class="s0">).join(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">))}</span><span class="s1">return </span><span class="s0">r=&gt;{</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e(r)}</span><span class="s1">catch</span><span class="s0">(e){</span><span class="s1">throw </span><span class="s0">e.stack+=`\n    =============\n${t}`,e}}}},</span><span class="s2">8913</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.program=t.expression=t.statement=t.statements=t.smart=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=i();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">s </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,s)){</span><span class="s1">var </span><span class="s0">a=n?Object.getOwnPropertyDescriptor(e,s):</span><span class="s1">null</span><span class="s0">;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">17</span><span class="s0">));</span><span class="s1">function </span><span class="s0">i(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">i=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}</span><span class="s1">function </span><span class="s0">s(e){</span><span class="s1">return</span><span class="s0">{code:e=&gt;`</span><span class="s6">/* @babel/template */</span><span class="s0">;\n${e}`,validate:()=&gt;{},unwrap:t=&gt;e(t.program.body.slice(</span><span class="s2">1</span><span class="s0">))}}const a=s((e=&gt;e.length&gt;</span><span class="s2">1</span><span class="s0">?e:e[</span><span class="s2">0</span><span class="s0">]));t.smart=a;const o=s((e=&gt;e));t.statements=o;const l=s((e=&gt;{</span><span class="s1">if</span><span class="s0">(</span><span class="s2">0</span><span class="s0">===e.length)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Found nothing to return.&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(e.length&gt;</span><span class="s2">1</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Found multiple statements but wanted one&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">e[</span><span class="s2">0</span><span class="s0">]}));t.statement=l;const p={code:e=&gt;`(\n${e}\n)`,validate:e=&gt;{</span><span class="s1">if</span><span class="s0">(e.program.body.length&gt;</span><span class="s2">1</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Found multiple statements but wanted one&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">0</span><span class="s0">===p.unwrap(e).start)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Parse result included parens.&quot;</span><span class="s0">)},unwrap:({program:e})=&gt;{const[t]=e.body;</span><span class="s1">return </span><span class="s0">n.assertExpressionStatement(t),t.expression}};t.expression=p,t.program={code:e=&gt;e,validate:()=&gt;{},unwrap:e=&gt;e.program}},</span><span class="s2">6205</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=t.program=t.expression=t.statements=t.statement=t.smart=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n,i=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=a();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,i)){</span><span class="s1">var </span><span class="s0">s=n?Object.getOwnPropertyDescriptor(e,i):</span><span class="s1">null</span><span class="s0">;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">8913</span><span class="s0">)),s=(n=r(</span><span class="s2">1619</span><span class="s0">))&amp;&amp;n.__esModule?n:{</span><span class="s1">default</span><span class="s0">:n};</span><span class="s1">function </span><span class="s0">a(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">a=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}const o=(</span><span class="s2">0</span><span class="s0">,s.</span><span class="s1">default</span><span class="s0">)(i.smart);t.smart=o;const l=(</span><span class="s2">0</span><span class="s0">,s.</span><span class="s1">default</span><span class="s0">)(i.statement);t.statement=l;const p=(</span><span class="s2">0</span><span class="s0">,s.</span><span class="s1">default</span><span class="s0">)(i.statements);t.statements=p;const c=(</span><span class="s2">0</span><span class="s0">,s.</span><span class="s1">default</span><span class="s0">)(i.expression);t.expression=c;const u=(</span><span class="s2">0</span><span class="s0">,s.</span><span class="s1">default</span><span class="s0">)(i.program);t.program=u;</span><span class="s1">var </span><span class="s0">d=Object.assign(o.bind(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">),{smart:o,statement:l,statements:p,expression:c,program:u,ast:o.ast});t.</span><span class="s1">default</span><span class="s0">=d},</span><span class="s2">3004</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t,r){const{metadata:a,names:l}=</span><span class="s1">function</span><span class="s0">(e,t,r){let n,s,a,l=</span><span class="s3">&quot;&quot;</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{l+=</span><span class="s3">&quot;$&quot;</span><span class="s0">;const p=o(t,l);n=p.names,s=</span><span class="s1">new </span><span class="s0">Set(n),a=(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(e,e.code(p.code),{parser:r.parser,placeholderWhitelist:</span><span class="s1">new </span><span class="s0">Set(p.names.concat(r.placeholderWhitelist?Array.from(r.placeholderWhitelist):[])),placeholderPattern:r.placeholderPattern,preserveComments:r.preserveComments,syntacticPlaceholders:r.syntacticPlaceholders})}</span><span class="s1">while</span><span class="s0">(a.placeholders.some((e=&gt;e.isDuplicate&amp;&amp;s.has(e.name))));</span><span class="s1">return</span><span class="s0">{metadata:a,names:n}}(e,t,r);</span><span class="s1">return </span><span class="s0">t=&gt;{const r={};</span><span class="s1">return </span><span class="s0">t.forEach(((e,t)=&gt;{r[l[t]]=e})),t=&gt;{const i=(</span><span class="s2">0</span><span class="s0">,n.normalizeReplacements)(t);</span><span class="s1">return </span><span class="s0">i&amp;&amp;Object.keys(i).forEach((e=&gt;{</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(r,e))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Unexpected replacement overlap.&quot;</span><span class="s0">)})),e.unwrap((</span><span class="s2">0</span><span class="s0">,s.</span><span class="s1">default</span><span class="s0">)(a,i?Object.assign(i,r):r))}}};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">2123</span><span class="s0">),i=a(r(</span><span class="s2">5008</span><span class="s0">)),s=a(r(</span><span class="s2">5985</span><span class="s0">));</span><span class="s1">function </span><span class="s0">a(e){</span><span class="s1">return </span><span class="s0">e&amp;&amp;e.__esModule?e:{</span><span class="s1">default</span><span class="s0">:e}}</span><span class="s1">function </span><span class="s0">o(e,t){const r=[];let n=e[</span><span class="s2">0</span><span class="s0">];</span><span class="s1">for</span><span class="s0">(let i=</span><span class="s2">1</span><span class="s0">;i&lt;e.length;i++){const s=`${t}${i-1}`;r.push(s),n+=s+e[i]}</span><span class="s1">return</span><span class="s0">{names:r,code:n}}},</span><span class="s2">2123</span><span class="s0">:(e,t)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.merge=</span><span class="s1">function</span><span class="s0">(e,t){const{placeholderWhitelist:r=e.placeholderWhitelist,placeholderPattern:n=e.placeholderPattern,preserveComments:i=e.preserveComments,syntacticPlaceholders:s=e.syntacticPlaceholders}=t;</span><span class="s1">return</span><span class="s0">{parser:Object.assign({},e.parser,t.parser),placeholderWhitelist:r,placeholderPattern:n,preserveComments:i,syntacticPlaceholders:s}},t.validate=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=e&amp;&amp;</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Unknown template options.&quot;</span><span class="s0">);const t=e||{},{placeholderWhitelist:r,placeholderPattern:n,preserveComments:i,syntacticPlaceholders:s}=t,a=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==e)</span><span class="s1">return</span><span class="s0">{};</span><span class="s1">var </span><span class="s0">r,n,i={},s=Object.keys(e);</span><span class="s1">for</span><span class="s0">(n=</span><span class="s2">0</span><span class="s0">;n&lt;s.length;n++)r=s[n],t.indexOf(r)&gt;=</span><span class="s2">0</span><span class="s0">||(i[r]=e[r]);</span><span class="s1">return </span><span class="s0">i}(t,[</span><span class="s3">&quot;placeholderWhitelist&quot;</span><span class="s0">,</span><span class="s3">&quot;placeholderPattern&quot;</span><span class="s0">,</span><span class="s3">&quot;preserveComments&quot;</span><span class="s0">,</span><span class="s3">&quot;syntacticPlaceholders&quot;</span><span class="s0">]);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=r&amp;&amp;!(r </span><span class="s1">instanceof </span><span class="s0">Set))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;'.placeholderWhitelist' must be a Set, null, or undefined&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=n&amp;&amp;!(n </span><span class="s1">instanceof </span><span class="s0">RegExp)&amp;&amp;!</span><span class="s2">1</span><span class="s0">!==n)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;'.placeholderPattern' must be a RegExp, false, null, or undefined&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=i&amp;&amp;</span><span class="s3">&quot;boolean&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">i)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;'.preserveComments' must be a boolean, null, or undefined&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=s&amp;&amp;</span><span class="s3">&quot;boolean&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">s)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;'.syntacticPlaceholders' must be a boolean, null, or undefined&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!</span><span class="s2">0</span><span class="s0">===s&amp;&amp;(</span><span class="s1">null</span><span class="s0">!=r||</span><span class="s1">null</span><span class="s0">!=n))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'&quot;</span><span class="s0">);</span><span class="s1">return</span><span class="s0">{parser:a,placeholderWhitelist:r||</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,placeholderPattern:</span><span class="s1">null</span><span class="s0">==n?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:n,preserveComments:</span><span class="s1">null</span><span class="s0">==i?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:i,syntacticPlaceholders:</span><span class="s1">null</span><span class="s0">==s?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:s}},t.normalizeReplacements=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(Array.isArray(e))</span><span class="s1">return </span><span class="s0">e.reduce(((e,t,r)=&gt;(e[</span><span class="s3">&quot;$&quot;</span><span class="s0">+r]=t,e)),{});</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e||</span><span class="s1">null</span><span class="s0">==e)</span><span class="s1">return </span><span class="s0">e||</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Template replacements must be an array, object, null, or undefined&quot;</span><span class="s0">)}},</span><span class="s2">5008</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t,r){const{placeholderWhitelist:a,placeholderPattern:o,preserveComments:p,syntacticPlaceholders:c}=r,u=</span><span class="s1">function</span><span class="s0">(e,t,r){const n=(t.plugins||[]).slice();!</span><span class="s2">1</span><span class="s0">!==r&amp;&amp;n.push(</span><span class="s3">&quot;placeholders&quot;</span><span class="s0">),t=Object.assign({allowReturnOutsideFunction:!</span><span class="s2">0</span><span class="s0">,allowSuperOutsideMethod:!</span><span class="s2">0</span><span class="s0">,sourceType:</span><span class="s3">&quot;module&quot;</span><span class="s0">},t,{plugins:n});</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,i.parse)(e,t)}</span><span class="s1">catch</span><span class="s0">(t){const r=t.loc;</span><span class="s1">throw </span><span class="s0">r&amp;&amp;(t.message+=</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">+(</span><span class="s2">0</span><span class="s0">,s.codeFrameColumns)(e,{start:r}),t.code=</span><span class="s3">&quot;BABEL_TEMPLATE_PARSE_ERROR&quot;</span><span class="s0">),t}}(t,r.parser,c);n.removePropertiesDeep(u,{preserveComments:p}),e.validate(u);const d={placeholders:[],placeholderNames:</span><span class="s1">new </span><span class="s0">Set},h={placeholders:[],placeholderNames:</span><span class="s1">new </span><span class="s0">Set},f={value:</span><span class="s1">void </span><span class="s2">0</span><span class="s0">};</span><span class="s1">return </span><span class="s0">n.traverse(u,l,{syntactic:d,legacy:h,isLegacyRef:f,placeholderWhitelist:a,placeholderPattern:o,syntacticPlaceholders:c}),Object.assign({ast:u},f.value?h:d)};</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=a();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,i)){</span><span class="s1">var </span><span class="s0">s=n?Object.getOwnPropertyDescriptor(e,i):</span><span class="s1">null</span><span class="s0">;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">17</span><span class="s0">)),i=r(</span><span class="s2">4494</span><span class="s0">),s=r(</span><span class="s2">785</span><span class="s0">);</span><span class="s1">function </span><span class="s0">a(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">a=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}const o=/^[_$A-Z0-9]+$/;</span><span class="s1">function </span><span class="s0">l(e,t,r){</span><span class="s1">var </span><span class="s0">i;let s;</span><span class="s1">if</span><span class="s0">(n.isPlaceholder(e)){</span><span class="s1">if</span><span class="s0">(!</span><span class="s2">1</span><span class="s0">===r.syntacticPlaceholders)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.&quot;</span><span class="s0">);s=e.name.name,r.isLegacyRef.value=!</span><span class="s2">1</span><span class="s0">}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!</span><span class="s2">1</span><span class="s0">===r.isLegacyRef.value||r.syntacticPlaceholders)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(n.isIdentifier(e)||n.isJSXIdentifier(e))s=e.name,r.isLegacyRef.value=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!n.isStringLiteral(e))</span><span class="s1">return</span><span class="s0">;s=e.value,r.isLegacyRef.value=!</span><span class="s2">0</span><span class="s0">}}</span><span class="s1">if</span><span class="s0">(!r.isLegacyRef.value&amp;&amp;(</span><span class="s1">null</span><span class="s0">!=r.placeholderPattern||</span><span class="s1">null</span><span class="s0">!=r.placeholderWhitelist))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(r.isLegacyRef.value&amp;&amp;(!</span><span class="s2">1</span><span class="s0">===r.placeholderPattern||!(r.placeholderPattern||o).test(s))&amp;&amp;!(</span><span class="s1">null</span><span class="s0">==(i=r.placeholderWhitelist)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:i.has(s)))</span><span class="s1">return</span><span class="s0">;t=t.slice();const{node:a,key:l}=t[t.length-1];let p;n.isStringLiteral(e)||n.isPlaceholder(e,{expectedNode:</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">})?p=</span><span class="s3">&quot;string&quot;</span><span class="s0">:n.isNewExpression(a)&amp;&amp;</span><span class="s3">&quot;arguments&quot;</span><span class="s0">===l||n.isCallExpression(a)&amp;&amp;</span><span class="s3">&quot;arguments&quot;</span><span class="s0">===l||n.isFunction(a)&amp;&amp;</span><span class="s3">&quot;params&quot;</span><span class="s0">===l?p=</span><span class="s3">&quot;param&quot;</span><span class="s0">:n.isExpressionStatement(a)&amp;&amp;!n.isPlaceholder(e)?(p=</span><span class="s3">&quot;statement&quot;</span><span class="s0">,t=t.slice(</span><span class="s2">0</span><span class="s0">,-</span><span class="s2">1</span><span class="s0">)):p=n.isStatement(e)&amp;&amp;n.isPlaceholder(e)?</span><span class="s3">&quot;statement&quot;</span><span class="s0">:</span><span class="s3">&quot;other&quot;</span><span class="s0">;const{placeholders:c,placeholderNames:u}=r.isLegacyRef.value?r.legacy:r.syntactic;c.push({name:s,type:p,resolve:e=&gt;</span><span class="s1">function</span><span class="s0">(e,t){let r=e;</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">;e&lt;t.length-1;e++){const{key:n,index:i}=t[e];r=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===i?r[n]:r[n][i]}const{key:n,index:i}=t[t.length-1];</span><span class="s1">return</span><span class="s0">{parent:r,key:n,index:i}}(e,t),isDuplicate:u.has(s)}),u.add(s)}},</span><span class="s2">5985</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){const r=n.cloneNode(e.ast);</span><span class="s1">return </span><span class="s0">t&amp;&amp;(e.placeholders.forEach((e=&gt;{</span><span class="s1">if</span><span class="s0">(!Object.prototype.hasOwnProperty.call(t,e.name)){const t=e.name;</span><span class="s1">throw new </span><span class="s0">Error(`Error: No substitution given </span><span class="s1">for </span><span class="s3">&quot;${t}&quot;</span><span class="s0">. If </span><span class="s1">this </span><span class="s0">is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: </span><span class="s1">false</span><span class="s0">, placeholderWhitelist: </span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">'${t}'</span><span class="s0">])}\n            - { placeholderPattern: /^${t}$/ }`)}})),Object.keys(t).forEach((t=&gt;{</span><span class="s1">if</span><span class="s0">(!e.placeholderNames.has(t))</span><span class="s1">throw new </span><span class="s0">Error(`Unknown substitution </span><span class="s3">&quot;${t}&quot; </span><span class="s0">given`)}))),e.placeholders.slice().reverse().forEach((e=&gt;{</span><span class="s1">try</span><span class="s0">{!</span><span class="s1">function</span><span class="s0">(e,t,r){e.isDuplicate&amp;&amp;(Array.isArray(r)?r=r.map((e=&gt;n.cloneNode(e))):</span><span class="s3">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r&amp;&amp;(r=n.cloneNode(r)));const{parent:i,key:s,index:a}=e.resolve(t);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;string&quot;</span><span class="s0">===e.type){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r&amp;&amp;(r=n.stringLiteral(r)),!r||!n.isStringLiteral(r))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Expected string substitution&quot;</span><span class="s0">)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;statement&quot;</span><span class="s0">===e.type)</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===a?r?Array.isArray(r)?r=n.blockStatement(r):</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r?r=n.expressionStatement(n.identifier(r)):n.isStatement(r)||(r=n.expressionStatement(r)):r=n.emptyStatement():r&amp;&amp;!Array.isArray(r)&amp;&amp;(</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r&amp;&amp;(r=n.identifier(r)),n.isStatement(r)||(r=n.expressionStatement(r)));</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;param&quot;</span><span class="s0">===e.type){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r&amp;&amp;(r=n.identifier(r)),</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===a)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Assertion failure.&quot;</span><span class="s0">)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r&amp;&amp;(r=n.identifier(r)),Array.isArray(r))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Cannot replace single expression with an array.&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===a)n.validate(i,s,r),i[s]=r;</span><span class="s1">else</span><span class="s0">{const t=i[s].slice();</span><span class="s3">&quot;statement&quot;</span><span class="s0">===e.type||</span><span class="s3">&quot;param&quot;</span><span class="s0">===e.type?</span><span class="s1">null</span><span class="s0">==r?t.splice(a,</span><span class="s2">1</span><span class="s0">):Array.isArray(r)?t.splice(a,</span><span class="s2">1</span><span class="s0">,...r):t[a]=r:t[a]=r,n.validate(i,s,t),i[s]=t}}(e,r,t&amp;&amp;t[e.name]||</span><span class="s1">null</span><span class="s0">)}</span><span class="s1">catch</span><span class="s0">(t){</span><span class="s1">throw </span><span class="s0">t.message=`@babel/template placeholder </span><span class="s3">&quot;${e.name}&quot;</span><span class="s0">: ${t.message}`,t}})),r};</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=i();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">s </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,s)){</span><span class="s1">var </span><span class="s0">a=n?Object.getOwnPropertyDescriptor(e,s):</span><span class="s1">null</span><span class="s0">;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">17</span><span class="s0">));</span><span class="s1">function </span><span class="s0">i(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">i=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}},</span><span class="s2">3046</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t,r){let a;</span><span class="s1">return </span><span class="s0">t=e.code(t),o=&gt;{const l=(</span><span class="s2">0</span><span class="s0">,n.normalizeReplacements)(o);</span><span class="s1">return </span><span class="s0">a||(a=(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(e,t,r)),e.unwrap((</span><span class="s2">0</span><span class="s0">,s.</span><span class="s1">default</span><span class="s0">)(a,l))}};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">2123</span><span class="s0">),i=a(r(</span><span class="s2">5008</span><span class="s0">)),s=a(r(</span><span class="s2">5985</span><span class="s0">));</span><span class="s1">function </span><span class="s0">a(e){</span><span class="s1">return </span><span class="s0">e&amp;&amp;e.__esModule?e:{</span><span class="s1">default</span><span class="s0">:e}}},</span><span class="s2">9278</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(!(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e)){</span><span class="s1">var </span><span class="s0">t;const r=</span><span class="s1">null</span><span class="s0">!=(t=</span><span class="s1">null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:e.type)?t:JSON.stringify(e);</span><span class="s1">throw new </span><span class="s0">TypeError(`Not a valid node of type </span><span class="s3">&quot;${r}&quot;</span><span class="s0">`)}};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1860</span><span class="s0">)},</span><span class="s2">2937</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.assertArrayExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s0">,e,t)},t.assertAssignmentExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s0">,e,t)},t.assertBinaryExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;BinaryExpression&quot;</span><span class="s0">,e,t)},t.assertInterpreterDirective=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;InterpreterDirective&quot;</span><span class="s0">,e,t)},t.assertDirective=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Directive&quot;</span><span class="s0">,e,t)},t.assertDirectiveLiteral=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;DirectiveLiteral&quot;</span><span class="s0">,e,t)},t.assertBlockStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">,e,t)},t.assertBreakStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;BreakStatement&quot;</span><span class="s0">,e,t)},t.assertCallExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;CallExpression&quot;</span><span class="s0">,e,t)},t.assertCatchClause=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;CatchClause&quot;</span><span class="s0">,e,t)},t.assertConditionalExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s0">,e,t)},t.assertContinueStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ContinueStatement&quot;</span><span class="s0">,e,t)},t.assertDebuggerStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;DebuggerStatement&quot;</span><span class="s0">,e,t)},t.assertDoWhileStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s0">,e,t)},t.assertEmptyStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;EmptyStatement&quot;</span><span class="s0">,e,t)},t.assertExpressionStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s0">,e,t)},t.assertFile=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;File&quot;</span><span class="s0">,e,t)},t.assertForInStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ForInStatement&quot;</span><span class="s0">,e,t)},t.assertForStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ForStatement&quot;</span><span class="s0">,e,t)},t.assertFunctionDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">,e,t)},t.assertFunctionExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">,e,t)},t.assertIdentifier=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,e,t)},t.assertIfStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;IfStatement&quot;</span><span class="s0">,e,t)},t.assertLabeledStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;LabeledStatement&quot;</span><span class="s0">,e,t)},t.assertStringLiteral=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">,e,t)},t.assertNumericLiteral=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">,e,t)},t.assertNullLiteral=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;NullLiteral&quot;</span><span class="s0">,e,t)},t.assertBooleanLiteral=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;BooleanLiteral&quot;</span><span class="s0">,e,t)},t.assertRegExpLiteral=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;RegExpLiteral&quot;</span><span class="s0">,e,t)},t.assertLogicalExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;LogicalExpression&quot;</span><span class="s0">,e,t)},t.assertMemberExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">,e,t)},t.assertNewExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;NewExpression&quot;</span><span class="s0">,e,t)},t.assertProgram=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Program&quot;</span><span class="s0">,e,t)},t.assertObjectExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s0">,e,t)},t.assertObjectMethod=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">,e,t)},t.assertObjectProperty=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">,e,t)},t.assertRestElement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">,e,t)},t.assertReturnStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ReturnStatement&quot;</span><span class="s0">,e,t)},t.assertSequenceExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s0">,e,t)},t.assertParenthesizedExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">,e,t)},t.assertSwitchCase=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;SwitchCase&quot;</span><span class="s0">,e,t)},t.assertSwitchStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;SwitchStatement&quot;</span><span class="s0">,e,t)},t.assertThisExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ThisExpression&quot;</span><span class="s0">,e,t)},t.assertThrowStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ThrowStatement&quot;</span><span class="s0">,e,t)},t.assertTryStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TryStatement&quot;</span><span class="s0">,e,t)},t.assertUnaryExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;UnaryExpression&quot;</span><span class="s0">,e,t)},t.assertUpdateExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;UpdateExpression&quot;</span><span class="s0">,e,t)},t.assertVariableDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">,e,t)},t.assertVariableDeclarator=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s0">,e,t)},t.assertWhileStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;WhileStatement&quot;</span><span class="s0">,e,t)},t.assertWithStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;WithStatement&quot;</span><span class="s0">,e,t)},t.assertAssignmentPattern=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">,e,t)},t.assertArrayPattern=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">,e,t)},t.assertArrowFunctionExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">,e,t)},t.assertClassBody=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ClassBody&quot;</span><span class="s0">,e,t)},t.assertClassExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ClassExpression&quot;</span><span class="s0">,e,t)},t.assertClassDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">,e,t)},t.assertExportAllDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">,e,t)},t.assertExportDefaultDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">,e,t)},t.assertExportNamedDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">,e,t)},t.assertExportSpecifier=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ExportSpecifier&quot;</span><span class="s0">,e,t)},t.assertForOfStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s0">,e,t)},t.assertImportDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">,e,t)},t.assertImportDefaultSpecifier=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">,e,t)},t.assertImportNamespaceSpecifier=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ImportNamespaceSpecifier&quot;</span><span class="s0">,e,t)},t.assertImportSpecifier=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s0">,e,t)},t.assertMetaProperty=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;MetaProperty&quot;</span><span class="s0">,e,t)},t.assertClassMethod=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">,e,t)},t.assertObjectPattern=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">,e,t)},t.assertSpreadElement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">,e,t)},t.assertSuper=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Super&quot;</span><span class="s0">,e,t)},t.assertTaggedTemplateExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TaggedTemplateExpression&quot;</span><span class="s0">,e,t)},t.assertTemplateElement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TemplateElement&quot;</span><span class="s0">,e,t)},t.assertTemplateLiteral=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TemplateLiteral&quot;</span><span class="s0">,e,t)},t.assertYieldExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;YieldExpression&quot;</span><span class="s0">,e,t)},t.assertAwaitExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;AwaitExpression&quot;</span><span class="s0">,e,t)},t.assertImport=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Import&quot;</span><span class="s0">,e,t)},t.assertBigIntLiteral=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;BigIntLiteral&quot;</span><span class="s0">,e,t)},t.assertExportNamespaceSpecifier=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ExportNamespaceSpecifier&quot;</span><span class="s0">,e,t)},t.assertOptionalMemberExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">,e,t)},t.assertOptionalCallExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;OptionalCallExpression&quot;</span><span class="s0">,e,t)},t.assertAnyTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;AnyTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertArrayTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ArrayTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertBooleanTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;BooleanTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertBooleanLiteralTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;BooleanLiteralTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertNullLiteralTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;NullLiteralTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertClassImplements=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ClassImplements&quot;</span><span class="s0">,e,t)},t.assertDeclareClass=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;DeclareClass&quot;</span><span class="s0">,e,t)},t.assertDeclareFunction=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;DeclareFunction&quot;</span><span class="s0">,e,t)},t.assertDeclareInterface=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;DeclareInterface&quot;</span><span class="s0">,e,t)},t.assertDeclareModule=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;DeclareModule&quot;</span><span class="s0">,e,t)},t.assertDeclareModuleExports=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;DeclareModuleExports&quot;</span><span class="s0">,e,t)},t.assertDeclareTypeAlias=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;DeclareTypeAlias&quot;</span><span class="s0">,e,t)},t.assertDeclareOpaqueType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;DeclareOpaqueType&quot;</span><span class="s0">,e,t)},t.assertDeclareVariable=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;DeclareVariable&quot;</span><span class="s0">,e,t)},t.assertDeclareExportDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;DeclareExportDeclaration&quot;</span><span class="s0">,e,t)},t.assertDeclareExportAllDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;DeclareExportAllDeclaration&quot;</span><span class="s0">,e,t)},t.assertDeclaredPredicate=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;DeclaredPredicate&quot;</span><span class="s0">,e,t)},t.assertExistsTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ExistsTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertFunctionTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertFunctionTypeParam=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;FunctionTypeParam&quot;</span><span class="s0">,e,t)},t.assertGenericTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;GenericTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertInferredPredicate=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;InferredPredicate&quot;</span><span class="s0">,e,t)},t.assertInterfaceExtends=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;InterfaceExtends&quot;</span><span class="s0">,e,t)},t.assertInterfaceDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;InterfaceDeclaration&quot;</span><span class="s0">,e,t)},t.assertInterfaceTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;InterfaceTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertIntersectionTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;IntersectionTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertMixedTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;MixedTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertEmptyTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;EmptyTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertNullableTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;NullableTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertNumberLiteralTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;NumberLiteralTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertNumberTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;NumberTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertObjectTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ObjectTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertObjectTypeInternalSlot=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ObjectTypeInternalSlot&quot;</span><span class="s0">,e,t)},t.assertObjectTypeCallProperty=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ObjectTypeCallProperty&quot;</span><span class="s0">,e,t)},t.assertObjectTypeIndexer=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ObjectTypeIndexer&quot;</span><span class="s0">,e,t)},t.assertObjectTypeProperty=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ObjectTypeProperty&quot;</span><span class="s0">,e,t)},t.assertObjectTypeSpreadProperty=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ObjectTypeSpreadProperty&quot;</span><span class="s0">,e,t)},t.assertOpaqueType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;OpaqueType&quot;</span><span class="s0">,e,t)},t.assertQualifiedTypeIdentifier=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;QualifiedTypeIdentifier&quot;</span><span class="s0">,e,t)},t.assertStringLiteralTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;StringLiteralTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertStringTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;StringTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertSymbolTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;SymbolTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertThisTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ThisTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertTupleTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TupleTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertTypeofTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TypeofTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertTypeAlias=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TypeAlias&quot;</span><span class="s0">,e,t)},t.assertTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertTypeCastExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">,e,t)},t.assertTypeParameter=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TypeParameter&quot;</span><span class="s0">,e,t)},t.assertTypeParameterDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">,e,t)},t.assertTypeParameterInstantiation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">,e,t)},t.assertUnionTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;UnionTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertVariance=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Variance&quot;</span><span class="s0">,e,t)},t.assertVoidTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;VoidTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertEnumDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;EnumDeclaration&quot;</span><span class="s0">,e,t)},t.assertEnumBooleanBody=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;EnumBooleanBody&quot;</span><span class="s0">,e,t)},t.assertEnumNumberBody=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;EnumNumberBody&quot;</span><span class="s0">,e,t)},t.assertEnumStringBody=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;EnumStringBody&quot;</span><span class="s0">,e,t)},t.assertEnumSymbolBody=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;EnumSymbolBody&quot;</span><span class="s0">,e,t)},t.assertEnumBooleanMember=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;EnumBooleanMember&quot;</span><span class="s0">,e,t)},t.assertEnumNumberMember=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;EnumNumberMember&quot;</span><span class="s0">,e,t)},t.assertEnumStringMember=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;EnumStringMember&quot;</span><span class="s0">,e,t)},t.assertEnumDefaultedMember=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;EnumDefaultedMember&quot;</span><span class="s0">,e,t)},t.assertIndexedAccessType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;IndexedAccessType&quot;</span><span class="s0">,e,t)},t.assertOptionalIndexedAccessType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;OptionalIndexedAccessType&quot;</span><span class="s0">,e,t)},t.assertJSXAttribute=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;JSXAttribute&quot;</span><span class="s0">,e,t)},t.assertJSXClosingElement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;JSXClosingElement&quot;</span><span class="s0">,e,t)},t.assertJSXElement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;JSXElement&quot;</span><span class="s0">,e,t)},t.assertJSXEmptyExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;JSXEmptyExpression&quot;</span><span class="s0">,e,t)},t.assertJSXExpressionContainer=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;JSXExpressionContainer&quot;</span><span class="s0">,e,t)},t.assertJSXSpreadChild=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;JSXSpreadChild&quot;</span><span class="s0">,e,t)},t.assertJSXIdentifier=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">,e,t)},t.assertJSXMemberExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s0">,e,t)},t.assertJSXNamespacedName=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">,e,t)},t.assertJSXOpeningElement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;JSXOpeningElement&quot;</span><span class="s0">,e,t)},t.assertJSXSpreadAttribute=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;JSXSpreadAttribute&quot;</span><span class="s0">,e,t)},t.assertJSXText=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;JSXText&quot;</span><span class="s0">,e,t)},t.assertJSXFragment=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;JSXFragment&quot;</span><span class="s0">,e,t)},t.assertJSXOpeningFragment=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;JSXOpeningFragment&quot;</span><span class="s0">,e,t)},t.assertJSXClosingFragment=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;JSXClosingFragment&quot;</span><span class="s0">,e,t)},t.assertNoop=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Noop&quot;</span><span class="s0">,e,t)},t.assertPlaceholder=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">,e,t)},t.assertV8IntrinsicIdentifier=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;V8IntrinsicIdentifier&quot;</span><span class="s0">,e,t)},t.assertArgumentPlaceholder=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ArgumentPlaceholder&quot;</span><span class="s0">,e,t)},t.assertBindExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;BindExpression&quot;</span><span class="s0">,e,t)},t.assertClassProperty=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ClassProperty&quot;</span><span class="s0">,e,t)},t.assertPipelineTopicExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;PipelineTopicExpression&quot;</span><span class="s0">,e,t)},t.assertPipelineBareFunction=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;PipelineBareFunction&quot;</span><span class="s0">,e,t)},t.assertPipelinePrimaryTopicReference=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;PipelinePrimaryTopicReference&quot;</span><span class="s0">,e,t)},t.assertClassPrivateProperty=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ClassPrivateProperty&quot;</span><span class="s0">,e,t)},t.assertClassPrivateMethod=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">,e,t)},t.assertImportAttribute=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ImportAttribute&quot;</span><span class="s0">,e,t)},t.assertDecorator=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">,e,t)},t.assertDoExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;DoExpression&quot;</span><span class="s0">,e,t)},t.assertExportDefaultSpecifier=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ExportDefaultSpecifier&quot;</span><span class="s0">,e,t)},t.assertPrivateName=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">,e,t)},t.assertRecordExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;RecordExpression&quot;</span><span class="s0">,e,t)},t.assertTupleExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TupleExpression&quot;</span><span class="s0">,e,t)},t.assertDecimalLiteral=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;DecimalLiteral&quot;</span><span class="s0">,e,t)},t.assertStaticBlock=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;StaticBlock&quot;</span><span class="s0">,e,t)},t.assertModuleExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ModuleExpression&quot;</span><span class="s0">,e,t)},t.assertTSParameterProperty=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSParameterProperty&quot;</span><span class="s0">,e,t)},t.assertTSDeclareFunction=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSDeclareFunction&quot;</span><span class="s0">,e,t)},t.assertTSDeclareMethod=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSDeclareMethod&quot;</span><span class="s0">,e,t)},t.assertTSQualifiedName=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSQualifiedName&quot;</span><span class="s0">,e,t)},t.assertTSCallSignatureDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSCallSignatureDeclaration&quot;</span><span class="s0">,e,t)},t.assertTSConstructSignatureDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSConstructSignatureDeclaration&quot;</span><span class="s0">,e,t)},t.assertTSPropertySignature=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSPropertySignature&quot;</span><span class="s0">,e,t)},t.assertTSMethodSignature=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSMethodSignature&quot;</span><span class="s0">,e,t)},t.assertTSIndexSignature=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSIndexSignature&quot;</span><span class="s0">,e,t)},t.assertTSAnyKeyword=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSAnyKeyword&quot;</span><span class="s0">,e,t)},t.assertTSBooleanKeyword=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSBooleanKeyword&quot;</span><span class="s0">,e,t)},t.assertTSBigIntKeyword=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSBigIntKeyword&quot;</span><span class="s0">,e,t)},t.assertTSIntrinsicKeyword=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSIntrinsicKeyword&quot;</span><span class="s0">,e,t)},t.assertTSNeverKeyword=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSNeverKeyword&quot;</span><span class="s0">,e,t)},t.assertTSNullKeyword=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSNullKeyword&quot;</span><span class="s0">,e,t)},t.assertTSNumberKeyword=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSNumberKeyword&quot;</span><span class="s0">,e,t)},t.assertTSObjectKeyword=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSObjectKeyword&quot;</span><span class="s0">,e,t)},t.assertTSStringKeyword=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSStringKeyword&quot;</span><span class="s0">,e,t)},t.assertTSSymbolKeyword=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSSymbolKeyword&quot;</span><span class="s0">,e,t)},t.assertTSUndefinedKeyword=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSUndefinedKeyword&quot;</span><span class="s0">,e,t)},t.assertTSUnknownKeyword=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSUnknownKeyword&quot;</span><span class="s0">,e,t)},t.assertTSVoidKeyword=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSVoidKeyword&quot;</span><span class="s0">,e,t)},t.assertTSThisType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSThisType&quot;</span><span class="s0">,e,t)},t.assertTSFunctionType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSFunctionType&quot;</span><span class="s0">,e,t)},t.assertTSConstructorType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSConstructorType&quot;</span><span class="s0">,e,t)},t.assertTSTypeReference=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSTypeReference&quot;</span><span class="s0">,e,t)},t.assertTSTypePredicate=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSTypePredicate&quot;</span><span class="s0">,e,t)},t.assertTSTypeQuery=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSTypeQuery&quot;</span><span class="s0">,e,t)},t.assertTSTypeLiteral=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSTypeLiteral&quot;</span><span class="s0">,e,t)},t.assertTSArrayType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSArrayType&quot;</span><span class="s0">,e,t)},t.assertTSTupleType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSTupleType&quot;</span><span class="s0">,e,t)},t.assertTSOptionalType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSOptionalType&quot;</span><span class="s0">,e,t)},t.assertTSRestType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSRestType&quot;</span><span class="s0">,e,t)},t.assertTSNamedTupleMember=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSNamedTupleMember&quot;</span><span class="s0">,e,t)},t.assertTSUnionType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSUnionType&quot;</span><span class="s0">,e,t)},t.assertTSIntersectionType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSIntersectionType&quot;</span><span class="s0">,e,t)},t.assertTSConditionalType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSConditionalType&quot;</span><span class="s0">,e,t)},t.assertTSInferType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSInferType&quot;</span><span class="s0">,e,t)},t.assertTSParenthesizedType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSParenthesizedType&quot;</span><span class="s0">,e,t)},t.assertTSTypeOperator=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSTypeOperator&quot;</span><span class="s0">,e,t)},t.assertTSIndexedAccessType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSIndexedAccessType&quot;</span><span class="s0">,e,t)},t.assertTSMappedType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSMappedType&quot;</span><span class="s0">,e,t)},t.assertTSLiteralType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSLiteralType&quot;</span><span class="s0">,e,t)},t.assertTSExpressionWithTypeArguments=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSExpressionWithTypeArguments&quot;</span><span class="s0">,e,t)},t.assertTSInterfaceDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSInterfaceDeclaration&quot;</span><span class="s0">,e,t)},t.assertTSInterfaceBody=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSInterfaceBody&quot;</span><span class="s0">,e,t)},t.assertTSTypeAliasDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSTypeAliasDeclaration&quot;</span><span class="s0">,e,t)},t.assertTSAsExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSAsExpression&quot;</span><span class="s0">,e,t)},t.assertTSTypeAssertion=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSTypeAssertion&quot;</span><span class="s0">,e,t)},t.assertTSEnumDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSEnumDeclaration&quot;</span><span class="s0">,e,t)},t.assertTSEnumMember=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSEnumMember&quot;</span><span class="s0">,e,t)},t.assertTSModuleDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSModuleDeclaration&quot;</span><span class="s0">,e,t)},t.assertTSModuleBlock=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSModuleBlock&quot;</span><span class="s0">,e,t)},t.assertTSImportType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSImportType&quot;</span><span class="s0">,e,t)},t.assertTSImportEqualsDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSImportEqualsDeclaration&quot;</span><span class="s0">,e,t)},t.assertTSExternalModuleReference=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSExternalModuleReference&quot;</span><span class="s0">,e,t)},t.assertTSNonNullExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSNonNullExpression&quot;</span><span class="s0">,e,t)},t.assertTSExportAssignment=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSExportAssignment&quot;</span><span class="s0">,e,t)},t.assertTSNamespaceExportDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSNamespaceExportDeclaration&quot;</span><span class="s0">,e,t)},t.assertTSTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">,e,t)},t.assertTSTypeParameterInstantiation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">,e,t)},t.assertTSTypeParameterDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSTypeParameterDeclaration&quot;</span><span class="s0">,e,t)},t.assertTSTypeParameter=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSTypeParameter&quot;</span><span class="s0">,e,t)},t.assertExpression=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,e,t)},t.assertBinary=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Binary&quot;</span><span class="s0">,e,t)},t.assertScopable=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,e,t)},t.assertBlockParent=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">,e,t)},t.assertBlock=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Block&quot;</span><span class="s0">,e,t)},t.assertStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,e,t)},t.assertTerminatorless=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Terminatorless&quot;</span><span class="s0">,e,t)},t.assertCompletionStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;CompletionStatement&quot;</span><span class="s0">,e,t)},t.assertConditional=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Conditional&quot;</span><span class="s0">,e,t)},t.assertLoop=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Loop&quot;</span><span class="s0">,e,t)},t.assertWhile=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;While&quot;</span><span class="s0">,e,t)},t.assertExpressionWrapper=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ExpressionWrapper&quot;</span><span class="s0">,e,t)},t.assertFor=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;For&quot;</span><span class="s0">,e,t)},t.assertForXStatement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ForXStatement&quot;</span><span class="s0">,e,t)},t.assertFunction=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Function&quot;</span><span class="s0">,e,t)},t.assertFunctionParent=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;FunctionParent&quot;</span><span class="s0">,e,t)},t.assertPureish=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Pureish&quot;</span><span class="s0">,e,t)},t.assertDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">,e,t)},t.assertPatternLike=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;PatternLike&quot;</span><span class="s0">,e,t)},t.assertLVal=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;LVal&quot;</span><span class="s0">,e,t)},t.assertTSEntityName=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSEntityName&quot;</span><span class="s0">,e,t)},t.assertLiteral=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Literal&quot;</span><span class="s0">,e,t)},t.assertImmutable=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">,e,t)},t.assertUserWhitespacable=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;UserWhitespacable&quot;</span><span class="s0">,e,t)},t.assertMethod=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Method&quot;</span><span class="s0">,e,t)},t.assertObjectMember=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ObjectMember&quot;</span><span class="s0">,e,t)},t.assertProperty=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Property&quot;</span><span class="s0">,e,t)},t.assertUnaryLike=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;UnaryLike&quot;</span><span class="s0">,e,t)},t.assertPattern=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">,e,t)},t.assertClass=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Class&quot;</span><span class="s0">,e,t)},t.assertModuleDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ModuleDeclaration&quot;</span><span class="s0">,e,t)},t.assertExportDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ExportDeclaration&quot;</span><span class="s0">,e,t)},t.assertModuleSpecifier=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;ModuleSpecifier&quot;</span><span class="s0">,e,t)},t.assertFlow=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,e,t)},t.assertFlowType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">,e,t)},t.assertFlowBaseAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;FlowBaseAnnotation&quot;</span><span class="s0">,e,t)},t.assertFlowDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;FlowDeclaration&quot;</span><span class="s0">,e,t)},t.assertFlowPredicate=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;FlowPredicate&quot;</span><span class="s0">,e,t)},t.assertEnumBody=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;EnumBody&quot;</span><span class="s0">,e,t)},t.assertEnumMember=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;EnumMember&quot;</span><span class="s0">,e,t)},t.assertJSX=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;JSX&quot;</span><span class="s0">,e,t)},t.assertPrivate=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;Private&quot;</span><span class="s0">,e,t)},t.assertTSTypeElement=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSTypeElement&quot;</span><span class="s0">,e,t)},t.assertTSType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">,e,t)},t.assertTSBaseType=</span><span class="s1">function</span><span class="s0">(e,t){i(</span><span class="s3">&quot;TSBaseType&quot;</span><span class="s0">,e,t)},t.assertNumberLiteral=</span><span class="s1">function</span><span class="s0">(e,t){console.trace(</span><span class="s3">&quot;The node type NumberLiteral has been renamed to NumericLiteral&quot;</span><span class="s0">),i(</span><span class="s3">&quot;NumberLiteral&quot;</span><span class="s0">,e,t)},t.assertRegexLiteral=</span><span class="s1">function</span><span class="s0">(e,t){console.trace(</span><span class="s3">&quot;The node type RegexLiteral has been renamed to RegExpLiteral&quot;</span><span class="s0">),i(</span><span class="s3">&quot;RegexLiteral&quot;</span><span class="s0">,e,t)},t.assertRestProperty=</span><span class="s1">function</span><span class="s0">(e,t){console.trace(</span><span class="s3">&quot;The node type RestProperty has been renamed to RestElement&quot;</span><span class="s0">),i(</span><span class="s3">&quot;RestProperty&quot;</span><span class="s0">,e,t)},t.assertSpreadProperty=</span><span class="s1">function</span><span class="s0">(e,t){console.trace(</span><span class="s3">&quot;The node type SpreadProperty has been renamed to SpreadElement&quot;</span><span class="s0">),i(</span><span class="s3">&quot;SpreadProperty&quot;</span><span class="s0">,e,t)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">5001</span><span class="s0">);</span><span class="s1">function </span><span class="s0">i(e,t,r){</span><span class="s1">if</span><span class="s0">(!(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t,r))</span><span class="s1">throw new </span><span class="s0">Error(`Expected type </span><span class="s3">&quot;${e}&quot; </span><span class="s1">with </span><span class="s0">option ${JSON.stringify(r)}, but instead got </span><span class="s3">&quot;${t.type}&quot;</span><span class="s0">.`)}},</span><span class="s2">2006</span><span class="s0">:()=&gt;{},</span><span class="s2">9234</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,...t){const r=n.BUILDER_KEYS[e],s=t.length;</span><span class="s1">if</span><span class="s0">(s&gt;r.length)</span><span class="s1">throw new </span><span class="s0">Error(`${e}: Too many arguments passed. Received ${s} but can receive no more than ${r.length}`);const a={type:e};let o=</span><span class="s2">0</span><span class="s0">;r.forEach((r=&gt;{const i=n.NODE_FIELDS[e][r];let l;o&lt;s&amp;&amp;(l=t[o]),</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===l&amp;&amp;(l=Array.isArray(i.</span><span class="s1">default</span><span class="s0">)?[]:i.</span><span class="s1">default</span><span class="s0">),a[r]=l,o++}));</span><span class="s1">for</span><span class="s0">(const e of Object.keys(a))(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(a,e,a[e]);</span><span class="s1">return </span><span class="s0">a};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1102</span><span class="s0">),i=r(</span><span class="s2">1843</span><span class="s0">)},</span><span class="s2">4660</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){const t=(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(e);</span><span class="s1">return </span><span class="s2">1</span><span class="s0">===t.length?t[</span><span class="s2">0</span><span class="s0">]:(</span><span class="s2">0</span><span class="s0">,n.unionTypeAnnotation)(t)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1580</span><span class="s0">),i=r(</span><span class="s2">6337</span><span class="s0">)},</span><span class="s2">7395</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;string&quot;</span><span class="s0">===e)</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.stringTypeAnnotation)();</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;number&quot;</span><span class="s0">===e)</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.numberTypeAnnotation)();</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;undefined&quot;</span><span class="s0">===e)</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.voidTypeAnnotation)();</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">===e)</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.booleanTypeAnnotation)();</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">===e)</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.genericTypeAnnotation)((</span><span class="s2">0</span><span class="s0">,n.identifier)(</span><span class="s3">&quot;Function&quot;</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;object&quot;</span><span class="s0">===e)</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.genericTypeAnnotation)((</span><span class="s2">0</span><span class="s0">,n.identifier)(</span><span class="s3">&quot;Object&quot;</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;symbol&quot;</span><span class="s0">===e)</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.genericTypeAnnotation)((</span><span class="s2">0</span><span class="s0">,n.identifier)(</span><span class="s3">&quot;Symbol&quot;</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;bigint&quot;</span><span class="s0">===e)</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.anyTypeAnnotation)();</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Invalid typeof value: &quot;</span><span class="s0">+e)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1580</span><span class="s0">)},</span><span class="s2">1580</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.arrayExpression=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s0">,...arguments)},t.assignmentExpression=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s0">,...arguments)},t.binaryExpression=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;BinaryExpression&quot;</span><span class="s0">,...arguments)},t.interpreterDirective=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;InterpreterDirective&quot;</span><span class="s0">,...arguments)},t.directive=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Directive&quot;</span><span class="s0">,...arguments)},t.directiveLiteral=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DirectiveLiteral&quot;</span><span class="s0">,...arguments)},t.blockStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">,...arguments)},t.breakStatement=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;BreakStatement&quot;</span><span class="s0">,...arguments)},t.callExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;CallExpression&quot;</span><span class="s0">,...arguments)},t.catchClause=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;CatchClause&quot;</span><span class="s0">,...arguments)},t.conditionalExpression=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s0">,...arguments)},t.continueStatement=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ContinueStatement&quot;</span><span class="s0">,...arguments)},t.debuggerStatement=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DebuggerStatement&quot;</span><span class="s0">,...arguments)},t.doWhileStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s0">,...arguments)},t.emptyStatement=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EmptyStatement&quot;</span><span class="s0">,...arguments)},t.expressionStatement=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s0">,...arguments)},t.file=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;File&quot;</span><span class="s0">,...arguments)},t.forInStatement=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ForInStatement&quot;</span><span class="s0">,...arguments)},t.forStatement=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ForStatement&quot;</span><span class="s0">,...arguments)},t.functionDeclaration=</span><span class="s1">function</span><span class="s0">(e,t,r,i,s){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">,...arguments)},t.functionExpression=</span><span class="s1">function</span><span class="s0">(e,t,r,i,s){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">,...arguments)},t.identifier=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,...arguments)},t.ifStatement=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;IfStatement&quot;</span><span class="s0">,...arguments)},t.labeledStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;LabeledStatement&quot;</span><span class="s0">,...arguments)},t.stringLiteral=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">,...arguments)},t.numericLiteral=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">,...arguments)},t.nullLiteral=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;NullLiteral&quot;</span><span class="s0">,...arguments)},t.booleanLiteral=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;BooleanLiteral&quot;</span><span class="s0">,...arguments)},t.regExpLiteral=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;RegExpLiteral&quot;</span><span class="s0">,...arguments)},t.logicalExpression=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;LogicalExpression&quot;</span><span class="s0">,...arguments)},t.memberExpression=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">,...arguments)},t.newExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;NewExpression&quot;</span><span class="s0">,...arguments)},t.program=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Program&quot;</span><span class="s0">,...arguments)},t.objectExpression=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s0">,...arguments)},t.objectMethod=</span><span class="s1">function</span><span class="s0">(e,t,r,i,s,a,o){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">,...arguments)},t.objectProperty=</span><span class="s1">function</span><span class="s0">(e,t,r,i,s){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">,...arguments)},t.restElement=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">,...arguments)},t.returnStatement=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ReturnStatement&quot;</span><span class="s0">,...arguments)},t.sequenceExpression=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s0">,...arguments)},t.parenthesizedExpression=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">,...arguments)},t.switchCase=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;SwitchCase&quot;</span><span class="s0">,...arguments)},t.switchStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;SwitchStatement&quot;</span><span class="s0">,...arguments)},t.thisExpression=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ThisExpression&quot;</span><span class="s0">,...arguments)},t.throwStatement=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ThrowStatement&quot;</span><span class="s0">,...arguments)},t.tryStatement=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TryStatement&quot;</span><span class="s0">,...arguments)},t.unaryExpression=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;UnaryExpression&quot;</span><span class="s0">,...arguments)},t.updateExpression=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;UpdateExpression&quot;</span><span class="s0">,...arguments)},t.variableDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">,...arguments)},t.variableDeclarator=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s0">,...arguments)},t.whileStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;WhileStatement&quot;</span><span class="s0">,...arguments)},t.withStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;WithStatement&quot;</span><span class="s0">,...arguments)},t.assignmentPattern=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">,...arguments)},t.arrayPattern=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">,...arguments)},t.arrowFunctionExpression=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">,...arguments)},t.classBody=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ClassBody&quot;</span><span class="s0">,...arguments)},t.classExpression=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ClassExpression&quot;</span><span class="s0">,...arguments)},t.classDeclaration=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">,...arguments)},t.exportAllDeclaration=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">,...arguments)},t.exportDefaultDeclaration=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">,...arguments)},t.exportNamedDeclaration=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">,...arguments)},t.exportSpecifier=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExportSpecifier&quot;</span><span class="s0">,...arguments)},t.forOfStatement=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s0">,...arguments)},t.importDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">,...arguments)},t.importDefaultSpecifier=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">,...arguments)},t.importNamespaceSpecifier=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ImportNamespaceSpecifier&quot;</span><span class="s0">,...arguments)},t.importSpecifier=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s0">,...arguments)},t.metaProperty=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;MetaProperty&quot;</span><span class="s0">,...arguments)},t.classMethod=</span><span class="s1">function</span><span class="s0">(e,t,r,i,s,a,o,l){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">,...arguments)},t.objectPattern=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">,...arguments)},t.spreadElement=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">,...arguments)},t.super=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Super&quot;</span><span class="s0">,...arguments)},t.taggedTemplateExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TaggedTemplateExpression&quot;</span><span class="s0">,...arguments)},t.templateElement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TemplateElement&quot;</span><span class="s0">,...arguments)},t.templateLiteral=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TemplateLiteral&quot;</span><span class="s0">,...arguments)},t.yieldExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;YieldExpression&quot;</span><span class="s0">,...arguments)},t.awaitExpression=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;AwaitExpression&quot;</span><span class="s0">,...arguments)},t.import=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Import&quot;</span><span class="s0">,...arguments)},t.bigIntLiteral=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;BigIntLiteral&quot;</span><span class="s0">,...arguments)},t.exportNamespaceSpecifier=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExportNamespaceSpecifier&quot;</span><span class="s0">,...arguments)},t.optionalMemberExpression=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">,...arguments)},t.optionalCallExpression=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;OptionalCallExpression&quot;</span><span class="s0">,...arguments)},t.anyTypeAnnotation=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;AnyTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.arrayTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ArrayTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.booleanTypeAnnotation=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;BooleanTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.booleanLiteralTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;BooleanLiteralTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.nullLiteralTypeAnnotation=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;NullLiteralTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.classImplements=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ClassImplements&quot;</span><span class="s0">,...arguments)},t.declareClass=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareClass&quot;</span><span class="s0">,...arguments)},t.declareFunction=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareFunction&quot;</span><span class="s0">,...arguments)},t.declareInterface=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareInterface&quot;</span><span class="s0">,...arguments)},t.declareModule=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareModule&quot;</span><span class="s0">,...arguments)},t.declareModuleExports=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareModuleExports&quot;</span><span class="s0">,...arguments)},t.declareTypeAlias=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareTypeAlias&quot;</span><span class="s0">,...arguments)},t.declareOpaqueType=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareOpaqueType&quot;</span><span class="s0">,...arguments)},t.declareVariable=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareVariable&quot;</span><span class="s0">,...arguments)},t.declareExportDeclaration=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareExportDeclaration&quot;</span><span class="s0">,...arguments)},t.declareExportAllDeclaration=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareExportAllDeclaration&quot;</span><span class="s0">,...arguments)},t.declaredPredicate=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclaredPredicate&quot;</span><span class="s0">,...arguments)},t.existsTypeAnnotation=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExistsTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.functionTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.functionTypeParam=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;FunctionTypeParam&quot;</span><span class="s0">,...arguments)},t.genericTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;GenericTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.inferredPredicate=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;InferredPredicate&quot;</span><span class="s0">,...arguments)},t.interfaceExtends=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;InterfaceExtends&quot;</span><span class="s0">,...arguments)},t.interfaceDeclaration=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;InterfaceDeclaration&quot;</span><span class="s0">,...arguments)},t.interfaceTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;InterfaceTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.intersectionTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;IntersectionTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.mixedTypeAnnotation=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;MixedTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.emptyTypeAnnotation=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EmptyTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.nullableTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;NullableTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.numberLiteralTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;NumberLiteralTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.numberTypeAnnotation=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;NumberTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.objectTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t,r,i,s){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.objectTypeInternalSlot=</span><span class="s1">function</span><span class="s0">(e,t,r,i,s){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectTypeInternalSlot&quot;</span><span class="s0">,...arguments)},t.objectTypeCallProperty=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectTypeCallProperty&quot;</span><span class="s0">,...arguments)},t.objectTypeIndexer=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectTypeIndexer&quot;</span><span class="s0">,...arguments)},t.objectTypeProperty=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectTypeProperty&quot;</span><span class="s0">,...arguments)},t.objectTypeSpreadProperty=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectTypeSpreadProperty&quot;</span><span class="s0">,...arguments)},t.opaqueType=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;OpaqueType&quot;</span><span class="s0">,...arguments)},t.qualifiedTypeIdentifier=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;QualifiedTypeIdentifier&quot;</span><span class="s0">,...arguments)},t.stringLiteralTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;StringLiteralTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.stringTypeAnnotation=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;StringTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.symbolTypeAnnotation=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;SymbolTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.thisTypeAnnotation=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ThisTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.tupleTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TupleTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.typeofTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TypeofTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.typeAlias=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TypeAlias&quot;</span><span class="s0">,...arguments)},t.typeAnnotation=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">,...arguments)},t.typeCastExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">,...arguments)},t.typeParameter=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TypeParameter&quot;</span><span class="s0">,...arguments)},t.typeParameterDeclaration=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">,...arguments)},t.typeParameterInstantiation=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">,...arguments)},t.unionTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;UnionTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.variance=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Variance&quot;</span><span class="s0">,...arguments)},t.voidTypeAnnotation=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;VoidTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.enumDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumDeclaration&quot;</span><span class="s0">,...arguments)},t.enumBooleanBody=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumBooleanBody&quot;</span><span class="s0">,...arguments)},t.enumNumberBody=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumNumberBody&quot;</span><span class="s0">,...arguments)},t.enumStringBody=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumStringBody&quot;</span><span class="s0">,...arguments)},t.enumSymbolBody=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumSymbolBody&quot;</span><span class="s0">,...arguments)},t.enumBooleanMember=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumBooleanMember&quot;</span><span class="s0">,...arguments)},t.enumNumberMember=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumNumberMember&quot;</span><span class="s0">,...arguments)},t.enumStringMember=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumStringMember&quot;</span><span class="s0">,...arguments)},t.enumDefaultedMember=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumDefaultedMember&quot;</span><span class="s0">,...arguments)},t.indexedAccessType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;IndexedAccessType&quot;</span><span class="s0">,...arguments)},t.optionalIndexedAccessType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;OptionalIndexedAccessType&quot;</span><span class="s0">,...arguments)},t.jSXAttribute=t.jsxAttribute=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXAttribute&quot;</span><span class="s0">,...arguments)},t.jSXClosingElement=t.jsxClosingElement=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXClosingElement&quot;</span><span class="s0">,...arguments)},t.jSXElement=t.jsxElement=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXElement&quot;</span><span class="s0">,...arguments)},t.jSXEmptyExpression=t.jsxEmptyExpression=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXEmptyExpression&quot;</span><span class="s0">,...arguments)},t.jSXExpressionContainer=t.jsxExpressionContainer=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXExpressionContainer&quot;</span><span class="s0">,...arguments)},t.jSXSpreadChild=t.jsxSpreadChild=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXSpreadChild&quot;</span><span class="s0">,...arguments)},t.jSXIdentifier=t.jsxIdentifier=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">,...arguments)},t.jSXMemberExpression=t.jsxMemberExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s0">,...arguments)},t.jSXNamespacedName=t.jsxNamespacedName=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">,...arguments)},t.jSXOpeningElement=t.jsxOpeningElement=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXOpeningElement&quot;</span><span class="s0">,...arguments)},t.jSXSpreadAttribute=t.jsxSpreadAttribute=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXSpreadAttribute&quot;</span><span class="s0">,...arguments)},t.jSXText=t.jsxText=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXText&quot;</span><span class="s0">,...arguments)},t.jSXFragment=t.jsxFragment=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXFragment&quot;</span><span class="s0">,...arguments)},t.jSXOpeningFragment=t.jsxOpeningFragment=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXOpeningFragment&quot;</span><span class="s0">,...arguments)},t.jSXClosingFragment=t.jsxClosingFragment=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXClosingFragment&quot;</span><span class="s0">,...arguments)},t.noop=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Noop&quot;</span><span class="s0">,...arguments)},t.placeholder=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">,...arguments)},t.v8IntrinsicIdentifier=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;V8IntrinsicIdentifier&quot;</span><span class="s0">,...arguments)},t.argumentPlaceholder=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ArgumentPlaceholder&quot;</span><span class="s0">,...arguments)},t.bindExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;BindExpression&quot;</span><span class="s0">,...arguments)},t.classProperty=</span><span class="s1">function</span><span class="s0">(e,t,r,i,s,a){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ClassProperty&quot;</span><span class="s0">,...arguments)},t.pipelineTopicExpression=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;PipelineTopicExpression&quot;</span><span class="s0">,...arguments)},t.pipelineBareFunction=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;PipelineBareFunction&quot;</span><span class="s0">,...arguments)},t.pipelinePrimaryTopicReference=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;PipelinePrimaryTopicReference&quot;</span><span class="s0">,...arguments)},t.classPrivateProperty=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ClassPrivateProperty&quot;</span><span class="s0">,...arguments)},t.classPrivateMethod=</span><span class="s1">function</span><span class="s0">(e,t,r,i,s){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">,...arguments)},t.importAttribute=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ImportAttribute&quot;</span><span class="s0">,...arguments)},t.decorator=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">,...arguments)},t.doExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DoExpression&quot;</span><span class="s0">,...arguments)},t.exportDefaultSpecifier=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExportDefaultSpecifier&quot;</span><span class="s0">,...arguments)},t.privateName=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">,...arguments)},t.recordExpression=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;RecordExpression&quot;</span><span class="s0">,...arguments)},t.tupleExpression=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TupleExpression&quot;</span><span class="s0">,...arguments)},t.decimalLiteral=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DecimalLiteral&quot;</span><span class="s0">,...arguments)},t.staticBlock=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;StaticBlock&quot;</span><span class="s0">,...arguments)},t.moduleExpression=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ModuleExpression&quot;</span><span class="s0">,...arguments)},t.tSParameterProperty=t.tsParameterProperty=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSParameterProperty&quot;</span><span class="s0">,...arguments)},t.tSDeclareFunction=t.tsDeclareFunction=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSDeclareFunction&quot;</span><span class="s0">,...arguments)},t.tSDeclareMethod=t.tsDeclareMethod=</span><span class="s1">function</span><span class="s0">(e,t,r,i,s){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSDeclareMethod&quot;</span><span class="s0">,...arguments)},t.tSQualifiedName=t.tsQualifiedName=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSQualifiedName&quot;</span><span class="s0">,...arguments)},t.tSCallSignatureDeclaration=t.tsCallSignatureDeclaration=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSCallSignatureDeclaration&quot;</span><span class="s0">,...arguments)},t.tSConstructSignatureDeclaration=t.tsConstructSignatureDeclaration=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSConstructSignatureDeclaration&quot;</span><span class="s0">,...arguments)},t.tSPropertySignature=t.tsPropertySignature=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSPropertySignature&quot;</span><span class="s0">,...arguments)},t.tSMethodSignature=t.tsMethodSignature=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSMethodSignature&quot;</span><span class="s0">,...arguments)},t.tSIndexSignature=t.tsIndexSignature=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSIndexSignature&quot;</span><span class="s0">,...arguments)},t.tSAnyKeyword=t.tsAnyKeyword=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSAnyKeyword&quot;</span><span class="s0">,...arguments)},t.tSBooleanKeyword=t.tsBooleanKeyword=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSBooleanKeyword&quot;</span><span class="s0">,...arguments)},t.tSBigIntKeyword=t.tsBigIntKeyword=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSBigIntKeyword&quot;</span><span class="s0">,...arguments)},t.tSIntrinsicKeyword=t.tsIntrinsicKeyword=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSIntrinsicKeyword&quot;</span><span class="s0">,...arguments)},t.tSNeverKeyword=t.tsNeverKeyword=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSNeverKeyword&quot;</span><span class="s0">,...arguments)},t.tSNullKeyword=t.tsNullKeyword=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSNullKeyword&quot;</span><span class="s0">,...arguments)},t.tSNumberKeyword=t.tsNumberKeyword=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSNumberKeyword&quot;</span><span class="s0">,...arguments)},t.tSObjectKeyword=t.tsObjectKeyword=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSObjectKeyword&quot;</span><span class="s0">,...arguments)},t.tSStringKeyword=t.tsStringKeyword=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSStringKeyword&quot;</span><span class="s0">,...arguments)},t.tSSymbolKeyword=t.tsSymbolKeyword=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSSymbolKeyword&quot;</span><span class="s0">,...arguments)},t.tSUndefinedKeyword=t.tsUndefinedKeyword=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSUndefinedKeyword&quot;</span><span class="s0">,...arguments)},t.tSUnknownKeyword=t.tsUnknownKeyword=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSUnknownKeyword&quot;</span><span class="s0">,...arguments)},t.tSVoidKeyword=t.tsVoidKeyword=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSVoidKeyword&quot;</span><span class="s0">,...arguments)},t.tSThisType=t.tsThisType=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSThisType&quot;</span><span class="s0">,...arguments)},t.tSFunctionType=t.tsFunctionType=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSFunctionType&quot;</span><span class="s0">,...arguments)},t.tSConstructorType=t.tsConstructorType=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSConstructorType&quot;</span><span class="s0">,...arguments)},t.tSTypeReference=t.tsTypeReference=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeReference&quot;</span><span class="s0">,...arguments)},t.tSTypePredicate=t.tsTypePredicate=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypePredicate&quot;</span><span class="s0">,...arguments)},t.tSTypeQuery=t.tsTypeQuery=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeQuery&quot;</span><span class="s0">,...arguments)},t.tSTypeLiteral=t.tsTypeLiteral=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeLiteral&quot;</span><span class="s0">,...arguments)},t.tSArrayType=t.tsArrayType=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSArrayType&quot;</span><span class="s0">,...arguments)},t.tSTupleType=t.tsTupleType=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTupleType&quot;</span><span class="s0">,...arguments)},t.tSOptionalType=t.tsOptionalType=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSOptionalType&quot;</span><span class="s0">,...arguments)},t.tSRestType=t.tsRestType=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSRestType&quot;</span><span class="s0">,...arguments)},t.tSNamedTupleMember=t.tsNamedTupleMember=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSNamedTupleMember&quot;</span><span class="s0">,...arguments)},t.tSUnionType=t.tsUnionType=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSUnionType&quot;</span><span class="s0">,...arguments)},t.tSIntersectionType=t.tsIntersectionType=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSIntersectionType&quot;</span><span class="s0">,...arguments)},t.tSConditionalType=t.tsConditionalType=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSConditionalType&quot;</span><span class="s0">,...arguments)},t.tSInferType=t.tsInferType=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSInferType&quot;</span><span class="s0">,...arguments)},t.tSParenthesizedType=t.tsParenthesizedType=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSParenthesizedType&quot;</span><span class="s0">,...arguments)},t.tSTypeOperator=t.tsTypeOperator=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeOperator&quot;</span><span class="s0">,...arguments)},t.tSIndexedAccessType=t.tsIndexedAccessType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSIndexedAccessType&quot;</span><span class="s0">,...arguments)},t.tSMappedType=t.tsMappedType=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSMappedType&quot;</span><span class="s0">,...arguments)},t.tSLiteralType=t.tsLiteralType=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSLiteralType&quot;</span><span class="s0">,...arguments)},t.tSExpressionWithTypeArguments=t.tsExpressionWithTypeArguments=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSExpressionWithTypeArguments&quot;</span><span class="s0">,...arguments)},t.tSInterfaceDeclaration=t.tsInterfaceDeclaration=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSInterfaceDeclaration&quot;</span><span class="s0">,...arguments)},t.tSInterfaceBody=t.tsInterfaceBody=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSInterfaceBody&quot;</span><span class="s0">,...arguments)},t.tSTypeAliasDeclaration=t.tsTypeAliasDeclaration=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeAliasDeclaration&quot;</span><span class="s0">,...arguments)},t.tSAsExpression=t.tsAsExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSAsExpression&quot;</span><span class="s0">,...arguments)},t.tSTypeAssertion=t.tsTypeAssertion=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeAssertion&quot;</span><span class="s0">,...arguments)},t.tSEnumDeclaration=t.tsEnumDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSEnumDeclaration&quot;</span><span class="s0">,...arguments)},t.tSEnumMember=t.tsEnumMember=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSEnumMember&quot;</span><span class="s0">,...arguments)},t.tSModuleDeclaration=t.tsModuleDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSModuleDeclaration&quot;</span><span class="s0">,...arguments)},t.tSModuleBlock=t.tsModuleBlock=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSModuleBlock&quot;</span><span class="s0">,...arguments)},t.tSImportType=t.tsImportType=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSImportType&quot;</span><span class="s0">,...arguments)},t.tSImportEqualsDeclaration=t.tsImportEqualsDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSImportEqualsDeclaration&quot;</span><span class="s0">,...arguments)},t.tSExternalModuleReference=t.tsExternalModuleReference=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSExternalModuleReference&quot;</span><span class="s0">,...arguments)},t.tSNonNullExpression=t.tsNonNullExpression=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSNonNullExpression&quot;</span><span class="s0">,...arguments)},t.tSExportAssignment=t.tsExportAssignment=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSExportAssignment&quot;</span><span class="s0">,...arguments)},t.tSNamespaceExportDeclaration=t.tsNamespaceExportDeclaration=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSNamespaceExportDeclaration&quot;</span><span class="s0">,...arguments)},t.tSTypeAnnotation=t.tsTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">,...arguments)},t.tSTypeParameterInstantiation=t.tsTypeParameterInstantiation=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">,...arguments)},t.tSTypeParameterDeclaration=t.tsTypeParameterDeclaration=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeParameterDeclaration&quot;</span><span class="s0">,...arguments)},t.tSTypeParameter=t.tsTypeParameter=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeParameter&quot;</span><span class="s0">,...arguments)},t.numberLiteral=</span><span class="s1">function</span><span class="s0">(...e){</span><span class="s1">return </span><span class="s0">console.trace(</span><span class="s3">&quot;The node type NumberLiteral has been renamed to NumericLiteral&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;NumberLiteral&quot;</span><span class="s0">,...e)},t.regexLiteral=</span><span class="s1">function</span><span class="s0">(...e){</span><span class="s1">return </span><span class="s0">console.trace(</span><span class="s3">&quot;The node type RegexLiteral has been renamed to RegExpLiteral&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;RegexLiteral&quot;</span><span class="s0">,...e)},t.restProperty=</span><span class="s1">function</span><span class="s0">(...e){</span><span class="s1">return </span><span class="s0">console.trace(</span><span class="s3">&quot;The node type RestProperty has been renamed to RestElement&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;RestProperty&quot;</span><span class="s0">,...e)},t.spreadProperty=</span><span class="s1">function</span><span class="s0">(...e){</span><span class="s1">return </span><span class="s0">console.trace(</span><span class="s3">&quot;The node type SpreadProperty has been renamed to SpreadElement&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;SpreadProperty&quot;</span><span class="s0">,...e)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">9234</span><span class="s0">)},</span><span class="s2">6306</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),Object.defineProperty(t,</span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.arrayExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.assignmentExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;BinaryExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.binaryExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;InterpreterDirective&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.interpreterDirective}}),Object.defineProperty(t,</span><span class="s3">&quot;Directive&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.directive}}),Object.defineProperty(t,</span><span class="s3">&quot;DirectiveLiteral&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.directiveLiteral}}),Object.defineProperty(t,</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.blockStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;BreakStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.breakStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;CallExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.callExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;CatchClause&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.catchClause}}),Object.defineProperty(t,</span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.conditionalExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;ContinueStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.continueStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;DebuggerStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.debuggerStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.doWhileStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;EmptyStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.emptyStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.expressionStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;File&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.file}}),Object.defineProperty(t,</span><span class="s3">&quot;ForInStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.forInStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;ForStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.forStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.functionDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.functionExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.identifier}}),Object.defineProperty(t,</span><span class="s3">&quot;IfStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.ifStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;LabeledStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.labeledStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.stringLiteral}}),Object.defineProperty(t,</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.numericLiteral}}),Object.defineProperty(t,</span><span class="s3">&quot;NullLiteral&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.nullLiteral}}),Object.defineProperty(t,</span><span class="s3">&quot;BooleanLiteral&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.booleanLiteral}}),Object.defineProperty(t,</span><span class="s3">&quot;RegExpLiteral&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.regExpLiteral}}),Object.defineProperty(t,</span><span class="s3">&quot;LogicalExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.logicalExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.memberExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;NewExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.newExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;Program&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.program}}),Object.defineProperty(t,</span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.objectExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.objectMethod}}),Object.defineProperty(t,</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.objectProperty}}),Object.defineProperty(t,</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.restElement}}),Object.defineProperty(t,</span><span class="s3">&quot;ReturnStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.returnStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.sequenceExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.parenthesizedExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;SwitchCase&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.switchCase}}),Object.defineProperty(t,</span><span class="s3">&quot;SwitchStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.switchStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;ThisExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.thisExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;ThrowStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.throwStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;TryStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tryStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;UnaryExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.unaryExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;UpdateExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.updateExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.variableDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.variableDeclarator}}),Object.defineProperty(t,</span><span class="s3">&quot;WhileStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.whileStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;WithStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.withStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.assignmentPattern}}),Object.defineProperty(t,</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.arrayPattern}}),Object.defineProperty(t,</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.arrowFunctionExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;ClassBody&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.classBody}}),Object.defineProperty(t,</span><span class="s3">&quot;ClassExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.classExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.classDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.exportAllDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.exportDefaultDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.exportNamedDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;ExportSpecifier&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.exportSpecifier}}),Object.defineProperty(t,</span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.forOfStatement}}),Object.defineProperty(t,</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.importDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.importDefaultSpecifier}}),Object.defineProperty(t,</span><span class="s3">&quot;ImportNamespaceSpecifier&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.importNamespaceSpecifier}}),Object.defineProperty(t,</span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.importSpecifier}}),Object.defineProperty(t,</span><span class="s3">&quot;MetaProperty&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.metaProperty}}),Object.defineProperty(t,</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.classMethod}}),Object.defineProperty(t,</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.objectPattern}}),Object.defineProperty(t,</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.spreadElement}}),Object.defineProperty(t,</span><span class="s3">&quot;Super&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.super}}),Object.defineProperty(t,</span><span class="s3">&quot;TaggedTemplateExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.taggedTemplateExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;TemplateElement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.templateElement}}),Object.defineProperty(t,</span><span class="s3">&quot;TemplateLiteral&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.templateLiteral}}),Object.defineProperty(t,</span><span class="s3">&quot;YieldExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.yieldExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;AwaitExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.awaitExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;Import&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.import}}),Object.defineProperty(t,</span><span class="s3">&quot;BigIntLiteral&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.bigIntLiteral}}),Object.defineProperty(t,</span><span class="s3">&quot;ExportNamespaceSpecifier&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.exportNamespaceSpecifier}}),Object.defineProperty(t,</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.optionalMemberExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;OptionalCallExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.optionalCallExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;AnyTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.anyTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;ArrayTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.arrayTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;BooleanTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.booleanTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;BooleanLiteralTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.booleanLiteralTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;NullLiteralTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.nullLiteralTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;ClassImplements&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.classImplements}}),Object.defineProperty(t,</span><span class="s3">&quot;DeclareClass&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.declareClass}}),Object.defineProperty(t,</span><span class="s3">&quot;DeclareFunction&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.declareFunction}}),Object.defineProperty(t,</span><span class="s3">&quot;DeclareInterface&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.declareInterface}}),Object.defineProperty(t,</span><span class="s3">&quot;DeclareModule&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.declareModule}}),Object.defineProperty(t,</span><span class="s3">&quot;DeclareModuleExports&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.declareModuleExports}}),Object.defineProperty(t,</span><span class="s3">&quot;DeclareTypeAlias&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.declareTypeAlias}}),Object.defineProperty(t,</span><span class="s3">&quot;DeclareOpaqueType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.declareOpaqueType}}),Object.defineProperty(t,</span><span class="s3">&quot;DeclareVariable&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.declareVariable}}),Object.defineProperty(t,</span><span class="s3">&quot;DeclareExportDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.declareExportDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;DeclareExportAllDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.declareExportAllDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;DeclaredPredicate&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.declaredPredicate}}),Object.defineProperty(t,</span><span class="s3">&quot;ExistsTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.existsTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.functionTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;FunctionTypeParam&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.functionTypeParam}}),Object.defineProperty(t,</span><span class="s3">&quot;GenericTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.genericTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;InferredPredicate&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.inferredPredicate}}),Object.defineProperty(t,</span><span class="s3">&quot;InterfaceExtends&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.interfaceExtends}}),Object.defineProperty(t,</span><span class="s3">&quot;InterfaceDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.interfaceDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;InterfaceTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.interfaceTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;IntersectionTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.intersectionTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;MixedTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.mixedTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;EmptyTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.emptyTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;NullableTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.nullableTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;NumberLiteralTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.numberLiteralTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;NumberTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.numberTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;ObjectTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.objectTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;ObjectTypeInternalSlot&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.objectTypeInternalSlot}}),Object.defineProperty(t,</span><span class="s3">&quot;ObjectTypeCallProperty&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.objectTypeCallProperty}}),Object.defineProperty(t,</span><span class="s3">&quot;ObjectTypeIndexer&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.objectTypeIndexer}}),Object.defineProperty(t,</span><span class="s3">&quot;ObjectTypeProperty&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.objectTypeProperty}}),Object.defineProperty(t,</span><span class="s3">&quot;ObjectTypeSpreadProperty&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.objectTypeSpreadProperty}}),Object.defineProperty(t,</span><span class="s3">&quot;OpaqueType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.opaqueType}}),Object.defineProperty(t,</span><span class="s3">&quot;QualifiedTypeIdentifier&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.qualifiedTypeIdentifier}}),Object.defineProperty(t,</span><span class="s3">&quot;StringLiteralTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.stringLiteralTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;StringTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.stringTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;SymbolTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.symbolTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;ThisTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.thisTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;TupleTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tupleTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;TypeofTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.typeofTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;TypeAlias&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.typeAlias}}),Object.defineProperty(t,</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.typeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.typeCastExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;TypeParameter&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.typeParameter}}),Object.defineProperty(t,</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.typeParameterDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.typeParameterInstantiation}}),Object.defineProperty(t,</span><span class="s3">&quot;UnionTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.unionTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;Variance&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.variance}}),Object.defineProperty(t,</span><span class="s3">&quot;VoidTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.voidTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;EnumDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.enumDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;EnumBooleanBody&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.enumBooleanBody}}),Object.defineProperty(t,</span><span class="s3">&quot;EnumNumberBody&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.enumNumberBody}}),Object.defineProperty(t,</span><span class="s3">&quot;EnumStringBody&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.enumStringBody}}),Object.defineProperty(t,</span><span class="s3">&quot;EnumSymbolBody&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.enumSymbolBody}}),Object.defineProperty(t,</span><span class="s3">&quot;EnumBooleanMember&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.enumBooleanMember}}),Object.defineProperty(t,</span><span class="s3">&quot;EnumNumberMember&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.enumNumberMember}}),Object.defineProperty(t,</span><span class="s3">&quot;EnumStringMember&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.enumStringMember}}),Object.defineProperty(t,</span><span class="s3">&quot;EnumDefaultedMember&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.enumDefaultedMember}}),Object.defineProperty(t,</span><span class="s3">&quot;IndexedAccessType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.indexedAccessType}}),Object.defineProperty(t,</span><span class="s3">&quot;OptionalIndexedAccessType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.optionalIndexedAccessType}}),Object.defineProperty(t,</span><span class="s3">&quot;JSXAttribute&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.jsxAttribute}}),Object.defineProperty(t,</span><span class="s3">&quot;JSXClosingElement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.jsxClosingElement}}),Object.defineProperty(t,</span><span class="s3">&quot;JSXElement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.jsxElement}}),Object.defineProperty(t,</span><span class="s3">&quot;JSXEmptyExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.jsxEmptyExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;JSXExpressionContainer&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.jsxExpressionContainer}}),Object.defineProperty(t,</span><span class="s3">&quot;JSXSpreadChild&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.jsxSpreadChild}}),Object.defineProperty(t,</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.jsxIdentifier}}),Object.defineProperty(t,</span><span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.jsxMemberExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.jsxNamespacedName}}),Object.defineProperty(t,</span><span class="s3">&quot;JSXOpeningElement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.jsxOpeningElement}}),Object.defineProperty(t,</span><span class="s3">&quot;JSXSpreadAttribute&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.jsxSpreadAttribute}}),Object.defineProperty(t,</span><span class="s3">&quot;JSXText&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.jsxText}}),Object.defineProperty(t,</span><span class="s3">&quot;JSXFragment&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.jsxFragment}}),Object.defineProperty(t,</span><span class="s3">&quot;JSXOpeningFragment&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.jsxOpeningFragment}}),Object.defineProperty(t,</span><span class="s3">&quot;JSXClosingFragment&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.jsxClosingFragment}}),Object.defineProperty(t,</span><span class="s3">&quot;Noop&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.noop}}),Object.defineProperty(t,</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.placeholder}}),Object.defineProperty(t,</span><span class="s3">&quot;V8IntrinsicIdentifier&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.v8IntrinsicIdentifier}}),Object.defineProperty(t,</span><span class="s3">&quot;ArgumentPlaceholder&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.argumentPlaceholder}}),Object.defineProperty(t,</span><span class="s3">&quot;BindExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.bindExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;ClassProperty&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.classProperty}}),Object.defineProperty(t,</span><span class="s3">&quot;PipelineTopicExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.pipelineTopicExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;PipelineBareFunction&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.pipelineBareFunction}}),Object.defineProperty(t,</span><span class="s3">&quot;PipelinePrimaryTopicReference&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.pipelinePrimaryTopicReference}}),Object.defineProperty(t,</span><span class="s3">&quot;ClassPrivateProperty&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.classPrivateProperty}}),Object.defineProperty(t,</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.classPrivateMethod}}),Object.defineProperty(t,</span><span class="s3">&quot;ImportAttribute&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.importAttribute}}),Object.defineProperty(t,</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.decorator}}),Object.defineProperty(t,</span><span class="s3">&quot;DoExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.doExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;ExportDefaultSpecifier&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.exportDefaultSpecifier}}),Object.defineProperty(t,</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.privateName}}),Object.defineProperty(t,</span><span class="s3">&quot;RecordExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.recordExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;TupleExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tupleExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;DecimalLiteral&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.decimalLiteral}}),Object.defineProperty(t,</span><span class="s3">&quot;StaticBlock&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.staticBlock}}),Object.defineProperty(t,</span><span class="s3">&quot;ModuleExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.moduleExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;TSParameterProperty&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsParameterProperty}}),Object.defineProperty(t,</span><span class="s3">&quot;TSDeclareFunction&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsDeclareFunction}}),Object.defineProperty(t,</span><span class="s3">&quot;TSDeclareMethod&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsDeclareMethod}}),Object.defineProperty(t,</span><span class="s3">&quot;TSQualifiedName&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsQualifiedName}}),Object.defineProperty(t,</span><span class="s3">&quot;TSCallSignatureDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsCallSignatureDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;TSConstructSignatureDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsConstructSignatureDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;TSPropertySignature&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsPropertySignature}}),Object.defineProperty(t,</span><span class="s3">&quot;TSMethodSignature&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsMethodSignature}}),Object.defineProperty(t,</span><span class="s3">&quot;TSIndexSignature&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsIndexSignature}}),Object.defineProperty(t,</span><span class="s3">&quot;TSAnyKeyword&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsAnyKeyword}}),Object.defineProperty(t,</span><span class="s3">&quot;TSBooleanKeyword&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsBooleanKeyword}}),Object.defineProperty(t,</span><span class="s3">&quot;TSBigIntKeyword&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsBigIntKeyword}}),Object.defineProperty(t,</span><span class="s3">&quot;TSIntrinsicKeyword&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsIntrinsicKeyword}}),Object.defineProperty(t,</span><span class="s3">&quot;TSNeverKeyword&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsNeverKeyword}}),Object.defineProperty(t,</span><span class="s3">&quot;TSNullKeyword&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsNullKeyword}}),Object.defineProperty(t,</span><span class="s3">&quot;TSNumberKeyword&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsNumberKeyword}}),Object.defineProperty(t,</span><span class="s3">&quot;TSObjectKeyword&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsObjectKeyword}}),Object.defineProperty(t,</span><span class="s3">&quot;TSStringKeyword&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsStringKeyword}}),Object.defineProperty(t,</span><span class="s3">&quot;TSSymbolKeyword&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsSymbolKeyword}}),Object.defineProperty(t,</span><span class="s3">&quot;TSUndefinedKeyword&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsUndefinedKeyword}}),Object.defineProperty(t,</span><span class="s3">&quot;TSUnknownKeyword&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsUnknownKeyword}}),Object.defineProperty(t,</span><span class="s3">&quot;TSVoidKeyword&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsVoidKeyword}}),Object.defineProperty(t,</span><span class="s3">&quot;TSThisType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsThisType}}),Object.defineProperty(t,</span><span class="s3">&quot;TSFunctionType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsFunctionType}}),Object.defineProperty(t,</span><span class="s3">&quot;TSConstructorType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsConstructorType}}),Object.defineProperty(t,</span><span class="s3">&quot;TSTypeReference&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsTypeReference}}),Object.defineProperty(t,</span><span class="s3">&quot;TSTypePredicate&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsTypePredicate}}),Object.defineProperty(t,</span><span class="s3">&quot;TSTypeQuery&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsTypeQuery}}),Object.defineProperty(t,</span><span class="s3">&quot;TSTypeLiteral&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsTypeLiteral}}),Object.defineProperty(t,</span><span class="s3">&quot;TSArrayType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsArrayType}}),Object.defineProperty(t,</span><span class="s3">&quot;TSTupleType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsTupleType}}),Object.defineProperty(t,</span><span class="s3">&quot;TSOptionalType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsOptionalType}}),Object.defineProperty(t,</span><span class="s3">&quot;TSRestType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsRestType}}),Object.defineProperty(t,</span><span class="s3">&quot;TSNamedTupleMember&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsNamedTupleMember}}),Object.defineProperty(t,</span><span class="s3">&quot;TSUnionType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsUnionType}}),Object.defineProperty(t,</span><span class="s3">&quot;TSIntersectionType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsIntersectionType}}),Object.defineProperty(t,</span><span class="s3">&quot;TSConditionalType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsConditionalType}}),Object.defineProperty(t,</span><span class="s3">&quot;TSInferType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsInferType}}),Object.defineProperty(t,</span><span class="s3">&quot;TSParenthesizedType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsParenthesizedType}}),Object.defineProperty(t,</span><span class="s3">&quot;TSTypeOperator&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsTypeOperator}}),Object.defineProperty(t,</span><span class="s3">&quot;TSIndexedAccessType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsIndexedAccessType}}),Object.defineProperty(t,</span><span class="s3">&quot;TSMappedType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsMappedType}}),Object.defineProperty(t,</span><span class="s3">&quot;TSLiteralType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsLiteralType}}),Object.defineProperty(t,</span><span class="s3">&quot;TSExpressionWithTypeArguments&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsExpressionWithTypeArguments}}),Object.defineProperty(t,</span><span class="s3">&quot;TSInterfaceDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsInterfaceDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;TSInterfaceBody&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsInterfaceBody}}),Object.defineProperty(t,</span><span class="s3">&quot;TSTypeAliasDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsTypeAliasDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;TSAsExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsAsExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;TSTypeAssertion&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsTypeAssertion}}),Object.defineProperty(t,</span><span class="s3">&quot;TSEnumDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsEnumDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;TSEnumMember&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsEnumMember}}),Object.defineProperty(t,</span><span class="s3">&quot;TSModuleDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsModuleDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;TSModuleBlock&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsModuleBlock}}),Object.defineProperty(t,</span><span class="s3">&quot;TSImportType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsImportType}}),Object.defineProperty(t,</span><span class="s3">&quot;TSImportEqualsDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsImportEqualsDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;TSExternalModuleReference&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsExternalModuleReference}}),Object.defineProperty(t,</span><span class="s3">&quot;TSNonNullExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsNonNullExpression}}),Object.defineProperty(t,</span><span class="s3">&quot;TSExportAssignment&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsExportAssignment}}),Object.defineProperty(t,</span><span class="s3">&quot;TSNamespaceExportDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsNamespaceExportDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsTypeAnnotation}}),Object.defineProperty(t,</span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsTypeParameterInstantiation}}),Object.defineProperty(t,</span><span class="s3">&quot;TSTypeParameterDeclaration&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsTypeParameterDeclaration}}),Object.defineProperty(t,</span><span class="s3">&quot;TSTypeParameter&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.tsTypeParameter}}),Object.defineProperty(t,</span><span class="s3">&quot;NumberLiteral&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.numberLiteral}}),Object.defineProperty(t,</span><span class="s3">&quot;RegexLiteral&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.regexLiteral}}),Object.defineProperty(t,</span><span class="s3">&quot;RestProperty&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.restProperty}}),Object.defineProperty(t,</span><span class="s3">&quot;SpreadProperty&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.spreadProperty}});</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1580</span><span class="s0">)},</span><span class="s2">478</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){const t=[];</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s2">0</span><span class="s0">;r&lt;e.children.length;r++){let s=e.children[r];(</span><span class="s2">0</span><span class="s0">,n.isJSXText)(s)?(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(s,t):((</span><span class="s2">0</span><span class="s0">,n.isJSXExpressionContainer)(s)&amp;&amp;(s=s.expression),(</span><span class="s2">0</span><span class="s0">,n.isJSXEmptyExpression)(s)||t.push(s))}</span><span class="s1">return </span><span class="s0">t};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3924</span><span class="s0">),i=r(</span><span class="s2">5908</span><span class="s0">)},</span><span class="s2">6998</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){const t=e.map((e=&gt;e.typeAnnotation)),r=(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(t);</span><span class="s1">return </span><span class="s2">1</span><span class="s0">===r.length?r[</span><span class="s2">0</span><span class="s0">]:(</span><span class="s2">0</span><span class="s0">,n.tsUnionType)(r)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1580</span><span class="s0">),i=r(</span><span class="s2">7921</span><span class="s0">)},</span><span class="s2">7307</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,!</span><span class="s2">1</span><span class="s0">)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">5833</span><span class="s0">)},</span><span class="s2">175</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">5833</span><span class="s0">)},</span><span class="s2">4982</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">5833</span><span class="s0">)},</span><span class="s2">5833</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=l;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1102</span><span class="s0">),i=r(</span><span class="s2">3924</span><span class="s0">);const s=Function.call.bind(Object.prototype.hasOwnProperty);</span><span class="s1">function </span><span class="s0">a(e,t,r){</span><span class="s1">return </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.type?l(e,t,r):e}</span><span class="s1">function </span><span class="s0">o(e,t,r){</span><span class="s1">return </span><span class="s0">Array.isArray(e)?e.map((e=&gt;a(e,t,r))):a(e,t,r)}</span><span class="s1">function </span><span class="s0">l(e,t=!</span><span class="s2">0</span><span class="s0">,r=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return </span><span class="s0">e;const{type:a}=e,l={type:e.type};</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,i.isIdentifier)(e))l.name=e.name,s(e,</span><span class="s3">&quot;optional&quot;</span><span class="s0">)&amp;&amp;</span><span class="s3">&quot;boolean&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.optional&amp;&amp;(l.optional=e.optional),s(e,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">)&amp;&amp;(l.typeAnnotation=t?o(e.typeAnnotation,!</span><span class="s2">0</span><span class="s0">,r):e.typeAnnotation);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!s(n.NODE_FIELDS,a))</span><span class="s1">throw new </span><span class="s0">Error(`Unknown node type: </span><span class="s3">&quot;${a}&quot;</span><span class="s0">`);</span><span class="s1">for</span><span class="s0">(const c of Object.keys(n.NODE_FIELDS[a]))s(e,c)&amp;&amp;(l[c]=t?(</span><span class="s2">0</span><span class="s0">,i.isFile)(e)&amp;&amp;</span><span class="s3">&quot;comments&quot;</span><span class="s0">===c?p(e.comments,t,r):o(e[c],!</span><span class="s2">0</span><span class="s0">,r):e[c])}</span><span class="s1">return </span><span class="s0">s(e,</span><span class="s3">&quot;loc&quot;</span><span class="s0">)&amp;&amp;(l.loc=r?</span><span class="s1">null</span><span class="s0">:e.loc),s(e,</span><span class="s3">&quot;leadingComments&quot;</span><span class="s0">)&amp;&amp;(l.leadingComments=p(e.leadingComments,t,r)),s(e,</span><span class="s3">&quot;innerComments&quot;</span><span class="s0">)&amp;&amp;(l.innerComments=p(e.innerComments,t,r)),s(e,</span><span class="s3">&quot;trailingComments&quot;</span><span class="s0">)&amp;&amp;(l.trailingComments=p(e.trailingComments,t,r)),s(e,</span><span class="s3">&quot;extra&quot;</span><span class="s0">)&amp;&amp;(l.extra=Object.assign({},e.extra)),l}</span><span class="s1">function </span><span class="s0">p(e,t,r){</span><span class="s1">return </span><span class="s0">e&amp;&amp;t?e.map((({type:e,value:t,loc:n})=&gt;r?{type:e,value:t,loc:</span><span class="s1">null</span><span class="s0">}:{type:e,value:t,loc:n})):e}},</span><span class="s2">8743</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">5833</span><span class="s0">)},</span><span class="s2">6517</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t,r,i){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t,[{type:i?</span><span class="s3">&quot;CommentLine&quot;</span><span class="s0">:</span><span class="s3">&quot;CommentBlock&quot;</span><span class="s0">,value:r}])};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">8290</span><span class="s0">)},</span><span class="s2">8290</span><span class="s0">:(e,t)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(!r||!e)</span><span class="s1">return </span><span class="s0">e;const n=`${t}Comments`;</span><span class="s1">return </span><span class="s0">e[n]?e[n]=</span><span class="s3">&quot;leading&quot;</span><span class="s0">===t?r.concat(e[n]):e[n].concat(r):e[n]=r,e}},</span><span class="s2">8267</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;innerComments&quot;</span><span class="s0">,e,t)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3746</span><span class="s0">)},</span><span class="s2">4510</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;leadingComments&quot;</span><span class="s0">,e,t)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3746</span><span class="s0">)},</span><span class="s2">5042</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;trailingComments&quot;</span><span class="s0">,e,t)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3746</span><span class="s0">)},</span><span class="s2">5644</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(e,t),(</span><span class="s2">0</span><span class="s0">,s.</span><span class="s1">default</span><span class="s0">)(e,t),e};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">5042</span><span class="s0">),i=r(</span><span class="s2">4510</span><span class="s0">),s=r(</span><span class="s2">8267</span><span class="s0">)},</span><span class="s2">6528</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">n.COMMENT_KEYS.forEach((t=&gt;{e[t]=</span><span class="s1">null</span><span class="s0">})),e};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">2770</span><span class="s0">)},</span><span class="s2">55</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.TSBASETYPE_TYPES=t.TSTYPE_TYPES=t.TSTYPEELEMENT_TYPES=t.PRIVATE_TYPES=t.JSX_TYPES=t.ENUMMEMBER_TYPES=t.ENUMBODY_TYPES=t.FLOWPREDICATE_TYPES=t.FLOWDECLARATION_TYPES=t.FLOWBASEANNOTATION_TYPES=t.FLOWTYPE_TYPES=t.FLOW_TYPES=t.MODULESPECIFIER_TYPES=t.EXPORTDECLARATION_TYPES=t.MODULEDECLARATION_TYPES=t.CLASS_TYPES=t.PATTERN_TYPES=t.UNARYLIKE_TYPES=t.PROPERTY_TYPES=t.OBJECTMEMBER_TYPES=t.METHOD_TYPES=t.USERWHITESPACABLE_TYPES=t.IMMUTABLE_TYPES=t.LITERAL_TYPES=t.TSENTITYNAME_TYPES=t.LVAL_TYPES=t.PATTERNLIKE_TYPES=t.DECLARATION_TYPES=t.PUREISH_TYPES=t.FUNCTIONPARENT_TYPES=t.FUNCTION_TYPES=t.FORXSTATEMENT_TYPES=t.FOR_TYPES=t.EXPRESSIONWRAPPER_TYPES=t.WHILE_TYPES=t.LOOP_TYPES=t.CONDITIONAL_TYPES=t.COMPLETIONSTATEMENT_TYPES=t.TERMINATORLESS_TYPES=t.STATEMENT_TYPES=t.BLOCK_TYPES=t.BLOCKPARENT_TYPES=t.SCOPABLE_TYPES=t.BINARY_TYPES=t.EXPRESSION_TYPES=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1102</span><span class="s0">);const i=n.FLIPPED_ALIAS_KEYS.Expression;t.EXPRESSION_TYPES=i;const s=n.FLIPPED_ALIAS_KEYS.Binary;t.BINARY_TYPES=s;const a=n.FLIPPED_ALIAS_KEYS.Scopable;t.SCOPABLE_TYPES=a;const o=n.FLIPPED_ALIAS_KEYS.BlockParent;t.BLOCKPARENT_TYPES=o;const l=n.FLIPPED_ALIAS_KEYS.Block;t.BLOCK_TYPES=l;const p=n.FLIPPED_ALIAS_KEYS.Statement;t.STATEMENT_TYPES=p;const c=n.FLIPPED_ALIAS_KEYS.Terminatorless;t.TERMINATORLESS_TYPES=c;const u=n.FLIPPED_ALIAS_KEYS.CompletionStatement;t.COMPLETIONSTATEMENT_TYPES=u;const d=n.FLIPPED_ALIAS_KEYS.Conditional;t.CONDITIONAL_TYPES=d;const h=n.FLIPPED_ALIAS_KEYS.Loop;t.LOOP_TYPES=h;const f=n.FLIPPED_ALIAS_KEYS.While;t.WHILE_TYPES=f;const m=n.FLIPPED_ALIAS_KEYS.ExpressionWrapper;t.EXPRESSIONWRAPPER_TYPES=m;const y=n.FLIPPED_ALIAS_KEYS.For;t.FOR_TYPES=y;const T=n.FLIPPED_ALIAS_KEYS.ForXStatement;t.FORXSTATEMENT_TYPES=T;const b=n.FLIPPED_ALIAS_KEYS.Function;t.FUNCTION_TYPES=b;const g=n.FLIPPED_ALIAS_KEYS.FunctionParent;t.FUNCTIONPARENT_TYPES=g;const S=n.FLIPPED_ALIAS_KEYS.Pureish;t.PUREISH_TYPES=S;const x=n.FLIPPED_ALIAS_KEYS.Declaration;t.DECLARATION_TYPES=x;const E=n.FLIPPED_ALIAS_KEYS.PatternLike;t.PATTERNLIKE_TYPES=E;const P=n.FLIPPED_ALIAS_KEYS.LVal;t.LVAL_TYPES=P;const v=n.FLIPPED_ALIAS_KEYS.TSEntityName;t.TSENTITYNAME_TYPES=v;const A=n.FLIPPED_ALIAS_KEYS.Literal;t.LITERAL_TYPES=A;const w=n.FLIPPED_ALIAS_KEYS.Immutable;t.IMMUTABLE_TYPES=w;const O=n.FLIPPED_ALIAS_KEYS.UserWhitespacable;t.USERWHITESPACABLE_TYPES=O;const I=n.FLIPPED_ALIAS_KEYS.Method;t.METHOD_TYPES=I;const N=n.FLIPPED_ALIAS_KEYS.ObjectMember;t.OBJECTMEMBER_TYPES=N;const C=n.FLIPPED_ALIAS_KEYS.Property;t.PROPERTY_TYPES=C;const k=n.FLIPPED_ALIAS_KEYS.UnaryLike;t.UNARYLIKE_TYPES=k;const D=n.FLIPPED_ALIAS_KEYS.Pattern;t.PATTERN_TYPES=D;const _=n.FLIPPED_ALIAS_KEYS.Class;t.CLASS_TYPES=_;const L=n.FLIPPED_ALIAS_KEYS.ModuleDeclaration;t.MODULEDECLARATION_TYPES=L;const M=n.FLIPPED_ALIAS_KEYS.ExportDeclaration;t.EXPORTDECLARATION_TYPES=M;const j=n.FLIPPED_ALIAS_KEYS.ModuleSpecifier;t.MODULESPECIFIER_TYPES=j;const F=n.FLIPPED_ALIAS_KEYS.Flow;t.FLOW_TYPES=F;const B=n.FLIPPED_ALIAS_KEYS.FlowType;t.FLOWTYPE_TYPES=B;const R=n.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;t.FLOWBASEANNOTATION_TYPES=R;const U=n.FLIPPED_ALIAS_KEYS.FlowDeclaration;t.FLOWDECLARATION_TYPES=U;const V=n.FLIPPED_ALIAS_KEYS.FlowPredicate;t.FLOWPREDICATE_TYPES=V;const K=n.FLIPPED_ALIAS_KEYS.EnumBody;t.ENUMBODY_TYPES=K;const q=n.FLIPPED_ALIAS_KEYS.EnumMember;t.ENUMMEMBER_TYPES=q;const Y=n.FLIPPED_ALIAS_KEYS.JSX;t.JSX_TYPES=Y;const W=n.FLIPPED_ALIAS_KEYS.Private;t.PRIVATE_TYPES=W;const X=n.FLIPPED_ALIAS_KEYS.TSTypeElement;t.TSTYPEELEMENT_TYPES=X;const J=n.FLIPPED_ALIAS_KEYS.TSType;t.TSTYPE_TYPES=J;const H=n.FLIPPED_ALIAS_KEYS.TSBaseType;t.TSBASETYPE_TYPES=H},</span><span class="s2">2770</span><span class="s0">:(e,t)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.NOT_LOCAL_BINDING=t.BLOCK_SCOPED_SYMBOL=t.INHERIT_KEYS=t.UNARY_OPERATORS=t.STRING_UNARY_OPERATORS=t.NUMBER_UNARY_OPERATORS=t.BOOLEAN_UNARY_OPERATORS=t.ASSIGNMENT_OPERATORS=t.BINARY_OPERATORS=t.NUMBER_BINARY_OPERATORS=t.BOOLEAN_BINARY_OPERATORS=t.COMPARISON_BINARY_OPERATORS=t.EQUALITY_BINARY_OPERATORS=t.BOOLEAN_NUMBER_BINARY_OPERATORS=t.UPDATE_OPERATORS=t.LOGICAL_OPERATORS=t.COMMENT_KEYS=t.FOR_INIT_KEYS=t.FLATTENABLE_KEYS=t.STATEMENT_OR_BLOCK_KEYS=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,t.STATEMENT_OR_BLOCK_KEYS=[</span><span class="s3">&quot;consequent&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;alternate&quot;</span><span class="s0">],t.FLATTENABLE_KEYS=[</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;expressions&quot;</span><span class="s0">],t.FOR_INIT_KEYS=[</span><span class="s3">&quot;left&quot;</span><span class="s0">,</span><span class="s3">&quot;init&quot;</span><span class="s0">],t.COMMENT_KEYS=[</span><span class="s3">&quot;leadingComments&quot;</span><span class="s0">,</span><span class="s3">&quot;trailingComments&quot;</span><span class="s0">,</span><span class="s3">&quot;innerComments&quot;</span><span class="s0">];const r=[</span><span class="s3">&quot;||&quot;</span><span class="s0">,</span><span class="s3">&quot;&amp;&amp;&quot;</span><span class="s0">,</span><span class="s3">&quot;??&quot;</span><span class="s0">];t.LOGICAL_OPERATORS=r,t.UPDATE_OPERATORS=[</span><span class="s3">&quot;++&quot;</span><span class="s0">,</span><span class="s3">&quot;--&quot;</span><span class="s0">];const n=[</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">,</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">,</span><span class="s3">&quot;&gt;=&quot;</span><span class="s0">,</span><span class="s3">&quot;&lt;=&quot;</span><span class="s0">];t.BOOLEAN_NUMBER_BINARY_OPERATORS=n;const i=[</span><span class="s3">&quot;==&quot;</span><span class="s0">,</span><span class="s3">&quot;===&quot;</span><span class="s0">,</span><span class="s3">&quot;!=&quot;</span><span class="s0">,</span><span class="s3">&quot;!==&quot;</span><span class="s0">];t.EQUALITY_BINARY_OPERATORS=i;const s=[...i,</span><span class="s3">&quot;in&quot;</span><span class="s0">,</span><span class="s3">&quot;instanceof&quot;</span><span class="s0">];t.COMPARISON_BINARY_OPERATORS=s;const a=[...s,...n];t.BOOLEAN_BINARY_OPERATORS=a;const o=[</span><span class="s3">&quot;-&quot;</span><span class="s0">,</span><span class="s3">&quot;/&quot;</span><span class="s0">,</span><span class="s3">&quot;%&quot;</span><span class="s0">,</span><span class="s3">&quot;*&quot;</span><span class="s0">,</span><span class="s3">&quot;**&quot;</span><span class="s0">,</span><span class="s3">&quot;&amp;&quot;</span><span class="s0">,</span><span class="s3">&quot;|&quot;</span><span class="s0">,</span><span class="s3">&quot;&gt;&gt;&quot;</span><span class="s0">,</span><span class="s3">&quot;&gt;&gt;&gt;&quot;</span><span class="s0">,</span><span class="s3">&quot;&lt;&lt;&quot;</span><span class="s0">,</span><span class="s3">&quot;^&quot;</span><span class="s0">];t.NUMBER_BINARY_OPERATORS=o;const l=[</span><span class="s3">&quot;+&quot;</span><span class="s0">,...o,...a];t.BINARY_OPERATORS=l;const p=[</span><span class="s3">&quot;=&quot;</span><span class="s0">,</span><span class="s3">&quot;+=&quot;</span><span class="s0">,...o.map((e=&gt;e+</span><span class="s3">&quot;=&quot;</span><span class="s0">)),...r.map((e=&gt;e+</span><span class="s3">&quot;=&quot;</span><span class="s0">))];t.ASSIGNMENT_OPERATORS=p;const c=[</span><span class="s3">&quot;delete&quot;</span><span class="s0">,</span><span class="s3">&quot;!&quot;</span><span class="s0">];t.BOOLEAN_UNARY_OPERATORS=c;const u=[</span><span class="s3">&quot;+&quot;</span><span class="s0">,</span><span class="s3">&quot;-&quot;</span><span class="s0">,</span><span class="s3">&quot;~&quot;</span><span class="s0">];t.NUMBER_UNARY_OPERATORS=u;const d=[</span><span class="s3">&quot;typeof&quot;</span><span class="s0">];t.STRING_UNARY_OPERATORS=d;const h=[</span><span class="s3">&quot;void&quot;</span><span class="s0">,</span><span class="s3">&quot;throw&quot;</span><span class="s0">,...c,...u,...d];t.UNARY_OPERATORS=h,t.INHERIT_KEYS={optional:[</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;returnType&quot;</span><span class="s0">],force:[</span><span class="s3">&quot;start&quot;</span><span class="s0">,</span><span class="s3">&quot;loc&quot;</span><span class="s0">,</span><span class="s3">&quot;end&quot;</span><span class="s0">]};const f=Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s3">&quot;var used to be block scoped&quot;</span><span class="s0">);t.BLOCK_SCOPED_SYMBOL=f;const m=Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s3">&quot;should not be considered a local binding&quot;</span><span class="s0">);t.NOT_LOCAL_BINDING=m},</span><span class="s2">9176</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t=</span><span class="s3">&quot;body&quot;</span><span class="s0">){</span><span class="s1">return </span><span class="s0">e[t]=(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e[t],e)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">2860</span><span class="s0">)},</span><span class="s2">8467</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function </span><span class="s0">e(t,r,o){const l=[];let p=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const c of t)</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,i.isEmptyStatement)(c)||(p=!</span><span class="s2">1</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,i.isExpression)(c))l.push(c);</span><span class="s1">else if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,i.isExpressionStatement)(c))l.push(c.expression);</span><span class="s1">else if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,i.isVariableDeclaration)(c)){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;var&quot;</span><span class="s0">!==c.kind)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const e of c.declarations){const t=(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e);</span><span class="s1">for</span><span class="s0">(const e of Object.keys(t))o.push({kind:c.kind,id:(</span><span class="s2">0</span><span class="s0">,a.</span><span class="s1">default</span><span class="s0">)(t[e])});e.init&amp;&amp;l.push((</span><span class="s2">0</span><span class="s0">,s.assignmentExpression)(</span><span class="s3">&quot;=&quot;</span><span class="s0">,e.id,e.init))}p=!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,i.isIfStatement)(c)){const t=c.consequent?e([c.consequent],r,o):r.buildUndefinedNode(),n=c.alternate?e([c.alternate],r,o):r.buildUndefinedNode();</span><span class="s1">if</span><span class="s0">(!t||!n)</span><span class="s1">return</span><span class="s0">;l.push((</span><span class="s2">0</span><span class="s0">,s.conditionalExpression)(c.test,t,n))}</span><span class="s1">else if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,i.isBlockStatement)(c)){const t=e(c.body,r,o);</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return</span><span class="s0">;l.push(t)}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!(</span><span class="s2">0</span><span class="s0">,i.isEmptyStatement)(c))</span><span class="s1">return</span><span class="s0">;</span><span class="s2">0</span><span class="s0">===t.indexOf(c)&amp;&amp;(p=!</span><span class="s2">0</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">p&amp;&amp;l.push(r.buildUndefinedNode()),</span><span class="s2">1</span><span class="s0">===l.length?l[</span><span class="s2">0</span><span class="s0">]:(</span><span class="s2">0</span><span class="s0">,s.sequenceExpression)(l)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">5337</span><span class="s0">),i=r(</span><span class="s2">3924</span><span class="s0">),s=r(</span><span class="s2">1580</span><span class="s0">),a=r(</span><span class="s2">5833</span><span class="s0">)},</span><span class="s2">7919</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s3">&quot;eval&quot;</span><span class="s0">!==(e=(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e))&amp;&amp;</span><span class="s3">&quot;arguments&quot;</span><span class="s0">!==e||(e=</span><span class="s3">&quot;_&quot;</span><span class="s0">+e),e};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">7718</span><span class="s0">)},</span><span class="s2">2860</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isBlockStatement)(e))</span><span class="s1">return </span><span class="s0">e;let r=[];</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.isEmptyStatement)(e)?r=[]:((</span><span class="s2">0</span><span class="s0">,n.isStatement)(e)||(e=(</span><span class="s2">0</span><span class="s0">,n.isFunction)(t)?(</span><span class="s2">0</span><span class="s0">,i.returnStatement)(e):(</span><span class="s2">0</span><span class="s0">,i.expressionStatement)(e)),r=[e]),(</span><span class="s2">0</span><span class="s0">,i.blockStatement)(r)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3924</span><span class="s0">),i=r(</span><span class="s2">1580</span><span class="s0">)},</span><span class="s2">6</span><span class="s0">e3:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t=e.key||e.property){</span><span class="s1">return</span><span class="s0">!e.computed&amp;&amp;(</span><span class="s2">0</span><span class="s0">,n.isIdentifier)(t)&amp;&amp;(t=(</span><span class="s2">0</span><span class="s0">,i.stringLiteral)(t.name)),t};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3924</span><span class="s0">),i=r(</span><span class="s2">1580</span><span class="s0">)},</span><span class="s2">836</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3924</span><span class="s0">);t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isExpressionStatement)(e)&amp;&amp;(e=e.expression),(</span><span class="s2">0</span><span class="s0">,n.isExpression)(e))</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isClass)(e)?e.type=</span><span class="s3">&quot;ClassExpression&quot;</span><span class="s0">:(</span><span class="s2">0</span><span class="s0">,n.isFunction)(e)&amp;&amp;(e.type=</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">),!(</span><span class="s2">0</span><span class="s0">,n.isExpression)(e))</span><span class="s1">throw new </span><span class="s0">Error(`cannot turn ${e.type} to an expression`);</span><span class="s1">return </span><span class="s0">e}},</span><span class="s2">7718</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){e+=</span><span class="s3">&quot;&quot;</span><span class="s0">;let t=</span><span class="s3">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const r of e)t+=(</span><span class="s2">0</span><span class="s0">,i.isIdentifierChar)(r.codePointAt(</span><span class="s2">0</span><span class="s0">))?r:</span><span class="s3">&quot;-&quot;</span><span class="s0">;</span><span class="s1">return </span><span class="s0">t=t.replace(/^[-</span><span class="s2">0</span><span class="s0">-</span><span class="s2">9</span><span class="s0">]+/,</span><span class="s3">&quot;&quot;</span><span class="s0">),t=t.replace(/[-\s]+(.)?/g,(</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">t?t.toUpperCase():</span><span class="s3">&quot;&quot;</span><span class="s0">})),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(t)||(t=`_${t}`),t||</span><span class="s3">&quot;_&quot;</span><span class="s0">};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">6335</span><span class="s0">),i=r(</span><span class="s2">7075</span><span class="s0">)},</span><span class="s2">3240</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=a;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3924</span><span class="s0">),i=r(</span><span class="s2">5833</span><span class="s0">),s=r(</span><span class="s2">2271</span><span class="s0">);</span><span class="s1">function </span><span class="s0">a(e,t=e.key){let r;</span><span class="s1">return</span><span class="s3">&quot;method&quot;</span><span class="s0">===e.kind?a.increment()+</span><span class="s3">&quot;&quot;</span><span class="s0">:(r=(</span><span class="s2">0</span><span class="s0">,n.isIdentifier)(t)?t.name:(</span><span class="s2">0</span><span class="s0">,n.isStringLiteral)(t)?JSON.stringify(t.value):JSON.stringify((</span><span class="s2">0</span><span class="s0">,s.</span><span class="s1">default</span><span class="s0">)((</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(t))),e.computed&amp;&amp;(r=`[${r}]`),e.static&amp;&amp;(r=`static:${r}`),r)}a.uid=</span><span class="s2">0</span><span class="s0">,a.increment=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">a.uid&gt;=Number.MAX_SAFE_INTEGER?a.uid=</span><span class="s2">0</span><span class="s0">:a.uid++}},</span><span class="s2">4868</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==e||!e.length)</span><span class="s1">return</span><span class="s0">;const r=[],i=(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t,r);</span><span class="s1">if</span><span class="s0">(i){</span><span class="s1">for</span><span class="s0">(const e of r)t.push(e);</span><span class="s1">return </span><span class="s0">i}};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">8467</span><span class="s0">)},</span><span class="s2">874</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3924</span><span class="s0">),i=r(</span><span class="s2">1580</span><span class="s0">);t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isStatement)(e))</span><span class="s1">return </span><span class="s0">e;let r,s=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isClass)(e))s=!</span><span class="s2">0</span><span class="s0">,r=</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isFunction)(e))s=!</span><span class="s2">0</span><span class="s0">,r=</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isAssignmentExpression)(e))</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,i.expressionStatement)(e);</span><span class="s1">if</span><span class="s0">(s&amp;&amp;!e.id&amp;&amp;(r=!</span><span class="s2">1</span><span class="s0">),!r){</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">throw new </span><span class="s0">Error(`cannot turn ${e.type} to a statement`)}</span><span class="s1">return </span><span class="s0">e.type=r,e}},</span><span class="s2">1799</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">6335</span><span class="s0">),i=r(</span><span class="s2">1580</span><span class="s0">);t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function </span><span class="s0">e(t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t)</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,i.identifier)(</span><span class="s3">&quot;undefined&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!</span><span class="s2">0</span><span class="s0">===t||!</span><span class="s2">1</span><span class="s0">===t)</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,i.booleanLiteral)(t);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===t)</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,i.nullLiteral)();</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t)</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,i.stringLiteral)(t);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t){let e;</span><span class="s1">if</span><span class="s0">(Number.isFinite(t))e=(</span><span class="s2">0</span><span class="s0">,i.numericLiteral)(Math.abs(t));</span><span class="s1">else</span><span class="s0">{let r;r=Number.isNaN(t)?(</span><span class="s2">0</span><span class="s0">,i.numericLiteral)(</span><span class="s2">0</span><span class="s0">):(</span><span class="s2">0</span><span class="s0">,i.numericLiteral)(</span><span class="s2">1</span><span class="s0">),e=(</span><span class="s2">0</span><span class="s0">,i.binaryExpression)(</span><span class="s3">&quot;/&quot;</span><span class="s0">,r,(</span><span class="s2">0</span><span class="s0">,i.numericLiteral)(</span><span class="s2">0</span><span class="s0">))}</span><span class="s1">return</span><span class="s0">(t&lt;</span><span class="s2">0</span><span class="s0">||Object.is(t,-</span><span class="s2">0</span><span class="s0">))&amp;&amp;(e=(</span><span class="s2">0</span><span class="s0">,i.unaryExpression)(</span><span class="s3">&quot;-&quot;</span><span class="s0">,e)),e}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s3">&quot;[object RegExp]&quot;</span><span class="s0">===s(e)}(t)){const e=t.source,r=t.toString().match(/\/([a-z]+|)$/)[</span><span class="s2">1</span><span class="s0">];</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,i.regExpLiteral)(e,r)}</span><span class="s1">if</span><span class="s0">(Array.isArray(t))</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,i.arrayExpression)(t.map(e));</span><span class="s1">if</span><span class="s0">(</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e||</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;[object Object]&quot;</span><span class="s0">!==Object.prototype.toString.call(e))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const t=Object.getPrototypeOf(e);</span><span class="s1">return null</span><span class="s0">===t||</span><span class="s1">null</span><span class="s0">===Object.getPrototypeOf(t)}(t)){const r=[];</span><span class="s1">for</span><span class="s0">(const s of Object.keys(t)){let a;a=(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(s)?(</span><span class="s2">0</span><span class="s0">,i.identifier)(s):(</span><span class="s2">0</span><span class="s0">,i.stringLiteral)(s),r.push((</span><span class="s2">0</span><span class="s0">,i.objectProperty)(a,e(t[s])))}</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,i.objectExpression)(r)}</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;don't know how to turn this value into a node&quot;</span><span class="s0">)};const s=Function.call.bind(Object.prototype.toString)},</span><span class="s2">9357</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">397</span><span class="s0">);Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.classMethodOrDeclareMethodCommon=t.classMethodOrPropertyCommon=t.patternLikeCommon=t.functionDeclarationCommon=t.functionTypeAnnotationCommon=t.functionCommon=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">i=r(</span><span class="s2">5001</span><span class="s0">),s=r(</span><span class="s2">6335</span><span class="s0">),a=r(</span><span class="s2">7075</span><span class="s0">),o=r(</span><span class="s2">2770</span><span class="s0">),l=r(</span><span class="s2">5455</span><span class="s0">);(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s0">,{fields:{elements:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeOrValueType)(</span><span class="s3">&quot;null&quot;</span><span class="s0">,</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">))),</span><span class="s1">default</span><span class="s0">:n.env.BABEL_TYPES_8_BREAKING?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:[]}},visitor:[</span><span class="s3">&quot;elements&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s0">,{fields:{operator:{validate:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(!n.env.BABEL_TYPES_8_BREAKING)</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">);const e=(</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(...o.ASSIGNMENT_OPERATORS),t=(</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(</span><span class="s3">&quot;=&quot;</span><span class="s0">);</span><span class="s1">return function</span><span class="s0">(r,n,s){((</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">,r.left)?t:e)(r,n,s)}}()},left:{validate:n.env.BABEL_TYPES_8_BREAKING?(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">,</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">,</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">):(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;LVal&quot;</span><span class="s0">)},right:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}},builder:[</span><span class="s3">&quot;operator&quot;</span><span class="s0">,</span><span class="s3">&quot;left&quot;</span><span class="s0">,</span><span class="s3">&quot;right&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;left&quot;</span><span class="s0">,</span><span class="s3">&quot;right&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;BinaryExpression&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;operator&quot;</span><span class="s0">,</span><span class="s3">&quot;left&quot;</span><span class="s0">,</span><span class="s3">&quot;right&quot;</span><span class="s0">],fields:{operator:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(...o.BINARY_OPERATORS)},left:{validate:</span><span class="s1">function</span><span class="s0">(){const e=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">),t=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">),r=</span><span class="s1">function</span><span class="s0">(r,n,i){(</span><span class="s3">&quot;in&quot;</span><span class="s0">===r.operator?t:e)(r,n,i)};</span><span class="s1">return </span><span class="s0">r.oneOfNodeTypes=[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">],r}()},right:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}},visitor:[</span><span class="s3">&quot;left&quot;</span><span class="s0">,</span><span class="s3">&quot;right&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Binary&quot;</span><span class="s0">,</span><span class="s3">&quot;Expression&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;InterpreterDirective&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;value&quot;</span><span class="s0">],fields:{value:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Directive&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;value&quot;</span><span class="s0">],fields:{value:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;DirectiveLiteral&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DirectiveLiteral&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;value&quot;</span><span class="s0">],fields:{value:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;directives&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;directives&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],fields:{directives:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Directive&quot;</span><span class="s0">))),</span><span class="s1">default</span><span class="s0">:[]},body:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)))}},aliases:[</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">,</span><span class="s3">&quot;Block&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;BreakStatement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;label&quot;</span><span class="s0">],fields:{label:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}},aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Terminatorless&quot;</span><span class="s0">,</span><span class="s3">&quot;CompletionStatement&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;CallExpression&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;callee&quot;</span><span class="s0">,</span><span class="s3">&quot;arguments&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;typeArguments&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;callee&quot;</span><span class="s0">,</span><span class="s3">&quot;arguments&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],fields:Object.assign({callee:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;V8IntrinsicIdentifier&quot;</span><span class="s0">)},arguments:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">,</span><span class="s3">&quot;ArgumentPlaceholder&quot;</span><span class="s0">)))}},n.env.BABEL_TYPES_8_BREAKING?{}:{optional:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}},{typeArguments:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},typeParameters:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}})}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;CatchClause&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;param&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],fields:{param:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">,</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},body:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">)}},aliases:[</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;test&quot;</span><span class="s0">,</span><span class="s3">&quot;consequent&quot;</span><span class="s0">,</span><span class="s3">&quot;alternate&quot;</span><span class="s0">],fields:{test:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},consequent:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},alternate:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}},aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Conditional&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ContinueStatement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;label&quot;</span><span class="s0">],fields:{label:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}},aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Terminatorless&quot;</span><span class="s0">,</span><span class="s3">&quot;CompletionStatement&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DebuggerStatement&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;test&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],fields:{test:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},body:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)}},aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">,</span><span class="s3">&quot;Loop&quot;</span><span class="s0">,</span><span class="s3">&quot;While&quot;</span><span class="s0">,</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EmptyStatement&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;expression&quot;</span><span class="s0">],fields:{expression:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}},aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;ExpressionWrapper&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;File&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;program&quot;</span><span class="s0">,</span><span class="s3">&quot;comments&quot;</span><span class="s0">,</span><span class="s3">&quot;tokens&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;program&quot;</span><span class="s0">],fields:{program:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Program&quot;</span><span class="s0">)},comments:{validate:n.env.BABEL_TYPES_8_BREAKING?(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;CommentBlock&quot;</span><span class="s0">,</span><span class="s3">&quot;CommentLine&quot;</span><span class="s0">)):Object.assign((()=&gt;{}),{each:{oneOfNodeTypes:[</span><span class="s3">&quot;CommentBlock&quot;</span><span class="s0">,</span><span class="s3">&quot;CommentLine&quot;</span><span class="s0">]}}),optional:!</span><span class="s2">0</span><span class="s0">},tokens:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertEach)(Object.assign((()=&gt;{}),{type:</span><span class="s3">&quot;any&quot;</span><span class="s0">})),optional:!</span><span class="s2">0</span><span class="s0">}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ForInStatement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;left&quot;</span><span class="s0">,</span><span class="s3">&quot;right&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;For&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">,</span><span class="s3">&quot;Loop&quot;</span><span class="s0">,</span><span class="s3">&quot;ForXStatement&quot;</span><span class="s0">],fields:{left:{validate:n.env.BABEL_TYPES_8_BREAKING?(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">,</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">,</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">):(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;LVal&quot;</span><span class="s0">)},right:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},body:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ForStatement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;init&quot;</span><span class="s0">,</span><span class="s3">&quot;test&quot;</span><span class="s0">,</span><span class="s3">&quot;update&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;For&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">,</span><span class="s3">&quot;Loop&quot;</span><span class="s0">],fields:{init:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Expression&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},test:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},update:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},body:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)}}});const p={params:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">,</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">,</span><span class="s3">&quot;TSParameterProperty&quot;</span><span class="s0">)))},generator:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">},async:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">}};t.functionCommon=p;const c={returnType:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;Noop&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},typeParameters:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;TSTypeParameterDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Noop&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}};t.functionTypeAnnotationCommon=c;const u=Object.assign({},p,{declare:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},id:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}});t.functionDeclarationCommon=u,(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;params&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;generator&quot;</span><span class="s0">,</span><span class="s3">&quot;async&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;params&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;returnType&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">],fields:Object.assign({},u,c,{body:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">)}}),aliases:[</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;Function&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">,</span><span class="s3">&quot;FunctionParent&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Pureish&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],validate:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(!n.env.BABEL_TYPES_8_BREAKING)</span><span class="s1">return</span><span class="s0">()=&gt;{};const e=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">);</span><span class="s1">return function</span><span class="s0">(t,r,n){(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">,t)||e(n,</span><span class="s3">&quot;id&quot;</span><span class="s0">,n.id)}}()}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">,{inherits:</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">,aliases:[</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;Function&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">,</span><span class="s3">&quot;FunctionParent&quot;</span><span class="s0">,</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Pureish&quot;</span><span class="s0">],fields:Object.assign({},p,c,{id:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},body:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">)}})});const d={typeAnnotation:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;Noop&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},decorators:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">)))}};t.patternLikeCommon=d,(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;name&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;PatternLike&quot;</span><span class="s0">,</span><span class="s3">&quot;LVal&quot;</span><span class="s0">,</span><span class="s3">&quot;TSEntityName&quot;</span><span class="s0">],fields:Object.assign({},d,{name:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">),Object.assign((</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(n.env.BABEL_TYPES_8_BREAKING&amp;&amp;!(</span><span class="s2">0</span><span class="s0">,s.</span><span class="s1">default</span><span class="s0">)(r,!</span><span class="s2">1</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">TypeError(`</span><span class="s3">&quot;${r}&quot; </span><span class="s0">is not a valid identifier name`)}),{type:</span><span class="s3">&quot;string&quot;</span><span class="s0">}))},optional:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}}),validate(e,t,r){</span><span class="s1">if</span><span class="s0">(!n.env.BABEL_TYPES_8_BREAKING)</span><span class="s1">return</span><span class="s0">;const s=/\.(\w+)$/.exec(t);</span><span class="s1">if</span><span class="s0">(!s)</span><span class="s1">return</span><span class="s0">;const[,o]=s,l={computed:!</span><span class="s2">1</span><span class="s0">};</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;property&quot;</span><span class="s0">===o){</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">,e,l))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">,e,l))</span><span class="s1">return</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;key&quot;</span><span class="s0">===o){</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Property&quot;</span><span class="s0">,e,l))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Method&quot;</span><span class="s0">,e,l))</span><span class="s1">return</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;exported&quot;</span><span class="s0">===o){</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExportSpecifier&quot;</span><span class="s0">,e))</span><span class="s1">return</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;imported&quot;</span><span class="s0">===o){</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s0">,e,{imported:r}))</span><span class="s1">return</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;meta&quot;</span><span class="s0">===o&amp;&amp;(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;MetaProperty&quot;</span><span class="s0">,e,{meta:r}))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(((</span><span class="s2">0</span><span class="s0">,a.isKeyword)(r.name)||(</span><span class="s2">0</span><span class="s0">,a.isReservedWord)(r.name,!</span><span class="s2">1</span><span class="s0">))&amp;&amp;</span><span class="s3">&quot;this&quot;</span><span class="s0">!==r.name)</span><span class="s1">throw new </span><span class="s0">TypeError(`</span><span class="s3">&quot;${r.name}&quot; </span><span class="s0">is not a valid identifier`)}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;IfStatement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;test&quot;</span><span class="s0">,</span><span class="s3">&quot;consequent&quot;</span><span class="s0">,</span><span class="s3">&quot;alternate&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Conditional&quot;</span><span class="s0">],fields:{test:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},consequent:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)},alternate:{optional:!</span><span class="s2">0</span><span class="s0">,validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;LabeledStatement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;label&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">],fields:{label:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)},body:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;value&quot;</span><span class="s0">],fields:{value:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">)}},aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Pureish&quot;</span><span class="s0">,</span><span class="s3">&quot;Literal&quot;</span><span class="s0">,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;value&quot;</span><span class="s0">],deprecatedAlias:</span><span class="s3">&quot;NumberLiteral&quot;</span><span class="s0">,fields:{value:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;number&quot;</span><span class="s0">)}},aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Pureish&quot;</span><span class="s0">,</span><span class="s3">&quot;Literal&quot;</span><span class="s0">,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;NullLiteral&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Pureish&quot;</span><span class="s0">,</span><span class="s3">&quot;Literal&quot;</span><span class="s0">,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;BooleanLiteral&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;value&quot;</span><span class="s0">],fields:{value:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">)}},aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Pureish&quot;</span><span class="s0">,</span><span class="s3">&quot;Literal&quot;</span><span class="s0">,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;RegExpLiteral&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;pattern&quot;</span><span class="s0">,</span><span class="s3">&quot;flags&quot;</span><span class="s0">],deprecatedAlias:</span><span class="s3">&quot;RegexLiteral&quot;</span><span class="s0">,aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Pureish&quot;</span><span class="s0">,</span><span class="s3">&quot;Literal&quot;</span><span class="s0">],fields:{pattern:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">)},flags:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">),Object.assign((</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(!n.env.BABEL_TYPES_8_BREAKING)</span><span class="s1">return</span><span class="s0">;const i=/[^gimsuy]/.exec(r);</span><span class="s1">if</span><span class="s0">(i)</span><span class="s1">throw new </span><span class="s0">TypeError(`</span><span class="s3">&quot;${i[0]}&quot; </span><span class="s0">is not a valid RegExp flag`)}),{type:</span><span class="s3">&quot;string&quot;</span><span class="s0">})),</span><span class="s1">default</span><span class="s0">:</span><span class="s3">&quot;&quot;</span><span class="s0">}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;LogicalExpression&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;operator&quot;</span><span class="s0">,</span><span class="s3">&quot;left&quot;</span><span class="s0">,</span><span class="s3">&quot;right&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;left&quot;</span><span class="s0">,</span><span class="s3">&quot;right&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Binary&quot;</span><span class="s0">,</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],fields:{operator:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(...o.LOGICAL_OPERATORS)},left:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},right:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;object&quot;</span><span class="s0">,</span><span class="s3">&quot;property&quot;</span><span class="s0">,</span><span class="s3">&quot;computed&quot;</span><span class="s0">,</span><span class="s3">&quot;optional&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;object&quot;</span><span class="s0">,</span><span class="s3">&quot;property&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;LVal&quot;</span><span class="s0">],fields:Object.assign({object:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},property:{validate:</span><span class="s1">function</span><span class="s0">(){const e=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">),t=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">),r=</span><span class="s1">function</span><span class="s0">(r,n,i){(r.computed?t:e)(r,n,i)};</span><span class="s1">return </span><span class="s0">r.oneOfNodeTypes=[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">],r}()},computed:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">}},n.env.BABEL_TYPES_8_BREAKING?{}:{optional:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}})}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;NewExpression&quot;</span><span class="s0">,{inherits:</span><span class="s3">&quot;CallExpression&quot;</span><span class="s0">}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Program&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;directives&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;directives&quot;</span><span class="s0">,</span><span class="s3">&quot;sourceType&quot;</span><span class="s0">,</span><span class="s3">&quot;interpreter&quot;</span><span class="s0">],fields:{sourceFile:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">)},sourceType:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(</span><span class="s3">&quot;script&quot;</span><span class="s0">,</span><span class="s3">&quot;module&quot;</span><span class="s0">),</span><span class="s1">default</span><span class="s0">:</span><span class="s3">&quot;script&quot;</span><span class="s0">},interpreter:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;InterpreterDirective&quot;</span><span class="s0">),</span><span class="s1">default</span><span class="s0">:</span><span class="s1">null</span><span class="s0">,optional:!</span><span class="s2">0</span><span class="s0">},directives:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Directive&quot;</span><span class="s0">))),</span><span class="s1">default</span><span class="s0">:[]},body:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)))}},aliases:[</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">,</span><span class="s3">&quot;Block&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;properties&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],fields:{properties:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">,</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">,</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">)))}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;kind&quot;</span><span class="s0">,</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;params&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;computed&quot;</span><span class="s0">,</span><span class="s3">&quot;generator&quot;</span><span class="s0">,</span><span class="s3">&quot;async&quot;</span><span class="s0">],fields:Object.assign({},p,c,{kind:Object.assign({validate:(</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(</span><span class="s3">&quot;method&quot;</span><span class="s0">,</span><span class="s3">&quot;get&quot;</span><span class="s0">,</span><span class="s3">&quot;set&quot;</span><span class="s0">)},n.env.BABEL_TYPES_8_BREAKING?{}:{</span><span class="s1">default</span><span class="s0">:</span><span class="s3">&quot;method&quot;</span><span class="s0">}),computed:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">},key:{validate:</span><span class="s1">function</span><span class="s0">(){const e=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">,</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">),t=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">),r=</span><span class="s1">function</span><span class="s0">(r,n,i){(r.computed?t:e)(r,n,i)};</span><span class="s1">return </span><span class="s0">r.oneOfNodeTypes=[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">,</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">],r}()},decorators:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">))),optional:!</span><span class="s2">0</span><span class="s0">},body:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">)}}),visitor:[</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;params&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">,</span><span class="s3">&quot;returnType&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;UserWhitespacable&quot;</span><span class="s0">,</span><span class="s3">&quot;Function&quot;</span><span class="s0">,</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">,</span><span class="s3">&quot;FunctionParent&quot;</span><span class="s0">,</span><span class="s3">&quot;Method&quot;</span><span class="s0">,</span><span class="s3">&quot;ObjectMember&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;value&quot;</span><span class="s0">,</span><span class="s3">&quot;computed&quot;</span><span class="s0">,</span><span class="s3">&quot;shorthand&quot;</span><span class="s0">,...n.env.BABEL_TYPES_8_BREAKING?[]:[</span><span class="s3">&quot;decorators&quot;</span><span class="s0">]],fields:{computed:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">},key:{validate:</span><span class="s1">function</span><span class="s0">(){const e=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">,</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">),t=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">),r=</span><span class="s1">function</span><span class="s0">(r,n,i){(r.computed?t:e)(r,n,i)};</span><span class="s1">return </span><span class="s0">r.oneOfNodeTypes=[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">,</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">],r}()},value:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;PatternLike&quot;</span><span class="s0">)},shorthand:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),Object.assign((</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(n.env.BABEL_TYPES_8_BREAKING&amp;&amp;r&amp;&amp;e.computed)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">&quot;Property shorthand of ObjectProperty cannot be true if computed is true&quot;</span><span class="s0">)}),{type:</span><span class="s3">&quot;boolean&quot;</span><span class="s0">}),(</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(n.env.BABEL_TYPES_8_BREAKING&amp;&amp;r&amp;&amp;!(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,e.key))</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">&quot;Property shorthand of ObjectProperty cannot be true if key is not an Identifier&quot;</span><span class="s0">)})),</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">},decorators:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">))),optional:!</span><span class="s2">0</span><span class="s0">}},visitor:[</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;value&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;UserWhitespacable&quot;</span><span class="s0">,</span><span class="s3">&quot;Property&quot;</span><span class="s0">,</span><span class="s3">&quot;ObjectMember&quot;</span><span class="s0">],validate:</span><span class="s1">function</span><span class="s0">(){const e=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">),t=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">);</span><span class="s1">return function</span><span class="s0">(r,s,a){n.env.BABEL_TYPES_8_BREAKING&amp;&amp;((</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">,r)?e:t)(a,</span><span class="s3">&quot;value&quot;</span><span class="s0">,a.value)}}()}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;LVal&quot;</span><span class="s0">,</span><span class="s3">&quot;PatternLike&quot;</span><span class="s0">],deprecatedAlias:</span><span class="s3">&quot;RestProperty&quot;</span><span class="s0">,fields:Object.assign({},d,{argument:{validate:n.env.BABEL_TYPES_8_BREAKING?(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">,</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">):(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;LVal&quot;</span><span class="s0">)}}),validate(e,t){</span><span class="s1">if</span><span class="s0">(!n.env.BABEL_TYPES_8_BREAKING)</span><span class="s1">return</span><span class="s0">;const r=/(\w+)\[(\d+)\]/.exec(t);</span><span class="s1">if</span><span class="s0">(!r)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Internal Babel error: malformed key.&quot;</span><span class="s0">);const[,i,s]=r;</span><span class="s1">if</span><span class="s0">(e[i].length&gt;s+</span><span class="s2">1</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">TypeError(`RestElement must be last element of ${i}`)}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ReturnStatement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Terminatorless&quot;</span><span class="s0">,</span><span class="s3">&quot;CompletionStatement&quot;</span><span class="s0">],fields:{argument:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;expressions&quot;</span><span class="s0">],fields:{expressions:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)))}},aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;expression&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;ExpressionWrapper&quot;</span><span class="s0">],fields:{expression:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;SwitchCase&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;test&quot;</span><span class="s0">,</span><span class="s3">&quot;consequent&quot;</span><span class="s0">],fields:{test:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},consequent:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)))}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;SwitchStatement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;discriminant&quot;</span><span class="s0">,</span><span class="s3">&quot;cases&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">,</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">],fields:{discriminant:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},cases:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;SwitchCase&quot;</span><span class="s0">)))}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ThisExpression&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ThrowStatement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Terminatorless&quot;</span><span class="s0">,</span><span class="s3">&quot;CompletionStatement&quot;</span><span class="s0">],fields:{argument:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TryStatement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;block&quot;</span><span class="s0">,</span><span class="s3">&quot;handler&quot;</span><span class="s0">,</span><span class="s3">&quot;finalizer&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">],fields:{block:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">),Object.assign((</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(n.env.BABEL_TYPES_8_BREAKING&amp;&amp;!e.handler&amp;&amp;!e.finalizer)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">&quot;TryStatement expects either a handler or finalizer, or both&quot;</span><span class="s0">)}),{oneOfNodeTypes:[</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">]}))},handler:{optional:!</span><span class="s2">0</span><span class="s0">,validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;CatchClause&quot;</span><span class="s0">)},finalizer:{optional:!</span><span class="s2">0</span><span class="s0">,validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;UnaryExpression&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;operator&quot;</span><span class="s0">,</span><span class="s3">&quot;argument&quot;</span><span class="s0">,</span><span class="s3">&quot;prefix&quot;</span><span class="s0">],fields:{prefix:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">0</span><span class="s0">},argument:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},operator:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(...o.UNARY_OPERATORS)}},visitor:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;UnaryLike&quot;</span><span class="s0">,</span><span class="s3">&quot;Expression&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;UpdateExpression&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;operator&quot;</span><span class="s0">,</span><span class="s3">&quot;argument&quot;</span><span class="s0">,</span><span class="s3">&quot;prefix&quot;</span><span class="s0">],fields:{prefix:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">},argument:{validate:n.env.BABEL_TYPES_8_BREAKING?(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">):(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},operator:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(...o.UPDATE_OPERATORS)}},visitor:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;kind&quot;</span><span class="s0">,</span><span class="s3">&quot;declarations&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;declarations&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],fields:{declare:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},kind:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(</span><span class="s3">&quot;var&quot;</span><span class="s0">,</span><span class="s3">&quot;let&quot;</span><span class="s0">,</span><span class="s3">&quot;const&quot;</span><span class="s0">)},declarations:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s0">)))}},validate(e,t,r){</span><span class="s1">if</span><span class="s0">(n.env.BABEL_TYPES_8_BREAKING&amp;&amp;(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ForXStatement&quot;</span><span class="s0">,e,{left:r})&amp;&amp;</span><span class="s2">1</span><span class="s0">!==r.declarations.length)</span><span class="s1">throw new </span><span class="s0">TypeError(`Exactly one VariableDeclarator is required </span><span class="s1">in </span><span class="s0">the VariableDeclaration of a ${e.type}`)}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;init&quot;</span><span class="s0">],fields:{id:{validate:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(!n.env.BABEL_TYPES_8_BREAKING)</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;LVal&quot;</span><span class="s0">);const e=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">,</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">),t=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">);</span><span class="s1">return function</span><span class="s0">(r,n,i){(r.init?e:t)(r,n,i)}}()},definite:{optional:!</span><span class="s2">0</span><span class="s0">,validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">)},init:{optional:!</span><span class="s2">0</span><span class="s0">,validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;WhileStatement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;test&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">,</span><span class="s3">&quot;Loop&quot;</span><span class="s0">,</span><span class="s3">&quot;While&quot;</span><span class="s0">,</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">],fields:{test:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},body:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;WithStatement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;object&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">],fields:{object:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},body:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;left&quot;</span><span class="s0">,</span><span class="s3">&quot;right&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;left&quot;</span><span class="s0">,</span><span class="s3">&quot;right&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">,</span><span class="s3">&quot;PatternLike&quot;</span><span class="s0">,</span><span class="s3">&quot;LVal&quot;</span><span class="s0">],fields:Object.assign({},d,{left:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">,</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">,</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">)},right:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},decorators:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">))),optional:!</span><span class="s2">0</span><span class="s0">}})}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;elements&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;elements&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">,</span><span class="s3">&quot;PatternLike&quot;</span><span class="s0">,</span><span class="s3">&quot;LVal&quot;</span><span class="s0">],fields:Object.assign({},d,{elements:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeOrValueType)(</span><span class="s3">&quot;null&quot;</span><span class="s0">,</span><span class="s3">&quot;PatternLike&quot;</span><span class="s0">)))},decorators:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">))),optional:!</span><span class="s2">0</span><span class="s0">}})}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;params&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;async&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;params&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;returnType&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;Function&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">,</span><span class="s3">&quot;FunctionParent&quot;</span><span class="s0">,</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Pureish&quot;</span><span class="s0">],fields:Object.assign({},p,c,{expression:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">)},body:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">,</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}})}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ClassBody&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;body&quot;</span><span class="s0">],fields:{body:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">,</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">,</span><span class="s3">&quot;ClassProperty&quot;</span><span class="s0">,</span><span class="s3">&quot;ClassPrivateProperty&quot;</span><span class="s0">,</span><span class="s3">&quot;TSDeclareMethod&quot;</span><span class="s0">,</span><span class="s3">&quot;TSIndexSignature&quot;</span><span class="s0">)))}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ClassExpression&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;superClass&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;superClass&quot;</span><span class="s0">,</span><span class="s3">&quot;mixins&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;superTypeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;implements&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;Class&quot;</span><span class="s0">,</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],fields:{id:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},typeParameters:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;TSTypeParameterDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Noop&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},body:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;ClassBody&quot;</span><span class="s0">)},superClass:{optional:!</span><span class="s2">0</span><span class="s0">,validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},superTypeParameters:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">,</span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},implements:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;TSExpressionWithTypeArguments&quot;</span><span class="s0">,</span><span class="s3">&quot;ClassImplements&quot;</span><span class="s0">))),optional:!</span><span class="s2">0</span><span class="s0">},decorators:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">))),optional:!</span><span class="s2">0</span><span class="s0">},mixins:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;InterfaceExtends&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">,{inherits:</span><span class="s3">&quot;ClassExpression&quot;</span><span class="s0">,aliases:[</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;Class&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],fields:{id:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)},typeParameters:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;TSTypeParameterDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Noop&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},body:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;ClassBody&quot;</span><span class="s0">)},superClass:{optional:!</span><span class="s2">0</span><span class="s0">,validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},superTypeParameters:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">,</span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},implements:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;TSExpressionWithTypeArguments&quot;</span><span class="s0">,</span><span class="s3">&quot;ClassImplements&quot;</span><span class="s0">))),optional:!</span><span class="s2">0</span><span class="s0">},decorators:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">))),optional:!</span><span class="s2">0</span><span class="s0">},mixins:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;InterfaceExtends&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},declare:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},abstract:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}},validate:</span><span class="s1">function</span><span class="s0">(){const e=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">);</span><span class="s1">return function</span><span class="s0">(t,r,s){n.env.BABEL_TYPES_8_BREAKING&amp;&amp;((</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">,t)||e(s,</span><span class="s3">&quot;id&quot;</span><span class="s0">,s.id))}}()}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;source&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">,</span><span class="s3">&quot;ModuleDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;ExportDeclaration&quot;</span><span class="s0">],fields:{source:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">)},exportKind:(</span><span class="s2">0</span><span class="s0">,l.validateOptional)((</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(</span><span class="s3">&quot;type&quot;</span><span class="s0">,</span><span class="s3">&quot;value&quot;</span><span class="s0">)),assertions:{optional:!</span><span class="s2">0</span><span class="s0">,validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;ImportAttribute&quot;</span><span class="s0">)))}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;declaration&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">,</span><span class="s3">&quot;ModuleDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;ExportDeclaration&quot;</span><span class="s0">],fields:{declaration:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;TSDeclareFunction&quot;</span><span class="s0">,</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;declaration&quot;</span><span class="s0">,</span><span class="s3">&quot;specifiers&quot;</span><span class="s0">,</span><span class="s3">&quot;source&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">,</span><span class="s3">&quot;ModuleDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;ExportDeclaration&quot;</span><span class="s0">],fields:{declaration:{optional:!</span><span class="s2">0</span><span class="s0">,validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">),Object.assign((</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(n.env.BABEL_TYPES_8_BREAKING&amp;&amp;r&amp;&amp;e.specifiers.length)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">&quot;Only declaration or specifiers is allowed on ExportNamedDeclaration&quot;</span><span class="s0">)}),{oneOfNodeTypes:[</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">]}),(</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(n.env.BABEL_TYPES_8_BREAKING&amp;&amp;r&amp;&amp;e.source)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">&quot;Cannot export a declaration from a source&quot;</span><span class="s0">)}))},assertions:{optional:!</span><span class="s2">0</span><span class="s0">,validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;ImportAttribute&quot;</span><span class="s0">)))},specifiers:{</span><span class="s1">default</span><span class="s0">:[],validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)(</span><span class="s1">function</span><span class="s0">(){const e=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;ExportSpecifier&quot;</span><span class="s0">,</span><span class="s3">&quot;ExportDefaultSpecifier&quot;</span><span class="s0">,</span><span class="s3">&quot;ExportNamespaceSpecifier&quot;</span><span class="s0">),t=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;ExportSpecifier&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">n.env.BABEL_TYPES_8_BREAKING?</span><span class="s1">function</span><span class="s0">(r,n,i){(r.source?e:t)(r,n,i)}:e}()))},source:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},exportKind:(</span><span class="s2">0</span><span class="s0">,l.validateOptional)((</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(</span><span class="s3">&quot;type&quot;</span><span class="s0">,</span><span class="s3">&quot;value&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExportSpecifier&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;local&quot;</span><span class="s0">,</span><span class="s3">&quot;exported&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;ModuleSpecifier&quot;</span><span class="s0">],fields:{local:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)},exported:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;left&quot;</span><span class="s0">,</span><span class="s3">&quot;right&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;left&quot;</span><span class="s0">,</span><span class="s3">&quot;right&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;await&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;For&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">,</span><span class="s3">&quot;Loop&quot;</span><span class="s0">,</span><span class="s3">&quot;ForXStatement&quot;</span><span class="s0">],fields:{left:{validate:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(!n.env.BABEL_TYPES_8_BREAKING)</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;LVal&quot;</span><span class="s0">);const e=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">),t=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">,</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">,</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">);</span><span class="s1">return function</span><span class="s0">(r,n,s){(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">,s)?e(r,n,s):t(r,n,s)}}()},right:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},body:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)},await:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;specifiers&quot;</span><span class="s0">,</span><span class="s3">&quot;source&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">,</span><span class="s3">&quot;ModuleDeclaration&quot;</span><span class="s0">],fields:{assertions:{optional:!</span><span class="s2">0</span><span class="s0">,validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;ImportAttribute&quot;</span><span class="s0">)))},specifiers:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s0">,</span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">,</span><span class="s3">&quot;ImportNamespaceSpecifier&quot;</span><span class="s0">)))},source:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">)},importKind:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(</span><span class="s3">&quot;type&quot;</span><span class="s0">,</span><span class="s3">&quot;typeof&quot;</span><span class="s0">,</span><span class="s3">&quot;value&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;local&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;ModuleSpecifier&quot;</span><span class="s0">],fields:{local:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ImportNamespaceSpecifier&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;local&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;ModuleSpecifier&quot;</span><span class="s0">],fields:{local:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;local&quot;</span><span class="s0">,</span><span class="s3">&quot;imported&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;ModuleSpecifier&quot;</span><span class="s0">],fields:{local:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)},imported:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">)},importKind:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(</span><span class="s3">&quot;type&quot;</span><span class="s0">,</span><span class="s3">&quot;typeof&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;MetaProperty&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;meta&quot;</span><span class="s0">,</span><span class="s3">&quot;property&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],fields:{meta:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),Object.assign((</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(!n.env.BABEL_TYPES_8_BREAKING)</span><span class="s1">return</span><span class="s0">;let s;</span><span class="s1">switch</span><span class="s0">(r.name){</span><span class="s1">case</span><span class="s3">&quot;function&quot;</span><span class="s0">:s=</span><span class="s3">&quot;sent&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;new&quot;</span><span class="s0">:s=</span><span class="s3">&quot;target&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;import&quot;</span><span class="s0">:s=</span><span class="s3">&quot;meta&quot;</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(!(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,e.property,{name:s}))</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">&quot;Unrecognised MetaProperty&quot;</span><span class="s0">)}),{oneOfNodeTypes:[</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">]}))},property:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)}}});const h={abstract:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},accessibility:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(</span><span class="s3">&quot;public&quot;</span><span class="s0">,</span><span class="s3">&quot;private&quot;</span><span class="s0">,</span><span class="s3">&quot;protected&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},static:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">},override:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">},computed:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">},optional:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},key:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)(</span><span class="s1">function</span><span class="s0">(){const e=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">,</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">),t=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">);</span><span class="s1">return function</span><span class="s0">(r,n,i){(r.computed?t:e)(r,n,i)}}(),(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">,</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">,</span><span class="s3">&quot;Expression&quot;</span><span class="s0">))}};t.classMethodOrPropertyCommon=h;const f=Object.assign({},p,h,{kind:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(</span><span class="s3">&quot;get&quot;</span><span class="s0">,</span><span class="s3">&quot;set&quot;</span><span class="s0">,</span><span class="s3">&quot;method&quot;</span><span class="s0">,</span><span class="s3">&quot;constructor&quot;</span><span class="s0">),</span><span class="s1">default</span><span class="s0">:</span><span class="s3">&quot;method&quot;</span><span class="s0">},access:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertOneOf)(</span><span class="s3">&quot;public&quot;</span><span class="s0">,</span><span class="s3">&quot;private&quot;</span><span class="s0">,</span><span class="s3">&quot;protected&quot;</span><span class="s0">)),optional:!</span><span class="s2">0</span><span class="s0">},decorators:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">))),optional:!</span><span class="s2">0</span><span class="s0">}});t.classMethodOrDeclareMethodCommon=f,(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Function&quot;</span><span class="s0">,</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">,</span><span class="s3">&quot;FunctionParent&quot;</span><span class="s0">,</span><span class="s3">&quot;Method&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;kind&quot;</span><span class="s0">,</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;params&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;computed&quot;</span><span class="s0">,</span><span class="s3">&quot;static&quot;</span><span class="s0">,</span><span class="s3">&quot;generator&quot;</span><span class="s0">,</span><span class="s3">&quot;async&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;params&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">,</span><span class="s3">&quot;returnType&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">],fields:Object.assign({},f,c,{body:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">)}})}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;properties&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;properties&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">,</span><span class="s3">&quot;PatternLike&quot;</span><span class="s0">,</span><span class="s3">&quot;LVal&quot;</span><span class="s0">],fields:Object.assign({},d,{properties:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">,</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">)))}})}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;UnaryLike&quot;</span><span class="s0">],deprecatedAlias:</span><span class="s3">&quot;SpreadProperty&quot;</span><span class="s0">,fields:{argument:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Super&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TaggedTemplateExpression&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;tag&quot;</span><span class="s0">,</span><span class="s3">&quot;quasi&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],fields:{tag:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},quasi:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;TemplateLiteral&quot;</span><span class="s0">)},typeParameters:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">,</span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TemplateElement&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;value&quot;</span><span class="s0">,</span><span class="s3">&quot;tail&quot;</span><span class="s0">],fields:{value:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertShape)({raw:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">)},cooked:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}})},tail:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TemplateLiteral&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;quasis&quot;</span><span class="s0">,</span><span class="s3">&quot;expressions&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Literal&quot;</span><span class="s0">],fields:{quasis:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;TemplateElement&quot;</span><span class="s0">)))},expressions:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;TSType&quot;</span><span class="s0">)),(</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(e.quasis.length!==r.length+</span><span class="s2">1</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">TypeError(`Number of ${e.type} quasis should be exactly one more than the number of expressions.\nExpected ${r.length+</span><span class="s2">1</span><span class="s0">} quasis but got ${e.quasis.length}`)}))}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;YieldExpression&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">,</span><span class="s3">&quot;delegate&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Terminatorless&quot;</span><span class="s0">],fields:{delegate:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),Object.assign((</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(n.env.BABEL_TYPES_8_BREAKING&amp;&amp;r&amp;&amp;!e.argument)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">&quot;Property delegate of YieldExpression cannot be true if there is no argument&quot;</span><span class="s0">)}),{type:</span><span class="s3">&quot;boolean&quot;</span><span class="s0">})),</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">},argument:{optional:!</span><span class="s2">0</span><span class="s0">,validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;AwaitExpression&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Terminatorless&quot;</span><span class="s0">],fields:{argument:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Import&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;BigIntLiteral&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;value&quot;</span><span class="s0">],fields:{value:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">)}},aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Pureish&quot;</span><span class="s0">,</span><span class="s3">&quot;Literal&quot;</span><span class="s0">,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExportNamespaceSpecifier&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;exported&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;ModuleSpecifier&quot;</span><span class="s0">],fields:{exported:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;object&quot;</span><span class="s0">,</span><span class="s3">&quot;property&quot;</span><span class="s0">,</span><span class="s3">&quot;computed&quot;</span><span class="s0">,</span><span class="s3">&quot;optional&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;object&quot;</span><span class="s0">,</span><span class="s3">&quot;property&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],fields:{object:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},property:{validate:</span><span class="s1">function</span><span class="s0">(){const e=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),t=(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">),r=</span><span class="s1">function</span><span class="s0">(r,n,i){(r.computed?t:e)(r,n,i)};</span><span class="s1">return </span><span class="s0">r.oneOfNodeTypes=[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">],r}()},computed:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">},optional:{validate:n.env.BABEL_TYPES_8_BREAKING?(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertOptionalChainStart)()):(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,l.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;OptionalCallExpression&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;callee&quot;</span><span class="s0">,</span><span class="s3">&quot;arguments&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;typeArguments&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;callee&quot;</span><span class="s0">,</span><span class="s3">&quot;arguments&quot;</span><span class="s0">,</span><span class="s3">&quot;optional&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],fields:{callee:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},arguments:{validate:(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertEach)((</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">,</span><span class="s3">&quot;ArgumentPlaceholder&quot;</span><span class="s0">)))},optional:{validate:n.env.BABEL_TYPES_8_BREAKING?(</span><span class="s2">0</span><span class="s0">,l.chain)((</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,l.assertOptionalChainStart)()):(</span><span class="s2">0</span><span class="s0">,l.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">)},typeArguments:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},typeParameters:{validate:(</span><span class="s2">0</span><span class="s0">,l.assertNodeType)(</span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}}})},</span><span class="s2">4683</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">397</span><span class="s0">),i=r(</span><span class="s2">5455</span><span class="s0">),s=r(</span><span class="s2">9357</span><span class="s0">);(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ArgumentPlaceholder&quot;</span><span class="s0">,{}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;BindExpression&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;object&quot;</span><span class="s0">,</span><span class="s3">&quot;callee&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],fields:n.env.BABEL_TYPES_8_BREAKING?{object:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)},callee:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}:{object:{validate:Object.assign((()=&gt;{}),{oneOfNodeTypes:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">]})},callee:{validate:Object.assign((()=&gt;{}),{oneOfNodeTypes:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">]})}}}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ClassProperty&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;value&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;value&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">,</span><span class="s3">&quot;computed&quot;</span><span class="s0">,</span><span class="s3">&quot;static&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Property&quot;</span><span class="s0">],fields:Object.assign({},s.classMethodOrPropertyCommon,{value:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},definite:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},typeAnnotation:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;Noop&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},decorators:{validate:(</span><span class="s2">0</span><span class="s0">,i.chain)((</span><span class="s2">0</span><span class="s0">,i.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,i.assertEach)((</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">))),optional:!</span><span class="s2">0</span><span class="s0">},readonly:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},declare:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}})}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;PipelineTopicExpression&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;expression&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;expression&quot;</span><span class="s0">],fields:{expression:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;PipelineBareFunction&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;callee&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;callee&quot;</span><span class="s0">],fields:{callee:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;PipelinePrimaryTopicReference&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ClassPrivateProperty&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;value&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;value&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">,</span><span class="s3">&quot;static&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Property&quot;</span><span class="s0">,</span><span class="s3">&quot;Private&quot;</span><span class="s0">],fields:{key:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">)},value:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},typeAnnotation:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;Noop&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},decorators:{validate:(</span><span class="s2">0</span><span class="s0">,i.chain)((</span><span class="s2">0</span><span class="s0">,i.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,i.assertEach)((</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">))),optional:!</span><span class="s2">0</span><span class="s0">}}}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;kind&quot;</span><span class="s0">,</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;params&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;static&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;params&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">,</span><span class="s3">&quot;returnType&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Function&quot;</span><span class="s0">,</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">,</span><span class="s3">&quot;FunctionParent&quot;</span><span class="s0">,</span><span class="s3">&quot;Method&quot;</span><span class="s0">,</span><span class="s3">&quot;Private&quot;</span><span class="s0">],fields:Object.assign({},s.classMethodOrDeclareMethodCommon,s.functionTypeAnnotationCommon,{key:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">)},body:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">)}})}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ImportAttribute&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;value&quot;</span><span class="s0">],fields:{key:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">)},value:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;expression&quot;</span><span class="s0">],fields:{expression:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DoExpression&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;body&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;async&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],fields:{body:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">)},async:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">}}}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExportDefaultSpecifier&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;exported&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;ModuleSpecifier&quot;</span><span class="s0">],fields:{exported:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Private&quot;</span><span class="s0">],fields:{id:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;RecordExpression&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;properties&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],fields:{properties:{validate:(</span><span class="s2">0</span><span class="s0">,i.chain)((</span><span class="s2">0</span><span class="s0">,i.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,i.assertEach)((</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">,</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">)))}}}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TupleExpression&quot;</span><span class="s0">,{fields:{elements:{validate:(</span><span class="s2">0</span><span class="s0">,i.chain)((</span><span class="s2">0</span><span class="s0">,i.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,i.assertEach)((</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">))),</span><span class="s1">default</span><span class="s0">:[]}},visitor:[</span><span class="s3">&quot;elements&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DecimalLiteral&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;value&quot;</span><span class="s0">],fields:{value:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">)}},aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Pureish&quot;</span><span class="s0">,</span><span class="s3">&quot;Literal&quot;</span><span class="s0">,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;StaticBlock&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;body&quot;</span><span class="s0">],fields:{body:{validate:(</span><span class="s2">0</span><span class="s0">,i.chain)((</span><span class="s2">0</span><span class="s0">,i.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,i.assertEach)((</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)))}},aliases:[</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ModuleExpression&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;body&quot;</span><span class="s0">],fields:{body:{validate:(</span><span class="s2">0</span><span class="s0">,i.assertNodeType)(</span><span class="s3">&quot;Program&quot;</span><span class="s0">)}},aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">]})},</span><span class="s2">2665</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">5455</span><span class="s0">);const i=(e,t=</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">)=&gt;{(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,{builder:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;extends&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;extends&quot;</span><span class="s0">,</span><span class="s3">&quot;mixins&quot;</span><span class="s0">,</span><span class="s3">&quot;implements&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),typeParameters:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(t),extends:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)((</span><span class="s2">0</span><span class="s0">,n.arrayOfType)(</span><span class="s3">&quot;InterfaceExtends&quot;</span><span class="s0">)),mixins:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)((</span><span class="s2">0</span><span class="s0">,n.arrayOfType)(</span><span class="s3">&quot;InterfaceExtends&quot;</span><span class="s0">)),implements:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)((</span><span class="s2">0</span><span class="s0">,n.arrayOfType)(</span><span class="s3">&quot;ClassImplements&quot;</span><span class="s0">)),body:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;ObjectTypeAnnotation&quot;</span><span class="s0">)}})};(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;AnyTypeAnnotation&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowBaseAnnotation&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ArrayTypeAnnotation&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;elementType&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">],fields:{elementType:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;BooleanTypeAnnotation&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowBaseAnnotation&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;BooleanLiteralTypeAnnotation&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;value&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">],fields:{value:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;NullLiteralTypeAnnotation&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowBaseAnnotation&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ClassImplements&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),typeParameters:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">)}}),i(</span><span class="s3">&quot;DeclareClass&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareFunction&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),predicate:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;DeclaredPredicate&quot;</span><span class="s0">)}}),i(</span><span class="s3">&quot;DeclareInterface&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareModule&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">,</span><span class="s3">&quot;kind&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)([</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">]),body:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">),kind:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)((</span><span class="s2">0</span><span class="s0">,n.assertOneOf)(</span><span class="s3">&quot;CommonJS&quot;</span><span class="s0">,</span><span class="s3">&quot;ES&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareModuleExports&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],fields:{typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareTypeAlias&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;right&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),typeParameters:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">),right:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareOpaqueType&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;supertype&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),typeParameters:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">),supertype:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareVariable&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareExportDeclaration&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;declaration&quot;</span><span class="s0">,</span><span class="s3">&quot;specifiers&quot;</span><span class="s0">,</span><span class="s3">&quot;source&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],fields:{declaration:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;Flow&quot;</span><span class="s0">),specifiers:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)((</span><span class="s2">0</span><span class="s0">,n.arrayOfType)([</span><span class="s3">&quot;ExportSpecifier&quot;</span><span class="s0">,</span><span class="s3">&quot;ExportNamespaceSpecifier&quot;</span><span class="s0">])),source:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">),</span><span class="s1">default</span><span class="s0">:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclareExportAllDeclaration&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;source&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],fields:{source:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">),exportKind:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)((</span><span class="s2">0</span><span class="s0">,n.assertOneOf)(</span><span class="s3">&quot;type&quot;</span><span class="s0">,</span><span class="s3">&quot;value&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;DeclaredPredicate&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;value&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowPredicate&quot;</span><span class="s0">],fields:{value:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Flow&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ExistsTypeAnnotation&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;params&quot;</span><span class="s0">,</span><span class="s3">&quot;rest&quot;</span><span class="s0">,</span><span class="s3">&quot;returnType&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">],fields:{typeParameters:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">),params:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.arrayOfType)(</span><span class="s3">&quot;FunctionTypeParam&quot;</span><span class="s0">)),rest:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;FunctionTypeParam&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;FunctionTypeParam&quot;</span><span class="s0">),returnType:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;FunctionTypeParam&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;name&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">],fields:{name:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">),optional:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;GenericTypeAnnotation&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)([</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;QualifiedTypeIdentifier&quot;</span><span class="s0">]),typeParameters:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;InferredPredicate&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowPredicate&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;InterfaceExtends&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)([</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;QualifiedTypeIdentifier&quot;</span><span class="s0">]),typeParameters:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">)}}),i(</span><span class="s3">&quot;InterfaceDeclaration&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;InterfaceTypeAnnotation&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;extends&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">],fields:{extends:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)((</span><span class="s2">0</span><span class="s0">,n.arrayOfType)(</span><span class="s3">&quot;InterfaceExtends&quot;</span><span class="s0">)),body:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;ObjectTypeAnnotation&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;IntersectionTypeAnnotation&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;types&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">],fields:{types:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.arrayOfType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;MixedTypeAnnotation&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowBaseAnnotation&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EmptyTypeAnnotation&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowBaseAnnotation&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;NullableTypeAnnotation&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">],fields:{typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;NumberLiteralTypeAnnotation&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;value&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">],fields:{value:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;number&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;NumberTypeAnnotation&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowBaseAnnotation&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectTypeAnnotation&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;properties&quot;</span><span class="s0">,</span><span class="s3">&quot;indexers&quot;</span><span class="s0">,</span><span class="s3">&quot;callProperties&quot;</span><span class="s0">,</span><span class="s3">&quot;internalSlots&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;properties&quot;</span><span class="s0">,</span><span class="s3">&quot;indexers&quot;</span><span class="s0">,</span><span class="s3">&quot;callProperties&quot;</span><span class="s0">,</span><span class="s3">&quot;internalSlots&quot;</span><span class="s0">,</span><span class="s3">&quot;exact&quot;</span><span class="s0">],fields:{properties:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.arrayOfType)([</span><span class="s3">&quot;ObjectTypeProperty&quot;</span><span class="s0">,</span><span class="s3">&quot;ObjectTypeSpreadProperty&quot;</span><span class="s0">])),indexers:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)((</span><span class="s2">0</span><span class="s0">,n.arrayOfType)(</span><span class="s3">&quot;ObjectTypeIndexer&quot;</span><span class="s0">)),callProperties:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)((</span><span class="s2">0</span><span class="s0">,n.arrayOfType)(</span><span class="s3">&quot;ObjectTypeCallProperty&quot;</span><span class="s0">)),internalSlots:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)((</span><span class="s2">0</span><span class="s0">,n.arrayOfType)(</span><span class="s3">&quot;ObjectTypeInternalSlot&quot;</span><span class="s0">)),exact:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">},inexact:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectTypeInternalSlot&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;value&quot;</span><span class="s0">,</span><span class="s3">&quot;optional&quot;</span><span class="s0">,</span><span class="s3">&quot;static&quot;</span><span class="s0">,</span><span class="s3">&quot;method&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;UserWhitespacable&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),value:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">),optional:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">)),static:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">)),method:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectTypeCallProperty&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;value&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;UserWhitespacable&quot;</span><span class="s0">],fields:{value:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">),static:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectTypeIndexer&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;value&quot;</span><span class="s0">,</span><span class="s3">&quot;variance&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;UserWhitespacable&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),key:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">),value:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">),static:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">)),variance:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;Variance&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectTypeProperty&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;value&quot;</span><span class="s0">,</span><span class="s3">&quot;variance&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;UserWhitespacable&quot;</span><span class="s0">],fields:{key:(</span><span class="s2">0</span><span class="s0">,n.validateType)([</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">]),value:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">),kind:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertOneOf)(</span><span class="s3">&quot;init&quot;</span><span class="s0">,</span><span class="s3">&quot;get&quot;</span><span class="s0">,</span><span class="s3">&quot;set&quot;</span><span class="s0">)),static:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">)),proto:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">)),optional:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">)),variance:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;Variance&quot;</span><span class="s0">),method:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ObjectTypeSpreadProperty&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;UserWhitespacable&quot;</span><span class="s0">],fields:{argument:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;OpaqueType&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;supertype&quot;</span><span class="s0">,</span><span class="s3">&quot;impltype&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),typeParameters:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">),supertype:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">),impltype:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;QualifiedTypeIdentifier&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;qualification&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),qualification:(</span><span class="s2">0</span><span class="s0">,n.validateType)([</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;QualifiedTypeIdentifier&quot;</span><span class="s0">])}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;StringLiteralTypeAnnotation&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;value&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">],fields:{value:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;StringTypeAnnotation&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowBaseAnnotation&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;SymbolTypeAnnotation&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowBaseAnnotation&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;ThisTypeAnnotation&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowBaseAnnotation&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TupleTypeAnnotation&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;types&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">],fields:{types:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.arrayOfType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TypeofTypeAnnotation&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">],fields:{argument:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TypeAlias&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;right&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),typeParameters:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">),right:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],fields:{typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;expression&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;ExpressionWrapper&quot;</span><span class="s0">,</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],fields:{expression:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">),typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TypeParameter&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;bound&quot;</span><span class="s0">,</span><span class="s3">&quot;default&quot;</span><span class="s0">,</span><span class="s3">&quot;variance&quot;</span><span class="s0">],fields:{name:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">)),bound:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">),</span><span class="s1">default</span><span class="s0">:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">),variance:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;Variance&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;params&quot;</span><span class="s0">],fields:{params:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.arrayOfType)(</span><span class="s3">&quot;TypeParameter&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;params&quot;</span><span class="s0">],fields:{params:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.arrayOfType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;UnionTypeAnnotation&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;types&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">],fields:{types:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.arrayOfType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Variance&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;kind&quot;</span><span class="s0">],fields:{kind:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertOneOf)(</span><span class="s3">&quot;minus&quot;</span><span class="s0">,</span><span class="s3">&quot;plus&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;VoidTypeAnnotation&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowBaseAnnotation&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumDeclaration&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),body:(</span><span class="s2">0</span><span class="s0">,n.validateType)([</span><span class="s3">&quot;EnumBooleanBody&quot;</span><span class="s0">,</span><span class="s3">&quot;EnumNumberBody&quot;</span><span class="s0">,</span><span class="s3">&quot;EnumStringBody&quot;</span><span class="s0">,</span><span class="s3">&quot;EnumSymbolBody&quot;</span><span class="s0">])}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumBooleanBody&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;EnumBody&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;members&quot;</span><span class="s0">],fields:{explicitType:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">)),members:(</span><span class="s2">0</span><span class="s0">,n.validateArrayOfType)(</span><span class="s3">&quot;EnumBooleanMember&quot;</span><span class="s0">),hasUnknownMembers:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumNumberBody&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;EnumBody&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;members&quot;</span><span class="s0">],fields:{explicitType:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">)),members:(</span><span class="s2">0</span><span class="s0">,n.validateArrayOfType)(</span><span class="s3">&quot;EnumNumberMember&quot;</span><span class="s0">),hasUnknownMembers:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumStringBody&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;EnumBody&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;members&quot;</span><span class="s0">],fields:{explicitType:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">)),members:(</span><span class="s2">0</span><span class="s0">,n.validateArrayOfType)([</span><span class="s3">&quot;EnumStringMember&quot;</span><span class="s0">,</span><span class="s3">&quot;EnumDefaultedMember&quot;</span><span class="s0">]),hasUnknownMembers:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumSymbolBody&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;EnumBody&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;members&quot;</span><span class="s0">],fields:{members:(</span><span class="s2">0</span><span class="s0">,n.validateArrayOfType)(</span><span class="s3">&quot;EnumDefaultedMember&quot;</span><span class="s0">),hasUnknownMembers:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">))}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumBooleanMember&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;EnumMember&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),init:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;BooleanLiteral&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumNumberMember&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;EnumMember&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;init&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),init:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumStringMember&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;EnumMember&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;init&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),init:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;EnumDefaultedMember&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;EnumMember&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;IndexedAccessType&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;objectType&quot;</span><span class="s0">,</span><span class="s3">&quot;indexType&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">],fields:{objectType:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">),indexType:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;OptionalIndexedAccessType&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;objectType&quot;</span><span class="s0">,</span><span class="s3">&quot;indexType&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">],fields:{objectType:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">),indexType:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;FlowType&quot;</span><span class="s0">),optional:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">))}})},</span><span class="s2">1102</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),Object.defineProperty(t,</span><span class="s3">&quot;VISITOR_KEYS&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.VISITOR_KEYS}}),Object.defineProperty(t,</span><span class="s3">&quot;ALIAS_KEYS&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.ALIAS_KEYS}}),Object.defineProperty(t,</span><span class="s3">&quot;FLIPPED_ALIAS_KEYS&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.FLIPPED_ALIAS_KEYS}}),Object.defineProperty(t,</span><span class="s3">&quot;NODE_FIELDS&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.NODE_FIELDS}}),Object.defineProperty(t,</span><span class="s3">&quot;BUILDER_KEYS&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.BUILDER_KEYS}}),Object.defineProperty(t,</span><span class="s3">&quot;DEPRECATED_KEYS&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.DEPRECATED_KEYS}}),Object.defineProperty(t,</span><span class="s3">&quot;NODE_PARENT_VALIDATIONS&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.NODE_PARENT_VALIDATIONS}}),Object.defineProperty(t,</span><span class="s3">&quot;PLACEHOLDERS&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">s.PLACEHOLDERS}}),Object.defineProperty(t,</span><span class="s3">&quot;PLACEHOLDERS_ALIAS&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">s.PLACEHOLDERS_ALIAS}}),Object.defineProperty(t,</span><span class="s3">&quot;PLACEHOLDERS_FLIPPED_ALIAS&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">s.PLACEHOLDERS_FLIPPED_ALIAS}}),t.TYPES=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1138</span><span class="s0">);r(</span><span class="s2">9357</span><span class="s0">),r(</span><span class="s2">2665</span><span class="s0">),r(</span><span class="s2">6540</span><span class="s0">),r(</span><span class="s2">511</span><span class="s0">),r(</span><span class="s2">4683</span><span class="s0">),r(</span><span class="s2">2130</span><span class="s0">);</span><span class="s1">var </span><span class="s0">i=r(</span><span class="s2">5455</span><span class="s0">),s=r(</span><span class="s2">6820</span><span class="s0">);n(i.VISITOR_KEYS),n(i.ALIAS_KEYS),n(i.FLIPPED_ALIAS_KEYS),n(i.NODE_FIELDS),n(i.BUILDER_KEYS),n(i.DEPRECATED_KEYS),n(s.PLACEHOLDERS_ALIAS),n(s.PLACEHOLDERS_FLIPPED_ALIAS);const a=Object.keys(i.VISITOR_KEYS).concat(Object.keys(i.FLIPPED_ALIAS_KEYS)).concat(Object.keys(i.DEPRECATED_KEYS));t.TYPES=a},</span><span class="s2">6540</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">5455</span><span class="s0">);(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXAttribute&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;name&quot;</span><span class="s0">,</span><span class="s3">&quot;value&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;JSX&quot;</span><span class="s0">,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">],fields:{name:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">)},value:{optional:!</span><span class="s2">0</span><span class="s0">,validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;JSXElement&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXFragment&quot;</span><span class="s0">,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXExpressionContainer&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXClosingElement&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;name&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;JSX&quot;</span><span class="s0">,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">],fields:{name:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXElement&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;openingElement&quot;</span><span class="s0">,</span><span class="s3">&quot;closingElement&quot;</span><span class="s0">,</span><span class="s3">&quot;children&quot;</span><span class="s0">,</span><span class="s3">&quot;selfClosing&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;openingElement&quot;</span><span class="s0">,</span><span class="s3">&quot;children&quot;</span><span class="s0">,</span><span class="s3">&quot;closingElement&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;JSX&quot;</span><span class="s0">,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">,</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],fields:{openingElement:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;JSXOpeningElement&quot;</span><span class="s0">)},closingElement:{optional:!</span><span class="s2">0</span><span class="s0">,validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;JSXClosingElement&quot;</span><span class="s0">)},children:{validate:(</span><span class="s2">0</span><span class="s0">,n.chain)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,n.assertEach)((</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;JSXText&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXExpressionContainer&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXSpreadChild&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXElement&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXFragment&quot;</span><span class="s0">)))},selfClosing:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXEmptyExpression&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;JSX&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXExpressionContainer&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;expression&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;JSX&quot;</span><span class="s0">,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">],fields:{expression:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXEmptyExpression&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXSpreadChild&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;expression&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;JSX&quot;</span><span class="s0">,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">],fields:{expression:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;name&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;JSX&quot;</span><span class="s0">],fields:{name:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;object&quot;</span><span class="s0">,</span><span class="s3">&quot;property&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;JSX&quot;</span><span class="s0">],fields:{object:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">)},property:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;namespace&quot;</span><span class="s0">,</span><span class="s3">&quot;name&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;JSX&quot;</span><span class="s0">],fields:{namespace:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">)},name:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXOpeningElement&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;name&quot;</span><span class="s0">,</span><span class="s3">&quot;attributes&quot;</span><span class="s0">,</span><span class="s3">&quot;selfClosing&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;name&quot;</span><span class="s0">,</span><span class="s3">&quot;attributes&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;JSX&quot;</span><span class="s0">,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">],fields:{name:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">)},selfClosing:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">},attributes:{validate:(</span><span class="s2">0</span><span class="s0">,n.chain)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,n.assertEach)((</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;JSXAttribute&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXSpreadAttribute&quot;</span><span class="s0">)))},typeParameters:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">,</span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXSpreadAttribute&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;JSX&quot;</span><span class="s0">],fields:{argument:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXText&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;JSX&quot;</span><span class="s0">,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;value&quot;</span><span class="s0">],fields:{value:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXFragment&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;openingFragment&quot;</span><span class="s0">,</span><span class="s3">&quot;closingFragment&quot;</span><span class="s0">,</span><span class="s3">&quot;children&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;openingFragment&quot;</span><span class="s0">,</span><span class="s3">&quot;children&quot;</span><span class="s0">,</span><span class="s3">&quot;closingFragment&quot;</span><span class="s0">],aliases:[</span><span class="s3">&quot;JSX&quot;</span><span class="s0">,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">,</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],fields:{openingFragment:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;JSXOpeningFragment&quot;</span><span class="s0">)},closingFragment:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;JSXClosingFragment&quot;</span><span class="s0">)},children:{validate:(</span><span class="s2">0</span><span class="s0">,n.chain)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,n.assertEach)((</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;JSXText&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXExpressionContainer&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXSpreadChild&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXElement&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXFragment&quot;</span><span class="s0">)))}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXOpeningFragment&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;JSX&quot;</span><span class="s0">,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">]}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;JSXClosingFragment&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;JSX&quot;</span><span class="s0">,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">]})},</span><span class="s2">511</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">5455</span><span class="s0">),i=r(</span><span class="s2">6820</span><span class="s0">);(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Noop&quot;</span><span class="s0">,{visitor:[]}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">,{visitor:[],builder:[</span><span class="s3">&quot;expectedNode&quot;</span><span class="s0">,</span><span class="s3">&quot;name&quot;</span><span class="s0">],fields:{name:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)},expectedNode:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertOneOf)(...i.PLACEHOLDERS)}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;V8IntrinsicIdentifier&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;name&quot;</span><span class="s0">],fields:{name:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">)}}})},</span><span class="s2">6820</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.PLACEHOLDERS_FLIPPED_ALIAS=t.PLACEHOLDERS_ALIAS=t.PLACEHOLDERS=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">5455</span><span class="s0">);const i=[</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">,</span><span class="s3">&quot;Expression&quot;</span><span class="s0">,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">,</span><span class="s3">&quot;ClassBody&quot;</span><span class="s0">,</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">];t.PLACEHOLDERS=i;const s={Declaration:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">],Pattern:[</span><span class="s3">&quot;PatternLike&quot;</span><span class="s0">,</span><span class="s3">&quot;LVal&quot;</span><span class="s0">]};t.PLACEHOLDERS_ALIAS=s;</span><span class="s1">for</span><span class="s0">(const e of i){const t=n.ALIAS_KEYS[e];</span><span class="s1">null</span><span class="s0">!=t&amp;&amp;t.length&amp;&amp;(s[e]=t)}const a={};t.PLACEHOLDERS_FLIPPED_ALIAS=a,Object.keys(s).forEach((e=&gt;{s[e].forEach((t=&gt;{Object.hasOwnProperty.call(a,t)||(a[t]=[]),a[t].push(e)}))}))},</span><span class="s2">2130</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">5455</span><span class="s0">),i=r(</span><span class="s2">9357</span><span class="s0">);const s=(</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),a={returnType:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;Noop&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},typeParameters:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;TSTypeParameterDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;Noop&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}};(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSParameterProperty&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;LVal&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;parameter&quot;</span><span class="s0">],fields:{accessibility:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertOneOf)(</span><span class="s3">&quot;public&quot;</span><span class="s0">,</span><span class="s3">&quot;private&quot;</span><span class="s0">,</span><span class="s3">&quot;protected&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},readonly:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},parameter:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSDeclareFunction&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;params&quot;</span><span class="s0">,</span><span class="s3">&quot;returnType&quot;</span><span class="s0">],fields:Object.assign({},i.functionDeclarationCommon,a)}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSDeclareMethod&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;decorators&quot;</span><span class="s0">,</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;params&quot;</span><span class="s0">,</span><span class="s3">&quot;returnType&quot;</span><span class="s0">],fields:Object.assign({},i.classMethodOrDeclareMethodCommon,a)}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSQualifiedName&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSEntityName&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;left&quot;</span><span class="s0">,</span><span class="s3">&quot;right&quot;</span><span class="s0">],fields:{left:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSEntityName&quot;</span><span class="s0">),right:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)}});const o={typeParameters:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TSTypeParameterDeclaration&quot;</span><span class="s0">),parameters:(</span><span class="s2">0</span><span class="s0">,n.validateArrayOfType)([</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">]),typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">)},l={aliases:[</span><span class="s3">&quot;TSTypeElement&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;parameters&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],fields:o};(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSCallSignatureDeclaration&quot;</span><span class="s0">,l),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSConstructSignatureDeclaration&quot;</span><span class="s0">,l);const p={key:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">),computed:(</span><span class="s2">0</span><span class="s0">,n.validate)(s),optional:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)(s)};(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSPropertySignature&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSTypeElement&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;initializer&quot;</span><span class="s0">],fields:Object.assign({},p,{readonly:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)(s),typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">),initializer:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)})}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSMethodSignature&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSTypeElement&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;key&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;parameters&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],fields:Object.assign({},o,p,{kind:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertOneOf)(</span><span class="s3">&quot;method&quot;</span><span class="s0">,</span><span class="s3">&quot;get&quot;</span><span class="s0">,</span><span class="s3">&quot;set&quot;</span><span class="s0">)}})}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSIndexSignature&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSTypeElement&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;parameters&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],fields:{readonly:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)(s),static:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)(s),parameters:(</span><span class="s2">0</span><span class="s0">,n.validateArrayOfType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">)}});const c=[</span><span class="s3">&quot;TSAnyKeyword&quot;</span><span class="s0">,</span><span class="s3">&quot;TSBooleanKeyword&quot;</span><span class="s0">,</span><span class="s3">&quot;TSBigIntKeyword&quot;</span><span class="s0">,</span><span class="s3">&quot;TSIntrinsicKeyword&quot;</span><span class="s0">,</span><span class="s3">&quot;TSNeverKeyword&quot;</span><span class="s0">,</span><span class="s3">&quot;TSNullKeyword&quot;</span><span class="s0">,</span><span class="s3">&quot;TSNumberKeyword&quot;</span><span class="s0">,</span><span class="s3">&quot;TSObjectKeyword&quot;</span><span class="s0">,</span><span class="s3">&quot;TSStringKeyword&quot;</span><span class="s0">,</span><span class="s3">&quot;TSSymbolKeyword&quot;</span><span class="s0">,</span><span class="s3">&quot;TSUndefinedKeyword&quot;</span><span class="s0">,</span><span class="s3">&quot;TSUnknownKeyword&quot;</span><span class="s0">,</span><span class="s3">&quot;TSVoidKeyword&quot;</span><span class="s0">];</span><span class="s1">for</span><span class="s0">(const e of c)(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">,</span><span class="s3">&quot;TSBaseType&quot;</span><span class="s0">],visitor:[],fields:{}});(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSThisType&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">,</span><span class="s3">&quot;TSBaseType&quot;</span><span class="s0">],visitor:[],fields:{}});const u={aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;parameters&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">]};(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSFunctionType&quot;</span><span class="s0">,Object.assign({},u,{fields:o})),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSConstructorType&quot;</span><span class="s0">,Object.assign({},u,{fields:Object.assign({},o,{abstract:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)(s)})})),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeReference&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;typeName&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">],fields:{typeName:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSEntityName&quot;</span><span class="s0">),typeParameters:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypePredicate&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;parameterName&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;parameterName&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;asserts&quot;</span><span class="s0">],fields:{parameterName:(</span><span class="s2">0</span><span class="s0">,n.validateType)([</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;TSThisType&quot;</span><span class="s0">]),typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">),asserts:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)(s)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeQuery&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;exprName&quot;</span><span class="s0">],fields:{exprName:(</span><span class="s2">0</span><span class="s0">,n.validateType)([</span><span class="s3">&quot;TSEntityName&quot;</span><span class="s0">,</span><span class="s3">&quot;TSImportType&quot;</span><span class="s0">])}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeLiteral&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;members&quot;</span><span class="s0">],fields:{members:(</span><span class="s2">0</span><span class="s0">,n.validateArrayOfType)(</span><span class="s3">&quot;TSTypeElement&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSArrayType&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;elementType&quot;</span><span class="s0">],fields:{elementType:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTupleType&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;elementTypes&quot;</span><span class="s0">],fields:{elementTypes:(</span><span class="s2">0</span><span class="s0">,n.validateArrayOfType)([</span><span class="s3">&quot;TSType&quot;</span><span class="s0">,</span><span class="s3">&quot;TSNamedTupleMember&quot;</span><span class="s0">])}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSOptionalType&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],fields:{typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSRestType&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],fields:{typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSNamedTupleMember&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;label&quot;</span><span class="s0">,</span><span class="s3">&quot;elementType&quot;</span><span class="s0">],builder:[</span><span class="s3">&quot;label&quot;</span><span class="s0">,</span><span class="s3">&quot;elementType&quot;</span><span class="s0">,</span><span class="s3">&quot;optional&quot;</span><span class="s0">],fields:{label:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),optional:{validate:s,</span><span class="s1">default</span><span class="s0">:!</span><span class="s2">1</span><span class="s0">},elementType:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">)}});const d={aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;types&quot;</span><span class="s0">],fields:{types:(</span><span class="s2">0</span><span class="s0">,n.validateArrayOfType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">)}};(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSUnionType&quot;</span><span class="s0">,d),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSIntersectionType&quot;</span><span class="s0">,d),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSConditionalType&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;checkType&quot;</span><span class="s0">,</span><span class="s3">&quot;extendsType&quot;</span><span class="s0">,</span><span class="s3">&quot;trueType&quot;</span><span class="s0">,</span><span class="s3">&quot;falseType&quot;</span><span class="s0">],fields:{checkType:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">),extendsType:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">),trueType:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">),falseType:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSInferType&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;typeParameter&quot;</span><span class="s0">],fields:{typeParameter:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSTypeParameter&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSParenthesizedType&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],fields:{typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeOperator&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],fields:{operator:(</span><span class="s2">0</span><span class="s0">,n.validate)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">)),typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSIndexedAccessType&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;objectType&quot;</span><span class="s0">,</span><span class="s3">&quot;indexType&quot;</span><span class="s0">],fields:{objectType:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">),indexType:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSMappedType&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;typeParameter&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;nameType&quot;</span><span class="s0">],fields:{readonly:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)(s),typeParameter:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSTypeParameter&quot;</span><span class="s0">),optional:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)(s),typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">),nameType:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSLiteralType&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">,</span><span class="s3">&quot;TSBaseType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;literal&quot;</span><span class="s0">],fields:{literal:(</span><span class="s2">0</span><span class="s0">,n.validateType)([</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">,</span><span class="s3">&quot;BooleanLiteral&quot;</span><span class="s0">,</span><span class="s3">&quot;BigIntLiteral&quot;</span><span class="s0">])}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSExpressionWithTypeArguments&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;expression&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">],fields:{expression:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSEntityName&quot;</span><span class="s0">),typeParameters:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSInterfaceDeclaration&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;extends&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],fields:{declare:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)(s),id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),typeParameters:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TSTypeParameterDeclaration&quot;</span><span class="s0">),extends:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)((</span><span class="s2">0</span><span class="s0">,n.arrayOfType)(</span><span class="s3">&quot;TSExpressionWithTypeArguments&quot;</span><span class="s0">)),body:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSInterfaceBody&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSInterfaceBody&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;body&quot;</span><span class="s0">],fields:{body:(</span><span class="s2">0</span><span class="s0">,n.validateArrayOfType)(</span><span class="s3">&quot;TSTypeElement&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeAliasDeclaration&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],fields:{declare:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)(s),id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),typeParameters:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TSTypeParameterDeclaration&quot;</span><span class="s0">),typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSAsExpression&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;expression&quot;</span><span class="s0">,</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],fields:{expression:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">),typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeAssertion&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">,</span><span class="s3">&quot;expression&quot;</span><span class="s0">],fields:{typeAnnotation:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">),expression:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSEnumDeclaration&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;members&quot;</span><span class="s0">],fields:{declare:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)(s),const:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)(s),id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),members:(</span><span class="s2">0</span><span class="s0">,n.validateArrayOfType)(</span><span class="s3">&quot;TSEnumMember&quot;</span><span class="s0">),initializer:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSEnumMember&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;initializer&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)([</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">]),initializer:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSModuleDeclaration&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;body&quot;</span><span class="s0">],fields:{declare:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)(s),global:(</span><span class="s2">0</span><span class="s0">,n.validateOptional)(s),id:(</span><span class="s2">0</span><span class="s0">,n.validateType)([</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">]),body:(</span><span class="s2">0</span><span class="s0">,n.validateType)([</span><span class="s3">&quot;TSModuleBlock&quot;</span><span class="s0">,</span><span class="s3">&quot;TSModuleDeclaration&quot;</span><span class="s0">])}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSModuleBlock&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;Block&quot;</span><span class="s0">,</span><span class="s3">&quot;BlockParent&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;body&quot;</span><span class="s0">],fields:{body:(</span><span class="s2">0</span><span class="s0">,n.validateArrayOfType)(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSImportType&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;TSType&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">,</span><span class="s3">&quot;qualifier&quot;</span><span class="s0">,</span><span class="s3">&quot;typeParameters&quot;</span><span class="s0">],fields:{argument:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">),qualifier:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TSEntityName&quot;</span><span class="s0">),typeParameters:(</span><span class="s2">0</span><span class="s0">,n.validateOptionalType)(</span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSImportEqualsDeclaration&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;moduleReference&quot;</span><span class="s0">],fields:{isExport:(</span><span class="s2">0</span><span class="s0">,n.validate)(s),id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),moduleReference:(</span><span class="s2">0</span><span class="s0">,n.validateType)([</span><span class="s3">&quot;TSEntityName&quot;</span><span class="s0">,</span><span class="s3">&quot;TSExternalModuleReference&quot;</span><span class="s0">])}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSExternalModuleReference&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;expression&quot;</span><span class="s0">],fields:{expression:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSNonNullExpression&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;expression&quot;</span><span class="s0">],fields:{expression:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSExportAssignment&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;expression&quot;</span><span class="s0">],fields:{expression:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSNamespaceExportDeclaration&quot;</span><span class="s0">,{aliases:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],fields:{id:(</span><span class="s2">0</span><span class="s0">,n.validateType)(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;typeAnnotation&quot;</span><span class="s0">],fields:{typeAnnotation:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">)}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;params&quot;</span><span class="s0">],fields:{params:{validate:(</span><span class="s2">0</span><span class="s0">,n.chain)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,n.assertEach)((</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">)))}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeParameterDeclaration&quot;</span><span class="s0">,{visitor:[</span><span class="s3">&quot;params&quot;</span><span class="s0">],fields:{params:{validate:(</span><span class="s2">0</span><span class="s0">,n.chain)((</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;array&quot;</span><span class="s0">),(</span><span class="s2">0</span><span class="s0">,n.assertEach)((</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;TSTypeParameter&quot;</span><span class="s0">)))}}}),(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;TSTypeParameter&quot;</span><span class="s0">,{builder:[</span><span class="s3">&quot;constraint&quot;</span><span class="s0">,</span><span class="s3">&quot;default&quot;</span><span class="s0">,</span><span class="s3">&quot;name&quot;</span><span class="s0">],visitor:[</span><span class="s3">&quot;constraint&quot;</span><span class="s0">,</span><span class="s3">&quot;default&quot;</span><span class="s0">],fields:{name:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertValueType)(</span><span class="s3">&quot;string&quot;</span><span class="s0">)},constraint:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">},</span><span class="s1">default</span><span class="s0">:{validate:(</span><span class="s2">0</span><span class="s0">,n.assertNodeType)(</span><span class="s3">&quot;TSType&quot;</span><span class="s0">),optional:!</span><span class="s2">0</span><span class="s0">}}})},</span><span class="s2">5455</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">397</span><span class="s0">);Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.validate=f,t.typeIs=m,t.validateType=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">f(m(e))},t.validateOptional=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">{validate:e,optional:!</span><span class="s2">0</span><span class="s0">}},t.validateOptionalType=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">{validate:m(e),optional:!</span><span class="s2">0</span><span class="s0">}},t.arrayOf=y,t.arrayOfType=T,t.validateArrayOfType=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">f(T(e))},t.assertEach=b,t.assertOneOf=</span><span class="s1">function</span><span class="s0">(...e){</span><span class="s1">function </span><span class="s0">t(t,r,n){</span><span class="s1">if</span><span class="s0">(e.indexOf(n)&lt;</span><span class="s2">0</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">TypeError(`Property ${r} expected value to be one of ${JSON.stringify(e)} but got ${JSON.stringify(n)}`)}</span><span class="s1">return </span><span class="s0">t.oneOf=e,t},t.assertNodeType=g,t.assertNodeOrValueType=</span><span class="s1">function</span><span class="s0">(...e){</span><span class="s1">function </span><span class="s0">t(t,r,n){</span><span class="s1">for</span><span class="s0">(const a of e)</span><span class="s1">if</span><span class="s0">(h(n)===a||(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(a,n))</span><span class="s1">return void</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,s.validateChild)(t,r,n);</span><span class="s1">throw new </span><span class="s0">TypeError(`Property ${r} of ${t.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(</span><span class="s1">null</span><span class="s0">==n?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:n.type)}`)}</span><span class="s1">return </span><span class="s0">t.oneOfNodeOrValueTypes=e,t},t.assertValueType=S,t.assertShape=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">function </span><span class="s0">t(t,r,n){const i=[];</span><span class="s1">for</span><span class="s0">(const r of Object.keys(e))</span><span class="s1">try</span><span class="s0">{(</span><span class="s2">0</span><span class="s0">,s.validateField)(t,r,n[r],e[r])}</span><span class="s1">catch</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e </span><span class="s1">instanceof </span><span class="s0">TypeError){i.push(e.message);</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">throw </span><span class="s0">e}</span><span class="s1">if</span><span class="s0">(i.length)</span><span class="s1">throw new </span><span class="s0">TypeError(`Property ${r} of ${t.type} expected to have the following:\n${i.join(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">)}`)}</span><span class="s1">return </span><span class="s0">t.shapeOf=e,t},t.assertOptionalChainStart=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return function</span><span class="s0">(e){</span><span class="s1">var </span><span class="s0">t;let r=e;</span><span class="s1">for</span><span class="s0">(;e;){const{type:e}=r;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;OptionalCallExpression&quot;</span><span class="s0">!==e){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">!==e)</span><span class="s1">break</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(r.optional)</span><span class="s1">return</span><span class="s0">;r=r.object}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(r.optional)</span><span class="s1">return</span><span class="s0">;r=r.callee}}</span><span class="s1">throw new </span><span class="s0">TypeError(`Non-optional ${e.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${</span><span class="s1">null</span><span class="s0">==(t=r)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.type}`)}},t.chain=x,t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t={}){const r=t.inherits&amp;&amp;v[t.inherits]||{};let n=t.fields;</span><span class="s1">if</span><span class="s0">(!n&amp;&amp;(n={},r.fields)){const e=Object.getOwnPropertyNames(r.fields);</span><span class="s1">for</span><span class="s0">(const t of e){const e=r.fields[t],i=e.</span><span class="s1">default</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(Array.isArray(i)?i.length&gt;</span><span class="s2">0</span><span class="s0">:i&amp;&amp;</span><span class="s3">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">i)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;field defaults can only be primitives or empty arrays currently&quot;</span><span class="s0">);n[t]={</span><span class="s1">default</span><span class="s0">:Array.isArray(i)?[]:i,optional:e.optional,validate:e.validate}}}const i=t.visitor||r.visitor||[],s=t.aliases||r.aliases||[],f=t.builder||r.builder||t.visitor||[];</span><span class="s1">for</span><span class="s0">(const r of Object.keys(t))</span><span class="s1">if</span><span class="s0">(-</span><span class="s2">1</span><span class="s0">===E.indexOf(r))</span><span class="s1">throw new </span><span class="s0">Error(`Unknown type option </span><span class="s3">&quot;${r}&quot; </span><span class="s0">on ${e}`);t.deprecatedAlias&amp;&amp;(u[t.deprecatedAlias]=e);</span><span class="s1">for</span><span class="s0">(const e of i.concat(f))n[e]=n[e]||{};</span><span class="s1">for</span><span class="s0">(const t of Object.keys(n)){const r=n[t];</span><span class="s1">void </span><span class="s2">0</span><span class="s0">!==r.</span><span class="s1">default</span><span class="s0">&amp;&amp;-</span><span class="s2">1</span><span class="s0">===f.indexOf(t)&amp;&amp;(r.optional=!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===r.</span><span class="s1">default</span><span class="s0">?r.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">null</span><span class="s0">:r.validate||</span><span class="s1">null</span><span class="s0">==r.</span><span class="s1">default</span><span class="s0">||(r.validate=S(h(r.</span><span class="s1">default</span><span class="s0">)));</span><span class="s1">for</span><span class="s0">(const n of Object.keys(r))</span><span class="s1">if</span><span class="s0">(-</span><span class="s2">1</span><span class="s0">===P.indexOf(n))</span><span class="s1">throw new </span><span class="s0">Error(`Unknown field key </span><span class="s3">&quot;${n}&quot; </span><span class="s0">on ${e}.${t}`)}a[e]=t.visitor=i,c[e]=t.builder=f,p[e]=t.fields=n,o[e]=t.aliases=s,s.forEach((t=&gt;{l[t]=l[t]||[],l[t].push(e)})),t.validate&amp;&amp;(d[e]=t.validate),v[e]=t},t.NODE_PARENT_VALIDATIONS=t.DEPRECATED_KEYS=t.BUILDER_KEYS=t.NODE_FIELDS=t.FLIPPED_ALIAS_KEYS=t.ALIAS_KEYS=t.VISITOR_KEYS=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">i=r(</span><span class="s2">5001</span><span class="s0">),s=r(</span><span class="s2">1843</span><span class="s0">);const a={};t.VISITOR_KEYS=a;const o={};t.ALIAS_KEYS=o;const l={};t.FLIPPED_ALIAS_KEYS=l;const p={};t.NODE_FIELDS=p;const c={};t.BUILDER_KEYS=c;const u={};t.DEPRECATED_KEYS=u;const d={};</span><span class="s1">function </span><span class="s0">h(e){</span><span class="s1">return </span><span class="s0">Array.isArray(e)?</span><span class="s3">&quot;array&quot;</span><span class="s0">:</span><span class="s1">null</span><span class="s0">===e?</span><span class="s3">&quot;null&quot;</span><span class="s0">:</span><span class="s1">typeof </span><span class="s0">e}</span><span class="s1">function </span><span class="s0">f(e){</span><span class="s1">return</span><span class="s0">{validate:e}}</span><span class="s1">function </span><span class="s0">m(e){</span><span class="s1">return</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e?g(e):g(...e)}</span><span class="s1">function </span><span class="s0">y(e){</span><span class="s1">return </span><span class="s0">x(S(</span><span class="s3">&quot;array&quot;</span><span class="s0">),b(e))}</span><span class="s1">function </span><span class="s0">T(e){</span><span class="s1">return </span><span class="s0">y(m(e))}</span><span class="s1">function </span><span class="s0">b(e){</span><span class="s1">function </span><span class="s0">t(t,r,i){</span><span class="s1">if</span><span class="s0">(Array.isArray(i))</span><span class="s1">for</span><span class="s0">(let a=</span><span class="s2">0</span><span class="s0">;a&lt;i.length;a++){const o=`${r}[${a}]`,l=i[a];e(t,o,l),n.env.BABEL_TYPES_8_BREAKING&amp;&amp;(</span><span class="s2">0</span><span class="s0">,s.validateChild)(t,o,l)}}</span><span class="s1">return </span><span class="s0">t.each=e,t}</span><span class="s1">function </span><span class="s0">g(...e){</span><span class="s1">function </span><span class="s0">t(t,r,n){</span><span class="s1">for</span><span class="s0">(const a of e)</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(a,n))</span><span class="s1">return void</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,s.validateChild)(t,r,n);</span><span class="s1">throw new </span><span class="s0">TypeError(`Property ${r} of ${t.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(</span><span class="s1">null</span><span class="s0">==n?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:n.type)}`)}</span><span class="s1">return </span><span class="s0">t.oneOfNodeTypes=e,t}</span><span class="s1">function </span><span class="s0">S(e){</span><span class="s1">function </span><span class="s0">t(t,r,n){</span><span class="s1">if</span><span class="s0">(h(n)!==e)</span><span class="s1">throw new </span><span class="s0">TypeError(`Property ${r} expected type of ${e} but got ${h(n)}`)}</span><span class="s1">return </span><span class="s0">t.type=e,t}</span><span class="s1">function </span><span class="s0">x(...e){</span><span class="s1">function </span><span class="s0">t(...t){</span><span class="s1">for</span><span class="s0">(const r of e)r(...t)}</span><span class="s1">if</span><span class="s0">(t.chainOf=e,e.length&gt;=</span><span class="s2">2</span><span class="s0">&amp;&amp;</span><span class="s3">&quot;type&quot;</span><span class="s1">in </span><span class="s0">e[</span><span class="s2">0</span><span class="s0">]&amp;&amp;</span><span class="s3">&quot;array&quot;</span><span class="s0">===e[</span><span class="s2">0</span><span class="s0">].type&amp;&amp;!(</span><span class="s3">&quot;each&quot;</span><span class="s1">in </span><span class="s0">e[</span><span class="s2">1</span><span class="s0">]))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'An assertValueType(&quot;array&quot;) validator can only be followed by an assertEach(...) validator.'</span><span class="s0">);</span><span class="s1">return </span><span class="s0">t}t.NODE_PARENT_VALIDATIONS=d;const E=[</span><span class="s3">&quot;aliases&quot;</span><span class="s0">,</span><span class="s3">&quot;builder&quot;</span><span class="s0">,</span><span class="s3">&quot;deprecatedAlias&quot;</span><span class="s0">,</span><span class="s3">&quot;fields&quot;</span><span class="s0">,</span><span class="s3">&quot;inherits&quot;</span><span class="s0">,</span><span class="s3">&quot;visitor&quot;</span><span class="s0">,</span><span class="s3">&quot;validate&quot;</span><span class="s0">],P=[</span><span class="s3">&quot;default&quot;</span><span class="s0">,</span><span class="s3">&quot;optional&quot;</span><span class="s0">,</span><span class="s3">&quot;validate&quot;</span><span class="s0">],v={}},</span><span class="s2">17</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">});</span><span class="s1">var </span><span class="s0">n={react:!</span><span class="s2">0</span><span class="s0">,assertNode:!</span><span class="s2">0</span><span class="s0">,createTypeAnnotationBasedOnTypeof:!</span><span class="s2">0</span><span class="s0">,createUnionTypeAnnotation:!</span><span class="s2">0</span><span class="s0">,createFlowUnionType:!</span><span class="s2">0</span><span class="s0">,createTSUnionType:!</span><span class="s2">0</span><span class="s0">,cloneNode:!</span><span class="s2">0</span><span class="s0">,clone:!</span><span class="s2">0</span><span class="s0">,cloneDeep:!</span><span class="s2">0</span><span class="s0">,cloneDeepWithoutLoc:!</span><span class="s2">0</span><span class="s0">,cloneWithoutLoc:!</span><span class="s2">0</span><span class="s0">,addComment:!</span><span class="s2">0</span><span class="s0">,addComments:!</span><span class="s2">0</span><span class="s0">,inheritInnerComments:!</span><span class="s2">0</span><span class="s0">,inheritLeadingComments:!</span><span class="s2">0</span><span class="s0">,inheritsComments:!</span><span class="s2">0</span><span class="s0">,inheritTrailingComments:!</span><span class="s2">0</span><span class="s0">,removeComments:!</span><span class="s2">0</span><span class="s0">,ensureBlock:!</span><span class="s2">0</span><span class="s0">,toBindingIdentifierName:!</span><span class="s2">0</span><span class="s0">,toBlock:!</span><span class="s2">0</span><span class="s0">,toComputedKey:!</span><span class="s2">0</span><span class="s0">,toExpression:!</span><span class="s2">0</span><span class="s0">,toIdentifier:!</span><span class="s2">0</span><span class="s0">,toKeyAlias:!</span><span class="s2">0</span><span class="s0">,toSequenceExpression:!</span><span class="s2">0</span><span class="s0">,toStatement:!</span><span class="s2">0</span><span class="s0">,valueToNode:!</span><span class="s2">0</span><span class="s0">,appendToMemberExpression:!</span><span class="s2">0</span><span class="s0">,inherits:!</span><span class="s2">0</span><span class="s0">,prependToMemberExpression:!</span><span class="s2">0</span><span class="s0">,removeProperties:!</span><span class="s2">0</span><span class="s0">,removePropertiesDeep:!</span><span class="s2">0</span><span class="s0">,removeTypeDuplicates:!</span><span class="s2">0</span><span class="s0">,getBindingIdentifiers:!</span><span class="s2">0</span><span class="s0">,getOuterBindingIdentifiers:!</span><span class="s2">0</span><span class="s0">,traverse:!</span><span class="s2">0</span><span class="s0">,traverseFast:!</span><span class="s2">0</span><span class="s0">,shallowEqual:!</span><span class="s2">0</span><span class="s0">,is:!</span><span class="s2">0</span><span class="s0">,isBinding:!</span><span class="s2">0</span><span class="s0">,isBlockScoped:!</span><span class="s2">0</span><span class="s0">,isImmutable:!</span><span class="s2">0</span><span class="s0">,isLet:!</span><span class="s2">0</span><span class="s0">,isNode:!</span><span class="s2">0</span><span class="s0">,isNodesEquivalent:!</span><span class="s2">0</span><span class="s0">,isPlaceholderType:!</span><span class="s2">0</span><span class="s0">,isReferenced:!</span><span class="s2">0</span><span class="s0">,isScope:!</span><span class="s2">0</span><span class="s0">,isSpecifierDefault:!</span><span class="s2">0</span><span class="s0">,isType:!</span><span class="s2">0</span><span class="s0">,isValidES3Identifier:!</span><span class="s2">0</span><span class="s0">,isValidIdentifier:!</span><span class="s2">0</span><span class="s0">,isVar:!</span><span class="s2">0</span><span class="s0">,matchesPattern:!</span><span class="s2">0</span><span class="s0">,validate:!</span><span class="s2">0</span><span class="s0">,buildMatchMemberExpression:!</span><span class="s2">0</span><span class="s0">};Object.defineProperty(t,</span><span class="s3">&quot;assertNode&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">o.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;createTypeAnnotationBasedOnTypeof&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">p.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;createUnionTypeAnnotation&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">c.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;createFlowUnionType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">c.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;createTSUnionType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">u.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;cloneNode&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">f.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;clone&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">m.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;cloneDeep&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">y.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;cloneDeepWithoutLoc&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">T.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;cloneWithoutLoc&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">b.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;addComment&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">g.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;addComments&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">S.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;inheritInnerComments&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">x.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;inheritLeadingComments&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">E.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;inheritsComments&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">P.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;inheritTrailingComments&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">v.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;removeComments&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">A.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;ensureBlock&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">I.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;toBindingIdentifierName&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">N.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;toBlock&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">C.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;toComputedKey&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">k.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;toExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">D.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;toIdentifier&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">_.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;toKeyAlias&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">L.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;toSequenceExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">M.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;toStatement&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">j.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;valueToNode&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">F.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;appendToMemberExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">R.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;inherits&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">U.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;prependToMemberExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">V.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;removeProperties&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">K.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;removePropertiesDeep&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">q.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;removeTypeDuplicates&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">Y.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;getBindingIdentifiers&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">W.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;getOuterBindingIdentifiers&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">X.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;traverse&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">J.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;traverseFast&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">H.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;shallowEqual&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">G.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;is&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">z.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;isBinding&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">$.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;isBlockScoped&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">Q.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;isImmutable&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">Z.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;isLet&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">ee.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;isNode&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">te.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;isNodesEquivalent&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">re.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;isPlaceholderType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">ne.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;isReferenced&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">ie.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;isScope&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">se.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;isSpecifierDefault&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">ae.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;isType&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">oe.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;isValidES3Identifier&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">le.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;isValidIdentifier&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">pe.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;isVar&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">ce.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;matchesPattern&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">ue.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;validate&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">de.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;buildMatchMemberExpression&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">he.</span><span class="s1">default</span><span class="s0">}}),t.react=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">i=r(</span><span class="s2">1934</span><span class="s0">),s=r(</span><span class="s2">5582</span><span class="s0">),a=r(</span><span class="s2">478</span><span class="s0">),o=r(</span><span class="s2">9278</span><span class="s0">),l=r(</span><span class="s2">2937</span><span class="s0">);Object.keys(l).forEach((</span><span class="s1">function</span><span class="s0">(e){</span><span class="s3">&quot;default&quot;</span><span class="s0">!==e&amp;&amp;</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">!==e&amp;&amp;(Object.prototype.hasOwnProperty.call(n,e)||e </span><span class="s1">in </span><span class="s0">t&amp;&amp;t[e]===l[e]||Object.defineProperty(t,e,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">l[e]}}))}));</span><span class="s1">var </span><span class="s0">p=r(</span><span class="s2">7395</span><span class="s0">),c=r(</span><span class="s2">4660</span><span class="s0">),u=r(</span><span class="s2">6998</span><span class="s0">),d=r(</span><span class="s2">1580</span><span class="s0">);Object.keys(d).forEach((</span><span class="s1">function</span><span class="s0">(e){</span><span class="s3">&quot;default&quot;</span><span class="s0">!==e&amp;&amp;</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">!==e&amp;&amp;(Object.prototype.hasOwnProperty.call(n,e)||e </span><span class="s1">in </span><span class="s0">t&amp;&amp;t[e]===d[e]||Object.defineProperty(t,e,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">d[e]}}))}));</span><span class="s1">var </span><span class="s0">h=r(</span><span class="s2">6306</span><span class="s0">);Object.keys(h).forEach((</span><span class="s1">function</span><span class="s0">(e){</span><span class="s3">&quot;default&quot;</span><span class="s0">!==e&amp;&amp;</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">!==e&amp;&amp;(Object.prototype.hasOwnProperty.call(n,e)||e </span><span class="s1">in </span><span class="s0">t&amp;&amp;t[e]===h[e]||Object.defineProperty(t,e,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">h[e]}}))}));</span><span class="s1">var </span><span class="s0">f=r(</span><span class="s2">5833</span><span class="s0">),m=r(</span><span class="s2">7307</span><span class="s0">),y=r(</span><span class="s2">175</span><span class="s0">),T=r(</span><span class="s2">4982</span><span class="s0">),b=r(</span><span class="s2">8743</span><span class="s0">),g=r(</span><span class="s2">6517</span><span class="s0">),S=r(</span><span class="s2">8290</span><span class="s0">),x=r(</span><span class="s2">8267</span><span class="s0">),E=r(</span><span class="s2">4510</span><span class="s0">),P=r(</span><span class="s2">5644</span><span class="s0">),v=r(</span><span class="s2">5042</span><span class="s0">),A=r(</span><span class="s2">6528</span><span class="s0">),w=r(</span><span class="s2">55</span><span class="s0">);Object.keys(w).forEach((</span><span class="s1">function</span><span class="s0">(e){</span><span class="s3">&quot;default&quot;</span><span class="s0">!==e&amp;&amp;</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">!==e&amp;&amp;(Object.prototype.hasOwnProperty.call(n,e)||e </span><span class="s1">in </span><span class="s0">t&amp;&amp;t[e]===w[e]||Object.defineProperty(t,e,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">w[e]}}))}));</span><span class="s1">var </span><span class="s0">O=r(</span><span class="s2">2770</span><span class="s0">);Object.keys(O).forEach((</span><span class="s1">function</span><span class="s0">(e){</span><span class="s3">&quot;default&quot;</span><span class="s0">!==e&amp;&amp;</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">!==e&amp;&amp;(Object.prototype.hasOwnProperty.call(n,e)||e </span><span class="s1">in </span><span class="s0">t&amp;&amp;t[e]===O[e]||Object.defineProperty(t,e,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">O[e]}}))}));</span><span class="s1">var </span><span class="s0">I=r(</span><span class="s2">9176</span><span class="s0">),N=r(</span><span class="s2">7919</span><span class="s0">),C=r(</span><span class="s2">2860</span><span class="s0">),k=r(</span><span class="s2">6</span><span class="s0">e3),D=r(</span><span class="s2">836</span><span class="s0">),_=r(</span><span class="s2">7718</span><span class="s0">),L=r(</span><span class="s2">3240</span><span class="s0">),M=r(</span><span class="s2">4868</span><span class="s0">),j=r(</span><span class="s2">874</span><span class="s0">),F=r(</span><span class="s2">1799</span><span class="s0">),B=r(</span><span class="s2">1102</span><span class="s0">);Object.keys(B).forEach((</span><span class="s1">function</span><span class="s0">(e){</span><span class="s3">&quot;default&quot;</span><span class="s0">!==e&amp;&amp;</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">!==e&amp;&amp;(Object.prototype.hasOwnProperty.call(n,e)||e </span><span class="s1">in </span><span class="s0">t&amp;&amp;t[e]===B[e]||Object.defineProperty(t,e,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">B[e]}}))}));</span><span class="s1">var </span><span class="s0">R=r(</span><span class="s2">9350</span><span class="s0">),U=r(</span><span class="s2">4758</span><span class="s0">),V=r(</span><span class="s2">1195</span><span class="s0">),K=r(</span><span class="s2">2252</span><span class="s0">),q=r(</span><span class="s2">2271</span><span class="s0">),Y=r(</span><span class="s2">6337</span><span class="s0">),W=r(</span><span class="s2">5337</span><span class="s0">),X=r(</span><span class="s2">210</span><span class="s0">),J=r(</span><span class="s2">9220</span><span class="s0">);Object.keys(J).forEach((</span><span class="s1">function</span><span class="s0">(e){</span><span class="s3">&quot;default&quot;</span><span class="s0">!==e&amp;&amp;</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">!==e&amp;&amp;(Object.prototype.hasOwnProperty.call(n,e)||e </span><span class="s1">in </span><span class="s0">t&amp;&amp;t[e]===J[e]||Object.defineProperty(t,e,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">J[e]}}))}));</span><span class="s1">var </span><span class="s0">H=r(</span><span class="s2">2829</span><span class="s0">),G=r(</span><span class="s2">4729</span><span class="s0">),z=r(</span><span class="s2">5001</span><span class="s0">),$=r(</span><span class="s2">48</span><span class="s0">),Q=r(</span><span class="s2">7199</span><span class="s0">),Z=r(</span><span class="s2">3261</span><span class="s0">),ee=r(</span><span class="s2">100</span><span class="s0">),te=r(</span><span class="s2">1860</span><span class="s0">),re=r(</span><span class="s2">7190</span><span class="s0">),ne=r(</span><span class="s2">549</span><span class="s0">),ie=r(</span><span class="s2">2954</span><span class="s0">),se=r(</span><span class="s2">5969</span><span class="s0">),ae=r(</span><span class="s2">1422</span><span class="s0">),oe=r(</span><span class="s2">4263</span><span class="s0">),le=r(</span><span class="s2">3902</span><span class="s0">),pe=r(</span><span class="s2">6335</span><span class="s0">),ce=r(</span><span class="s2">7117</span><span class="s0">),ue=r(</span><span class="s2">4185</span><span class="s0">),de=r(</span><span class="s2">1843</span><span class="s0">),he=r(</span><span class="s2">3427</span><span class="s0">),fe=r(</span><span class="s2">3924</span><span class="s0">);Object.keys(fe).forEach((</span><span class="s1">function</span><span class="s0">(e){</span><span class="s3">&quot;default&quot;</span><span class="s0">!==e&amp;&amp;</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">!==e&amp;&amp;(Object.prototype.hasOwnProperty.call(n,e)||e </span><span class="s1">in </span><span class="s0">t&amp;&amp;t[e]===fe[e]||Object.defineProperty(t,e,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">fe[e]}}))}));</span><span class="s1">var </span><span class="s0">me=r(</span><span class="s2">2006</span><span class="s0">);Object.keys(me).forEach((</span><span class="s1">function</span><span class="s0">(e){</span><span class="s3">&quot;default&quot;</span><span class="s0">!==e&amp;&amp;</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">!==e&amp;&amp;(Object.prototype.hasOwnProperty.call(n,e)||e </span><span class="s1">in </span><span class="s0">t&amp;&amp;t[e]===me[e]||Object.defineProperty(t,e,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">me[e]}}))}));const ye={isReactComponent:i.</span><span class="s1">default</span><span class="s0">,isCompatTag:s.</span><span class="s1">default</span><span class="s0">,buildChildren:a.</span><span class="s1">default</span><span class="s0">};t.react=ye},</span><span class="s2">9350</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t,r=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">return </span><span class="s0">e.object=(</span><span class="s2">0</span><span class="s0">,n.memberExpression)(e.object,e.property,e.computed),e.property=t,e.computed=!!r,e};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1580</span><span class="s0">)},</span><span class="s2">6337</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function </span><span class="s0">e(t){const r={},s={},a=[],o=[];</span><span class="s1">for</span><span class="s0">(let l=</span><span class="s2">0</span><span class="s0">;l&lt;t.length;l++){const p=t[l];</span><span class="s1">if</span><span class="s0">(p&amp;&amp;!(o.indexOf(p)&gt;=</span><span class="s2">0</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isAnyTypeAnnotation)(p))</span><span class="s1">return</span><span class="s0">[p];</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isFlowBaseAnnotation)(p))s[p.type]=p;</span><span class="s1">else if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isUnionTypeAnnotation)(p))a.indexOf(p.types)&lt;</span><span class="s2">0</span><span class="s0">&amp;&amp;(t=t.concat(p.types),a.push(p.types));</span><span class="s1">else if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isGenericTypeAnnotation)(p)){const t=i(p.id);</span><span class="s1">if</span><span class="s0">(r[t]){let n=r[t];n.typeParameters?p.typeParameters&amp;&amp;(n.typeParameters.params=e(n.typeParameters.params.concat(p.typeParameters.params))):n=p.typeParameters}</span><span class="s1">else </span><span class="s0">r[t]=p}</span><span class="s1">else </span><span class="s0">o.push(p)}}</span><span class="s1">for</span><span class="s0">(const e of Object.keys(s))o.push(s[e]);</span><span class="s1">for</span><span class="s0">(const e of Object.keys(r))o.push(r[e]);</span><span class="s1">return </span><span class="s0">o};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3924</span><span class="s0">);</span><span class="s1">function </span><span class="s0">i(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.isIdentifier)(e)?e.name:`${e.id.name}.${i(e.qualification)}`}},</span><span class="s2">4758</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e||!t)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">for</span><span class="s0">(const r of n.INHERIT_KEYS.optional)</span><span class="s1">null</span><span class="s0">==e[r]&amp;&amp;(e[r]=t[r]);</span><span class="s1">for</span><span class="s0">(const r of Object.keys(t))</span><span class="s3">&quot;_&quot;</span><span class="s0">===r[</span><span class="s2">0</span><span class="s0">]&amp;&amp;</span><span class="s3">&quot;__clone&quot;</span><span class="s0">!==r&amp;&amp;(e[r]=t[r]);</span><span class="s1">for</span><span class="s0">(const r of n.INHERIT_KEYS.force)e[r]=t[r];</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(e,t),e};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">2770</span><span class="s0">),i=r(</span><span class="s2">5644</span><span class="s0">)},</span><span class="s2">1195</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">e.object=(</span><span class="s2">0</span><span class="s0">,n.memberExpression)(t,e.object),e};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1580</span><span class="s0">)},</span><span class="s2">2252</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t={}){const r=t.preserveComments?i:s;</span><span class="s1">for</span><span class="s0">(const t of r)</span><span class="s1">null</span><span class="s0">!=e[t]&amp;&amp;(e[t]=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const t of Object.keys(e))</span><span class="s3">&quot;_&quot;</span><span class="s0">===t[</span><span class="s2">0</span><span class="s0">]&amp;&amp;</span><span class="s1">null</span><span class="s0">!=e[t]&amp;&amp;(e[t]=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">);const n=Object.getOwnPropertySymbols(e);</span><span class="s1">for</span><span class="s0">(const t of n)e[t]=</span><span class="s1">null</span><span class="s0">};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">2770</span><span class="s0">);const i=[</span><span class="s3">&quot;tokens&quot;</span><span class="s0">,</span><span class="s3">&quot;start&quot;</span><span class="s0">,</span><span class="s3">&quot;end&quot;</span><span class="s0">,</span><span class="s3">&quot;loc&quot;</span><span class="s0">,</span><span class="s3">&quot;raw&quot;</span><span class="s0">,</span><span class="s3">&quot;rawValue&quot;</span><span class="s0">],s=n.COMMENT_KEYS.concat([</span><span class="s3">&quot;comments&quot;</span><span class="s0">]).concat(i)},</span><span class="s2">2271</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,i.</span><span class="s1">default</span><span class="s0">,t),e};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">2829</span><span class="s0">),i=r(</span><span class="s2">2252</span><span class="s0">)},</span><span class="s2">7921</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){const t={},r={},i=[],s=[];</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">;t&lt;e.length;t++){const a=e[t];</span><span class="s1">if</span><span class="s0">(a&amp;&amp;!(s.indexOf(a)&gt;=</span><span class="s2">0</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isTSAnyKeyword)(a))</span><span class="s1">return</span><span class="s0">[a];(</span><span class="s2">0</span><span class="s0">,n.isTSBaseType)(a)?r[a.type]=a:(</span><span class="s2">0</span><span class="s0">,n.isTSUnionType)(a)?i.indexOf(a.types)&lt;</span><span class="s2">0</span><span class="s0">&amp;&amp;(e=e.concat(a.types),i.push(a.types)):s.push(a)}}</span><span class="s1">for</span><span class="s0">(const e of Object.keys(r))s.push(r[e]);</span><span class="s1">for</span><span class="s0">(const e of Object.keys(t))s.push(t[e]);</span><span class="s1">return </span><span class="s0">s};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3924</span><span class="s0">)},</span><span class="s2">5337</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=i;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3924</span><span class="s0">);</span><span class="s1">function </span><span class="s0">i(e,t,r){let s=[].concat(e);const a=Object.create(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(;s.length;){const e=s.shift();</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">continue</span><span class="s0">;const o=i.keys[e.type];</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isIdentifier)(e))t?(a[e.name]=a[e.name]||[]).push(e):a[e.name]=e;</span><span class="s1">else if</span><span class="s0">(!(</span><span class="s2">0</span><span class="s0">,n.isExportDeclaration)(e)||(</span><span class="s2">0</span><span class="s0">,n.isExportAllDeclaration)(e)){</span><span class="s1">if</span><span class="s0">(r){</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isFunctionDeclaration)(e)){s.push(e.id);</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isFunctionExpression)(e))</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(o)</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">;t&lt;o.length;t++){const r=o[t];e[r]&amp;&amp;(s=s.concat(e[r]))}}</span><span class="s1">else</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.isDeclaration)(e.declaration)&amp;&amp;s.push(e.declaration)}</span><span class="s1">return </span><span class="s0">a}i.keys={DeclareClass:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],DeclareFunction:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],DeclareModule:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],DeclareVariable:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],DeclareInterface:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],DeclareTypeAlias:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],DeclareOpaqueType:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],InterfaceDeclaration:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],TypeAlias:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],OpaqueType:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],CatchClause:[</span><span class="s3">&quot;param&quot;</span><span class="s0">],LabeledStatement:[</span><span class="s3">&quot;label&quot;</span><span class="s0">],UnaryExpression:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">],AssignmentExpression:[</span><span class="s3">&quot;left&quot;</span><span class="s0">],ImportSpecifier:[</span><span class="s3">&quot;local&quot;</span><span class="s0">],ImportNamespaceSpecifier:[</span><span class="s3">&quot;local&quot;</span><span class="s0">],ImportDefaultSpecifier:[</span><span class="s3">&quot;local&quot;</span><span class="s0">],ImportDeclaration:[</span><span class="s3">&quot;specifiers&quot;</span><span class="s0">],ExportSpecifier:[</span><span class="s3">&quot;exported&quot;</span><span class="s0">],ExportNamespaceSpecifier:[</span><span class="s3">&quot;exported&quot;</span><span class="s0">],ExportDefaultSpecifier:[</span><span class="s3">&quot;exported&quot;</span><span class="s0">],FunctionDeclaration:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;params&quot;</span><span class="s0">],FunctionExpression:[</span><span class="s3">&quot;id&quot;</span><span class="s0">,</span><span class="s3">&quot;params&quot;</span><span class="s0">],ArrowFunctionExpression:[</span><span class="s3">&quot;params&quot;</span><span class="s0">],ObjectMethod:[</span><span class="s3">&quot;params&quot;</span><span class="s0">],ClassMethod:[</span><span class="s3">&quot;params&quot;</span><span class="s0">],ForInStatement:[</span><span class="s3">&quot;left&quot;</span><span class="s0">],ForOfStatement:[</span><span class="s3">&quot;left&quot;</span><span class="s0">],ClassDeclaration:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],ClassExpression:[</span><span class="s3">&quot;id&quot;</span><span class="s0">],RestElement:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">],UpdateExpression:[</span><span class="s3">&quot;argument&quot;</span><span class="s0">],ObjectProperty:[</span><span class="s3">&quot;value&quot;</span><span class="s0">],AssignmentPattern:[</span><span class="s3">&quot;left&quot;</span><span class="s0">],ArrayPattern:[</span><span class="s3">&quot;elements&quot;</span><span class="s0">],ObjectPattern:[</span><span class="s3">&quot;properties&quot;</span><span class="s0">],VariableDeclaration:[</span><span class="s3">&quot;declarations&quot;</span><span class="s0">],VariableDeclarator:[</span><span class="s3">&quot;id&quot;</span><span class="s0">]}},</span><span class="s2">210</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">5337</span><span class="s0">);t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t,!</span><span class="s2">0</span><span class="s0">)}},</span><span class="s2">9220</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s3">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;(t={enter:t});const{enter:n,exit:s}=t;i(e,n,s,r,[])};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1102</span><span class="s0">);</span><span class="s1">function </span><span class="s0">i(e,t,r,s,a){const o=n.VISITOR_KEYS[e.type];</span><span class="s1">if</span><span class="s0">(o){t&amp;&amp;t(e,a,s);</span><span class="s1">for</span><span class="s0">(const n of o){const o=e[n];</span><span class="s1">if</span><span class="s0">(Array.isArray(o))</span><span class="s1">for</span><span class="s0">(let l=</span><span class="s2">0</span><span class="s0">;l&lt;o.length;l++){const p=o[l];p&amp;&amp;(a.push({node:e,key:n,index:l}),i(p,t,r,s,a),a.pop())}</span><span class="s1">else </span><span class="s0">o&amp;&amp;(a.push({node:e,key:n}),i(o,t,r,s,a),a.pop())}r&amp;&amp;r(e,a,s)}}},</span><span class="s2">2829</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function </span><span class="s0">e(t,r,i){</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return</span><span class="s0">;const s=n.VISITOR_KEYS[t.type];</span><span class="s1">if</span><span class="s0">(s){r(t,i=i||{});</span><span class="s1">for</span><span class="s0">(const n of s){const s=t[n];</span><span class="s1">if</span><span class="s0">(Array.isArray(s))</span><span class="s1">for</span><span class="s0">(const t of s)e(t,r,i);</span><span class="s1">else </span><span class="s0">e(s,r,i)}}};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1102</span><span class="s0">)},</span><span class="s2">3746</span><span class="s0">:(e,t)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t,r){t&amp;&amp;r&amp;&amp;(t[e]=Array.from(</span><span class="s1">new </span><span class="s0">Set([].concat(t[e],r[e]).filter(Boolean))))}},</span><span class="s2">5908</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){const r=e.value.split(/\r\n|\n|\r/);let i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">;e&lt;r.length;e++)r[e].match(/[^ \t]/)&amp;&amp;(i=e);let s=</span><span class="s3">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">;e&lt;r.length;e++){const t=r[e],n=</span><span class="s2">0</span><span class="s0">===e,a=e===r.length-1,o=e===i;let l=t.replace(/\t/g,</span><span class="s3">&quot; &quot;</span><span class="s0">);n||(l=l.replace(/^[ ]+/,</span><span class="s3">&quot;&quot;</span><span class="s0">)),a||(l=l.replace(/[ ]+$/,</span><span class="s3">&quot;&quot;</span><span class="s0">)),l&amp;&amp;(o||(l+=</span><span class="s3">&quot; &quot;</span><span class="s0">),s+=l)}s&amp;&amp;t.push((</span><span class="s2">0</span><span class="s0">,n.stringLiteral)(s))};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1580</span><span class="s0">)},</span><span class="s2">4729</span><span class="s0">:(e,t)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){const r=Object.keys(t);</span><span class="s1">for</span><span class="s0">(const n of r)</span><span class="s1">if</span><span class="s0">(e[n]!==t[n])</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}},</span><span class="s2">3427</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){const r=e.split(</span><span class="s3">&quot;.&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">e=&gt;(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,r,t)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">4185</span><span class="s0">)},</span><span class="s2">3924</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.isArrayExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isAssignmentExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isBinaryExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;BinaryExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isInterpreterDirective=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;InterpreterDirective&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDirective=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;Directive&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDirectiveLiteral=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;DirectiveLiteral&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isBlockStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isBreakStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;BreakStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isCallExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;CallExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isCatchClause=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;CatchClause&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isConditionalExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isContinueStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ContinueStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDebuggerStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;DebuggerStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDoWhileStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isEmptyStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;EmptyStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isExpressionStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isFile=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;File&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isForInStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ForInStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isForStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ForStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isFunctionDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isFunctionExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isIdentifier=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isIfStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;IfStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isLabeledStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;LabeledStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isStringLiteral=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isNumericLiteral=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isNullLiteral=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;NullLiteral&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isBooleanLiteral=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;BooleanLiteral&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isRegExpLiteral=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;RegExpLiteral&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isLogicalExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;LogicalExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isMemberExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isNewExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;NewExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isProgram=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;Program&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isObjectExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isObjectMethod=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isObjectProperty=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isRestElement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isReturnStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ReturnStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isSequenceExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isParenthesizedExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isSwitchCase=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;SwitchCase&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isSwitchStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;SwitchStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isThisExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ThisExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isThrowStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ThrowStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTryStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TryStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isUnaryExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;UnaryExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isUpdateExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;UpdateExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isVariableDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isVariableDeclarator=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isWhileStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;WhileStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isWithStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;WithStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isAssignmentPattern=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isArrayPattern=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isArrowFunctionExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isClassBody=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ClassBody&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isClassExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ClassExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isClassDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isExportAllDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isExportDefaultDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isExportNamedDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isExportSpecifier=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ExportSpecifier&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isForOfStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isImportDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isImportDefaultSpecifier=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isImportNamespaceSpecifier=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ImportNamespaceSpecifier&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isImportSpecifier=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isMetaProperty=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;MetaProperty&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isClassMethod=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isObjectPattern=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isSpreadElement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isSuper=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;Super&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTaggedTemplateExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TaggedTemplateExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTemplateElement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TemplateElement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTemplateLiteral=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TemplateLiteral&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isYieldExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;YieldExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isAwaitExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;AwaitExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isImport=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;Import&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isBigIntLiteral=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;BigIntLiteral&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isExportNamespaceSpecifier=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ExportNamespaceSpecifier&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isOptionalMemberExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isOptionalCallExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;OptionalCallExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isAnyTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;AnyTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isArrayTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ArrayTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isBooleanTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;BooleanTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isBooleanLiteralTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;BooleanLiteralTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isNullLiteralTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;NullLiteralTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isClassImplements=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ClassImplements&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDeclareClass=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;DeclareClass&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDeclareFunction=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;DeclareFunction&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDeclareInterface=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;DeclareInterface&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDeclareModule=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;DeclareModule&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDeclareModuleExports=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;DeclareModuleExports&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDeclareTypeAlias=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;DeclareTypeAlias&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDeclareOpaqueType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;DeclareOpaqueType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDeclareVariable=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;DeclareVariable&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDeclareExportDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;DeclareExportDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDeclareExportAllDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;DeclareExportAllDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDeclaredPredicate=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;DeclaredPredicate&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isExistsTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ExistsTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isFunctionTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isFunctionTypeParam=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;FunctionTypeParam&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isGenericTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;GenericTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isInferredPredicate=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;InferredPredicate&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isInterfaceExtends=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;InterfaceExtends&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isInterfaceDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;InterfaceDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isInterfaceTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;InterfaceTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isIntersectionTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;IntersectionTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isMixedTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;MixedTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isEmptyTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;EmptyTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isNullableTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;NullableTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isNumberLiteralTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;NumberLiteralTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isNumberTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;NumberTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isObjectTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ObjectTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isObjectTypeInternalSlot=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ObjectTypeInternalSlot&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isObjectTypeCallProperty=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ObjectTypeCallProperty&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isObjectTypeIndexer=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ObjectTypeIndexer&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isObjectTypeProperty=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ObjectTypeProperty&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isObjectTypeSpreadProperty=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ObjectTypeSpreadProperty&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isOpaqueType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;OpaqueType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isQualifiedTypeIdentifier=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;QualifiedTypeIdentifier&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isStringLiteralTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;StringLiteralTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isStringTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;StringTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isSymbolTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;SymbolTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isThisTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ThisTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTupleTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TupleTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTypeofTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TypeofTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTypeAlias=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TypeAlias&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTypeCastExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTypeParameter=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TypeParameter&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTypeParameterDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTypeParameterInstantiation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isUnionTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;UnionTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isVariance=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;Variance&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isVoidTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;VoidTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isEnumDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;EnumDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isEnumBooleanBody=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;EnumBooleanBody&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isEnumNumberBody=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;EnumNumberBody&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isEnumStringBody=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;EnumStringBody&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isEnumSymbolBody=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;EnumSymbolBody&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isEnumBooleanMember=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;EnumBooleanMember&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isEnumNumberMember=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;EnumNumberMember&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isEnumStringMember=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;EnumStringMember&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isEnumDefaultedMember=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;EnumDefaultedMember&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isIndexedAccessType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;IndexedAccessType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isOptionalIndexedAccessType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;OptionalIndexedAccessType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isJSXAttribute=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXAttribute&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isJSXClosingElement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXClosingElement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isJSXElement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXElement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isJSXEmptyExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXEmptyExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isJSXExpressionContainer=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXExpressionContainer&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isJSXSpreadChild=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXSpreadChild&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isJSXIdentifier=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isJSXMemberExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isJSXNamespacedName=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isJSXOpeningElement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXOpeningElement&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isJSXSpreadAttribute=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXSpreadAttribute&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isJSXText=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXText&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isJSXFragment=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXFragment&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isJSXOpeningFragment=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXOpeningFragment&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isJSXClosingFragment=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXClosingFragment&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isNoop=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;Noop&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isPlaceholder=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isV8IntrinsicIdentifier=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;V8IntrinsicIdentifier&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isArgumentPlaceholder=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ArgumentPlaceholder&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isBindExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;BindExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isClassProperty=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ClassProperty&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isPipelineTopicExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;PipelineTopicExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isPipelineBareFunction=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;PipelineBareFunction&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isPipelinePrimaryTopicReference=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;PipelinePrimaryTopicReference&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isClassPrivateProperty=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ClassPrivateProperty&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isClassPrivateMethod=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isImportAttribute=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ImportAttribute&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDecorator=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDoExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;DoExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isExportDefaultSpecifier=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ExportDefaultSpecifier&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isPrivateName=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isRecordExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;RecordExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTupleExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TupleExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isDecimalLiteral=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;DecimalLiteral&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isStaticBlock=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;StaticBlock&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isModuleExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;ModuleExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSParameterProperty=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSParameterProperty&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSDeclareFunction=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSDeclareFunction&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSDeclareMethod=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSDeclareMethod&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSQualifiedName=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSQualifiedName&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSCallSignatureDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSCallSignatureDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSConstructSignatureDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSConstructSignatureDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSPropertySignature=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSPropertySignature&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSMethodSignature=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSMethodSignature&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSIndexSignature=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSIndexSignature&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSAnyKeyword=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSAnyKeyword&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSBooleanKeyword=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSBooleanKeyword&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSBigIntKeyword=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSBigIntKeyword&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSIntrinsicKeyword=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSIntrinsicKeyword&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSNeverKeyword=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSNeverKeyword&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSNullKeyword=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSNullKeyword&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSNumberKeyword=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSNumberKeyword&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSObjectKeyword=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSObjectKeyword&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSStringKeyword=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSStringKeyword&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSSymbolKeyword=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSSymbolKeyword&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSUndefinedKeyword=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSUndefinedKeyword&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSUnknownKeyword=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSUnknownKeyword&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSVoidKeyword=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSVoidKeyword&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSThisType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSThisType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSFunctionType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSFunctionType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSConstructorType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSConstructorType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSTypeReference=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSTypeReference&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSTypePredicate=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSTypePredicate&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSTypeQuery=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSTypeQuery&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSTypeLiteral=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSTypeLiteral&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSArrayType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSArrayType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSTupleType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSTupleType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSOptionalType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSOptionalType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSRestType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSRestType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSNamedTupleMember=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSNamedTupleMember&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSUnionType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSUnionType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSIntersectionType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSIntersectionType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSConditionalType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSConditionalType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSInferType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSInferType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSParenthesizedType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSParenthesizedType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSTypeOperator=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSTypeOperator&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSIndexedAccessType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSIndexedAccessType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSMappedType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSMappedType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSLiteralType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSLiteralType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSExpressionWithTypeArguments=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSExpressionWithTypeArguments&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSInterfaceDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSInterfaceDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSInterfaceBody=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSInterfaceBody&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSTypeAliasDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSTypeAliasDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSAsExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSAsExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSTypeAssertion=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSTypeAssertion&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSEnumDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSEnumDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSEnumMember=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSEnumMember&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSModuleDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSModuleDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSModuleBlock=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSModuleBlock&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSImportType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSImportType&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSImportEqualsDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSImportEqualsDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSExternalModuleReference=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSExternalModuleReference&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSNonNullExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSNonNullExpression&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSExportAssignment=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSExportAssignment&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSNamespaceExportDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSNamespaceExportDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSTypeAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSTypeParameterInstantiation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSTypeParameterDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSTypeParameterDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isTSTypeParameter=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;TSTypeParameter&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isExpression=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;BinaryExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;CallExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===r||</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NullLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;BooleanLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;RegExpLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;LogicalExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NewExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ThisExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;UnaryExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;UpdateExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;MetaProperty&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Super&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TaggedTemplateExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TemplateLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;YieldExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;AwaitExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Import&quot;</span><span class="s0">===r||</span><span class="s3">&quot;BigIntLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;OptionalCallExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXElement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXFragment&quot;</span><span class="s0">===r||</span><span class="s3">&quot;BindExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;PipelinePrimaryTopicReference&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DoExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;RecordExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TupleExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DecimalLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ModuleExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSAsExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSTypeAssertion&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSNonNullExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===r&amp;&amp;(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">===e.expectedNode||</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.expectedNode||</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===e.expectedNode))&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isBinary=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;BinaryExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;LogicalExpression&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isScopable=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;CatchClause&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ForInStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ForStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Program&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">===r||</span><span class="s3">&quot;SwitchStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;WhileStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">===r||</span><span class="s3">&quot;StaticBlock&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSModuleBlock&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===r&amp;&amp;</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">===e.expectedNode)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isBlockParent=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;CatchClause&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ForInStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ForStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Program&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">===r||</span><span class="s3">&quot;SwitchStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;WhileStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">===r||</span><span class="s3">&quot;StaticBlock&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSModuleBlock&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===r&amp;&amp;</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">===e.expectedNode)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isBlock=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Program&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSModuleBlock&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===r&amp;&amp;</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">===e.expectedNode)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;BreakStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ContinueStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DebuggerStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;EmptyStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ForInStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ForStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;IfStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;LabeledStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ReturnStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;SwitchStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ThrowStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TryStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;WhileStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;WithStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareClass&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareFunction&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareInterface&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareModule&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareModuleExports&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareTypeAlias&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareOpaqueType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareVariable&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareExportDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareExportAllDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;InterfaceDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;OpaqueType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TypeAlias&quot;</span><span class="s0">===r||</span><span class="s3">&quot;EnumDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSDeclareFunction&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSInterfaceDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSTypeAliasDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSEnumDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSModuleDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSImportEqualsDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSExportAssignment&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSNamespaceExportDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===r&amp;&amp;(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">===e.expectedNode||</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">===e.expectedNode||</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">===e.expectedNode))&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isTerminatorless=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;BreakStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ContinueStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ReturnStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ThrowStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;YieldExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;AwaitExpression&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isCompletionStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;BreakStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ContinueStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ReturnStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ThrowStatement&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isConditional=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;IfStatement&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isLoop=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ForInStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ForStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;WhileStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isWhile=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;WhileStatement&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isExpressionWrapper=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isFor=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;ForInStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ForStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isForXStatement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;ForInStatement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isFunction=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isFunctionParent=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isPureish=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NullLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;BooleanLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;RegExpLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;BigIntLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DecimalLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===r&amp;&amp;</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===e.expectedNode)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareClass&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareFunction&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareInterface&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareModule&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareModuleExports&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareTypeAlias&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareOpaqueType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareVariable&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareExportDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareExportAllDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;InterfaceDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;OpaqueType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TypeAlias&quot;</span><span class="s0">===r||</span><span class="s3">&quot;EnumDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSDeclareFunction&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSInterfaceDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSTypeAliasDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSEnumDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSModuleDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===r&amp;&amp;</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">===e.expectedNode)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isPatternLike=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===r||</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===r&amp;&amp;(</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">===e.expectedNode||</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.expectedNode))&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isLVal=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===r||</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSParameterProperty&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===r&amp;&amp;(</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">===e.expectedNode||</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.expectedNode))&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isTSEntityName=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSQualifiedName&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===r&amp;&amp;</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.expectedNode)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isLiteral=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NullLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;BooleanLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;RegExpLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TemplateLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;BigIntLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DecimalLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===r&amp;&amp;</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===e.expectedNode)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isImmutable=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NullLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;BooleanLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;BigIntLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXAttribute&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXClosingElement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXElement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXExpressionContainer&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXSpreadChild&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXOpeningElement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXText&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXFragment&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXOpeningFragment&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXClosingFragment&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DecimalLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===r&amp;&amp;</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===e.expectedNode)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isUserWhitespacable=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectTypeInternalSlot&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectTypeCallProperty&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectTypeIndexer&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectTypeProperty&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectTypeSpreadProperty&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isMethod=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isObjectMember=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isProperty=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassProperty&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassPrivateProperty&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isUnaryLike=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;UnaryExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isPattern=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===r&amp;&amp;</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">===e.expectedNode)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isClass=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;ClassExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isModuleDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isExportDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isModuleSpecifier=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;ExportSpecifier&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ImportNamespaceSpecifier&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ExportNamespaceSpecifier&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ExportDefaultSpecifier&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isFlow=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;AnyTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ArrayTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;BooleanTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;BooleanLiteralTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NullLiteralTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassImplements&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareClass&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareFunction&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareInterface&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareModule&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareModuleExports&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareTypeAlias&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareOpaqueType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareVariable&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareExportDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareExportAllDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclaredPredicate&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ExistsTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;FunctionTypeParam&quot;</span><span class="s0">===r||</span><span class="s3">&quot;GenericTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;InferredPredicate&quot;</span><span class="s0">===r||</span><span class="s3">&quot;InterfaceExtends&quot;</span><span class="s0">===r||</span><span class="s3">&quot;InterfaceDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;InterfaceTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;IntersectionTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;MixedTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;EmptyTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NullableTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NumberLiteralTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NumberTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectTypeInternalSlot&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectTypeCallProperty&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectTypeIndexer&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectTypeProperty&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectTypeSpreadProperty&quot;</span><span class="s0">===r||</span><span class="s3">&quot;OpaqueType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;QualifiedTypeIdentifier&quot;</span><span class="s0">===r||</span><span class="s3">&quot;StringLiteralTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;StringTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;SymbolTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ThisTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TupleTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TypeofTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TypeAlias&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TypeParameter&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;UnionTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;Variance&quot;</span><span class="s0">===r||</span><span class="s3">&quot;VoidTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;IndexedAccessType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;OptionalIndexedAccessType&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isFlowType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;AnyTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ArrayTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;BooleanTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;BooleanLiteralTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NullLiteralTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ExistsTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;GenericTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;InterfaceTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;IntersectionTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;MixedTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;EmptyTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NullableTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NumberLiteralTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NumberTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ObjectTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;StringLiteralTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;StringTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;SymbolTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ThisTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TupleTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TypeofTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;UnionTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;VoidTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;IndexedAccessType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;OptionalIndexedAccessType&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isFlowBaseAnnotation=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;AnyTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;BooleanTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NullLiteralTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;MixedTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;EmptyTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;NumberTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;StringTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;SymbolTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ThisTypeAnnotation&quot;</span><span class="s0">===r||</span><span class="s3">&quot;VoidTypeAnnotation&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isFlowDeclaration=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;DeclareClass&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareFunction&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareInterface&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareModule&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareModuleExports&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareTypeAlias&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareOpaqueType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareVariable&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareExportDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;DeclareExportAllDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;InterfaceDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;OpaqueType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TypeAlias&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isFlowPredicate=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;DeclaredPredicate&quot;</span><span class="s0">===r||</span><span class="s3">&quot;InferredPredicate&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isEnumBody=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;EnumBooleanBody&quot;</span><span class="s0">===r||</span><span class="s3">&quot;EnumNumberBody&quot;</span><span class="s0">===r||</span><span class="s3">&quot;EnumStringBody&quot;</span><span class="s0">===r||</span><span class="s3">&quot;EnumSymbolBody&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isEnumMember=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;EnumBooleanMember&quot;</span><span class="s0">===r||</span><span class="s3">&quot;EnumNumberMember&quot;</span><span class="s0">===r||</span><span class="s3">&quot;EnumStringMember&quot;</span><span class="s0">===r||</span><span class="s3">&quot;EnumDefaultedMember&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isJSX=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;JSXAttribute&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXClosingElement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXElement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXEmptyExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXExpressionContainer&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXSpreadChild&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXOpeningElement&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXSpreadAttribute&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXText&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXFragment&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXOpeningFragment&quot;</span><span class="s0">===r||</span><span class="s3">&quot;JSXClosingFragment&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isPrivate=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;ClassPrivateProperty&quot;</span><span class="s0">===r||</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">===r||</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isTSTypeElement=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;TSCallSignatureDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSConstructSignatureDeclaration&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSPropertySignature&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSMethodSignature&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSIndexSignature&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isTSType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;TSAnyKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSBooleanKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSBigIntKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSIntrinsicKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSNeverKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSNullKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSNumberKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSObjectKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSStringKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSSymbolKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSUndefinedKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSUnknownKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSVoidKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSThisType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSFunctionType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSConstructorType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSTypeReference&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSTypePredicate&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSTypeQuery&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSTypeLiteral&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSArrayType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSTupleType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSOptionalType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSRestType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSUnionType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSIntersectionType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSConditionalType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSInferType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSParenthesizedType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSTypeOperator&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSIndexedAccessType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSMappedType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSLiteralType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSExpressionWithTypeArguments&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSImportType&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isTSBaseType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=e.type;</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;TSAnyKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSBooleanKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSBigIntKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSIntrinsicKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSNeverKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSNullKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSNumberKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSObjectKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSStringKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSSymbolKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSUndefinedKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSUnknownKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSVoidKeyword&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSThisType&quot;</span><span class="s0">===r||</span><span class="s3">&quot;TSLiteralType&quot;</span><span class="s0">===r)&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t))},t.isNumberLiteral=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">console.trace(</span><span class="s3">&quot;The node type NumberLiteral has been renamed to NumericLiteral&quot;</span><span class="s0">),!!e&amp;&amp;(</span><span class="s3">&quot;NumberLiteral&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isRegexLiteral=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">console.trace(</span><span class="s3">&quot;The node type RegexLiteral has been renamed to RegExpLiteral&quot;</span><span class="s0">),!!e&amp;&amp;(</span><span class="s3">&quot;RegexLiteral&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isRestProperty=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">console.trace(</span><span class="s3">&quot;The node type RestProperty has been renamed to RestElement&quot;</span><span class="s0">),!!e&amp;&amp;(</span><span class="s3">&quot;RestProperty&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))},t.isSpreadProperty=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">console.trace(</span><span class="s3">&quot;The node type SpreadProperty has been renamed to SpreadElement&quot;</span><span class="s0">),!!e&amp;&amp;(</span><span class="s3">&quot;SpreadProperty&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e,t)))};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">4729</span><span class="s0">)},</span><span class="s2">5001</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return</span><span class="s0">!!t&amp;&amp;((</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(t.type,e)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===r||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(t,r):!r&amp;&amp;</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===t.type&amp;&amp;e </span><span class="s1">in </span><span class="s0">a.FLIPPED_ALIAS_KEYS&amp;&amp;(</span><span class="s2">0</span><span class="s0">,s.</span><span class="s1">default</span><span class="s0">)(t.expectedNode,e))};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">4729</span><span class="s0">),i=r(</span><span class="s2">4263</span><span class="s0">),s=r(</span><span class="s2">549</span><span class="s0">),a=r(</span><span class="s2">1102</span><span class="s0">)},</span><span class="s2">48</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(r&amp;&amp;</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">===t.type&amp;&amp;</span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s0">===r.type)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const i=n.</span><span class="s1">default</span><span class="s0">.keys[t.type];</span><span class="s1">if</span><span class="s0">(i)</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s2">0</span><span class="s0">;r&lt;i.length;r++){const n=t[i[r]];</span><span class="s1">if</span><span class="s0">(Array.isArray(n)){</span><span class="s1">if</span><span class="s0">(n.indexOf(e)&gt;=</span><span class="s2">0</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(n===e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">5337</span><span class="s0">)},</span><span class="s2">7199</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.isFunctionDeclaration)(e)||(</span><span class="s2">0</span><span class="s0">,n.isClassDeclaration)(e)||(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(e)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3924</span><span class="s0">),i=r(</span><span class="s2">100</span><span class="s0">)},</span><span class="s2">3261</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">!!(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e.type,</span><span class="s3">&quot;Immutable&quot;</span><span class="s0">)||!!(</span><span class="s2">0</span><span class="s0">,i.isIdentifier)(e)&amp;&amp;</span><span class="s3">&quot;undefined&quot;</span><span class="s0">===e.name};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">4263</span><span class="s0">),i=r(</span><span class="s2">3924</span><span class="s0">)},</span><span class="s2">100</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.isVariableDeclaration)(e)&amp;&amp;(</span><span class="s3">&quot;var&quot;</span><span class="s0">!==e.kind||e[i.BLOCK_SCOPED_SYMBOL])};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3924</span><span class="s0">),i=r(</span><span class="s2">2770</span><span class="s0">)},</span><span class="s2">1860</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">!(!e||!n.VISITOR_KEYS[e.type])};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1102</span><span class="s0">)},</span><span class="s2">7190</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function </span><span class="s0">e(t,r){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">t||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">r||</span><span class="s1">null</span><span class="s0">==t||</span><span class="s1">null</span><span class="s0">==r)</span><span class="s1">return </span><span class="s0">t===r;</span><span class="s1">if</span><span class="s0">(t.type!==r.type)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const i=Object.keys(n.NODE_FIELDS[t.type]||t.type),s=n.VISITOR_KEYS[t.type];</span><span class="s1">for</span><span class="s0">(const n of i){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">t[n]!=</span><span class="s1">typeof </span><span class="s0">r[n])</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=t[n]||</span><span class="s1">null</span><span class="s0">!=r[n]){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==t[n]||</span><span class="s1">null</span><span class="s0">==r[n])</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(Array.isArray(t[n])){</span><span class="s1">if</span><span class="s0">(!Array.isArray(r[n]))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(t[n].length!==r[n].length)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let i=</span><span class="s2">0</span><span class="s0">;i&lt;t[n].length;i++)</span><span class="s1">if</span><span class="s0">(!e(t[n][i],r[n][i]))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">t[n]||</span><span class="s1">null</span><span class="s0">!=s&amp;&amp;s.includes(n)){</span><span class="s1">if</span><span class="s0">(!e(t[n],r[n]))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}</span><span class="s1">else for</span><span class="s0">(const e of Object.keys(t[n]))</span><span class="s1">if</span><span class="s0">(t[n][e]!==r[n][e])</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1102</span><span class="s0">)},</span><span class="s2">549</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(e===t)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;const r=n.PLACEHOLDERS_ALIAS[e];</span><span class="s1">if</span><span class="s0">(r)</span><span class="s1">for</span><span class="s0">(const e of r)</span><span class="s1">if</span><span class="s0">(t===e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1102</span><span class="s0">)},</span><span class="s2">2954</span><span class="s0">:(e,t)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">switch</span><span class="s0">(t.type){</span><span class="s1">case</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">t.property===e?!!t.computed:t.object===e;</span><span class="s1">case</span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">t.init===e;</span><span class="s1">case</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">t.body===e;</span><span class="s1">case</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(t.params.includes(e))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ClassProperty&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ClassPrivateProperty&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">t.key===e?!!t.computed:t.value!==e||!r||</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">!==r.type;</span><span class="s1">case</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ClassExpression&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">t.superClass===e;</span><span class="s1">case</span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">t.right===e;</span><span class="s1">case</span><span class="s3">&quot;LabeledStatement&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;CatchClause&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;BreakStatement&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ContinueStatement&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ExportNamespaceSpecifier&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ExportDefaultSpecifier&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ExportSpecifier&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==r||!r.source)&amp;&amp;t.local===e;</span><span class="s1">case</span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ImportNamespaceSpecifier&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;JSXAttribute&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;MetaProperty&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ObjectTypeProperty&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">t.key!==e;</span><span class="s1">case</span><span class="s3">&quot;TSEnumMember&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">t.id!==e;</span><span class="s1">case</span><span class="s3">&quot;TSPropertySignature&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">t.key!==e||!!t.computed}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}},</span><span class="s2">5969</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">(!(</span><span class="s2">0</span><span class="s0">,n.isBlockStatement)(e)||!(</span><span class="s2">0</span><span class="s0">,n.isFunction)(t)&amp;&amp;!(</span><span class="s2">0</span><span class="s0">,n.isCatchClause)(t))&amp;&amp;(!(!(</span><span class="s2">0</span><span class="s0">,n.isPattern)(e)||!(</span><span class="s2">0</span><span class="s0">,n.isFunction)(t)&amp;&amp;!(</span><span class="s2">0</span><span class="s0">,n.isCatchClause)(t))||(</span><span class="s2">0</span><span class="s0">,n.isScopable)(e))};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3924</span><span class="s0">)},</span><span class="s2">1422</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.isImportDefaultSpecifier)(e)||(</span><span class="s2">0</span><span class="s0">,n.isIdentifier)(e.imported||e.exported,{name:</span><span class="s3">&quot;default&quot;</span><span class="s0">})};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3924</span><span class="s0">)},</span><span class="s2">4263</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(e===t)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(n.ALIAS_KEYS[t])</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=n.FLIPPED_ALIAS_KEYS[t];</span><span class="s1">if</span><span class="s0">(r){</span><span class="s1">if</span><span class="s0">(r[</span><span class="s2">0</span><span class="s0">]===e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const t of r)</span><span class="s1">if</span><span class="s0">(e===t)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1102</span><span class="s0">)},</span><span class="s2">3902</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(e)&amp;&amp;!i.has(e)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">6335</span><span class="s0">);const i=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">&quot;abstract&quot;</span><span class="s0">,</span><span class="s3">&quot;boolean&quot;</span><span class="s0">,</span><span class="s3">&quot;byte&quot;</span><span class="s0">,</span><span class="s3">&quot;char&quot;</span><span class="s0">,</span><span class="s3">&quot;double&quot;</span><span class="s0">,</span><span class="s3">&quot;enum&quot;</span><span class="s0">,</span><span class="s3">&quot;final&quot;</span><span class="s0">,</span><span class="s3">&quot;float&quot;</span><span class="s0">,</span><span class="s3">&quot;goto&quot;</span><span class="s0">,</span><span class="s3">&quot;implements&quot;</span><span class="s0">,</span><span class="s3">&quot;int&quot;</span><span class="s0">,</span><span class="s3">&quot;interface&quot;</span><span class="s0">,</span><span class="s3">&quot;long&quot;</span><span class="s0">,</span><span class="s3">&quot;native&quot;</span><span class="s0">,</span><span class="s3">&quot;package&quot;</span><span class="s0">,</span><span class="s3">&quot;private&quot;</span><span class="s0">,</span><span class="s3">&quot;protected&quot;</span><span class="s0">,</span><span class="s3">&quot;public&quot;</span><span class="s0">,</span><span class="s3">&quot;short&quot;</span><span class="s0">,</span><span class="s3">&quot;static&quot;</span><span class="s0">,</span><span class="s3">&quot;synchronized&quot;</span><span class="s0">,</span><span class="s3">&quot;throws&quot;</span><span class="s0">,</span><span class="s3">&quot;transient&quot;</span><span class="s0">,</span><span class="s3">&quot;volatile&quot;</span><span class="s0">])},</span><span class="s2">6335</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t=!</span><span class="s2">0</span><span class="s0">){</span><span class="s1">return</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;((!t||!(</span><span class="s2">0</span><span class="s0">,n.isKeyword)(e)&amp;&amp;!(</span><span class="s2">0</span><span class="s0">,n.isStrictReservedWord)(e,!</span><span class="s2">0</span><span class="s0">))&amp;&amp;(</span><span class="s2">0</span><span class="s0">,n.isIdentifierName)(e))};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">7075</span><span class="s0">)},</span><span class="s2">7117</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,n.isVariableDeclaration)(e,{kind:</span><span class="s3">&quot;var&quot;</span><span class="s0">})&amp;&amp;!e[i.BLOCK_SCOPED_SYMBOL]};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3924</span><span class="s0">),i=r(</span><span class="s2">2770</span><span class="s0">)},</span><span class="s2">4185</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(!(</span><span class="s2">0</span><span class="s0">,n.isMemberExpression)(e))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const i=Array.isArray(t)?t:t.split(</span><span class="s3">&quot;.&quot;</span><span class="s0">),s=[];let a;</span><span class="s1">for</span><span class="s0">(a=e;(</span><span class="s2">0</span><span class="s0">,n.isMemberExpression)(a);a=a.object)s.push(a.property);</span><span class="s1">if</span><span class="s0">(s.push(a),s.length&lt;i.length)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!r&amp;&amp;s.length&gt;i.length)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">,t=s.length-1;e&lt;i.length;e++,t--){const r=s[t];let a;</span><span class="s1">if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isIdentifier)(r))a=r.name;</span><span class="s1">else if</span><span class="s0">((</span><span class="s2">0</span><span class="s0">,n.isStringLiteral)(r))a=r.value;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!(</span><span class="s2">0</span><span class="s0">,n.isThisExpression)(r))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;a=</span><span class="s3">&quot;this&quot;</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(i[e]!==a)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">3924</span><span class="s0">)},</span><span class="s2">5582</span><span class="s0">:(e,t)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;/^[a-z]/.test(e)}},</span><span class="s2">1934</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=(</span><span class="s2">0</span><span class="s0">,r(</span><span class="s2">3427</span><span class="s0">).</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;React.Component&quot;</span><span class="s0">);t.</span><span class="s1">default</span><span class="s0">=n},</span><span class="s2">1843</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">;const a=n.NODE_FIELDS[e.type];</span><span class="s1">if</span><span class="s0">(!a)</span><span class="s1">return</span><span class="s0">;i(e,t,r,a[t]),s(e,t,r)},t.validateField=i,t.validateChild=s;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1102</span><span class="s0">);</span><span class="s1">function </span><span class="s0">i(e,t,r,n){</span><span class="s1">null</span><span class="s0">!=n&amp;&amp;n.validate&amp;&amp;(n.optional&amp;&amp;</span><span class="s1">null</span><span class="s0">==r||n.validate(e,t,r))}</span><span class="s1">function </span><span class="s0">s(e,t,r){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==r)</span><span class="s1">return</span><span class="s0">;const i=n.NODE_PARENT_VALIDATIONS[r.type];i&amp;&amp;i(e,t,r)}},</span><span class="s2">4987</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">397</span><span class="s0">);t.log=</span><span class="s1">function</span><span class="s0">(...e){</span><span class="s1">return</span><span class="s3">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">console&amp;&amp;console.log&amp;&amp;console.log(...e)},t.formatArgs=</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">if</span><span class="s0">(t[</span><span class="s2">0</span><span class="s0">]=(</span><span class="s1">this</span><span class="s0">.useColors?</span><span class="s3">&quot;%c&quot;</span><span class="s0">:</span><span class="s3">&quot;&quot;</span><span class="s0">)+</span><span class="s1">this</span><span class="s0">.namespace+(</span><span class="s1">this</span><span class="s0">.useColors?</span><span class="s3">&quot; %c&quot;</span><span class="s0">:</span><span class="s3">&quot; &quot;</span><span class="s0">)+t[</span><span class="s2">0</span><span class="s0">]+(</span><span class="s1">this</span><span class="s0">.useColors?</span><span class="s3">&quot;%c &quot;</span><span class="s0">:</span><span class="s3">&quot; &quot;</span><span class="s0">)+</span><span class="s3">&quot;+&quot;</span><span class="s0">+e.exports.humanize(</span><span class="s1">this</span><span class="s0">.diff),!</span><span class="s1">this</span><span class="s0">.useColors)</span><span class="s1">return</span><span class="s0">;const r=</span><span class="s3">&quot;color: &quot;</span><span class="s0">+</span><span class="s1">this</span><span class="s0">.color;t.splice(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,r,</span><span class="s3">&quot;color: inherit&quot;</span><span class="s0">);let n=</span><span class="s2">0</span><span class="s0">,i=</span><span class="s2">0</span><span class="s0">;t[</span><span class="s2">0</span><span class="s0">].replace(/%[a-zA-Z%]/g,(e=&gt;{</span><span class="s3">&quot;%%&quot;</span><span class="s0">!==e&amp;&amp;(n++,</span><span class="s3">&quot;%c&quot;</span><span class="s0">===e&amp;&amp;(i=n))})),t.splice(i,</span><span class="s2">0</span><span class="s0">,r)},t.save=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">try</span><span class="s0">{e?t.storage.setItem(</span><span class="s3">&quot;debug&quot;</span><span class="s0">,e):t.storage.removeItem(</span><span class="s3">&quot;debug&quot;</span><span class="s0">)}</span><span class="s1">catch</span><span class="s0">(e){}},t.load=</span><span class="s1">function</span><span class="s0">(){let e;</span><span class="s1">try</span><span class="s0">{e=t.storage.getItem(</span><span class="s3">&quot;debug&quot;</span><span class="s0">)}</span><span class="s1">catch</span><span class="s0">(e){}</span><span class="s1">return</span><span class="s0">!e&amp;&amp;</span><span class="s1">void </span><span class="s2">0</span><span class="s0">!==n&amp;&amp;</span><span class="s3">&quot;env&quot;</span><span class="s1">in </span><span class="s0">n&amp;&amp;(e=n.env.DEBUG),e},t.useColors=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">!(</span><span class="s3">&quot;undefined&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">window||!window.process||</span><span class="s3">&quot;renderer&quot;</span><span class="s0">!==window.process.type&amp;&amp;!window.process.__nwjs)||(</span><span class="s3">&quot;undefined&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&amp;&amp;(</span><span class="s3">&quot;undefined&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">document&amp;&amp;document.documentElement&amp;&amp;document.documentElement.style&amp;&amp;document.documentElement.style.WebkitAppearance||</span><span class="s3">&quot;undefined&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">window&amp;&amp;window.console&amp;&amp;(window.console.firebug||window.console.exception&amp;&amp;window.console.table)||</span><span class="s3">&quot;undefined&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">navigator&amp;&amp;navigator.userAgent&amp;&amp;navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&amp;&amp;parseInt(RegExp.$1,</span><span class="s2">10</span><span class="s0">)&gt;=</span><span class="s2">31</span><span class="s0">||</span><span class="s3">&quot;undefined&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">navigator&amp;&amp;navigator.userAgent&amp;&amp;navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))},t.storage=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">localStorage}</span><span class="s1">catch</span><span class="s0">(e){}}(),t.colors=[</span><span class="s3">&quot;#0000CC&quot;</span><span class="s0">,</span><span class="s3">&quot;#0000FF&quot;</span><span class="s0">,</span><span class="s3">&quot;#0033CC&quot;</span><span class="s0">,</span><span class="s3">&quot;#0033FF&quot;</span><span class="s0">,</span><span class="s3">&quot;#0066CC&quot;</span><span class="s0">,</span><span class="s3">&quot;#0066FF&quot;</span><span class="s0">,</span><span class="s3">&quot;#0099CC&quot;</span><span class="s0">,</span><span class="s3">&quot;#0099FF&quot;</span><span class="s0">,</span><span class="s3">&quot;#00CC00&quot;</span><span class="s0">,</span><span class="s3">&quot;#00CC33&quot;</span><span class="s0">,</span><span class="s3">&quot;#00CC66&quot;</span><span class="s0">,</span><span class="s3">&quot;#00CC99&quot;</span><span class="s0">,</span><span class="s3">&quot;#00CCCC&quot;</span><span class="s0">,</span><span class="s3">&quot;#00CCFF&quot;</span><span class="s0">,</span><span class="s3">&quot;#3300CC&quot;</span><span class="s0">,</span><span class="s3">&quot;#3300FF&quot;</span><span class="s0">,</span><span class="s3">&quot;#3333CC&quot;</span><span class="s0">,</span><span class="s3">&quot;#3333FF&quot;</span><span class="s0">,</span><span class="s3">&quot;#3366CC&quot;</span><span class="s0">,</span><span class="s3">&quot;#3366FF&quot;</span><span class="s0">,</span><span class="s3">&quot;#3399CC&quot;</span><span class="s0">,</span><span class="s3">&quot;#3399FF&quot;</span><span class="s0">,</span><span class="s3">&quot;#33CC00&quot;</span><span class="s0">,</span><span class="s3">&quot;#33CC33&quot;</span><span class="s0">,</span><span class="s3">&quot;#33CC66&quot;</span><span class="s0">,</span><span class="s3">&quot;#33CC99&quot;</span><span class="s0">,</span><span class="s3">&quot;#33CCCC&quot;</span><span class="s0">,</span><span class="s3">&quot;#33CCFF&quot;</span><span class="s0">,</span><span class="s3">&quot;#6600CC&quot;</span><span class="s0">,</span><span class="s3">&quot;#6600FF&quot;</span><span class="s0">,</span><span class="s3">&quot;#6633CC&quot;</span><span class="s0">,</span><span class="s3">&quot;#6633FF&quot;</span><span class="s0">,</span><span class="s3">&quot;#66CC00&quot;</span><span class="s0">,</span><span class="s3">&quot;#66CC33&quot;</span><span class="s0">,</span><span class="s3">&quot;#9900CC&quot;</span><span class="s0">,</span><span class="s3">&quot;#9900FF&quot;</span><span class="s0">,</span><span class="s3">&quot;#9933CC&quot;</span><span class="s0">,</span><span class="s3">&quot;#9933FF&quot;</span><span class="s0">,</span><span class="s3">&quot;#99CC00&quot;</span><span class="s0">,</span><span class="s3">&quot;#99CC33&quot;</span><span class="s0">,</span><span class="s3">&quot;#CC0000&quot;</span><span class="s0">,</span><span class="s3">&quot;#CC0033&quot;</span><span class="s0">,</span><span class="s3">&quot;#CC0066&quot;</span><span class="s0">,</span><span class="s3">&quot;#CC0099&quot;</span><span class="s0">,</span><span class="s3">&quot;#CC00CC&quot;</span><span class="s0">,</span><span class="s3">&quot;#CC00FF&quot;</span><span class="s0">,</span><span class="s3">&quot;#CC3300&quot;</span><span class="s0">,</span><span class="s3">&quot;#CC3333&quot;</span><span class="s0">,</span><span class="s3">&quot;#CC3366&quot;</span><span class="s0">,</span><span class="s3">&quot;#CC3399&quot;</span><span class="s0">,</span><span class="s3">&quot;#CC33CC&quot;</span><span class="s0">,</span><span class="s3">&quot;#CC33FF&quot;</span><span class="s0">,</span><span class="s3">&quot;#CC6600&quot;</span><span class="s0">,</span><span class="s3">&quot;#CC6633&quot;</span><span class="s0">,</span><span class="s3">&quot;#CC9900&quot;</span><span class="s0">,</span><span class="s3">&quot;#CC9933&quot;</span><span class="s0">,</span><span class="s3">&quot;#CCCC00&quot;</span><span class="s0">,</span><span class="s3">&quot;#CCCC33&quot;</span><span class="s0">,</span><span class="s3">&quot;#FF0000&quot;</span><span class="s0">,</span><span class="s3">&quot;#FF0033&quot;</span><span class="s0">,</span><span class="s3">&quot;#FF0066&quot;</span><span class="s0">,</span><span class="s3">&quot;#FF0099&quot;</span><span class="s0">,</span><span class="s3">&quot;#FF00CC&quot;</span><span class="s0">,</span><span class="s3">&quot;#FF00FF&quot;</span><span class="s0">,</span><span class="s3">&quot;#FF3300&quot;</span><span class="s0">,</span><span class="s3">&quot;#FF3333&quot;</span><span class="s0">,</span><span class="s3">&quot;#FF3366&quot;</span><span class="s0">,</span><span class="s3">&quot;#FF3399&quot;</span><span class="s0">,</span><span class="s3">&quot;#FF33CC&quot;</span><span class="s0">,</span><span class="s3">&quot;#FF33FF&quot;</span><span class="s0">,</span><span class="s3">&quot;#FF6600&quot;</span><span class="s0">,</span><span class="s3">&quot;#FF6633&quot;</span><span class="s0">,</span><span class="s3">&quot;#FF9900&quot;</span><span class="s0">,</span><span class="s3">&quot;#FF9933&quot;</span><span class="s0">,</span><span class="s3">&quot;#FFCC00&quot;</span><span class="s0">,</span><span class="s3">&quot;#FFCC33&quot;</span><span class="s0">],e.exports=r(</span><span class="s2">7179</span><span class="s0">)(t);const{formatters:i}=e.exports;i.j=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">JSON.stringify(e)}</span><span class="s1">catch</span><span class="s0">(e){</span><span class="s1">return</span><span class="s3">&quot;[UnexpectedJSONParseError]: &quot;</span><span class="s0">+e.message}}},</span><span class="s2">7179</span><span class="s0">:(e,t,r)=&gt;{e.exports=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">function </span><span class="s0">t(e){let t=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s2">0</span><span class="s0">;r&lt;e.length;r++)t=(t&lt;&lt;</span><span class="s2">5</span><span class="s0">)-t+e.charCodeAt(r),t|=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">return </span><span class="s0">n.colors[Math.abs(t)%n.colors.length]}</span><span class="s1">function </span><span class="s0">n(e){let r;</span><span class="s1">function </span><span class="s0">a(...e){</span><span class="s1">if</span><span class="s0">(!a.enabled)</span><span class="s1">return</span><span class="s0">;const t=a,i=Number(</span><span class="s1">new </span><span class="s0">Date),s=i-(r||i);t.diff=s,t.prev=r,t.curr=i,r=i,e[</span><span class="s2">0</span><span class="s0">]=n.coerce(e[</span><span class="s2">0</span><span class="s0">]),</span><span class="s3">&quot;string&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e[</span><span class="s2">0</span><span class="s0">]&amp;&amp;e.unshift(</span><span class="s3">&quot;%O&quot;</span><span class="s0">);let o=</span><span class="s2">0</span><span class="s0">;e[</span><span class="s2">0</span><span class="s0">]=e[</span><span class="s2">0</span><span class="s0">].replace(/%([a-zA-Z%])/g,((r,i)=&gt;{</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;%%&quot;</span><span class="s0">===r)</span><span class="s1">return </span><span class="s0">r;o++;const s=n.formatters[i];</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">s){const n=e[o];r=s.call(t,n),e.splice(o,</span><span class="s2">1</span><span class="s0">),o--}</span><span class="s1">return </span><span class="s0">r})),n.formatArgs.call(t,e),(t.log||n.log).apply(t,e)}</span><span class="s1">return </span><span class="s0">a.namespace=e,a.enabled=n.enabled(e),a.useColors=n.useColors(),a.color=t(e),a.destroy=i,a.extend=s,</span><span class="s3">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n.init&amp;&amp;n.init(a),n.instances.push(a),a}</span><span class="s1">function </span><span class="s0">i(){const e=n.instances.indexOf(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">return</span><span class="s0">-</span><span class="s2">1</span><span class="s0">!==e&amp;&amp;(n.instances.splice(e,</span><span class="s2">1</span><span class="s0">),!</span><span class="s2">0</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">s(e,t){const r=n(</span><span class="s1">this</span><span class="s0">.namespace+(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===t?</span><span class="s3">&quot;:&quot;</span><span class="s0">:t)+e);</span><span class="s1">return </span><span class="s0">r.log=</span><span class="s1">this</span><span class="s0">.log,r}</span><span class="s1">function </span><span class="s0">a(e){</span><span class="s1">return </span><span class="s0">e.toString().substring(</span><span class="s2">2</span><span class="s0">,e.toString().length-2).replace(/\.\*\?$/,</span><span class="s3">&quot;*&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">n.debug=n,n.</span><span class="s1">default</span><span class="s0">=n,n.coerce=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">e </span><span class="s1">instanceof </span><span class="s0">Error?e.stack||e.message:e},n.disable=</span><span class="s1">function</span><span class="s0">(){const e=[...n.names.map(a),...n.skips.map(a).map((e=&gt;</span><span class="s3">&quot;-&quot;</span><span class="s0">+e))].join(</span><span class="s3">&quot;,&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">n.enable(</span><span class="s3">&quot;&quot;</span><span class="s0">),e},n.enable=</span><span class="s1">function</span><span class="s0">(e){let t;n.save(e),n.names=[],n.skips=[];const r=(</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e?e:</span><span class="s3">&quot;&quot;</span><span class="s0">).split(/[\s,]+/),i=r.length;</span><span class="s1">for</span><span class="s0">(t=</span><span class="s2">0</span><span class="s0">;t&lt;i;t++)r[t]&amp;&amp;(</span><span class="s3">&quot;-&quot;</span><span class="s0">===(e=r[t].replace(/\*/g,</span><span class="s3">&quot;.*?&quot;</span><span class="s0">))[</span><span class="s2">0</span><span class="s0">]?n.skips.push(</span><span class="s1">new </span><span class="s0">RegExp(</span><span class="s3">&quot;^&quot;</span><span class="s0">+e.substr(</span><span class="s2">1</span><span class="s0">)+</span><span class="s3">&quot;$&quot;</span><span class="s0">)):n.names.push(</span><span class="s1">new </span><span class="s0">RegExp(</span><span class="s3">&quot;^&quot;</span><span class="s0">+e+</span><span class="s3">&quot;$&quot;</span><span class="s0">)));</span><span class="s1">for</span><span class="s0">(t=</span><span class="s2">0</span><span class="s0">;t&lt;n.instances.length;t++){const e=n.instances[t];e.enabled=n.enabled(e.namespace)}},n.enabled=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;*&quot;</span><span class="s0">===e[e.length-1])</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;let t,r;</span><span class="s1">for</span><span class="s0">(t=</span><span class="s2">0</span><span class="s0">,r=n.skips.length;t&lt;r;t++)</span><span class="s1">if</span><span class="s0">(n.skips[t].test(e))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(t=</span><span class="s2">0</span><span class="s0">,r=n.names.length;t&lt;r;t++)</span><span class="s1">if</span><span class="s0">(n.names[t].test(e))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">},n.humanize=r(</span><span class="s2">1331</span><span class="s0">),Object.keys(e).forEach((t=&gt;{n[t]=e[t]})),n.instances=[],n.names=[],n.skips=[],n.formatters={},n.selectColor=t,n.enable(n.load()),n}},</span><span class="s2">4410</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">397</span><span class="s0">);</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===n||</span><span class="s3">&quot;renderer&quot;</span><span class="s0">===n.type||!</span><span class="s2">0</span><span class="s0">===n.browser||n.__nwjs?e.exports=r(</span><span class="s2">4987</span><span class="s0">):e.exports=r(</span><span class="s2">848</span><span class="s0">)},</span><span class="s2">848</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">397</span><span class="s0">);const i=r(</span><span class="s2">6224</span><span class="s0">),s=r(</span><span class="s2">3837</span><span class="s0">);t.init=</span><span class="s1">function</span><span class="s0">(e){e.inspectOpts={};const r=Object.keys(t.inspectOpts);</span><span class="s1">for</span><span class="s0">(let n=</span><span class="s2">0</span><span class="s0">;n&lt;r.length;n++)e.inspectOpts[r[n]]=t.inspectOpts[r[n]]},t.log=</span><span class="s1">function</span><span class="s0">(...e){</span><span class="s1">return </span><span class="s0">n.stderr.write(s.format(...e)+</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">)},t.formatArgs=</span><span class="s1">function</span><span class="s0">(r){const{namespace:n,useColors:i}=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(i){const t=</span><span class="s1">this</span><span class="s0">.color,i=</span><span class="s3">&quot;[3&quot;</span><span class="s0">+(t&lt;</span><span class="s2">8</span><span class="s0">?t:</span><span class="s3">&quot;8;5;&quot;</span><span class="s0">+t),s=`  ${i};</span><span class="s2">1</span><span class="s0">m${n} [</span><span class="s2">0</span><span class="s0">m`;r[</span><span class="s2">0</span><span class="s0">]=s+r[</span><span class="s2">0</span><span class="s0">].split(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">).join(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">+s),r.push(i+</span><span class="s3">&quot;m+&quot;</span><span class="s0">+e.exports.humanize(</span><span class="s1">this</span><span class="s0">.diff)+</span><span class="s3">&quot;[0m&quot;</span><span class="s0">)}</span><span class="s1">else </span><span class="s0">r[</span><span class="s2">0</span><span class="s0">]=(t.inspectOpts.hideDate?</span><span class="s3">&quot;&quot;</span><span class="s0">:(</span><span class="s1">new </span><span class="s0">Date).toISOString()+</span><span class="s3">&quot; &quot;</span><span class="s0">)+n+</span><span class="s3">&quot; &quot;</span><span class="s0">+r[</span><span class="s2">0</span><span class="s0">]},t.save=</span><span class="s1">function</span><span class="s0">(e){e?n.env.DEBUG=e:</span><span class="s1">delete </span><span class="s0">n.env.DEBUG},t.load=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n.env.DEBUG},t.useColors=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s3">&quot;colors&quot;</span><span class="s1">in </span><span class="s0">t.inspectOpts?Boolean(t.inspectOpts.colors):i.isatty(n.stderr.fd)},t.colors=[</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">1</span><span class="s0">];</span><span class="s1">try</span><span class="s0">{const e=r(</span><span class="s2">7319</span><span class="s0">);e&amp;&amp;(e.stderr||e).level&gt;=</span><span class="s2">2</span><span class="s0">&amp;&amp;(t.colors=[</span><span class="s2">20</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">27</span><span class="s0">,</span><span class="s2">32</span><span class="s0">,</span><span class="s2">33</span><span class="s0">,</span><span class="s2">38</span><span class="s0">,</span><span class="s2">39</span><span class="s0">,</span><span class="s2">40</span><span class="s0">,</span><span class="s2">41</span><span class="s0">,</span><span class="s2">42</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">44</span><span class="s0">,</span><span class="s2">45</span><span class="s0">,</span><span class="s2">56</span><span class="s0">,</span><span class="s2">57</span><span class="s0">,</span><span class="s2">62</span><span class="s0">,</span><span class="s2">63</span><span class="s0">,</span><span class="s2">68</span><span class="s0">,</span><span class="s2">69</span><span class="s0">,</span><span class="s2">74</span><span class="s0">,</span><span class="s2">75</span><span class="s0">,</span><span class="s2">76</span><span class="s0">,</span><span class="s2">77</span><span class="s0">,</span><span class="s2">78</span><span class="s0">,</span><span class="s2">79</span><span class="s0">,</span><span class="s2">80</span><span class="s0">,</span><span class="s2">81</span><span class="s0">,</span><span class="s2">92</span><span class="s0">,</span><span class="s2">93</span><span class="s0">,</span><span class="s2">98</span><span class="s0">,</span><span class="s2">99</span><span class="s0">,</span><span class="s2">112</span><span class="s0">,</span><span class="s2">113</span><span class="s0">,</span><span class="s2">128</span><span class="s0">,</span><span class="s2">129</span><span class="s0">,</span><span class="s2">134</span><span class="s0">,</span><span class="s2">135</span><span class="s0">,</span><span class="s2">148</span><span class="s0">,</span><span class="s2">149</span><span class="s0">,</span><span class="s2">160</span><span class="s0">,</span><span class="s2">161</span><span class="s0">,</span><span class="s2">162</span><span class="s0">,</span><span class="s2">163</span><span class="s0">,</span><span class="s2">164</span><span class="s0">,</span><span class="s2">165</span><span class="s0">,</span><span class="s2">166</span><span class="s0">,</span><span class="s2">167</span><span class="s0">,</span><span class="s2">168</span><span class="s0">,</span><span class="s2">169</span><span class="s0">,</span><span class="s2">170</span><span class="s0">,</span><span class="s2">171</span><span class="s0">,</span><span class="s2">172</span><span class="s0">,</span><span class="s2">173</span><span class="s0">,</span><span class="s2">178</span><span class="s0">,</span><span class="s2">179</span><span class="s0">,</span><span class="s2">184</span><span class="s0">,</span><span class="s2">185</span><span class="s0">,</span><span class="s2">196</span><span class="s0">,</span><span class="s2">197</span><span class="s0">,</span><span class="s2">198</span><span class="s0">,</span><span class="s2">199</span><span class="s0">,</span><span class="s2">200</span><span class="s0">,</span><span class="s2">201</span><span class="s0">,</span><span class="s2">202</span><span class="s0">,</span><span class="s2">203</span><span class="s0">,</span><span class="s2">204</span><span class="s0">,</span><span class="s2">205</span><span class="s0">,</span><span class="s2">206</span><span class="s0">,</span><span class="s2">207</span><span class="s0">,</span><span class="s2">208</span><span class="s0">,</span><span class="s2">209</span><span class="s0">,</span><span class="s2">214</span><span class="s0">,</span><span class="s2">215</span><span class="s0">,</span><span class="s2">220</span><span class="s0">,</span><span class="s2">221</span><span class="s0">])}</span><span class="s1">catch</span><span class="s0">(e){}t.inspectOpts=Object.keys(n.env).filter((e=&gt;/^debug_/i.test(e))).reduce(((e,t)=&gt;{const r=t.substring(</span><span class="s2">6</span><span class="s0">).toLowerCase().replace(/_([a-z])/g,((e,t)=&gt;t.toUpperCase()));let i=n.env[t];</span><span class="s1">return </span><span class="s0">i=!!/^(yes|on|</span><span class="s1">true</span><span class="s0">|enabled)$/i.test(i)||!/^(no|off|</span><span class="s1">false</span><span class="s0">|disabled)$/i.test(i)&amp;&amp;(</span><span class="s3">&quot;null&quot;</span><span class="s0">===i?</span><span class="s1">null</span><span class="s0">:Number(i)),e[r]=i,e}),{}),e.exports=r(</span><span class="s2">7179</span><span class="s0">)(t);const{formatters:a}=e.exports;a.o=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return this</span><span class="s0">.inspectOpts.colors=</span><span class="s1">this</span><span class="s0">.useColors,s.inspect(e,</span><span class="s1">this</span><span class="s0">.inspectOpts).replace(/\s*\n\s*/g,</span><span class="s3">&quot; &quot;</span><span class="s0">)},a.O=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return this</span><span class="s0">.inspectOpts.colors=</span><span class="s1">this</span><span class="s0">.useColors,s.inspect(e,</span><span class="s1">this</span><span class="s0">.inspectOpts)}},</span><span class="s2">8715</span><span class="s0">:</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">var </span><span class="s0">n,i,s;!</span><span class="s1">function</span><span class="s0">(a,o){</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;i=[r(</span><span class="s2">7356</span><span class="s0">)],</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===(s=</span><span class="s3">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof</span><span class="s0">(n=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">var </span><span class="s0">t=/(^|@)\S+:\d+/,r=/^\s*at .*(\S+:\d+|\(native\))/m,n=/^(eval@)?(\[native code])?$/;</span><span class="s1">return</span><span class="s0">{parse:</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">!==e.stacktrace||</span><span class="s1">void </span><span class="s2">0</span><span class="s0">!==e[</span><span class="s3">&quot;opera#sourceloc&quot;</span><span class="s0">])</span><span class="s1">return this</span><span class="s0">.parseOpera(e);</span><span class="s1">if</span><span class="s0">(e.stack&amp;&amp;e.stack.match(r))</span><span class="s1">return this</span><span class="s0">.parseV8OrIE(e);</span><span class="s1">if</span><span class="s0">(e.stack)</span><span class="s1">return this</span><span class="s0">.parseFFOrSafari(e);</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Cannot parse given Error object&quot;</span><span class="s0">)},extractLocation:</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(-</span><span class="s2">1</span><span class="s0">===e.indexOf(</span><span class="s3">&quot;:&quot;</span><span class="s0">))</span><span class="s1">return</span><span class="s0">[e];</span><span class="s1">var </span><span class="s0">t=/(.+?)(?::(\d+))?(?::(\d+))?$/.exec(e.replace(/[()]/g,</span><span class="s3">&quot;&quot;</span><span class="s0">));</span><span class="s1">return</span><span class="s0">[t[</span><span class="s2">1</span><span class="s0">],t[</span><span class="s2">2</span><span class="s0">]||</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,t[</span><span class="s2">3</span><span class="s0">]||</span><span class="s1">void </span><span class="s2">0</span><span class="s0">]},parseV8OrIE:</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">return </span><span class="s0">t.stack.split(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">).filter((</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">!!e.match(r)}),</span><span class="s1">this</span><span class="s0">).map((</span><span class="s1">function</span><span class="s0">(t){t.indexOf(</span><span class="s3">&quot;(eval &quot;</span><span class="s0">)&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;(t=t.replace(/eval code/g,</span><span class="s3">&quot;eval&quot;</span><span class="s0">).replace(/(\(eval at [^()]*)|(\),.*$)/g,</span><span class="s3">&quot;&quot;</span><span class="s0">));</span><span class="s1">var </span><span class="s0">r=t.replace(/^\s+/,</span><span class="s3">&quot;&quot;</span><span class="s0">).replace(/\(eval code/g,</span><span class="s3">&quot;(&quot;</span><span class="s0">),n=r.match(/ (\((.+):(\d+):(\d+)\)$)/),i=(r=n?r.replace(n[</span><span class="s2">0</span><span class="s0">],</span><span class="s3">&quot;&quot;</span><span class="s0">):r).split(/\s+/).slice(</span><span class="s2">1</span><span class="s0">),s=</span><span class="s1">this</span><span class="s0">.extractLocation(n?n[</span><span class="s2">1</span><span class="s0">]:i.pop()),a=i.join(</span><span class="s3">&quot; &quot;</span><span class="s0">)||</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,o=[</span><span class="s3">&quot;eval&quot;</span><span class="s0">,</span><span class="s3">&quot;&lt;anonymous&gt;&quot;</span><span class="s0">].indexOf(s[</span><span class="s2">0</span><span class="s0">])&gt;-</span><span class="s2">1</span><span class="s0">?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:s[</span><span class="s2">0</span><span class="s0">];</span><span class="s1">return new </span><span class="s0">e({functionName:a,fileName:o,lineNumber:s[</span><span class="s2">1</span><span class="s0">],columnNumber:s[</span><span class="s2">2</span><span class="s0">],source:t})}),</span><span class="s1">this</span><span class="s0">)},parseFFOrSafari:</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">return </span><span class="s0">t.stack.split(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">).filter((</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">!e.match(n)}),</span><span class="s1">this</span><span class="s0">).map((</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">if</span><span class="s0">(t.indexOf(</span><span class="s3">&quot; &gt; eval&quot;</span><span class="s0">)&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;(t=t.replace(/ line (\d+)(?: &gt; eval line \d+)* &gt; eval:\d+:\d+/g,</span><span class="s3">&quot;:$1&quot;</span><span class="s0">)),-</span><span class="s2">1</span><span class="s0">===t.indexOf(</span><span class="s3">&quot;@&quot;</span><span class="s0">)&amp;&amp;-</span><span class="s2">1</span><span class="s0">===t.indexOf(</span><span class="s3">&quot;:&quot;</span><span class="s0">))</span><span class="s1">return new </span><span class="s0">e({functionName:t});</span><span class="s1">var </span><span class="s0">r=/((.*</span><span class="s3">&quot;.+&quot;</span><span class="s0">[^@]*)?[^@]*)(?:@)/,n=t.match(r),i=n&amp;&amp;n[</span><span class="s2">1</span><span class="s0">]?n[</span><span class="s2">1</span><span class="s0">]:</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,s=</span><span class="s1">this</span><span class="s0">.extractLocation(t.replace(r,</span><span class="s3">&quot;&quot;</span><span class="s0">));</span><span class="s1">return new </span><span class="s0">e({functionName:i,fileName:s[</span><span class="s2">0</span><span class="s0">],lineNumber:s[</span><span class="s2">1</span><span class="s0">],columnNumber:s[</span><span class="s2">2</span><span class="s0">],source:t})}),</span><span class="s1">this</span><span class="s0">)},parseOpera:</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">!e.stacktrace||e.message.indexOf(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">)&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;e.message.split(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">).length&gt;e.stacktrace.split(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">).length?</span><span class="s1">this</span><span class="s0">.parseOpera9(e):e.stack?</span><span class="s1">this</span><span class="s0">.parseOpera11(e):</span><span class="s1">this</span><span class="s0">.parseOpera10(e)},parseOpera9:</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">r=/Line (\d+).*script (?:</span><span class="s1">in </span><span class="s0">)?(\S+)/i,n=t.message.split(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">),i=[],s=</span><span class="s2">2</span><span class="s0">,a=n.length;s&lt;a;s+=</span><span class="s2">2</span><span class="s0">){</span><span class="s1">var </span><span class="s0">o=r.exec(n[s]);o&amp;&amp;i.push(</span><span class="s1">new </span><span class="s0">e({fileName:o[</span><span class="s2">2</span><span class="s0">],lineNumber:o[</span><span class="s2">1</span><span class="s0">],source:n[s]}))}</span><span class="s1">return </span><span class="s0">i},parseOpera10:</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">r=/Line (\d+).*script (?:</span><span class="s1">in </span><span class="s0">)?(\S+)(?:: In </span><span class="s1">function </span><span class="s0">(\S+))?$/i,n=t.stacktrace.split(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">),i=[],s=</span><span class="s2">0</span><span class="s0">,a=n.length;s&lt;a;s+=</span><span class="s2">2</span><span class="s0">){</span><span class="s1">var </span><span class="s0">o=r.exec(n[s]);o&amp;&amp;i.push(</span><span class="s1">new </span><span class="s0">e({functionName:o[</span><span class="s2">3</span><span class="s0">]||</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,fileName:o[</span><span class="s2">2</span><span class="s0">],lineNumber:o[</span><span class="s2">1</span><span class="s0">],source:n[s]}))}</span><span class="s1">return </span><span class="s0">i},parseOpera11:</span><span class="s1">function</span><span class="s0">(r){</span><span class="s1">return </span><span class="s0">r.stack.split(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">).filter((</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">!!e.match(t)&amp;&amp;!e.match(/^Error created at/)}),</span><span class="s1">this</span><span class="s0">).map((</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">var </span><span class="s0">r,n=t.split(</span><span class="s3">&quot;@&quot;</span><span class="s0">),i=</span><span class="s1">this</span><span class="s0">.extractLocation(n.pop()),s=n.shift()||</span><span class="s3">&quot;&quot;</span><span class="s0">,a=s.replace(/&lt;anonymous </span><span class="s1">function</span><span class="s0">(: (\w+))?&gt;/,</span><span class="s3">&quot;$2&quot;</span><span class="s0">).replace(/\([^)]*\)/g,</span><span class="s3">&quot;&quot;</span><span class="s0">)||</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;s.match(/\(([^)]*)\)/)&amp;&amp;(r=s.replace(/^[^(]+\(([^)]*)\)$/,</span><span class="s3">&quot;$1&quot;</span><span class="s0">));</span><span class="s1">var </span><span class="s0">o=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===r||</span><span class="s3">&quot;[arguments not available]&quot;</span><span class="s0">===r?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.split(</span><span class="s3">&quot;,&quot;</span><span class="s0">);</span><span class="s1">return new </span><span class="s0">e({functionName:a,args:o,fileName:i[</span><span class="s2">0</span><span class="s0">],lineNumber:i[</span><span class="s2">1</span><span class="s0">],columnNumber:i[</span><span class="s2">2</span><span class="s0">],source:t})}),</span><span class="s1">this</span><span class="s0">)}}})?n.apply(t,i):n)||(e.exports=s)}()},</span><span class="s2">1014</span><span class="s0">:e=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">t=/[|\\{}()[\]^$+*?.]/g;e.exports=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;string&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">&quot;Expected a string&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">e.replace(t,</span><span class="s3">&quot;</span><span class="s4">\\</span><span class="s3">$&amp;&quot;</span><span class="s0">)}},</span><span class="s2">2261</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;e.exports=r(</span><span class="s2">964</span><span class="s0">)},</span><span class="s2">9341</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">397</span><span class="s0">);e.exports=(e,t)=&gt;{t=t||n.argv;const r=e.startsWith(</span><span class="s3">&quot;-&quot;</span><span class="s0">)?</span><span class="s3">&quot;&quot;</span><span class="s0">:</span><span class="s2">1</span><span class="s0">===e.length?</span><span class="s3">&quot;-&quot;</span><span class="s0">:</span><span class="s3">&quot;--&quot;</span><span class="s0">,i=t.indexOf(r+e),s=t.indexOf(</span><span class="s3">&quot;--&quot;</span><span class="s0">);</span><span class="s1">return</span><span class="s0">-</span><span class="s2">1</span><span class="s0">!==i&amp;&amp;(-</span><span class="s2">1</span><span class="s0">===s||i&lt;s)}},</span><span class="s2">8631</span><span class="s0">:(e,t)=&gt;{Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=/(([</span><span class="s3">'&quot;])(?:(?!</span><span class="s4">\2</span><span class="s3">|</span><span class="s4">\\</span><span class="s3">).|</span><span class="s4">\\</span><span class="s3">(?:</span><span class="s4">\r\n</span><span class="s3">|[</span><span class="s5">\s\S</span><span class="s3">]))*(</span><span class="s4">\2</span><span class="s3">)?|`(?:[^`</span><span class="s4">\\</span><span class="s3">$]|</span><span class="s4">\\</span><span class="s3">[</span><span class="s5">\s\S</span><span class="s3">]|</span><span class="s5">\$</span><span class="s3">(?!</span><span class="s5">\{</span><span class="s3">)|</span><span class="s5">\$\{</span><span class="s3">(?:[^{}]|</span><span class="s5">\{</span><span class="s3">[^}]*</span><span class="s5">\}</span><span class="s3">?)*</span><span class="s5">\}</span><span class="s3">?)*(`)?)|(</span><span class="s5">\/\/</span><span class="s3">.*)|(</span><span class="s5">\/\*</span><span class="s3">(?:[^*]|</span><span class="s5">\*</span><span class="s3">(?!</span><span class="s5">\/</span><span class="s3">))*(</span><span class="s5">\*\/</span><span class="s3">)?)|(</span><span class="s5">\/</span><span class="s3">(?!</span><span class="s5">\*</span><span class="s3">)(?:</span><span class="s5">\[</span><span class="s3">(?:(?![</span><span class="s5">\]</span><span class="s4">\\</span><span class="s3">]).|</span><span class="s4">\\</span><span class="s3">.)*</span><span class="s5">\]</span><span class="s3">|(?![</span><span class="s5">\/\]</span><span class="s4">\\</span><span class="s3">]).|</span><span class="s4">\\</span><span class="s3">.)+</span><span class="s5">\/</span><span class="s3">(?:(?!</span><span class="s5">\s</span><span class="s3">*(?:</span><span class="s4">\b</span><span class="s3">|[</span><span class="s4">\u0080</span><span class="s3">-</span><span class="s4">\uFFFF</span><span class="s3">$</span><span class="s4">\\</span><span class="s3">'&quot;~({]|[+</span><span class="s5">\-</span><span class="s3">!](?!=)|</span><span class="s5">\.</span><span class="s3">?</span><span class="s5">\d</span><span class="s3">))|[gmiyus]{1,6}</span><span class="s4">\b</span><span class="s3">(?![</span><span class="s4">\u0080</span><span class="s3">-</span><span class="s4">\uFFFF</span><span class="s3">$</span><span class="s4">\\</span><span class="s3">]|</span><span class="s5">\s</span><span class="s3">*(?:[+</span><span class="s5">\-</span><span class="s3">*%&amp;|^&lt;&gt;!=?({]|</span><span class="s5">\/</span><span class="s3">(?![</span><span class="s5">\/</span><span class="s3">*])))))|(0[xX][</span><span class="s5">\d</span><span class="s3">a-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:</span><span class="s5">\d</span><span class="s3">*</span><span class="s5">\.\d</span><span class="s3">+|</span><span class="s5">\d</span><span class="s3">+</span><span class="s5">\.</span><span class="s3">?)(?:[eE][+-]?</span><span class="s5">\d</span><span class="s3">+)?)|((?!</span><span class="s5">\d</span><span class="s3">)(?:(?!</span><span class="s5">\s</span><span class="s3">)[$</span><span class="s5">\w</span><span class="s4">\u0080</span><span class="s3">-</span><span class="s4">\uFFFF</span><span class="s3">]|</span><span class="s4">\\</span><span class="s3">u[</span><span class="s5">\d</span><span class="s3">a-fA-F]{4}|</span><span class="s4">\\</span><span class="s3">u</span><span class="s5">\{</span><span class="s3">[</span><span class="s5">\d</span><span class="s3">a-fA-F]+</span><span class="s5">\}</span><span class="s3">)+)|(--|</span><span class="s5">\+\+</span><span class="s3">|&amp;&amp;|</span><span class="s5">\|\|</span><span class="s3">|=&gt;|</span><span class="s5">\.</span><span class="s3">{3}|(?:[+</span><span class="s5">\-\/</span><span class="s3">%&amp;|^]|</span><span class="s5">\*</span><span class="s3">{1,2}|&lt;{1,2}|&gt;{1,3}|!=?|={1,2})=?|[?~.,:;[</span><span class="s5">\]</span><span class="s3">(){}])|(</span><span class="s5">\s</span><span class="s3">+)|(^$|[</span><span class="s5">\s\S</span><span class="s3">])/g,t.matchToToken=function(e){var t={type:&quot;</span><span class="s0">invalid</span><span class="s3">&quot;,value:e[0],closed:void 0};return e[1]?(t.type=&quot;</span><span class="s0">string</span><span class="s3">&quot;,t.closed=!(!e[3]&amp;&amp;!e[4])):e[5]?t.type=&quot;</span><span class="s0">comment</span><span class="s3">&quot;:e[6]?(t.type=&quot;</span><span class="s0">comment</span><span class="s3">&quot;,t.closed=!!e[7]):e[8]?t.type=&quot;</span><span class="s0">regex</span><span class="s3">&quot;:e[9]?t.type=&quot;</span><span class="s0">number</span><span class="s3">&quot;:e[10]?t.type=&quot;</span><span class="s0">name</span><span class="s3">&quot;:e[11]?t.type=&quot;</span><span class="s0">punctuator</span><span class="s3">&quot;:e[12]&amp;&amp;(t.type=&quot;</span><span class="s0">whitespace</span><span class="s3">&quot;),t}},442:e=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;const t={},r=t.hasOwnProperty,n=(e,t)=&gt;{for(const n in e)r.call(e,n)&amp;&amp;t(n,e[n])},i=t.toString,s=Array.isArray,a=Buffer.isBuffer,o={'&quot;':'</span><span class="s0">\\</span><span class="s3">&quot;',&quot;'&quot;:&quot;</span><span class="s4">\\</span><span class="s3">'&quot;,&quot;</span><span class="s0">\\</span><span class="s3">&quot;:&quot;</span><span class="s0">\\\\</span><span class="s3">&quot;,&quot;</span><span class="s0">\b</span><span class="s3">&quot;:&quot;</span><span class="s0">\\b</span><span class="s3">&quot;,&quot;</span><span class="s0">\f</span><span class="s3">&quot;:&quot;</span><span class="s0">\\f</span><span class="s3">&quot;,&quot;</span><span class="s0">\n</span><span class="s3">&quot;:&quot;</span><span class="s0">\\n</span><span class="s3">&quot;,&quot;</span><span class="s0">\r</span><span class="s3">&quot;:&quot;</span><span class="s0">\\r</span><span class="s3">&quot;,&quot;</span><span class="s0">\t</span><span class="s3">&quot;:&quot;</span><span class="s0">\\t</span><span class="s3">&quot;},l=/[&quot;'</span><span class="s4">\\\b\f\n\r\t</span><span class="s3">]/,p=/[0-9]/,c=/[ !#-&amp;</span><span class="s5">\(</span><span class="s3">-</span><span class="s5">\[\]</span><span class="s3">-_a-~]/,u=(e,t)=&gt;{const r=()=&gt;{S=g,++t.indentLevel,g=t.indent.repeat(t.indentLevel)},d={escapeEverything:!1,minimal:!1,isScriptContext:!1,quotes:&quot;single&quot;,wrap:!1,es6:!1,json:!1,compact:!0,lowercaseHex:!1,numbers:&quot;decimal&quot;,indent:&quot;</span><span class="s4">\t</span><span class="s3">&quot;,indentLevel:0,__inline1__:!1,__inline2__:!1},h=t&amp;&amp;t.json;var f,m;h&amp;&amp;(d.quotes=&quot;double&quot;,d.wrap=!0),f=d,t=(m=t)?(n(m,((e,t)=&gt;{f[e]=t})),f):f,&quot;single&quot;!=t.quotes&amp;&amp;&quot;double&quot;!=t.quotes&amp;&amp;&quot;backtick&quot;!=t.quotes&amp;&amp;(t.quotes=&quot;single&quot;);const y=&quot;double&quot;==t.quotes?'&quot;':&quot;</span><span class="s0">backtick</span><span class="s3">&quot;==t.quotes?&quot;</span><span class="s0">`</span><span class="s3">&quot;:&quot;'&quot;,T=t.compact,b=t.lowercaseHex;let g=t.indent.repeat(t.indentLevel),S=&quot;&quot;;const x=t.__inline1__,E=t.__inline2__,P=T?&quot;&quot;:&quot;</span><span class="s4">\n</span><span class="s3">&quot;;let v,A=!0;const w=&quot;binary&quot;==t.numbers,O=&quot;octal&quot;==t.numbers,I=&quot;decimal&quot;==t.numbers,N=&quot;hexadecimal&quot;==t.numbers;if(h&amp;&amp;e&amp;&amp;&quot;function&quot;==typeof e.toJSON&amp;&amp;(e=e.toJSON()),&quot;string&quot;!=typeof(C=e)&amp;&amp;&quot;[object String]&quot;!=i.call(C)){if((e=&gt;&quot;[object Map]&quot;==i.call(e))(e))return 0==e.size?&quot;new Map()&quot;:(T||(t.__inline1__=!0,t.__inline2__=!1),&quot;new Map(&quot;+u(Array.from(e),t)+&quot;)&quot;);if((e=&gt;&quot;[object Set]&quot;==i.call(e))(e))return 0==e.size?&quot;new Set()&quot;:&quot;new Set(&quot;+u(Array.from(e),t)+&quot;)&quot;;if(a(e))return 0==e.length?&quot;Buffer.from([])&quot;:&quot;Buffer.from(&quot;+u(Array.from(e),t)+&quot;)&quot;;if(s(e))return v=[],t.wrap=!0,x&amp;&amp;(t.__inline1__=!1,t.__inline2__=!0),E||r(),((e,t)=&gt;{const r=e.length;let n=-1;for(;++n&lt;r;)t(e[n])})(e,(e=&gt;{A=!1,E&amp;&amp;(t.__inline2__=!1),v.push((T||E?&quot;&quot;:g)+u(e,t))})),A?&quot;[]&quot;:E?&quot;[&quot;+v.join(&quot;, &quot;)+&quot;]&quot;:&quot;[&quot;+P+v.join(&quot;,&quot;+P)+P+(T?&quot;&quot;:S)+&quot;]&quot;;if(!(e=&gt;&quot;number&quot;==typeof e||&quot;[object Number]&quot;==i.call(e))(e))return(e=&gt;&quot;[object Object]&quot;==i.call(e))(e)?(v=[],t.wrap=!0,r(),n(e,((e,r)=&gt;{A=!1,v.push((T?&quot;&quot;:g)+u(e,t)+&quot;:&quot;+(T?&quot;&quot;:&quot; &quot;)+u(r,t))})),A?&quot;{}&quot;:&quot;{&quot;+P+v.join(&quot;,&quot;+P)+P+(T?&quot;&quot;:S)+&quot;}&quot;):h?JSON.stringify(e)||&quot;null&quot;:String(e);if(h)return JSON.stringify(e);if(I)return String(e);if(N){let t=e.toString(16);return b||(t=t.toUpperCase()),&quot;0x&quot;+t}if(w)return&quot;0b&quot;+e.toString(2);if(O)return&quot;0o&quot;+e.toString(8)}var C;const k=e;let D=-1;const _=k.length;for(v=&quot;&quot;;++D&lt;_;){const e=k.charAt(D);if(t.es6){const e=k.charCodeAt(D);if(e&gt;=55296&amp;&amp;e&lt;=56319&amp;&amp;_&gt;D+1){const t=k.charCodeAt(D+1);if(t&gt;=56320&amp;&amp;t&lt;=57343){let r=(1024*(e-55296)+t-56320+65536).toString(16);b||(r=r.toUpperCase()),v+=&quot;</span><span class="s4">\\</span><span class="s3">u{&quot;+r+&quot;}&quot;,++D;continue}}}if(!t.escapeEverything){if(c.test(e)){v+=e;continue}if('&quot;'==e){v+=y==e?'</span><span class="s4">\\</span><span class="s3">&quot;':e;continue}if(&quot;`&quot;==e){v+=y==e?&quot;</span><span class="s4">\\</span><span class="s3">`&quot;:e;continue}if(&quot;'&quot;==e){v+=y==e?&quot;</span><span class="s0">\\</span><span class="s3">'&quot;:e;continue}}if(&quot;</span><span class="s4">\0</span><span class="s3">&quot;==e&amp;&amp;!h&amp;&amp;!p.test(k.charAt(D+1))){v+=&quot;</span><span class="s4">\\</span><span class="s3">0&quot;;continue}if(l.test(e)){v+=o[e];continue}const r=e.charCodeAt(0);if(t.minimal&amp;&amp;8232!=r&amp;&amp;8233!=r){v+=e;continue}let n=r.toString(16);b||(n=n.toUpperCase());const i=n.length&gt;2||h,s=&quot;</span><span class="s4">\\</span><span class="s3">&quot;+(i?&quot;u&quot;:&quot;x&quot;)+(&quot;0000&quot;+n).slice(i?-4:-2);v+=s}return t.wrap&amp;&amp;(v=y+v+y),&quot;`&quot;==y&amp;&amp;(v=v.replace(/</span><span class="s5">\$\{</span><span class="s3">/g,&quot;</span><span class="s4">\\</span><span class="s3">${&quot;)),t.isScriptContext?v.replace(/&lt;</span><span class="s5">\/</span><span class="s3">(script|style)/gi,&quot;&lt;</span><span class="s4">\\</span><span class="s3">/$1&quot;).replace(/&lt;!--/g,h?&quot;</span><span class="s4">\\</span><span class="s3">u003C!--&quot;:&quot;</span><span class="s4">\\</span><span class="s3">x3C!--&quot;):v};u.version=&quot;2.5.2&quot;,e.exports=u},3018:(e,t,r)=&gt;{&quot;use strict&quot;;var n=r(397);e.exports=b;var i,s=r(7745),a=r(3837),o=r(5986),l=(i=&quot;function&quot;==typeof Symbol&amp;&amp;&quot;1&quot;!==n.env._nodeLRUCacheForceNoSymbol?function(e){return Symbol(e)}:function(e){return&quot;_&quot;+e})(&quot;max&quot;),p=i(&quot;length&quot;),c=i(&quot;lengthCalculator&quot;),u=i(&quot;allowStale&quot;),d=i(&quot;maxAge&quot;),h=i(&quot;dispose&quot;),f=i(&quot;noDisposeOnSet&quot;),m=i(&quot;lruList&quot;),y=i(&quot;cache&quot;);function T(){return 1}function b(e){if(!(this instanceof b))return new b(e);&quot;number&quot;==typeof e&amp;&amp;(e={max:e}),e||(e={});var t=this[l]=e.max;(!t||&quot;number&quot;!=typeof t||t&lt;=0)&amp;&amp;(this[l]=1/0);var r=e.length||T;&quot;function&quot;!=typeof r&amp;&amp;(r=T),this[c]=r,this[u]=e.stale||!1,this[d]=e.maxAge||0,this[h]=e.dispose,this[f]=e.noDisposeOnSet||!1,this.reset()}function g(e,t,r,n){var i=r.value;x(e,i)&amp;&amp;(P(e,r),e[u]||(i=void 0)),i&amp;&amp;t.call(n,i.value,i.key,e)}function S(e,t,r){var n=e[y].get(t);if(n){var i=n.value;x(e,i)?(P(e,n),e[u]||(i=void 0)):r&amp;&amp;e[m].unshiftNode(n),i&amp;&amp;(i=i.value)}return i}function x(e,t){if(!t||!t.maxAge&amp;&amp;!e[d])return!1;var r=Date.now()-t.now;return t.maxAge?r&gt;t.maxAge:e[d]&amp;&amp;r&gt;e[d]}function E(e){if(e[p]&gt;e[l])for(var t=e[m].tail;e[p]&gt;e[l]&amp;&amp;null!==t;){var r=t.prev;P(e,t),t=r}}function P(e,t){if(t){var r=t.value;e[h]&amp;&amp;e[h](r.key,r.value),e[p]-=r.length,e[y].delete(r.key),e[m].removeNode(t)}}function v(e,t,r,n,i){this.key=e,this.value=t,this.length=r,this.now=n,this.maxAge=i||0}Object.defineProperty(b.prototype,&quot;max&quot;,{set:function(e){(!e||&quot;number&quot;!=typeof e||e&lt;=0)&amp;&amp;(e=1/0),this[l]=e,E(this)},get:function(){return this[l]},enumerable:!0}),Object.defineProperty(b.prototype,&quot;allowStale&quot;,{set:function(e){this[u]=!!e},get:function(){return this[u]},enumerable:!0}),Object.defineProperty(b.prototype,&quot;maxAge&quot;,{set:function(e){(!e||&quot;number&quot;!=typeof e||e&lt;0)&amp;&amp;(e=0),this[d]=e,E(this)},get:function(){return this[d]},enumerable:!0}),Object.defineProperty(b.prototype,&quot;lengthCalculator&quot;,{set:function(e){&quot;function&quot;!=typeof e&amp;&amp;(e=T),e!==this[c]&amp;&amp;(this[c]=e,this[p]=0,this[m].forEach((function(e){e.length=this[c](e.value,e.key),this[p]+=e.length}),this)),E(this)},get:function(){return this[c]},enumerable:!0}),Object.defineProperty(b.prototype,&quot;length&quot;,{get:function(){return this[p]},enumerable:!0}),Object.defineProperty(b.prototype,&quot;itemCount&quot;,{get:function(){return this[m].length},enumerable:!0}),b.prototype.rforEach=function(e,t){t=t||this;for(var r=this[m].tail;null!==r;){var n=r.prev;g(this,e,r,t),r=n}},b.prototype.forEach=function(e,t){t=t||this;for(var r=this[m].head;null!==r;){var n=r.next;g(this,e,r,t),r=n}},b.prototype.keys=function(){return this[m].toArray().map((function(e){return e.key}),this)},b.prototype.values=function(){return this[m].toArray().map((function(e){return e.value}),this)},b.prototype.reset=function(){this[h]&amp;&amp;this[m]&amp;&amp;this[m].length&amp;&amp;this[m].forEach((function(e){this[h](e.key,e.value)}),this),this[y]=new s,this[m]=new o,this[p]=0},b.prototype.dump=function(){return this[m].map((function(e){if(!x(this,e))return{k:e.key,v:e.value,e:e.now+(e.maxAge||0)}}),this).toArray().filter((function(e){return e}))},b.prototype.dumpLru=function(){return this[m]},b.prototype.inspect=function(e,t){var r=&quot;LRUCache {&quot;,n=!1;this[u]&amp;&amp;(r+=&quot;</span><span class="s4">\n  </span><span class="s3">allowStale: true&quot;,n=!0);var i=this[l];i&amp;&amp;i!==1/0&amp;&amp;(n&amp;&amp;(r+=&quot;,&quot;),r+=&quot;</span><span class="s4">\n  </span><span class="s3">max: &quot;+a.inspect(i,t),n=!0);var s=this[d];s&amp;&amp;(n&amp;&amp;(r+=&quot;,&quot;),r+=&quot;</span><span class="s4">\n  </span><span class="s3">maxAge: &quot;+a.inspect(s,t),n=!0);var o=this[c];o&amp;&amp;o!==T&amp;&amp;(n&amp;&amp;(r+=&quot;,&quot;),r+=&quot;</span><span class="s4">\n  </span><span class="s3">length: &quot;+a.inspect(this[p],t),n=!0);var h=!1;return this[m].forEach((function(e){h?r+=&quot;,</span><span class="s4">\n  </span><span class="s3">&quot;:(n&amp;&amp;(r+=&quot;,</span><span class="s4">\n</span><span class="s3">&quot;),h=!0,r+=&quot;</span><span class="s4">\n  </span><span class="s3">&quot;);var i=a.inspect(e.key).split(&quot;</span><span class="s4">\n</span><span class="s3">&quot;).join(&quot;</span><span class="s4">\n  </span><span class="s3">&quot;),l={value:e.value};e.maxAge!==s&amp;&amp;(l.maxAge=e.maxAge),o!==T&amp;&amp;(l.length=e.length),x(this,e)&amp;&amp;(l.stale=!0),l=a.inspect(l,t).split(&quot;</span><span class="s4">\n</span><span class="s3">&quot;).join(&quot;</span><span class="s4">\n  </span><span class="s3">&quot;),r+=i+&quot; =&gt; &quot;+l})),(h||n)&amp;&amp;(r+=&quot;</span><span class="s4">\n</span><span class="s3">&quot;),r+=&quot;}&quot;},b.prototype.set=function(e,t,r){var n=(r=r||this[d])?Date.now():0,i=this[c](t,e);if(this[y].has(e)){if(i&gt;this[l])return P(this,this[y].get(e)),!1;var s=this[y].get(e).value;return this[h]&amp;&amp;(this[f]||this[h](e,s.value)),s.now=n,s.maxAge=r,s.value=t,this[p]+=i-s.length,s.length=i,this.get(e),E(this),!0}var a=new v(e,t,i,n,r);return a.length&gt;this[l]?(this[h]&amp;&amp;this[h](e,t),!1):(this[p]+=a.length,this[m].unshift(a),this[y].set(e,this[m].head),E(this),!0)},b.prototype.has=function(e){return!!this[y].has(e)&amp;&amp;!x(this,this[y].get(e).value)},b.prototype.get=function(e){return S(this,e,!0)},b.prototype.peek=function(e){return S(this,e,!1)},b.prototype.pop=function(){var e=this[m].tail;return e?(P(this,e),e.value):null},b.prototype.del=function(e){P(this,this[y].get(e))},b.prototype.load=function(e){this.reset();for(var t=Date.now(),r=e.length-1;r&gt;=0;r--){var n=e[r],i=n.e||0;if(0===i)this.set(n.k,n.v);else{var s=i-t;s&gt;0&amp;&amp;this.set(n.k,n.v,s)}}},b.prototype.prune=function(){var e=this;this[y].forEach((function(t,r){S(e,r,!1)}))}},1331:e=&gt;{var t=1e3,r=60*t,n=60*r,i=24*n;function s(e,t,r,n){var i=t&gt;=1.5*r;return Math.round(e/r)+&quot; &quot;+n+(i?&quot;s&quot;:&quot;&quot;)}e.exports=function(e,a){a=a||{};var o,l,p=typeof e;if(&quot;string&quot;===p&amp;&amp;e.length&gt;0)return function(e){if(!((e=String(e)).length&gt;100)){var s=/^(-?(?:</span><span class="s5">\d</span><span class="s3">+)?</span><span class="s5">\.</span><span class="s3">?</span><span class="s5">\d</span><span class="s3">+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(s){var a=parseFloat(s[1]);switch((s[2]||&quot;ms&quot;).toLowerCase()){case&quot;years&quot;:case&quot;year&quot;:case&quot;yrs&quot;:case&quot;yr&quot;:case&quot;y&quot;:return 315576e5*a;case&quot;weeks&quot;:case&quot;week&quot;:case&quot;w&quot;:return 6048e5*a;case&quot;days&quot;:case&quot;day&quot;:case&quot;d&quot;:return a*i;case&quot;hours&quot;:case&quot;hour&quot;:case&quot;hrs&quot;:case&quot;hr&quot;:case&quot;h&quot;:return a*n;case&quot;minutes&quot;:case&quot;minute&quot;:case&quot;mins&quot;:case&quot;min&quot;:case&quot;m&quot;:return a*r;case&quot;seconds&quot;:case&quot;second&quot;:case&quot;secs&quot;:case&quot;sec&quot;:case&quot;s&quot;:return a*t;case&quot;milliseconds&quot;:case&quot;millisecond&quot;:case&quot;msecs&quot;:case&quot;msec&quot;:case&quot;ms&quot;:return a;default:return}}}}(e);if(&quot;number&quot;===p&amp;&amp;isFinite(e))return a.long?(o=e,(l=Math.abs(o))&gt;=i?s(o,l,i,&quot;day&quot;):l&gt;=n?s(o,l,n,&quot;hour&quot;):l&gt;=r?s(o,l,r,&quot;minute&quot;):l&gt;=t?s(o,l,t,&quot;second&quot;):o+&quot; ms&quot;):function(e){var s=Math.abs(e);return s&gt;=i?Math.round(e/i)+&quot;d&quot;:s&gt;=n?Math.round(e/n)+&quot;h&quot;:s&gt;=r?Math.round(e/r)+&quot;m&quot;:s&gt;=t?Math.round(e/t)+&quot;s&quot;:e+&quot;ms&quot;}(e);throw new Error(&quot;val is not a non-empty string or a valid number. val=&quot;+JSON.stringify(e))}},397:e=&gt;{var t,r,n=e.exports={};function i(){throw new Error(&quot;setTimeout has not been defined&quot;)}function s(){throw new Error(&quot;clearTimeout has not been defined&quot;)}function a(e){if(t===setTimeout)return setTimeout(e,0);if((t===i||!t)&amp;&amp;setTimeout)return t=setTimeout,setTimeout(e,0);try{return t(e,0)}catch(r){try{return t.call(null,e,0)}catch(r){return t.call(this,e,0)}}}!function(){try{t=&quot;function&quot;==typeof setTimeout?setTimeout:i}catch(e){t=i}try{r=&quot;function&quot;==typeof clearTimeout?clearTimeout:s}catch(e){r=s}}();var o,l=[],p=!1,c=-1;function u(){p&amp;&amp;o&amp;&amp;(p=!1,o.length?l=o.concat(l):c=-1,l.length&amp;&amp;d())}function d(){if(!p){var e=a(u);p=!0;for(var t=l.length;t;){for(o=l,l=[];++c&lt;t;)o&amp;&amp;o[c].run();c=-1,t=l.length}o=null,p=!1,function(e){if(r===clearTimeout)return clearTimeout(e);if((r===s||!r)&amp;&amp;clearTimeout)return r=clearTimeout,clearTimeout(e);try{return r(e)}catch(t){try{return r.call(null,e)}catch(t){return r.call(this,e)}}}(e)}}function h(e,t){this.fun=e,this.array=t}function f(){}n.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length&gt;1)for(var r=1;r&lt;arguments.length;r++)t[r-1]=arguments[r];l.push(new h(e,t)),1!==l.length||p||a(d)},h.prototype.run=function(){this.fun.apply(null,this.array)},n.title=&quot;browser&quot;,n.browser=!0,n.env={},n.argv=[],n.version=&quot;&quot;,n.versions={},n.on=f,n.addListener=f,n.once=f,n.off=f,n.removeListener=f,n.removeAllListeners=f,n.emit=f,n.prependListener=f,n.prependOnceListener=f,n.listeners=function(e){return[]},n.binding=function(e){throw new Error(&quot;process.binding is not supported&quot;)},n.cwd=function(){return&quot;/&quot;},n.chdir=function(e){throw new Error(&quot;process.chdir is not supported&quot;)},n.umask=function(){return 0}},7745:(e,t,r)=&gt;{var n=r(397);&quot;pseudomap&quot;===n.env.npm_package_name&amp;&amp;&quot;test&quot;===n.env.npm_lifecycle_script&amp;&amp;(n.env.TEST_PSEUDOMAP=&quot;true&quot;),&quot;function&quot;!=typeof Map||n.env.TEST_PSEUDOMAP?e.exports=r(7503):e.exports=Map},7503:e=&gt;{var t=Object.prototype.hasOwnProperty;function r(e){if(!(this instanceof r))throw new TypeError(&quot;Constructor PseudoMap requires '</span><span class="s1">new</span><span class="s3">'&quot;);if(this.clear(),e)if(e instanceof r||&quot;function&quot;==typeof Map&amp;&amp;e instanceof Map)e.forEach((function(e,t){this.set(t,e)}),this);else{if(!Array.isArray(e))throw new TypeError(&quot;invalid argument&quot;);e.forEach((function(e){this.set(e[0],e[1])}),this)}}function n(e,t){return e===t||e!=e&amp;&amp;t!=t}function i(e,t,r){this.key=e,this.value=t,this._index=r}function s(e,r){for(var i=0,s=&quot;_&quot;+r,a=s;t.call(e,a);a=s+i++)if(n(e[a].key,r))return e[a]}e.exports=r,r.prototype.forEach=function(e,t){t=t||this,Object.keys(this._data).forEach((function(r){&quot;size&quot;!==r&amp;&amp;e.call(t,this._data[r].value,this._data[r].key)}),this)},r.prototype.has=function(e){return!!s(this._data,e)},r.prototype.get=function(e){var t=s(this._data,e);return t&amp;&amp;t.value},r.prototype.set=function(e,r){!function(e,r,s){for(var a=0,o=&quot;_&quot;+r,l=o;t.call(e,l);l=o+a++)if(n(e[l].key,r))return void(e[l].value=s);e.size++,e[l]=new i(r,s,l)}(this._data,e,r)},r.prototype.delete=function(e){var t=s(this._data,e);t&amp;&amp;(delete this._data[t._index],this._data.size--)},r.prototype.clear=function(){var e=Object.create(null);e.size=0,Object.defineProperty(this,&quot;_data&quot;,{value:e,enumerable:!1,configurable:!0,writable:!1})},Object.defineProperty(r.prototype,&quot;size&quot;,{get:function(){return this._data.size},set:function(e){},enumerable:!0,configurable:!0}),r.prototype.values=r.prototype.keys=r.prototype.entries=function(){throw new Error(&quot;iterators are not implemented in this version&quot;)}},6651:(e,t)=&gt;{t.getArg=function(e,t,r){if(t in e)return e[t];if(3===arguments.length)return r;throw new Error('&quot;'+t+'&quot; </span><span class="s0">is a required argument.</span><span class="s3">')};var r=/^(?:([</span><span class="s5">\w</span><span class="s3">+</span><span class="s5">\-</span><span class="s3">.]+):)?</span><span class="s5">\/\/</span><span class="s3">(?:(</span><span class="s5">\w</span><span class="s3">+:</span><span class="s5">\w</span><span class="s3">+)@)?([</span><span class="s5">\w</span><span class="s3">.-]*)(?::(</span><span class="s5">\d</span><span class="s3">+))?(.*)$/,n=/^data:.+</span><span class="s5">\,</span><span class="s3">.+$/;function i(e){var t=e.match(r);return t?{scheme:t[1],auth:t[2],host:t[3],port:t[4],path:t[5]}:null}function s(e){var t=&quot;&quot;;return e.scheme&amp;&amp;(t+=e.scheme+&quot;:&quot;),t+=&quot;//&quot;,e.auth&amp;&amp;(t+=e.auth+&quot;@&quot;),e.host&amp;&amp;(t+=e.host),e.port&amp;&amp;(t+=&quot;:&quot;+e.port),e.path&amp;&amp;(t+=e.path),t}t.urlParse=i,t.urlGenerate=s;var a,o,l=(a=function(e){var r=e,n=i(e);if(n){if(!n.path)return e;r=n.path}for(var a=t.isAbsolute(r),o=[],l=0,p=0;;){if(l=p,-1===(p=r.indexOf(&quot;/&quot;,l))){o.push(r.slice(l));break}for(o.push(r.slice(l,p));p&lt;r.length&amp;&amp;&quot;/&quot;===r[p];)p++}var c,u=0;for(p=o.length-1;p&gt;=0;p--)&quot;.&quot;===(c=o[p])?o.splice(p,1):&quot;..&quot;===c?u++:u&gt;0&amp;&amp;(&quot;&quot;===c?(o.splice(p+1,u),u=0):(o.splice(p,2),u--));return&quot;&quot;===(r=o.join(&quot;/&quot;))&amp;&amp;(r=a?&quot;/&quot;:&quot;.&quot;),n?(n.path=r,s(n)):r},o=[],function(e){for(var t=0;t&lt;o.length;t++)if(o[t].input===e){var r=o[0];return o[0]=o[t],o[t]=r,o[0].result}var n=a(e);return o.unshift({input:e,result:n}),o.length&gt;32&amp;&amp;o.pop(),n});function p(e,t){&quot;&quot;===e&amp;&amp;(e=&quot;.&quot;),&quot;&quot;===t&amp;&amp;(t=&quot;.&quot;);var r=i(t),a=i(e);if(a&amp;&amp;(e=a.path||&quot;/&quot;),r&amp;&amp;!r.scheme)return a&amp;&amp;(r.scheme=a.scheme),s(r);if(r||t.match(n))return t;if(a&amp;&amp;!a.host&amp;&amp;!a.path)return a.host=t,s(a);var o=&quot;/&quot;===t.charAt(0)?t:l(e.replace(/</span><span class="s5">\/</span><span class="s3">+$/,&quot;&quot;)+&quot;/&quot;+t);return a?(a.path=o,s(a)):o}t.normalize=l,t.join=p,t.isAbsolute=function(e){return&quot;/&quot;===e.charAt(0)||r.test(e)},t.relative=function(e,t){&quot;&quot;===e&amp;&amp;(e=&quot;.&quot;),e=e.replace(/</span><span class="s5">\/</span><span class="s3">$/,&quot;&quot;);for(var r=0;0!==t.indexOf(e+&quot;/&quot;);){var n=e.lastIndexOf(&quot;/&quot;);if(n&lt;0)return t;if((e=e.slice(0,n)).match(/^([^</span><span class="s5">\/</span><span class="s3">]+:</span><span class="s5">\/</span><span class="s3">)?</span><span class="s5">\/</span><span class="s3">*$/))return t;++r}return Array(r+1).join(&quot;../&quot;)+t.substr(e.length+1)};var c=!(&quot;__proto__&quot;in Object.create(null));function u(e){return e}function d(e){if(!e)return!1;var t=e.length;if(t&lt;9)return!1;if(95!==e.charCodeAt(t-1)||95!==e.charCodeAt(t-2)||111!==e.charCodeAt(t-3)||116!==e.charCodeAt(t-4)||111!==e.charCodeAt(t-5)||114!==e.charCodeAt(t-6)||112!==e.charCodeAt(t-7)||95!==e.charCodeAt(t-8)||95!==e.charCodeAt(t-9))return!1;for(var r=t-10;r&gt;=0;r--)if(36!==e.charCodeAt(r))return!1;return!0}function h(e,t){return e===t?0:null===e?1:null===t?-1:e&gt;t?1:-1}t.toSetString=c?u:function(e){return d(e)?&quot;$&quot;+e:e},t.fromSetString=c?u:function(e){return d(e)?e.slice(1):e},t.compareByOriginalPositions=function(e,t,r){var n=h(e.source,t.source);return 0!==n||0!=(n=e.originalLine-t.originalLine)||0!=(n=e.originalColumn-t.originalColumn)||r||0!=(n=e.generatedColumn-t.generatedColumn)||0!=(n=e.generatedLine-t.generatedLine)?n:h(e.name,t.name)},t.compareByOriginalPositionsNoSource=function(e,t,r){var n;return 0!=(n=e.originalLine-t.originalLine)||0!=(n=e.originalColumn-t.originalColumn)||r||0!=(n=e.generatedColumn-t.generatedColumn)||0!=(n=e.generatedLine-t.generatedLine)?n:h(e.name,t.name)},t.compareByGeneratedPositionsDeflated=function(e,t,r){var n=e.generatedLine-t.generatedLine;return 0!==n||0!=(n=e.generatedColumn-t.generatedColumn)||r||0!==(n=h(e.source,t.source))||0!=(n=e.originalLine-t.originalLine)||0!=(n=e.originalColumn-t.originalColumn)?n:h(e.name,t.name)},t.compareByGeneratedPositionsDeflatedNoLine=function(e,t,r){var n=e.generatedColumn-t.generatedColumn;return 0!==n||r||0!==(n=h(e.source,t.source))||0!=(n=e.originalLine-t.originalLine)||0!=(n=e.originalColumn-t.originalColumn)?n:h(e.name,t.name)},t.compareByGeneratedPositionsInflated=function(e,t){var r=e.generatedLine-t.generatedLine;return 0!==r||0!=(r=e.generatedColumn-t.generatedColumn)||0!==(r=h(e.source,t.source))||0!=(r=e.originalLine-t.originalLine)||0!=(r=e.originalColumn-t.originalColumn)?r:h(e.name,t.name)},t.parseSourceMapInput=function(e){return JSON.parse(e.replace(/^</span><span class="s5">\)</span><span class="s3">]}'</span><span class="s0">[^\n]*\n/,</span><span class="s3">&quot;&quot;</span><span class="s0">))},t.computeSourceURL=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(t=t||</span><span class="s3">&quot;&quot;</span><span class="s0">,e&amp;&amp;(</span><span class="s3">&quot;/&quot;</span><span class="s0">!==e[e.length-1]&amp;&amp;</span><span class="s3">&quot;/&quot;</span><span class="s0">!==t[</span><span class="s2">0</span><span class="s0">]&amp;&amp;(e+=</span><span class="s3">&quot;/&quot;</span><span class="s0">),t=e+t),r){</span><span class="s1">var </span><span class="s0">n=i(r);</span><span class="s1">if</span><span class="s0">(!n)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;sourceMapURL could not be parsed&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(n.path){</span><span class="s1">var </span><span class="s0">a=n.path.lastIndexOf(</span><span class="s3">&quot;/&quot;</span><span class="s0">);a&gt;=</span><span class="s2">0</span><span class="s0">&amp;&amp;(n.path=n.path.substring(</span><span class="s2">0</span><span class="s0">,a+</span><span class="s2">1</span><span class="s0">))}t=p(s(n),t)}</span><span class="s1">return </span><span class="s0">l(t)}},</span><span class="s2">7356</span><span class="s0">:</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">var </span><span class="s0">r,n,i;!</span><span class="s1">function</span><span class="s0">(s,a){</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;n=[],</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===(i=</span><span class="s3">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof</span><span class="s0">(r=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">function </span><span class="s0">e(e){</span><span class="s1">return </span><span class="s0">e.charAt(</span><span class="s2">0</span><span class="s0">).toUpperCase()+e.substring(</span><span class="s2">1</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">t(e){</span><span class="s1">return function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">[e]}}</span><span class="s1">var </span><span class="s0">r=[</span><span class="s3">&quot;isConstructor&quot;</span><span class="s0">,</span><span class="s3">&quot;isEval&quot;</span><span class="s0">,</span><span class="s3">&quot;isNative&quot;</span><span class="s0">,</span><span class="s3">&quot;isToplevel&quot;</span><span class="s0">],n=[</span><span class="s3">&quot;columnNumber&quot;</span><span class="s0">,</span><span class="s3">&quot;lineNumber&quot;</span><span class="s0">],i=[</span><span class="s3">&quot;fileName&quot;</span><span class="s0">,</span><span class="s3">&quot;functionName&quot;</span><span class="s0">,</span><span class="s3">&quot;source&quot;</span><span class="s0">],s=r.concat(n,i,[</span><span class="s3">&quot;args&quot;</span><span class="s0">]);</span><span class="s1">function </span><span class="s0">a(t){</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">r=</span><span class="s2">0</span><span class="s0">;r&lt;s.length;r++)</span><span class="s1">void </span><span class="s2">0</span><span class="s0">!==t[s[r]]&amp;&amp;</span><span class="s1">this</span><span class="s0">[</span><span class="s3">&quot;set&quot;</span><span class="s0">+e(s[r])](t[s[r]])}a.prototype={getArgs:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">.args},setArgs:</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;[object Array]&quot;</span><span class="s0">!==Object.prototype.toString.call(e))</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">&quot;Args must be an Array&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.args=e},getEvalOrigin:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">.evalOrigin},setEvalOrigin:</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e </span><span class="s1">instanceof </span><span class="s0">a)</span><span class="s1">this</span><span class="s0">.evalOrigin=e;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!(e </span><span class="s1">instanceof </span><span class="s0">Object))</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">&quot;Eval Origin must be an Object or StackFrame&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.evalOrigin=</span><span class="s1">new </span><span class="s0">a(e)}},toString:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.getFileName()||</span><span class="s3">&quot;&quot;</span><span class="s0">,t=</span><span class="s1">this</span><span class="s0">.getLineNumber()||</span><span class="s3">&quot;&quot;</span><span class="s0">,r=</span><span class="s1">this</span><span class="s0">.getColumnNumber()||</span><span class="s3">&quot;&quot;</span><span class="s0">,n=</span><span class="s1">this</span><span class="s0">.getFunctionName()||</span><span class="s3">&quot;&quot;</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.getIsEval()?e?</span><span class="s3">&quot;[eval] (&quot;</span><span class="s0">+e+</span><span class="s3">&quot;:&quot;</span><span class="s0">+t+</span><span class="s3">&quot;:&quot;</span><span class="s0">+r+</span><span class="s3">&quot;)&quot;</span><span class="s0">:</span><span class="s3">&quot;[eval]:&quot;</span><span class="s0">+t+</span><span class="s3">&quot;:&quot;</span><span class="s0">+r:n?n+</span><span class="s3">&quot; (&quot;</span><span class="s0">+e+</span><span class="s3">&quot;:&quot;</span><span class="s0">+t+</span><span class="s3">&quot;:&quot;</span><span class="s0">+r+</span><span class="s3">&quot;)&quot;</span><span class="s0">:e+</span><span class="s3">&quot;:&quot;</span><span class="s0">+t+</span><span class="s3">&quot;:&quot;</span><span class="s0">+r}},a.fromString=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">var </span><span class="s0">t=e.indexOf(</span><span class="s3">&quot;(&quot;</span><span class="s0">),r=e.lastIndexOf(</span><span class="s3">&quot;)&quot;</span><span class="s0">),n=e.substring(</span><span class="s2">0</span><span class="s0">,t),i=e.substring(t+</span><span class="s2">1</span><span class="s0">,r).split(</span><span class="s3">&quot;,&quot;</span><span class="s0">),s=e.substring(r+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">0</span><span class="s0">===s.indexOf(</span><span class="s3">&quot;@&quot;</span><span class="s0">))</span><span class="s1">var </span><span class="s0">o=/@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(s,</span><span class="s3">&quot;&quot;</span><span class="s0">),l=o[</span><span class="s2">1</span><span class="s0">],p=o[</span><span class="s2">2</span><span class="s0">],c=o[</span><span class="s2">3</span><span class="s0">];</span><span class="s1">return new </span><span class="s0">a({functionName:n,args:i||</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,fileName:l,lineNumber:p||</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,columnNumber:c||</span><span class="s1">void </span><span class="s2">0</span><span class="s0">})};</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">o=</span><span class="s2">0</span><span class="s0">;o&lt;r.length;o++)a.prototype[</span><span class="s3">&quot;get&quot;</span><span class="s0">+e(r[o])]=t(r[o]),a.prototype[</span><span class="s3">&quot;set&quot;</span><span class="s0">+e(r[o])]=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return function</span><span class="s0">(t){</span><span class="s1">this</span><span class="s0">[e]=Boolean(t)}}(r[o]);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">l=</span><span class="s2">0</span><span class="s0">;l&lt;n.length;l++)a.prototype[</span><span class="s3">&quot;get&quot;</span><span class="s0">+e(n[l])]=t(n[l]),a.prototype[</span><span class="s3">&quot;set&quot;</span><span class="s0">+e(n[l])]=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return function</span><span class="s0">(t){</span><span class="s1">if</span><span class="s0">(r=t,isNaN(parseFloat(r))||!isFinite(r))</span><span class="s1">throw new </span><span class="s0">TypeError(e+</span><span class="s3">&quot; must be a Number&quot;</span><span class="s0">);</span><span class="s1">var </span><span class="s0">r;</span><span class="s1">this</span><span class="s0">[e]=Number(t)}}(n[l]);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">p=</span><span class="s2">0</span><span class="s0">;p&lt;i.length;p++)a.prototype[</span><span class="s3">&quot;get&quot;</span><span class="s0">+e(i[p])]=t(i[p]),a.prototype[</span><span class="s3">&quot;set&quot;</span><span class="s0">+e(i[p])]=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return function</span><span class="s0">(t){</span><span class="s1">this</span><span class="s0">[e]=String(t)}}(i[p]);</span><span class="s1">return </span><span class="s0">a})?r.apply(t,n):r)||(e.exports=i)}()},</span><span class="s2">7319</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">397</span><span class="s0">);const i=r(</span><span class="s2">2037</span><span class="s0">),s=r(</span><span class="s2">6224</span><span class="s0">),a=r(</span><span class="s2">9358</span><span class="s0">),{env:o}=n;let l;</span><span class="s1">function </span><span class="s0">p(e){</span><span class="s1">return </span><span class="s2">0</span><span class="s0">!==e&amp;&amp;{level:e,hasBasic:!</span><span class="s2">0</span><span class="s0">,has256:e&gt;=</span><span class="s2">2</span><span class="s0">,has16m:e&gt;=</span><span class="s2">3</span><span class="s0">}}</span><span class="s1">function </span><span class="s0">c(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">0</span><span class="s0">===l)</span><span class="s1">return </span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(a(</span><span class="s3">&quot;color=16m&quot;</span><span class="s0">)||a(</span><span class="s3">&quot;color=full&quot;</span><span class="s0">)||a(</span><span class="s3">&quot;color=truecolor&quot;</span><span class="s0">))</span><span class="s1">return </span><span class="s2">3</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(a(</span><span class="s3">&quot;color=256&quot;</span><span class="s0">))</span><span class="s1">return </span><span class="s2">2</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e&amp;&amp;!t&amp;&amp;</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===l)</span><span class="s1">return </span><span class="s2">0</span><span class="s0">;const r=l||</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;dumb&quot;</span><span class="s0">===o.TERM)</span><span class="s1">return </span><span class="s0">r;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;win32&quot;</span><span class="s0">===n.platform){const e=i.release().split(</span><span class="s3">&quot;.&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">Number(e[</span><span class="s2">0</span><span class="s0">])&gt;=</span><span class="s2">10</span><span class="s0">&amp;&amp;Number(e[</span><span class="s2">2</span><span class="s0">])&gt;=</span><span class="s2">10586</span><span class="s0">?Number(e[</span><span class="s2">2</span><span class="s0">])&gt;=</span><span class="s2">14931</span><span class="s0">?</span><span class="s2">3</span><span class="s0">:</span><span class="s2">2</span><span class="s0">:</span><span class="s2">1</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;CI&quot;</span><span class="s1">in </span><span class="s0">o)</span><span class="s1">return</span><span class="s0">[</span><span class="s3">&quot;TRAVIS&quot;</span><span class="s0">,</span><span class="s3">&quot;CIRCLECI&quot;</span><span class="s0">,</span><span class="s3">&quot;APPVEYOR&quot;</span><span class="s0">,</span><span class="s3">&quot;GITLAB_CI&quot;</span><span class="s0">].some((e=&gt;e </span><span class="s1">in </span><span class="s0">o))||</span><span class="s3">&quot;codeship&quot;</span><span class="s0">===o.CI_NAME?</span><span class="s2">1</span><span class="s0">:r;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;TEAMCITY_VERSION&quot;</span><span class="s1">in </span><span class="s0">o)</span><span class="s1">return</span><span class="s0">/^(</span><span class="s2">9</span><span class="s0">\.(</span><span class="s2">0</span><span class="s0">*[</span><span class="s2">1</span><span class="s0">-</span><span class="s2">9</span><span class="s0">]\d*)\.|\d{</span><span class="s2">2</span><span class="s0">,}\.)/.test(o.TEAMCITY_VERSION)?</span><span class="s2">1</span><span class="s0">:</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;GITHUB_ACTIONS&quot;</span><span class="s1">in </span><span class="s0">o)</span><span class="s1">return </span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;truecolor&quot;</span><span class="s0">===o.COLORTERM)</span><span class="s1">return </span><span class="s2">3</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;TERM_PROGRAM&quot;</span><span class="s1">in </span><span class="s0">o){const e=parseInt((o.TERM_PROGRAM_VERSION||</span><span class="s3">&quot;&quot;</span><span class="s0">).split(</span><span class="s3">&quot;.&quot;</span><span class="s0">)[</span><span class="s2">0</span><span class="s0">],</span><span class="s2">10</span><span class="s0">);</span><span class="s1">switch</span><span class="s0">(o.TERM_PROGRAM){</span><span class="s1">case</span><span class="s3">&quot;iTerm.app&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e&gt;=</span><span class="s2">3</span><span class="s0">?</span><span class="s2">3</span><span class="s0">:</span><span class="s2">2</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;Apple_Terminal&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s2">2</span><span class="s0">}}</span><span class="s1">return</span><span class="s0">/-</span><span class="s2">256</span><span class="s0">(color)?$/i.test(o.TERM)?</span><span class="s2">2</span><span class="s0">:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(o.TERM)||</span><span class="s3">&quot;COLORTERM&quot;</span><span class="s1">in </span><span class="s0">o?</span><span class="s2">1</span><span class="s0">:r}a(</span><span class="s3">&quot;no-color&quot;</span><span class="s0">)||a(</span><span class="s3">&quot;no-colors&quot;</span><span class="s0">)||a(</span><span class="s3">&quot;color=false&quot;</span><span class="s0">)||a(</span><span class="s3">&quot;color=never&quot;</span><span class="s0">)?l=</span><span class="s2">0</span><span class="s0">:(a(</span><span class="s3">&quot;color&quot;</span><span class="s0">)||a(</span><span class="s3">&quot;colors&quot;</span><span class="s0">)||a(</span><span class="s3">&quot;color=true&quot;</span><span class="s0">)||a(</span><span class="s3">&quot;color=always&quot;</span><span class="s0">))&amp;&amp;(l=</span><span class="s2">1</span><span class="s0">),</span><span class="s3">&quot;FORCE_COLOR&quot;</span><span class="s1">in </span><span class="s0">o&amp;&amp;(l=</span><span class="s3">&quot;true&quot;</span><span class="s0">===o.FORCE_COLOR?</span><span class="s2">1</span><span class="s0">:</span><span class="s3">&quot;false&quot;</span><span class="s0">===o.FORCE_COLOR?</span><span class="s2">0</span><span class="s0">:</span><span class="s2">0</span><span class="s0">===o.FORCE_COLOR.length?</span><span class="s2">1</span><span class="s0">:Math.min(parseInt(o.FORCE_COLOR,</span><span class="s2">10</span><span class="s0">),</span><span class="s2">3</span><span class="s0">)),e.exports={supportsColor:</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">p(c(e,e&amp;&amp;e.isTTY))},stdout:p(c(!</span><span class="s2">0</span><span class="s0">,s.isatty(</span><span class="s2">1</span><span class="s0">))),stderr:p(c(!</span><span class="s2">0</span><span class="s0">,s.isatty(</span><span class="s2">2</span><span class="s0">)))}},</span><span class="s2">9358</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">397</span><span class="s0">);e.exports=(e,t=n.argv)=&gt;{const r=e.startsWith(</span><span class="s3">&quot;-&quot;</span><span class="s0">)?</span><span class="s3">&quot;&quot;</span><span class="s0">:</span><span class="s2">1</span><span class="s0">===e.length?</span><span class="s3">&quot;-&quot;</span><span class="s0">:</span><span class="s3">&quot;--&quot;</span><span class="s0">,i=t.indexOf(r+e),s=t.indexOf(</span><span class="s3">&quot;--&quot;</span><span class="s0">);</span><span class="s1">return</span><span class="s0">-</span><span class="s2">1</span><span class="s0">!==i&amp;&amp;(-</span><span class="s2">1</span><span class="s0">===s||i&lt;s)}},</span><span class="s2">1138</span><span class="s0">:e=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;let t=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">function </span><span class="s0">r(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!==t&amp;&amp;(t.property,</span><span class="s2">1</span><span class="s0">)){const e=t;</span><span class="s1">return </span><span class="s0">t=r.prototype=</span><span class="s1">null</span><span class="s0">,e}</span><span class="s1">return </span><span class="s0">t=r.prototype=</span><span class="s1">null</span><span class="s0">==e?Object.create(</span><span class="s1">null</span><span class="s0">):e,</span><span class="s1">new </span><span class="s0">r}r(),e.exports=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">r(e)}},</span><span class="s2">5986</span><span class="s0">:e=&gt;{</span><span class="s1">function </span><span class="s0">t(e){</span><span class="s1">var </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(r </span><span class="s1">instanceof </span><span class="s0">t||(r=</span><span class="s1">new </span><span class="s0">t),r.tail=</span><span class="s1">null</span><span class="s0">,r.head=</span><span class="s1">null</span><span class="s0">,r.length=</span><span class="s2">0</span><span class="s0">,e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.forEach)e.forEach((</span><span class="s1">function</span><span class="s0">(e){r.push(e)}));</span><span class="s1">else if</span><span class="s0">(arguments.length&gt;</span><span class="s2">0</span><span class="s0">)</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">n=</span><span class="s2">0</span><span class="s0">,i=arguments.length;n&lt;i;n++)r.push(arguments[n]);</span><span class="s1">return </span><span class="s0">r}</span><span class="s1">function </span><span class="s0">r(e,t){e.tail=</span><span class="s1">new </span><span class="s0">i(t,e.tail,</span><span class="s1">null</span><span class="s0">,e),e.head||(e.head=e.tail),e.length++}</span><span class="s1">function </span><span class="s0">n(e,t){e.head=</span><span class="s1">new </span><span class="s0">i(t,</span><span class="s1">null</span><span class="s0">,e.head,e),e.tail||(e.tail=e.head),e.length++}</span><span class="s1">function </span><span class="s0">i(e,t,r,n){</span><span class="s1">if</span><span class="s0">(!(</span><span class="s1">this instanceof </span><span class="s0">i))</span><span class="s1">return new </span><span class="s0">i(e,t,r,n);</span><span class="s1">this</span><span class="s0">.list=n,</span><span class="s1">this</span><span class="s0">.value=e,t?(t.next=</span><span class="s1">this</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.prev=t):</span><span class="s1">this</span><span class="s0">.prev=</span><span class="s1">null</span><span class="s0">,r?(r.prev=</span><span class="s1">this</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next=r):</span><span class="s1">this</span><span class="s0">.next=</span><span class="s1">null</span><span class="s0">}e.exports=t,t.Node=i,t.create=t,t.prototype.removeNode=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e.list!==</span><span class="s1">this</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;removing node which does not belong to this list&quot;</span><span class="s0">);</span><span class="s1">var </span><span class="s0">t=e.next,r=e.prev;t&amp;&amp;(t.prev=r),r&amp;&amp;(r.next=t),e===</span><span class="s1">this</span><span class="s0">.head&amp;&amp;(</span><span class="s1">this</span><span class="s0">.head=t),e===</span><span class="s1">this</span><span class="s0">.tail&amp;&amp;(</span><span class="s1">this</span><span class="s0">.tail=r),e.list.length--,e.next=</span><span class="s1">null</span><span class="s0">,e.prev=</span><span class="s1">null</span><span class="s0">,e.list=</span><span class="s1">null</span><span class="s0">},t.prototype.unshiftNode=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e!==</span><span class="s1">this</span><span class="s0">.head){e.list&amp;&amp;e.list.removeNode(e);</span><span class="s1">var </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.head;e.list=</span><span class="s1">this</span><span class="s0">,e.next=t,t&amp;&amp;(t.prev=e),</span><span class="s1">this</span><span class="s0">.head=e,</span><span class="s1">this</span><span class="s0">.tail||(</span><span class="s1">this</span><span class="s0">.tail=e),</span><span class="s1">this</span><span class="s0">.length++}},t.prototype.pushNode=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e!==</span><span class="s1">this</span><span class="s0">.tail){e.list&amp;&amp;e.list.removeNode(e);</span><span class="s1">var </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.tail;e.list=</span><span class="s1">this</span><span class="s0">,e.prev=t,t&amp;&amp;(t.next=e),</span><span class="s1">this</span><span class="s0">.tail=e,</span><span class="s1">this</span><span class="s0">.head||(</span><span class="s1">this</span><span class="s0">.head=e),</span><span class="s1">this</span><span class="s0">.length++}},t.prototype.push=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=</span><span class="s2">0</span><span class="s0">,t=arguments.length;e&lt;t;e++)r(</span><span class="s1">this</span><span class="s0">,arguments[e]);</span><span class="s1">return this</span><span class="s0">.length},t.prototype.unshift=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=</span><span class="s2">0</span><span class="s0">,t=arguments.length;e&lt;t;e++)n(</span><span class="s1">this</span><span class="s0">,arguments[e]);</span><span class="s1">return this</span><span class="s0">.length},t.prototype.pop=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tail){</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.tail.value;</span><span class="s1">return this</span><span class="s0">.tail=</span><span class="s1">this</span><span class="s0">.tail.prev,</span><span class="s1">this</span><span class="s0">.tail?</span><span class="s1">this</span><span class="s0">.tail.next=</span><span class="s1">null</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.head=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.length--,e}},t.prototype.shift=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.head){</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.head.value;</span><span class="s1">return this</span><span class="s0">.head=</span><span class="s1">this</span><span class="s0">.head.next,</span><span class="s1">this</span><span class="s0">.head?</span><span class="s1">this</span><span class="s0">.head.prev=</span><span class="s1">null</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.tail=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.length--,e}},t.prototype.forEach=</span><span class="s1">function</span><span class="s0">(e,t){t=t||</span><span class="s1">this</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.head,n=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">null</span><span class="s0">!==r;n++)e.call(t,r.value,n,</span><span class="s1">this</span><span class="s0">),r=r.next},t.prototype.forEachReverse=</span><span class="s1">function</span><span class="s0">(e,t){t=t||</span><span class="s1">this</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.tail,n=</span><span class="s1">this</span><span class="s0">.length-1;</span><span class="s1">null</span><span class="s0">!==r;n--)e.call(t,r.value,n,</span><span class="s1">this</span><span class="s0">),r=r.prev},t.prototype.get=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">t=</span><span class="s2">0</span><span class="s0">,r=</span><span class="s1">this</span><span class="s0">.head;</span><span class="s1">null</span><span class="s0">!==r&amp;&amp;t&lt;e;t++)r=r.next;</span><span class="s1">if</span><span class="s0">(t===e&amp;&amp;</span><span class="s1">null</span><span class="s0">!==r)</span><span class="s1">return </span><span class="s0">r.value},t.prototype.getReverse=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">t=</span><span class="s2">0</span><span class="s0">,r=</span><span class="s1">this</span><span class="s0">.tail;</span><span class="s1">null</span><span class="s0">!==r&amp;&amp;t&lt;e;t++)r=r.prev;</span><span class="s1">if</span><span class="s0">(t===e&amp;&amp;</span><span class="s1">null</span><span class="s0">!==r)</span><span class="s1">return </span><span class="s0">r.value},t.prototype.map=</span><span class="s1">function</span><span class="s0">(e,r){r=r||</span><span class="s1">this</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">new </span><span class="s0">t,i=</span><span class="s1">this</span><span class="s0">.head;</span><span class="s1">null</span><span class="s0">!==i;)n.push(e.call(r,i.value,</span><span class="s1">this</span><span class="s0">)),i=i.next;</span><span class="s1">return </span><span class="s0">n},t.prototype.mapReverse=</span><span class="s1">function</span><span class="s0">(e,r){r=r||</span><span class="s1">this</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">new </span><span class="s0">t,i=</span><span class="s1">this</span><span class="s0">.tail;</span><span class="s1">null</span><span class="s0">!==i;)n.push(e.call(r,i.value,</span><span class="s1">this</span><span class="s0">)),i=i.prev;</span><span class="s1">return </span><span class="s0">n},t.prototype.reduce=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">var </span><span class="s0">r,n=</span><span class="s1">this</span><span class="s0">.head;</span><span class="s1">if</span><span class="s0">(arguments.length&gt;</span><span class="s2">1</span><span class="s0">)r=t;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.head)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">&quot;Reduce of empty list with no initial value&quot;</span><span class="s0">);n=</span><span class="s1">this</span><span class="s0">.head.next,r=</span><span class="s1">this</span><span class="s0">.head.value}</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">null</span><span class="s0">!==n;i++)r=e(r,n.value,i),n=n.next;</span><span class="s1">return </span><span class="s0">r},t.prototype.reduceReverse=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">var </span><span class="s0">r,n=</span><span class="s1">this</span><span class="s0">.tail;</span><span class="s1">if</span><span class="s0">(arguments.length&gt;</span><span class="s2">1</span><span class="s0">)r=t;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.tail)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">&quot;Reduce of empty list with no initial value&quot;</span><span class="s0">);n=</span><span class="s1">this</span><span class="s0">.tail.prev,r=</span><span class="s1">this</span><span class="s0">.tail.value}</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i=</span><span class="s1">this</span><span class="s0">.length-1;</span><span class="s1">null</span><span class="s0">!==n;i--)r=e(r,n.value,i),n=n.prev;</span><span class="s1">return </span><span class="s0">r},t.prototype.toArray=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">Array(</span><span class="s1">this</span><span class="s0">.length),t=</span><span class="s2">0</span><span class="s0">,r=</span><span class="s1">this</span><span class="s0">.head;</span><span class="s1">null</span><span class="s0">!==r;t++)e[t]=r.value,r=r.next;</span><span class="s1">return </span><span class="s0">e},t.prototype.toArrayReverse=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">Array(</span><span class="s1">this</span><span class="s0">.length),t=</span><span class="s2">0</span><span class="s0">,r=</span><span class="s1">this</span><span class="s0">.tail;</span><span class="s1">null</span><span class="s0">!==r;t++)e[t]=r.value,r=r.prev;</span><span class="s1">return </span><span class="s0">e},t.prototype.slice=</span><span class="s1">function</span><span class="s0">(e,r){(r=r||</span><span class="s1">this</span><span class="s0">.length)&lt;</span><span class="s2">0</span><span class="s0">&amp;&amp;(r+=</span><span class="s1">this</span><span class="s0">.length),(e=e||</span><span class="s2">0</span><span class="s0">)&lt;</span><span class="s2">0</span><span class="s0">&amp;&amp;(e+=</span><span class="s1">this</span><span class="s0">.length);</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">new </span><span class="s0">t;</span><span class="s1">if</span><span class="s0">(r&lt;e||r&lt;</span><span class="s2">0</span><span class="s0">)</span><span class="s1">return </span><span class="s0">n;e&lt;</span><span class="s2">0</span><span class="s0">&amp;&amp;(e=</span><span class="s2">0</span><span class="s0">),r&gt;</span><span class="s1">this</span><span class="s0">.length&amp;&amp;(r=</span><span class="s1">this</span><span class="s0">.length);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i=</span><span class="s2">0</span><span class="s0">,s=</span><span class="s1">this</span><span class="s0">.head;</span><span class="s1">null</span><span class="s0">!==s&amp;&amp;i&lt;e;i++)s=s.next;</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">null</span><span class="s0">!==s&amp;&amp;i&lt;r;i++,s=s.next)n.push(s.value);</span><span class="s1">return </span><span class="s0">n},t.prototype.sliceReverse=</span><span class="s1">function</span><span class="s0">(e,r){(r=r||</span><span class="s1">this</span><span class="s0">.length)&lt;</span><span class="s2">0</span><span class="s0">&amp;&amp;(r+=</span><span class="s1">this</span><span class="s0">.length),(e=e||</span><span class="s2">0</span><span class="s0">)&lt;</span><span class="s2">0</span><span class="s0">&amp;&amp;(e+=</span><span class="s1">this</span><span class="s0">.length);</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">new </span><span class="s0">t;</span><span class="s1">if</span><span class="s0">(r&lt;e||r&lt;</span><span class="s2">0</span><span class="s0">)</span><span class="s1">return </span><span class="s0">n;e&lt;</span><span class="s2">0</span><span class="s0">&amp;&amp;(e=</span><span class="s2">0</span><span class="s0">),r&gt;</span><span class="s1">this</span><span class="s0">.length&amp;&amp;(r=</span><span class="s1">this</span><span class="s0">.length);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i=</span><span class="s1">this</span><span class="s0">.length,s=</span><span class="s1">this</span><span class="s0">.tail;</span><span class="s1">null</span><span class="s0">!==s&amp;&amp;i&gt;r;i--)s=s.prev;</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">null</span><span class="s0">!==s&amp;&amp;i&gt;e;i--,s=s.prev)n.push(s.value);</span><span class="s1">return </span><span class="s0">n},t.prototype.reverse=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.head,t=</span><span class="s1">this</span><span class="s0">.tail,r=e;</span><span class="s1">null</span><span class="s0">!==r;r=r.prev){</span><span class="s1">var </span><span class="s0">n=r.prev;r.prev=r.next,r.next=n}</span><span class="s1">return this</span><span class="s0">.head=t,</span><span class="s1">this</span><span class="s0">.tail=e,</span><span class="s1">this</span><span class="s0">}},</span><span class="s2">8404</span><span class="s0">:(e,t)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;const r=/^[ \t]+$/;t.</span><span class="s1">default</span><span class="s0">=class{constructor(e){</span><span class="s1">this</span><span class="s0">._map=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._buf=[],</span><span class="s1">this</span><span class="s0">._last=</span><span class="s3">&quot;&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._queue=[],</span><span class="s1">this</span><span class="s0">._position={line:</span><span class="s2">1</span><span class="s0">,column:</span><span class="s2">0</span><span class="s0">},</span><span class="s1">this</span><span class="s0">._sourcePosition={identifierName:</span><span class="s1">null</span><span class="s0">,line:</span><span class="s1">null</span><span class="s0">,column:</span><span class="s1">null</span><span class="s0">,filename:</span><span class="s1">null</span><span class="s0">},</span><span class="s1">this</span><span class="s0">._disallowedPop=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._map=e}get(){</span><span class="s1">this</span><span class="s0">._flush();const e=</span><span class="s1">this</span><span class="s0">._map,t={code:</span><span class="s1">this</span><span class="s0">._buf.join(</span><span class="s3">&quot;&quot;</span><span class="s0">).trimRight(),map:</span><span class="s1">null</span><span class="s0">,rawMappings:</span><span class="s1">null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:e.getRawMappings()};</span><span class="s1">return </span><span class="s0">e&amp;&amp;Object.defineProperty(t,</span><span class="s3">&quot;map&quot;</span><span class="s0">,{configurable:!</span><span class="s2">0</span><span class="s0">,enumerable:!</span><span class="s2">0</span><span class="s0">,get(){</span><span class="s1">return this</span><span class="s0">.map=e.get()},set(e){Object.defineProperty(</span><span class="s1">this</span><span class="s0">,</span><span class="s3">&quot;map&quot;</span><span class="s0">,{value:e,writable:!</span><span class="s2">0</span><span class="s0">})}}),t}append(e){</span><span class="s1">this</span><span class="s0">._flush();const{line:t,column:r,filename:n,identifierName:i,force:s}=</span><span class="s1">this</span><span class="s0">._sourcePosition;</span><span class="s1">this</span><span class="s0">._append(e,t,r,i,n,s)}queue(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">===e)</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">._queue.length&gt;</span><span class="s2">0</span><span class="s0">&amp;&amp;r.test(</span><span class="s1">this</span><span class="s0">._queue[</span><span class="s2">0</span><span class="s0">][</span><span class="s2">0</span><span class="s0">]);)</span><span class="s1">this</span><span class="s0">._queue.shift();const{line:t,column:n,filename:i,identifierName:s,force:a}=</span><span class="s1">this</span><span class="s0">._sourcePosition;</span><span class="s1">this</span><span class="s0">._queue.unshift([e,t,n,s,i,a])}_flush(){let e;</span><span class="s1">for</span><span class="s0">(;e=</span><span class="s1">this</span><span class="s0">._queue.pop();)</span><span class="s1">this</span><span class="s0">._append(...e)}_append(e,t,r,n,i,s){</span><span class="s1">this</span><span class="s0">._buf.push(e),</span><span class="s1">this</span><span class="s0">._last=e[e.length-1];let a=e.indexOf(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">),o=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s2">0</span><span class="s0">!==a&amp;&amp;</span><span class="s1">this</span><span class="s0">._mark(t,r,n,i,s);-</span><span class="s2">1</span><span class="s0">!==a;)</span><span class="s1">this</span><span class="s0">._position.line++,</span><span class="s1">this</span><span class="s0">._position.column=</span><span class="s2">0</span><span class="s0">,o=a+</span><span class="s2">1</span><span class="s0">,o&lt;e.length&amp;&amp;</span><span class="s1">this</span><span class="s0">._mark(++t,</span><span class="s2">0</span><span class="s0">,n,i,s),a=e.indexOf(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">,o);</span><span class="s1">this</span><span class="s0">._position.column+=e.length-o}_mark(e,t,r,n,i){</span><span class="s1">var </span><span class="s0">s;</span><span class="s1">null</span><span class="s0">==(s=</span><span class="s1">this</span><span class="s0">._map)||s.mark(</span><span class="s1">this</span><span class="s0">._position.line,</span><span class="s1">this</span><span class="s0">._position.column,e,t,r,n,i)}removeTrailingNewline(){</span><span class="s1">this</span><span class="s0">._queue.length&gt;</span><span class="s2">0</span><span class="s0">&amp;&amp;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">._queue[</span><span class="s2">0</span><span class="s0">][</span><span class="s2">0</span><span class="s0">]&amp;&amp;</span><span class="s1">this</span><span class="s0">._queue.shift()}removeLastSemicolon(){</span><span class="s1">this</span><span class="s0">._queue.length&gt;</span><span class="s2">0</span><span class="s0">&amp;&amp;</span><span class="s3">&quot;;&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">._queue[</span><span class="s2">0</span><span class="s0">][</span><span class="s2">0</span><span class="s0">]&amp;&amp;</span><span class="s1">this</span><span class="s0">._queue.shift()}endsWith(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">1</span><span class="s0">===e.length){let t;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">._queue.length&gt;</span><span class="s2">0</span><span class="s0">){const e=</span><span class="s1">this</span><span class="s0">._queue[</span><span class="s2">0</span><span class="s0">][</span><span class="s2">0</span><span class="s0">];t=e[e.length-1]}</span><span class="s1">else </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">._last;</span><span class="s1">return </span><span class="s0">t===e}const t=</span><span class="s1">this</span><span class="s0">._last+</span><span class="s1">this</span><span class="s0">._queue.reduce(((e,t)=&gt;t[</span><span class="s2">0</span><span class="s0">]+e),</span><span class="s3">&quot;&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">e.length&lt;=t.length&amp;&amp;t.slice(-e.length)===e}hasContent(){</span><span class="s1">return this</span><span class="s0">._queue.length&gt;</span><span class="s2">0</span><span class="s0">||!!</span><span class="s1">this</span><span class="s0">._last}exactSource(e,t){</span><span class="s1">this</span><span class="s0">.source(</span><span class="s3">&quot;start&quot;</span><span class="s0">,e,!</span><span class="s2">0</span><span class="s0">),t(),</span><span class="s1">this</span><span class="s0">.source(</span><span class="s3">&quot;end&quot;</span><span class="s0">,e),</span><span class="s1">this</span><span class="s0">._disallowPop(</span><span class="s3">&quot;start&quot;</span><span class="s0">,e)}source(e,t,r){e&amp;&amp;!t||</span><span class="s1">this</span><span class="s0">._normalizePosition(e,t,</span><span class="s1">this</span><span class="s0">._sourcePosition,r)}withSource(e,t,r){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._map)</span><span class="s1">return </span><span class="s0">r();const n=</span><span class="s1">this</span><span class="s0">._sourcePosition.line,i=</span><span class="s1">this</span><span class="s0">._sourcePosition.column,s=</span><span class="s1">this</span><span class="s0">._sourcePosition.filename,a=</span><span class="s1">this</span><span class="s0">._sourcePosition.identifierName;</span><span class="s1">this</span><span class="s0">.source(e,t),r(),</span><span class="s1">this</span><span class="s0">._sourcePosition.force&amp;&amp;</span><span class="s1">this</span><span class="s0">._sourcePosition.line===n&amp;&amp;</span><span class="s1">this</span><span class="s0">._sourcePosition.column===i&amp;&amp;</span><span class="s1">this</span><span class="s0">._sourcePosition.filename===s||</span><span class="s1">this</span><span class="s0">._disallowedPop&amp;&amp;</span><span class="s1">this</span><span class="s0">._disallowedPop.line===n&amp;&amp;</span><span class="s1">this</span><span class="s0">._disallowedPop.column===i&amp;&amp;</span><span class="s1">this</span><span class="s0">._disallowedPop.filename===s||(</span><span class="s1">this</span><span class="s0">._sourcePosition.line=n,</span><span class="s1">this</span><span class="s0">._sourcePosition.column=i,</span><span class="s1">this</span><span class="s0">._sourcePosition.filename=s,</span><span class="s1">this</span><span class="s0">._sourcePosition.identifierName=a,</span><span class="s1">this</span><span class="s0">._sourcePosition.force=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._disallowedPop=</span><span class="s1">null</span><span class="s0">)}_disallowPop(e,t){e&amp;&amp;!t||(</span><span class="s1">this</span><span class="s0">._disallowedPop=</span><span class="s1">this</span><span class="s0">._normalizePosition(e,t))}_normalizePosition(e,t,r,n){const i=t?t[e]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===r&amp;&amp;(r={identifierName:</span><span class="s1">null</span><span class="s0">,line:</span><span class="s1">null</span><span class="s0">,column:</span><span class="s1">null</span><span class="s0">,filename:</span><span class="s1">null</span><span class="s0">,force:!</span><span class="s2">1</span><span class="s0">});const s=r.line,a=r.column,o=r.filename;</span><span class="s1">return </span><span class="s0">r.identifierName=</span><span class="s3">&quot;start&quot;</span><span class="s0">===e&amp;&amp;(</span><span class="s1">null</span><span class="s0">==t?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.identifierName)||</span><span class="s1">null</span><span class="s0">,r.line=</span><span class="s1">null</span><span class="s0">==i?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:i.line,r.column=</span><span class="s1">null</span><span class="s0">==i?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:i.column,r.filename=</span><span class="s1">null</span><span class="s0">==t?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.filename,(n||r.line!==s||r.column!==a||r.filename!==o)&amp;&amp;(r.force=n),r}getCurrentColumn(){const e=</span><span class="s1">this</span><span class="s0">._queue.reduce(((e,t)=&gt;t[</span><span class="s2">0</span><span class="s0">]+e),</span><span class="s3">&quot;&quot;</span><span class="s0">),t=e.lastIndexOf(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">);</span><span class="s1">return</span><span class="s0">-</span><span class="s2">1</span><span class="s0">===t?</span><span class="s1">this</span><span class="s0">._position.column+e.length:e.length-1-t}getCurrentLine(){const e=</span><span class="s1">this</span><span class="s0">._queue.reduce(((e,t)=&gt;t[</span><span class="s2">0</span><span class="s0">]+e),</span><span class="s3">&quot;&quot;</span><span class="s0">);let t=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s2">0</span><span class="s0">;r&lt;e.length;r++)</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">===e[r]&amp;&amp;t++;</span><span class="s1">return this</span><span class="s0">._position.line+t}}},</span><span class="s2">3762</span><span class="s0">:(e,t)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.File=</span><span class="s1">function</span><span class="s0">(e){e.program&amp;&amp;</span><span class="s1">this</span><span class="s0">.print(e.program.interpreter,e),</span><span class="s1">this</span><span class="s0">.print(e.program,e)},t.Program=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">this</span><span class="s0">.printInnerComments(e,!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.printSequence(e.directives,e),e.directives&amp;&amp;e.directives.length&amp;&amp;</span><span class="s1">this</span><span class="s0">.newline(),</span><span class="s1">this</span><span class="s0">.printSequence(e.body,e)},t.BlockStatement=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">var </span><span class="s0">t;</span><span class="s1">this</span><span class="s0">.token(</span><span class="s3">&quot;{&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.printInnerComments(e);const r=</span><span class="s1">null</span><span class="s0">==(t=e.directives)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.length;e.body.length||r?(</span><span class="s1">this</span><span class="s0">.newline(),</span><span class="s1">this</span><span class="s0">.printSequence(e.directives,e,{indent:!</span><span class="s2">0</span><span class="s0">}),r&amp;&amp;</span><span class="s1">this</span><span class="s0">.newline(),</span><span class="s1">this</span><span class="s0">.printSequence(e.body,e,{indent:!</span><span class="s2">0</span><span class="s0">}),</span><span class="s1">this</span><span class="s0">.removeTrailingNewline(),</span><span class="s1">this</span><span class="s0">.source(</span><span class="s3">&quot;end&quot;</span><span class="s0">,e.loc),</span><span class="s1">this</span><span class="s0">.endsWith(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.newline(),</span><span class="s1">this</span><span class="s0">.rightBrace()):(</span><span class="s1">this</span><span class="s0">.source(</span><span class="s3">&quot;end&quot;</span><span class="s0">,e.loc),</span><span class="s1">this</span><span class="s0">.token(</span><span class="s3">&quot;}&quot;</span><span class="s0">))},t.Noop=</span><span class="s1">function</span><span class="s0">(){},t.Directive=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">this</span><span class="s0">.print(e.value,e),</span><span class="s1">this</span><span class="s0">.semicolon()},t.DirectiveLiteral=</span><span class="s1">function</span><span class="s0">(e){const t=</span><span class="s1">this</span><span class="s0">.getPossibleRaw(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=t)</span><span class="s1">return void this</span><span class="s0">.token(t);const{value:i}=e;</span><span class="s1">if</span><span class="s0">(n.test(i)){</span><span class="s1">if</span><span class="s0">(r.test(i))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.token(`</span><span class="s3">'${i}'</span><span class="s0">`)}</span><span class="s1">else this</span><span class="s0">.token(`</span><span class="s3">&quot;${i}&quot;</span><span class="s0">`)},t.InterpreterDirective=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">this</span><span class="s0">.token(`#!${e.value}\n`)},t.Placeholder=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">this</span><span class="s0">.token(</span><span class="s3">&quot;%%&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.print(e.name),</span><span class="s1">this</span><span class="s0">.token(</span><span class="s3">&quot;%%&quot;</span><span class="s0">),</span><span class="s3">&quot;Statement&quot;</span><span class="s0">===e.expectedNode&amp;&amp;</span><span class="s1">this</span><span class="s0">.semicolon()};const r=/(?:^|[^\\])(?:\\\\)*</span><span class="s3">'/,n=/(?:^|[^</span><span class="s4">\\</span><span class="s3">])(?:</span><span class="s4">\\\\</span><span class="s3">)*&quot;/},9570:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.ClassExpression=t.ClassDeclaration=function(e,t){this.format.decoratorsBeforeExport&amp;&amp;(n.isExportDefaultDeclaration(t)||n.isExportNamedDeclaration(t))||this.printJoin(e.decorators,e),e.declare&amp;&amp;(this.word(&quot;declare&quot;),this.space()),e.abstract&amp;&amp;(this.word(&quot;abstract&quot;),this.space()),this.word(&quot;class&quot;),e.id&amp;&amp;(this.space(),this.print(e.id,e)),this.print(e.typeParameters,e),e.superClass&amp;&amp;(this.space(),this.word(&quot;extends&quot;),this.space(),this.print(e.superClass,e),this.print(e.superTypeParameters,e)),e.implements&amp;&amp;(this.space(),this.word(&quot;implements&quot;),this.space(),this.printList(e.implements,e)),this.space(),this.print(e.body,e)},t.ClassBody=function(e){this.token(&quot;{&quot;),this.printInnerComments(e),0===e.body.length?this.token(&quot;}&quot;):(this.newline(),this.indent(),this.printSequence(e.body,e),this.dedent(),this.endsWith(&quot;</span><span class="s4">\n</span><span class="s3">&quot;)||this.newline(),this.rightBrace())},t.ClassProperty=function(e){this.printJoin(e.decorators,e),this.tsPrintClassMemberModifiers(e,!0),e.computed?(this.token(&quot;[&quot;),this.print(e.key,e),this.token(&quot;]&quot;)):(this._variance(e),this.print(e.key,e)),e.optional&amp;&amp;this.token(&quot;?&quot;),e.definite&amp;&amp;this.token(&quot;!&quot;),this.print(e.typeAnnotation,e),e.value&amp;&amp;(this.space(),this.token(&quot;=&quot;),this.space(),this.print(e.value,e)),this.semicolon()},t.ClassPrivateProperty=function(e){this.printJoin(e.decorators,e),e.static&amp;&amp;(this.word(&quot;static&quot;),this.space()),this.print(e.key,e),this.print(e.typeAnnotation,e),e.value&amp;&amp;(this.space(),this.token(&quot;=&quot;),this.space(),this.print(e.value,e)),this.semicolon()},t.ClassMethod=function(e){this._classMethodHead(e),this.space(),this.print(e.body,e)},t.ClassPrivateMethod=function(e){this._classMethodHead(e),this.space(),this.print(e.body,e)},t._classMethodHead=function(e){this.printJoin(e.decorators,e),this.tsPrintClassMemberModifiers(e,!1),this._methodHead(e)},t.StaticBlock=function(e){this.word(&quot;static&quot;),this.space(),this.token(&quot;{&quot;),0===e.body.length?this.token(&quot;}&quot;):(this.newline(),this.printSequence(e.body,e,{indent:!0}),this.rightBrace())};var n=function(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;object&quot;!=typeof e&amp;&amp;&quot;function&quot;!=typeof e)return{default:e};var t=i();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var a=n?Object.getOwnPropertyDescriptor(e,s):null;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}return r.default=e,t&amp;&amp;t.set(e,r),r}(r(1710));function i(){if(&quot;function&quot;!=typeof WeakMap)return null;var e=new WeakMap;return i=function(){return e},e}},9901:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.UnaryExpression=function(e){&quot;void&quot;===e.operator||&quot;delete&quot;===e.operator||&quot;typeof&quot;===e.operator||&quot;throw&quot;===e.operator?(this.word(e.operator),this.space()):this.token(e.operator),this.print(e.argument,e)},t.DoExpression=function(e){this.word(&quot;do&quot;),this.space(),this.print(e.body,e)},t.ParenthesizedExpression=function(e){this.token(&quot;(&quot;),this.print(e.expression,e),this.token(&quot;)&quot;)},t.UpdateExpression=function(e){e.prefix?(this.token(e.operator),this.print(e.argument,e)):(this.startTerminatorless(!0),this.print(e.argument,e),this.endTerminatorless(),this.token(e.operator))},t.ConditionalExpression=function(e){this.print(e.test,e),this.space(),this.token(&quot;?&quot;),this.space(),this.print(e.consequent,e),this.space(),this.token(&quot;:&quot;),this.space(),this.print(e.alternate,e)},t.NewExpression=function(e,t){this.word(&quot;new&quot;),this.space(),this.print(e.callee,e),(!this.format.minified||0!==e.arguments.length||e.optional||n.isCallExpression(t,{callee:e})||n.isMemberExpression(t)||n.isNewExpression(t))&amp;&amp;(this.print(e.typeArguments,e),this.print(e.typeParameters,e),e.optional&amp;&amp;this.token(&quot;?.&quot;),this.token(&quot;(&quot;),this.printList(e.arguments,e),this.token(&quot;)&quot;))},t.SequenceExpression=function(e){this.printList(e.expressions,e)},t.ThisExpression=function(){this.word(&quot;this&quot;)},t.Super=function(){this.word(&quot;super&quot;)},t.Decorator=function(e){this.token(&quot;@&quot;),this.print(e.expression,e),this.newline()},t.OptionalMemberExpression=function(e){if(this.print(e.object,e),!e.computed&amp;&amp;n.isMemberExpression(e.property))throw new TypeError(&quot;Got a MemberExpression for MemberExpression property&quot;);let t=e.computed;n.isLiteral(e.property)&amp;&amp;&quot;number&quot;==typeof e.property.value&amp;&amp;(t=!0),e.optional&amp;&amp;this.token(&quot;?.&quot;),t?(this.token(&quot;[&quot;),this.print(e.property,e),this.token(&quot;]&quot;)):(e.optional||this.token(&quot;.&quot;),this.print(e.property,e))},t.OptionalCallExpression=function(e){this.print(e.callee,e),this.print(e.typeArguments,e),this.print(e.typeParameters,e),e.optional&amp;&amp;this.token(&quot;?.&quot;),this.token(&quot;(&quot;),this.printList(e.arguments,e),this.token(&quot;)&quot;)},t.CallExpression=function(e){this.print(e.callee,e),this.print(e.typeArguments,e),this.print(e.typeParameters,e),this.token(&quot;(&quot;),this.printList(e.arguments,e),this.token(&quot;)&quot;)},t.Import=function(){this.word(&quot;import&quot;)},t.EmptyStatement=function(){this.semicolon(!0)},t.ExpressionStatement=function(e){this.print(e.expression,e),this.semicolon()},t.AssignmentPattern=function(e){this.print(e.left,e),e.left.optional&amp;&amp;this.token(&quot;?&quot;),this.print(e.left.typeAnnotation,e),this.space(),this.token(&quot;=&quot;),this.space(),this.print(e.right,e)},t.LogicalExpression=t.BinaryExpression=t.AssignmentExpression=function(e,t){const r=this.inForStatementInitCounter&amp;&amp;&quot;in&quot;===e.operator&amp;&amp;!i.needsParens(e,t);r&amp;&amp;this.token(&quot;(&quot;),this.print(e.left,e),this.space(),&quot;in&quot;===e.operator||&quot;instanceof&quot;===e.operator?this.word(e.operator):this.token(e.operator),this.space(),this.print(e.right,e),r&amp;&amp;this.token(&quot;)&quot;)},t.BindExpression=function(e){this.print(e.object,e),this.token(&quot;::&quot;),this.print(e.callee,e)},t.MemberExpression=function(e){if(this.print(e.object,e),!e.computed&amp;&amp;n.isMemberExpression(e.property))throw new TypeError(&quot;Got a MemberExpression for MemberExpression property&quot;);let t=e.computed;n.isLiteral(e.property)&amp;&amp;&quot;number&quot;==typeof e.property.value&amp;&amp;(t=!0),t?(this.token(&quot;[&quot;),this.print(e.property,e),this.token(&quot;]&quot;)):(this.token(&quot;.&quot;),this.print(e.property,e))},t.MetaProperty=function(e){this.print(e.meta,e),this.token(&quot;.&quot;),this.print(e.property,e)},t.PrivateName=function(e){this.token(&quot;#&quot;),this.print(e.id,e)},t.V8IntrinsicIdentifier=function(e){this.token(&quot;%&quot;),this.word(e.name)},t.AwaitExpression=t.YieldExpression=void 0;var n=a(r(1710)),i=a(r(944));function s(){if(&quot;function&quot;!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}function a(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;object&quot;!=typeof e&amp;&amp;&quot;function&quot;!=typeof e)return{default:e};var t=s();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=n?Object.getOwnPropertyDescriptor(e,i):null;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,i,a):r[i]=e[i]}return r.default=e,t&amp;&amp;t.set(e,r),r}function o(e){return function(t){if(this.word(e),t.delegate&amp;&amp;this.token(&quot;*&quot;),t.argument){this.space();const e=this.startTerminatorless();this.print(t.argument,t),this.endTerminatorless(e)}}}const l=o(&quot;yield&quot;);t.YieldExpression=l;const p=o(&quot;await&quot;);t.AwaitExpression=p},308:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.AnyTypeAnnotation=function(){this.word(&quot;any&quot;)},t.ArrayTypeAnnotation=function(e){this.print(e.elementType,e),this.token(&quot;[&quot;),this.token(&quot;]&quot;)},t.BooleanTypeAnnotation=function(){this.word(&quot;boolean&quot;)},t.BooleanLiteralTypeAnnotation=function(e){this.word(e.value?&quot;true&quot;:&quot;false&quot;)},t.NullLiteralTypeAnnotation=function(){this.word(&quot;null&quot;)},t.DeclareClass=function(e,t){n.isDeclareExportDeclaration(t)||(this.word(&quot;declare&quot;),this.space()),this.word(&quot;class&quot;),this.space(),this._interfaceish(e)},t.DeclareFunction=function(e,t){n.isDeclareExportDeclaration(t)||(this.word(&quot;declare&quot;),this.space()),this.word(&quot;function&quot;),this.space(),this.print(e.id,e),this.print(e.id.typeAnnotation.typeAnnotation,e),e.predicate&amp;&amp;(this.space(),this.print(e.predicate,e)),this.semicolon()},t.InferredPredicate=function(){this.token(&quot;%&quot;),this.word(&quot;checks&quot;)},t.DeclaredPredicate=function(e){this.token(&quot;%&quot;),this.word(&quot;checks&quot;),this.token(&quot;(&quot;),this.print(e.value,e),this.token(&quot;)&quot;)},t.DeclareInterface=function(e){this.word(&quot;declare&quot;),this.space(),this.InterfaceDeclaration(e)},t.DeclareModule=function(e){this.word(&quot;declare&quot;),this.space(),this.word(&quot;module&quot;),this.space(),this.print(e.id,e),this.space(),this.print(e.body,e)},t.DeclareModuleExports=function(e){this.word(&quot;declare&quot;),this.space(),this.word(&quot;module&quot;),this.token(&quot;.&quot;),this.word(&quot;exports&quot;),this.print(e.typeAnnotation,e)},t.DeclareTypeAlias=function(e){this.word(&quot;declare&quot;),this.space(),this.TypeAlias(e)},t.DeclareOpaqueType=function(e,t){n.isDeclareExportDeclaration(t)||(this.word(&quot;declare&quot;),this.space()),this.OpaqueType(e)},t.DeclareVariable=function(e,t){n.isDeclareExportDeclaration(t)||(this.word(&quot;declare&quot;),this.space()),this.word(&quot;var&quot;),this.space(),this.print(e.id,e),this.print(e.id.typeAnnotation,e),this.semicolon()},t.DeclareExportDeclaration=function(e){this.word(&quot;declare&quot;),this.space(),this.word(&quot;export&quot;),this.space(),e.default&amp;&amp;(this.word(&quot;default&quot;),this.space()),c.apply(this,arguments)},t.DeclareExportAllDeclaration=function(){this.word(&quot;declare&quot;),this.space(),i.ExportAllDeclaration.apply(this,arguments)},t.EnumDeclaration=function(e){const{id:t,body:r}=e;this.word(&quot;enum&quot;),this.space(),this.print(t,e),this.print(r,e)},t.EnumBooleanBody=function(e){const{explicitType:t}=e;o(this,&quot;boolean&quot;,t),l(this,e)},t.EnumNumberBody=function(e){const{explicitType:t}=e;o(this,&quot;number&quot;,t),l(this,e)},t.EnumStringBody=function(e){const{explicitType:t}=e;o(this,&quot;string&quot;,t),l(this,e)},t.EnumSymbolBody=function(e){o(this,&quot;symbol&quot;,!0),l(this,e)},t.EnumDefaultedMember=function(e){const{id:t}=e;this.print(t,e),this.token(&quot;,&quot;)},t.EnumBooleanMember=function(e){p(this,e)},t.EnumNumberMember=function(e){p(this,e)},t.EnumStringMember=function(e){p(this,e)},t.ExistsTypeAnnotation=function(){this.token(&quot;*&quot;)},t.FunctionTypeAnnotation=function(e,t){this.print(e.typeParameters,e),this.token(&quot;(&quot;),this.printList(e.params,e),e.rest&amp;&amp;(e.params.length&amp;&amp;(this.token(&quot;,&quot;),this.space()),this.token(&quot;...&quot;),this.print(e.rest,e)),this.token(&quot;)&quot;),&quot;ObjectTypeCallProperty&quot;===t.type||&quot;DeclareFunction&quot;===t.type||&quot;ObjectTypeProperty&quot;===t.type&amp;&amp;t.method?this.token(&quot;:&quot;):(this.space(),this.token(&quot;=&gt;&quot;)),this.space(),this.print(e.returnType,e)},t.FunctionTypeParam=function(e){this.print(e.name,e),e.optional&amp;&amp;this.token(&quot;?&quot;),e.name&amp;&amp;(this.token(&quot;:&quot;),this.space()),this.print(e.typeAnnotation,e)},t.GenericTypeAnnotation=t.ClassImplements=t.InterfaceExtends=function(e){this.print(e.id,e),this.print(e.typeParameters,e)},t._interfaceish=function(e){this.print(e.id,e),this.print(e.typeParameters,e),e.extends.length&amp;&amp;(this.space(),this.word(&quot;extends&quot;),this.space(),this.printList(e.extends,e)),e.mixins&amp;&amp;e.mixins.length&amp;&amp;(this.space(),this.word(&quot;mixins&quot;),this.space(),this.printList(e.mixins,e)),e.implements&amp;&amp;e.implements.length&amp;&amp;(this.space(),this.word(&quot;implements&quot;),this.space(),this.printList(e.implements,e)),this.space(),this.print(e.body,e)},t._variance=function(e){e.variance&amp;&amp;(&quot;plus&quot;===e.variance.kind?this.token(&quot;+&quot;):&quot;minus&quot;===e.variance.kind&amp;&amp;this.token(&quot;-&quot;))},t.InterfaceDeclaration=function(e){this.word(&quot;interface&quot;),this.space(),this._interfaceish(e)},t.InterfaceTypeAnnotation=function(e){this.word(&quot;interface&quot;),e.extends&amp;&amp;e.extends.length&amp;&amp;(this.space(),this.word(&quot;extends&quot;),this.space(),this.printList(e.extends,e)),this.space(),this.print(e.body,e)},t.IntersectionTypeAnnotation=function(e){this.printJoin(e.types,e,{separator:u})},t.MixedTypeAnnotation=function(){this.word(&quot;mixed&quot;)},t.EmptyTypeAnnotation=function(){this.word(&quot;empty&quot;)},t.NullableTypeAnnotation=function(e){this.token(&quot;?&quot;),this.print(e.typeAnnotation,e)},t.NumberTypeAnnotation=function(){this.word(&quot;number&quot;)},t.StringTypeAnnotation=function(){this.word(&quot;string&quot;)},t.ThisTypeAnnotation=function(){this.word(&quot;this&quot;)},t.TupleTypeAnnotation=function(e){this.token(&quot;[&quot;),this.printList(e.types,e),this.token(&quot;]&quot;)},t.TypeofTypeAnnotation=function(e){this.word(&quot;typeof&quot;),this.space(),this.print(e.argument,e)},t.TypeAlias=function(e){this.word(&quot;type&quot;),this.space(),this.print(e.id,e),this.print(e.typeParameters,e),this.space(),this.token(&quot;=&quot;),this.space(),this.print(e.right,e),this.semicolon()},t.TypeAnnotation=function(e){this.token(&quot;:&quot;),this.space(),e.optional&amp;&amp;this.token(&quot;?&quot;),this.print(e.typeAnnotation,e)},t.TypeParameterDeclaration=t.TypeParameterInstantiation=function(e){this.token(&quot;&lt;&quot;),this.printList(e.params,e,{}),this.token(&quot;&gt;&quot;)},t.TypeParameter=function(e){this._variance(e),this.word(e.name),e.bound&amp;&amp;this.print(e.bound,e),e.default&amp;&amp;(this.space(),this.token(&quot;=&quot;),this.space(),this.print(e.default,e))},t.OpaqueType=function(e){this.word(&quot;opaque&quot;),this.space(),this.word(&quot;type&quot;),this.space(),this.print(e.id,e),this.print(e.typeParameters,e),e.supertype&amp;&amp;(this.token(&quot;:&quot;),this.space(),this.print(e.supertype,e)),e.impltype&amp;&amp;(this.space(),this.token(&quot;=&quot;),this.space(),this.print(e.impltype,e)),this.semicolon()},t.ObjectTypeAnnotation=function(e){e.exact?this.token(&quot;{|&quot;):this.token(&quot;{&quot;);const t=e.properties.concat(e.callProperties||[],e.indexers||[],e.internalSlots||[]);t.length&amp;&amp;(this.space(),this.printJoin(t,e,{addNewlines(e){if(e&amp;&amp;!t[0])return 1},indent:!0,statement:!0,iterator:()=&gt;{(1!==t.length||e.inexact)&amp;&amp;(this.token(&quot;,&quot;),this.space())}}),this.space()),e.inexact&amp;&amp;(this.indent(),this.token(&quot;...&quot;),t.length&amp;&amp;this.newline(),this.dedent()),e.exact?this.token(&quot;|}&quot;):this.token(&quot;}&quot;)},t.ObjectTypeInternalSlot=function(e){e.static&amp;&amp;(this.word(&quot;static&quot;),this.space()),this.token(&quot;[&quot;),this.token(&quot;[&quot;),this.print(e.id,e),this.token(&quot;]&quot;),this.token(&quot;]&quot;),e.optional&amp;&amp;this.token(&quot;?&quot;),e.method||(this.token(&quot;:&quot;),this.space()),this.print(e.value,e)},t.ObjectTypeCallProperty=function(e){e.static&amp;&amp;(this.word(&quot;static&quot;),this.space()),this.print(e.value,e)},t.ObjectTypeIndexer=function(e){e.static&amp;&amp;(this.word(&quot;static&quot;),this.space()),this._variance(e),this.token(&quot;[&quot;),e.id&amp;&amp;(this.print(e.id,e),this.token(&quot;:&quot;),this.space()),this.print(e.key,e),this.token(&quot;]&quot;),this.token(&quot;:&quot;),this.space(),this.print(e.value,e)},t.ObjectTypeProperty=function(e){e.proto&amp;&amp;(this.word(&quot;proto&quot;),this.space()),e.static&amp;&amp;(this.word(&quot;static&quot;),this.space()),&quot;get&quot;!==e.kind&amp;&amp;&quot;set&quot;!==e.kind||(this.word(e.kind),this.space()),this._variance(e),this.print(e.key,e),e.optional&amp;&amp;this.token(&quot;?&quot;),e.method||(this.token(&quot;:&quot;),this.space()),this.print(e.value,e)},t.ObjectTypeSpreadProperty=function(e){this.token(&quot;...&quot;),this.print(e.argument,e)},t.QualifiedTypeIdentifier=function(e){this.print(e.qualification,e),this.token(&quot;.&quot;),this.print(e.id,e)},t.SymbolTypeAnnotation=function(){this.word(&quot;symbol&quot;)},t.UnionTypeAnnotation=function(e){this.printJoin(e.types,e,{separator:d})},t.TypeCastExpression=function(e){this.token(&quot;(&quot;),this.print(e.expression,e),this.print(e.typeAnnotation,e),this.token(&quot;)&quot;)},t.Variance=function(e){&quot;plus&quot;===e.kind?this.token(&quot;+&quot;):this.token(&quot;-&quot;)},t.VoidTypeAnnotation=function(){this.word(&quot;void&quot;)},Object.defineProperty(t,&quot;NumberLiteralTypeAnnotation&quot;,{enumerable:!0,get:function(){return s.NumericLiteral}}),Object.defineProperty(t,&quot;StringLiteralTypeAnnotation&quot;,{enumerable:!0,get:function(){return s.StringLiteral}});var n=function(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;object&quot;!=typeof e&amp;&amp;&quot;function&quot;!=typeof e)return{default:e};var t=a();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var s=n?Object.getOwnPropertyDescriptor(e,i):null;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}return r.default=e,t&amp;&amp;t.set(e,r),r}(r(1710)),i=r(3503),s=r(4827);function a(){if(&quot;function&quot;!=typeof WeakMap)return null;var e=new WeakMap;return a=function(){return e},e}function o(e,t,r){r&amp;&amp;(e.space(),e.word(&quot;of&quot;),e.space(),e.word(t)),e.space()}function l(e,t){const{members:r}=t;e.token(&quot;{&quot;),e.indent(),e.newline();for(const n of r)e.print(n,t),e.newline();e.dedent(),e.token(&quot;}&quot;)}function p(e,t){const{id:r,init:n}=t;e.print(r,t),e.space(),e.token(&quot;=&quot;),e.space(),e.print(n,t),e.token(&quot;,&quot;)}function c(e){if(e.declaration){const t=e.declaration;this.print(t,e),n.isStatement(t)||this.semicolon()}else this.token(&quot;{&quot;),e.specifiers.length&amp;&amp;(this.space(),this.printList(e.specifiers,e),this.space()),this.token(&quot;}&quot;),e.source&amp;&amp;(this.space(),this.word(&quot;from&quot;),this.space(),this.print(e.source,e)),this.semicolon()}function u(){this.space(),this.token(&quot;&amp;&quot;),this.space()}function d(){this.space(),this.token(&quot;|&quot;),this.space()}},1464:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0});var n=r(3378);Object.keys(n).forEach((function(e){&quot;default&quot;!==e&amp;&amp;&quot;__esModule&quot;!==e&amp;&amp;(e in t&amp;&amp;t[e]===n[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return n[e]}}))}));var i=r(9901);Object.keys(i).forEach((function(e){&quot;default&quot;!==e&amp;&amp;&quot;__esModule&quot;!==e&amp;&amp;(e in t&amp;&amp;t[e]===i[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return i[e]}}))}));var s=r(9772);Object.keys(s).forEach((function(e){&quot;default&quot;!==e&amp;&amp;&quot;__esModule&quot;!==e&amp;&amp;(e in t&amp;&amp;t[e]===s[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return s[e]}}))}));var a=r(9570);Object.keys(a).forEach((function(e){&quot;default&quot;!==e&amp;&amp;&quot;__esModule&quot;!==e&amp;&amp;(e in t&amp;&amp;t[e]===a[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return a[e]}}))}));var o=r(4390);Object.keys(o).forEach((function(e){&quot;default&quot;!==e&amp;&amp;&quot;__esModule&quot;!==e&amp;&amp;(e in t&amp;&amp;t[e]===o[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return o[e]}}))}));var l=r(3503);Object.keys(l).forEach((function(e){&quot;default&quot;!==e&amp;&amp;&quot;__esModule&quot;!==e&amp;&amp;(e in t&amp;&amp;t[e]===l[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return l[e]}}))}));var p=r(4827);Object.keys(p).forEach((function(e){&quot;default&quot;!==e&amp;&amp;&quot;__esModule&quot;!==e&amp;&amp;(e in t&amp;&amp;t[e]===p[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return p[e]}}))}));var c=r(308);Object.keys(c).forEach((function(e){&quot;default&quot;!==e&amp;&amp;&quot;__esModule&quot;!==e&amp;&amp;(e in t&amp;&amp;t[e]===c[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return c[e]}}))}));var u=r(3762);Object.keys(u).forEach((function(e){&quot;default&quot;!==e&amp;&amp;&quot;__esModule&quot;!==e&amp;&amp;(e in t&amp;&amp;t[e]===u[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return u[e]}}))}));var d=r(6209);Object.keys(d).forEach((function(e){&quot;default&quot;!==e&amp;&amp;&quot;__esModule&quot;!==e&amp;&amp;(e in t&amp;&amp;t[e]===d[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return d[e]}}))}));var h=r(5529);Object.keys(h).forEach((function(e){&quot;default&quot;!==e&amp;&amp;&quot;__esModule&quot;!==e&amp;&amp;(e in t&amp;&amp;t[e]===h[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return h[e]}}))}))},6209:(e,t)=&gt;{&quot;use strict&quot;;function r(){this.space()}Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.JSXAttribute=function(e){this.print(e.name,e),e.value&amp;&amp;(this.token(&quot;=&quot;),this.print(e.value,e))},t.JSXIdentifier=function(e){this.word(e.name)},t.JSXNamespacedName=function(e){this.print(e.namespace,e),this.token(&quot;:&quot;),this.print(e.name,e)},t.JSXMemberExpression=function(e){this.print(e.object,e),this.token(&quot;.&quot;),this.print(e.property,e)},t.JSXSpreadAttribute=function(e){this.token(&quot;{&quot;),this.token(&quot;...&quot;),this.print(e.argument,e),this.token(&quot;}&quot;)},t.JSXExpressionContainer=function(e){this.token(&quot;{&quot;),this.print(e.expression,e),this.token(&quot;}&quot;)},t.JSXSpreadChild=function(e){this.token(&quot;{&quot;),this.token(&quot;...&quot;),this.print(e.expression,e),this.token(&quot;}&quot;)},t.JSXText=function(e){const t=this.getPossibleRaw(e);null!=t?this.token(t):this.token(e.value)},t.JSXElement=function(e){const t=e.openingElement;if(this.print(t,e),!t.selfClosing){this.indent();for(const t of e.children)this.print(t,e);this.dedent(),this.print(e.closingElement,e)}},t.JSXOpeningElement=function(e){this.token(&quot;&lt;&quot;),this.print(e.name,e),this.print(e.typeParameters,e),e.attributes.length&gt;0&amp;&amp;(this.space(),this.printJoin(e.attributes,e,{separator:r})),e.selfClosing?(this.space(),this.token(&quot;/&gt;&quot;)):this.token(&quot;&gt;&quot;)},t.JSXClosingElement=function(e){this.token(&quot;&lt;/&quot;),this.print(e.name,e),this.token(&quot;&gt;&quot;)},t.JSXEmptyExpression=function(e){this.printInnerComments(e)},t.JSXFragment=function(e){this.print(e.openingFragment,e),this.indent();for(const t of e.children)this.print(t,e);this.dedent(),this.print(e.closingFragment,e)},t.JSXOpeningFragment=function(){this.token(&quot;&lt;&quot;),this.token(&quot;&gt;&quot;)},t.JSXClosingFragment=function(){this.token(&quot;&lt;/&quot;),this.token(&quot;&gt;&quot;)}},4390:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t._params=function(e){this.print(e.typeParameters,e),this.token(&quot;(&quot;),this._parameters(e.params,e),this.token(&quot;)&quot;),this.print(e.returnType,e)},t._parameters=function(e,t){for(let r=0;r&lt;e.length;r++)this._param(e[r],t),r&lt;e.length-1&amp;&amp;(this.token(&quot;,&quot;),this.space())},t._param=function(e,t){this.printJoin(e.decorators,e),this.print(e,t),e.optional&amp;&amp;this.token(&quot;?&quot;),this.print(e.typeAnnotation,e)},t._methodHead=function(e){const t=e.kind,r=e.key;&quot;get&quot;!==t&amp;&amp;&quot;set&quot;!==t||(this.word(t),this.space()),e.async&amp;&amp;(this._catchUp(&quot;start&quot;,r.loc),this.word(&quot;async&quot;),this.space()),&quot;method&quot;!==t&amp;&amp;&quot;init&quot;!==t||e.generator&amp;&amp;this.token(&quot;*&quot;),e.computed?(this.token(&quot;[&quot;),this.print(r,e),this.token(&quot;]&quot;)):this.print(r,e),e.optional&amp;&amp;this.token(&quot;?&quot;),this._params(e)},t._predicate=function(e){e.predicate&amp;&amp;(e.returnType||this.token(&quot;:&quot;),this.space(),this.print(e.predicate,e))},t._functionHead=function(e){e.async&amp;&amp;(this.word(&quot;async&quot;),this.space()),this.word(&quot;function&quot;),e.generator&amp;&amp;this.token(&quot;*&quot;),this.space(),e.id&amp;&amp;this.print(e.id,e),this._params(e),this._predicate(e)},t.FunctionDeclaration=t.FunctionExpression=function(e){this._functionHead(e),this.space(),this.print(e.body,e)},t.ArrowFunctionExpression=function(e){e.async&amp;&amp;(this.word(&quot;async&quot;),this.space());const t=e.params[0];1===e.params.length&amp;&amp;n.isIdentifier(t)&amp;&amp;!function(e,t){return e.typeParameters||e.returnType||t.typeAnnotation||t.optional||t.trailingComments}(e,t)?(this.format.retainLines||e.async)&amp;&amp;e.loc&amp;&amp;e.body.loc&amp;&amp;e.loc.start.line&lt;e.body.loc.start.line?(this.token(&quot;(&quot;),t.loc&amp;&amp;t.loc.start.line&gt;e.loc.start.line?(this.indent(),this.print(t,e),this.dedent(),this._catchUp(&quot;start&quot;,e.body.loc)):this.print(t,e),this.token(&quot;)&quot;)):this.print(t,e):this._params(e),this._predicate(e),this.space(),this.token(&quot;=&gt;&quot;),this.space(),this.print(e.body,e)};var n=function(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;object&quot;!=typeof e&amp;&amp;&quot;function&quot;!=typeof e)return{default:e};var t=i();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var a=n?Object.getOwnPropertyDescriptor(e,s):null;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}return r.default=e,t&amp;&amp;t.set(e,r),r}(r(1710));function i(){if(&quot;function&quot;!=typeof WeakMap)return null;var e=new WeakMap;return i=function(){return e},e}},3503:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.ImportSpecifier=function(e){&quot;type&quot;!==e.importKind&amp;&amp;&quot;typeof&quot;!==e.importKind||(this.word(e.importKind),this.space()),this.print(e.imported,e),e.local&amp;&amp;e.local.name!==e.imported.name&amp;&amp;(this.space(),this.word(&quot;as&quot;),this.space(),this.print(e.local,e))},t.ImportDefaultSpecifier=function(e){this.print(e.local,e)},t.ExportDefaultSpecifier=function(e){this.print(e.exported,e)},t.ExportSpecifier=function(e){this.print(e.local,e),e.exported&amp;&amp;e.local.name!==e.exported.name&amp;&amp;(this.space(),this.word(&quot;as&quot;),this.space(),this.print(e.exported,e))},t.ExportNamespaceSpecifier=function(e){this.token(&quot;*&quot;),this.space(),this.word(&quot;as&quot;),this.space(),this.print(e.exported,e)},t.ExportAllDeclaration=function(e){this.word(&quot;export&quot;),this.space(),&quot;type&quot;===e.exportKind&amp;&amp;(this.word(&quot;type&quot;),this.space()),this.token(&quot;*&quot;),this.space(),this.word(&quot;from&quot;),this.space(),this.print(e.source,e),this.printAssertions(e),this.semicolon()},t.ExportNamedDeclaration=function(e){this.format.decoratorsBeforeExport&amp;&amp;n.isClassDeclaration(e.declaration)&amp;&amp;this.printJoin(e.declaration.decorators,e),this.word(&quot;export&quot;),this.space(),s.apply(this,arguments)},t.ExportDefaultDeclaration=function(e){this.format.decoratorsBeforeExport&amp;&amp;n.isClassDeclaration(e.declaration)&amp;&amp;this.printJoin(e.declaration.decorators,e),this.word(&quot;export&quot;),this.space(),this.word(&quot;default&quot;),this.space(),s.apply(this,arguments)},t.ImportDeclaration=function(e){var t;this.word(&quot;import&quot;),this.space(),(&quot;type&quot;===e.importKind||&quot;typeof&quot;===e.importKind)&amp;&amp;(this.word(e.importKind),this.space());const r=e.specifiers.slice(0);if(null==r?void 0:r.length){for(;;){const t=r[0];if(!n.isImportDefaultSpecifier(t)&amp;&amp;!n.isImportNamespaceSpecifier(t))break;this.print(r.shift(),e),r.length&amp;&amp;(this.token(&quot;,&quot;),this.space())}r.length&amp;&amp;(this.token(&quot;{&quot;),this.space(),this.printList(r,e),this.space(),this.token(&quot;}&quot;)),this.space(),this.word(&quot;from&quot;),this.space()}this.print(e.source,e),this.printAssertions(e),(null==(t=e.attributes)?void 0:t.length)&amp;&amp;(this.space(),this.word(&quot;with&quot;),this.space(),this.printList(e.attributes,e)),this.semicolon()},t.ImportAttribute=function(e){this.print(e.key),this.token(&quot;:&quot;),this.space(),this.print(e.value)},t.ImportNamespaceSpecifier=function(e){this.token(&quot;*&quot;),this.space(),this.word(&quot;as&quot;),this.space(),this.print(e.local,e)};var n=function(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;object&quot;!=typeof e&amp;&amp;&quot;function&quot;!=typeof e)return{default:e};var t=i();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var a=n?Object.getOwnPropertyDescriptor(e,s):null;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}return r.default=e,t&amp;&amp;t.set(e,r),r}(r(1710));function i(){if(&quot;function&quot;!=typeof WeakMap)return null;var e=new WeakMap;return i=function(){return e},e}function s(e){if(e.declaration){const t=e.declaration;this.print(t,e),n.isStatement(t)||this.semicolon()}else{&quot;type&quot;===e.exportKind&amp;&amp;(this.word(&quot;type&quot;),this.space());const t=e.specifiers.slice(0);let r=!1;for(;;){const i=t[0];if(!n.isExportDefaultSpecifier(i)&amp;&amp;!n.isExportNamespaceSpecifier(i))break;r=!0,this.print(t.shift(),e),t.length&amp;&amp;(this.token(&quot;,&quot;),this.space())}(t.length||!t.length&amp;&amp;!r)&amp;&amp;(this.token(&quot;{&quot;),t.length&amp;&amp;(this.space(),this.printList(t,e),this.space()),this.token(&quot;}&quot;)),e.source&amp;&amp;(this.space(),this.word(&quot;from&quot;),this.space(),this.print(e.source,e),this.printAssertions(e)),this.semicolon()}}},9772:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.WithStatement=function(e){this.word(&quot;with&quot;),this.space(),this.token(&quot;(&quot;),this.print(e.object,e),this.token(&quot;)&quot;),this.printBlock(e)},t.IfStatement=function(e){this.word(&quot;if&quot;),this.space(),this.token(&quot;(&quot;),this.print(e.test,e),this.token(&quot;)&quot;),this.space();const t=e.alternate&amp;&amp;n.isIfStatement(s(e.consequent));t&amp;&amp;(this.token(&quot;{&quot;),this.newline(),this.indent()),this.printAndIndentOnComments(e.consequent,e),t&amp;&amp;(this.dedent(),this.newline(),this.token(&quot;}&quot;)),e.alternate&amp;&amp;(this.endsWith(&quot;}&quot;)&amp;&amp;this.space(),this.word(&quot;else&quot;),this.space(),this.printAndIndentOnComments(e.alternate,e))},t.ForStatement=function(e){this.word(&quot;for&quot;),this.space(),this.token(&quot;(&quot;),this.inForStatementInitCounter++,this.print(e.init,e),this.inForStatementInitCounter--,this.token(&quot;;&quot;),e.test&amp;&amp;(this.space(),this.print(e.test,e)),this.token(&quot;;&quot;),e.update&amp;&amp;(this.space(),this.print(e.update,e)),this.token(&quot;)&quot;),this.printBlock(e)},t.WhileStatement=function(e){this.word(&quot;while&quot;),this.space(),this.token(&quot;(&quot;),this.print(e.test,e),this.token(&quot;)&quot;),this.printBlock(e)},t.DoWhileStatement=function(e){this.word(&quot;do&quot;),this.space(),this.print(e.body,e),this.space(),this.word(&quot;while&quot;),this.space(),this.token(&quot;(&quot;),this.print(e.test,e),this.token(&quot;)&quot;),this.semicolon()},t.LabeledStatement=function(e){this.print(e.label,e),this.token(&quot;:&quot;),this.space(),this.print(e.body,e)},t.TryStatement=function(e){this.word(&quot;try&quot;),this.space(),this.print(e.block,e),this.space(),e.handlers?this.print(e.handlers[0],e):this.print(e.handler,e),e.finalizer&amp;&amp;(this.space(),this.word(&quot;finally&quot;),this.space(),this.print(e.finalizer,e))},t.CatchClause=function(e){this.word(&quot;catch&quot;),this.space(),e.param&amp;&amp;(this.token(&quot;(&quot;),this.print(e.param,e),this.print(e.param.typeAnnotation,e),this.token(&quot;)&quot;),this.space()),this.print(e.body,e)},t.SwitchStatement=function(e){this.word(&quot;switch&quot;),this.space(),this.token(&quot;(&quot;),this.print(e.discriminant,e),this.token(&quot;)&quot;),this.space(),this.token(&quot;{&quot;),this.printSequence(e.cases,e,{indent:!0,addNewlines(t,r){if(!t&amp;&amp;e.cases[e.cases.length-1]===r)return-1}}),this.token(&quot;}&quot;)},t.SwitchCase=function(e){e.test?(this.word(&quot;case&quot;),this.space(),this.print(e.test,e),this.token(&quot;:&quot;)):(this.word(&quot;default&quot;),this.token(&quot;:&quot;)),e.consequent.length&amp;&amp;(this.newline(),this.printSequence(e.consequent,e,{indent:!0}))},t.DebuggerStatement=function(){this.word(&quot;debugger&quot;),this.semicolon()},t.VariableDeclaration=function(e,t){e.declare&amp;&amp;(this.word(&quot;declare&quot;),this.space()),this.word(e.kind),this.space();let r,i=!1;if(!n.isFor(t))for(const t of e.declarations)t.init&amp;&amp;(i=!0);i&amp;&amp;(r=&quot;const&quot;===e.kind?m:f),this.printList(e.declarations,e,{separator:r}),(!n.isFor(t)||t.left!==e&amp;&amp;t.init!==e)&amp;&amp;this.semicolon()},t.VariableDeclarator=function(e){this.print(e.id,e),e.definite&amp;&amp;this.token(&quot;!&quot;),this.print(e.id.typeAnnotation,e),e.init&amp;&amp;(this.space(),this.token(&quot;=&quot;),this.space(),this.print(e.init,e))},t.ThrowStatement=t.BreakStatement=t.ReturnStatement=t.ContinueStatement=t.ForOfStatement=t.ForInStatement=void 0;var n=function(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;object&quot;!=typeof e&amp;&amp;&quot;function&quot;!=typeof e)return{default:e};var t=i();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var a=n?Object.getOwnPropertyDescriptor(e,s):null;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}return r.default=e,t&amp;&amp;t.set(e,r),r}(r(1710));function i(){if(&quot;function&quot;!=typeof WeakMap)return null;var e=new WeakMap;return i=function(){return e},e}function s(e){return n.isStatement(e.body)?s(e.body):e}const a=function(e){return function(t){this.word(&quot;for&quot;),this.space(),&quot;of&quot;===e&amp;&amp;t.await&amp;&amp;(this.word(&quot;await&quot;),this.space()),this.token(&quot;(&quot;),this.print(t.left,t),this.space(),this.word(e),this.space(),this.print(t.right,t),this.token(&quot;)&quot;),this.printBlock(t)}},o=a(&quot;in&quot;);t.ForInStatement=o;const l=a(&quot;of&quot;);function p(e,t=&quot;label&quot;){return function(r){this.word(e);const n=r[t];if(n){this.space();const e=&quot;label&quot;==t,i=this.startTerminatorless(e);this.print(n,r),this.endTerminatorless(i)}this.semicolon()}}t.ForOfStatement=l;const c=p(&quot;continue&quot;);t.ContinueStatement=c;const u=p(&quot;return&quot;,&quot;argument&quot;);t.ReturnStatement=u;const d=p(&quot;break&quot;);t.BreakStatement=d;const h=p(&quot;throw&quot;,&quot;argument&quot;);function f(){if(this.token(&quot;,&quot;),this.newline(),this.endsWith(&quot;</span><span class="s4">\n</span><span class="s3">&quot;))for(let e=0;e&lt;4;e++)this.space(!0)}function m(){if(this.token(&quot;,&quot;),this.newline(),this.endsWith(&quot;</span><span class="s4">\n</span><span class="s3">&quot;))for(let e=0;e&lt;6;e++)this.space(!0)}t.ThrowStatement=h},3378:(e,t)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.TaggedTemplateExpression=function(e){this.print(e.tag,e),this.print(e.typeParameters,e),this.print(e.quasi,e)},t.TemplateElement=function(e,t){const r=t.quasis[0]===e,n=t.quasis[t.quasis.length-1]===e,i=(r?&quot;`&quot;:&quot;}&quot;)+e.value.raw+(n?&quot;`&quot;:&quot;${&quot;);this.token(i)},t.TemplateLiteral=function(e){const t=e.quasis;for(let r=0;r&lt;t.length;r++)this.print(t[r],e),r+1&lt;t.length&amp;&amp;this.print(e.expressions[r],e)}},4827:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.Identifier=function(e){this.exactSource(e.loc,(()=&gt;{this.word(e.name)}))},t.ArgumentPlaceholder=function(){this.token(&quot;?&quot;)},t.SpreadElement=t.RestElement=function(e){this.token(&quot;...&quot;),this.print(e.argument,e)},t.ObjectPattern=t.ObjectExpression=function(e){const t=e.properties;this.token(&quot;{&quot;),this.printInnerComments(e),t.length&amp;&amp;(this.space(),this.printList(t,e,{indent:!0,statement:!0}),this.space()),this.token(&quot;}&quot;)},t.ObjectMethod=function(e){this.printJoin(e.decorators,e),this._methodHead(e),this.space(),this.print(e.body,e)},t.ObjectProperty=function(e){if(this.printJoin(e.decorators,e),e.computed)this.token(&quot;[&quot;),this.print(e.key,e),this.token(&quot;]&quot;);else{if(i.isAssignmentPattern(e.value)&amp;&amp;i.isIdentifier(e.key)&amp;&amp;e.key.name===e.value.left.name)return void this.print(e.value,e);if(this.print(e.key,e),e.shorthand&amp;&amp;i.isIdentifier(e.key)&amp;&amp;i.isIdentifier(e.value)&amp;&amp;e.key.name===e.value.name)return}this.token(&quot;:&quot;),this.space(),this.print(e.value,e)},t.ArrayPattern=t.ArrayExpression=function(e){const t=e.elements,r=t.length;this.token(&quot;[&quot;),this.printInnerComments(e);for(let n=0;n&lt;t.length;n++){const i=t[n];i?(n&gt;0&amp;&amp;this.space(),this.print(i,e),n&lt;r-1&amp;&amp;this.token(&quot;,&quot;)):this.token(&quot;,&quot;)}this.token(&quot;]&quot;)},t.RecordExpression=function(e){const t=e.properties;let r,n;if(&quot;bar&quot;===this.format.recordAndTupleSyntaxType)r=&quot;{|&quot;,n=&quot;|}&quot;;else{if(&quot;hash&quot;!==this.format.recordAndTupleSyntaxType)throw new Error(`The &quot;recordAndTupleSyntaxType&quot; generator option must be &quot;bar&quot; or &quot;hash&quot; (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);r=&quot;#{&quot;,n=&quot;}&quot;}this.token(r),this.printInnerComments(e),t.length&amp;&amp;(this.space(),this.printList(t,e,{indent:!0,statement:!0}),this.space()),this.token(n)},t.TupleExpression=function(e){const t=e.elements,r=t.length;let n,i;if(&quot;bar&quot;===this.format.recordAndTupleSyntaxType)n=&quot;[|&quot;,i=&quot;|]&quot;;else{if(&quot;hash&quot;!==this.format.recordAndTupleSyntaxType)throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);n=&quot;#[&quot;,i=&quot;]&quot;}this.token(n),this.printInnerComments(e);for(let n=0;n&lt;t.length;n++){const i=t[n];i&amp;&amp;(n&gt;0&amp;&amp;this.space(),this.print(i,e),n&lt;r-1&amp;&amp;this.token(&quot;,&quot;))}this.token(i)},t.RegExpLiteral=function(e){this.word(`/${e.pattern}/${e.flags}`)},t.BooleanLiteral=function(e){this.word(e.value?&quot;true&quot;:&quot;false&quot;)},t.NullLiteral=function(){this.word(&quot;null&quot;)},t.NumericLiteral=function(e){const t=this.getPossibleRaw(e),r=this.format.jsescOption,n=e.value+&quot;&quot;;r.numbers?this.number((0,s.default)(e.value,r)):null==t?this.number(n):this.format.minified?this.number(t.length&lt;n.length?t:n):this.number(t)},t.StringLiteral=function(e){const t=this.getPossibleRaw(e);if(!this.format.minified&amp;&amp;null!=t)return void this.token(t);const r=this.format.jsescOption;this.format.jsonCompatibleStrings&amp;&amp;(r.json=!0);const n=(0,s.default)(e.value,r);return this.token(n)},t.BigIntLiteral=function(e){const t=this.getPossibleRaw(e);this.format.minified||null==t?this.token(e.value+&quot;n&quot;):this.token(t)},t.DecimalLiteral=function(e){const t=this.getPossibleRaw(e);this.format.minified||null==t?this.token(e.value+&quot;m&quot;):this.token(t)},t.PipelineTopicExpression=function(e){this.print(e.expression,e)},t.PipelineBareFunction=function(e){this.print(e.callee,e)},t.PipelinePrimaryTopicReference=function(){this.token(&quot;#&quot;)};var n,i=function(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;object&quot;!=typeof e&amp;&amp;&quot;function&quot;!=typeof e)return{default:e};var t=a();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var s=n?Object.getOwnPropertyDescriptor(e,i):null;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}return r.default=e,t&amp;&amp;t.set(e,r),r}(r(1710)),s=(n=r(442))&amp;&amp;n.__esModule?n:{default:n};function a(){if(&quot;function&quot;!=typeof WeakMap)return null;var e=new WeakMap;return a=function(){return e},e}},5529:(e,t)=&gt;{&quot;use strict&quot;;function r(e,t){!0!==t&amp;&amp;e.token(t)}Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.TSTypeAnnotation=function(e){this.token(&quot;:&quot;),this.space(),e.optional&amp;&amp;this.token(&quot;?&quot;),this.print(e.typeAnnotation,e)},t.TSTypeParameterDeclaration=t.TSTypeParameterInstantiation=function(e){this.token(&quot;&lt;&quot;),this.printList(e.params,e,{}),this.token(&quot;&gt;&quot;)},t.TSTypeParameter=function(e){this.word(e.name),e.constraint&amp;&amp;(this.space(),this.word(&quot;extends&quot;),this.space(),this.print(e.constraint,e)),e.default&amp;&amp;(this.space(),this.token(&quot;=&quot;),this.space(),this.print(e.default,e))},t.TSParameterProperty=function(e){e.accessibility&amp;&amp;(this.word(e.accessibility),this.space()),e.readonly&amp;&amp;(this.word(&quot;readonly&quot;),this.space()),this._param(e.parameter)},t.TSDeclareFunction=function(e){e.declare&amp;&amp;(this.word(&quot;declare&quot;),this.space()),this._functionHead(e),this.token(&quot;;&quot;)},t.TSDeclareMethod=function(e){this._classMethodHead(e),this.token(&quot;;&quot;)},t.TSQualifiedName=function(e){this.print(e.left,e),this.token(&quot;.&quot;),this.print(e.right,e)},t.TSCallSignatureDeclaration=function(e){this.tsPrintSignatureDeclarationBase(e),this.token(&quot;;&quot;)},t.TSConstructSignatureDeclaration=function(e){this.word(&quot;new&quot;),this.space(),this.tsPrintSignatureDeclarationBase(e),this.token(&quot;;&quot;)},t.TSPropertySignature=function(e){const{readonly:t,initializer:r}=e;t&amp;&amp;(this.word(&quot;readonly&quot;),this.space()),this.tsPrintPropertyOrMethodName(e),this.print(e.typeAnnotation,e),r&amp;&amp;(this.space(),this.token(&quot;=&quot;),this.space(),this.print(r,e)),this.token(&quot;;&quot;)},t.tsPrintPropertyOrMethodName=function(e){e.computed&amp;&amp;this.token(&quot;[&quot;),this.print(e.key,e),e.computed&amp;&amp;this.token(&quot;]&quot;),e.optional&amp;&amp;this.token(&quot;?&quot;)},t.TSMethodSignature=function(e){this.tsPrintPropertyOrMethodName(e),this.tsPrintSignatureDeclarationBase(e),this.token(&quot;;&quot;)},t.TSIndexSignature=function(e){const{readonly:t}=e;t&amp;&amp;(this.word(&quot;readonly&quot;),this.space()),this.token(&quot;[&quot;),this._parameters(e.parameters,e),this.token(&quot;]&quot;),this.print(e.typeAnnotation,e),this.token(&quot;;&quot;)},t.TSAnyKeyword=function(){this.word(&quot;any&quot;)},t.TSBigIntKeyword=function(){this.word(&quot;bigint&quot;)},t.TSUnknownKeyword=function(){this.word(&quot;unknown&quot;)},t.TSNumberKeyword=function(){this.word(&quot;number&quot;)},t.TSObjectKeyword=function(){this.word(&quot;object&quot;)},t.TSBooleanKeyword=function(){this.word(&quot;boolean&quot;)},t.TSStringKeyword=function(){this.word(&quot;string&quot;)},t.TSSymbolKeyword=function(){this.word(&quot;symbol&quot;)},t.TSVoidKeyword=function(){this.word(&quot;void&quot;)},t.TSUndefinedKeyword=function(){this.word(&quot;undefined&quot;)},t.TSNullKeyword=function(){this.word(&quot;null&quot;)},t.TSNeverKeyword=function(){this.word(&quot;never&quot;)},t.TSIntrinsicKeyword=function(){this.word(&quot;intrinsic&quot;)},t.TSThisType=function(){this.word(&quot;this&quot;)},t.TSFunctionType=function(e){this.tsPrintFunctionOrConstructorType(e)},t.TSConstructorType=function(e){this.word(&quot;new&quot;),this.space(),this.tsPrintFunctionOrConstructorType(e)},t.tsPrintFunctionOrConstructorType=function(e){const{typeParameters:t,parameters:r}=e;this.print(t,e),this.token(&quot;(&quot;),this._parameters(r,e),this.token(&quot;)&quot;),this.space(),this.token(&quot;=&gt;&quot;),this.space(),this.print(e.typeAnnotation.typeAnnotation,e)},t.TSTypeReference=function(e){this.print(e.typeName,e),this.print(e.typeParameters,e)},t.TSTypePredicate=function(e){e.asserts&amp;&amp;(this.word(&quot;asserts&quot;),this.space()),this.print(e.parameterName),e.typeAnnotation&amp;&amp;(this.space(),this.word(&quot;is&quot;),this.space(),this.print(e.typeAnnotation.typeAnnotation))},t.TSTypeQuery=function(e){this.word(&quot;typeof&quot;),this.space(),this.print(e.exprName)},t.TSTypeLiteral=function(e){this.tsPrintTypeLiteralOrInterfaceBody(e.members,e)},t.tsPrintTypeLiteralOrInterfaceBody=function(e,t){this.tsPrintBraced(e,t)},t.tsPrintBraced=function(e,t){if(this.token(&quot;{&quot;),e.length){this.indent(),this.newline();for(const r of e)this.print(r,t),this.newline();this.dedent(),this.rightBrace()}else this.token(&quot;}&quot;)},t.TSArrayType=function(e){this.print(e.elementType,e),this.token(&quot;[]&quot;)},t.TSTupleType=function(e){this.token(&quot;[&quot;),this.printList(e.elementTypes,e),this.token(&quot;]&quot;)},t.TSOptionalType=function(e){this.print(e.typeAnnotation,e),this.token(&quot;?&quot;)},t.TSRestType=function(e){this.token(&quot;...&quot;),this.print(e.typeAnnotation,e)},t.TSNamedTupleMember=function(e){this.print(e.label,e),e.optional&amp;&amp;this.token(&quot;?&quot;),this.token(&quot;:&quot;),this.space(),this.print(e.elementType,e)},t.TSUnionType=function(e){this.tsPrintUnionOrIntersectionType(e,&quot;|&quot;)},t.TSIntersectionType=function(e){this.tsPrintUnionOrIntersectionType(e,&quot;&amp;&quot;)},t.tsPrintUnionOrIntersectionType=function(e,t){this.printJoin(e.types,e,{separator(){this.space(),this.token(t),this.space()}})},t.TSConditionalType=function(e){this.print(e.checkType),this.space(),this.word(&quot;extends&quot;),this.space(),this.print(e.extendsType),this.space(),this.token(&quot;?&quot;),this.space(),this.print(e.trueType),this.space(),this.token(&quot;:&quot;),this.space(),this.print(e.falseType)},t.TSInferType=function(e){this.token(&quot;infer&quot;),this.space(),this.print(e.typeParameter)},t.TSParenthesizedType=function(e){this.token(&quot;(&quot;),this.print(e.typeAnnotation,e),this.token(&quot;)&quot;)},t.TSTypeOperator=function(e){this.word(e.operator),this.space(),this.print(e.typeAnnotation,e)},t.TSIndexedAccessType=function(e){this.print(e.objectType,e),this.token(&quot;[&quot;),this.print(e.indexType,e),this.token(&quot;]&quot;)},t.TSMappedType=function(e){const{nameType:t,optional:n,readonly:i,typeParameter:s}=e;this.token(&quot;{&quot;),this.space(),i&amp;&amp;(r(this,i),this.word(&quot;readonly&quot;),this.space()),this.token(&quot;[&quot;),this.word(s.name),this.space(),this.word(&quot;in&quot;),this.space(),this.print(s.constraint,s),t&amp;&amp;(this.space(),this.word(&quot;as&quot;),this.space(),this.print(t,e)),this.token(&quot;]&quot;),n&amp;&amp;(r(this,n),this.token(&quot;?&quot;)),this.token(&quot;:&quot;),this.space(),this.print(e.typeAnnotation,e),this.space(),this.token(&quot;}&quot;)},t.TSLiteralType=function(e){this.print(e.literal,e)},t.TSExpressionWithTypeArguments=function(e){this.print(e.expression,e),this.print(e.typeParameters,e)},t.TSInterfaceDeclaration=function(e){const{declare:t,id:r,typeParameters:n,extends:i,body:s}=e;t&amp;&amp;(this.word(&quot;declare&quot;),this.space()),this.word(&quot;interface&quot;),this.space(),this.print(r,e),this.print(n,e),i&amp;&amp;(this.space(),this.word(&quot;extends&quot;),this.space(),this.printList(i,e)),this.space(),this.print(s,e)},t.TSInterfaceBody=function(e){this.tsPrintTypeLiteralOrInterfaceBody(e.body,e)},t.TSTypeAliasDeclaration=function(e){const{declare:t,id:r,typeParameters:n,typeAnnotation:i}=e;t&amp;&amp;(this.word(&quot;declare&quot;),this.space()),this.word(&quot;type&quot;),this.space(),this.print(r,e),this.print(n,e),this.space(),this.token(&quot;=&quot;),this.space(),this.print(i,e),this.token(&quot;;&quot;)},t.TSAsExpression=function(e){const{expression:t,typeAnnotation:r}=e;this.print(t,e),this.space(),this.word(&quot;as&quot;),this.space(),this.print(r,e)},t.TSTypeAssertion=function(e){const{typeAnnotation:t,expression:r}=e;this.token(&quot;&lt;&quot;),this.print(t,e),this.token(&quot;&gt;&quot;),this.space(),this.print(r,e)},t.TSEnumDeclaration=function(e){const{declare:t,const:r,id:n,members:i}=e;t&amp;&amp;(this.word(&quot;declare&quot;),this.space()),r&amp;&amp;(this.word(&quot;const&quot;),this.space()),this.word(&quot;enum&quot;),this.space(),this.print(n,e),this.space(),this.tsPrintBraced(i,e)},t.TSEnumMember=function(e){const{id:t,initializer:r}=e;this.print(t,e),r&amp;&amp;(this.space(),this.token(&quot;=&quot;),this.space(),this.print(r,e)),this.token(&quot;,&quot;)},t.TSModuleDeclaration=function(e){const{declare:t,id:r}=e;if(t&amp;&amp;(this.word(&quot;declare&quot;),this.space()),e.global||(this.word(&quot;Identifier&quot;===r.type?&quot;namespace&quot;:&quot;module&quot;),this.space()),this.print(r,e),!e.body)return void this.token(&quot;;&quot;);let n=e.body;for(;&quot;TSModuleDeclaration&quot;===n.type;)this.token(&quot;.&quot;),this.print(n.id,n),n=n.body;this.space(),this.print(n,e)},t.TSModuleBlock=function(e){this.tsPrintBraced(e.body,e)},t.TSImportType=function(e){const{argument:t,qualifier:r,typeParameters:n}=e;this.word(&quot;import&quot;),this.token(&quot;(&quot;),this.print(t,e),this.token(&quot;)&quot;),r&amp;&amp;(this.token(&quot;.&quot;),this.print(r,e)),n&amp;&amp;this.print(n,e)},t.TSImportEqualsDeclaration=function(e){const{isExport:t,id:r,moduleReference:n}=e;t&amp;&amp;(this.word(&quot;export&quot;),this.space()),this.word(&quot;import&quot;),this.space(),this.print(r,e),this.space(),this.token(&quot;=&quot;),this.space(),this.print(n,e),this.token(&quot;;&quot;)},t.TSExternalModuleReference=function(e){this.token(&quot;require(&quot;),this.print(e.expression,e),this.token(&quot;)&quot;)},t.TSNonNullExpression=function(e){this.print(e.expression,e),this.token(&quot;!&quot;)},t.TSExportAssignment=function(e){this.word(&quot;export&quot;),this.space(),this.token(&quot;=&quot;),this.space(),this.print(e.expression,e),this.token(&quot;;&quot;)},t.TSNamespaceExportDeclaration=function(e){this.word(&quot;export&quot;),this.space(),this.word(&quot;as&quot;),this.space(),this.word(&quot;namespace&quot;),this.space(),this.print(e.id,e)},t.tsPrintSignatureDeclarationBase=function(e){const{typeParameters:t,parameters:r}=e;this.print(t,e),this.token(&quot;(&quot;),this._parameters(r,e),this.token(&quot;)&quot;),this.print(e.typeAnnotation,e)},t.tsPrintClassMemberModifiers=function(e,t){t&amp;&amp;e.declare&amp;&amp;(this.word(&quot;declare&quot;),this.space()),e.accessibility&amp;&amp;(this.word(e.accessibility),this.space()),e.static&amp;&amp;(this.word(&quot;static&quot;),this.space()),e.abstract&amp;&amp;(this.word(&quot;abstract&quot;),this.space()),t&amp;&amp;e.readonly&amp;&amp;(this.word(&quot;readonly&quot;),this.space())}},5386:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e,t,r){return new a(e,t,r).generate()},t.CodeGenerator=void 0;var n=s(r(1783)),i=s(r(3237));function s(e){return e&amp;&amp;e.__esModule?e:{default:e}}class a extends i.default{constructor(e,t={},r){const i=function(e,t){const r={auxiliaryCommentBefore:t.auxiliaryCommentBefore,auxiliaryCommentAfter:t.auxiliaryCommentAfter,shouldPrintComment:t.shouldPrintComment,retainLines:t.retainLines,retainFunctionParens:t.retainFunctionParens,comments:null==t.comments||t.comments,compact:t.compact,minified:t.minified,concise:t.concise,jsonCompatibleStrings:t.jsonCompatibleStrings,indent:{adjustMultilineComment:!0,style:&quot;  &quot;,base:0},decoratorsBeforeExport:!!t.decoratorsBeforeExport,jsescOption:Object.assign({quotes:&quot;double&quot;,wrap:!0},t.jsescOption),recordAndTupleSyntaxType:t.recordAndTupleSyntaxType};return r.minified?(r.compact=!0,r.shouldPrintComment=r.shouldPrintComment||(()=&gt;r.comments)):r.shouldPrintComment=r.shouldPrintComment||(e=&gt;r.comments||e.indexOf(&quot;@license&quot;)&gt;=0||e.indexOf(&quot;@preserve&quot;)&gt;=0),&quot;auto&quot;===r.compact&amp;&amp;(r.compact=e.length&gt;5e5,r.compact&amp;&amp;console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${t.filename} as it exceeds the max of 500KB.`)),r.compact&amp;&amp;(r.indent.adjustMultilineComment=!1),r}(r,t);super(i,t.sourceMaps?new n.default(t,r):null),this.ast=void 0,this.ast=e}generate(){return super.generate(this.ast)}}t.CodeGenerator=class{constructor(e,t,r){this._generator=new a(e,t,r)}generate(){return this._generator.generate()}}},944:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.needsWhitespace=f,t.needsWhitespaceBefore=function(e,t){return f(e,t,&quot;before&quot;)},t.needsWhitespaceAfter=function(e,t){return f(e,t,&quot;after&quot;)},t.needsParens=function(e,t,r){return!!t&amp;&amp;(!(!s.isNewExpression(t)||t.callee!==e||!h(e))||d(p,e,t,r))};var n=o(r(3880)),i=o(r(3602)),s=o(r(1710));function a(){if(&quot;function&quot;!=typeof WeakMap)return null;var e=new WeakMap;return a=function(){return e},e}function o(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;object&quot;!=typeof e&amp;&amp;&quot;function&quot;!=typeof e)return{default:e};var t=a();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var s=n?Object.getOwnPropertyDescriptor(e,i):null;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}return r.default=e,t&amp;&amp;t.set(e,r),r}function l(e){const t={};function r(e,r){const n=t[e];t[e]=n?function(e,t,i){const s=n(e,t,i);return null==s?r(e,t,i):s}:r}for(const t of Object.keys(e)){const n=s.FLIPPED_ALIAS_KEYS[t];if(n)for(const i of n)r(i,e[t]);else r(t,e[t])}return t}const p=l(i),c=l(n.nodes),u=l(n.list);function d(e,t,r,n){const i=e[t.type];return i?i(t,r,n):null}function h(e){return!!s.isCallExpression(e)||s.isMemberExpression(e)&amp;&amp;h(e.object)}function f(e,t,r){if(!e)return 0;s.isExpressionStatement(e)&amp;&amp;(e=e.expression);let n=d(c,e,t);if(!n){const i=d(u,e,t);if(i)for(let t=0;t&lt;i.length&amp;&amp;(n=f(i[t],e,r),!n);t++);}return&quot;object&quot;==typeof n&amp;&amp;null!==n&amp;&amp;n[r]||0}},3602:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.NullableTypeAnnotation=function(e,t){return n.isArrayTypeAnnotation(t)},t.FunctionTypeAnnotation=function(e,t,r){return n.isUnionTypeAnnotation(t)||n.isIntersectionTypeAnnotation(t)||n.isArrayTypeAnnotation(t)||n.isTypeAnnotation(t)&amp;&amp;n.isArrowFunctionExpression(r[r.length-3])},t.UpdateExpression=function(e,t){return o(e,t)||a(e,t)},t.ObjectExpression=function(e,t,r){return c(r,{considerArrow:!0})},t.DoExpression=function(e,t,r){return c(r)},t.Binary=function(e,t){if(&quot;**&quot;===e.operator&amp;&amp;n.isBinaryExpression(t,{operator:&quot;**&quot;}))return t.left===e;if(a(e,t))return!0;if(o(e,t)||n.isUnaryLike(t)||n.isAwaitExpression(t))return!0;if(n.isBinary(t)){const r=t.operator,i=s[r],a=e.operator,o=s[a];if(i===o&amp;&amp;t.right===e&amp;&amp;!n.isLogicalExpression(t)||i&gt;o)return!0}},t.IntersectionTypeAnnotation=t.UnionTypeAnnotation=function(e,t){return n.isArrayTypeAnnotation(t)||n.isNullableTypeAnnotation(t)||n.isIntersectionTypeAnnotation(t)||n.isUnionTypeAnnotation(t)},t.TSAsExpression=function(){return!0},t.TSTypeAssertion=function(){return!0},t.TSIntersectionType=t.TSUnionType=function(e,t){return n.isTSArrayType(t)||n.isTSOptionalType(t)||n.isTSIntersectionType(t)||n.isTSUnionType(t)||n.isTSRestType(t)},t.TSInferType=function(e,t){return n.isTSArrayType(t)||n.isTSOptionalType(t)},t.BinaryExpression=function(e,t){return&quot;in&quot;===e.operator&amp;&amp;(n.isVariableDeclarator(t)||n.isFor(t))},t.SequenceExpression=function(e,t){return!(n.isForStatement(t)||n.isThrowStatement(t)||n.isReturnStatement(t)||n.isIfStatement(t)&amp;&amp;t.test===e||n.isWhileStatement(t)&amp;&amp;t.test===e||n.isForInStatement(t)&amp;&amp;t.right===e||n.isSwitchStatement(t)&amp;&amp;t.discriminant===e||n.isExpressionStatement(t)&amp;&amp;t.expression===e)},t.AwaitExpression=t.YieldExpression=function(e,t){return n.isBinary(t)||n.isUnaryLike(t)||o(e,t)||n.isAwaitExpression(t)&amp;&amp;n.isYieldExpression(e)||n.isConditionalExpression(t)&amp;&amp;e===t.test||a(e,t)},t.ClassExpression=function(e,t,r){return c(r,{considerDefaultExports:!0})},t.UnaryLike=l,t.FunctionExpression=function(e,t,r){return c(r,{considerDefaultExports:!0})},t.ArrowFunctionExpression=function(e,t){return n.isExportDeclaration(t)||p(e,t)},t.ConditionalExpression=p,t.OptionalCallExpression=t.OptionalMemberExpression=function(e,t){return n.isCallExpression(t,{callee:e})||n.isMemberExpression(t,{object:e})},t.AssignmentExpression=function(e,t,r){return!!n.isObjectPattern(e.left)||p(e,t)},t.LogicalExpression=function(e,t){switch(e.operator){case&quot;||&quot;:return!!n.isLogicalExpression(t)&amp;&amp;(&quot;??&quot;===t.operator||&quot;&amp;&amp;&quot;===t.operator);case&quot;&amp;&amp;&quot;:return n.isLogicalExpression(t,{operator:&quot;??&quot;});case&quot;??&quot;:return n.isLogicalExpression(t)&amp;&amp;&quot;??&quot;!==t.operator}};var n=function(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;object&quot;!=typeof e&amp;&amp;&quot;function&quot;!=typeof e)return{default:e};var t=i();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var a=n?Object.getOwnPropertyDescriptor(e,s):null;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}return r.default=e,t&amp;&amp;t.set(e,r),r}(r(1710));function i(){if(&quot;function&quot;!=typeof WeakMap)return null;var e=new WeakMap;return i=function(){return e},e}const s={&quot;||&quot;:0,&quot;??&quot;:0,&quot;&amp;&amp;&quot;:1,&quot;|&quot;:2,&quot;^&quot;:3,&quot;&amp;&quot;:4,&quot;==&quot;:5,&quot;===&quot;:5,&quot;!=&quot;:5,&quot;!==&quot;:5,&quot;&lt;&quot;:6,&quot;&gt;&quot;:6,&quot;&lt;=&quot;:6,&quot;&gt;=&quot;:6,in:6,instanceof:6,&quot;&gt;&gt;&quot;:7,&quot;&lt;&lt;&quot;:7,&quot;&gt;&gt;&gt;&quot;:7,&quot;+&quot;:8,&quot;-&quot;:8,&quot;*&quot;:9,&quot;/&quot;:9,&quot;%&quot;:9,&quot;**&quot;:10},a=(e,t)=&gt;(n.isClassDeclaration(t)||n.isClassExpression(t))&amp;&amp;t.superClass===e,o=(e,t)=&gt;(n.isMemberExpression(t)||n.isOptionalMemberExpression(t))&amp;&amp;t.object===e||(n.isCallExpression(t)||n.isOptionalCallExpression(t)||n.isNewExpression(t))&amp;&amp;t.callee===e||n.isTaggedTemplateExpression(t)&amp;&amp;t.tag===e||n.isTSNonNullExpression(t);function l(e,t){return o(e,t)||n.isBinaryExpression(t,{operator:&quot;**&quot;,left:e})||a(e,t)}function p(e,t){return!!(n.isUnaryLike(t)||n.isBinary(t)||n.isConditionalExpression(t,{test:e})||n.isAwaitExpression(t)||n.isTSTypeAssertion(t)||n.isTSAsExpression(t))||l(e,t)}function c(e,{considerArrow:t=!1,considerDefaultExports:r=!1}={}){let i=e.length-1,s=e[i];i--;let a=e[i];for(;i&gt;=0;){if(n.isExpressionStatement(a,{expression:s})||r&amp;&amp;n.isExportDefaultDeclaration(a,{declaration:s})||t&amp;&amp;n.isArrowFunctionExpression(a,{body:s}))return!0;if(!(o(s,a)&amp;&amp;!n.isNewExpression(a)||n.isSequenceExpression(a)&amp;&amp;a.expressions[0]===s||n.isConditional(a,{test:s})||n.isBinary(a,{left:s})||n.isAssignmentExpression(a,{left:s})))return!1;s=a,i--,a=e[i]}return!1}},3880:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.list=t.nodes=void 0;var n=function(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;object&quot;!=typeof e&amp;&amp;&quot;function&quot;!=typeof e)return{default:e};var t=i();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var a=n?Object.getOwnPropertyDescriptor(e,s):null;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}return r.default=e,t&amp;&amp;t.set(e,r),r}(r(1710));function i(){if(&quot;function&quot;!=typeof WeakMap)return null;var e=new WeakMap;return i=function(){return e},e}function s(e,t={}){return n.isMemberExpression(e)||n.isOptionalMemberExpression(e)?(s(e.object,t),e.computed&amp;&amp;s(e.property,t)):n.isBinary(e)||n.isAssignmentExpression(e)?(s(e.left,t),s(e.right,t)):n.isCallExpression(e)||n.isOptionalCallExpression(e)?(t.hasCall=!0,s(e.callee,t)):n.isFunction(e)?t.hasFunction=!0:n.isIdentifier(e)&amp;&amp;(t.hasHelper=t.hasHelper||a(e.callee)),t}function a(e){return n.isMemberExpression(e)?a(e.object)||a(e.property):n.isIdentifier(e)?&quot;require&quot;===e.name||&quot;_&quot;===e.name[0]:n.isCallExpression(e)?a(e.callee):!(!n.isBinary(e)&amp;&amp;!n.isAssignmentExpression(e))&amp;&amp;(n.isIdentifier(e.left)&amp;&amp;a(e.left)||a(e.right))}function o(e){return n.isLiteral(e)||n.isObjectExpression(e)||n.isArrayExpression(e)||n.isIdentifier(e)||n.isMemberExpression(e)}const l={AssignmentExpression(e){const t=s(e.right);if(t.hasCall&amp;&amp;t.hasHelper||t.hasFunction)return{before:t.hasFunction,after:!0}},SwitchCase:(e,t)=&gt;({before:e.consequent.length||t.cases[0]===e,after:!e.consequent.length&amp;&amp;t.cases[t.cases.length-1]===e}),LogicalExpression(e){if(n.isFunction(e.left)||n.isFunction(e.right))return{after:!0}},Literal(e){if(&quot;use strict&quot;===e.value)return{after:!0}},CallExpression(e){if(n.isFunction(e.callee)||a(e))return{before:!0,after:!0}},OptionalCallExpression(e){if(n.isFunction(e.callee))return{before:!0,after:!0}},VariableDeclaration(e){for(let t=0;t&lt;e.declarations.length;t++){const r=e.declarations[t];let n=a(r.id)&amp;&amp;!o(r.init);if(!n){const e=s(r.init);n=a(r.init)&amp;&amp;e.hasCall||e.hasFunction}if(n)return{before:!0,after:!0}}},IfStatement(e){if(n.isBlockStatement(e.consequent))return{before:!0,after:!0}}};t.nodes=l,l.ObjectProperty=l.ObjectTypeProperty=l.ObjectMethod=function(e,t){if(t.properties[0]===e)return{before:!0}},l.ObjectTypeCallProperty=function(e,t){var r;if(t.callProperties[0]===e&amp;&amp;!(null==(r=t.properties)?void 0:r.length))return{before:!0}},l.ObjectTypeIndexer=function(e,t){var r,n;if(t.indexers[0]===e&amp;&amp;!(null==(r=t.properties)?void 0:r.length)&amp;&amp;!(null==(n=t.callProperties)?void 0:n.length))return{before:!0}},l.ObjectTypeInternalSlot=function(e,t){var r,n,i;if(t.internalSlots[0]===e&amp;&amp;!(null==(r=t.properties)?void 0:r.length)&amp;&amp;!(null==(n=t.callProperties)?void 0:n.length)&amp;&amp;!(null==(i=t.indexers)?void 0:i.length))return{before:!0}};t.list={VariableDeclaration:e=&gt;e.declarations.map((e=&gt;e.init)),ArrayExpression:e=&gt;e.elements,ObjectExpression:e=&gt;e.properties},[[&quot;Function&quot;,!0],[&quot;Class&quot;,!0],[&quot;Loop&quot;,!0],[&quot;LabeledStatement&quot;,!0],[&quot;SwitchStatement&quot;,!0],[&quot;TryStatement&quot;,!0]].forEach((function([e,t]){&quot;boolean&quot;==typeof t&amp;&amp;(t={after:t,before:t}),[e].concat(n.FLIPPED_ALIAS_KEYS[e]||[]).forEach((function(e){l[e]=function(){return t}}))}))},3237:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=void 0;var n,i=(n=r(8404))&amp;&amp;n.__esModule?n:{default:n},s=p(r(944)),a=p(r(1710)),o=p(r(1464));function l(){if(&quot;function&quot;!=typeof WeakMap)return null;var e=new WeakMap;return l=function(){return e},e}function p(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;object&quot;!=typeof e&amp;&amp;&quot;function&quot;!=typeof e)return{default:e};var t=l();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var s=n?Object.getOwnPropertyDescriptor(e,i):null;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}return r.default=e,t&amp;&amp;t.set(e,r),r}const c=/e/i,u=/</span><span class="s5">\.</span><span class="s3">0+$/,d=/^0[box]/,h=/^</span><span class="s5">\s</span><span class="s3">*[@#]__PURE__</span><span class="s5">\s</span><span class="s3">*$/;class f{constructor(e,t){this.inForStatementInitCounter=0,this._printStack=[],this._indent=0,this._insideAux=!1,this._printedCommentStarts={},this._parenPushNewlineState=null,this._noLineTerminator=!1,this._printAuxAfterOnNextUserNode=!1,this._printedComments=new WeakSet,this._endsWithInteger=!1,this._endsWithWord=!1,this.format=e||{},this._buf=new i.default(t)}generate(e){return this.print(e),this._maybeAddAuxComment(),this._buf.get()}indent(){this.format.compact||this.format.concise||this._indent++}dedent(){this.format.compact||this.format.concise||this._indent--}semicolon(e=!1){this._maybeAddAuxComment(),this._append(&quot;;&quot;,!e)}rightBrace(){this.format.minified&amp;&amp;this._buf.removeLastSemicolon(),this.token(&quot;}&quot;)}space(e=!1){this.format.compact||(this._buf.hasContent()&amp;&amp;!this.endsWith(&quot; &quot;)&amp;&amp;!this.endsWith(&quot;</span><span class="s4">\n</span><span class="s3">&quot;)||e)&amp;&amp;this._space()}word(e){(this._endsWithWord||this.endsWith(&quot;/&quot;)&amp;&amp;0===e.indexOf(&quot;/&quot;))&amp;&amp;this._space(),this._maybeAddAuxComment(),this._append(e),this._endsWithWord=!0}number(e){this.word(e),this._endsWithInteger=Number.isInteger(+e)&amp;&amp;!d.test(e)&amp;&amp;!c.test(e)&amp;&amp;!u.test(e)&amp;&amp;&quot;.&quot;!==e[e.length-1]}token(e){(&quot;--&quot;===e&amp;&amp;this.endsWith(&quot;!&quot;)||&quot;+&quot;===e[0]&amp;&amp;this.endsWith(&quot;+&quot;)||&quot;-&quot;===e[0]&amp;&amp;this.endsWith(&quot;-&quot;)||&quot;.&quot;===e[0]&amp;&amp;this._endsWithInteger)&amp;&amp;this._space(),this._maybeAddAuxComment(),this._append(e)}newline(e){if(!this.format.retainLines&amp;&amp;!this.format.compact)if(this.format.concise)this.space();else if(!(this.endsWith(&quot;</span><span class="s4">\n\n</span><span class="s3">&quot;)||(&quot;number&quot;!=typeof e&amp;&amp;(e=1),e=Math.min(2,e),(this.endsWith(&quot;{</span><span class="s4">\n</span><span class="s3">&quot;)||this.endsWith(&quot;:</span><span class="s4">\n</span><span class="s3">&quot;))&amp;&amp;e--,e&lt;=0)))for(let t=0;t&lt;e;t++)this._newline()}endsWith(e){return this._buf.endsWith(e)}removeTrailingNewline(){this._buf.removeTrailingNewline()}exactSource(e,t){this._catchUp(&quot;start&quot;,e),this._buf.exactSource(e,t)}source(e,t){this._catchUp(e,t),this._buf.source(e,t)}withSource(e,t,r){this._catchUp(e,t),this._buf.withSource(e,t,r)}_space(){this._append(&quot; &quot;,!0)}_newline(){this._append(&quot;</span><span class="s4">\n</span><span class="s3">&quot;,!0)}_append(e,t=!1){this._maybeAddParen(e),this._maybeIndent(e),t?this._buf.queue(e):this._buf.append(e),this._endsWithWord=!1,this._endsWithInteger=!1}_maybeIndent(e){this._indent&amp;&amp;this.endsWith(&quot;</span><span class="s4">\n</span><span class="s3">&quot;)&amp;&amp;&quot;</span><span class="s4">\n</span><span class="s3">&quot;!==e[0]&amp;&amp;this._buf.queue(this._getIndent())}_maybeAddParen(e){const t=this._parenPushNewlineState;if(!t)return;let r;for(r=0;r&lt;e.length&amp;&amp;&quot; &quot;===e[r];r++)continue;if(r===e.length)return;const n=e[r];if(&quot;</span><span class="s4">\n</span><span class="s3">&quot;!==n){if(&quot;/&quot;!==n||r+1===e.length)return void(this._parenPushNewlineState=null);const t=e[r+1];if(&quot;*&quot;===t){if(h.test(e.slice(r+2,e.length-2)))return}else if(&quot;/&quot;!==t)return void(this._parenPushNewlineState=null)}this.token(&quot;(&quot;),this.indent(),t.printed=!0}_catchUp(e,t){if(!this.format.retainLines)return;const r=t?t[e]:null;if(null!=(null==r?void 0:r.line)){const e=r.line-this._buf.getCurrentLine();for(let t=0;t&lt;e;t++)this._newline()}}_getIndent(){return this.format.indent.style.repeat(this._indent)}startTerminatorless(e=!1){return e?(this._noLineTerminator=!0,null):this._parenPushNewlineState={printed:!1}}endTerminatorless(e){this._noLineTerminator=!1,(null==e?void 0:e.printed)&amp;&amp;(this.dedent(),this.newline(),this.token(&quot;)&quot;))}print(e,t){if(!e)return;const r=this.format.concise;e._compact&amp;&amp;(this.format.concise=!0);const n=this[e.type];if(!n)throw new ReferenceError(`unknown node of type ${JSON.stringify(e.type)} with constructor ${JSON.stringify(null==e?void 0:e.constructor.name)}`);this._printStack.push(e);const i=this._insideAux;this._insideAux=!e.loc,this._maybeAddAuxComment(this._insideAux&amp;&amp;!i);let o=s.needsParens(e,t,this._printStack);this.format.retainFunctionParens&amp;&amp;&quot;FunctionExpression&quot;===e.type&amp;&amp;e.extra&amp;&amp;e.extra.parenthesized&amp;&amp;(o=!0),o&amp;&amp;this.token(&quot;(&quot;),this._printLeadingComments(e);const l=a.isProgram(e)||a.isFile(e)?null:e.loc;this.withSource(&quot;start&quot;,l,(()=&gt;{n.call(this,e,t)})),this._printTrailingComments(e),o&amp;&amp;this.token(&quot;)&quot;),this._printStack.pop(),this.format.concise=r,this._insideAux=i}_maybeAddAuxComment(e){e&amp;&amp;this._printAuxBeforeComment(),this._insideAux||this._printAuxAfterComment()}_printAuxBeforeComment(){if(this._printAuxAfterOnNextUserNode)return;this._printAuxAfterOnNextUserNode=!0;const e=this.format.auxiliaryCommentBefore;e&amp;&amp;this._printComment({type:&quot;CommentBlock&quot;,value:e})}_printAuxAfterComment(){if(!this._printAuxAfterOnNextUserNode)return;this._printAuxAfterOnNextUserNode=!1;const e=this.format.auxiliaryCommentAfter;e&amp;&amp;this._printComment({type:&quot;CommentBlock&quot;,value:e})}getPossibleRaw(e){const t=e.extra;if(t&amp;&amp;null!=t.raw&amp;&amp;null!=t.rawValue&amp;&amp;e.value===t.rawValue)return t.raw}printJoin(e,t,r={}){if(!(null==e?void 0:e.length))return;r.indent&amp;&amp;this.indent();const n={addNewlines:r.addNewlines};for(let i=0;i&lt;e.length;i++){const s=e[i];s&amp;&amp;(r.statement&amp;&amp;this._printNewline(!0,s,t,n),this.print(s,t),r.iterator&amp;&amp;r.iterator(s,i),r.separator&amp;&amp;i&lt;e.length-1&amp;&amp;r.separator.call(this),r.statement&amp;&amp;this._printNewline(!1,s,t,n))}r.indent&amp;&amp;this.dedent()}printAndIndentOnComments(e,t){const r=e.leadingComments&amp;&amp;e.leadingComments.length&gt;0;r&amp;&amp;this.indent(),this.print(e,t),r&amp;&amp;this.dedent()}printBlock(e){const t=e.body;a.isEmptyStatement(t)||this.space(),this.print(t,e)}_printTrailingComments(e){this._printComments(this._getComments(!1,e))}_printLeadingComments(e){this._printComments(this._getComments(!0,e),!0)}printInnerComments(e,t=!0){var r;(null==(r=e.innerComments)?void 0:r.length)&amp;&amp;(t&amp;&amp;this.indent(),this._printComments(e.innerComments),t&amp;&amp;this.dedent())}printSequence(e,t,r={}){return r.statement=!0,this.printJoin(e,t,r)}printList(e,t,r={}){return null==r.separator&amp;&amp;(r.separator=m),this.printJoin(e,t,r)}_printNewline(e,t,r,n){if(this.format.retainLines||this.format.compact)return;if(this.format.concise)return void this.space();let i=0;this._buf.hasContent()&amp;&amp;(e||i++,n.addNewlines&amp;&amp;(i+=n.addNewlines(e,t)||0),(e?s.needsWhitespaceBefore:s.needsWhitespaceAfter)(t,r)&amp;&amp;i++),this.newline(i)}_getComments(e,t){return t&amp;&amp;(e?t.leadingComments:t.trailingComments)||[]}_printComment(e,t){if(!this.format.shouldPrintComment(e.value))return;if(e.ignore)return;if(this._printedComments.has(e))return;if(this._printedComments.add(e),null!=e.start){if(this._printedCommentStarts[e.start])return;this._printedCommentStarts[e.start]=!0}const r=&quot;CommentBlock&quot;===e.type,n=r&amp;&amp;!t&amp;&amp;!this._noLineTerminator;n&amp;&amp;this._buf.hasContent()&amp;&amp;this.newline(1),this.endsWith(&quot;[&quot;)||this.endsWith(&quot;{&quot;)||this.space();let i=r||this._noLineTerminator?`/*${e.value}*/`:`//${e.value}</span><span class="s4">\n</span><span class="s3">`;if(r&amp;&amp;this.format.indent.adjustMultilineComment){var s;const t=null==(s=e.loc)?void 0:s.start.column;if(t){const e=new RegExp(&quot;</span><span class="s4">\\</span><span class="s3">n</span><span class="s4">\\</span><span class="s3">s{1,&quot;+t+&quot;}&quot;,&quot;g&quot;);i=i.replace(e,&quot;</span><span class="s4">\n</span><span class="s3">&quot;)}const r=Math.max(this._getIndent().length,this.format.retainLines?0:this._buf.getCurrentColumn());i=i.replace(/</span><span class="s4">\n</span><span class="s3">(?!$)/g,`</span><span class="s4">\n</span><span class="s3">${&quot; &quot;.repeat(r)}`)}this.endsWith(&quot;/&quot;)&amp;&amp;this._space(),this.withSource(&quot;start&quot;,e.loc,(()=&gt;{this._append(i)})),n&amp;&amp;this.newline(1)}_printComments(e,t){if(null==e?void 0:e.length)if(t&amp;&amp;1===e.length&amp;&amp;h.test(e[0].value))this._printComment(e[0],this._buf.hasContent()&amp;&amp;!this.endsWith(&quot;</span><span class="s4">\n</span><span class="s3">&quot;));else for(const t of e)this._printComment(t)}printAssertions(e){var t;(null==(t=e.assertions)?void 0:t.length)&amp;&amp;(this.space(),this.word(&quot;assert&quot;),this.space(),this.token(&quot;{&quot;),this.space(),this.printList(e.assertions,e),this.space(),this.token(&quot;}&quot;))}}function m(){this.token(&quot;,&quot;),this.space()}t.default=f,Object.assign(f.prototype,o)},1783:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=void 0;var n,i=(n=r(8737))&amp;&amp;n.__esModule?n:{default:n};t.default=class{constructor(e,t){this._cachedMap=null,this._code=t,this._opts=e,this._rawMappings=[]}get(){if(!this._cachedMap){const e=this._cachedMap=new i.default.SourceMapGenerator({sourceRoot:this._opts.sourceRoot}),t=this._code;&quot;string&quot;==typeof t?e.setSourceContent(this._opts.sourceFileName.replace(/</span><span class="s4">\\</span><span class="s3">/g,&quot;/&quot;),t):&quot;object&quot;==typeof t&amp;&amp;Object.keys(t).forEach((r=&gt;{e.setSourceContent(r.replace(/</span><span class="s4">\\</span><span class="s3">/g,&quot;/&quot;),t[r])})),this._rawMappings.forEach((t=&gt;e.addMapping(t)),e)}return this._cachedMap.toJSON()}getRawMappings(){return this._rawMappings.slice()}mark(e,t,r,n,i,s,a){this._lastGenLine!==e&amp;&amp;null===r||(a||this._lastGenLine!==e||this._lastSourceLine!==r||this._lastSourceColumn!==n)&amp;&amp;(this._cachedMap=null,this._lastGenLine=e,this._lastSourceLine=r,this._lastSourceColumn=n,this._rawMappings.push({name:i||void 0,generated:{line:e,column:t},source:null==r?void 0:(s||this._opts.sourceFileName).replace(/</span><span class="s4">\\</span><span class="s3">/g,&quot;/&quot;),original:null==r?void 0:{line:r,column:n}}))}}},7493:(e,t)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0});const r=!0,n=!0,i=!0,s=!0;class a{constructor(e,t={}){this.label=void 0,this.keyword=void 0,this.beforeExpr=void 0,this.startsExpr=void 0,this.rightAssociative=void 0,this.isLoop=void 0,this.isAssign=void 0,this.prefix=void 0,this.postfix=void 0,this.binop=void 0,this.updateContext=void 0,this.label=e,this.keyword=t.keyword,this.beforeExpr=!!t.beforeExpr,this.startsExpr=!!t.startsExpr,this.rightAssociative=!!t.rightAssociative,this.isLoop=!!t.isLoop,this.isAssign=!!t.isAssign,this.prefix=!!t.prefix,this.postfix=!!t.postfix,this.binop=null!=t.binop?t.binop:null,this.updateContext=null}}const o=new Map;function l(e,t={}){t.keyword=e;const r=new a(e,t);return o.set(e,r),r}function p(e,t){return new a(e,{beforeExpr:r,binop:t})}const c={num:new a(&quot;num&quot;,{startsExpr:n}),bigint:new a(&quot;bigint&quot;,{startsExpr:n}),decimal:new a(&quot;decimal&quot;,{startsExpr:n}),regexp:new a(&quot;regexp&quot;,{startsExpr:n}),string:new a(&quot;string&quot;,{startsExpr:n}),name:new a(&quot;name&quot;,{startsExpr:n}),eof:new a(&quot;eof&quot;),bracketL:new a(&quot;[&quot;,{beforeExpr:r,startsExpr:n}),bracketHashL:new a(&quot;#[&quot;,{beforeExpr:r,startsExpr:n}),bracketBarL:new a(&quot;[|&quot;,{beforeExpr:r,startsExpr:n}),bracketR:new a(&quot;]&quot;),bracketBarR:new a(&quot;|]&quot;),braceL:new a(&quot;{&quot;,{beforeExpr:r,startsExpr:n}),braceBarL:new a(&quot;{|&quot;,{beforeExpr:r,startsExpr:n}),braceHashL:new a(&quot;#{&quot;,{beforeExpr:r,startsExpr:n}),braceR:new a(&quot;}&quot;),braceBarR:new a(&quot;|}&quot;),parenL:new a(&quot;(&quot;,{beforeExpr:r,startsExpr:n}),parenR:new a(&quot;)&quot;),comma:new a(&quot;,&quot;,{beforeExpr:r}),semi:new a(&quot;;&quot;,{beforeExpr:r}),colon:new a(&quot;:&quot;,{beforeExpr:r}),doubleColon:new a(&quot;::&quot;,{beforeExpr:r}),dot:new a(&quot;.&quot;),question:new a(&quot;?&quot;,{beforeExpr:r}),questionDot:new a(&quot;?.&quot;),arrow:new a(&quot;=&gt;&quot;,{beforeExpr:r}),template:new a(&quot;template&quot;),ellipsis:new a(&quot;...&quot;,{beforeExpr:r}),backQuote:new a(&quot;`&quot;,{startsExpr:n}),dollarBraceL:new a(&quot;${&quot;,{beforeExpr:r,startsExpr:n}),at:new a(&quot;@&quot;),hash:new a(&quot;#&quot;,{startsExpr:n}),interpreterDirective:new a(&quot;#!...&quot;),eq:new a(&quot;=&quot;,{beforeExpr:r,isAssign:!0}),assign:new a(&quot;_=&quot;,{beforeExpr:r,isAssign:!0}),incDec:new a(&quot;++/--&quot;,{prefix:s,postfix:!0,startsExpr:n}),bang:new a(&quot;!&quot;,{beforeExpr:r,prefix:s,startsExpr:n}),tilde:new a(&quot;~&quot;,{beforeExpr:r,prefix:s,startsExpr:n}),pipeline:p(&quot;|&gt;&quot;,0),nullishCoalescing:p(&quot;??&quot;,1),logicalOR:p(&quot;||&quot;,1),logicalAND:p(&quot;&amp;&amp;&quot;,2),bitwiseOR:p(&quot;|&quot;,3),bitwiseXOR:p(&quot;^&quot;,4),bitwiseAND:p(&quot;&amp;&quot;,5),equality:p(&quot;==/!=/===/!==&quot;,6),relational:p(&quot;&lt;/&gt;/&lt;=/&gt;=&quot;,7),bitShift:p(&quot;&lt;&lt;/&gt;&gt;/&gt;&gt;&gt;&quot;,8),plusMin:new a(&quot;+/-&quot;,{beforeExpr:r,binop:9,prefix:s,startsExpr:n}),modulo:new a(&quot;%&quot;,{beforeExpr:r,binop:10,startsExpr:n}),star:new a(&quot;*&quot;,{binop:10}),slash:p(&quot;/&quot;,10),exponent:new a(&quot;**&quot;,{beforeExpr:r,binop:11,rightAssociative:!0}),_break:l(&quot;break&quot;),_case:l(&quot;case&quot;,{beforeExpr:r}),_catch:l(&quot;catch&quot;),_continue:l(&quot;continue&quot;),_debugger:l(&quot;debugger&quot;),_default:l(&quot;default&quot;,{beforeExpr:r}),_do:l(&quot;do&quot;,{isLoop:i,beforeExpr:r}),_else:l(&quot;else&quot;,{beforeExpr:r}),_finally:l(&quot;finally&quot;),_for:l(&quot;for&quot;,{isLoop:i}),_function:l(&quot;function&quot;,{startsExpr:n}),_if:l(&quot;if&quot;),_return:l(&quot;return&quot;,{beforeExpr:r}),_switch:l(&quot;switch&quot;),_throw:l(&quot;throw&quot;,{beforeExpr:r,prefix:s,startsExpr:n}),_try:l(&quot;try&quot;),_var:l(&quot;var&quot;),_const:l(&quot;const&quot;),_while:l(&quot;while&quot;,{isLoop:i}),_with:l(&quot;with&quot;),_new:l(&quot;new&quot;,{beforeExpr:r,startsExpr:n}),_this:l(&quot;this&quot;,{startsExpr:n}),_super:l(&quot;super&quot;,{startsExpr:n}),_class:l(&quot;class&quot;,{startsExpr:n}),_extends:l(&quot;extends&quot;,{beforeExpr:r}),_export:l(&quot;export&quot;),_import:l(&quot;import&quot;,{startsExpr:n}),_null:l(&quot;null&quot;,{startsExpr:n}),_true:l(&quot;true&quot;,{startsExpr:n}),_false:l(&quot;false&quot;,{startsExpr:n}),_in:l(&quot;in&quot;,{beforeExpr:r,binop:7}),_instanceof:l(&quot;instanceof&quot;,{beforeExpr:r,binop:7}),_typeof:l(&quot;typeof&quot;,{beforeExpr:r,prefix:s,startsExpr:n}),_void:l(&quot;void&quot;,{beforeExpr:r,prefix:s,startsExpr:n}),_delete:l(&quot;delete&quot;,{beforeExpr:r,prefix:s,startsExpr:n})},u=/</span><span class="s4">\r\n</span><span class="s3">?|[</span><span class="s4">\n\u2028\u2029</span><span class="s3">]/,d=new RegExp(u.source,&quot;g&quot;);function h(e){switch(e){case 10:case 13:case 8232:case 8233:return!0;default:return!1}}const f=/(?:</span><span class="s5">\s</span><span class="s3">|</span><span class="s5">\/\/</span><span class="s3">.*|</span><span class="s5">\/\*</span><span class="s3">[^]*?</span><span class="s5">\*\/</span><span class="s3">)*/g;function m(e){switch(e){case 9:case 11:case 12:case 32:case 160:case 5760:case 8192:case 8193:case 8194:case 8195:case 8196:case 8197:case 8198:case 8199:case 8200:case 8201:case 8202:case 8239:case 8287:case 12288:case 65279:return!0;default:return!1}}class y{constructor(e,t){this.line=void 0,this.column=void 0,this.line=e,this.column=t}}class T{constructor(e,t){this.start=void 0,this.end=void 0,this.filename=void 0,this.identifierName=void 0,this.start=e,this.end=t}}class b{constructor(){this.sawUnambiguousESM=!1,this.ambiguousScriptDifferentAst=!1}hasPlugin(e){return this.plugins.has(e)}getPluginOption(e,t){if(this.hasPlugin(e))return this.plugins.get(e)[t]}}function g(e){return e[e.length-1]}class S extends b{addComment(e){this.filename&amp;&amp;(e.loc.filename=this.filename),this.state.trailingComments.push(e),this.state.leadingComments.push(e)}adjustCommentsAfterTrailingComma(e,t,r){if(0===this.state.leadingComments.length)return;let n=null,i=t.length;for(;null===n&amp;&amp;i&gt;0;)n=t[--i];if(null===n)return;for(let e=0;e&lt;this.state.leadingComments.length;e++)this.state.leadingComments[e].end&lt;this.state.commentPreviousNode.end&amp;&amp;(this.state.leadingComments.splice(e,1),e--);const s=[];for(let t=0;t&lt;this.state.leadingComments.length;t++){const n=this.state.leadingComments[t];n.end&lt;e.end?(s.push(n),r||(this.state.leadingComments.splice(t,1),t--)):(void 0===e.trailingComments&amp;&amp;(e.trailingComments=[]),e.trailingComments.push(n))}r&amp;&amp;(this.state.leadingComments=[]),s.length&gt;0?n.trailingComments=s:void 0!==n.trailingComments&amp;&amp;(n.trailingComments=[])}processComment(e){if(&quot;Program&quot;===e.type&amp;&amp;e.body.length&gt;0)return;const t=this.state.commentStack;let r,n,i,s,a;if(this.state.trailingComments.length&gt;0)this.state.trailingComments[0].start&gt;=e.end?(i=this.state.trailingComments,this.state.trailingComments=[]):this.state.trailingComments.length=0;else if(t.length&gt;0){const r=g(t);r.trailingComments&amp;&amp;r.trailingComments[0].start&gt;=e.end&amp;&amp;(i=r.trailingComments,delete r.trailingComments)}for(t.length&gt;0&amp;&amp;g(t).start&gt;=e.start&amp;&amp;(r=t.pop());t.length&gt;0&amp;&amp;g(t).start&gt;=e.start;)n=t.pop();if(!n&amp;&amp;r&amp;&amp;(n=r),r)switch(e.type){case&quot;ObjectExpression&quot;:this.adjustCommentsAfterTrailingComma(e,e.properties);break;case&quot;ObjectPattern&quot;:this.adjustCommentsAfterTrailingComma(e,e.properties,!0);break;case&quot;CallExpression&quot;:this.adjustCommentsAfterTrailingComma(e,e.arguments);break;case&quot;ArrayExpression&quot;:this.adjustCommentsAfterTrailingComma(e,e.elements);break;case&quot;ArrayPattern&quot;:this.adjustCommentsAfterTrailingComma(e,e.elements,!0)}else this.state.commentPreviousNode&amp;&amp;(&quot;ImportSpecifier&quot;===this.state.commentPreviousNode.type&amp;&amp;&quot;ImportSpecifier&quot;!==e.type||&quot;ExportSpecifier&quot;===this.state.commentPreviousNode.type&amp;&amp;&quot;ExportSpecifier&quot;!==e.type)&amp;&amp;this.adjustCommentsAfterTrailingComma(e,[this.state.commentPreviousNode]);if(n){if(n.leadingComments)if(n!==e&amp;&amp;n.leadingComments.length&gt;0&amp;&amp;g(n.leadingComments).end&lt;=e.start)e.leadingComments=n.leadingComments,delete n.leadingComments;else for(s=n.leadingComments.length-2;s&gt;=0;--s)if(n.leadingComments[s].end&lt;=e.start){e.leadingComments=n.leadingComments.splice(0,s+1);break}}else if(this.state.leadingComments.length&gt;0)if(g(this.state.leadingComments).end&lt;=e.start){if(this.state.commentPreviousNode)for(a=0;a&lt;this.state.leadingComments.length;a++)this.state.leadingComments[a].end&lt;this.state.commentPreviousNode.end&amp;&amp;(this.state.leadingComments.splice(a,1),a--);this.state.leadingComments.length&gt;0&amp;&amp;(e.leadingComments=this.state.leadingComments,this.state.leadingComments=[])}else{for(s=0;s&lt;this.state.leadingComments.length&amp;&amp;!(this.state.leadingComments[s].end&gt;e.start);s++);const t=this.state.leadingComments.slice(0,s);t.length&amp;&amp;(e.leadingComments=t),i=this.state.leadingComments.slice(s),0===i.length&amp;&amp;(i=null)}if(this.state.commentPreviousNode=e,i)if(i.length&amp;&amp;i[0].start&gt;=e.start&amp;&amp;g(i).end&lt;=e.end)e.innerComments=i;else{const t=i.findIndex((t=&gt;t.end&gt;=e.end));t&gt;0?(e.innerComments=i.slice(0,t),e.trailingComments=i.slice(t)):e.trailingComments=i}t.push(e)}}const x=Object.freeze({AccessorIsGenerator:&quot;A %0ter cannot be a generator&quot;,ArgumentsInClass:&quot;'</span><span class="s0">arguments</span><span class="s3">' is only allowed in functions and class methods&quot;,AsyncFunctionInSingleStatementContext:&quot;Async functions can only be declared at the top level or inside a block&quot;,AwaitBindingIdentifier:&quot;Can not use '</span><span class="s0">await</span><span class="s3">' as identifier inside an async function&quot;,AwaitExpressionFormalParameter:&quot;await is not allowed in async function parameters&quot;,AwaitNotInAsyncContext:&quot;'</span><span class="s0">await</span><span class="s3">' is only allowed within async functions and at the top levels of modules&quot;,AwaitNotInAsyncFunction:&quot;'</span><span class="s0">await</span><span class="s3">' is only allowed within async functions&quot;,BadGetterArity:&quot;getter must not have any formal parameters&quot;,BadSetterArity:&quot;setter must have exactly one formal parameter&quot;,BadSetterRestParameter:&quot;setter function argument must not be a rest parameter&quot;,ConstructorClassField:&quot;Classes may not have a field named '</span><span class="s0">constructor</span><span class="s3">'&quot;,ConstructorClassPrivateField:&quot;Classes may not have a private field named '</span><span class="s0">#constructor</span><span class="s3">'&quot;,ConstructorIsAccessor:&quot;Class constructor may not be an accessor&quot;,ConstructorIsAsync:&quot;Constructor can'</span><span class="s0">t be an async </span><span class="s1">function</span><span class="s3">&quot;,ConstructorIsGenerator:&quot;</span><span class="s0">Constructor can</span><span class="s3">'t be a generator&quot;,DeclarationMissingInitializer:&quot;%0 require an initialization value&quot;,DecoratorBeforeExport:&quot;Decorators must be placed *before* the '</span><span class="s0">export</span><span class="s3">' keyword. You can set the '</span><span class="s0">decoratorsBeforeExport</span><span class="s3">' option to false to use the '</span><span class="s0">export @decorator class {}</span><span class="s3">' syntax&quot;,DecoratorConstructor:&quot;Decorators can'</span><span class="s0">t be used </span><span class="s1">with </span><span class="s0">a constructor. Did you mean </span><span class="s3">'@dec class { ... }'</span><span class="s0">?</span><span class="s3">&quot;,DecoratorExportClass:&quot;</span><span class="s0">Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.</span><span class="s3">&quot;,DecoratorSemicolon:&quot;</span><span class="s0">Decorators must not be followed by a semicolon</span><span class="s3">&quot;,DecoratorStaticBlock:&quot;</span><span class="s0">Decorators can</span><span class="s3">'t be used with a static block&quot;,DeletePrivateField:&quot;Deleting a private field is not allowed&quot;,DestructureNamedImport:&quot;ES2015 named imports do not destructure. Use another statement for destructuring after the import.&quot;,DuplicateConstructor:&quot;Duplicate constructor in the same class&quot;,DuplicateDefaultExport:&quot;Only one default export allowed per module.&quot;,DuplicateExport:&quot;`%0` has already been exported. Exported identifiers must be unique.&quot;,DuplicateProto:&quot;Redefinition of __proto__ property&quot;,DuplicateRegExpFlags:&quot;Duplicate regular expression flag&quot;,DuplicateStaticBlock:&quot;Duplicate static block in the same class&quot;,ElementAfterRest:&quot;Rest element must be last element&quot;,EscapedCharNotAnIdentifier:&quot;Invalid Unicode escape&quot;,ExportBindingIsString:&quot;A string literal cannot be used as an exported binding without `from`.</span><span class="s4">\n</span><span class="s3">- Did you mean `export { %0 as '</span><span class="s0">%</span><span class="s2">1</span><span class="s3">' } from '</span><span class="s0">some-module</span><span class="s3">'`?&quot;,ExportDefaultFromAsIdentifier:&quot;'</span><span class="s0">from</span><span class="s3">' is not allowed as an identifier after '</span><span class="s0">export </span><span class="s1">default</span><span class="s3">'&quot;,ForInOfLoopInitializer:&quot;%0 loop variable declaration may not have an initializer&quot;,GeneratorInSingleStatementContext:&quot;Generators can only be declared at the top level or inside a block&quot;,IllegalBreakContinue:&quot;Unsyntactic %0&quot;,IllegalLanguageModeDirective:&quot;Illegal '</span><span class="s0">use strict</span><span class="s3">' directive in function with non-simple parameter list&quot;,IllegalReturn:&quot;'</span><span class="s1">return</span><span class="s3">' outside of function&quot;,ImportBindingIsString:'</span><span class="s0">A string literal cannot be used as an imported binding.\n- Did you mean `import { </span><span class="s3">&quot;%0&quot; </span><span class="s0">as foo }`?</span><span class="s3">',ImportCallArgumentTrailingComma:&quot;Trailing comma is disallowed inside import(...) arguments&quot;,ImportCallArity:&quot;import() requires exactly %0&quot;,ImportCallNotNewExpression:&quot;Cannot use new with import(...)&quot;,ImportCallSpreadArgument:&quot;... is not allowed in import()&quot;,ImportMetaOutsideModule:&quot;import.meta may appear only with '</span><span class="s0">sourceType: \</span><span class="s3">&quot;module</span><span class="s4">\&quot;</span><span class="s3">'&quot;</span><span class="s0">,ImportOutsideModule:</span><span class="s3">&quot;'import' and 'export' may appear only with 'sourceType: </span><span class="s4">\&quot;</span><span class="s3">module</span><span class="s4">\&quot;</span><span class="s3">'&quot;</span><span class="s0">,InvalidBigIntLiteral:</span><span class="s3">&quot;Invalid BigIntLiteral&quot;</span><span class="s0">,InvalidCodePoint:</span><span class="s3">&quot;Code point out of bounds&quot;</span><span class="s0">,InvalidDecimal:</span><span class="s3">&quot;Invalid decimal&quot;</span><span class="s0">,InvalidDigit:</span><span class="s3">&quot;Expected number in radix %0&quot;</span><span class="s0">,InvalidEscapeSequence:</span><span class="s3">&quot;Bad character escape sequence&quot;</span><span class="s0">,InvalidEscapeSequenceTemplate:</span><span class="s3">&quot;Invalid escape sequence in template&quot;</span><span class="s0">,InvalidEscapedReservedWord:</span><span class="s3">&quot;Escape sequence in keyword %0&quot;</span><span class="s0">,InvalidIdentifier:</span><span class="s3">&quot;Invalid identifier %0&quot;</span><span class="s0">,InvalidLhs:</span><span class="s3">&quot;Invalid left-hand side in %0&quot;</span><span class="s0">,InvalidLhsBinding:</span><span class="s3">&quot;Binding invalid left-hand side in %0&quot;</span><span class="s0">,InvalidNumber:</span><span class="s3">&quot;Invalid number&quot;</span><span class="s0">,InvalidOrMissingExponent:</span><span class="s3">&quot;Floating-point numbers require a valid exponent after the 'e'&quot;</span><span class="s0">,InvalidOrUnexpectedToken:</span><span class="s3">&quot;Unexpected character '%0'&quot;</span><span class="s0">,InvalidParenthesizedAssignment:</span><span class="s3">&quot;Invalid parenthesized assignment pattern&quot;</span><span class="s0">,InvalidPrivateFieldResolution:</span><span class="s3">&quot;Private name #%0 is not defined&quot;</span><span class="s0">,InvalidPropertyBindingPattern:</span><span class="s3">&quot;Binding member expression&quot;</span><span class="s0">,InvalidRecordProperty:</span><span class="s3">&quot;Only properties and spread elements are allowed in record definitions&quot;</span><span class="s0">,InvalidRestAssignmentPattern:</span><span class="s3">&quot;Invalid rest operator's argument&quot;</span><span class="s0">,LabelRedeclaration:</span><span class="s3">&quot;Label '%0' is already declared&quot;</span><span class="s0">,LetInLexicalBinding:</span><span class="s3">&quot;'let' is not allowed to be used as a name in 'let' or 'const' declarations.&quot;</span><span class="s0">,LineTerminatorBeforeArrow:</span><span class="s3">&quot;No line break is allowed before '=&gt;'&quot;</span><span class="s0">,MalformedRegExpFlags:</span><span class="s3">&quot;Invalid regular expression flag&quot;</span><span class="s0">,MissingClassName:</span><span class="s3">&quot;A class name is required&quot;</span><span class="s0">,MissingEqInAssignment:</span><span class="s3">&quot;Only '=' operator can be used for specifying default value.&quot;</span><span class="s0">,MissingUnicodeEscape:</span><span class="s3">&quot;Expecting Unicode escape sequence </span><span class="s4">\\</span><span class="s3">uXXXX&quot;</span><span class="s0">,MixingCoalesceWithLogical:</span><span class="s3">&quot;Nullish coalescing operator(??) requires parens when mixing with logical operators&quot;</span><span class="s0">,ModuleAttributeDifferentFromType:</span><span class="s3">&quot;The only accepted module attribute is `type`&quot;</span><span class="s0">,ModuleAttributeInvalidValue:</span><span class="s3">&quot;Only string literals are allowed as module attribute values&quot;</span><span class="s0">,ModuleAttributesWithDuplicateKeys:</span><span class="s3">'Duplicate key &quot;%0&quot; is not allowed in module attributes'</span><span class="s0">,ModuleExportNameHasLoneSurrogate:</span><span class="s3">&quot;An export name cannot include a lone surrogate, found '</span><span class="s4">\\</span><span class="s3">u%0'&quot;</span><span class="s0">,ModuleExportUndefined:</span><span class="s3">&quot;Export '%0' is not defined&quot;</span><span class="s0">,MultipleDefaultsInSwitch:</span><span class="s3">&quot;Multiple default clauses&quot;</span><span class="s0">,NewlineAfterThrow:</span><span class="s3">&quot;Illegal newline after throw&quot;</span><span class="s0">,NoCatchOrFinally:</span><span class="s3">&quot;Missing catch or finally clause&quot;</span><span class="s0">,NumberIdentifier:</span><span class="s3">&quot;Identifier directly after number&quot;</span><span class="s0">,NumericSeparatorInEscapeSequence:</span><span class="s3">&quot;Numeric separators are not allowed inside unicode escape sequences or hex escape sequences&quot;</span><span class="s0">,ObsoleteAwaitStar:</span><span class="s3">&quot;await* has been removed from the async functions proposal. Use Promise.all() instead.&quot;</span><span class="s0">,OptionalChainingNoNew:</span><span class="s3">&quot;constructors in/after an Optional Chain are not allowed&quot;</span><span class="s0">,OptionalChainingNoTemplate:</span><span class="s3">&quot;Tagged Template Literals are not allowed in optionalChain&quot;</span><span class="s0">,ParamDupe:</span><span class="s3">&quot;Argument name clash&quot;</span><span class="s0">,PatternHasAccessor:</span><span class="s3">&quot;Object pattern can't contain getter or setter&quot;</span><span class="s0">,PatternHasMethod:</span><span class="s3">&quot;Object pattern can't contain methods&quot;</span><span class="s0">,PipelineBodyNoArrow:</span><span class="s3">'Unexpected arrow &quot;=&gt;&quot; after pipeline body; arrow function in pipeline body must be parenthesized'</span><span class="s0">,PipelineBodySequenceExpression:</span><span class="s3">&quot;Pipeline body may not be a comma-separated sequence expression&quot;</span><span class="s0">,PipelineHeadSequenceExpression:</span><span class="s3">&quot;Pipeline head should not be a comma-separated sequence expression&quot;</span><span class="s0">,PipelineTopicUnused:</span><span class="s3">&quot;Pipeline is in topic style but does not use topic reference&quot;</span><span class="s0">,PrimaryTopicNotAllowed:</span><span class="s3">&quot;Topic reference was used in a lexical context without topic binding&quot;</span><span class="s0">,PrimaryTopicRequiresSmartPipeline:</span><span class="s3">&quot;Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.&quot;</span><span class="s0">,PrivateInExpectedIn:</span><span class="s3">&quot;Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)&quot;</span><span class="s0">,PrivateNameRedeclaration:</span><span class="s3">&quot;Duplicate private name #%0&quot;</span><span class="s0">,RecordExpressionBarIncorrectEndSyntaxType:</span><span class="s3">&quot;Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'&quot;</span><span class="s0">,RecordExpressionBarIncorrectStartSyntaxType:</span><span class="s3">&quot;Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'&quot;</span><span class="s0">,RecordExpressionHashIncorrectStartSyntaxType:</span><span class="s3">&quot;Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'&quot;</span><span class="s0">,RecordNoProto:</span><span class="s3">&quot;'__proto__' is not allowed in Record expressions&quot;</span><span class="s0">,RestTrailingComma:</span><span class="s3">&quot;Unexpected trailing comma after rest element&quot;</span><span class="s0">,SloppyFunction:</span><span class="s3">&quot;In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement&quot;</span><span class="s0">,StaticPrototype:</span><span class="s3">&quot;Classes may not have static property named prototype&quot;</span><span class="s0">,StrictDelete:</span><span class="s3">&quot;Deleting local variable in strict mode&quot;</span><span class="s0">,StrictEvalArguments:</span><span class="s3">&quot;Assigning to '%0' in strict mode&quot;</span><span class="s0">,StrictEvalArgumentsBinding:</span><span class="s3">&quot;Binding '%0' in strict mode&quot;</span><span class="s0">,StrictFunction:</span><span class="s3">&quot;In strict mode code, functions can only be declared at top level or inside a block&quot;</span><span class="s0">,StrictNumericEscape:</span><span class="s3">&quot;The only valid numeric escape in strict mode is '</span><span class="s4">\\</span><span class="s3">0'&quot;</span><span class="s0">,StrictOctalLiteral:</span><span class="s3">&quot;Legacy octal literals are not allowed in strict mode&quot;</span><span class="s0">,StrictWith:</span><span class="s3">&quot;'with' in strict mode&quot;</span><span class="s0">,SuperNotAllowed:</span><span class="s3">&quot;super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?&quot;</span><span class="s0">,SuperPrivateField:</span><span class="s3">&quot;Private fields can't be accessed on super&quot;</span><span class="s0">,TrailingDecorator:</span><span class="s3">&quot;Decorators must be attached to a class element&quot;</span><span class="s0">,TupleExpressionBarIncorrectEndSyntaxType:</span><span class="s3">&quot;Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'&quot;</span><span class="s0">,TupleExpressionBarIncorrectStartSyntaxType:</span><span class="s3">&quot;Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'&quot;</span><span class="s0">,TupleExpressionHashIncorrectStartSyntaxType:</span><span class="s3">&quot;Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'&quot;</span><span class="s0">,UnexpectedArgumentPlaceholder:</span><span class="s3">&quot;Unexpected argument placeholder&quot;</span><span class="s0">,UnexpectedAwaitAfterPipelineBody:</span><span class="s3">'Unexpected &quot;await&quot; after pipeline body; await must have parentheses in minimal proposal'</span><span class="s0">,UnexpectedDigitAfterHash:</span><span class="s3">&quot;Unexpected digit after hash token&quot;</span><span class="s0">,UnexpectedImportExport:</span><span class="s3">&quot;'import' and 'export' may only appear at the top level&quot;</span><span class="s0">,UnexpectedKeyword:</span><span class="s3">&quot;Unexpected keyword '%0'&quot;</span><span class="s0">,UnexpectedLeadingDecorator:</span><span class="s3">&quot;Leading decorators must be attached to a class declaration&quot;</span><span class="s0">,UnexpectedLexicalDeclaration:</span><span class="s3">&quot;Lexical declaration cannot appear in a single-statement context&quot;</span><span class="s0">,UnexpectedNewTarget:</span><span class="s3">&quot;new.target can only be used in functions&quot;</span><span class="s0">,UnexpectedNumericSeparator:</span><span class="s3">&quot;A numeric separator is only allowed between two digits&quot;</span><span class="s0">,UnexpectedPrivateField:</span><span class="s3">&quot;Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )</span><span class="s4">\n </span><span class="s3">or a property of member expression (i.e. this.#p).&quot;</span><span class="s0">,UnexpectedReservedWord:</span><span class="s3">&quot;Unexpected reserved word '%0'&quot;</span><span class="s0">,UnexpectedSuper:</span><span class="s3">&quot;super is only allowed in object methods and classes&quot;</span><span class="s0">,UnexpectedToken:</span><span class="s3">&quot;Unexpected token '%0'&quot;</span><span class="s0">,UnexpectedTokenUnaryExponentiation:</span><span class="s3">&quot;Illegal expression. Wrap left hand side or entire exponentiation in parentheses.&quot;</span><span class="s0">,UnsupportedBind:</span><span class="s3">&quot;Binding should be performed on object property.&quot;</span><span class="s0">,UnsupportedDecoratorExport:</span><span class="s3">&quot;A decorated export must export a class declaration&quot;</span><span class="s0">,UnsupportedDefaultExport:</span><span class="s3">&quot;Only expressions, functions or classes are allowed as the `default` export.&quot;</span><span class="s0">,UnsupportedImport:</span><span class="s3">&quot;import can only be used in import() or import.meta&quot;</span><span class="s0">,UnsupportedMetaProperty:</span><span class="s3">&quot;The only valid meta property for %0 is %0.%1&quot;</span><span class="s0">,UnsupportedParameterDecorator:</span><span class="s3">&quot;Decorators cannot be used to decorate parameters&quot;</span><span class="s0">,UnsupportedPropertyDecorator:</span><span class="s3">&quot;Decorators cannot be used to decorate object literal properties&quot;</span><span class="s0">,UnsupportedSuper:</span><span class="s3">&quot;super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])&quot;</span><span class="s0">,UnterminatedComment:</span><span class="s3">&quot;Unterminated comment&quot;</span><span class="s0">,UnterminatedRegExp:</span><span class="s3">&quot;Unterminated regular expression&quot;</span><span class="s0">,UnterminatedString:</span><span class="s3">&quot;Unterminated string constant&quot;</span><span class="s0">,UnterminatedTemplate:</span><span class="s3">&quot;Unterminated template&quot;</span><span class="s0">,VarRedeclaration:</span><span class="s3">&quot;Identifier '%0' has already been declared&quot;</span><span class="s0">,YieldBindingIdentifier:</span><span class="s3">&quot;Can not use 'yield' as identifier inside a generator&quot;</span><span class="s0">,YieldInParameter:</span><span class="s3">&quot;Yield expression is not allowed in formal parameters&quot;</span><span class="s0">,ZeroDigitNumericSeparator:</span><span class="s3">&quot;Numeric separator can not be used after leading 0&quot;</span><span class="s0">});class E extends S{getLocationForPosition(e){let t;</span><span class="s1">return </span><span class="s0">t=e===</span><span class="s1">this</span><span class="s0">.state.start?</span><span class="s1">this</span><span class="s0">.state.startLoc:e===</span><span class="s1">this</span><span class="s0">.state.lastTokStart?</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc:e===</span><span class="s1">this</span><span class="s0">.state.end?</span><span class="s1">this</span><span class="s0">.state.endLoc:e===</span><span class="s1">this</span><span class="s0">.state.lastTokEnd?</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc:</span><span class="s1">function</span><span class="s0">(e,t){let r,n=</span><span class="s2">1</span><span class="s0">,i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(d.lastIndex=</span><span class="s2">0</span><span class="s0">;(r=d.exec(e))&amp;&amp;r.index&lt;t;)n++,i=d.lastIndex;</span><span class="s1">return new </span><span class="s0">y(n,t-i)}(</span><span class="s1">this</span><span class="s0">.input,e),t}raise(e,t,...r){</span><span class="s1">return this</span><span class="s0">.raiseWithData(e,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,t,...r)}raiseWithData(e,t,r,...n){const i=</span><span class="s1">this</span><span class="s0">.getLocationForPosition(e),s=r.replace(/%(\d+)/g,((e,t)=&gt;n[t]))+` (${i.line}:${i.column})`;</span><span class="s1">return this</span><span class="s0">._raise(Object.assign({loc:i,pos:e},t),s)}_raise(e,t){const r=</span><span class="s1">new </span><span class="s0">SyntaxError(t);</span><span class="s1">if</span><span class="s0">(Object.assign(r,e),</span><span class="s1">this</span><span class="s0">.options.errorRecovery)</span><span class="s1">return this</span><span class="s0">.isLookahead||</span><span class="s1">this</span><span class="s0">.state.errors.push(r),r;</span><span class="s1">throw </span><span class="s0">r}}</span><span class="s1">function </span><span class="s0">P(e){</span><span class="s1">return null</span><span class="s0">!=e&amp;&amp;</span><span class="s3">&quot;Property&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;init&quot;</span><span class="s0">===e.kind&amp;&amp;!</span><span class="s2">1</span><span class="s0">===e.method}class v{constructor(e,t,r,n){</span><span class="s1">this</span><span class="s0">.token=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isExpr=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.preserveSpace=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.override=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.token=e,</span><span class="s1">this</span><span class="s0">.isExpr=!!t,</span><span class="s1">this</span><span class="s0">.preserveSpace=!!r,</span><span class="s1">this</span><span class="s0">.override=n}}const A={braceStatement:</span><span class="s1">new </span><span class="s0">v(</span><span class="s3">&quot;{&quot;</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),braceExpression:</span><span class="s1">new </span><span class="s0">v(</span><span class="s3">&quot;{&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),recordExpression:</span><span class="s1">new </span><span class="s0">v(</span><span class="s3">&quot;#{&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),templateQuasi:</span><span class="s1">new </span><span class="s0">v(</span><span class="s3">&quot;${&quot;</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),parenStatement:</span><span class="s1">new </span><span class="s0">v(</span><span class="s3">&quot;(&quot;</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),parenExpression:</span><span class="s1">new </span><span class="s0">v(</span><span class="s3">&quot;(&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),template:</span><span class="s1">new </span><span class="s0">v(</span><span class="s3">&quot;`&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">,(e=&gt;e.readTmplToken())),functionExpression:</span><span class="s1">new </span><span class="s0">v(</span><span class="s3">&quot;function&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),functionStatement:</span><span class="s1">new </span><span class="s0">v(</span><span class="s3">&quot;function&quot;</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">)};c.parenR.updateContext=c.braceR.updateContext=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.context.length)</span><span class="s1">return void</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">0</span><span class="s0">);let e=</span><span class="s1">this</span><span class="s0">.state.context.pop();e===A.braceStatement&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.curContext().token&amp;&amp;(e=</span><span class="s1">this</span><span class="s0">.state.context.pop()),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!e.isExpr},c.name.updateContext=</span><span class="s1">function</span><span class="s0">(e){let t=!</span><span class="s2">1</span><span class="s0">;e!==c.dot&amp;&amp;(</span><span class="s3">&quot;of&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.state.value||</span><span class="s1">this</span><span class="s0">.state.exprAllowed||e===c._function||e===c._class||(t=!</span><span class="s2">0</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=t,</span><span class="s1">this</span><span class="s0">.state.isIterator&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.isIterator=!</span><span class="s2">1</span><span class="s0">)},c.braceL.updateContext=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">this</span><span class="s0">.state.context.push(</span><span class="s1">this</span><span class="s0">.braceIsBlock(e)?A.braceStatement:A.braceExpression),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">0</span><span class="s0">},c.dollarBraceL.updateContext=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">.state.context.push(A.templateQuasi),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">0</span><span class="s0">},c.parenL.updateContext=</span><span class="s1">function</span><span class="s0">(e){const t=e===c._if||e===c._for||e===c._with||e===c._while;</span><span class="s1">this</span><span class="s0">.state.context.push(t?A.parenStatement:A.parenExpression),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">0</span><span class="s0">},c.incDec.updateContext=</span><span class="s1">function</span><span class="s0">(){},c._function.updateContext=c._class.updateContext=</span><span class="s1">function</span><span class="s0">(e){!e.beforeExpr||e===c.semi||e===c._else||e===c._return&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()||(e===c.colon||e===c.braceL)&amp;&amp;</span><span class="s1">this</span><span class="s0">.curContext()===A.b_stat?</span><span class="s1">this</span><span class="s0">.state.context.push(A.functionStatement):</span><span class="s1">this</span><span class="s0">.state.context.push(A.functionExpression),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">},c.backQuote.updateContext=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">.curContext()===A.template?</span><span class="s1">this</span><span class="s0">.state.context.pop():</span><span class="s1">this</span><span class="s0">.state.context.push(A.template),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">},c.braceHashL.updateContext=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">.state.context.push(A.recordExpression),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">0</span><span class="s0">};let w=</span><span class="s3">&quot;ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-ꟊꟵ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ&quot;</span><span class="s0">,O=</span><span class="s3">&quot;‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿᫀᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿&quot;</span><span class="s0">;const I=</span><span class="s1">new </span><span class="s0">RegExp(</span><span class="s3">&quot;[&quot;</span><span class="s0">+w+</span><span class="s3">&quot;]&quot;</span><span class="s0">),N=</span><span class="s1">new </span><span class="s0">RegExp(</span><span class="s3">&quot;[&quot;</span><span class="s0">+w+O+</span><span class="s3">&quot;]&quot;</span><span class="s0">);w=O=</span><span class="s1">null</span><span class="s0">;const C=[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">25</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">122</span><span class="s0">,</span><span class="s2">70</span><span class="s0">,</span><span class="s2">52</span><span class="s0">,</span><span class="s2">268</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">48</span><span class="s0">,</span><span class="s2">48</span><span class="s0">,</span><span class="s2">31</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">37</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">157</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">39</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">51</span><span class="s0">,</span><span class="s2">157</span><span class="s0">,</span><span class="s2">310</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">153</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">66</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">25</span><span class="s0">,</span><span class="s2">71</span><span class="s0">,</span><span class="s2">55</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">65</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">36</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">27</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">53</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">111</span><span class="s0">,</span><span class="s2">72</span><span class="s0">,</span><span class="s2">56</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">349</span><span class="s0">,</span><span class="s2">41</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">79</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">107</span><span class="s0">,</span><span class="s2">20</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">52</span><span class="s0">,</span><span class="s2">76</span><span class="s0">,</span><span class="s2">44</span><span class="s0">,</span><span class="s2">33</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">27</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">34</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">36</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">85</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">46</span><span class="s0">,</span><span class="s2">39</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">159</span><span class="s0">,</span><span class="s2">52</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">31</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">185</span><span class="s0">,</span><span class="s2">46</span><span class="s0">,</span><span class="s2">42</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">37</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">60</span><span class="s0">,</span><span class="s2">42</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">72</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">230</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">117</span><span class="s0">,</span><span class="s2">63</span><span class="s0">,</span><span class="s2">32</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">23</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">95</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">38</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">39</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">45</span><span class="s0">,</span><span class="s2">20</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">56</span><span class="s0">,</span><span class="s2">264</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">36</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">113</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">37</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">31</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">328</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">190</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">80</span><span class="s0">,</span><span class="s2">921</span><span class="s0">,</span><span class="s2">103</span><span class="s0">,</span><span class="s2">110</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">195</span><span class="s0">,</span><span class="s2">2749</span><span class="s0">,</span><span class="s2">1070</span><span class="s0">,</span><span class="s2">4050</span><span class="s0">,</span><span class="s2">582</span><span class="s0">,</span><span class="s2">8634</span><span class="s0">,</span><span class="s2">568</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">114</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">32</span><span class="s0">,</span><span class="s2">20</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">689</span><span class="s0">,</span><span class="s2">63</span><span class="s0">,</span><span class="s2">129</span><span class="s0">,</span><span class="s2">74</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">67</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">65</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">6135</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">1237</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">8952</span><span class="s0">,</span><span class="s2">286</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">395</span><span class="s0">,</span><span class="s2">2309</span><span class="s0">,</span><span class="s2">106</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">5991</span><span class="s0">,</span><span class="s2">84</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">70</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">64</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">27</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">339</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2357</span><span class="s0">,</span><span class="s2">44</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">370</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">1301</span><span class="s0">,</span><span class="s2">196</span><span class="s0">,</span><span class="s2">60</span><span class="s0">,</span><span class="s2">67</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1205</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">4421</span><span class="s0">,</span><span class="s2">42717</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">4148</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">221</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">5761</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">7472</span><span class="s0">,</span><span class="s2">3104</span><span class="s0">,</span><span class="s2">541</span><span class="s0">,</span><span class="s2">1507</span><span class="s0">,</span><span class="s2">4938</span><span class="s0">],k=[</span><span class="s2">509</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">227</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">150</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">294</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">1368</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">41</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">166</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">574</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">370</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">154</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">176</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">32</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">46</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">37</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">45</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">49</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">83</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">161</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">56</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">193</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">82</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">214</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">83</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">82</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">84</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">243</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">166</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">71</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">120</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">41</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">406</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">57</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">123</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">49</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">330</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">19306</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">135</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">60</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">1014</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">82</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">19628</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">5319</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">31</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">149</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1418</span><span class="s0">,</span><span class="s2">49</span><span class="s0">,</span><span class="s2">513</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">49</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">23</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">1361</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">262</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">419</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">1495</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">110</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">4759</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">787719</span><span class="s0">,</span><span class="s2">239</span><span class="s0">];</span><span class="s1">function </span><span class="s0">D(e,t){let r=</span><span class="s2">65536</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let n=</span><span class="s2">0</span><span class="s0">,i=t.length;n&lt;i;n+=</span><span class="s2">2</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(r+=t[n],r&gt;e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(r+=t[n+</span><span class="s2">1</span><span class="s0">],r&gt;=e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}</span><span class="s1">function </span><span class="s0">_(e){</span><span class="s1">return </span><span class="s0">e&lt;</span><span class="s2">65</span><span class="s0">?</span><span class="s2">36</span><span class="s0">===e:e&lt;=</span><span class="s2">90</span><span class="s0">||(e&lt;</span><span class="s2">97</span><span class="s0">?</span><span class="s2">95</span><span class="s0">===e:e&lt;=</span><span class="s2">122</span><span class="s0">||(e&lt;=</span><span class="s2">65535</span><span class="s0">?e&gt;=</span><span class="s2">170</span><span class="s0">&amp;&amp;I.test(String.fromCharCode(e)):D(e,C)))}</span><span class="s1">function </span><span class="s0">L(e){</span><span class="s1">return </span><span class="s0">e&lt;</span><span class="s2">48</span><span class="s0">?</span><span class="s2">36</span><span class="s0">===e:e&lt;</span><span class="s2">58</span><span class="s0">||!(e&lt;</span><span class="s2">65</span><span class="s0">)&amp;&amp;(e&lt;=</span><span class="s2">90</span><span class="s0">||(e&lt;</span><span class="s2">97</span><span class="s0">?</span><span class="s2">95</span><span class="s0">===e:e&lt;=</span><span class="s2">122</span><span class="s0">||(e&lt;=</span><span class="s2">65535</span><span class="s0">?e&gt;=</span><span class="s2">170</span><span class="s0">&amp;&amp;N.test(String.fromCharCode(e)):D(e,C)||D(e,k))))}const M=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">&quot;break&quot;</span><span class="s0">,</span><span class="s3">&quot;case&quot;</span><span class="s0">,</span><span class="s3">&quot;catch&quot;</span><span class="s0">,</span><span class="s3">&quot;continue&quot;</span><span class="s0">,</span><span class="s3">&quot;debugger&quot;</span><span class="s0">,</span><span class="s3">&quot;default&quot;</span><span class="s0">,</span><span class="s3">&quot;do&quot;</span><span class="s0">,</span><span class="s3">&quot;else&quot;</span><span class="s0">,</span><span class="s3">&quot;finally&quot;</span><span class="s0">,</span><span class="s3">&quot;for&quot;</span><span class="s0">,</span><span class="s3">&quot;function&quot;</span><span class="s0">,</span><span class="s3">&quot;if&quot;</span><span class="s0">,</span><span class="s3">&quot;return&quot;</span><span class="s0">,</span><span class="s3">&quot;switch&quot;</span><span class="s0">,</span><span class="s3">&quot;throw&quot;</span><span class="s0">,</span><span class="s3">&quot;try&quot;</span><span class="s0">,</span><span class="s3">&quot;var&quot;</span><span class="s0">,</span><span class="s3">&quot;const&quot;</span><span class="s0">,</span><span class="s3">&quot;while&quot;</span><span class="s0">,</span><span class="s3">&quot;with&quot;</span><span class="s0">,</span><span class="s3">&quot;new&quot;</span><span class="s0">,</span><span class="s3">&quot;this&quot;</span><span class="s0">,</span><span class="s3">&quot;super&quot;</span><span class="s0">,</span><span class="s3">&quot;class&quot;</span><span class="s0">,</span><span class="s3">&quot;extends&quot;</span><span class="s0">,</span><span class="s3">&quot;export&quot;</span><span class="s0">,</span><span class="s3">&quot;import&quot;</span><span class="s0">,</span><span class="s3">&quot;null&quot;</span><span class="s0">,</span><span class="s3">&quot;true&quot;</span><span class="s0">,</span><span class="s3">&quot;false&quot;</span><span class="s0">,</span><span class="s3">&quot;in&quot;</span><span class="s0">,</span><span class="s3">&quot;instanceof&quot;</span><span class="s0">,</span><span class="s3">&quot;typeof&quot;</span><span class="s0">,</span><span class="s3">&quot;void&quot;</span><span class="s0">,</span><span class="s3">&quot;delete&quot;</span><span class="s0">]),j=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">&quot;implements&quot;</span><span class="s0">,</span><span class="s3">&quot;interface&quot;</span><span class="s0">,</span><span class="s3">&quot;let&quot;</span><span class="s0">,</span><span class="s3">&quot;package&quot;</span><span class="s0">,</span><span class="s3">&quot;private&quot;</span><span class="s0">,</span><span class="s3">&quot;protected&quot;</span><span class="s0">,</span><span class="s3">&quot;public&quot;</span><span class="s0">,</span><span class="s3">&quot;static&quot;</span><span class="s0">,</span><span class="s3">&quot;yield&quot;</span><span class="s0">]),F=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">&quot;eval&quot;</span><span class="s0">,</span><span class="s3">&quot;arguments&quot;</span><span class="s0">]);</span><span class="s1">function </span><span class="s0">B(e,t){</span><span class="s1">return </span><span class="s0">t&amp;&amp;</span><span class="s3">&quot;await&quot;</span><span class="s0">===e||</span><span class="s3">&quot;enum&quot;</span><span class="s0">===e}</span><span class="s1">function </span><span class="s0">R(e,t){</span><span class="s1">return </span><span class="s0">B(e,t)||j.has(e)}</span><span class="s1">function </span><span class="s0">U(e){</span><span class="s1">return </span><span class="s0">F.has(e)}</span><span class="s1">function </span><span class="s0">V(e,t){</span><span class="s1">return </span><span class="s0">R(e,t)||U(e)}</span><span class="s1">function </span><span class="s0">K(e){</span><span class="s1">return </span><span class="s0">M.has(e)}const q=/^</span><span class="s1">in</span><span class="s0">(stanceof)?$/,Y=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">&quot;_&quot;</span><span class="s0">,</span><span class="s3">&quot;any&quot;</span><span class="s0">,</span><span class="s3">&quot;bool&quot;</span><span class="s0">,</span><span class="s3">&quot;boolean&quot;</span><span class="s0">,</span><span class="s3">&quot;empty&quot;</span><span class="s0">,</span><span class="s3">&quot;extends&quot;</span><span class="s0">,</span><span class="s3">&quot;false&quot;</span><span class="s0">,</span><span class="s3">&quot;interface&quot;</span><span class="s0">,</span><span class="s3">&quot;mixed&quot;</span><span class="s0">,</span><span class="s3">&quot;null&quot;</span><span class="s0">,</span><span class="s3">&quot;number&quot;</span><span class="s0">,</span><span class="s3">&quot;static&quot;</span><span class="s0">,</span><span class="s3">&quot;string&quot;</span><span class="s0">,</span><span class="s3">&quot;true&quot;</span><span class="s0">,</span><span class="s3">&quot;typeof&quot;</span><span class="s0">,</span><span class="s3">&quot;void&quot;</span><span class="s0">]),W=Object.freeze({AmbiguousConditionalArrow:</span><span class="s3">&quot;Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.&quot;</span><span class="s0">,AmbiguousDeclareModuleKind:</span><span class="s3">&quot;Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module&quot;</span><span class="s0">,AssignReservedType:</span><span class="s3">&quot;Cannot overwrite reserved type %0&quot;</span><span class="s0">,DeclareClassElement:</span><span class="s3">&quot;The `declare` modifier can only appear on class fields.&quot;</span><span class="s0">,DeclareClassFieldInitializer:</span><span class="s3">&quot;Initializers are not allowed in fields with the `declare` modifier.&quot;</span><span class="s0">,DuplicateDeclareModuleExports:</span><span class="s3">&quot;Duplicate `declare module.exports` statement&quot;</span><span class="s0">,EnumBooleanMemberNotInitialized:</span><span class="s3">&quot;Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.&quot;</span><span class="s0">,EnumDuplicateMemberName:</span><span class="s3">&quot;Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.&quot;</span><span class="s0">,EnumInconsistentMemberValues:</span><span class="s3">&quot;Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.&quot;</span><span class="s0">,EnumInvalidExplicitType:</span><span class="s3">&quot;Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.&quot;</span><span class="s0">,EnumInvalidExplicitTypeUnknownSupplied:</span><span class="s3">&quot;Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.&quot;</span><span class="s0">,EnumInvalidMemberInitializerPrimaryType:</span><span class="s3">&quot;Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.&quot;</span><span class="s0">,EnumInvalidMemberInitializerSymbolType:</span><span class="s3">&quot;Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.&quot;</span><span class="s0">,EnumInvalidMemberInitializerUnknownType:</span><span class="s3">&quot;The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.&quot;</span><span class="s0">,EnumInvalidMemberName:</span><span class="s3">&quot;Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.&quot;</span><span class="s0">,EnumNumberMemberNotInitialized:</span><span class="s3">&quot;Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.&quot;</span><span class="s0">,EnumStringMemberInconsistentlyInitailized:</span><span class="s3">&quot;String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.&quot;</span><span class="s0">,ImportTypeShorthandOnlyInPureImport:</span><span class="s3">&quot;The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements&quot;</span><span class="s0">,InexactInsideExact:</span><span class="s3">&quot;Explicit inexact syntax cannot appear inside an explicit exact object type&quot;</span><span class="s0">,InexactInsideNonObject:</span><span class="s3">&quot;Explicit inexact syntax cannot appear in class or interface definitions&quot;</span><span class="s0">,InexactVariance:</span><span class="s3">&quot;Explicit inexact syntax cannot have variance&quot;</span><span class="s0">,InvalidNonTypeImportInDeclareModule:</span><span class="s3">&quot;Imports within a `declare module` body must always be `import type` or `import typeof`&quot;</span><span class="s0">,MissingTypeParamDefault:</span><span class="s3">&quot;Type parameter declaration needs a default, since a preceding type parameter declaration has a default.&quot;</span><span class="s0">,NestedDeclareModule:</span><span class="s3">&quot;`declare module` cannot be used inside another `declare module`&quot;</span><span class="s0">,NestedFlowComment:</span><span class="s3">&quot;Cannot have a flow comment inside another flow comment&quot;</span><span class="s0">,OptionalBindingPattern:</span><span class="s3">&quot;A binding pattern parameter cannot be optional in an implementation signature.&quot;</span><span class="s0">,SpreadVariance:</span><span class="s3">&quot;Spread properties cannot have variance&quot;</span><span class="s0">,TypeBeforeInitializer:</span><span class="s3">&quot;Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`&quot;</span><span class="s0">,TypeCastInPattern:</span><span class="s3">&quot;The type cast expression is expected to be wrapped with parenthesis&quot;</span><span class="s0">,UnexpectedExplicitInexactInObject:</span><span class="s3">&quot;Explicit inexact syntax must appear at the end of an inexact object&quot;</span><span class="s0">,UnexpectedReservedType:</span><span class="s3">&quot;Unexpected reserved type %0&quot;</span><span class="s0">,UnexpectedReservedUnderscore:</span><span class="s3">&quot;`_` is only allowed as a type argument to call or new&quot;</span><span class="s0">,UnexpectedSpaceBetweenModuloChecks:</span><span class="s3">&quot;Spaces between `%` and `checks` are not allowed here.&quot;</span><span class="s0">,UnexpectedSpreadType:</span><span class="s3">&quot;Spread operator cannot appear in class or interface definitions&quot;</span><span class="s0">,UnexpectedSubtractionOperand:</span><span class="s3">'Unexpected token, expected &quot;number&quot; or &quot;bigint&quot;'</span><span class="s0">,UnexpectedTokenAfterTypeParameter:</span><span class="s3">&quot;Expected an arrow function after this type parameter declaration&quot;</span><span class="s0">,UnexpectedTypeParameterBeforeAsyncArrowFunction:</span><span class="s3">&quot;Type parameters must come after the async keyword, e.g. instead of `&lt;T&gt; async () =&gt; {}`, use `async &lt;T&gt;() =&gt; {}`&quot;</span><span class="s0">,UnsupportedDeclareExportKind:</span><span class="s3">&quot;`declare export %0` is not supported. Use `%1` instead&quot;</span><span class="s0">,UnsupportedStatementInDeclareModule:</span><span class="s3">&quot;Only declares and type imports are allowed inside declare module&quot;</span><span class="s0">,UnterminatedFlowComment:</span><span class="s3">&quot;Unterminated flow-comment&quot;</span><span class="s0">});</span><span class="s1">function </span><span class="s0">X(e){</span><span class="s1">return</span><span class="s3">&quot;type&quot;</span><span class="s0">===e.importKind||</span><span class="s3">&quot;typeof&quot;</span><span class="s0">===e.importKind}</span><span class="s1">function </span><span class="s0">J(e){</span><span class="s1">return</span><span class="s0">(e.type===c.name||!!e.type.keyword)&amp;&amp;</span><span class="s3">&quot;from&quot;</span><span class="s0">!==e.value}const H={const:</span><span class="s3">&quot;declare export var&quot;</span><span class="s0">,let:</span><span class="s3">&quot;declare export var&quot;</span><span class="s0">,type:</span><span class="s3">&quot;export type&quot;</span><span class="s0">,interface:</span><span class="s3">&quot;export interface&quot;</span><span class="s0">},G=/\*?\s*@((?:no)?flow)\b/,z={quot:</span><span class="s3">'&quot;'</span><span class="s0">,amp:</span><span class="s3">&quot;&amp;&quot;</span><span class="s0">,apos:</span><span class="s3">&quot;'&quot;</span><span class="s0">,lt:</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">,gt:</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">,nbsp:</span><span class="s3">&quot; &quot;</span><span class="s0">,iexcl:</span><span class="s3">&quot;¡&quot;</span><span class="s0">,cent:</span><span class="s3">&quot;¢&quot;</span><span class="s0">,pound:</span><span class="s3">&quot;£&quot;</span><span class="s0">,curren:</span><span class="s3">&quot;¤&quot;</span><span class="s0">,yen:</span><span class="s3">&quot;¥&quot;</span><span class="s0">,brvbar:</span><span class="s3">&quot;¦&quot;</span><span class="s0">,sect:</span><span class="s3">&quot;§&quot;</span><span class="s0">,uml:</span><span class="s3">&quot;¨&quot;</span><span class="s0">,copy:</span><span class="s3">&quot;©&quot;</span><span class="s0">,ordf:</span><span class="s3">&quot;ª&quot;</span><span class="s0">,laquo:</span><span class="s3">&quot;«&quot;</span><span class="s0">,not:</span><span class="s3">&quot;¬&quot;</span><span class="s0">,shy:</span><span class="s3">&quot;­&quot;</span><span class="s0">,reg:</span><span class="s3">&quot;®&quot;</span><span class="s0">,macr:</span><span class="s3">&quot;¯&quot;</span><span class="s0">,deg:</span><span class="s3">&quot;°&quot;</span><span class="s0">,plusmn:</span><span class="s3">&quot;±&quot;</span><span class="s0">,sup2:</span><span class="s3">&quot;²&quot;</span><span class="s0">,sup3:</span><span class="s3">&quot;³&quot;</span><span class="s0">,acute:</span><span class="s3">&quot;´&quot;</span><span class="s0">,micro:</span><span class="s3">&quot;µ&quot;</span><span class="s0">,para:</span><span class="s3">&quot;¶&quot;</span><span class="s0">,middot:</span><span class="s3">&quot;·&quot;</span><span class="s0">,cedil:</span><span class="s3">&quot;¸&quot;</span><span class="s0">,sup1:</span><span class="s3">&quot;¹&quot;</span><span class="s0">,ordm:</span><span class="s3">&quot;º&quot;</span><span class="s0">,raquo:</span><span class="s3">&quot;»&quot;</span><span class="s0">,frac14:</span><span class="s3">&quot;¼&quot;</span><span class="s0">,frac12:</span><span class="s3">&quot;½&quot;</span><span class="s0">,frac34:</span><span class="s3">&quot;¾&quot;</span><span class="s0">,iquest:</span><span class="s3">&quot;¿&quot;</span><span class="s0">,Agrave:</span><span class="s3">&quot;À&quot;</span><span class="s0">,Aacute:</span><span class="s3">&quot;Á&quot;</span><span class="s0">,Acirc:</span><span class="s3">&quot;Â&quot;</span><span class="s0">,Atilde:</span><span class="s3">&quot;Ã&quot;</span><span class="s0">,Auml:</span><span class="s3">&quot;Ä&quot;</span><span class="s0">,Aring:</span><span class="s3">&quot;Å&quot;</span><span class="s0">,AElig:</span><span class="s3">&quot;Æ&quot;</span><span class="s0">,Ccedil:</span><span class="s3">&quot;Ç&quot;</span><span class="s0">,Egrave:</span><span class="s3">&quot;È&quot;</span><span class="s0">,Eacute:</span><span class="s3">&quot;É&quot;</span><span class="s0">,Ecirc:</span><span class="s3">&quot;Ê&quot;</span><span class="s0">,Euml:</span><span class="s3">&quot;Ë&quot;</span><span class="s0">,Igrave:</span><span class="s3">&quot;Ì&quot;</span><span class="s0">,Iacute:</span><span class="s3">&quot;Í&quot;</span><span class="s0">,Icirc:</span><span class="s3">&quot;Î&quot;</span><span class="s0">,Iuml:</span><span class="s3">&quot;Ï&quot;</span><span class="s0">,ETH:</span><span class="s3">&quot;Ð&quot;</span><span class="s0">,Ntilde:</span><span class="s3">&quot;Ñ&quot;</span><span class="s0">,Ograve:</span><span class="s3">&quot;Ò&quot;</span><span class="s0">,Oacute:</span><span class="s3">&quot;Ó&quot;</span><span class="s0">,Ocirc:</span><span class="s3">&quot;Ô&quot;</span><span class="s0">,Otilde:</span><span class="s3">&quot;Õ&quot;</span><span class="s0">,Ouml:</span><span class="s3">&quot;Ö&quot;</span><span class="s0">,times:</span><span class="s3">&quot;×&quot;</span><span class="s0">,Oslash:</span><span class="s3">&quot;Ø&quot;</span><span class="s0">,Ugrave:</span><span class="s3">&quot;Ù&quot;</span><span class="s0">,Uacute:</span><span class="s3">&quot;Ú&quot;</span><span class="s0">,Ucirc:</span><span class="s3">&quot;Û&quot;</span><span class="s0">,Uuml:</span><span class="s3">&quot;Ü&quot;</span><span class="s0">,Yacute:</span><span class="s3">&quot;Ý&quot;</span><span class="s0">,THORN:</span><span class="s3">&quot;Þ&quot;</span><span class="s0">,szlig:</span><span class="s3">&quot;ß&quot;</span><span class="s0">,agrave:</span><span class="s3">&quot;à&quot;</span><span class="s0">,aacute:</span><span class="s3">&quot;á&quot;</span><span class="s0">,acirc:</span><span class="s3">&quot;â&quot;</span><span class="s0">,atilde:</span><span class="s3">&quot;ã&quot;</span><span class="s0">,auml:</span><span class="s3">&quot;ä&quot;</span><span class="s0">,aring:</span><span class="s3">&quot;å&quot;</span><span class="s0">,aelig:</span><span class="s3">&quot;æ&quot;</span><span class="s0">,ccedil:</span><span class="s3">&quot;ç&quot;</span><span class="s0">,egrave:</span><span class="s3">&quot;è&quot;</span><span class="s0">,eacute:</span><span class="s3">&quot;é&quot;</span><span class="s0">,ecirc:</span><span class="s3">&quot;ê&quot;</span><span class="s0">,euml:</span><span class="s3">&quot;ë&quot;</span><span class="s0">,igrave:</span><span class="s3">&quot;ì&quot;</span><span class="s0">,iacute:</span><span class="s3">&quot;í&quot;</span><span class="s0">,icirc:</span><span class="s3">&quot;î&quot;</span><span class="s0">,iuml:</span><span class="s3">&quot;ï&quot;</span><span class="s0">,eth:</span><span class="s3">&quot;ð&quot;</span><span class="s0">,ntilde:</span><span class="s3">&quot;ñ&quot;</span><span class="s0">,ograve:</span><span class="s3">&quot;ò&quot;</span><span class="s0">,oacute:</span><span class="s3">&quot;ó&quot;</span><span class="s0">,ocirc:</span><span class="s3">&quot;ô&quot;</span><span class="s0">,otilde:</span><span class="s3">&quot;õ&quot;</span><span class="s0">,ouml:</span><span class="s3">&quot;ö&quot;</span><span class="s0">,divide:</span><span class="s3">&quot;÷&quot;</span><span class="s0">,oslash:</span><span class="s3">&quot;ø&quot;</span><span class="s0">,ugrave:</span><span class="s3">&quot;ù&quot;</span><span class="s0">,uacute:</span><span class="s3">&quot;ú&quot;</span><span class="s0">,ucirc:</span><span class="s3">&quot;û&quot;</span><span class="s0">,uuml:</span><span class="s3">&quot;ü&quot;</span><span class="s0">,yacute:</span><span class="s3">&quot;ý&quot;</span><span class="s0">,thorn:</span><span class="s3">&quot;þ&quot;</span><span class="s0">,yuml:</span><span class="s3">&quot;ÿ&quot;</span><span class="s0">,OElig:</span><span class="s3">&quot;Œ&quot;</span><span class="s0">,oelig:</span><span class="s3">&quot;œ&quot;</span><span class="s0">,Scaron:</span><span class="s3">&quot;Š&quot;</span><span class="s0">,scaron:</span><span class="s3">&quot;š&quot;</span><span class="s0">,Yuml:</span><span class="s3">&quot;Ÿ&quot;</span><span class="s0">,fnof:</span><span class="s3">&quot;ƒ&quot;</span><span class="s0">,circ:</span><span class="s3">&quot;ˆ&quot;</span><span class="s0">,tilde:</span><span class="s3">&quot;˜&quot;</span><span class="s0">,Alpha:</span><span class="s3">&quot;Α&quot;</span><span class="s0">,Beta:</span><span class="s3">&quot;Β&quot;</span><span class="s0">,Gamma:</span><span class="s3">&quot;Γ&quot;</span><span class="s0">,Delta:</span><span class="s3">&quot;Δ&quot;</span><span class="s0">,Epsilon:</span><span class="s3">&quot;Ε&quot;</span><span class="s0">,Zeta:</span><span class="s3">&quot;Ζ&quot;</span><span class="s0">,Eta:</span><span class="s3">&quot;Η&quot;</span><span class="s0">,Theta:</span><span class="s3">&quot;Θ&quot;</span><span class="s0">,Iota:</span><span class="s3">&quot;Ι&quot;</span><span class="s0">,Kappa:</span><span class="s3">&quot;Κ&quot;</span><span class="s0">,Lambda:</span><span class="s3">&quot;Λ&quot;</span><span class="s0">,Mu:</span><span class="s3">&quot;Μ&quot;</span><span class="s0">,Nu:</span><span class="s3">&quot;Ν&quot;</span><span class="s0">,Xi:</span><span class="s3">&quot;Ξ&quot;</span><span class="s0">,Omicron:</span><span class="s3">&quot;Ο&quot;</span><span class="s0">,Pi:</span><span class="s3">&quot;Π&quot;</span><span class="s0">,Rho:</span><span class="s3">&quot;Ρ&quot;</span><span class="s0">,Sigma:</span><span class="s3">&quot;Σ&quot;</span><span class="s0">,Tau:</span><span class="s3">&quot;Τ&quot;</span><span class="s0">,Upsilon:</span><span class="s3">&quot;Υ&quot;</span><span class="s0">,Phi:</span><span class="s3">&quot;Φ&quot;</span><span class="s0">,Chi:</span><span class="s3">&quot;Χ&quot;</span><span class="s0">,Psi:</span><span class="s3">&quot;Ψ&quot;</span><span class="s0">,Omega:</span><span class="s3">&quot;Ω&quot;</span><span class="s0">,alpha:</span><span class="s3">&quot;α&quot;</span><span class="s0">,beta:</span><span class="s3">&quot;β&quot;</span><span class="s0">,gamma:</span><span class="s3">&quot;γ&quot;</span><span class="s0">,delta:</span><span class="s3">&quot;δ&quot;</span><span class="s0">,epsilon:</span><span class="s3">&quot;ε&quot;</span><span class="s0">,zeta:</span><span class="s3">&quot;ζ&quot;</span><span class="s0">,eta:</span><span class="s3">&quot;η&quot;</span><span class="s0">,theta:</span><span class="s3">&quot;θ&quot;</span><span class="s0">,iota:</span><span class="s3">&quot;ι&quot;</span><span class="s0">,kappa:</span><span class="s3">&quot;κ&quot;</span><span class="s0">,lambda:</span><span class="s3">&quot;λ&quot;</span><span class="s0">,mu:</span><span class="s3">&quot;μ&quot;</span><span class="s0">,nu:</span><span class="s3">&quot;ν&quot;</span><span class="s0">,xi:</span><span class="s3">&quot;ξ&quot;</span><span class="s0">,omicron:</span><span class="s3">&quot;ο&quot;</span><span class="s0">,pi:</span><span class="s3">&quot;π&quot;</span><span class="s0">,rho:</span><span class="s3">&quot;ρ&quot;</span><span class="s0">,sigmaf:</span><span class="s3">&quot;ς&quot;</span><span class="s0">,sigma:</span><span class="s3">&quot;σ&quot;</span><span class="s0">,tau:</span><span class="s3">&quot;τ&quot;</span><span class="s0">,upsilon:</span><span class="s3">&quot;υ&quot;</span><span class="s0">,phi:</span><span class="s3">&quot;φ&quot;</span><span class="s0">,chi:</span><span class="s3">&quot;χ&quot;</span><span class="s0">,psi:</span><span class="s3">&quot;ψ&quot;</span><span class="s0">,omega:</span><span class="s3">&quot;ω&quot;</span><span class="s0">,thetasym:</span><span class="s3">&quot;ϑ&quot;</span><span class="s0">,upsih:</span><span class="s3">&quot;ϒ&quot;</span><span class="s0">,piv:</span><span class="s3">&quot;ϖ&quot;</span><span class="s0">,ensp:</span><span class="s3">&quot; &quot;</span><span class="s0">,emsp:</span><span class="s3">&quot; &quot;</span><span class="s0">,thinsp:</span><span class="s3">&quot; &quot;</span><span class="s0">,zwnj:</span><span class="s3">&quot;‌&quot;</span><span class="s0">,zwj:</span><span class="s3">&quot;‍&quot;</span><span class="s0">,lrm:</span><span class="s3">&quot;‎&quot;</span><span class="s0">,rlm:</span><span class="s3">&quot;‏&quot;</span><span class="s0">,ndash:</span><span class="s3">&quot;–&quot;</span><span class="s0">,mdash:</span><span class="s3">&quot;—&quot;</span><span class="s0">,lsquo:</span><span class="s3">&quot;‘&quot;</span><span class="s0">,rsquo:</span><span class="s3">&quot;’&quot;</span><span class="s0">,sbquo:</span><span class="s3">&quot;‚&quot;</span><span class="s0">,ldquo:</span><span class="s3">&quot;“&quot;</span><span class="s0">,rdquo:</span><span class="s3">&quot;”&quot;</span><span class="s0">,bdquo:</span><span class="s3">&quot;„&quot;</span><span class="s0">,dagger:</span><span class="s3">&quot;†&quot;</span><span class="s0">,Dagger:</span><span class="s3">&quot;‡&quot;</span><span class="s0">,bull:</span><span class="s3">&quot;•&quot;</span><span class="s0">,hellip:</span><span class="s3">&quot;…&quot;</span><span class="s0">,permil:</span><span class="s3">&quot;‰&quot;</span><span class="s0">,prime:</span><span class="s3">&quot;′&quot;</span><span class="s0">,Prime:</span><span class="s3">&quot;″&quot;</span><span class="s0">,lsaquo:</span><span class="s3">&quot;‹&quot;</span><span class="s0">,rsaquo:</span><span class="s3">&quot;›&quot;</span><span class="s0">,oline:</span><span class="s3">&quot;‾&quot;</span><span class="s0">,frasl:</span><span class="s3">&quot;⁄&quot;</span><span class="s0">,euro:</span><span class="s3">&quot;€&quot;</span><span class="s0">,image:</span><span class="s3">&quot;ℑ&quot;</span><span class="s0">,weierp:</span><span class="s3">&quot;℘&quot;</span><span class="s0">,real:</span><span class="s3">&quot;ℜ&quot;</span><span class="s0">,trade:</span><span class="s3">&quot;™&quot;</span><span class="s0">,alefsym:</span><span class="s3">&quot;ℵ&quot;</span><span class="s0">,larr:</span><span class="s3">&quot;←&quot;</span><span class="s0">,uarr:</span><span class="s3">&quot;↑&quot;</span><span class="s0">,rarr:</span><span class="s3">&quot;→&quot;</span><span class="s0">,darr:</span><span class="s3">&quot;↓&quot;</span><span class="s0">,harr:</span><span class="s3">&quot;↔&quot;</span><span class="s0">,crarr:</span><span class="s3">&quot;↵&quot;</span><span class="s0">,lArr:</span><span class="s3">&quot;⇐&quot;</span><span class="s0">,uArr:</span><span class="s3">&quot;⇑&quot;</span><span class="s0">,rArr:</span><span class="s3">&quot;⇒&quot;</span><span class="s0">,dArr:</span><span class="s3">&quot;⇓&quot;</span><span class="s0">,hArr:</span><span class="s3">&quot;⇔&quot;</span><span class="s0">,forall:</span><span class="s3">&quot;∀&quot;</span><span class="s0">,part:</span><span class="s3">&quot;∂&quot;</span><span class="s0">,exist:</span><span class="s3">&quot;∃&quot;</span><span class="s0">,empty:</span><span class="s3">&quot;∅&quot;</span><span class="s0">,nabla:</span><span class="s3">&quot;∇&quot;</span><span class="s0">,isin:</span><span class="s3">&quot;∈&quot;</span><span class="s0">,notin:</span><span class="s3">&quot;∉&quot;</span><span class="s0">,ni:</span><span class="s3">&quot;∋&quot;</span><span class="s0">,prod:</span><span class="s3">&quot;∏&quot;</span><span class="s0">,sum:</span><span class="s3">&quot;∑&quot;</span><span class="s0">,minus:</span><span class="s3">&quot;−&quot;</span><span class="s0">,lowast:</span><span class="s3">&quot;∗&quot;</span><span class="s0">,radic:</span><span class="s3">&quot;√&quot;</span><span class="s0">,prop:</span><span class="s3">&quot;∝&quot;</span><span class="s0">,infin:</span><span class="s3">&quot;∞&quot;</span><span class="s0">,ang:</span><span class="s3">&quot;∠&quot;</span><span class="s0">,and:</span><span class="s3">&quot;∧&quot;</span><span class="s0">,or:</span><span class="s3">&quot;∨&quot;</span><span class="s0">,cap:</span><span class="s3">&quot;∩&quot;</span><span class="s0">,cup:</span><span class="s3">&quot;∪&quot;</span><span class="s0">,int:</span><span class="s3">&quot;∫&quot;</span><span class="s0">,there4:</span><span class="s3">&quot;∴&quot;</span><span class="s0">,sim:</span><span class="s3">&quot;∼&quot;</span><span class="s0">,cong:</span><span class="s3">&quot;≅&quot;</span><span class="s0">,asymp:</span><span class="s3">&quot;≈&quot;</span><span class="s0">,ne:</span><span class="s3">&quot;≠&quot;</span><span class="s0">,equiv:</span><span class="s3">&quot;≡&quot;</span><span class="s0">,le:</span><span class="s3">&quot;≤&quot;</span><span class="s0">,ge:</span><span class="s3">&quot;≥&quot;</span><span class="s0">,sub:</span><span class="s3">&quot;⊂&quot;</span><span class="s0">,sup:</span><span class="s3">&quot;⊃&quot;</span><span class="s0">,nsub:</span><span class="s3">&quot;⊄&quot;</span><span class="s0">,sube:</span><span class="s3">&quot;⊆&quot;</span><span class="s0">,supe:</span><span class="s3">&quot;⊇&quot;</span><span class="s0">,oplus:</span><span class="s3">&quot;⊕&quot;</span><span class="s0">,otimes:</span><span class="s3">&quot;⊗&quot;</span><span class="s0">,perp:</span><span class="s3">&quot;⊥&quot;</span><span class="s0">,sdot:</span><span class="s3">&quot;⋅&quot;</span><span class="s0">,lceil:</span><span class="s3">&quot;⌈&quot;</span><span class="s0">,rceil:</span><span class="s3">&quot;⌉&quot;</span><span class="s0">,lfloor:</span><span class="s3">&quot;⌊&quot;</span><span class="s0">,rfloor:</span><span class="s3">&quot;⌋&quot;</span><span class="s0">,lang:</span><span class="s3">&quot;〈&quot;</span><span class="s0">,rang:</span><span class="s3">&quot;〉&quot;</span><span class="s0">,loz:</span><span class="s3">&quot;◊&quot;</span><span class="s0">,spades:</span><span class="s3">&quot;♠&quot;</span><span class="s0">,clubs:</span><span class="s3">&quot;♣&quot;</span><span class="s0">,hearts:</span><span class="s3">&quot;♥&quot;</span><span class="s0">,diams:</span><span class="s3">&quot;♦&quot;</span><span class="s0">},$=/^[\da-fA-F]+$/,Q=/^\d+$/,Z=Object.freeze({AttributeIsEmpty:</span><span class="s3">&quot;JSX attributes must only be assigned a non-empty expression&quot;</span><span class="s0">,MissingClosingTagFragment:</span><span class="s3">&quot;Expected corresponding JSX closing tag for &lt;&gt;&quot;</span><span class="s0">,MissingClosingTagElement:</span><span class="s3">&quot;Expected corresponding JSX closing tag for &lt;%0&gt;&quot;</span><span class="s0">,UnsupportedJsxValue:</span><span class="s3">&quot;JSX value should be either an expression or a quoted JSX text&quot;</span><span class="s0">,UnterminatedJsxContent:</span><span class="s3">&quot;Unterminated JSX contents&quot;</span><span class="s0">,UnwrappedAdjacentJSXElements:</span><span class="s3">&quot;Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment &lt;&gt;...&lt;/&gt;?&quot;</span><span class="s0">});</span><span class="s1">function </span><span class="s0">ee(e){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(</span><span class="s3">&quot;JSXOpeningFragment&quot;</span><span class="s0">===e.type||</span><span class="s3">&quot;JSXClosingFragment&quot;</span><span class="s0">===e.type)}</span><span class="s1">function </span><span class="s0">te(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">===e.type)</span><span class="s1">return </span><span class="s0">e.name;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">===e.type)</span><span class="s1">return </span><span class="s0">e.namespace.name+</span><span class="s3">&quot;:&quot;</span><span class="s0">+e.name.name;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s0">===e.type)</span><span class="s1">return </span><span class="s0">te(e.object)+</span><span class="s3">&quot;.&quot;</span><span class="s0">+te(e.property);</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Node had unexpected type: &quot;</span><span class="s0">+e.type)}A.j_oTag=</span><span class="s1">new </span><span class="s0">v(</span><span class="s3">&quot;&lt;tag&quot;</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),A.j_cTag=</span><span class="s1">new </span><span class="s0">v(</span><span class="s3">&quot;&lt;/tag&quot;</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),A.j_expr=</span><span class="s1">new </span><span class="s0">v(</span><span class="s3">&quot;&lt;tag&gt;...&lt;/tag&gt;&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),c.jsxName=</span><span class="s1">new </span><span class="s0">a(</span><span class="s3">&quot;jsxName&quot;</span><span class="s0">),c.jsxText=</span><span class="s1">new </span><span class="s0">a(</span><span class="s3">&quot;jsxText&quot;</span><span class="s0">,{beforeExpr:!</span><span class="s2">0</span><span class="s0">}),c.jsxTagStart=</span><span class="s1">new </span><span class="s0">a(</span><span class="s3">&quot;jsxTagStart&quot;</span><span class="s0">,{startsExpr:!</span><span class="s2">0</span><span class="s0">}),c.jsxTagEnd=</span><span class="s1">new </span><span class="s0">a(</span><span class="s3">&quot;jsxTagEnd&quot;</span><span class="s0">),c.jsxTagStart.updateContext=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">.state.context.push(A.j_expr),</span><span class="s1">this</span><span class="s0">.state.context.push(A.j_oTag),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">},c.jsxTagEnd.updateContext=</span><span class="s1">function</span><span class="s0">(e){const t=</span><span class="s1">this</span><span class="s0">.state.context.pop();t===A.j_oTag&amp;&amp;e===c.slash||t===A.j_cTag?(</span><span class="s1">this</span><span class="s0">.state.context.pop(),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=</span><span class="s1">this</span><span class="s0">.curContext()===A.j_expr):</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">0</span><span class="s0">};class re{constructor(e){</span><span class="s1">this</span><span class="s0">.flags=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.</span><span class="s1">var</span><span class="s0">=[],</span><span class="s1">this</span><span class="s0">.lexical=[],</span><span class="s1">this</span><span class="s0">.functions=[],</span><span class="s1">this</span><span class="s0">.flags=e}}class ne{constructor(e,t){</span><span class="s1">this</span><span class="s0">.scopeStack=[],</span><span class="s1">this</span><span class="s0">.undefinedExports=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.undefinedPrivateNames=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.raise=e,</span><span class="s1">this</span><span class="s0">.inModule=t}get inFunction(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">2</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentVarScope().flags)&gt;</span><span class="s2">0</span><span class="s0">}get allowSuper(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">16</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentThisScope().flags)&gt;</span><span class="s2">0</span><span class="s0">}get allowDirectSuper(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">32</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentThisScope().flags)&gt;</span><span class="s2">0</span><span class="s0">}get inClass(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">64</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentThisScope().flags)&gt;</span><span class="s2">0</span><span class="s0">}get inNonArrowFunction(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">2</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentThisScope().flags)&gt;</span><span class="s2">0</span><span class="s0">}get treatFunctionsAsVar(){</span><span class="s1">return this</span><span class="s0">.treatFunctionsAsVarInScope(</span><span class="s1">this</span><span class="s0">.currentScope())}createScope(e){</span><span class="s1">return new </span><span class="s0">re(e)}enter(e){</span><span class="s1">this</span><span class="s0">.scopeStack.push(</span><span class="s1">this</span><span class="s0">.createScope(e))}exit(){</span><span class="s1">this</span><span class="s0">.scopeStack.pop()}treatFunctionsAsVarInScope(e){</span><span class="s1">return</span><span class="s0">!!(</span><span class="s2">2</span><span class="s0">&amp;e.flags||!</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;</span><span class="s2">1</span><span class="s0">&amp;e.flags)}declareName(e,t,r){let n=</span><span class="s1">this</span><span class="s0">.currentScope();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">8</span><span class="s0">&amp;t||</span><span class="s2">16</span><span class="s0">&amp;t)</span><span class="s1">this</span><span class="s0">.checkRedeclarationInScope(n,e,t,r),</span><span class="s2">16</span><span class="s0">&amp;t?n.functions.push(e):n.lexical.push(e),</span><span class="s2">8</span><span class="s0">&amp;t&amp;&amp;</span><span class="s1">this</span><span class="s0">.maybeExportDefined(n,e);</span><span class="s1">else if</span><span class="s0">(</span><span class="s2">4</span><span class="s0">&amp;t)</span><span class="s1">for</span><span class="s0">(let i=</span><span class="s1">this</span><span class="s0">.scopeStack.length-1;i&gt;=</span><span class="s2">0</span><span class="s0">&amp;&amp;(n=</span><span class="s1">this</span><span class="s0">.scopeStack[i],</span><span class="s1">this</span><span class="s0">.checkRedeclarationInScope(n,e,t,r),n.</span><span class="s1">var</span><span class="s0">.push(e),</span><span class="s1">this</span><span class="s0">.maybeExportDefined(n,e),!(</span><span class="s2">131</span><span class="s0">&amp;n.flags));--i);</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;</span><span class="s2">1</span><span class="s0">&amp;n.flags&amp;&amp;</span><span class="s1">this</span><span class="s0">.undefinedExports.</span><span class="s1">delete</span><span class="s0">(e)}maybeExportDefined(e,t){</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;</span><span class="s2">1</span><span class="s0">&amp;e.flags&amp;&amp;</span><span class="s1">this</span><span class="s0">.undefinedExports.</span><span class="s1">delete</span><span class="s0">(t)}checkRedeclarationInScope(e,t,r,n){</span><span class="s1">this</span><span class="s0">.isRedeclaredInScope(e,t,r)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(n,x.VarRedeclaration,t)}isRedeclaredInScope(e,t,r){</span><span class="s1">return</span><span class="s0">!!(</span><span class="s2">1</span><span class="s0">&amp;r)&amp;&amp;(</span><span class="s2">8</span><span class="s0">&amp;r?e.lexical.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">||e.functions.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">||e.</span><span class="s1">var</span><span class="s0">.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">:</span><span class="s2">16</span><span class="s0">&amp;r?e.lexical.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">||!</span><span class="s1">this</span><span class="s0">.treatFunctionsAsVarInScope(e)&amp;&amp;e.</span><span class="s1">var</span><span class="s0">.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">:e.lexical.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;!(</span><span class="s2">8</span><span class="s0">&amp;e.flags&amp;&amp;e.lexical[</span><span class="s2">0</span><span class="s0">]===t)||!</span><span class="s1">this</span><span class="s0">.treatFunctionsAsVarInScope(e)&amp;&amp;e.functions.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">)}checkLocalExport(e){-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.scopeStack[</span><span class="s2">0</span><span class="s0">].lexical.indexOf(e.name)&amp;&amp;-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.scopeStack[</span><span class="s2">0</span><span class="s0">].</span><span class="s1">var</span><span class="s0">.indexOf(e.name)&amp;&amp;-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.scopeStack[</span><span class="s2">0</span><span class="s0">].functions.indexOf(e.name)&amp;&amp;</span><span class="s1">this</span><span class="s0">.undefinedExports.set(e.name,e.start)}currentScope(){</span><span class="s1">return this</span><span class="s0">.scopeStack[</span><span class="s1">this</span><span class="s0">.scopeStack.length-1]}currentVarScope(){</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s1">this</span><span class="s0">.scopeStack.length-1;;e--){const t=</span><span class="s1">this</span><span class="s0">.scopeStack[e];</span><span class="s1">if</span><span class="s0">(</span><span class="s2">131</span><span class="s0">&amp;t.flags)</span><span class="s1">return </span><span class="s0">t}}currentThisScope(){</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s1">this</span><span class="s0">.scopeStack.length-1;;e--){const t=</span><span class="s1">this</span><span class="s0">.scopeStack[e];</span><span class="s1">if</span><span class="s0">((</span><span class="s2">131</span><span class="s0">&amp;t.flags||</span><span class="s2">64</span><span class="s0">&amp;t.flags)&amp;&amp;!(</span><span class="s2">4</span><span class="s0">&amp;t.flags))</span><span class="s1">return </span><span class="s0">t}}}class ie extends re{constructor(...e){super(...e),</span><span class="s1">this</span><span class="s0">.types=[],</span><span class="s1">this</span><span class="s0">.enums=[],</span><span class="s1">this</span><span class="s0">.constEnums=[],</span><span class="s1">this</span><span class="s0">.classes=[],</span><span class="s1">this</span><span class="s0">.exportOnlyBindings=[]}}class se extends ne{createScope(e){</span><span class="s1">return new </span><span class="s0">ie(e)}declareName(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.currentScope();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">1024</span><span class="s0">&amp;t)</span><span class="s1">return this</span><span class="s0">.maybeExportDefined(n,e),</span><span class="s1">void </span><span class="s0">n.exportOnlyBindings.push(e);super.declareName(...arguments),</span><span class="s2">2</span><span class="s0">&amp;t&amp;&amp;(</span><span class="s2">1</span><span class="s0">&amp;t||(</span><span class="s1">this</span><span class="s0">.checkRedeclarationInScope(n,e,t,r),</span><span class="s1">this</span><span class="s0">.maybeExportDefined(n,e)),n.types.push(e)),</span><span class="s2">256</span><span class="s0">&amp;t&amp;&amp;n.enums.push(e),</span><span class="s2">512</span><span class="s0">&amp;t&amp;&amp;n.constEnums.push(e),</span><span class="s2">128</span><span class="s0">&amp;t&amp;&amp;n.classes.push(e)}isRedeclaredInScope(e,t,r){</span><span class="s1">return </span><span class="s0">e.enums.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">?!(</span><span class="s2">256</span><span class="s0">&amp;r)||!!(</span><span class="s2">512</span><span class="s0">&amp;r)!=e.constEnums.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">:</span><span class="s2">128</span><span class="s0">&amp;r&amp;&amp;e.classes.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">?e.lexical.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;!!(</span><span class="s2">1</span><span class="s0">&amp;r):!!(</span><span class="s2">2</span><span class="s0">&amp;r&amp;&amp;e.types.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">)||super.isRedeclaredInScope(...arguments)}checkLocalExport(e){-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.scopeStack[</span><span class="s2">0</span><span class="s0">].types.indexOf(e.name)&amp;&amp;-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.scopeStack[</span><span class="s2">0</span><span class="s0">].exportOnlyBindings.indexOf(e.name)&amp;&amp;super.checkLocalExport(e)}}class ae{constructor(){</span><span class="s1">this</span><span class="s0">.stacks=[]}enter(e){</span><span class="s1">this</span><span class="s0">.stacks.push(e)}exit(){</span><span class="s1">this</span><span class="s0">.stacks.pop()}currentFlags(){</span><span class="s1">return this</span><span class="s0">.stacks[</span><span class="s1">this</span><span class="s0">.stacks.length-1]}get hasAwait(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">2</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentFlags())&gt;</span><span class="s2">0</span><span class="s0">}get hasYield(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">1</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentFlags())&gt;</span><span class="s2">0</span><span class="s0">}get hasReturn(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">4</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentFlags())&gt;</span><span class="s2">0</span><span class="s0">}get hasIn(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">8</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">.currentFlags())&gt;</span><span class="s2">0</span><span class="s0">}}</span><span class="s1">function </span><span class="s0">oe(e,t){</span><span class="s1">return</span><span class="s0">(e?</span><span class="s2">2</span><span class="s0">:</span><span class="s2">0</span><span class="s0">)|(t?</span><span class="s2">1</span><span class="s0">:</span><span class="s2">0</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">le(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==e)</span><span class="s1">throw new </span><span class="s0">Error(`Unexpected ${e} value.`);</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">function </span><span class="s0">pe(e){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Assert fail&quot;</span><span class="s0">)}const ce=Object.freeze({ClassMethodHasDeclare:</span><span class="s3">&quot;Class methods cannot have the 'declare' modifier&quot;</span><span class="s0">,ClassMethodHasReadonly:</span><span class="s3">&quot;Class methods cannot have the 'readonly' modifier&quot;</span><span class="s0">,ConstructorHasTypeParameters:</span><span class="s3">&quot;Type parameters cannot appear on a constructor declaration.&quot;</span><span class="s0">,DeclareClassFieldHasInitializer:</span><span class="s3">&quot;Initializers are not allowed in ambient contexts.&quot;</span><span class="s0">,DeclareFunctionHasImplementation:</span><span class="s3">&quot;An implementation cannot be declared in ambient contexts.&quot;</span><span class="s0">,DuplicateModifier:</span><span class="s3">&quot;Duplicate modifier: '%0'&quot;</span><span class="s0">,EmptyHeritageClauseType:</span><span class="s3">&quot;'%0' list cannot be empty.&quot;</span><span class="s0">,EmptyTypeArguments:</span><span class="s3">&quot;Type argument list cannot be empty.&quot;</span><span class="s0">,EmptyTypeParameters:</span><span class="s3">&quot;Type parameter list cannot be empty.&quot;</span><span class="s0">,IndexSignatureHasAbstract:</span><span class="s3">&quot;Index signatures cannot have the 'abstract' modifier&quot;</span><span class="s0">,IndexSignatureHasAccessibility:</span><span class="s3">&quot;Index signatures cannot have an accessibility modifier ('%0')&quot;</span><span class="s0">,IndexSignatureHasStatic:</span><span class="s3">&quot;Index signatures cannot have the 'static' modifier&quot;</span><span class="s0">,IndexSignatureHasDeclare:</span><span class="s3">&quot;Index signatures cannot have the 'declare' modifier&quot;</span><span class="s0">,InvalidTupleMemberLabel:</span><span class="s3">&quot;Tuple members must be labeled with a simple identifier.&quot;</span><span class="s0">,MixedLabeledAndUnlabeledElements:</span><span class="s3">&quot;Tuple members must all have names or all not have names.&quot;</span><span class="s0">,OptionalTypeBeforeRequired:</span><span class="s3">&quot;A required element cannot follow an optional element.&quot;</span><span class="s0">,PatternIsOptional:</span><span class="s3">&quot;A binding pattern parameter cannot be optional in an implementation signature.&quot;</span><span class="s0">,PrivateElementHasAbstract:</span><span class="s3">&quot;Private elements cannot have the 'abstract' modifier.&quot;</span><span class="s0">,PrivateElementHasAccessibility:</span><span class="s3">&quot;Private elements cannot have an accessibility modifier ('%0')&quot;</span><span class="s0">,TypeAnnotationAfterAssign:</span><span class="s3">&quot;Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`&quot;</span><span class="s0">,UnexpectedParameterModifier:</span><span class="s3">&quot;A parameter property is only allowed in a constructor implementation.&quot;</span><span class="s0">,UnexpectedReadonly:</span><span class="s3">&quot;'readonly' type modifier is only permitted on array and tuple literal types.&quot;</span><span class="s0">,UnexpectedTypeAnnotation:</span><span class="s3">&quot;Did not expect a type annotation here.&quot;</span><span class="s0">,UnexpectedTypeCastInParameter:</span><span class="s3">&quot;Unexpected type cast in parameter position.&quot;</span><span class="s0">,UnsupportedImportTypeArgument:</span><span class="s3">&quot;Argument in a type import must be a string literal&quot;</span><span class="s0">,UnsupportedParameterPropertyKind:</span><span class="s3">&quot;A parameter property may not be declared using a binding pattern.&quot;</span><span class="s0">,UnsupportedSignatureParameterKind:</span><span class="s3">&quot;Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0&quot;</span><span class="s0">});</span><span class="s1">function </span><span class="s0">ue(e,t){</span><span class="s1">return </span><span class="s0">e.some((e=&gt;Array.isArray(e)?e[</span><span class="s2">0</span><span class="s0">]===t:e===t))}</span><span class="s1">function </span><span class="s0">de(e,t,r){const n=e.find((e=&gt;Array.isArray(e)?e[</span><span class="s2">0</span><span class="s0">]===t:e===t));</span><span class="s1">return </span><span class="s0">n&amp;&amp;Array.isArray(n)?n[</span><span class="s2">1</span><span class="s0">][r]:</span><span class="s1">null</span><span class="s0">}c.placeholder=</span><span class="s1">new </span><span class="s0">a(</span><span class="s3">&quot;%%&quot;</span><span class="s0">,{startsExpr:!</span><span class="s2">0</span><span class="s0">});const he=[</span><span class="s3">&quot;minimal&quot;</span><span class="s0">,</span><span class="s3">&quot;smart&quot;</span><span class="s0">,</span><span class="s3">&quot;fsharp&quot;</span><span class="s0">],fe=[</span><span class="s3">&quot;hash&quot;</span><span class="s0">,</span><span class="s3">&quot;bar&quot;</span><span class="s0">],me={estree:e=&gt;class extends e{estreeParseRegExpLiteral({pattern:e,flags:t}){let r=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{r=</span><span class="s1">new </span><span class="s0">RegExp(e,t)}</span><span class="s1">catch</span><span class="s0">(e){}const n=</span><span class="s1">this</span><span class="s0">.estreeParseLiteral(r);</span><span class="s1">return </span><span class="s0">n.regex={pattern:e,flags:t},n}estreeParseBigIntLiteral(e){const t=</span><span class="s3">&quot;undefined&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">BigInt?BigInt(e):</span><span class="s1">null</span><span class="s0">,r=</span><span class="s1">this</span><span class="s0">.estreeParseLiteral(t);</span><span class="s1">return </span><span class="s0">r.bigint=String(r.value||e),r}estreeParseDecimalLiteral(e){const t=</span><span class="s1">this</span><span class="s0">.estreeParseLiteral(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">return </span><span class="s0">t.decimal=String(t.value||e),t}estreeParseLiteral(e){</span><span class="s1">return this</span><span class="s0">.parseLiteral(e,</span><span class="s3">&quot;Literal&quot;</span><span class="s0">)}directiveToStmt(e){const t=e.value,r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e.start,e.loc.start),n=</span><span class="s1">this</span><span class="s0">.startNodeAt(t.start,t.loc.start);</span><span class="s1">return </span><span class="s0">n.value=t.value,n.raw=t.extra.raw,r.expression=</span><span class="s1">this</span><span class="s0">.finishNodeAt(n,</span><span class="s3">&quot;Literal&quot;</span><span class="s0">,t.end,t.loc.end),r.directive=t.extra.raw.slice(</span><span class="s2">1</span><span class="s0">,-</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNodeAt(r,</span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s0">,e.end,e.loc.end)}initFunction(e,t){super.initFunction(e,t),e.expression=!</span><span class="s2">1</span><span class="s0">}checkDeclaration(e){P(e)?</span><span class="s1">this</span><span class="s0">.checkDeclaration(e.value):super.checkDeclaration(e)}getObjectOrClassMethodParams(e){</span><span class="s1">return </span><span class="s0">e.value.params}checkLVal(e,t=</span><span class="s2">64</span><span class="s0">,r,n,i){</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">===e.type?e.properties.forEach((e=&gt;{</span><span class="s1">this</span><span class="s0">.checkLVal(</span><span class="s3">&quot;Property&quot;</span><span class="s0">===e.type?e.value:e,t,r,</span><span class="s3">&quot;object destructuring pattern&quot;</span><span class="s0">,i)})):super.checkLVal(e,t,r,n,i)}checkProto(e,t,r,n){e.method||super.checkProto(e,t,r,n)}isValidDirective(e){</span><span class="s1">var </span><span class="s0">t;</span><span class="s1">return</span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;Literal&quot;</span><span class="s0">===e.expression.type&amp;&amp;</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.expression.value&amp;&amp;!(</span><span class="s1">null</span><span class="s0">==(t=e.expression.extra)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.parenthesized)}stmtToDirective(e){const t=super.stmtToDirective(e),r=e.expression.value;</span><span class="s1">return </span><span class="s0">t.value.value=r,t}parseBlockBody(e,t,r,n){super.parseBlockBody(e,t,r,n);const i=e.directives.map((e=&gt;</span><span class="s1">this</span><span class="s0">.directiveToStmt(e)));e.body=i.concat(e.body),</span><span class="s1">delete </span><span class="s0">e.directives}pushClassMethod(e,t,r,n,i,s){</span><span class="s1">this</span><span class="s0">.parseMethod(t,r,n,i,s,</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),t.typeParameters&amp;&amp;(t.value.typeParameters=t.typeParameters,</span><span class="s1">delete </span><span class="s0">t.typeParameters),e.body.push(t)}parseExprAtom(e){</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c.num:</span><span class="s1">case </span><span class="s0">c.string:</span><span class="s1">return this</span><span class="s0">.estreeParseLiteral(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">case </span><span class="s0">c.regexp:</span><span class="s1">return this</span><span class="s0">.estreeParseRegExpLiteral(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">case </span><span class="s0">c.bigint:</span><span class="s1">return this</span><span class="s0">.estreeParseBigIntLiteral(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">case </span><span class="s0">c.decimal:</span><span class="s1">return this</span><span class="s0">.estreeParseDecimalLiteral(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">case </span><span class="s0">c._null:</span><span class="s1">return this</span><span class="s0">.estreeParseLiteral(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._true:</span><span class="s1">return this</span><span class="s0">.estreeParseLiteral(!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._false:</span><span class="s1">return this</span><span class="s0">.estreeParseLiteral(!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return </span><span class="s0">super.parseExprAtom(e)}}parseLiteral(e,t,r,n){const i=super.parseLiteral(e,t,r,n);</span><span class="s1">return </span><span class="s0">i.raw=i.extra.raw,</span><span class="s1">delete </span><span class="s0">i.extra,i}parseFunctionBody(e,t,r=!</span><span class="s2">1</span><span class="s0">){super.parseFunctionBody(e,t,r),e.expression=</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">!==e.body.type}parseMethod(e,t,r,n,i,s,a=!</span><span class="s2">1</span><span class="s0">){let o=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">o.kind=e.kind,o=super.parseMethod(o,t,r,n,i,s,a),o.type=</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">,</span><span class="s1">delete </span><span class="s0">o.kind,e.value=o,s=</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">===s?</span><span class="s3">&quot;MethodDefinition&quot;</span><span class="s0">:s,</span><span class="s1">this</span><span class="s0">.finishNode(e,s)}parseObjectMethod(e,t,r,n,i){const s=super.parseObjectMethod(e,t,r,n,i);</span><span class="s1">return </span><span class="s0">s&amp;&amp;(s.type=</span><span class="s3">&quot;Property&quot;</span><span class="s0">,</span><span class="s3">&quot;method&quot;</span><span class="s0">===s.kind&amp;&amp;(s.kind=</span><span class="s3">&quot;init&quot;</span><span class="s0">),s.shorthand=!</span><span class="s2">1</span><span class="s0">),s}parseObjectProperty(e,t,r,n,i){const s=super.parseObjectProperty(e,t,r,n,i);</span><span class="s1">return </span><span class="s0">s&amp;&amp;(s.kind=</span><span class="s3">&quot;init&quot;</span><span class="s0">,s.type=</span><span class="s3">&quot;Property&quot;</span><span class="s0">),s}toAssignable(e){</span><span class="s1">return </span><span class="s0">P(e)?(</span><span class="s1">this</span><span class="s0">.toAssignable(e.value),e):super.toAssignable(e)}toAssignableObjectExpressionProp(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;get&quot;</span><span class="s0">===e.kind||</span><span class="s3">&quot;set&quot;</span><span class="s0">===e.kind)</span><span class="s1">throw this</span><span class="s0">.raise(e.key.start,x.PatternHasAccessor);</span><span class="s1">if</span><span class="s0">(e.method)</span><span class="s1">throw this</span><span class="s0">.raise(e.key.start,x.PatternHasMethod);super.toAssignableObjectExpressionProp(e,t)}finishCallExpression(e,t){</span><span class="s1">return </span><span class="s0">super.finishCallExpression(e,t),</span><span class="s3">&quot;Import&quot;</span><span class="s0">===e.callee.type&amp;&amp;(e.type=</span><span class="s3">&quot;ImportExpression&quot;</span><span class="s0">,e.source=e.arguments[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">delete </span><span class="s0">e.arguments,</span><span class="s1">delete </span><span class="s0">e.callee),e}toReferencedArguments(e){</span><span class="s3">&quot;ImportExpression&quot;</span><span class="s0">!==e.type&amp;&amp;super.toReferencedArguments(e)}parseExport(e){</span><span class="s1">switch</span><span class="s0">(super.parseExport(e),e.type){</span><span class="s1">case</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">:e.exported=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">:</span><span class="s2">1</span><span class="s0">===e.specifiers.length&amp;&amp;</span><span class="s3">&quot;ExportNamespaceSpecifier&quot;</span><span class="s0">===e.specifiers[</span><span class="s2">0</span><span class="s0">].type&amp;&amp;(e.type=</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">,e.exported=e.specifiers[</span><span class="s2">0</span><span class="s0">].exported,</span><span class="s1">delete </span><span class="s0">e.specifiers)}</span><span class="s1">return </span><span class="s0">e}parseSubscript(e,t,r,n,i){const s=super.parseSubscript(e,t,r,n,i);</span><span class="s1">if</span><span class="s0">(i.optionalChainMember){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">!==s.type&amp;&amp;</span><span class="s3">&quot;OptionalCallExpression&quot;</span><span class="s0">!==s.type||(s.type=s.type.substring(</span><span class="s2">8</span><span class="s0">)),i.stop){const e=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(s);</span><span class="s1">return </span><span class="s0">e.expression=s,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ChainExpression&quot;</span><span class="s0">)}}</span><span class="s1">else</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">!==s.type&amp;&amp;</span><span class="s3">&quot;CallExpression&quot;</span><span class="s0">!==s.type||(s.optional=!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">return </span><span class="s0">s}},jsx:e=&gt;class extends e{jsxReadToken(){let e=</span><span class="s3">&quot;&quot;</span><span class="s0">,t=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">for</span><span class="s0">(;;){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos&gt;=</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,Z.UnterminatedJsxContent);const r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">switch</span><span class="s0">(r){</span><span class="s1">case </span><span class="s2">60</span><span class="s0">:</span><span class="s1">case </span><span class="s2">123</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.state.pos===</span><span class="s1">this</span><span class="s0">.state.start?</span><span class="s2">60</span><span class="s0">===r&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.exprAllowed?(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.jsxTagStart)):super.getTokenFromCode(r):(e+=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos),</span><span class="s1">this</span><span class="s0">.finishToken(c.jsxText,e));</span><span class="s1">case </span><span class="s2">38</span><span class="s0">:e+=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos),e+=</span><span class="s1">this</span><span class="s0">.jsxReadEntity(),t=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:h(r)?(e+=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos),e+=</span><span class="s1">this</span><span class="s0">.jsxReadNewLine(!</span><span class="s2">0</span><span class="s0">),t=</span><span class="s1">this</span><span class="s0">.state.pos):++</span><span class="s1">this</span><span class="s0">.state.pos}}}jsxReadNewLine(e){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);let r;</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s2">13</span><span class="s0">===t&amp;&amp;</span><span class="s2">10</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)?(++</span><span class="s1">this</span><span class="s0">.state.pos,r=e?</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">:</span><span class="s3">&quot;</span><span class="s4">\r\n</span><span class="s3">&quot;</span><span class="s0">):r=String.fromCharCode(t),++</span><span class="s1">this</span><span class="s0">.state.curLine,</span><span class="s1">this</span><span class="s0">.state.lineStart=</span><span class="s1">this</span><span class="s0">.state.pos,r}jsxReadString(e){let t=</span><span class="s3">&quot;&quot;</span><span class="s0">,r=++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">for</span><span class="s0">(;;){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos&gt;=</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.UnterminatedString);const n=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(n===e)</span><span class="s1">break</span><span class="s0">;</span><span class="s2">38</span><span class="s0">===n?(t+=</span><span class="s1">this</span><span class="s0">.input.slice(r,</span><span class="s1">this</span><span class="s0">.state.pos),t+=</span><span class="s1">this</span><span class="s0">.jsxReadEntity(),r=</span><span class="s1">this</span><span class="s0">.state.pos):h(n)?(t+=</span><span class="s1">this</span><span class="s0">.input.slice(r,</span><span class="s1">this</span><span class="s0">.state.pos),t+=</span><span class="s1">this</span><span class="s0">.jsxReadNewLine(!</span><span class="s2">1</span><span class="s0">),r=</span><span class="s1">this</span><span class="s0">.state.pos):++</span><span class="s1">this</span><span class="s0">.state.pos}</span><span class="s1">return </span><span class="s0">t+=</span><span class="s1">this</span><span class="s0">.input.slice(r,</span><span class="s1">this</span><span class="s0">.state.pos++),</span><span class="s1">this</span><span class="s0">.finishToken(c.string,t)}jsxReadEntity(){let e,t=</span><span class="s3">&quot;&quot;</span><span class="s0">,r=</span><span class="s2">0</span><span class="s0">,n=</span><span class="s1">this</span><span class="s0">.input[</span><span class="s1">this</span><span class="s0">.state.pos];const i=++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length&amp;&amp;r++&lt;</span><span class="s2">10</span><span class="s0">;){</span><span class="s1">if</span><span class="s0">(n=</span><span class="s1">this</span><span class="s0">.input[</span><span class="s1">this</span><span class="s0">.state.pos++],</span><span class="s3">&quot;;&quot;</span><span class="s0">===n){</span><span class="s3">&quot;#&quot;</span><span class="s0">===t[</span><span class="s2">0</span><span class="s0">]?</span><span class="s3">&quot;x&quot;</span><span class="s0">===t[</span><span class="s2">1</span><span class="s0">]?(t=t.substr(</span><span class="s2">2</span><span class="s0">),$.test(t)&amp;&amp;(e=String.fromCodePoint(parseInt(t,</span><span class="s2">16</span><span class="s0">)))):(t=t.substr(</span><span class="s2">1</span><span class="s0">),Q.test(t)&amp;&amp;(e=String.fromCodePoint(parseInt(t,</span><span class="s2">10</span><span class="s0">)))):e=z[t];</span><span class="s1">break</span><span class="s0">}t+=n}</span><span class="s1">return </span><span class="s0">e||(</span><span class="s1">this</span><span class="s0">.state.pos=i,</span><span class="s3">&quot;&amp;&quot;</span><span class="s0">)}jsxReadWord(){let e;const t=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">do</span><span class="s0">{e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(++</span><span class="s1">this</span><span class="s0">.state.pos)}</span><span class="s1">while</span><span class="s0">(L(e)||</span><span class="s2">45</span><span class="s0">===e);</span><span class="s1">return this</span><span class="s0">.finishToken(c.jsxName,</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos))}jsxParseIdentifier(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.match(c.jsxName)?e.name=</span><span class="s1">this</span><span class="s0">.state.value:</span><span class="s1">this</span><span class="s0">.state.type.keyword?e.name=</span><span class="s1">this</span><span class="s0">.state.type.keyword:</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">)}jsxParseNamespacedName(){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc,r=</span><span class="s1">this</span><span class="s0">.jsxParseIdentifier();</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.eat(c.colon))</span><span class="s1">return </span><span class="s0">r;const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);</span><span class="s1">return </span><span class="s0">n.namespace=r,n.name=</span><span class="s1">this</span><span class="s0">.jsxParseIdentifier(),</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">)}jsxParseElementName(){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc;let r=</span><span class="s1">this</span><span class="s0">.jsxParseNamespacedName();</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">===r.type)</span><span class="s1">return </span><span class="s0">r;</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.eat(c.dot);){const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);n.object=r,n.property=</span><span class="s1">this</span><span class="s0">.jsxParseIdentifier(),r=</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">r}jsxParseAttributeValue(){let e;</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c.braceL:</span><span class="s1">return </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.next(),e=</span><span class="s1">this</span><span class="s0">.jsxParseExpressionContainer(e),</span><span class="s3">&quot;JSXEmptyExpression&quot;</span><span class="s0">===e.expression.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,Z.AttributeIsEmpty),e;</span><span class="s1">case </span><span class="s0">c.jsxTagStart:</span><span class="s1">case </span><span class="s0">c.string:</span><span class="s1">return this</span><span class="s0">.parseExprAtom();</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,Z.UnsupportedJsxValue)}}jsxParseEmptyExpression(){const e=</span><span class="s1">this</span><span class="s0">.startNodeAt(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc);</span><span class="s1">return this</span><span class="s0">.finishNodeAt(e,</span><span class="s3">&quot;JSXEmptyExpression&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.start,</span><span class="s1">this</span><span class="s0">.state.startLoc)}jsxParseSpreadChild(e){</span><span class="s1">return this</span><span class="s0">.next(),e.expression=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;JSXSpreadChild&quot;</span><span class="s0">)}jsxParseExpressionContainer(e){</span><span class="s1">return this</span><span class="s0">.match(c.braceR)?e.expression=</span><span class="s1">this</span><span class="s0">.jsxParseEmptyExpression():e.expression=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;JSXExpressionContainer&quot;</span><span class="s0">)}jsxParseAttribute(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.eat(c.braceL)?(</span><span class="s1">this</span><span class="s0">.expect(c.ellipsis),e.argument=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;JSXSpreadAttribute&quot;</span><span class="s0">)):(e.name=</span><span class="s1">this</span><span class="s0">.jsxParseNamespacedName(),e.value=</span><span class="s1">this</span><span class="s0">.eat(c.eq)?</span><span class="s1">this</span><span class="s0">.jsxParseAttributeValue():</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;JSXAttribute&quot;</span><span class="s0">))}jsxParseOpeningElementAt(e,t){const r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);</span><span class="s1">return this</span><span class="s0">.match(c.jsxTagEnd)?(</span><span class="s1">this</span><span class="s0">.expect(c.jsxTagEnd),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;JSXOpeningFragment&quot;</span><span class="s0">)):(r.name=</span><span class="s1">this</span><span class="s0">.jsxParseElementName(),</span><span class="s1">this</span><span class="s0">.jsxParseOpeningElementAfterName(r))}jsxParseOpeningElementAfterName(e){const t=[];</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.match(c.slash)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.jsxTagEnd);)t.push(</span><span class="s1">this</span><span class="s0">.jsxParseAttribute());</span><span class="s1">return </span><span class="s0">e.attributes=t,e.selfClosing=</span><span class="s1">this</span><span class="s0">.eat(c.slash),</span><span class="s1">this</span><span class="s0">.expect(c.jsxTagEnd),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;JSXOpeningElement&quot;</span><span class="s0">)}jsxParseClosingElementAt(e,t){const r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);</span><span class="s1">return this</span><span class="s0">.match(c.jsxTagEnd)?(</span><span class="s1">this</span><span class="s0">.expect(c.jsxTagEnd),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;JSXClosingFragment&quot;</span><span class="s0">)):(r.name=</span><span class="s1">this</span><span class="s0">.jsxParseElementName(),</span><span class="s1">this</span><span class="s0">.expect(c.jsxTagEnd),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;JSXClosingElement&quot;</span><span class="s0">))}jsxParseElementAt(e,t){const r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t),n=[],i=</span><span class="s1">this</span><span class="s0">.jsxParseOpeningElementAt(e,t);let s=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!i.selfClosing){e:</span><span class="s1">for</span><span class="s0">(;;)</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c.jsxTagStart:</span><span class="s1">if</span><span class="s0">(e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.eat(c.slash)){s=</span><span class="s1">this</span><span class="s0">.jsxParseClosingElementAt(e,t);</span><span class="s1">break </span><span class="s0">e}n.push(</span><span class="s1">this</span><span class="s0">.jsxParseElementAt(e,t));</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">c.jsxText:n.push(</span><span class="s1">this</span><span class="s0">.parseExprAtom());</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">c.braceL:{const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.ellipsis)?n.push(</span><span class="s1">this</span><span class="s0">.jsxParseSpreadChild(e)):n.push(</span><span class="s1">this</span><span class="s0">.jsxParseExpressionContainer(e));</span><span class="s1">break</span><span class="s0">}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw this</span><span class="s0">.unexpected()}ee(i)&amp;&amp;!ee(s)?</span><span class="s1">this</span><span class="s0">.raise(s.start,Z.MissingClosingTagFragment):!ee(i)&amp;&amp;ee(s)?</span><span class="s1">this</span><span class="s0">.raise(s.start,Z.MissingClosingTagElement,te(i.name)):ee(i)||ee(s)||te(s.name)!==te(i.name)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(s.start,Z.MissingClosingTagElement,te(i.name))}</span><span class="s1">if</span><span class="s0">(ee(i)?(r.openingFragment=i,r.closingFragment=s):(r.openingElement=i,r.closingElement=s),r.children=n,</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,Z.UnwrappedAdjacentJSXElements);</span><span class="s1">return </span><span class="s0">ee(i)?</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;JSXFragment&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;JSXElement&quot;</span><span class="s0">)}jsxParseElement(){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.jsxParseElementAt(e,t)}parseExprAtom(e){</span><span class="s1">return this</span><span class="s0">.match(c.jsxText)?</span><span class="s1">this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;JSXText&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.match(c.jsxTagStart)?</span><span class="s1">this</span><span class="s0">.jsxParseElement():</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">33</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)?(</span><span class="s1">this</span><span class="s0">.finishToken(c.jsxTagStart),</span><span class="s1">this</span><span class="s0">.jsxParseElement()):super.parseExprAtom(e)}getTokenFromCode(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.inPropertyName)</span><span class="s1">return </span><span class="s0">super.getTokenFromCode(e);const t=</span><span class="s1">this</span><span class="s0">.curContext();</span><span class="s1">if</span><span class="s0">(t===A.j_expr)</span><span class="s1">return this</span><span class="s0">.jsxReadToken();</span><span class="s1">if</span><span class="s0">(t===A.j_oTag||t===A.j_cTag){</span><span class="s1">if</span><span class="s0">(_(e))</span><span class="s1">return this</span><span class="s0">.jsxReadWord();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">62</span><span class="s0">===e)</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.jsxTagEnd);</span><span class="s1">if</span><span class="s0">((</span><span class="s2">34</span><span class="s0">===e||</span><span class="s2">39</span><span class="s0">===e)&amp;&amp;t===A.j_oTag)</span><span class="s1">return this</span><span class="s0">.jsxReadString(e)}</span><span class="s1">return </span><span class="s2">60</span><span class="s0">===e&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.exprAllowed&amp;&amp;</span><span class="s2">33</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)?(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.jsxTagStart)):super.getTokenFromCode(e)}updateContext(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.braceL)){const t=</span><span class="s1">this</span><span class="s0">.curContext();t===A.j_oTag?</span><span class="s1">this</span><span class="s0">.state.context.push(A.braceExpression):t===A.j_expr?</span><span class="s1">this</span><span class="s0">.state.context.push(A.templateQuasi):super.updateContext(e),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c.slash)||e!==c.jsxTagStart)</span><span class="s1">return </span><span class="s0">super.updateContext(e);</span><span class="s1">this</span><span class="s0">.state.context.length-=</span><span class="s2">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.context.push(A.j_cTag),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">}}},flow:e=&gt;{</span><span class="s1">var </span><span class="s0">t;</span><span class="s1">return </span><span class="s0">t=class extends e{constructor(e,t){super(e,t),</span><span class="s1">this</span><span class="s0">.flowPragma=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.flowPragma=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">}shouldParseTypes(){</span><span class="s1">return this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;flow&quot;</span><span class="s0">,</span><span class="s3">&quot;all&quot;</span><span class="s0">)||</span><span class="s3">&quot;flow&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.flowPragma}shouldParseEnums(){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;flow&quot;</span><span class="s0">,</span><span class="s3">&quot;enums&quot;</span><span class="s0">)}finishToken(e,t){</span><span class="s1">return </span><span class="s0">e!==c.string&amp;&amp;e!==c.semi&amp;&amp;e!==c.interpreterDirective&amp;&amp;</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.flowPragma&amp;&amp;(</span><span class="s1">this</span><span class="s0">.flowPragma=</span><span class="s1">null</span><span class="s0">),super.finishToken(e,t)}addComment(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.flowPragma){const t=G.exec(e.value);</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;flow&quot;</span><span class="s0">===t[</span><span class="s2">1</span><span class="s0">])</span><span class="s1">this</span><span class="s0">.flowPragma=</span><span class="s3">&quot;flow&quot;</span><span class="s0">;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;noflow&quot;</span><span class="s0">!==t[</span><span class="s2">1</span><span class="s0">])</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Unexpected flow pragma&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.flowPragma=</span><span class="s3">&quot;noflow&quot;</span><span class="s0">}}</span><span class="s1">return </span><span class="s0">super.addComment(e)}flowParseTypeInitialiser(e){const t=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(e||c.colon);const r=</span><span class="s1">this</span><span class="s0">.flowParseType();</span><span class="s1">return this</span><span class="s0">.state.inType=t,r}flowParsePredicate(){const e=</span><span class="s1">this</span><span class="s0">.startNode(),t=</span><span class="s1">this</span><span class="s0">.state.startLoc,r=</span><span class="s1">this</span><span class="s0">.state.start;</span><span class="s1">this</span><span class="s0">.expect(c.modulo);const n=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">return this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;checks&quot;</span><span class="s0">),t.line===n.line&amp;&amp;t.column===n.column-1||</span><span class="s1">this</span><span class="s0">.raise(r,W.UnexpectedSpaceBetweenModuloChecks),</span><span class="s1">this</span><span class="s0">.eat(c.parenL)?(e.value=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.expect(c.parenR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclaredPredicate&quot;</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;InferredPredicate&quot;</span><span class="s0">)}flowParseTypeAndPredicateInitialiser(){const e=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(c.colon);let t=</span><span class="s1">null</span><span class="s0">,r=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.match(c.modulo)?(</span><span class="s1">this</span><span class="s0">.state.inType=e,r=</span><span class="s1">this</span><span class="s0">.flowParsePredicate()):(t=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.state.inType=e,</span><span class="s1">this</span><span class="s0">.match(c.modulo)&amp;&amp;(r=</span><span class="s1">this</span><span class="s0">.flowParsePredicate())),[t,r]}flowParseDeclareClass(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseInterfaceish(e,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclareClass&quot;</span><span class="s0">)}flowParseDeclareFunction(e){</span><span class="s1">this</span><span class="s0">.next();const t=e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),r=</span><span class="s1">this</span><span class="s0">.startNode(),n=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)?r.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration():r.typeParameters=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(c.parenL);const i=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParams();</span><span class="s1">return </span><span class="s0">r.params=i.params,r.rest=i.rest,</span><span class="s1">this</span><span class="s0">.expect(c.parenR),[r.returnType,e.predicate]=</span><span class="s1">this</span><span class="s0">.flowParseTypeAndPredicateInitialiser(),n.typeAnnotation=</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">),t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.resetEndLocation(t),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclareFunction&quot;</span><span class="s0">)}flowParseDeclare(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._class))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareClass(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._function))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareFunction(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._var))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareVariable(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;module&quot;</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.match(c.dot)?</span><span class="s1">this</span><span class="s0">.flowParseDeclareModuleExports(e):(t&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,W.NestedDeclareModule),</span><span class="s1">this</span><span class="s0">.flowParseDeclareModule(e));</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareTypeAlias(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;opaque&quot;</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareOpaqueType(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;interface&quot;</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareInterface(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._export))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareExportDeclaration(e,t);</span><span class="s1">throw this</span><span class="s0">.unexpected()}flowParseDeclareVariable(e){</span><span class="s1">return this</span><span class="s0">.next(),e.id=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotatableIdentifier(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.declareName(e.id.name,</span><span class="s2">5</span><span class="s0">,e.id.start),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclareVariable&quot;</span><span class="s0">)}flowParseDeclareModule(e){</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(c.string)?e.id=</span><span class="s1">this</span><span class="s0">.parseExprAtom():e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier();const t=e.body=</span><span class="s1">this</span><span class="s0">.startNode(),r=t.body=[];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.braceL);!</span><span class="s1">this</span><span class="s0">.match(c.braceR);){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.match(c._import)?(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(c._typeof)||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,W.InvalidNonTypeImportInDeclareModule),</span><span class="s1">this</span><span class="s0">.parseImport(e)):(</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;declare&quot;</span><span class="s0">,W.UnsupportedStatementInDeclareModule),e=</span><span class="s1">this</span><span class="s0">.flowParseDeclare(e,!</span><span class="s2">0</span><span class="s0">)),r.push(e)}</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">);let n=</span><span class="s1">null</span><span class="s0">,i=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">return </span><span class="s0">r.forEach((e=&gt;{!</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s3">&quot;DeclareExportAllDeclaration&quot;</span><span class="s0">===e.type||</span><span class="s3">&quot;DeclareExportDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(!e.declaration||</span><span class="s3">&quot;TypeAlias&quot;</span><span class="s0">!==e.declaration.type&amp;&amp;</span><span class="s3">&quot;InterfaceDeclaration&quot;</span><span class="s0">!==e.declaration.type)}(e)?</span><span class="s3">&quot;DeclareModuleExports&quot;</span><span class="s0">===e.type&amp;&amp;(i&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,W.DuplicateDeclareModuleExports),</span><span class="s3">&quot;ES&quot;</span><span class="s0">===n&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,W.AmbiguousDeclareModuleKind),n=</span><span class="s3">&quot;CommonJS&quot;</span><span class="s0">,i=!</span><span class="s2">0</span><span class="s0">):(</span><span class="s3">&quot;CommonJS&quot;</span><span class="s0">===n&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,W.AmbiguousDeclareModuleKind),n=</span><span class="s3">&quot;ES&quot;</span><span class="s0">)})),e.kind=n||</span><span class="s3">&quot;CommonJS&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclareModule&quot;</span><span class="s0">)}flowParseDeclareExportDeclaration(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c._export),</span><span class="s1">this</span><span class="s0">.eat(c._default))</span><span class="s1">return this</span><span class="s0">.match(c._function)||</span><span class="s1">this</span><span class="s0">.match(c._class)?e.declaration=</span><span class="s1">this</span><span class="s0">.flowParseDeclare(</span><span class="s1">this</span><span class="s0">.startNode()):(e.declaration=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.semicolon()),e.</span><span class="s1">default</span><span class="s0">=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclareExportDeclaration&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._const)||</span><span class="s1">this</span><span class="s0">.isLet()||(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;interface&quot;</span><span class="s0">))&amp;&amp;!t){const e=</span><span class="s1">this</span><span class="s0">.state.value,t=H[e];</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,W.UnsupportedDeclareExportKind,e,t)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._var)||</span><span class="s1">this</span><span class="s0">.match(c._function)||</span><span class="s1">this</span><span class="s0">.match(c._class)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;opaque&quot;</span><span class="s0">))</span><span class="s1">return </span><span class="s0">e.declaration=</span><span class="s1">this</span><span class="s0">.flowParseDeclare(</span><span class="s1">this</span><span class="s0">.startNode()),e.</span><span class="s1">default</span><span class="s0">=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclareExportDeclaration&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.star)||</span><span class="s1">this</span><span class="s0">.match(c.braceL)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;interface&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;opaque&quot;</span><span class="s0">))</span><span class="s1">return</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">===(e=</span><span class="s1">this</span><span class="s0">.parseExport(e)).type&amp;&amp;(e.type=</span><span class="s3">&quot;ExportDeclaration&quot;</span><span class="s0">,e.</span><span class="s1">default</span><span class="s0">=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">delete </span><span class="s0">e.exportKind),e.type=</span><span class="s3">&quot;Declare&quot;</span><span class="s0">+e.type,e;</span><span class="s1">throw this</span><span class="s0">.unexpected()}flowParseDeclareModuleExports(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;exports&quot;</span><span class="s0">),e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclareModuleExports&quot;</span><span class="s0">)}flowParseDeclareTypeAlias(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseTypeAlias(e),e.type=</span><span class="s3">&quot;DeclareTypeAlias&quot;</span><span class="s0">,e}flowParseDeclareOpaqueType(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseOpaqueType(e,!</span><span class="s2">0</span><span class="s0">),e.type=</span><span class="s3">&quot;DeclareOpaqueType&quot;</span><span class="s0">,e}flowParseDeclareInterface(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseInterfaceish(e),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DeclareInterface&quot;</span><span class="s0">)}flowParseInterfaceish(e,t=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(e.id=</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!t,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.declareName(e.id.name,t?</span><span class="s2">17</span><span class="s0">:</span><span class="s2">9</span><span class="s0">,e.id.start),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)?e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration():e.typeParameters=</span><span class="s1">null</span><span class="s0">,e.extends=[],e.implements=[],e.mixins=[],</span><span class="s1">this</span><span class="s0">.eat(c._extends))</span><span class="s1">do</span><span class="s0">{e.extends.push(</span><span class="s1">this</span><span class="s0">.flowParseInterfaceExtends())}</span><span class="s1">while</span><span class="s0">(!t&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.comma));</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;mixins&quot;</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.next();</span><span class="s1">do</span><span class="s0">{e.mixins.push(</span><span class="s1">this</span><span class="s0">.flowParseInterfaceExtends())}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.comma))}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;implements&quot;</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.next();</span><span class="s1">do</span><span class="s0">{e.implements.push(</span><span class="s1">this</span><span class="s0">.flowParseInterfaceExtends())}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.comma))}e.body=</span><span class="s1">this</span><span class="s0">.flowParseObjectType({allowStatic:t,allowExact:!</span><span class="s2">1</span><span class="s0">,allowSpread:!</span><span class="s2">1</span><span class="s0">,allowProto:t,allowInexact:!</span><span class="s2">1</span><span class="s0">})}flowParseInterfaceExtends(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.id=</span><span class="s1">this</span><span class="s0">.flowParseQualifiedTypeIdentifier(),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)?e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiation():e.typeParameters=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;InterfaceExtends&quot;</span><span class="s0">)}flowParseInterface(e){</span><span class="s1">return this</span><span class="s0">.flowParseInterfaceish(e),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;InterfaceDeclaration&quot;</span><span class="s0">)}checkNotUnderscore(e){</span><span class="s3">&quot;_&quot;</span><span class="s0">===e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,W.UnexpectedReservedUnderscore)}checkReservedType(e,t,r){Y.has(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,r?W.AssignReservedType:W.UnexpectedReservedType,e)}flowParseRestrictedIdentifier(e,t){</span><span class="s1">return this</span><span class="s0">.checkReservedType(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.state.start,t),</span><span class="s1">this</span><span class="s0">.parseIdentifier(e)}flowParseTypeAlias(e){</span><span class="s1">return </span><span class="s0">e.id=</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.declareName(e.id.name,</span><span class="s2">9</span><span class="s0">,e.id.start),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)?e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration():e.typeParameters=</span><span class="s1">null</span><span class="s0">,e.right=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(c.eq),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TypeAlias&quot;</span><span class="s0">)}flowParseOpaqueType(e,t){</span><span class="s1">return this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">),e.id=</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.declareName(e.id.name,</span><span class="s2">9</span><span class="s0">,e.id.start),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)?e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration():e.typeParameters=</span><span class="s1">null</span><span class="s0">,e.supertype=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(c.colon)&amp;&amp;(e.supertype=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(c.colon)),e.impltype=</span><span class="s1">null</span><span class="s0">,t||(e.impltype=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(c.eq)),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;OpaqueType&quot;</span><span class="s0">)}flowParseTypeParameter(e=!</span><span class="s2">1</span><span class="s0">){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.startNode(),n=</span><span class="s1">this</span><span class="s0">.flowParseVariance(),i=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotatableIdentifier();</span><span class="s1">return </span><span class="s0">r.name=i.name,r.variance=n,r.bound=i.typeAnnotation,</span><span class="s1">this</span><span class="s0">.match(c.eq)?(</span><span class="s1">this</span><span class="s0">.eat(c.eq),r.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">this</span><span class="s0">.flowParseType()):e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,W.MissingTypeParamDefault),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;TypeParameter&quot;</span><span class="s0">)}flowParseTypeParameterDeclaration(){const e=</span><span class="s1">this</span><span class="s0">.state.inType,t=</span><span class="s1">this</span><span class="s0">.startNode();t.params=[],</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(c.jsxTagStart)?</span><span class="s1">this</span><span class="s0">.next():</span><span class="s1">this</span><span class="s0">.unexpected();let r=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{const e=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameter(r);t.params.push(e),e.</span><span class="s1">default</span><span class="s0">&amp;&amp;(r=!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expect(c.comma)}</span><span class="s1">while</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">));</span><span class="s1">return this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.inType=e,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TypeParameterDeclaration&quot;</span><span class="s0">)}flowParseTypeParameterInstantiation(){const e=</span><span class="s1">this</span><span class="s0">.startNode(),t=</span><span class="s1">this</span><span class="s0">.state.inType;e.params=[],</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">);const r=</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=!</span><span class="s2">1</span><span class="s0">;!</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">);)e.params.push(</span><span class="s1">this</span><span class="s0">.flowParseType()),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expect(c.comma);</span><span class="s1">return this</span><span class="s0">.state.noAnonFunctionType=r,</span><span class="s1">this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.inType=t,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">)}flowParseTypeParameterInstantiationCallOrNew(){const e=</span><span class="s1">this</span><span class="s0">.startNode(),t=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">for</span><span class="s0">(e.params=[],</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">);!</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">);)e.params.push(</span><span class="s1">this</span><span class="s0">.flowParseTypeOrImplicitInstantiation()),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expect(c.comma);</span><span class="s1">return this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.inType=t,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TypeParameterInstantiation&quot;</span><span class="s0">)}flowParseInterfaceType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;interface&quot;</span><span class="s0">),e.extends=[],</span><span class="s1">this</span><span class="s0">.eat(c._extends))</span><span class="s1">do</span><span class="s0">{e.extends.push(</span><span class="s1">this</span><span class="s0">.flowParseInterfaceExtends())}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.comma));</span><span class="s1">return </span><span class="s0">e.body=</span><span class="s1">this</span><span class="s0">.flowParseObjectType({allowStatic:!</span><span class="s2">1</span><span class="s0">,allowExact:!</span><span class="s2">1</span><span class="s0">,allowSpread:!</span><span class="s2">1</span><span class="s0">,allowProto:!</span><span class="s2">1</span><span class="s0">,allowInexact:!</span><span class="s2">1</span><span class="s0">}),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;InterfaceTypeAnnotation&quot;</span><span class="s0">)}flowParseObjectPropertyKey(){</span><span class="s1">return this</span><span class="s0">.match(c.num)||</span><span class="s1">this</span><span class="s0">.match(c.string)?</span><span class="s1">this</span><span class="s0">.parseExprAtom():</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">)}flowParseObjectTypeIndexer(e,t,r){</span><span class="s1">return </span><span class="s0">e.static=t,</span><span class="s1">this</span><span class="s0">.lookahead().type===c.colon?(e.id=</span><span class="s1">this</span><span class="s0">.flowParseObjectPropertyKey(),e.key=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser()):(e.id=</span><span class="s1">null</span><span class="s0">,e.key=</span><span class="s1">this</span><span class="s0">.flowParseType()),</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),e.value=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(),e.variance=r,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ObjectTypeIndexer&quot;</span><span class="s0">)}flowParseObjectTypeInternalSlot(e,t){</span><span class="s1">return </span><span class="s0">e.static=t,e.id=</span><span class="s1">this</span><span class="s0">.flowParseObjectPropertyKey(),</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(c.parenL)?(e.method=!</span><span class="s2">0</span><span class="s0">,e.optional=!</span><span class="s2">1</span><span class="s0">,e.value=</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeMethodish(</span><span class="s1">this</span><span class="s0">.startNodeAt(e.start,e.loc.start))):(e.method=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(e.optional=!</span><span class="s2">0</span><span class="s0">),e.value=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ObjectTypeInternalSlot&quot;</span><span class="s0">)}flowParseObjectTypeMethodish(e){</span><span class="s1">for</span><span class="s0">(e.params=[],e.rest=</span><span class="s1">null</span><span class="s0">,e.typeParameters=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration()),</span><span class="s1">this</span><span class="s0">.expect(c.parenL);!</span><span class="s1">this</span><span class="s0">.match(c.parenR)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.ellipsis);)e.params.push(</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParam()),</span><span class="s1">this</span><span class="s0">.match(c.parenR)||</span><span class="s1">this</span><span class="s0">.expect(c.comma);</span><span class="s1">return this</span><span class="s0">.eat(c.ellipsis)&amp;&amp;(e.rest=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParam()),</span><span class="s1">this</span><span class="s0">.expect(c.parenR),e.returnType=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">)}flowParseObjectTypeCallProperty(e,t){const r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.static=t,e.value=</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeMethodish(r),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ObjectTypeCallProperty&quot;</span><span class="s0">)}flowParseObjectType({allowStatic:e,allowExact:t,allowSpread:r,allowProto:n,allowInexact:i}){const s=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s2">0</span><span class="s0">;const a=</span><span class="s1">this</span><span class="s0">.startNode();let o,l;a.callProperties=[],a.properties=[],a.indexers=[],a.internalSlots=[];let p=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(t&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.braceBarL)?(</span><span class="s1">this</span><span class="s0">.expect(c.braceBarL),o=c.braceBarR,l=!</span><span class="s2">0</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.expect(c.braceL),o=c.braceR,l=!</span><span class="s2">1</span><span class="s0">),a.exact=l;!</span><span class="s1">this</span><span class="s0">.match(o);){let t=!</span><span class="s2">1</span><span class="s0">,s=</span><span class="s1">null</span><span class="s0">,o=</span><span class="s1">null</span><span class="s0">;const u=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(n&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;proto&quot;</span><span class="s0">)){const t=</span><span class="s1">this</span><span class="s0">.lookahead();t.type!==c.colon&amp;&amp;t.type!==c.question&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),s=</span><span class="s1">this</span><span class="s0">.state.start,e=!</span><span class="s2">1</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(e&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;static&quot;</span><span class="s0">)){const e=</span><span class="s1">this</span><span class="s0">.lookahead();e.type!==c.colon&amp;&amp;e.type!==c.question&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),t=!</span><span class="s2">0</span><span class="s0">)}const d=</span><span class="s1">this</span><span class="s0">.flowParseVariance();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.bracketL))</span><span class="s1">null</span><span class="s0">!=s&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(s),</span><span class="s1">this</span><span class="s0">.eat(c.bracketL)?(d&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(d.start),a.internalSlots.push(</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeInternalSlot(u,t))):a.indexers.push(</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeIndexer(u,t,d));</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">))</span><span class="s1">null</span><span class="s0">!=s&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(s),d&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(d.start),a.callProperties.push(</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeCallProperty(u,t));</span><span class="s1">else</span><span class="s0">{let e=</span><span class="s3">&quot;init&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;get&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;set&quot;</span><span class="s0">)){const t=</span><span class="s1">this</span><span class="s0">.lookahead();t.type!==c.name&amp;&amp;t.type!==c.string&amp;&amp;t.type!==c.num||(e=</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.next())}const n=</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeProperty(u,t,s,d,e,r,</span><span class="s1">null</span><span class="s0">!=i?i:!l);</span><span class="s1">null</span><span class="s0">===n?(p=!</span><span class="s2">0</span><span class="s0">,o=</span><span class="s1">this</span><span class="s0">.state.lastTokStart):a.properties.push(n)}</span><span class="s1">this</span><span class="s0">.flowObjectTypeSemicolon(),!o||</span><span class="s1">this</span><span class="s0">.match(c.braceR)||</span><span class="s1">this</span><span class="s0">.match(c.braceBarR)||</span><span class="s1">this</span><span class="s0">.raise(o,W.UnexpectedExplicitInexactInObject)}</span><span class="s1">this</span><span class="s0">.expect(o),r&amp;&amp;(a.inexact=p);const u=</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s3">&quot;ObjectTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.state.inType=s,u}flowParseObjectTypeProperty(e,t,r,n,i,s,a){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.ellipsis))</span><span class="s1">return this</span><span class="s0">.match(c.comma)||</span><span class="s1">this</span><span class="s0">.match(c.semi)||</span><span class="s1">this</span><span class="s0">.match(c.braceR)||</span><span class="s1">this</span><span class="s0">.match(c.braceBarR)?(s?a||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,W.InexactInsideExact):</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,W.InexactInsideNonObject),n&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(n.start,W.InexactVariance),</span><span class="s1">null</span><span class="s0">):(s||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,W.UnexpectedSpreadType),</span><span class="s1">null</span><span class="s0">!=r&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(r),n&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(n.start,W.SpreadVariance),e.argument=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ObjectTypeSpreadProperty&quot;</span><span class="s0">));{e.key=</span><span class="s1">this</span><span class="s0">.flowParseObjectPropertyKey(),e.static=t,e.proto=</span><span class="s1">null</span><span class="s0">!=r,e.kind=i;let s=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(c.parenL)?(e.method=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">null</span><span class="s0">!=r&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(r),n&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(n.start),e.value=</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeMethodish(</span><span class="s1">this</span><span class="s0">.startNodeAt(e.start,e.loc.start)),</span><span class="s3">&quot;get&quot;</span><span class="s0">!==i&amp;&amp;</span><span class="s3">&quot;set&quot;</span><span class="s0">!==i||</span><span class="s1">this</span><span class="s0">.flowCheckGetterSetterParams(e)):(</span><span class="s3">&quot;init&quot;</span><span class="s0">!==i&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),e.method=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(s=!</span><span class="s2">0</span><span class="s0">),e.value=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(),e.variance=n),e.optional=s,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ObjectTypeProperty&quot;</span><span class="s0">)}}flowCheckGetterSetterParams(e){const t=</span><span class="s3">&quot;get&quot;</span><span class="s0">===e.kind?</span><span class="s2">0</span><span class="s0">:</span><span class="s2">1</span><span class="s0">,r=e.start;e.value.params.length+(e.value.rest?</span><span class="s2">1</span><span class="s0">:</span><span class="s2">0</span><span class="s0">)!==t&amp;&amp;(</span><span class="s3">&quot;get&quot;</span><span class="s0">===e.kind?</span><span class="s1">this</span><span class="s0">.raise(r,x.BadGetterArity):</span><span class="s1">this</span><span class="s0">.raise(r,x.BadSetterArity)),</span><span class="s3">&quot;set&quot;</span><span class="s0">===e.kind&amp;&amp;e.value.rest&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r,x.BadSetterRestParameter)}flowObjectTypeSemicolon(){</span><span class="s1">this</span><span class="s0">.eat(c.semi)||</span><span class="s1">this</span><span class="s0">.eat(c.comma)||</span><span class="s1">this</span><span class="s0">.match(c.braceR)||</span><span class="s1">this</span><span class="s0">.match(c.braceBarR)||</span><span class="s1">this</span><span class="s0">.unexpected()}flowParseQualifiedTypeIdentifier(e,t,r){e=e||</span><span class="s1">this</span><span class="s0">.state.start,t=t||</span><span class="s1">this</span><span class="s0">.state.startLoc;let n=r||</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.eat(c.dot);){const r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);r.qualification=n,r.id=</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s2">0</span><span class="s0">),n=</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;QualifiedTypeIdentifier&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">n}flowParseGenericType(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);</span><span class="s1">return </span><span class="s0">n.typeParameters=</span><span class="s1">null</span><span class="s0">,n.id=</span><span class="s1">this</span><span class="s0">.flowParseQualifiedTypeIdentifier(e,t,r),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(n.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiation()),</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;GenericTypeAnnotation&quot;</span><span class="s0">)}flowParseTypeofType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(c._typeof),e.argument=</span><span class="s1">this</span><span class="s0">.flowParsePrimaryType(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TypeofTypeAnnotation&quot;</span><span class="s0">)}flowParseTupleType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">for</span><span class="s0">(e.types=[],</span><span class="s1">this</span><span class="s0">.expect(c.bracketL);</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.bracketR)&amp;&amp;(e.types.push(</span><span class="s1">this</span><span class="s0">.flowParseType()),!</span><span class="s1">this</span><span class="s0">.match(c.bracketR));)</span><span class="s1">this</span><span class="s0">.expect(c.comma);</span><span class="s1">return this</span><span class="s0">.expect(c.bracketR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TupleTypeAnnotation&quot;</span><span class="s0">)}flowParseFunctionTypeParam(){let e=</span><span class="s1">null</span><span class="s0">,t=!</span><span class="s2">1</span><span class="s0">,r=</span><span class="s1">null</span><span class="s0">;const n=</span><span class="s1">this</span><span class="s0">.startNode(),i=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s1">return </span><span class="s0">i.type===c.colon||i.type===c.question?(e=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(t=!</span><span class="s2">0</span><span class="s0">),r=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser()):r=</span><span class="s1">this</span><span class="s0">.flowParseType(),n.name=e,n.optional=t,n.typeAnnotation=r,</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;FunctionTypeParam&quot;</span><span class="s0">)}reinterpretTypeAsFunctionTypeParam(e){const t=</span><span class="s1">this</span><span class="s0">.startNodeAt(e.start,e.loc.start);</span><span class="s1">return </span><span class="s0">t.name=</span><span class="s1">null</span><span class="s0">,t.optional=!</span><span class="s2">1</span><span class="s0">,t.typeAnnotation=e,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;FunctionTypeParam&quot;</span><span class="s0">)}flowParseFunctionTypeParams(e=[]){let t=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.match(c.parenR)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.ellipsis);)e.push(</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParam()),</span><span class="s1">this</span><span class="s0">.match(c.parenR)||</span><span class="s1">this</span><span class="s0">.expect(c.comma);</span><span class="s1">return this</span><span class="s0">.eat(c.ellipsis)&amp;&amp;(t=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParam()),{params:e,rest:t}}flowIdentToTypeAnnotation(e,t,r,n){</span><span class="s1">switch</span><span class="s0">(n.name){</span><span class="s1">case</span><span class="s3">&quot;any&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;AnyTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;bool&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;boolean&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;BooleanTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;mixed&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;MixedTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;empty&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;EmptyTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;number&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;NumberTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;string&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;StringTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;symbol&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;SymbolTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.checkNotUnderscore(n.name),</span><span class="s1">this</span><span class="s0">.flowParseGenericType(e,t,n)}}flowParsePrimaryType(){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc,r=</span><span class="s1">this</span><span class="s0">.startNode();let n,i,s=!</span><span class="s2">1</span><span class="s0">;const a=</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType;</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c.name:</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;interface&quot;</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.flowParseInterfaceType():</span><span class="s1">this</span><span class="s0">.flowIdentToTypeAnnotation(e,t,r,</span><span class="s1">this</span><span class="s0">.parseIdentifier());</span><span class="s1">case </span><span class="s0">c.braceL:</span><span class="s1">return this</span><span class="s0">.flowParseObjectType({allowStatic:!</span><span class="s2">1</span><span class="s0">,allowExact:!</span><span class="s2">1</span><span class="s0">,allowSpread:!</span><span class="s2">0</span><span class="s0">,allowProto:!</span><span class="s2">1</span><span class="s0">,allowInexact:!</span><span class="s2">0</span><span class="s0">});</span><span class="s1">case </span><span class="s0">c.braceBarL:</span><span class="s1">return this</span><span class="s0">.flowParseObjectType({allowStatic:!</span><span class="s2">1</span><span class="s0">,allowExact:!</span><span class="s2">0</span><span class="s0">,allowSpread:!</span><span class="s2">0</span><span class="s0">,allowProto:!</span><span class="s2">1</span><span class="s0">,allowInexact:!</span><span class="s2">1</span><span class="s0">});</span><span class="s1">case </span><span class="s0">c.bracketL:</span><span class="s1">return this</span><span class="s0">.state.noAnonFunctionType=!</span><span class="s2">1</span><span class="s0">,i=</span><span class="s1">this</span><span class="s0">.flowParseTupleType(),</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=a,i;</span><span class="s1">case </span><span class="s0">c.relational:</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value)</span><span class="s1">return </span><span class="s0">r.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration(),</span><span class="s1">this</span><span class="s0">.expect(c.parenL),n=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParams(),r.params=n.params,r.rest=n.rest,</span><span class="s1">this</span><span class="s0">.expect(c.parenR),</span><span class="s1">this</span><span class="s0">.expect(c.arrow),r.returnType=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">c.parenL:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),!</span><span class="s1">this</span><span class="s0">.match(c.parenR)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.ellipsis))</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.name)){const e=</span><span class="s1">this</span><span class="s0">.lookahead().type;s=e!==c.question&amp;&amp;e!==c.colon}</span><span class="s1">else </span><span class="s0">s=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(s){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=!</span><span class="s2">1</span><span class="s0">,i=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=a,</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType||!(</span><span class="s1">this</span><span class="s0">.match(c.comma)||</span><span class="s1">this</span><span class="s0">.match(c.parenR)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookahead().type===c.arrow))</span><span class="s1">return this</span><span class="s0">.expect(c.parenR),i;</span><span class="s1">this</span><span class="s0">.eat(c.comma)}</span><span class="s1">return </span><span class="s0">n=i?</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParams([</span><span class="s1">this</span><span class="s0">.reinterpretTypeAsFunctionTypeParam(i)]):</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParams(),r.params=n.params,r.rest=n.rest,</span><span class="s1">this</span><span class="s0">.expect(c.parenR),</span><span class="s1">this</span><span class="s0">.expect(c.arrow),r.returnType=</span><span class="s1">this</span><span class="s0">.flowParseType(),r.typeParameters=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.string:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;StringLiteralTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._true:</span><span class="s1">case </span><span class="s0">c._false:</span><span class="s1">return </span><span class="s0">r.value=</span><span class="s1">this</span><span class="s0">.match(c._true),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;BooleanLiteralTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.plusMin:</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;-&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.num))</span><span class="s1">return this</span><span class="s0">.parseLiteral(-</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;NumberLiteralTypeAnnotation&quot;</span><span class="s0">,r.start,r.loc.start);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.bigint))</span><span class="s1">return this</span><span class="s0">.parseLiteral(-</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;BigIntLiteralTypeAnnotation&quot;</span><span class="s0">,r.start,r.loc.start);</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,W.UnexpectedSubtractionOperand)}</span><span class="s1">throw this</span><span class="s0">.unexpected();</span><span class="s1">case </span><span class="s0">c.num:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;NumberLiteralTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.bigint:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;BigIntLiteralTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._void:</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;VoidTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._null:</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;NullLiteralTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._this:</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;ThisTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.star:</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;ExistsTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;typeof&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.type.keyword)</span><span class="s1">return this</span><span class="s0">.flowParseTypeofType();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type.keyword){const e=</span><span class="s1">this</span><span class="s0">.state.type.label;</span><span class="s1">return this</span><span class="s0">.next(),super.createIdentifier(r,e)}}</span><span class="s1">throw this</span><span class="s0">.unexpected()}flowParsePostfixType(){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc;let r=</span><span class="s1">this</span><span class="s0">.flowParsePrimaryType();</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.match(c.bracketL)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon();){const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);n.elementType=r,</span><span class="s1">this</span><span class="s0">.expect(c.bracketL),</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),r=</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;ArrayTypeAnnotation&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">r}flowParsePrefixType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.eat(c.question)?(e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParsePrefixType(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;NullableTypeAnnotation&quot;</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.flowParsePostfixType()}flowParseAnonFunctionWithoutParens(){const e=</span><span class="s1">this</span><span class="s0">.flowParsePrefixType();</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.arrow)){const t=</span><span class="s1">this</span><span class="s0">.startNodeAt(e.start,e.loc.start);</span><span class="s1">return </span><span class="s0">t.params=[</span><span class="s1">this</span><span class="s0">.reinterpretTypeAsFunctionTypeParam(e)],t.rest=</span><span class="s1">null</span><span class="s0">,t.returnType=</span><span class="s1">this</span><span class="s0">.flowParseType(),t.typeParameters=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}flowParseIntersectionType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.eat(c.bitwiseAND);const t=</span><span class="s1">this</span><span class="s0">.flowParseAnonFunctionWithoutParens();</span><span class="s1">for</span><span class="s0">(e.types=[t];</span><span class="s1">this</span><span class="s0">.eat(c.bitwiseAND);)e.types.push(</span><span class="s1">this</span><span class="s0">.flowParseAnonFunctionWithoutParens());</span><span class="s1">return </span><span class="s2">1</span><span class="s0">===e.types.length?t:</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;IntersectionTypeAnnotation&quot;</span><span class="s0">)}flowParseUnionType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.eat(c.bitwiseOR);const t=</span><span class="s1">this</span><span class="s0">.flowParseIntersectionType();</span><span class="s1">for</span><span class="s0">(e.types=[t];</span><span class="s1">this</span><span class="s0">.eat(c.bitwiseOR);)e.types.push(</span><span class="s1">this</span><span class="s0">.flowParseIntersectionType());</span><span class="s1">return </span><span class="s2">1</span><span class="s0">===e.types.length?t:</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;UnionTypeAnnotation&quot;</span><span class="s0">)}flowParseType(){const e=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s2">0</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.flowParseUnionType();</span><span class="s1">return this</span><span class="s0">.state.inType=e,</span><span class="s1">this</span><span class="s0">.state.exprAllowed=</span><span class="s1">this</span><span class="s0">.state.exprAllowed||</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType,t}flowParseTypeOrImplicitInstantiation(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type===c.name&amp;&amp;</span><span class="s3">&quot;_&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc,r=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">return this</span><span class="s0">.flowParseGenericType(e,t,r)}</span><span class="s1">return this</span><span class="s0">.flowParseType()}flowParseTypeAnnotation(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">)}flowParseTypeAnnotatableIdentifier(e){const t=e?</span><span class="s1">this</span><span class="s0">.parseIdentifier():</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier();</span><span class="s1">return this</span><span class="s0">.match(c.colon)&amp;&amp;(t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.resetEndLocation(t)),t}typeCastToParameter(e){</span><span class="s1">return </span><span class="s0">e.expression.typeAnnotation=e.typeAnnotation,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e.expression,e.typeAnnotation.end,e.typeAnnotation.loc.end),e.expression}flowParseVariance(){let e=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.match(c.plusMin)&amp;&amp;(e=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s3">&quot;+&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value?e.kind=</span><span class="s3">&quot;plus&quot;</span><span class="s0">:e.kind=</span><span class="s3">&quot;minus&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;Variance&quot;</span><span class="s0">)),e}parseFunctionBody(e,t,r=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">return </span><span class="s0">t?</span><span class="s1">this</span><span class="s0">.forwardNoArrowParamsConversionAt(e,(()=&gt;super.parseFunctionBody(e,!</span><span class="s2">0</span><span class="s0">,r))):super.parseFunctionBody(e,!</span><span class="s2">1</span><span class="s0">,r)}parseFunctionBodyAndFinish(e,t,r=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.colon)){const t=</span><span class="s1">this</span><span class="s0">.startNode();[t.typeAnnotation,e.predicate]=</span><span class="s1">this</span><span class="s0">.flowParseTypeAndPredicateInitialiser(),e.returnType=t.typeAnnotation?</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">):</span><span class="s1">null</span><span class="s0">}super.parseFunctionBodyAndFinish(e,t,r)}parseStatement(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.name)&amp;&amp;</span><span class="s3">&quot;interface&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value){const e=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s1">if</span><span class="s0">(e.type===c.name||K(e.value)){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseInterface(e)}}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.shouldParseEnums()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;enum&quot;</span><span class="s0">)){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseEnumDeclaration(e)}const r=super.parseStatement(e,t);</span><span class="s1">return void </span><span class="s2">0</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.flowPragma||</span><span class="s1">this</span><span class="s0">.isValidDirective(r)||(</span><span class="s1">this</span><span class="s0">.flowPragma=</span><span class="s1">null</span><span class="s0">),r}parseExpressionStatement(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===t.type)</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;declare&quot;</span><span class="s0">===t.name){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._class)||</span><span class="s1">this</span><span class="s0">.match(c.name)||</span><span class="s1">this</span><span class="s0">.match(c._function)||</span><span class="s1">this</span><span class="s0">.match(c._var)||</span><span class="s1">this</span><span class="s0">.match(c._export))</span><span class="s1">return this</span><span class="s0">.flowParseDeclare(e)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.name)){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;interface&quot;</span><span class="s0">===t.name)</span><span class="s1">return this</span><span class="s0">.flowParseInterface(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;type&quot;</span><span class="s0">===t.name)</span><span class="s1">return this</span><span class="s0">.flowParseTypeAlias(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;opaque&quot;</span><span class="s0">===t.name)</span><span class="s1">return this</span><span class="s0">.flowParseOpaqueType(e,!</span><span class="s2">1</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">super.parseExpressionStatement(e,t)}shouldParseExportDeclaration(){</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;interface&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;opaque&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.shouldParseEnums()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;enum&quot;</span><span class="s0">)||super.shouldParseExportDeclaration()}isExportDefaultSpecifier(){</span><span class="s1">return</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c.name)||!(</span><span class="s3">&quot;type&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value||</span><span class="s3">&quot;interface&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value||</span><span class="s3">&quot;opaque&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value||</span><span class="s1">this</span><span class="s0">.shouldParseEnums()&amp;&amp;</span><span class="s3">&quot;enum&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value))&amp;&amp;super.isExportDefaultSpecifier()}parseExportDefaultExpression(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.shouldParseEnums()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;enum&quot;</span><span class="s0">)){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseEnumDeclaration(e)}</span><span class="s1">return </span><span class="s0">super.parseExportDefaultExpression()}parseConditional(e,t,r,n){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c.question))</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(n){const i=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;super.parseConditional(e,t,r)));</span><span class="s1">return </span><span class="s0">i.node?(i.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=i.failState),i.node):(n.start=i.error.pos||</span><span class="s1">this</span><span class="s0">.state.start,e)}</span><span class="s1">this</span><span class="s0">.expect(c.question);const i=</span><span class="s1">this</span><span class="s0">.state.clone(),s=</span><span class="s1">this</span><span class="s0">.state.noArrowAt,a=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);let{consequent:o,failed:l}=</span><span class="s1">this</span><span class="s0">.tryParseConditionalConsequent(),[p,u]=</span><span class="s1">this</span><span class="s0">.getArrowLikeExpressions(o);</span><span class="s1">if</span><span class="s0">(l||u.length&gt;</span><span class="s2">0</span><span class="s0">){const e=[...s];</span><span class="s1">if</span><span class="s0">(u.length&gt;</span><span class="s2">0</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.state=i,</span><span class="s1">this</span><span class="s0">.state.noArrowAt=e;</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">;t&lt;u.length;t++)e.push(u[t].start);({consequent:o,failed:l}=</span><span class="s1">this</span><span class="s0">.tryParseConditionalConsequent()),[p,u]=</span><span class="s1">this</span><span class="s0">.getArrowLikeExpressions(o)}l&amp;&amp;p.length&gt;</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(i.start,W.AmbiguousConditionalArrow),l&amp;&amp;</span><span class="s2">1</span><span class="s0">===p.length&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=i,</span><span class="s1">this</span><span class="s0">.state.noArrowAt=e.concat(p[</span><span class="s2">0</span><span class="s0">].start),({consequent:o,failed:l}=</span><span class="s1">this</span><span class="s0">.tryParseConditionalConsequent()))}</span><span class="s1">return this</span><span class="s0">.getArrowLikeExpressions(o,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.noArrowAt=s,</span><span class="s1">this</span><span class="s0">.expect(c.colon),a.test=e,a.consequent=o,a.alternate=</span><span class="s1">this</span><span class="s0">.forwardNoArrowParamsConversionAt(a,(()=&gt;</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">))),</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s0">)}tryParseConditionalConsequent(){</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.push(</span><span class="s1">this</span><span class="s0">.state.start);const e=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),t=!</span><span class="s1">this</span><span class="s0">.match(c.colon);</span><span class="s1">return this</span><span class="s0">.state.noArrowParamsConversionAt.pop(),{consequent:e,failed:t}}getArrowLikeExpressions(e,t){const r=[e],n=[];</span><span class="s1">for</span><span class="s0">(;</span><span class="s2">0</span><span class="s0">!==r.length;){const e=r.pop();</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">===e.type?(e.typeParameters||!e.returnType?</span><span class="s1">this</span><span class="s0">.finishArrowValidation(e):n.push(e),r.push(e.body)):</span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s0">===e.type&amp;&amp;(r.push(e.consequent),r.push(e.alternate))}</span><span class="s1">return </span><span class="s0">t?(n.forEach((e=&gt;</span><span class="s1">this</span><span class="s0">.finishArrowValidation(e))),[n,[]]):</span><span class="s1">function</span><span class="s0">(e,t){const r=[],n=[];</span><span class="s1">for</span><span class="s0">(let i=</span><span class="s2">0</span><span class="s0">;i&lt;e.length;i++)(t(e[i])?r:n).push(e[i]);</span><span class="s1">return</span><span class="s0">[r,n]}(n,(e=&gt;e.params.every((e=&gt;</span><span class="s1">this</span><span class="s0">.isAssignable(e,!</span><span class="s2">0</span><span class="s0">)))))}finishArrowValidation(e){</span><span class="s1">var </span><span class="s0">t;</span><span class="s1">this</span><span class="s0">.toAssignableList(e.params,</span><span class="s1">null</span><span class="s0">==(t=e.extra)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.trailingComma),</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">6</span><span class="s0">),super.checkParams(e,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.exit()}forwardNoArrowParamsConversionAt(e,t){let r;</span><span class="s1">return</span><span class="s0">-</span><span class="s2">1</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.indexOf(e.start)?(</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.push(</span><span class="s1">this</span><span class="s0">.state.start),r=t(),</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.pop()):r=t(),r}parseParenItem(e,t,r){</span><span class="s1">if</span><span class="s0">(e=super.parseParenItem(e,t,r),</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(e.optional=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e)),</span><span class="s1">this</span><span class="s0">.match(c.colon)){const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">n.expression=e,n.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}assertModuleNodeAllowed(e){</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;(</span><span class="s3">&quot;type&quot;</span><span class="s0">===e.importKind||</span><span class="s3">&quot;typeof&quot;</span><span class="s0">===e.importKind)||</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;type&quot;</span><span class="s0">===e.exportKind||</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;type&quot;</span><span class="s0">===e.exportKind||super.assertModuleNodeAllowed(e)}parseExport(e){const t=super.parseExport(e);</span><span class="s1">return</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">!==t.type&amp;&amp;</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">!==t.type||(t.exportKind=t.exportKind||</span><span class="s3">&quot;value&quot;</span><span class="s0">),t}parseExportDeclaration(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)){e.exportKind=</span><span class="s3">&quot;type&quot;</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.braceL)?(e.specifiers=</span><span class="s1">this</span><span class="s0">.parseExportSpecifiers(),</span><span class="s1">this</span><span class="s0">.parseExportFrom(e),</span><span class="s1">null</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.flowParseTypeAlias(t)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;opaque&quot;</span><span class="s0">)){e.exportKind=</span><span class="s3">&quot;type&quot;</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseOpaqueType(t,!</span><span class="s2">1</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;interface&quot;</span><span class="s0">)){e.exportKind=</span><span class="s3">&quot;type&quot;</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseInterface(t)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.shouldParseEnums()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;enum&quot;</span><span class="s0">)){e.exportKind=</span><span class="s3">&quot;value&quot;</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseEnumDeclaration(t)}</span><span class="s1">return </span><span class="s0">super.parseExportDeclaration(e)}eatExportStar(e){</span><span class="s1">return</span><span class="s0">!!super.eatExportStar(...arguments)||!(!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.lookahead().type!==c.star)&amp;&amp;(e.exportKind=</span><span class="s3">&quot;type&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.next(),!</span><span class="s2">0</span><span class="s0">)}maybeParseExportNamespaceSpecifier(e){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=super.maybeParseExportNamespaceSpecifier(e);</span><span class="s1">return </span><span class="s0">r&amp;&amp;</span><span class="s3">&quot;type&quot;</span><span class="s0">===e.exportKind&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(t),r}parseClassId(e,t,r){super.parseClassId(e,t,r),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration())}parseClassMember(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.state.start;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;declare&quot;</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parseClassMemberFromModifier(e,t))</span><span class="s1">return</span><span class="s0">;t.declare=!</span><span class="s2">0</span><span class="s0">}super.parseClassMember(e,t,r),t.declare&amp;&amp;(</span><span class="s3">&quot;ClassProperty&quot;</span><span class="s0">!==t.type&amp;&amp;</span><span class="s3">&quot;ClassPrivateProperty&quot;</span><span class="s0">!==t.type?</span><span class="s1">this</span><span class="s0">.raise(n,W.DeclareClassElement):t.value&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.value.start,W.DeclareClassFieldInitializer))}getTokenFromCode(e){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">return </span><span class="s2">123</span><span class="s0">===e&amp;&amp;</span><span class="s2">124</span><span class="s0">===t?</span><span class="s1">this</span><span class="s0">.finishOp(c.braceBarL,</span><span class="s2">2</span><span class="s0">):!</span><span class="s1">this</span><span class="s0">.state.inType||</span><span class="s2">62</span><span class="s0">!==e&amp;&amp;</span><span class="s2">60</span><span class="s0">!==e?</span><span class="s1">this</span><span class="s0">.state.inType&amp;&amp;</span><span class="s2">63</span><span class="s0">===e?</span><span class="s1">this</span><span class="s0">.finishOp(c.question,</span><span class="s2">1</span><span class="s0">):</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s2">64</span><span class="s0">===e&amp;&amp;</span><span class="s2">64</span><span class="s0">===t}(e,t)?(</span><span class="s1">this</span><span class="s0">.state.isIterator=!</span><span class="s2">0</span><span class="s0">,super.readWord()):super.getTokenFromCode(e):</span><span class="s1">this</span><span class="s0">.finishOp(c.relational,</span><span class="s2">1</span><span class="s0">)}isAssignable(e,t){</span><span class="s1">switch</span><span class="s0">(e.type){</span><span class="s1">case</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s0">:{const t=e.properties.length-1;</span><span class="s1">return </span><span class="s0">e.properties.every(((e,r)=&gt;</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">!==e.type&amp;&amp;(r===t||</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">===e.type)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isAssignable(e)))}</span><span class="s1">case</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.isAssignable(e.value);</span><span class="s1">case</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.isAssignable(e.argument);</span><span class="s1">case</span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.elements.every((e=&gt;</span><span class="s1">this</span><span class="s0">.isAssignable(e)));</span><span class="s1">case</span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;=&quot;</span><span class="s0">===e.operator;</span><span class="s1">case</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.isAssignable(e.expression);</span><span class="s1">case</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!t;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}}toAssignable(e){</span><span class="s1">return</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">===e.type?super.toAssignable(</span><span class="s1">this</span><span class="s0">.typeCastToParameter(e)):super.toAssignable(e)}toAssignableList(e,t){</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">;t&lt;e.length;t++){const r=e[t];</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">===(</span><span class="s1">null</span><span class="s0">==r?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.type)&amp;&amp;(e[t]=</span><span class="s1">this</span><span class="s0">.typeCastToParameter(r))}</span><span class="s1">return </span><span class="s0">super.toAssignableList(e,t)}toReferencedList(e,t){</span><span class="s1">for</span><span class="s0">(let n=</span><span class="s2">0</span><span class="s0">;n&lt;e.length;n++){</span><span class="s1">var </span><span class="s0">r;const i=e[n];i&amp;&amp;</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">===i.type&amp;&amp;!(</span><span class="s1">null</span><span class="s0">==(r=i.extra)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.parenthesized)&amp;&amp;(e.length&gt;</span><span class="s2">1</span><span class="s0">||!t)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(i.typeAnnotation.start,W.TypeCastInPattern)}</span><span class="s1">return </span><span class="s0">e}parseArrayLike(e,t,r,n){const i=super.parseArrayLike(e,t,r,n);</span><span class="s1">return </span><span class="s0">t&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters&amp;&amp;</span><span class="s1">this</span><span class="s0">.toReferencedList(i.elements),i}checkLVal(e,t=</span><span class="s2">64</span><span class="s0">,r,n){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">!==e.type)</span><span class="s1">return </span><span class="s0">super.checkLVal(e,t,r,n)}parseClassProperty(e){</span><span class="s1">return this</span><span class="s0">.match(c.colon)&amp;&amp;(e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation()),super.parseClassProperty(e)}parseClassPrivateProperty(e){</span><span class="s1">return this</span><span class="s0">.match(c.colon)&amp;&amp;(e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation()),super.parseClassPrivateProperty(e)}isClassMethod(){</span><span class="s1">return this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)||super.isClassMethod()}isClassProperty(){</span><span class="s1">return this</span><span class="s0">.match(c.colon)||super.isClassProperty()}isNonstaticConstructor(e){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.match(c.colon)&amp;&amp;super.isNonstaticConstructor(e)}pushClassMethod(e,t,r,n,i,s){t.variance&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(t.variance.start),</span><span class="s1">delete </span><span class="s0">t.variance,</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(t.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration()),super.pushClassMethod(e,t,r,n,i,s)}pushClassPrivateMethod(e,t,r,n){t.variance&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(t.variance.start),</span><span class="s1">delete </span><span class="s0">t.variance,</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(t.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration()),super.pushClassPrivateMethod(e,t,r,n)}parseClassSuper(e){</span><span class="s1">if</span><span class="s0">(super.parseClassSuper(e),e.superClass&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(e.superTypeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiation()),</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;implements&quot;</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.next();const t=e.implements=[];</span><span class="s1">do</span><span class="s0">{const e=</span><span class="s1">this</span><span class="s0">.startNode();e.id=</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)?e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiation():e.typeParameters=</span><span class="s1">null</span><span class="s0">,t.push(</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ClassImplements&quot;</span><span class="s0">))}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.comma))}}parsePropertyName(e,t){const r=</span><span class="s1">this</span><span class="s0">.flowParseVariance(),n=super.parsePropertyName(e,t);</span><span class="s1">return </span><span class="s0">e.variance=r,n}parseObjPropValue(e,t,r,n,i,s,a,o){let l;e.variance&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(e.variance.start),</span><span class="s1">delete </span><span class="s0">e.variance,</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;!a&amp;&amp;(l=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration(),</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.unexpected()),super.parseObjPropValue(e,t,r,n,i,s,a,o),l&amp;&amp;((e.value||e).typeParameters=l)}parseAssignableListItemTypes(e){</span><span class="s1">return this</span><span class="s0">.eat(c.question)&amp;&amp;(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,W.OptionalBindingPattern),e.optional=!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(c.colon)&amp;&amp;(e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation()),</span><span class="s1">this</span><span class="s0">.resetEndLocation(e),e}parseMaybeDefault(e,t,r){const n=super.parseMaybeDefault(e,t,r);</span><span class="s1">return</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">===n.type&amp;&amp;n.typeAnnotation&amp;&amp;n.right.start&lt;n.typeAnnotation.start&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(n.typeAnnotation.start,W.TypeBeforeInitializer),n}shouldParseDefaultImport(e){</span><span class="s1">return </span><span class="s0">X(e)?J(</span><span class="s1">this</span><span class="s0">.state):super.shouldParseDefaultImport(e)}parseImportSpecifierLocal(e,t,r,n){t.local=X(e)?</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkLVal(t.local,</span><span class="s2">9</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,n),e.specifiers.push(</span><span class="s1">this</span><span class="s0">.finishNode(t,r))}maybeParseDefaultImportSpecifier(e){e.importKind=</span><span class="s3">&quot;value&quot;</span><span class="s0">;let t=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._typeof)?t=</span><span class="s3">&quot;typeof&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)&amp;&amp;(t=</span><span class="s3">&quot;type&quot;</span><span class="s0">),t){const r=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s3">&quot;type&quot;</span><span class="s0">===t&amp;&amp;r.type===c.star&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(r.start),(J(r)||r.type===c.braceL||r.type===c.star)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),e.importKind=t)}</span><span class="s1">return </span><span class="s0">super.maybeParseDefaultImportSpecifier(e)}parseImportSpecifier(e){const t=</span><span class="s1">this</span><span class="s0">.startNode(),r=</span><span class="s1">this</span><span class="s0">.state.start,n=</span><span class="s1">this</span><span class="s0">.parseModuleExportName();let i=</span><span class="s1">null</span><span class="s0">;</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===n.type&amp;&amp;(</span><span class="s3">&quot;type&quot;</span><span class="s0">===n.name?i=</span><span class="s3">&quot;type&quot;</span><span class="s0">:</span><span class="s3">&quot;typeof&quot;</span><span class="s0">===n.name&amp;&amp;(i=</span><span class="s3">&quot;typeof&quot;</span><span class="s0">));let s=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isLookaheadContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">)){const e=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">null</span><span class="s0">===i||</span><span class="s1">this</span><span class="s0">.match(c.name)||</span><span class="s1">this</span><span class="s0">.state.type.keyword?(t.imported=n,t.importKind=</span><span class="s1">null</span><span class="s0">,t.local=</span><span class="s1">this</span><span class="s0">.parseIdentifier()):(t.imported=e,t.importKind=i,t.local=e.__clone())}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!==i&amp;&amp;(</span><span class="s1">this</span><span class="s0">.match(c.name)||</span><span class="s1">this</span><span class="s0">.state.type.keyword))t.imported=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),t.importKind=i,</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">)?t.local=</span><span class="s1">this</span><span class="s0">.parseIdentifier():(s=!</span><span class="s2">0</span><span class="s0">,t.local=t.imported.__clone());</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===n.type)</span><span class="s1">throw this</span><span class="s0">.raise(t.start,x.ImportBindingIsString,n.value);s=!</span><span class="s2">0</span><span class="s0">,t.imported=n,t.importKind=</span><span class="s1">null</span><span class="s0">,t.local=t.imported.__clone()}const a=X(e),o=X(t);a&amp;&amp;o&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r,W.ImportTypeShorthandOnlyInPureImport),(a||o)&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkReservedType(t.local.name,t.local.start,!</span><span class="s2">0</span><span class="s0">),!s||a||o||</span><span class="s1">this</span><span class="s0">.checkReservedWord(t.local.name,t.start,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.checkLVal(t.local,</span><span class="s2">9</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s3">&quot;import specifier&quot;</span><span class="s0">),e.specifiers.push(</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s0">))}parseFunctionParams(e,t){const r=e.kind;</span><span class="s3">&quot;get&quot;</span><span class="s0">!==r&amp;&amp;</span><span class="s3">&quot;set&quot;</span><span class="s0">!==r&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration()),super.parseFunctionParams(e,t)}parseVarId(e,t){super.parseVarId(e,t),</span><span class="s1">this</span><span class="s0">.match(c.colon)&amp;&amp;(e.id.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.resetEndLocation(e.id))}parseAsyncArrowFromCallExpression(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.colon)){const t=</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType;</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=!</span><span class="s2">0</span><span class="s0">,e.returnType=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=t}</span><span class="s1">return </span><span class="s0">super.parseAsyncArrowFromCallExpression(e,t)}shouldParseAsyncArrow(){</span><span class="s1">return this</span><span class="s0">.match(c.colon)||super.shouldParseAsyncArrow()}parseMaybeAssign(e,t,r){</span><span class="s1">var </span><span class="s0">n;let i,s=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;jsx&quot;</span><span class="s0">)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.match(c.jsxTagStart)||</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">))){</span><span class="s1">if</span><span class="s0">(s=</span><span class="s1">this</span><span class="s0">.state.clone(),i=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;super.parseMaybeAssign(e,t,r)),s),!i.error)</span><span class="s1">return </span><span class="s0">i.node;const{context:n}=</span><span class="s1">this</span><span class="s0">.state;n[n.length-1]===A.j_oTag?n.length-=</span><span class="s2">2</span><span class="s0">:n[n.length-1]===A.j_expr&amp;&amp;(n.length-=</span><span class="s2">1</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">((</span><span class="s1">null</span><span class="s0">==(n=i)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:n.error)||</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)){</span><span class="s1">var </span><span class="s0">a,o;let n;s=s||</span><span class="s1">this</span><span class="s0">.state.clone();const l=</span><span class="s1">this</span><span class="s0">.tryParse((i=&gt;{</span><span class="s1">var </span><span class="s0">s;n=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration();const a=</span><span class="s1">this</span><span class="s0">.forwardNoArrowParamsConversionAt(n,(()=&gt;{const i=super.parseMaybeAssign(e,t,r);</span><span class="s1">return this</span><span class="s0">.resetStartLocationFromNode(i,n),i}));</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">!==a.type&amp;&amp;(</span><span class="s1">null</span><span class="s0">==(s=a.extra)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:s.parenthesized)&amp;&amp;i();const o=</span><span class="s1">this</span><span class="s0">.maybeUnwrapTypeCastExpression(a);</span><span class="s1">return </span><span class="s0">o.typeParameters=n,</span><span class="s1">this</span><span class="s0">.resetStartLocationFromNode(o,n),a}),s);let p=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(l.node&amp;&amp;</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.maybeUnwrapTypeCastExpression(l.node).type){</span><span class="s1">if</span><span class="s0">(!l.error&amp;&amp;!l.aborted)</span><span class="s1">return </span><span class="s0">l.node.async&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(n.start,W.UnexpectedTypeParameterBeforeAsyncArrowFunction),l.node;p=l.node}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==(a=i)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:a.node)</span><span class="s1">return this</span><span class="s0">.state=i.failState,i.node;</span><span class="s1">if</span><span class="s0">(p)</span><span class="s1">return this</span><span class="s0">.state=l.failState,p;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==(o=i)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:o.thrown)</span><span class="s1">throw </span><span class="s0">i.error;</span><span class="s1">if</span><span class="s0">(l.thrown)</span><span class="s1">throw </span><span class="s0">l.error;</span><span class="s1">throw this</span><span class="s0">.raise(n.start,W.UnexpectedTokenAfterTypeParameter)}</span><span class="s1">return </span><span class="s0">super.parseMaybeAssign(e,t,r)}parseArrow(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.colon)){const t=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;{const t=</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType;</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=!</span><span class="s2">0</span><span class="s0">;const r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return</span><span class="s0">[r.typeAnnotation,e.predicate]=</span><span class="s1">this</span><span class="s0">.flowParseTypeAndPredicateInitialiser(),</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=t,</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.match(c.arrow)||</span><span class="s1">this</span><span class="s0">.unexpected(),r}));</span><span class="s1">if</span><span class="s0">(t.thrown)</span><span class="s1">return null</span><span class="s0">;t.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=t.failState),e.returnType=t.node.typeAnnotation?</span><span class="s1">this</span><span class="s0">.finishNode(t.node,</span><span class="s3">&quot;TypeAnnotation&quot;</span><span class="s0">):</span><span class="s1">null</span><span class="s0">}</span><span class="s1">return </span><span class="s0">super.parseArrow(e)}shouldParseArrow(){</span><span class="s1">return this</span><span class="s0">.match(c.colon)||super.shouldParseArrow()}setArrowFunctionParameters(e,t){-</span><span class="s2">1</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.indexOf(e.start)?e.params=t:super.setArrowFunctionParameters(e,t)}checkParams(e,t,r){</span><span class="s1">if</span><span class="s0">(!r||-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.indexOf(e.start))</span><span class="s1">return </span><span class="s0">super.checkParams(...arguments)}parseParenAndDistinguishExpression(e){</span><span class="s1">return </span><span class="s0">super.parseParenAndDistinguishExpression(e&amp;&amp;-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.noArrowAt.indexOf(</span><span class="s1">this</span><span class="s0">.state.start))}parseSubscripts(e,t,r,n){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;async&quot;</span><span class="s0">===e.name&amp;&amp;-</span><span class="s2">1</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.state.noArrowAt.indexOf(t)){</span><span class="s1">this</span><span class="s0">.next();const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);n.callee=e,n.arguments=</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(c.parenR,!</span><span class="s2">1</span><span class="s0">),e=</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;CallExpression&quot;</span><span class="s0">)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;async&quot;</span><span class="s0">===e.name&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)){const i=</span><span class="s1">this</span><span class="s0">.state.clone(),s=</span><span class="s1">this</span><span class="s0">.tryParse((e=&gt;</span><span class="s1">this</span><span class="s0">.parseAsyncArrowWithTypeParameters(t,r)||e()),i);</span><span class="s1">if</span><span class="s0">(!s.error&amp;&amp;!s.aborted)</span><span class="s1">return </span><span class="s0">s.node;const a=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;super.parseSubscripts(e,t,r,n)),i);</span><span class="s1">if</span><span class="s0">(a.node&amp;&amp;!a.error)</span><span class="s1">return </span><span class="s0">a.node;</span><span class="s1">if</span><span class="s0">(s.node)</span><span class="s1">return this</span><span class="s0">.state=s.failState,s.node;</span><span class="s1">if</span><span class="s0">(a.node)</span><span class="s1">return this</span><span class="s0">.state=a.failState,a.node;</span><span class="s1">throw </span><span class="s0">s.error||a.error}</span><span class="s1">return </span><span class="s0">super.parseSubscripts(e,t,r,n)}parseSubscript(e,t,r,n,i){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.questionDot)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isLookaheadToken_lt()){</span><span class="s1">if</span><span class="s0">(i.optionalChainMember=!</span><span class="s2">0</span><span class="s0">,n)</span><span class="s1">return </span><span class="s0">i.stop=!</span><span class="s2">0</span><span class="s0">,e;</span><span class="s1">this</span><span class="s0">.next();const s=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">s.callee=e,s.typeArguments=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiation(),</span><span class="s1">this</span><span class="s0">.expect(c.parenL),s.arguments=</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(c.parenR,!</span><span class="s2">1</span><span class="s0">),s.optional=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishCallExpression(s,!</span><span class="s2">0</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(!n&amp;&amp;</span><span class="s1">this</span><span class="s0">.shouldParseTypes()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)){const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);n.callee=e;const s=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;(n.typeArguments=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiationCallOrNew(),</span><span class="s1">this</span><span class="s0">.expect(c.parenL),n.arguments=</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(c.parenR,!</span><span class="s2">1</span><span class="s0">),i.optionalChainMember&amp;&amp;(n.optional=!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishCallExpression(n,i.optionalChainMember))));</span><span class="s1">if</span><span class="s0">(s.node)</span><span class="s1">return </span><span class="s0">s.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=s.failState),s.node}</span><span class="s1">return </span><span class="s0">super.parseSubscript(e,t,r,n,i)}parseNewArguments(e){let t=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.shouldParseTypes()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(t=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiationCallOrNew())).node),e.typeArguments=t,super.parseNewArguments(e)}parseAsyncArrowWithTypeParameters(e,t){const r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parseFunctionParams(r),</span><span class="s1">this</span><span class="s0">.parseArrow(r))</span><span class="s1">return this</span><span class="s0">.parseArrowExpression(r,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">)}readToken_mult_modulo(e){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">42</span><span class="s0">===e&amp;&amp;</span><span class="s2">47</span><span class="s0">===t&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.hasFlowComment)</span><span class="s1">return this</span><span class="s0">.state.hasFlowComment=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">,</span><span class="s1">void this</span><span class="s0">.nextToken();super.readToken_mult_modulo(e)}readToken_pipe_amp(e){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);</span><span class="s2">124</span><span class="s0">!==e||</span><span class="s2">125</span><span class="s0">!==t?super.readToken_pipe_amp(e):</span><span class="s1">this</span><span class="s0">.finishOp(c.braceBarR,</span><span class="s2">2</span><span class="s0">)}parseTopLevel(e,t){const r=super.parseTopLevel(e,t);</span><span class="s1">return this</span><span class="s0">.state.hasFlowComment&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,W.UnterminatedFlowComment),r}skipBlockComment(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;flowComments&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.skipFlowComment())</span><span class="s1">return this</span><span class="s0">.state.hasFlowComment&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,W.NestedFlowComment),</span><span class="s1">this</span><span class="s0">.hasFlowCommentCompletion(),</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s1">this</span><span class="s0">.skipFlowComment(),</span><span class="s1">void</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.hasFlowComment=!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.hasFlowComment){const e=</span><span class="s1">this</span><span class="s0">.input.indexOf(</span><span class="s3">&quot;*-/&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(-</span><span class="s2">1</span><span class="s0">===e)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos-2,x.UnterminatedComment);</span><span class="s1">this</span><span class="s0">.state.pos=e+</span><span class="s2">3</span><span class="s0">}</span><span class="s1">else </span><span class="s0">super.skipBlockComment()}skipFlowComment(){const{pos:e}=</span><span class="s1">this</span><span class="s0">.state;let t=</span><span class="s2">2</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;[</span><span class="s2">32</span><span class="s0">,</span><span class="s2">9</span><span class="s0">].includes(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e+t));)t++;const r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(t+e),n=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(t+e+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">return </span><span class="s2">58</span><span class="s0">===r&amp;&amp;</span><span class="s2">58</span><span class="s0">===n?t+</span><span class="s2">2</span><span class="s0">:</span><span class="s3">&quot;flow-include&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.slice(t+e,t+e+</span><span class="s2">12</span><span class="s0">)?t+</span><span class="s2">12</span><span class="s0">:</span><span class="s2">58</span><span class="s0">===r&amp;&amp;</span><span class="s2">58</span><span class="s0">!==n&amp;&amp;t}hasFlowCommentCompletion(){</span><span class="s1">if</span><span class="s0">(-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.indexOf(</span><span class="s3">&quot;*/&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.UnterminatedComment)}flowEnumErrorBooleanMemberNotInitialized(e,{enumName:t,memberName:r}){</span><span class="s1">this</span><span class="s0">.raise(e,W.EnumBooleanMemberNotInitialized,r,t)}flowEnumErrorInvalidMemberName(e,{enumName:t,memberName:r}){const n=r[</span><span class="s2">0</span><span class="s0">].toUpperCase()+r.slice(</span><span class="s2">1</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.raise(e,W.EnumInvalidMemberName,r,n,t)}flowEnumErrorDuplicateMemberName(e,{enumName:t,memberName:r}){</span><span class="s1">this</span><span class="s0">.raise(e,W.EnumDuplicateMemberName,r,t)}flowEnumErrorInconsistentMemberValues(e,{enumName:t}){</span><span class="s1">this</span><span class="s0">.raise(e,W.EnumInconsistentMemberValues,t)}flowEnumErrorInvalidExplicitType(e,{enumName:t,suppliedType:r}){</span><span class="s1">return this</span><span class="s0">.raise(e,</span><span class="s1">null</span><span class="s0">===r?W.EnumInvalidExplicitTypeUnknownSupplied:W.EnumInvalidExplicitType,t,r)}flowEnumErrorInvalidMemberInitializer(e,{enumName:t,explicitType:r,memberName:n}){let i=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">switch</span><span class="s0">(r){</span><span class="s1">case</span><span class="s3">&quot;boolean&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;number&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;string&quot;</span><span class="s0">:i=W.EnumInvalidMemberInitializerPrimaryType;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;symbol&quot;</span><span class="s0">:i=W.EnumInvalidMemberInitializerSymbolType;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:i=W.EnumInvalidMemberInitializerUnknownType}</span><span class="s1">return this</span><span class="s0">.raise(e,i,t,n,r)}flowEnumErrorNumberMemberNotInitialized(e,{enumName:t,memberName:r}){</span><span class="s1">this</span><span class="s0">.raise(e,W.EnumNumberMemberNotInitialized,t,r)}flowEnumErrorStringMemberInconsistentlyInitailized(e,{enumName:t}){</span><span class="s1">this</span><span class="s0">.raise(e,W.EnumStringMemberInconsistentlyInitailized,t)}flowEnumMemberInit(){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=()=&gt;</span><span class="s1">this</span><span class="s0">.match(c.comma)||</span><span class="s1">this</span><span class="s0">.match(c.braceR);</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c.num:{const r=</span><span class="s1">this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">t()?{type:</span><span class="s3">&quot;number&quot;</span><span class="s0">,pos:r.start,value:r}:{type:</span><span class="s3">&quot;invalid&quot;</span><span class="s0">,pos:e}}</span><span class="s1">case </span><span class="s0">c.string:{const r=</span><span class="s1">this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">t()?{type:</span><span class="s3">&quot;string&quot;</span><span class="s0">,pos:r.start,value:r}:{type:</span><span class="s3">&quot;invalid&quot;</span><span class="s0">,pos:e}}</span><span class="s1">case </span><span class="s0">c._true:</span><span class="s1">case </span><span class="s0">c._false:{const r=</span><span class="s1">this</span><span class="s0">.parseBooleanLiteral();</span><span class="s1">return </span><span class="s0">t()?{type:</span><span class="s3">&quot;boolean&quot;</span><span class="s0">,pos:r.start,value:r}:{type:</span><span class="s3">&quot;invalid&quot;</span><span class="s0">,pos:e}}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">{type:</span><span class="s3">&quot;invalid&quot;</span><span class="s0">,pos:e}}}flowEnumMemberRaw(){const e=</span><span class="s1">this</span><span class="s0">.state.start;</span><span class="s1">return</span><span class="s0">{id:</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),init:</span><span class="s1">this</span><span class="s0">.eat(c.eq)?</span><span class="s1">this</span><span class="s0">.flowEnumMemberInit():{type:</span><span class="s3">&quot;none&quot;</span><span class="s0">,pos:e}}}flowEnumCheckExplicitTypeMismatch(e,t,r){const{explicitType:n}=t;</span><span class="s1">null</span><span class="s0">!==n&amp;&amp;n!==r&amp;&amp;</span><span class="s1">this</span><span class="s0">.flowEnumErrorInvalidMemberInitializer(e,t)}flowEnumMembers({enumName:e,explicitType:t}){const r=</span><span class="s1">new </span><span class="s0">Set,n={booleanMembers:[],numberMembers:[],stringMembers:[],defaultedMembers:[]};</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.match(c.braceR);){const i=</span><span class="s1">this</span><span class="s0">.startNode(),{id:s,init:a}=</span><span class="s1">this</span><span class="s0">.flowEnumMemberRaw(),o=s.name;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;&quot;</span><span class="s0">===o)</span><span class="s1">continue</span><span class="s0">;/^[a-z]/.test(o)&amp;&amp;</span><span class="s1">this</span><span class="s0">.flowEnumErrorInvalidMemberName(s.start,{enumName:e,memberName:o}),r.has(o)&amp;&amp;</span><span class="s1">this</span><span class="s0">.flowEnumErrorDuplicateMemberName(s.start,{enumName:e,memberName:o}),r.add(o);const l={enumName:e,explicitType:t,memberName:o};</span><span class="s1">switch</span><span class="s0">(i.id=s,a.type){</span><span class="s1">case</span><span class="s3">&quot;boolean&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.flowEnumCheckExplicitTypeMismatch(a.pos,l,</span><span class="s3">&quot;boolean&quot;</span><span class="s0">),i.init=a.value,n.booleanMembers.push(</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s3">&quot;EnumBooleanMember&quot;</span><span class="s0">));</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;number&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.flowEnumCheckExplicitTypeMismatch(a.pos,l,</span><span class="s3">&quot;number&quot;</span><span class="s0">),i.init=a.value,n.numberMembers.push(</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s3">&quot;EnumNumberMember&quot;</span><span class="s0">));</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;string&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.flowEnumCheckExplicitTypeMismatch(a.pos,l,</span><span class="s3">&quot;string&quot;</span><span class="s0">),i.init=a.value,n.stringMembers.push(</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s3">&quot;EnumStringMember&quot;</span><span class="s0">));</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;invalid&quot;</span><span class="s0">:</span><span class="s1">throw this</span><span class="s0">.flowEnumErrorInvalidMemberInitializer(a.pos,l);</span><span class="s1">case</span><span class="s3">&quot;none&quot;</span><span class="s0">:</span><span class="s1">switch</span><span class="s0">(t){</span><span class="s1">case</span><span class="s3">&quot;boolean&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.flowEnumErrorBooleanMemberNotInitialized(a.pos,l);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;number&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.flowEnumErrorNumberMemberNotInitialized(a.pos,l);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:n.defaultedMembers.push(</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s3">&quot;EnumDefaultedMember&quot;</span><span class="s0">))}}</span><span class="s1">this</span><span class="s0">.match(c.braceR)||</span><span class="s1">this</span><span class="s0">.expect(c.comma)}</span><span class="s1">return </span><span class="s0">n}flowEnumStringMembers(e,t,{enumName:r}){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">0</span><span class="s0">===e.length)</span><span class="s1">return </span><span class="s0">t;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">0</span><span class="s0">===t.length)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(t.length&gt;e.length){</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">;t&lt;e.length;t++){const n=e[t];</span><span class="s1">this</span><span class="s0">.flowEnumErrorStringMemberInconsistentlyInitailized(n.start,{enumName:r})}</span><span class="s1">return </span><span class="s0">t}</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">;e&lt;t.length;e++){const n=t[e];</span><span class="s1">this</span><span class="s0">.flowEnumErrorStringMemberInconsistentlyInitailized(n.start,{enumName:r})}</span><span class="s1">return </span><span class="s0">e}flowEnumParseExplicitType({enumName:e}){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;of&quot;</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c.name))</span><span class="s1">throw this</span><span class="s0">.flowEnumErrorInvalidExplicitType(</span><span class="s1">this</span><span class="s0">.state.start,{enumName:e,suppliedType:</span><span class="s1">null</span><span class="s0">});const{value:t}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s3">&quot;boolean&quot;</span><span class="s0">!==t&amp;&amp;</span><span class="s3">&quot;number&quot;</span><span class="s0">!==t&amp;&amp;</span><span class="s3">&quot;string&quot;</span><span class="s0">!==t&amp;&amp;</span><span class="s3">&quot;symbol&quot;</span><span class="s0">!==t&amp;&amp;</span><span class="s1">this</span><span class="s0">.flowEnumErrorInvalidExplicitType(</span><span class="s1">this</span><span class="s0">.state.start,{enumName:e,suppliedType:t}),t}</span><span class="s1">return null</span><span class="s0">}flowEnumBody(e,{enumName:t,nameLoc:r}){const n=</span><span class="s1">this</span><span class="s0">.flowEnumParseExplicitType({enumName:t});</span><span class="s1">this</span><span class="s0">.expect(c.braceL);const i=</span><span class="s1">this</span><span class="s0">.flowEnumMembers({enumName:t,explicitType:n});</span><span class="s1">switch</span><span class="s0">(n){</span><span class="s1">case</span><span class="s3">&quot;boolean&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.explicitType=!</span><span class="s2">0</span><span class="s0">,e.members=i.booleanMembers,</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumBooleanBody&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;number&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.explicitType=!</span><span class="s2">0</span><span class="s0">,e.members=i.numberMembers,</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumNumberBody&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;string&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.explicitType=!</span><span class="s2">0</span><span class="s0">,e.members=</span><span class="s1">this</span><span class="s0">.flowEnumStringMembers(i.stringMembers,i.defaultedMembers,{enumName:t}),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumStringBody&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;symbol&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.members=i.defaultedMembers,</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumSymbolBody&quot;</span><span class="s0">);</span><span class="s1">default</span><span class="s0">:{const n=()=&gt;(e.members=[],</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumStringBody&quot;</span><span class="s0">));e.explicitType=!</span><span class="s2">1</span><span class="s0">;const s=i.booleanMembers.length,a=i.numberMembers.length,o=i.stringMembers.length,l=i.defaultedMembers.length;</span><span class="s1">if</span><span class="s0">(s||a||o||l){</span><span class="s1">if</span><span class="s0">(s||a){</span><span class="s1">if</span><span class="s0">(!a&amp;&amp;!o&amp;&amp;s&gt;=l){</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">,r=i.defaultedMembers;e&lt;r.length;e++){const n=r[e];</span><span class="s1">this</span><span class="s0">.flowEnumErrorBooleanMemberNotInitialized(n.start,{enumName:t,memberName:n.id.name})}</span><span class="s1">return </span><span class="s0">e.members=i.booleanMembers,</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumBooleanBody&quot;</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(!s&amp;&amp;!o&amp;&amp;a&gt;=l){</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">,r=i.defaultedMembers;e&lt;r.length;e++){const n=r[e];</span><span class="s1">this</span><span class="s0">.flowEnumErrorNumberMemberNotInitialized(n.start,{enumName:t,memberName:n.id.name})}</span><span class="s1">return </span><span class="s0">e.members=i.numberMembers,</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumNumberBody&quot;</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.flowEnumErrorInconsistentMemberValues(r,{enumName:t}),n()}</span><span class="s1">return </span><span class="s0">e.members=</span><span class="s1">this</span><span class="s0">.flowEnumStringMembers(i.stringMembers,i.defaultedMembers,{enumName:t}),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumStringBody&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">n()}}}flowParseEnumDeclaration(e){const t=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">return </span><span class="s0">e.id=t,e.body=</span><span class="s1">this</span><span class="s0">.flowEnumBody(</span><span class="s1">this</span><span class="s0">.startNode(),{enumName:t.name,nameLoc:t.start}),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EnumDeclaration&quot;</span><span class="s0">)}updateContext(e){</span><span class="s1">this</span><span class="s0">.match(c.name)&amp;&amp;</span><span class="s3">&quot;of&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value&amp;&amp;e===c.name&amp;&amp;</span><span class="s3">&quot;interface&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.slice(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,</span><span class="s1">this</span><span class="s0">.state.lastTokEnd)?</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">:super.updateContext(e)}isLookaheadToken_lt(){const e=</span><span class="s1">this</span><span class="s0">.nextTokenStart();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">60</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e)){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">return </span><span class="s2">60</span><span class="s0">!==t&amp;&amp;</span><span class="s2">61</span><span class="s0">!==t}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}maybeUnwrapTypeCastExpression(e){</span><span class="s1">return</span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s0">===e.type?e.expression:e}},t},typescript:e=&gt;class extends e{getScopeHandler(){</span><span class="s1">return </span><span class="s0">se}tsIsIdentifier(){</span><span class="s1">return this</span><span class="s0">.match(c.name)}tsNextTokenCanFollowModifier(){</span><span class="s1">return this</span><span class="s0">.next(),!(</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()||</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.match(c.parenR)||</span><span class="s1">this</span><span class="s0">.match(c.colon)||</span><span class="s1">this</span><span class="s0">.match(c.eq)||</span><span class="s1">this</span><span class="s0">.match(c.question)||</span><span class="s1">this</span><span class="s0">.match(c.bang))}tsParseModifier(e){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c.name))</span><span class="s1">return</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">return</span><span class="s0">-</span><span class="s2">1</span><span class="s0">!==e.indexOf(t)&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsTryParse(</span><span class="s1">this</span><span class="s0">.tsNextTokenCanFollowModifier.bind(</span><span class="s1">this</span><span class="s0">))?t:</span><span class="s1">void </span><span class="s2">0</span><span class="s0">}tsParseModifiers(e,t){</span><span class="s1">for</span><span class="s0">(;;){const r=</span><span class="s1">this</span><span class="s0">.state.start,n=</span><span class="s1">this</span><span class="s0">.tsParseModifier(t);</span><span class="s1">if</span><span class="s0">(!n)</span><span class="s1">break</span><span class="s0">;Object.hasOwnProperty.call(e,n)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r,ce.DuplicateModifier,n),e[n]=!</span><span class="s2">0</span><span class="s0">}}tsIsListTerminator(e){</span><span class="s1">switch</span><span class="s0">(e){</span><span class="s1">case</span><span class="s3">&quot;EnumMembers&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TypeMembers&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.match(c.braceR);</span><span class="s1">case</span><span class="s3">&quot;HeritageClauseElement&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.match(c.braceL);</span><span class="s1">case</span><span class="s3">&quot;TupleElementTypes&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.match(c.bracketR);</span><span class="s1">case</span><span class="s3">&quot;TypeParametersOrArguments&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">)}</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Unreachable&quot;</span><span class="s0">)}tsParseList(e,t){const r=[];</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.tsIsListTerminator(e);)r.push(t());</span><span class="s1">return </span><span class="s0">r}tsParseDelimitedList(e,t){</span><span class="s1">return </span><span class="s0">le(</span><span class="s1">this</span><span class="s0">.tsParseDelimitedListWorker(e,t,!</span><span class="s2">0</span><span class="s0">))}tsParseDelimitedListWorker(e,t,r){const n=[];</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.tsIsListTerminator(e);){const i=t();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==i)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(n.push(i),!</span><span class="s1">this</span><span class="s0">.eat(c.comma)){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsIsListTerminator(e))</span><span class="s1">break</span><span class="s0">;</span><span class="s1">return void</span><span class="s0">(r&amp;&amp;</span><span class="s1">this</span><span class="s0">.expect(c.comma))}}</span><span class="s1">return </span><span class="s0">n}tsParseBracketedList(e,t,r,n){n||(r?</span><span class="s1">this</span><span class="s0">.expect(c.bracketL):</span><span class="s1">this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">));const i=</span><span class="s1">this</span><span class="s0">.tsParseDelimitedList(e,t);</span><span class="s1">return </span><span class="s0">r?</span><span class="s1">this</span><span class="s0">.expect(c.bracketR):</span><span class="s1">this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">),i}tsParseImportType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(c._import),</span><span class="s1">this</span><span class="s0">.expect(c.parenL),</span><span class="s1">this</span><span class="s0">.match(c.string)||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,ce.UnsupportedImportTypeArgument),e.argument=</span><span class="s1">this</span><span class="s0">.parseExprAtom(),</span><span class="s1">this</span><span class="s0">.expect(c.parenR),</span><span class="s1">this</span><span class="s0">.eat(c.dot)&amp;&amp;(e.qualifier=</span><span class="s1">this</span><span class="s0">.tsParseEntityName(!</span><span class="s2">0</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSImportType&quot;</span><span class="s0">)}tsParseEntityName(e){let t=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.eat(c.dot);){const r=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(t);r.left=t,r.right=</span><span class="s1">this</span><span class="s0">.parseIdentifier(e),t=</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;TSQualifiedName&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">t}tsParseTypeReference(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.typeName=</span><span class="s1">this</span><span class="s0">.tsParseEntityName(!</span><span class="s2">1</span><span class="s0">),!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeReference&quot;</span><span class="s0">)}tsParseThisTypePredicate(e){</span><span class="s1">this</span><span class="s0">.next();const t=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e);</span><span class="s1">return </span><span class="s0">t.parameterName=e,t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation(!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSTypePredicate&quot;</span><span class="s0">)}tsParseThisTypeNode(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSThisType&quot;</span><span class="s0">)}tsParseTypeQuery(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(c._typeof),</span><span class="s1">this</span><span class="s0">.match(c._import)?e.exprName=</span><span class="s1">this</span><span class="s0">.tsParseImportType():e.exprName=</span><span class="s1">this</span><span class="s0">.tsParseEntityName(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeQuery&quot;</span><span class="s0">)}tsParseTypeParameter(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.name=</span><span class="s1">this</span><span class="s0">.parseIdentifierName(e.start),e.constraint=</span><span class="s1">this</span><span class="s0">.tsEatThenParseType(c._extends),e.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">this</span><span class="s0">.tsEatThenParseType(c.eq),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeParameter&quot;</span><span class="s0">)}tsTryParseTypeParameters(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.tsParseTypeParameters()}tsParseTypeParameters(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(c.jsxTagStart)?</span><span class="s1">this</span><span class="s0">.next():</span><span class="s1">this</span><span class="s0">.unexpected(),e.params=</span><span class="s1">this</span><span class="s0">.tsParseBracketedList(</span><span class="s3">&quot;TypeParametersOrArguments&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseTypeParameter.bind(</span><span class="s1">this</span><span class="s0">),!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s2">0</span><span class="s0">===e.params.length&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,ce.EmptyTypeParameters),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeParameterDeclaration&quot;</span><span class="s0">)}tsTryNextParseConstantContext(){</span><span class="s1">return this</span><span class="s0">.lookahead().type===c._const?(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.tsParseTypeReference()):</span><span class="s1">null</span><span class="s0">}tsFillSignature(e,t){const r=e===c.arrow;t.typeParameters=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters(),</span><span class="s1">this</span><span class="s0">.expect(c.parenL),t.parameters=</span><span class="s1">this</span><span class="s0">.tsParseBindingListForSignature(),(r||</span><span class="s1">this</span><span class="s0">.match(e))&amp;&amp;(t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseTypeOrTypePredicateAnnotation(e))}tsParseBindingListForSignature(){</span><span class="s1">return this</span><span class="s0">.parseBindingList(c.parenR,</span><span class="s2">41</span><span class="s0">).map((e=&gt;(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,ce.UnsupportedSignatureParameterKind,e.type),e)))}tsParseTypeMemberSemicolon(){</span><span class="s1">this</span><span class="s0">.eat(c.comma)||</span><span class="s1">this</span><span class="s0">.semicolon()}tsParseSignatureMember(e,t){</span><span class="s1">return this</span><span class="s0">.tsFillSignature(c.colon,t),</span><span class="s1">this</span><span class="s0">.tsParseTypeMemberSemicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(t,e)}tsIsUnambiguouslyIndexSignature(){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.eat(c.name)&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.colon)}tsTryParseIndexSignature(e){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c.bracketL)||!</span><span class="s1">this</span><span class="s0">.tsLookAhead(</span><span class="s1">this</span><span class="s0">.tsIsUnambiguouslyIndexSignature.bind(</span><span class="s1">this</span><span class="s0">)))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.expect(c.bracketL);const t=</span><span class="s1">this</span><span class="s0">.parseIdentifier();t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.resetEndLocation(t),</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),e.parameters=[t];const r=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();</span><span class="s1">return </span><span class="s0">r&amp;&amp;(e.typeAnnotation=r),</span><span class="s1">this</span><span class="s0">.tsParseTypeMemberSemicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSIndexSignature&quot;</span><span class="s0">)}tsParsePropertyOrMethodSignature(e,t){</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(e.optional=!</span><span class="s2">0</span><span class="s0">);const r=e;</span><span class="s1">if</span><span class="s0">(t||!</span><span class="s1">this</span><span class="s0">.match(c.parenL)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)){const e=r;t&amp;&amp;(e.readonly=!</span><span class="s2">0</span><span class="s0">);const n=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();</span><span class="s1">return </span><span class="s0">n&amp;&amp;(e.typeAnnotation=n),</span><span class="s1">this</span><span class="s0">.tsParseTypeMemberSemicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSPropertySignature&quot;</span><span class="s0">)}{const e=r;</span><span class="s1">return this</span><span class="s0">.tsFillSignature(c.colon,e),</span><span class="s1">this</span><span class="s0">.tsParseTypeMemberSemicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSMethodSignature&quot;</span><span class="s0">)}}tsParseTypeMember(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.tsParseSignatureMember(</span><span class="s3">&quot;TSCallSignatureDeclaration&quot;</span><span class="s0">,e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._new)){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.tsParseSignatureMember(</span><span class="s3">&quot;TSConstructSignatureDeclaration&quot;</span><span class="s0">,e):(e.key=</span><span class="s1">this</span><span class="s0">.createIdentifier(t,</span><span class="s3">&quot;new&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsParsePropertyOrMethodSignature(e,!</span><span class="s2">1</span><span class="s0">))}const t=!!</span><span class="s1">this</span><span class="s0">.tsParseModifier([</span><span class="s3">&quot;readonly&quot;</span><span class="s0">]),r=</span><span class="s1">this</span><span class="s0">.tsTryParseIndexSignature(e);</span><span class="s1">return </span><span class="s0">r?(t&amp;&amp;(e.readonly=!</span><span class="s2">0</span><span class="s0">),r):(</span><span class="s1">this</span><span class="s0">.parsePropertyName(e,!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsParsePropertyOrMethodSignature(e,t))}tsParseTypeLiteral(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.members=</span><span class="s1">this</span><span class="s0">.tsParseObjectTypeMembers(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeLiteral&quot;</span><span class="s0">)}tsParseObjectTypeMembers(){</span><span class="s1">this</span><span class="s0">.expect(c.braceL);const e=</span><span class="s1">this</span><span class="s0">.tsParseList(</span><span class="s3">&quot;TypeMembers&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseTypeMember.bind(</span><span class="s1">this</span><span class="s0">));</span><span class="s1">return this</span><span class="s0">.expect(c.braceR),e}tsIsStartOfMappedType(){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.eat(c.plusMin)?</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;readonly&quot;</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;readonly&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.next(),!!</span><span class="s1">this</span><span class="s0">.match(c.bracketL)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),!!</span><span class="s1">this</span><span class="s0">.tsIsIdentifier()&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c._in))))}tsParseMappedTypeParameter(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.name=</span><span class="s1">this</span><span class="s0">.parseIdentifierName(e.start),e.constraint=</span><span class="s1">this</span><span class="s0">.tsExpectThenParseType(c._in),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeParameter&quot;</span><span class="s0">)}tsParseMappedType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(c.braceL),</span><span class="s1">this</span><span class="s0">.match(c.plusMin)?(e.readonly=</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;readonly&quot;</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;readonly&quot;</span><span class="s0">)&amp;&amp;(e.readonly=!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.bracketL),e.typeParameter=</span><span class="s1">this</span><span class="s0">.tsParseMappedTypeParameter(),e.nameType=</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.tsParseType():</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),</span><span class="s1">this</span><span class="s0">.match(c.plusMin)?(e.optional=</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expect(c.question)):</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(e.optional=!</span><span class="s2">0</span><span class="s0">),e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsTryParseType(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSMappedType&quot;</span><span class="s0">)}tsParseTupleType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();e.elementTypes=</span><span class="s1">this</span><span class="s0">.tsParseBracketedList(</span><span class="s3">&quot;TupleElementTypes&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseTupleElementType.bind(</span><span class="s1">this</span><span class="s0">),!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">);let t=!</span><span class="s2">1</span><span class="s0">,r=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.elementTypes.forEach((e=&gt;{</span><span class="s1">var </span><span class="s0">n;let{type:i}=e;!t||</span><span class="s3">&quot;TSRestType&quot;</span><span class="s0">===i||</span><span class="s3">&quot;TSOptionalType&quot;</span><span class="s0">===i||</span><span class="s3">&quot;TSNamedTupleMember&quot;</span><span class="s0">===i&amp;&amp;e.optional||</span><span class="s1">this</span><span class="s0">.raise(e.start,ce.OptionalTypeBeforeRequired),t=t||</span><span class="s3">&quot;TSNamedTupleMember&quot;</span><span class="s0">===i&amp;&amp;e.optional||</span><span class="s3">&quot;TSOptionalType&quot;</span><span class="s0">===i,</span><span class="s3">&quot;TSRestType&quot;</span><span class="s0">===i&amp;&amp;(i=(e=e.typeAnnotation).type);const s=</span><span class="s3">&quot;TSNamedTupleMember&quot;</span><span class="s0">===i;r=</span><span class="s1">null</span><span class="s0">!=(n=r)?n:s,r!==s&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,ce.MixedLabeledAndUnlabeledElements)})),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTupleType&quot;</span><span class="s0">)}tsParseTupleElementType(){const{start:e,startLoc:t}=</span><span class="s1">this</span><span class="s0">.state,r=</span><span class="s1">this</span><span class="s0">.eat(c.ellipsis);let n=</span><span class="s1">this</span><span class="s0">.tsParseType();const i=</span><span class="s1">this</span><span class="s0">.eat(c.question);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.colon)){const e=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(n);e.optional=i,</span><span class="s3">&quot;TSTypeReference&quot;</span><span class="s0">!==n.type||n.typeParameters||</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==n.typeName.type?(</span><span class="s1">this</span><span class="s0">.raise(n.start,ce.InvalidTupleMemberLabel),e.label=n):e.label=n.typeName,e.elementType=</span><span class="s1">this</span><span class="s0">.tsParseType(),n=</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSNamedTupleMember&quot;</span><span class="s0">)}</span><span class="s1">else if</span><span class="s0">(i){const e=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(n);e.typeAnnotation=n,n=</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSOptionalType&quot;</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(r){const r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);r.typeAnnotation=n,n=</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;TSRestType&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">n}tsParseParenthesizedType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(c.parenL),e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseType(),</span><span class="s1">this</span><span class="s0">.expect(c.parenR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSParenthesizedType&quot;</span><span class="s0">)}tsParseFunctionOrConstructorType(e){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return</span><span class="s3">&quot;TSConstructorType&quot;</span><span class="s0">===e&amp;&amp;</span><span class="s1">this</span><span class="s0">.expect(c._new),</span><span class="s1">this</span><span class="s0">.tsFillSignature(c.arrow,t),</span><span class="s1">this</span><span class="s0">.finishNode(t,e)}tsParseLiteralTypeNode(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.literal=(()=&gt;{</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c.num:</span><span class="s1">case </span><span class="s0">c.bigint:</span><span class="s1">case </span><span class="s0">c.string:</span><span class="s1">case </span><span class="s0">c._true:</span><span class="s1">case </span><span class="s0">c._false:</span><span class="s1">return this</span><span class="s0">.parseExprAtom();</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw this</span><span class="s0">.unexpected()}})(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSLiteralType&quot;</span><span class="s0">)}tsParseTemplateLiteralType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.literal=</span><span class="s1">this</span><span class="s0">.parseTemplate(!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSLiteralType&quot;</span><span class="s0">)}parseTemplateSubstitution(){</span><span class="s1">return this</span><span class="s0">.state.inType?</span><span class="s1">this</span><span class="s0">.tsParseType():super.parseTemplateSubstitution()}tsParseThisTypeOrThisTypePredicate(){const e=</span><span class="s1">this</span><span class="s0">.tsParseThisTypeNode();</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;is&quot;</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()?</span><span class="s1">this</span><span class="s0">.tsParseThisTypePredicate(e):e}tsParseNonArrayType(){</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c.name:</span><span class="s1">case </span><span class="s0">c._void:</span><span class="s1">case </span><span class="s0">c._null:{const e=</span><span class="s1">this</span><span class="s0">.match(c._void)?</span><span class="s3">&quot;TSVoidKeyword&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.match(c._null)?</span><span class="s3">&quot;TSNullKeyword&quot;</span><span class="s0">:</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">switch</span><span class="s0">(e){</span><span class="s1">case</span><span class="s3">&quot;any&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSAnyKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;boolean&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSBooleanKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;bigint&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSBigIntKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;never&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSNeverKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;number&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSNumberKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;object&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSObjectKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;string&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSStringKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;symbol&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSSymbolKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;undefined&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSUndefinedKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;unknown&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;TSUnknownKeyword&quot;</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">}}(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">!==e&amp;&amp;</span><span class="s2">46</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(t,e)}</span><span class="s1">return this</span><span class="s0">.tsParseTypeReference()}</span><span class="s1">case </span><span class="s0">c.string:</span><span class="s1">case </span><span class="s0">c.num:</span><span class="s1">case </span><span class="s0">c.bigint:</span><span class="s1">case </span><span class="s0">c._true:</span><span class="s1">case </span><span class="s0">c._false:</span><span class="s1">return this</span><span class="s0">.tsParseLiteralTypeNode();</span><span class="s1">case </span><span class="s0">c.plusMin:</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;-&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value){const e=</span><span class="s1">this</span><span class="s0">.startNode(),t=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s1">if</span><span class="s0">(t.type!==c.num&amp;&amp;t.type!==c.bigint)</span><span class="s1">throw this</span><span class="s0">.unexpected();</span><span class="s1">return </span><span class="s0">e.literal=</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSLiteralType&quot;</span><span class="s0">)}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">c._this:</span><span class="s1">return this</span><span class="s0">.tsParseThisTypeOrThisTypePredicate();</span><span class="s1">case </span><span class="s0">c._typeof:</span><span class="s1">return this</span><span class="s0">.tsParseTypeQuery();</span><span class="s1">case </span><span class="s0">c._import:</span><span class="s1">return this</span><span class="s0">.tsParseImportType();</span><span class="s1">case </span><span class="s0">c.braceL:</span><span class="s1">return this</span><span class="s0">.tsLookAhead(</span><span class="s1">this</span><span class="s0">.tsIsStartOfMappedType.bind(</span><span class="s1">this</span><span class="s0">))?</span><span class="s1">this</span><span class="s0">.tsParseMappedType():</span><span class="s1">this</span><span class="s0">.tsParseTypeLiteral();</span><span class="s1">case </span><span class="s0">c.bracketL:</span><span class="s1">return this</span><span class="s0">.tsParseTupleType();</span><span class="s1">case </span><span class="s0">c.parenL:</span><span class="s1">return this</span><span class="s0">.tsParseParenthesizedType();</span><span class="s1">case </span><span class="s0">c.backQuote:</span><span class="s1">return this</span><span class="s0">.tsParseTemplateLiteralType()}</span><span class="s1">throw this</span><span class="s0">.unexpected()}tsParseArrayTypeOrHigher(){let e=</span><span class="s1">this</span><span class="s0">.tsParseNonArrayType();</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.bracketL);)</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.bracketR)){const t=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e);t.elementType=e,</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),e=</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSArrayType&quot;</span><span class="s0">)}</span><span class="s1">else</span><span class="s0">{const t=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e);t.objectType=e,t.indexType=</span><span class="s1">this</span><span class="s0">.tsParseType(),</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),e=</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSIndexedAccessType&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}tsParseTypeOperator(e){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expectContextual(e),t.operator=e,t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseTypeOperatorOrHigher(),</span><span class="s3">&quot;readonly&quot;</span><span class="s0">===e&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsCheckTypeAnnotationForReadOnly(t),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSTypeOperator&quot;</span><span class="s0">)}tsCheckTypeAnnotationForReadOnly(e){</span><span class="s1">switch</span><span class="s0">(e.typeAnnotation.type){</span><span class="s1">case</span><span class="s3">&quot;TSTupleType&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TSArrayType&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.raise(e.start,ce.UnexpectedReadonly)}}tsParseInferType(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;infer&quot;</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">t.name=</span><span class="s1">this</span><span class="s0">.parseIdentifierName(t.start),e.typeParameter=</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSTypeParameter&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSInferType&quot;</span><span class="s0">)}tsParseTypeOperatorOrHigher(){const e=[</span><span class="s3">&quot;keyof&quot;</span><span class="s0">,</span><span class="s3">&quot;unique&quot;</span><span class="s0">,</span><span class="s3">&quot;readonly&quot;</span><span class="s0">].find((e=&gt;</span><span class="s1">this</span><span class="s0">.isContextual(e)));</span><span class="s1">return </span><span class="s0">e?</span><span class="s1">this</span><span class="s0">.tsParseTypeOperator(e):</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;infer&quot;</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.tsParseInferType():</span><span class="s1">this</span><span class="s0">.tsParseArrayTypeOrHigher()}tsParseUnionOrIntersectionType(e,t,r){</span><span class="s1">this</span><span class="s0">.eat(r);let n=t();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(r)){const i=[n];</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.eat(r);)i.push(t());const s=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(n);s.types=i,n=</span><span class="s1">this</span><span class="s0">.finishNode(s,e)}</span><span class="s1">return </span><span class="s0">n}tsParseIntersectionTypeOrHigher(){</span><span class="s1">return this</span><span class="s0">.tsParseUnionOrIntersectionType(</span><span class="s3">&quot;TSIntersectionType&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseTypeOperatorOrHigher.bind(</span><span class="s1">this</span><span class="s0">),c.bitwiseAND)}tsParseUnionTypeOrHigher(){</span><span class="s1">return this</span><span class="s0">.tsParseUnionOrIntersectionType(</span><span class="s3">&quot;TSUnionType&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseIntersectionTypeOrHigher.bind(</span><span class="s1">this</span><span class="s0">),c.bitwiseOR)}tsIsStartOfFunctionType(){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(c.parenL)&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsLookAhead(</span><span class="s1">this</span><span class="s0">.tsIsUnambiguouslyStartOfFunctionType.bind(</span><span class="s1">this</span><span class="s0">))}tsSkipParameterStart(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.name)||</span><span class="s1">this</span><span class="s0">.match(c._this))</span><span class="s1">return this</span><span class="s0">.next(),!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.braceL)){let e=</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next();e&gt;</span><span class="s2">0</span><span class="s0">;)</span><span class="s1">this</span><span class="s0">.match(c.braceL)?++e:</span><span class="s1">this</span><span class="s0">.match(c.braceR)&amp;&amp;--e,</span><span class="s1">this</span><span class="s0">.next();</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.bracketL)){let e=</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next();e&gt;</span><span class="s2">0</span><span class="s0">;)</span><span class="s1">this</span><span class="s0">.match(c.bracketL)?++e:</span><span class="s1">this</span><span class="s0">.match(c.bracketR)&amp;&amp;--e,</span><span class="s1">this</span><span class="s0">.next();</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}tsIsUnambiguouslyStartOfFunctionType(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.parenR)||</span><span class="s1">this</span><span class="s0">.match(c.ellipsis))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsSkipParameterStart()){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.colon)||</span><span class="s1">this</span><span class="s0">.match(c.comma)||</span><span class="s1">this</span><span class="s0">.match(c.question)||</span><span class="s1">this</span><span class="s0">.match(c.eq))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.parenR)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.arrow)))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}tsParseTypeOrTypePredicateAnnotation(e){</span><span class="s1">return this</span><span class="s0">.tsInType((()=&gt;{const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.expect(e);const r=!!</span><span class="s1">this</span><span class="s0">.tsTryParse(</span><span class="s1">this</span><span class="s0">.tsParseTypePredicateAsserts.bind(</span><span class="s1">this</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(r&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c._this)){let e=</span><span class="s1">this</span><span class="s0">.tsParseThisTypeOrThisTypePredicate();</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;TSThisType&quot;</span><span class="s0">===e.type){const r=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(t);r.parameterName=e,r.asserts=!</span><span class="s2">0</span><span class="s0">,e=</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;TSTypePredicate&quot;</span><span class="s0">)}</span><span class="s1">else </span><span class="s0">e.asserts=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">return </span><span class="s0">t.typeAnnotation=e,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">)}const n=</span><span class="s1">this</span><span class="s0">.tsIsIdentifier()&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsTryParse(</span><span class="s1">this</span><span class="s0">.tsParseTypePredicatePrefix.bind(</span><span class="s1">this</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(!n){</span><span class="s1">if</span><span class="s0">(!r)</span><span class="s1">return this</span><span class="s0">.tsParseTypeAnnotation(!</span><span class="s2">1</span><span class="s0">,t);const e=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(t);</span><span class="s1">return </span><span class="s0">e.parameterName=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),e.asserts=r,t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypePredicate&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">)}const i=</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation(!</span><span class="s2">1</span><span class="s0">),s=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(t);</span><span class="s1">return </span><span class="s0">s.parameterName=n,s.typeAnnotation=i,s.asserts=r,t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s3">&quot;TSTypePredicate&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">)}))}tsTryParseTypeOrTypePredicateAnnotation(){</span><span class="s1">return this</span><span class="s0">.match(c.colon)?</span><span class="s1">this</span><span class="s0">.tsParseTypeOrTypePredicateAnnotation(c.colon):</span><span class="s1">void </span><span class="s2">0</span><span class="s0">}tsTryParseTypeAnnotation(){</span><span class="s1">return this</span><span class="s0">.match(c.colon)?</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation():</span><span class="s1">void </span><span class="s2">0</span><span class="s0">}tsTryParseType(){</span><span class="s1">return this</span><span class="s0">.tsEatThenParseType(c.colon)}tsParseTypePredicatePrefix(){const e=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;is&quot;</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak())</span><span class="s1">return this</span><span class="s0">.next(),e}tsParseTypePredicateAsserts(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c.name)||</span><span class="s3">&quot;asserts&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.state.value||</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak())</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const e=</span><span class="s1">this</span><span class="s0">.state.containsEsc;</span><span class="s1">return this</span><span class="s0">.next(),!(!</span><span class="s1">this</span><span class="s0">.match(c.name)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c._this)||(e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,x.InvalidEscapedReservedWord,</span><span class="s3">&quot;asserts&quot;</span><span class="s0">),</span><span class="s2">0</span><span class="s0">))}tsParseTypeAnnotation(e=!</span><span class="s2">0</span><span class="s0">,t=</span><span class="s1">this</span><span class="s0">.startNode()){</span><span class="s1">return this</span><span class="s0">.tsInType((()=&gt;{e&amp;&amp;</span><span class="s1">this</span><span class="s0">.expect(c.colon),t.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseType()})),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s0">)}tsParseType(){pe(</span><span class="s1">this</span><span class="s0">.state.inType);const e=</span><span class="s1">this</span><span class="s0">.tsParseNonConditionalType();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()||!</span><span class="s1">this</span><span class="s0">.eat(c._extends))</span><span class="s1">return </span><span class="s0">e;const t=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e);</span><span class="s1">return </span><span class="s0">t.checkType=e,t.extendsType=</span><span class="s1">this</span><span class="s0">.tsParseNonConditionalType(),</span><span class="s1">this</span><span class="s0">.expect(c.question),t.trueType=</span><span class="s1">this</span><span class="s0">.tsParseType(),</span><span class="s1">this</span><span class="s0">.expect(c.colon),t.falseType=</span><span class="s1">this</span><span class="s0">.tsParseType(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSConditionalType&quot;</span><span class="s0">)}tsParseNonConditionalType(){</span><span class="s1">return this</span><span class="s0">.tsIsStartOfFunctionType()?</span><span class="s1">this</span><span class="s0">.tsParseFunctionOrConstructorType(</span><span class="s3">&quot;TSFunctionType&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.match(c._new)?</span><span class="s1">this</span><span class="s0">.tsParseFunctionOrConstructorType(</span><span class="s3">&quot;TSConstructorType&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.tsParseUnionTypeOrHigher()}tsParseTypeAssertion(){const e=</span><span class="s1">this</span><span class="s0">.startNode(),t=</span><span class="s1">this</span><span class="s0">.tsTryNextParseConstantContext();</span><span class="s1">return </span><span class="s0">e.typeAnnotation=t||</span><span class="s1">this</span><span class="s0">.tsNextThenParseType(),</span><span class="s1">this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">),e.expression=</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeAssertion&quot;</span><span class="s0">)}tsParseHeritageClause(e){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.tsParseDelimitedList(</span><span class="s3">&quot;HeritageClauseElement&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseExpressionWithTypeArguments.bind(</span><span class="s1">this</span><span class="s0">));</span><span class="s1">return </span><span class="s0">r.length||</span><span class="s1">this</span><span class="s0">.raise(t,ce.EmptyHeritageClauseType,e),r}tsParseExpressionWithTypeArguments(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.expression=</span><span class="s1">this</span><span class="s0">.tsParseEntityName(!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSExpressionWithTypeArguments&quot;</span><span class="s0">)}tsParseInterfaceDeclaration(e){e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,</span><span class="s2">130</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s3">&quot;typescript interface declaration&quot;</span><span class="s0">),e.typeParameters=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters(),</span><span class="s1">this</span><span class="s0">.eat(c._extends)&amp;&amp;(e.extends=</span><span class="s1">this</span><span class="s0">.tsParseHeritageClause(</span><span class="s3">&quot;extends&quot;</span><span class="s0">));const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">t.body=</span><span class="s1">this</span><span class="s0">.tsInType(</span><span class="s1">this</span><span class="s0">.tsParseObjectTypeMembers.bind(</span><span class="s1">this</span><span class="s0">)),e.body=</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSInterfaceBody&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSInterfaceDeclaration&quot;</span><span class="s0">)}tsParseTypeAliasDeclaration(e){</span><span class="s1">return </span><span class="s0">e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,</span><span class="s2">2</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s3">&quot;typescript type alias&quot;</span><span class="s0">),e.typeParameters=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters(),e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsInType((()=&gt;{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.eq),</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;intrinsic&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookahead().type!==c.dot){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSIntrinsicKeyword&quot;</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.tsParseType()})),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeAliasDeclaration&quot;</span><span class="s0">)}tsInNoContext(e){const t=</span><span class="s1">this</span><span class="s0">.state.context;</span><span class="s1">this</span><span class="s0">.state.context=[t[</span><span class="s2">0</span><span class="s0">]];</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.context=t}}tsInType(e){const t=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.inType=t}}tsEatThenParseType(e){</span><span class="s1">return this</span><span class="s0">.match(e)?</span><span class="s1">this</span><span class="s0">.tsNextThenParseType():</span><span class="s1">void </span><span class="s2">0</span><span class="s0">}tsExpectThenParseType(e){</span><span class="s1">return this</span><span class="s0">.tsDoThenParseType((()=&gt;</span><span class="s1">this</span><span class="s0">.expect(e)))}tsNextThenParseType(){</span><span class="s1">return this</span><span class="s0">.tsDoThenParseType((()=&gt;</span><span class="s1">this</span><span class="s0">.next()))}tsDoThenParseType(e){</span><span class="s1">return this</span><span class="s0">.tsInType((()=&gt;(e(),</span><span class="s1">this</span><span class="s0">.tsParseType())))}tsParseEnumMember(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.id=</span><span class="s1">this</span><span class="s0">.match(c.string)?</span><span class="s1">this</span><span class="s0">.parseExprAtom():</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.eat(c.eq)&amp;&amp;(e.initializer=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSEnumMember&quot;</span><span class="s0">)}tsParseEnumDeclaration(e,t){</span><span class="s1">return </span><span class="s0">t&amp;&amp;(e.const=!</span><span class="s2">0</span><span class="s0">),e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,t?</span><span class="s2">779</span><span class="s0">:</span><span class="s2">267</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s3">&quot;typescript enum declaration&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.braceL),e.members=</span><span class="s1">this</span><span class="s0">.tsParseDelimitedList(</span><span class="s3">&quot;EnumMembers&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseEnumMember.bind(</span><span class="s1">this</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSEnumDeclaration&quot;</span><span class="s0">)}tsParseModuleBlock(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.scope.enter(</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.braceL),</span><span class="s1">this</span><span class="s0">.parseBlockOrModuleBlockBody(e.body=[],</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">,c.braceR),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSModuleBlock&quot;</span><span class="s0">)}tsParseModuleOrNamespaceDeclaration(e,t=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),t||</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,</span><span class="s2">1024</span><span class="s0">,</span><span class="s1">null</span><span class="s0">,</span><span class="s3">&quot;module or namespace declaration&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.eat(c.dot)){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.tsParseModuleOrNamespaceDeclaration(t,!</span><span class="s2">0</span><span class="s0">),e.body=t}</span><span class="s1">else this</span><span class="s0">.scope.enter(</span><span class="s2">128</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.enter(</span><span class="s2">0</span><span class="s0">),e.body=</span><span class="s1">this</span><span class="s0">.tsParseModuleBlock(),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit();</span><span class="s1">return this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSModuleDeclaration&quot;</span><span class="s0">)}tsParseAmbientExternalModuleDeclaration(e){</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;global&quot;</span><span class="s0">)?(e.global=!</span><span class="s2">0</span><span class="s0">,e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier()):</span><span class="s1">this</span><span class="s0">.match(c.string)?e.id=</span><span class="s1">this</span><span class="s0">.parseExprAtom():</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.match(c.braceL)?(</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">128</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.enter(</span><span class="s2">0</span><span class="s0">),e.body=</span><span class="s1">this</span><span class="s0">.tsParseModuleBlock(),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit()):</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSModuleDeclaration&quot;</span><span class="s0">)}tsParseImportEqualsDeclaration(e,t){</span><span class="s1">return </span><span class="s0">e.isExport=t||!</span><span class="s2">1</span><span class="s0">,e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,</span><span class="s2">9</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s3">&quot;import equals declaration&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.eq),e.moduleReference=</span><span class="s1">this</span><span class="s0">.tsParseModuleReference(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSImportEqualsDeclaration&quot;</span><span class="s0">)}tsIsExternalModuleReference(){</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;require&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">40</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()}tsParseModuleReference(){</span><span class="s1">return this</span><span class="s0">.tsIsExternalModuleReference()?</span><span class="s1">this</span><span class="s0">.tsParseExternalModuleReference():</span><span class="s1">this</span><span class="s0">.tsParseEntityName(!</span><span class="s2">1</span><span class="s0">)}tsParseExternalModuleReference(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;require&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.parenL),!</span><span class="s1">this</span><span class="s0">.match(c.string))</span><span class="s1">throw this</span><span class="s0">.unexpected();</span><span class="s1">return </span><span class="s0">e.expression=</span><span class="s1">this</span><span class="s0">.parseExprAtom(),</span><span class="s1">this</span><span class="s0">.expect(c.parenR),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSExternalModuleReference&quot;</span><span class="s0">)}tsLookAhead(e){const t=</span><span class="s1">this</span><span class="s0">.state.clone(),r=e();</span><span class="s1">return this</span><span class="s0">.state=t,r}tsTryParseAndCatch(e){const t=</span><span class="s1">this</span><span class="s0">.tryParse((t=&gt;e()||t()));</span><span class="s1">if</span><span class="s0">(!t.aborted&amp;&amp;t.node)</span><span class="s1">return </span><span class="s0">t.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=t.failState),t.node}tsTryParse(e){const t=</span><span class="s1">this</span><span class="s0">.state.clone(),r=e();</span><span class="s1">return void </span><span class="s2">0</span><span class="s0">!==r&amp;&amp;!</span><span class="s2">1</span><span class="s0">!==r?r:</span><span class="s1">void</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state=t)}tsTryParseDeclare(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isLineTerminator())</span><span class="s1">return</span><span class="s0">;let t,r=</span><span class="s1">this</span><span class="s0">.state.type;</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;let&quot;</span><span class="s0">)&amp;&amp;(r=c._var,t=</span><span class="s3">&quot;let&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsInDeclareContext((()=&gt;{</span><span class="s1">switch</span><span class="s0">(r){</span><span class="s1">case </span><span class="s0">c._function:</span><span class="s1">return </span><span class="s0">e.declare=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseFunctionStatement(e,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._class:</span><span class="s1">return </span><span class="s0">e.declare=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseClass(e,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._const:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._const)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isLookaheadContextual(</span><span class="s3">&quot;enum&quot;</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.expect(c._const),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;enum&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsParseEnumDeclaration(e,!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._var:</span><span class="s1">return </span><span class="s0">t=t||</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.parseVarStatement(e,t);</span><span class="s1">case </span><span class="s0">c.name:{const t=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">return</span><span class="s3">&quot;global&quot;</span><span class="s0">===t?</span><span class="s1">this</span><span class="s0">.tsParseAmbientExternalModuleDeclaration(e):</span><span class="s1">this</span><span class="s0">.tsParseDeclaration(e,t,!</span><span class="s2">0</span><span class="s0">)}}}))}tsTryParseExportDeclaration(){</span><span class="s1">return this</span><span class="s0">.tsParseDeclaration(</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.state.value,!</span><span class="s2">0</span><span class="s0">)}tsParseExpressionStatement(e,t){</span><span class="s1">switch</span><span class="s0">(t.name){</span><span class="s1">case</span><span class="s3">&quot;declare&quot;</span><span class="s0">:{const t=</span><span class="s1">this</span><span class="s0">.tsTryParseDeclare(e);</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return </span><span class="s0">t.declare=!</span><span class="s2">0</span><span class="s0">,t;</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case</span><span class="s3">&quot;global&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.braceL)){</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">128</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.enter(</span><span class="s2">0</span><span class="s0">);const r=e;</span><span class="s1">return </span><span class="s0">r.global=!</span><span class="s2">0</span><span class="s0">,r.id=t,r.body=</span><span class="s1">this</span><span class="s0">.tsParseModuleBlock(),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;TSModuleDeclaration&quot;</span><span class="s0">)}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.tsParseDeclaration(e,t.name,!</span><span class="s2">1</span><span class="s0">)}}tsParseDeclaration(e,t,r){</span><span class="s1">switch</span><span class="s0">(t){</span><span class="s1">case</span><span class="s3">&quot;abstract&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsCheckLineTerminatorAndMatch(c._class,r)){const t=e;</span><span class="s1">return </span><span class="s0">t.abstract=!</span><span class="s2">0</span><span class="s0">,r&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c._class)||</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,c._class)),</span><span class="s1">this</span><span class="s0">.parseClass(t,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">)}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;enum&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(r||</span><span class="s1">this</span><span class="s0">.match(c.name))</span><span class="s1">return </span><span class="s0">r&amp;&amp;</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.tsParseEnumDeclaration(e,!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;interface&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsCheckLineTerminatorAndMatch(c.name,r))</span><span class="s1">return </span><span class="s0">r&amp;&amp;</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.tsParseInterfaceDeclaration(e);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;module&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(r&amp;&amp;</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.string))</span><span class="s1">return this</span><span class="s0">.tsParseAmbientExternalModuleDeclaration(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsCheckLineTerminatorAndMatch(c.name,r))</span><span class="s1">return this</span><span class="s0">.tsParseModuleOrNamespaceDeclaration(e);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;namespace&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsCheckLineTerminatorAndMatch(c.name,r))</span><span class="s1">return </span><span class="s0">r&amp;&amp;</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.tsParseModuleOrNamespaceDeclaration(e);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;type&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsCheckLineTerminatorAndMatch(c.name,r))</span><span class="s1">return </span><span class="s0">r&amp;&amp;</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.tsParseTypeAliasDeclaration(e)}}tsCheckLineTerminatorAndMatch(e,t){</span><span class="s1">return</span><span class="s0">(t||</span><span class="s1">this</span><span class="s0">.match(e))&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isLineTerminator()}tsTryParseGenericAsyncArrowFunction(e,t){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">))</span><span class="s1">return</span><span class="s0">;const r=</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters;</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s2">0</span><span class="s0">;const n=</span><span class="s1">this</span><span class="s0">.tsTryParseAndCatch((()=&gt;{const r=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);</span><span class="s1">return </span><span class="s0">r.typeParameters=</span><span class="s1">this</span><span class="s0">.tsParseTypeParameters(),super.parseFunctionParams(r),r.returnType=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeOrTypePredicateAnnotation(),</span><span class="s1">this</span><span class="s0">.expect(c.arrow),r}));</span><span class="s1">return this</span><span class="s0">.state.maybeInArrowParameters=r,n?</span><span class="s1">this</span><span class="s0">.parseArrowExpression(n,</span><span class="s1">null</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">):</span><span class="s1">void </span><span class="s2">0</span><span class="s0">}tsParseTypeArguments(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.params=</span><span class="s1">this</span><span class="s0">.tsInType((()=&gt;</span><span class="s1">this</span><span class="s0">.tsInNoContext((()=&gt;(</span><span class="s1">this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsParseDelimitedList(</span><span class="s3">&quot;TypeParametersOrArguments&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseType.bind(</span><span class="s1">this</span><span class="s0">))))))),</span><span class="s2">0</span><span class="s0">===e.params.length&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,ce.EmptyTypeArguments),</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expectRelational(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">)}tsIsDeclarationStart(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.name))</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.value){</span><span class="s1">case</span><span class="s3">&quot;abstract&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;declare&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;enum&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;interface&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;module&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;namespace&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;type&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}isExportDefaultSpecifier(){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.tsIsDeclarationStart()&amp;&amp;super.isExportDefaultSpecifier()}parseAssignableListItem(e,t){const r=</span><span class="s1">this</span><span class="s0">.state.start,n=</span><span class="s1">this</span><span class="s0">.state.startLoc;let i,s=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">void </span><span class="s2">0</span><span class="s0">!==e&amp;&amp;(i=</span><span class="s1">this</span><span class="s0">.parseAccessModifier(),s=!!</span><span class="s1">this</span><span class="s0">.tsParseModifier([</span><span class="s3">&quot;readonly&quot;</span><span class="s0">]),!</span><span class="s2">1</span><span class="s0">===e&amp;&amp;(i||s)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r,ce.UnexpectedParameterModifier));const a=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault();</span><span class="s1">this</span><span class="s0">.parseAssignableListItemTypes(a);const o=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault(a.start,a.loc.start,a);</span><span class="s1">if</span><span class="s0">(i||s){const e=</span><span class="s1">this</span><span class="s0">.startNodeAt(r,n);</span><span class="s1">return </span><span class="s0">t.length&amp;&amp;(e.decorators=t),i&amp;&amp;(e.accessibility=i),s&amp;&amp;(e.readonly=s),</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==o.type&amp;&amp;</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">!==o.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,ce.UnsupportedParameterPropertyKind),e.parameter=o,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TSParameterProperty&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">t.length&amp;&amp;(a.decorators=t),o}parseFunctionBodyAndFinish(e,t,r=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.match(c.colon)&amp;&amp;(e.returnType=</span><span class="s1">this</span><span class="s0">.tsParseTypeOrTypePredicateAnnotation(c.colon));const n=</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">===t?</span><span class="s3">&quot;TSDeclareFunction&quot;</span><span class="s0">:</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">===t?</span><span class="s3">&quot;TSDeclareMethod&quot;</span><span class="s0">:</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;n&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.braceL)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isLineTerminator()?</span><span class="s1">this</span><span class="s0">.finishNode(e,n):</span><span class="s3">&quot;TSDeclareFunction&quot;</span><span class="s0">===n&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.isDeclareContext&amp;&amp;(</span><span class="s1">this</span><span class="s0">.raise(e.start,ce.DeclareFunctionHasImplementation),e.declare)?super.parseFunctionBodyAndFinish(e,n,r):super.parseFunctionBodyAndFinish(e,t,r)}registerFunctionStatementId(e){!e.body&amp;&amp;e.id?</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,</span><span class="s2">1024</span><span class="s0">,</span><span class="s1">null</span><span class="s0">,</span><span class="s3">&quot;function name&quot;</span><span class="s0">):super.registerFunctionStatementId(...arguments)}tsCheckForInvalidTypeCasts(e){e.forEach((e=&gt;{</span><span class="s3">&quot;TSTypeCastExpression&quot;</span><span class="s0">===(</span><span class="s1">null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:e.type)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.typeAnnotation.start,ce.UnexpectedTypeAnnotation)}))}toReferencedList(e,t){</span><span class="s1">return this</span><span class="s0">.tsCheckForInvalidTypeCasts(e),e}parseArrayLike(...e){const t=super.parseArrayLike(...e);</span><span class="s1">return</span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s0">===t.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsCheckForInvalidTypeCasts(t.elements),t}parseSubscript(e,t,r,n,i){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.bang)){</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next();const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">n.expression=e,</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;TSNonNullExpression&quot;</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)){const s=</span><span class="s1">this</span><span class="s0">.tsTryParseAndCatch((()=&gt;{</span><span class="s1">if</span><span class="s0">(!n&amp;&amp;</span><span class="s1">this</span><span class="s0">.atPossibleAsyncArrow(e)){const e=</span><span class="s1">this</span><span class="s0">.tsTryParseGenericAsyncArrowFunction(t,r);</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">return </span><span class="s0">e}const s=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);s.callee=e;const a=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments();</span><span class="s1">if</span><span class="s0">(a){</span><span class="s1">if</span><span class="s0">(!n&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.parenL))</span><span class="s1">return </span><span class="s0">s.arguments=</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(c.parenR,!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsCheckForInvalidTypeCasts(s.arguments),s.typeParameters=a,</span><span class="s1">this</span><span class="s0">.finishCallExpression(s,i.optionalChainMember);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.backQuote)){const n=</span><span class="s1">this</span><span class="s0">.parseTaggedTemplateExpression(e,t,r,i);</span><span class="s1">return </span><span class="s0">n.typeParameters=a,n}}</span><span class="s1">this</span><span class="s0">.unexpected()}));</span><span class="s1">if</span><span class="s0">(s)</span><span class="s1">return </span><span class="s0">s}</span><span class="s1">return </span><span class="s0">super.parseSubscript(e,t,r,n,i)}parseNewArguments(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)){const t=</span><span class="s1">this</span><span class="s0">.tsTryParseAndCatch((()=&gt;{const e=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments();</span><span class="s1">return this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.unexpected(),e}));t&amp;&amp;(e.typeParameters=t)}super.parseNewArguments(e)}parseExprOp(e,t,r,n){</span><span class="s1">if</span><span class="s0">(le(c._in.binop)&gt;n&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">)){const i=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);i.expression=e;const s=</span><span class="s1">this</span><span class="s0">.tsTryNextParseConstantContext();</span><span class="s1">return </span><span class="s0">i.typeAnnotation=s||</span><span class="s1">this</span><span class="s0">.tsNextThenParseType(),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s3">&quot;TSAsExpression&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.reScan_lt_gt(),</span><span class="s1">this</span><span class="s0">.parseExprOp(i,t,r,n)}</span><span class="s1">return </span><span class="s0">super.parseExprOp(e,t,r,n)}checkReservedWord(e,t,r,n){}checkDuplicateExports(){}parseImport(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.name)||</span><span class="s1">this</span><span class="s0">.match(c.star)||</span><span class="s1">this</span><span class="s0">.match(c.braceL)){const t=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.name)&amp;&amp;t.type===c.eq)</span><span class="s1">return this</span><span class="s0">.tsParseImportEqualsDeclaration(e);!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)||t.type===c.comma||t.type===c.name&amp;&amp;</span><span class="s3">&quot;from&quot;</span><span class="s0">===t.value||(e.importKind=</span><span class="s3">&quot;type&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next())}e.importKind||(e.importKind=</span><span class="s3">&quot;value&quot;</span><span class="s0">);const t=super.parseImport(e);</span><span class="s1">return</span><span class="s3">&quot;type&quot;</span><span class="s0">===t.importKind&amp;&amp;t.specifiers.length&gt;</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">===t.specifiers[</span><span class="s2">0</span><span class="s0">].type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,</span><span class="s3">&quot;A type-only import can specify a default import or named bindings, but not both.&quot;</span><span class="s0">),t}parseExport(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._import))</span><span class="s1">return this</span><span class="s0">.expect(c._import),</span><span class="s1">this</span><span class="s0">.tsParseImportEqualsDeclaration(e,!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.eq)){const t=e;</span><span class="s1">return </span><span class="s0">t.expression=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSExportAssignment&quot;</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">)){const t=e;</span><span class="s1">return this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;namespace&quot;</span><span class="s0">),t.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TSNamespaceExportDeclaration&quot;</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;type&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookahead().type===c.braceL?(</span><span class="s1">this</span><span class="s0">.next(),e.exportKind=</span><span class="s3">&quot;type&quot;</span><span class="s0">):e.exportKind=</span><span class="s3">&quot;value&quot;</span><span class="s0">,super.parseExport(e)}isAbstractClass(){</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">&quot;abstract&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookahead().type===c._class}parseExportDefaultExpression(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isAbstractClass()){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseClass(e,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),e.abstract=!</span><span class="s2">0</span><span class="s0">,e}</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;interface&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value){const e=</span><span class="s1">this</span><span class="s0">.tsParseDeclaration(</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.state.value,!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">return </span><span class="s0">super.parseExportDefaultExpression()}parseStatementContent(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type===c._const){const e=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s1">if</span><span class="s0">(e.type===c.name&amp;&amp;</span><span class="s3">&quot;enum&quot;</span><span class="s0">===e.value){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(c._const),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;enum&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsParseEnumDeclaration(e,!</span><span class="s2">0</span><span class="s0">)}}</span><span class="s1">return </span><span class="s0">super.parseStatementContent(e,t)}parseAccessModifier(){</span><span class="s1">return this</span><span class="s0">.tsParseModifier([</span><span class="s3">&quot;public&quot;</span><span class="s0">,</span><span class="s3">&quot;protected&quot;</span><span class="s0">,</span><span class="s3">&quot;private&quot;</span><span class="s0">])}parseClassMember(e,t,r){</span><span class="s1">this</span><span class="s0">.tsParseModifiers(t,[</span><span class="s3">&quot;declare&quot;</span><span class="s0">]);const n=</span><span class="s1">this</span><span class="s0">.parseAccessModifier();n&amp;&amp;(t.accessibility=n),</span><span class="s1">this</span><span class="s0">.tsParseModifiers(t,[</span><span class="s3">&quot;declare&quot;</span><span class="s0">]);const i=()=&gt;{super.parseClassMember(e,t,r)};t.declare?</span><span class="s1">this</span><span class="s0">.tsInDeclareContext(i):i()}parseClassMemberWithIsStatic(e,t,r,n){</span><span class="s1">this</span><span class="s0">.tsParseModifiers(t,[</span><span class="s3">&quot;abstract&quot;</span><span class="s0">,</span><span class="s3">&quot;readonly&quot;</span><span class="s0">,</span><span class="s3">&quot;declare&quot;</span><span class="s0">]);const i=</span><span class="s1">this</span><span class="s0">.tsTryParseIndexSignature(t);</span><span class="s1">if</span><span class="s0">(i)</span><span class="s1">return </span><span class="s0">e.body.push(i),t.abstract&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,ce.IndexSignatureHasAbstract),n&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,ce.IndexSignatureHasStatic),t.accessibility&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,ce.IndexSignatureHasAccessibility,t.accessibility),</span><span class="s1">void</span><span class="s0">(t.declare&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,ce.IndexSignatureHasDeclare));super.parseClassMemberWithIsStatic(e,t,r,n)}parsePostMemberNameModifiers(e){</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(e.optional=!</span><span class="s2">0</span><span class="s0">),e.readonly&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.parenL)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,ce.ClassMethodHasReadonly),e.declare&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.parenL)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,ce.ClassMethodHasDeclare)}parseExpressionStatement(e,t){</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===t.type?</span><span class="s1">this</span><span class="s0">.tsParseExpressionStatement(e,t):</span><span class="s1">void </span><span class="s2">0</span><span class="s0">)||super.parseExpressionStatement(e,t)}shouldParseExportDeclaration(){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.tsIsDeclarationStart()||super.shouldParseExportDeclaration()}parseConditional(e,t,r,n){</span><span class="s1">if</span><span class="s0">(!n||!</span><span class="s1">this</span><span class="s0">.match(c.question))</span><span class="s1">return </span><span class="s0">super.parseConditional(e,t,r,n);const i=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;super.parseConditional(e,t,r)));</span><span class="s1">return </span><span class="s0">i.node?(i.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=i.failState),i.node):(n.start=i.error.pos||</span><span class="s1">this</span><span class="s0">.state.start,e)}parseParenItem(e,t,r){</span><span class="s1">if</span><span class="s0">(e=super.parseParenItem(e,t,r),</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(e.optional=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e)),</span><span class="s1">this</span><span class="s0">.match(c.colon)){const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">n.expression=e,n.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;TSTypeCastExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}parseExportDeclaration(e){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.state.startLoc,n=</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;declare&quot;</span><span class="s0">);let i;</span><span class="s1">return this</span><span class="s0">.match(c.name)&amp;&amp;(i=</span><span class="s1">this</span><span class="s0">.tsTryParseExportDeclaration()),i||(i=super.parseExportDeclaration(e)),i&amp;&amp;(</span><span class="s3">&quot;TSInterfaceDeclaration&quot;</span><span class="s0">===i.type||</span><span class="s3">&quot;TSTypeAliasDeclaration&quot;</span><span class="s0">===i.type||n)&amp;&amp;(e.exportKind=</span><span class="s3">&quot;type&quot;</span><span class="s0">),i&amp;&amp;n&amp;&amp;(</span><span class="s1">this</span><span class="s0">.resetStartLocation(i,t,r),i.declare=!</span><span class="s2">0</span><span class="s0">),i}parseClassId(e,t,r){</span><span class="s1">if</span><span class="s0">((!t||r)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;implements&quot;</span><span class="s0">))</span><span class="s1">return</span><span class="s0">;super.parseClassId(e,t,r,e.declare?</span><span class="s2">1024</span><span class="s0">:</span><span class="s2">139</span><span class="s0">);const n=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters();n&amp;&amp;(e.typeParameters=n)}parseClassPropertyAnnotation(e){!e.optional&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.bang)&amp;&amp;(e.definite=!</span><span class="s2">0</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();t&amp;&amp;(e.typeAnnotation=t)}parseClassProperty(e){</span><span class="s1">return this</span><span class="s0">.parseClassPropertyAnnotation(e),</span><span class="s1">this</span><span class="s0">.state.isDeclareContext&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.eq)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,ce.DeclareClassFieldHasInitializer),super.parseClassProperty(e)}parseClassPrivateProperty(e){</span><span class="s1">return </span><span class="s0">e.abstract&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,ce.PrivateElementHasAbstract),e.accessibility&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,ce.PrivateElementHasAccessibility,e.accessibility),</span><span class="s1">this</span><span class="s0">.parseClassPropertyAnnotation(e),super.parseClassPrivateProperty(e)}pushClassMethod(e,t,r,n,i,s){const a=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters();a&amp;&amp;i&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(a.start,ce.ConstructorHasTypeParameters),a&amp;&amp;(t.typeParameters=a),super.pushClassMethod(e,t,r,n,i,s)}pushClassPrivateMethod(e,t,r,n){const i=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters();i&amp;&amp;(t.typeParameters=i),super.pushClassPrivateMethod(e,t,r,n)}parseClassSuper(e){super.parseClassSuper(e),e.superClass&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)&amp;&amp;(e.superTypeParameters=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments()),</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;implements&quot;</span><span class="s0">)&amp;&amp;(e.implements=</span><span class="s1">this</span><span class="s0">.tsParseHeritageClause(</span><span class="s3">&quot;implements&quot;</span><span class="s0">))}parseObjPropValue(e,...t){const r=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters();r&amp;&amp;(e.typeParameters=r),super.parseObjPropValue(e,...t)}parseFunctionParams(e,t){const r=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters();r&amp;&amp;(e.typeParameters=r),super.parseFunctionParams(e,t)}parseVarId(e,t){super.parseVarId(e,t),</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.id.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.bang)&amp;&amp;(e.definite=!</span><span class="s2">0</span><span class="s0">);const r=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();r&amp;&amp;(e.id.typeAnnotation=r,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e.id))}parseAsyncArrowFromCallExpression(e,t){</span><span class="s1">return this</span><span class="s0">.match(c.colon)&amp;&amp;(e.returnType=</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation()),super.parseAsyncArrowFromCallExpression(e,t)}parseMaybeAssign(...e){</span><span class="s1">var </span><span class="s0">t,r,n,i,s,a,o;let l,p,u,d;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.jsxTagStart)){</span><span class="s1">if</span><span class="s0">(l=</span><span class="s1">this</span><span class="s0">.state.clone(),p=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;super.parseMaybeAssign(...e)),l),!p.error)</span><span class="s1">return </span><span class="s0">p.node;const{context:t}=</span><span class="s1">this</span><span class="s0">.state;t[t.length-1]===A.j_oTag?t.length-=</span><span class="s2">2</span><span class="s0">:t[t.length-1]===A.j_expr&amp;&amp;(t.length-=</span><span class="s2">1</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(!(</span><span class="s1">null</span><span class="s0">==(t=p)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.error)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">))</span><span class="s1">return </span><span class="s0">super.parseMaybeAssign(...e);l=l||</span><span class="s1">this</span><span class="s0">.state.clone();const h=</span><span class="s1">this</span><span class="s0">.tryParse((t=&gt;{</span><span class="s1">var </span><span class="s0">r;d=</span><span class="s1">this</span><span class="s0">.tsParseTypeParameters();const n=super.parseMaybeAssign(...e);</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">!==n.type||n.extra&amp;&amp;n.extra.parenthesized)&amp;&amp;t(),</span><span class="s2">0</span><span class="s0">!==(</span><span class="s1">null</span><span class="s0">==(r=d)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.params.length)&amp;&amp;</span><span class="s1">this</span><span class="s0">.resetStartLocationFromNode(n,d),n.typeParameters=d,n}),l);</span><span class="s1">if</span><span class="s0">(!h.error&amp;&amp;!h.aborted)</span><span class="s1">return </span><span class="s0">h.node;</span><span class="s1">if</span><span class="s0">(!p&amp;&amp;(pe(!</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;jsx&quot;</span><span class="s0">)),u=</span><span class="s1">this</span><span class="s0">.tryParse((()=&gt;super.parseMaybeAssign(...e)),l),!u.error))</span><span class="s1">return </span><span class="s0">u.node;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==(r=p)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.node)</span><span class="s1">return this</span><span class="s0">.state=p.failState,p.node;</span><span class="s1">if</span><span class="s0">(h.node)</span><span class="s1">return this</span><span class="s0">.state=h.failState,h.node;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==(n=u)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:n.node)</span><span class="s1">return this</span><span class="s0">.state=u.failState,u.node;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==(i=p)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:i.thrown)</span><span class="s1">throw </span><span class="s0">p.error;</span><span class="s1">if</span><span class="s0">(h.thrown)</span><span class="s1">throw </span><span class="s0">h.error;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==(s=u)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:s.thrown)</span><span class="s1">throw </span><span class="s0">u.error;</span><span class="s1">throw</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==(a=p)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:a.error)||h.error||(</span><span class="s1">null</span><span class="s0">==(o=u)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:o.error)}parseMaybeUnary(e){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;jsx&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.tsParseTypeAssertion():super.parseMaybeUnary(e)}parseArrow(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.colon)){const t=</span><span class="s1">this</span><span class="s0">.tryParse((e=&gt;{const t=</span><span class="s1">this</span><span class="s0">.tsParseTypeOrTypePredicateAnnotation(c.colon);</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.arrow)||e(),t}));</span><span class="s1">if</span><span class="s0">(t.aborted)</span><span class="s1">return</span><span class="s0">;t.thrown||(t.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=t.failState),e.returnType=t.node)}</span><span class="s1">return </span><span class="s0">super.parseArrow(e)}parseAssignableListItemTypes(e){</span><span class="s1">this</span><span class="s0">.eat(c.question)&amp;&amp;(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type||</span><span class="s1">this</span><span class="s0">.state.isDeclareContext||</span><span class="s1">this</span><span class="s0">.state.inType||</span><span class="s1">this</span><span class="s0">.raise(e.start,ce.PatternIsOptional),e.optional=!</span><span class="s2">0</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();</span><span class="s1">return </span><span class="s0">t&amp;&amp;(e.typeAnnotation=t),</span><span class="s1">this</span><span class="s0">.resetEndLocation(e),e}toAssignable(e){</span><span class="s1">switch</span><span class="s0">(e.type){</span><span class="s1">case</span><span class="s3">&quot;TSTypeCastExpression&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">super.toAssignable(</span><span class="s1">this</span><span class="s0">.typeCastToParameter(e));</span><span class="s1">case</span><span class="s3">&quot;TSParameterProperty&quot;</span><span class="s0">:</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return </span><span class="s0">super.toAssignable(e);</span><span class="s1">case</span><span class="s3">&quot;TSAsExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TSNonNullExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TSTypeAssertion&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.expression=</span><span class="s1">this</span><span class="s0">.toAssignable(e.expression),e}}checkLVal(e,t=</span><span class="s2">64</span><span class="s0">,r,n){</span><span class="s1">switch</span><span class="s0">(e.type){</span><span class="s1">case</span><span class="s3">&quot;TSTypeCastExpression&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;TSParameterProperty&quot;</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.checkLVal(e.parameter,t,r,</span><span class="s3">&quot;parameter property&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s3">&quot;TSAsExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TSNonNullExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TSTypeAssertion&quot;</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.checkLVal(e.expression,t,r,n);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return void </span><span class="s0">super.checkLVal(e,t,r,n)}}parseBindingAtom(){</span><span class="s1">return this</span><span class="s0">.state.type===c._this?</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">):super.parseBindingAtom()}parseMaybeDecoratorArguments(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)){const t=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.parenL)){const r=super.parseMaybeDecoratorArguments(e);</span><span class="s1">return </span><span class="s0">r.typeParameters=t,r}</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">this</span><span class="s0">.state.start,c.parenL)}</span><span class="s1">return </span><span class="s0">super.parseMaybeDecoratorArguments(e)}isClassMethod(){</span><span class="s1">return this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)||super.isClassMethod()}isClassProperty(){</span><span class="s1">return this</span><span class="s0">.match(c.bang)||</span><span class="s1">this</span><span class="s0">.match(c.colon)||super.isClassProperty()}parseMaybeDefault(...e){const t=super.parseMaybeDefault(...e);</span><span class="s1">return</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">===t.type&amp;&amp;t.typeAnnotation&amp;&amp;t.right.start&lt;t.typeAnnotation.start&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.typeAnnotation.start,ce.TypeAnnotationAfterAssign),t}getTokenFromCode(e){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.state.inType||</span><span class="s2">62</span><span class="s0">!==e&amp;&amp;</span><span class="s2">60</span><span class="s0">!==e?super.getTokenFromCode(e):</span><span class="s1">this</span><span class="s0">.finishOp(c.relational,</span><span class="s2">1</span><span class="s0">)}reScan_lt_gt(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.relational)){const e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.start);</span><span class="s2">60</span><span class="s0">!==e&amp;&amp;</span><span class="s2">62</span><span class="s0">!==e||(</span><span class="s1">this</span><span class="s0">.state.pos-=</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.readToken_lt_gt(e))}}toAssignableList(e){</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">;t&lt;e.length;t++){const r=e[t];</span><span class="s1">if</span><span class="s0">(r)</span><span class="s1">switch</span><span class="s0">(r.type){</span><span class="s1">case</span><span class="s3">&quot;TSTypeCastExpression&quot;</span><span class="s0">:e[t]=</span><span class="s1">this</span><span class="s0">.typeCastToParameter(r);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;TSAsExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;TSTypeAssertion&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters?</span><span class="s1">this</span><span class="s0">.raise(r.start,ce.UnexpectedTypeCastInParameter):e[t]=</span><span class="s1">this</span><span class="s0">.typeCastToParameter(r)}}</span><span class="s1">return </span><span class="s0">super.toAssignableList(...arguments)}typeCastToParameter(e){</span><span class="s1">return </span><span class="s0">e.expression.typeAnnotation=e.typeAnnotation,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e.expression,e.typeAnnotation.end,e.typeAnnotation.loc.end),e.expression}shouldParseArrow(){</span><span class="s1">return this</span><span class="s0">.match(c.colon)||super.shouldParseArrow()}shouldParseAsyncArrow(){</span><span class="s1">return this</span><span class="s0">.match(c.colon)||super.shouldParseAsyncArrow()}canHaveLeadingDecorator(){</span><span class="s1">return </span><span class="s0">super.canHaveLeadingDecorator()||</span><span class="s1">this</span><span class="s0">.isAbstractClass()}jsxParseOpeningElementAfterName(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isRelational(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">)){const t=</span><span class="s1">this</span><span class="s0">.tsTryParseAndCatch((()=&gt;</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments()));t&amp;&amp;(e.typeParameters=t)}</span><span class="s1">return </span><span class="s0">super.jsxParseOpeningElementAfterName(e)}getGetterSetterExpectedParamCount(e){const t=super.getGetterSetterExpectedParamCount(e),r=e.params[</span><span class="s2">0</span><span class="s0">];</span><span class="s1">return </span><span class="s0">r&amp;&amp;</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===r.type&amp;&amp;</span><span class="s3">&quot;this&quot;</span><span class="s0">===r.name?t+</span><span class="s2">1</span><span class="s0">:t}parseCatchClauseParam(){const e=super.parseCatchClauseParam(),t=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();</span><span class="s1">return </span><span class="s0">t&amp;&amp;(e.typeAnnotation=t,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e)),e}tsInDeclareContext(e){const t=</span><span class="s1">this</span><span class="s0">.state.isDeclareContext;</span><span class="s1">this</span><span class="s0">.state.isDeclareContext=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.isDeclareContext=t}}},v8intrinsic:e=&gt;class extends e{parseV8Intrinsic(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.modulo)){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.modulo),</span><span class="s1">this</span><span class="s0">.match(c.name)){const e=</span><span class="s1">this</span><span class="s0">.parseIdentifierName(</span><span class="s1">this</span><span class="s0">.state.start),r=</span><span class="s1">this</span><span class="s0">.createIdentifier(t,e);</span><span class="s1">if</span><span class="s0">(r.type=</span><span class="s3">&quot;V8IntrinsicIdentifier&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(c.parenL))</span><span class="s1">return </span><span class="s0">r}</span><span class="s1">this</span><span class="s0">.unexpected(e)}}parseExprAtom(){</span><span class="s1">return this</span><span class="s0">.parseV8Intrinsic()||super.parseExprAtom(...arguments)}},placeholders:e=&gt;class extends e{parsePlaceholder(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.placeholder)){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.assertNoSpace(</span><span class="s3">&quot;Unexpected space in placeholder.&quot;</span><span class="s0">),t.name=super.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.assertNoSpace(</span><span class="s3">&quot;Unexpected space in placeholder.&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.placeholder),</span><span class="s1">this</span><span class="s0">.finishPlaceholder(t,e)}}finishPlaceholder(e,t){const r=!(!e.expectedNode||</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">!==e.type);</span><span class="s1">return </span><span class="s0">e.expectedNode=t,r?e:</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">)}getTokenFromCode(e){</span><span class="s1">return </span><span class="s2">37</span><span class="s0">===e&amp;&amp;</span><span class="s2">37</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.finishOp(c.placeholder,</span><span class="s2">2</span><span class="s0">):super.getTokenFromCode(...arguments)}parseExprAtom(){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)||super.parseExprAtom(...arguments)}parseIdentifier(){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)||super.parseIdentifier(...arguments)}checkReservedWord(e){</span><span class="s1">void </span><span class="s2">0</span><span class="s0">!==e&amp;&amp;super.checkReservedWord(...arguments)}parseBindingAtom(){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">)||super.parseBindingAtom(...arguments)}checkLVal(e){</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">!==e.type&amp;&amp;super.checkLVal(...arguments)}toAssignable(e){</span><span class="s1">return </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;Expression&quot;</span><span class="s0">===e.expectedNode?(e.expectedNode=</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">,e):super.toAssignable(...arguments)}verifyBreakContinue(e){e.label&amp;&amp;</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===e.label.type||super.verifyBreakContinue(...arguments)}parseExpressionStatement(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">!==t.type||t.extra&amp;&amp;t.extra.parenthesized)</span><span class="s1">return </span><span class="s0">super.parseExpressionStatement(...arguments);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.colon)){const r=e;</span><span class="s1">return </span><span class="s0">r.label=</span><span class="s1">this</span><span class="s0">.finishPlaceholder(t,</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),r.body=</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s3">&quot;label&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;LabeledStatement&quot;</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.semicolon(),e.name=t.name,</span><span class="s1">this</span><span class="s0">.finishPlaceholder(e,</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)}parseBlock(){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">)||super.parseBlock(...arguments)}parseFunctionId(){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)||super.parseFunctionId(...arguments)}parseClass(e,t,r){const n=t?</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">:</span><span class="s3">&quot;ClassExpression&quot;</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.takeDecorators(e);const i=</span><span class="s1">this</span><span class="s0">.state.strict,s=</span><span class="s1">this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(s)</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._extends)||</span><span class="s1">this</span><span class="s0">.match(c.placeholder)||</span><span class="s1">this</span><span class="s0">.match(c.braceL))e.id=s;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(r||!t)</span><span class="s1">return </span><span class="s0">e.id=</span><span class="s1">null</span><span class="s0">,e.body=</span><span class="s1">this</span><span class="s0">.finishPlaceholder(s,</span><span class="s3">&quot;ClassBody&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,n);</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,</span><span class="s3">&quot;A class name is required&quot;</span><span class="s0">)}</span><span class="s1">else this</span><span class="s0">.parseClassId(e,t,r);</span><span class="s1">return this</span><span class="s0">.parseClassSuper(e),e.body=</span><span class="s1">this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;ClassBody&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.parseClassBody(!!e.superClass,i),</span><span class="s1">this</span><span class="s0">.finishNode(e,n)}parseExport(e){const t=</span><span class="s1">this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return </span><span class="s0">super.parseExport(...arguments);</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;from&quot;</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.comma))</span><span class="s1">return </span><span class="s0">e.specifiers=[],e.source=</span><span class="s1">null</span><span class="s0">,e.declaration=</span><span class="s1">this</span><span class="s0">.finishPlaceholder(t,</span><span class="s3">&quot;Declaration&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;exportDefaultFrom&quot;</span><span class="s0">);const r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">r.exported=t,e.specifiers=[</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;ExportDefaultSpecifier&quot;</span><span class="s0">)],super.parseExport(e)}isExportDefaultSpecifier(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._default)){const e=</span><span class="s1">this</span><span class="s0">.nextTokenStart();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isUnparsedContextual(e,</span><span class="s3">&quot;from&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.input.startsWith(c.placeholder.label,</span><span class="s1">this</span><span class="s0">.nextTokenStartSince(e+</span><span class="s2">4</span><span class="s0">)))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return </span><span class="s0">super.isExportDefaultSpecifier()}maybeParseExportDefaultSpecifier(e){</span><span class="s1">return</span><span class="s0">!!(e.specifiers&amp;&amp;e.specifiers.length&gt;</span><span class="s2">0</span><span class="s0">)||super.maybeParseExportDefaultSpecifier(...arguments)}checkExport(e){const{specifiers:t}=e;(</span><span class="s1">null</span><span class="s0">==t?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.length)&amp;&amp;(e.specifiers=t.filter((e=&gt;</span><span class="s3">&quot;Placeholder&quot;</span><span class="s0">===e.exported.type))),super.checkExport(e),e.specifiers=t}parseImport(e){const t=</span><span class="s1">this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return </span><span class="s0">super.parseImport(...arguments);</span><span class="s1">if</span><span class="s0">(e.specifiers=[],!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;from&quot;</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.comma))</span><span class="s1">return </span><span class="s0">e.source=</span><span class="s1">this</span><span class="s0">.finishPlaceholder(t,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">);const r=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(t);</span><span class="s1">return </span><span class="s0">r.local=t,</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">),e.specifiers.push(r),</span><span class="s1">this</span><span class="s0">.eat(c.comma)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.maybeParseStarImportSpecifier(e)||</span><span class="s1">this</span><span class="s0">.parseNamedImportSpecifiers(e)),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;from&quot;</span><span class="s0">),e.source=</span><span class="s1">this</span><span class="s0">.parseImportSource(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">)}parseImportSource(){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">)||super.parseImportSource(...arguments)}}},ye=Object.keys(me),Te={sourceType:</span><span class="s3">&quot;script&quot;</span><span class="s0">,sourceFilename:</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,startLine:</span><span class="s2">1</span><span class="s0">,allowAwaitOutsideFunction:!</span><span class="s2">1</span><span class="s0">,allowReturnOutsideFunction:!</span><span class="s2">1</span><span class="s0">,allowImportExportEverywhere:!</span><span class="s2">1</span><span class="s0">,allowSuperOutsideMethod:!</span><span class="s2">1</span><span class="s0">,allowUndeclaredExports:!</span><span class="s2">1</span><span class="s0">,plugins:[],strictMode:</span><span class="s1">null</span><span class="s0">,ranges:!</span><span class="s2">1</span><span class="s0">,tokens:!</span><span class="s2">1</span><span class="s0">,createParenthesizedExpressions:!</span><span class="s2">1</span><span class="s0">,errorRecovery:!</span><span class="s2">1</span><span class="s0">};class be{constructor(){</span><span class="s1">this</span><span class="s0">.strict=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.curLine=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.startLoc=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.endLoc=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.errors=[],</span><span class="s1">this</span><span class="s0">.potentialArrowAt=-</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.noArrowAt=[],</span><span class="s1">this</span><span class="s0">.noArrowParamsConversionAt=[],</span><span class="s1">this</span><span class="s0">.maybeInArrowParameters=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.inPipeline=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.inType=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.noAnonFunctionType=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.inPropertyName=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.hasFlowComment=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isIterator=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isDeclareContext=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.topicContext={maxNumOfResolvableTopics:</span><span class="s2">0</span><span class="s0">,maxTopicIndex:</span><span class="s1">null</span><span class="s0">},</span><span class="s1">this</span><span class="s0">.soloAwait=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.inFSharpPipelineDirectBody=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.labels=[],</span><span class="s1">this</span><span class="s0">.decoratorStack=[[]],</span><span class="s1">this</span><span class="s0">.comments=[],</span><span class="s1">this</span><span class="s0">.trailingComments=[],</span><span class="s1">this</span><span class="s0">.leadingComments=[],</span><span class="s1">this</span><span class="s0">.commentStack=[],</span><span class="s1">this</span><span class="s0">.commentPreviousNode=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.pos=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lineStart=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.type=c.eof,</span><span class="s1">this</span><span class="s0">.value=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.start=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.end=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lastTokEndLoc=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lastTokStartLoc=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lastTokStart=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lastTokEnd=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.context=[A.braceStatement],</span><span class="s1">this</span><span class="s0">.exprAllowed=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.containsEsc=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.octalPositions=[],</span><span class="s1">this</span><span class="s0">.exportedIdentifiers=[],</span><span class="s1">this</span><span class="s0">.tokensLength=</span><span class="s2">0</span><span class="s0">}init(e){</span><span class="s1">this</span><span class="s0">.strict=!</span><span class="s2">1</span><span class="s0">!==e.strictMode&amp;&amp;</span><span class="s3">&quot;module&quot;</span><span class="s0">===e.sourceType,</span><span class="s1">this</span><span class="s0">.curLine=e.startLine,</span><span class="s1">this</span><span class="s0">.startLoc=</span><span class="s1">this</span><span class="s0">.endLoc=</span><span class="s1">this</span><span class="s0">.curPosition()}curPosition(){</span><span class="s1">return new </span><span class="s0">y(</span><span class="s1">this</span><span class="s0">.curLine,</span><span class="s1">this</span><span class="s0">.pos-this.lineStart)}clone(e){const t=</span><span class="s1">new </span><span class="s0">be,r=Object.keys(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let n=</span><span class="s2">0</span><span class="s0">,i=r.length;n&lt;i;n++){const i=r[n];let s=</span><span class="s1">this</span><span class="s0">[i];!e&amp;&amp;Array.isArray(s)&amp;&amp;(s=s.slice()),t[i]=s}</span><span class="s1">return </span><span class="s0">t}}</span><span class="s1">var </span><span class="s0">ge=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">e&gt;=</span><span class="s2">48</span><span class="s0">&amp;&amp;e&lt;=</span><span class="s2">57</span><span class="s0">};const Se=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">&quot;g&quot;</span><span class="s0">,</span><span class="s3">&quot;m&quot;</span><span class="s0">,</span><span class="s3">&quot;s&quot;</span><span class="s0">,</span><span class="s3">&quot;i&quot;</span><span class="s0">,</span><span class="s3">&quot;y&quot;</span><span class="s0">,</span><span class="s3">&quot;u&quot;</span><span class="s0">]),xe={decBinOct:[</span><span class="s2">46</span><span class="s0">,</span><span class="s2">66</span><span class="s0">,</span><span class="s2">69</span><span class="s0">,</span><span class="s2">79</span><span class="s0">,</span><span class="s2">95</span><span class="s0">,</span><span class="s2">98</span><span class="s0">,</span><span class="s2">101</span><span class="s0">,</span><span class="s2">111</span><span class="s0">],hex:[</span><span class="s2">46</span><span class="s0">,</span><span class="s2">88</span><span class="s0">,</span><span class="s2">95</span><span class="s0">,</span><span class="s2">120</span><span class="s0">]},Ee={bin:[</span><span class="s2">48</span><span class="s0">,</span><span class="s2">49</span><span class="s0">]};Ee.oct=[...Ee.bin,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">51</span><span class="s0">,</span><span class="s2">52</span><span class="s0">,</span><span class="s2">53</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">55</span><span class="s0">],Ee.dec=[...Ee.oct,</span><span class="s2">56</span><span class="s0">,</span><span class="s2">57</span><span class="s0">],Ee.hex=[...Ee.dec,</span><span class="s2">65</span><span class="s0">,</span><span class="s2">66</span><span class="s0">,</span><span class="s2">67</span><span class="s0">,</span><span class="s2">68</span><span class="s0">,</span><span class="s2">69</span><span class="s0">,</span><span class="s2">70</span><span class="s0">,</span><span class="s2">97</span><span class="s0">,</span><span class="s2">98</span><span class="s0">,</span><span class="s2">99</span><span class="s0">,</span><span class="s2">100</span><span class="s0">,</span><span class="s2">101</span><span class="s0">,</span><span class="s2">102</span><span class="s0">];class Pe{constructor(e){</span><span class="s1">this</span><span class="s0">.type=e.type,</span><span class="s1">this</span><span class="s0">.value=e.value,</span><span class="s1">this</span><span class="s0">.start=e.start,</span><span class="s1">this</span><span class="s0">.end=e.end,</span><span class="s1">this</span><span class="s0">.loc=</span><span class="s1">new </span><span class="s0">T(e.startLoc,e.endLoc)}}class ve extends E{constructor(e,t){super(),</span><span class="s1">this</span><span class="s0">.isLookahead=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tokens=[],</span><span class="s1">this</span><span class="s0">.state=</span><span class="s1">new </span><span class="s0">be,</span><span class="s1">this</span><span class="s0">.state.init(e),</span><span class="s1">this</span><span class="s0">.input=t,</span><span class="s1">this</span><span class="s0">.length=t.length,</span><span class="s1">this</span><span class="s0">.isLookahead=!</span><span class="s2">1</span><span class="s0">}pushToken(e){</span><span class="s1">this</span><span class="s0">.tokens.length=</span><span class="s1">this</span><span class="s0">.state.tokensLength,</span><span class="s1">this</span><span class="s0">.tokens.push(e),++</span><span class="s1">this</span><span class="s0">.state.tokensLength}next(){</span><span class="s1">this</span><span class="s0">.isLookahead||(</span><span class="s1">this</span><span class="s0">.checkKeywordEscapes(),</span><span class="s1">this</span><span class="s0">.options.tokens&amp;&amp;</span><span class="s1">this</span><span class="s0">.pushToken(</span><span class="s1">new </span><span class="s0">Pe(</span><span class="s1">this</span><span class="s0">.state))),</span><span class="s1">this</span><span class="s0">.state.lastTokEnd=</span><span class="s1">this</span><span class="s0">.state.end,</span><span class="s1">this</span><span class="s0">.state.lastTokStart=</span><span class="s1">this</span><span class="s0">.state.start,</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc=</span><span class="s1">this</span><span class="s0">.state.endLoc,</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc=</span><span class="s1">this</span><span class="s0">.state.startLoc,</span><span class="s1">this</span><span class="s0">.nextToken()}eat(e){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.match(e)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),!</span><span class="s2">0</span><span class="s0">)}match(e){</span><span class="s1">return this</span><span class="s0">.state.type===e}lookahead(){const e=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">this</span><span class="s0">.state=e.clone(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.isLookahead=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.isLookahead=!</span><span class="s2">1</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">return this</span><span class="s0">.state=e,t}nextTokenStart(){</span><span class="s1">return this</span><span class="s0">.nextTokenStartSince(</span><span class="s1">this</span><span class="s0">.state.pos)}nextTokenStartSince(e){</span><span class="s1">return </span><span class="s0">f.lastIndex=e,e+f.exec(</span><span class="s1">this</span><span class="s0">.input)[</span><span class="s2">0</span><span class="s0">].length}lookaheadCharCode(){</span><span class="s1">return this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.nextTokenStart())}setStrict(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.strict=e,</span><span class="s1">this</span><span class="s0">.match(c.num)||</span><span class="s1">this</span><span class="s0">.match(c.string)){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos=</span><span class="s1">this</span><span class="s0">.state.start;</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.state.lineStart;)</span><span class="s1">this</span><span class="s0">.state.lineStart=</span><span class="s1">this</span><span class="s0">.input.lastIndexOf(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.lineStart-2)+</span><span class="s2">1</span><span class="s0">,--</span><span class="s1">this</span><span class="s0">.state.curLine;</span><span class="s1">this</span><span class="s0">.nextToken()}}curContext(){</span><span class="s1">return this</span><span class="s0">.state.context[</span><span class="s1">this</span><span class="s0">.state.context.length-1]}nextToken(){const e=</span><span class="s1">this</span><span class="s0">.curContext();</span><span class="s1">if</span><span class="s0">((</span><span class="s1">null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:e.preserveSpace)||</span><span class="s1">this</span><span class="s0">.skipSpace(),</span><span class="s1">this</span><span class="s0">.state.octalPositions=[],</span><span class="s1">this</span><span class="s0">.state.start=</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.state.startLoc=</span><span class="s1">this</span><span class="s0">.state.curPosition(),</span><span class="s1">this</span><span class="s0">.state.pos&gt;=</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">return void this</span><span class="s0">.finishToken(c.eof);const t=</span><span class="s1">null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:e.override;t?t(</span><span class="s1">this</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.getTokenFromCode(</span><span class="s1">this</span><span class="s0">.input.codePointAt(</span><span class="s1">this</span><span class="s0">.state.pos))}pushComment(e,t,r,n,i,s){const a={type:e?</span><span class="s3">&quot;CommentBlock&quot;</span><span class="s0">:</span><span class="s3">&quot;CommentLine&quot;</span><span class="s0">,value:t,start:r,end:n,loc:</span><span class="s1">new </span><span class="s0">T(i,s)};</span><span class="s1">this</span><span class="s0">.options.tokens&amp;&amp;</span><span class="s1">this</span><span class="s0">.pushToken(a),</span><span class="s1">this</span><span class="s0">.state.comments.push(a),</span><span class="s1">this</span><span class="s0">.addComment(a)}skipBlockComment(){const e=</span><span class="s1">this</span><span class="s0">.state.curPosition(),t=</span><span class="s1">this</span><span class="s0">.state.pos,r=</span><span class="s1">this</span><span class="s0">.input.indexOf(</span><span class="s3">&quot;*/&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(-</span><span class="s2">1</span><span class="s0">===r)</span><span class="s1">throw this</span><span class="s0">.raise(t,x.UnterminatedComment);let n;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos=r+</span><span class="s2">2</span><span class="s0">,d.lastIndex=t;(n=d.exec(</span><span class="s1">this</span><span class="s0">.input))&amp;&amp;n.index&lt;</span><span class="s1">this</span><span class="s0">.state.pos;)++</span><span class="s1">this</span><span class="s0">.state.curLine,</span><span class="s1">this</span><span class="s0">.state.lineStart=n.index+n[</span><span class="s2">0</span><span class="s0">].length;</span><span class="s1">this</span><span class="s0">.isLookahead||</span><span class="s1">this</span><span class="s0">.pushComment(!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.input.slice(t+</span><span class="s2">2</span><span class="s0">,r),t,</span><span class="s1">this</span><span class="s0">.state.pos,e,</span><span class="s1">this</span><span class="s0">.state.curPosition())}skipLineComment(e){const t=</span><span class="s1">this</span><span class="s0">.state.pos,r=</span><span class="s1">this</span><span class="s0">.state.curPosition();let n=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+=e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">for</span><span class="s0">(;!h(n)&amp;&amp;++</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length;)n=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">this</span><span class="s0">.isLookahead||</span><span class="s1">this</span><span class="s0">.pushComment(!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.input.slice(t+e,</span><span class="s1">this</span><span class="s0">.state.pos),t,</span><span class="s1">this</span><span class="s0">.state.pos,r,</span><span class="s1">this</span><span class="s0">.state.curPosition())}skipSpace(){e:</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length;){const e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">switch</span><span class="s0">(e){</span><span class="s1">case </span><span class="s2">32</span><span class="s0">:</span><span class="s1">case </span><span class="s2">160</span><span class="s0">:</span><span class="s1">case </span><span class="s2">9</span><span class="s0">:++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s2">13</span><span class="s0">:</span><span class="s2">10</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)&amp;&amp;++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">case </span><span class="s2">10</span><span class="s0">:</span><span class="s1">case </span><span class="s2">8232</span><span class="s0">:</span><span class="s1">case </span><span class="s2">8233</span><span class="s0">:++</span><span class="s1">this</span><span class="s0">.state.pos,++</span><span class="s1">this</span><span class="s0">.state.curLine,</span><span class="s1">this</span><span class="s0">.state.lineStart=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s2">47</span><span class="s0">:</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)){</span><span class="s1">case </span><span class="s2">42</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.skipBlockComment();</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s2">47</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.skipLineComment(</span><span class="s2">2</span><span class="s0">);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">break </span><span class="s0">e}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(!m(e))</span><span class="s1">break </span><span class="s0">e;++</span><span class="s1">this</span><span class="s0">.state.pos}}}finishToken(e,t){</span><span class="s1">this</span><span class="s0">.state.end=</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.state.endLoc=</span><span class="s1">this</span><span class="s0">.state.curPosition();const r=</span><span class="s1">this</span><span class="s0">.state.type;</span><span class="s1">this</span><span class="s0">.state.type=e,</span><span class="s1">this</span><span class="s0">.state.value=t,</span><span class="s1">this</span><span class="s0">.isLookahead||</span><span class="s1">this</span><span class="s0">.updateContext(r)}readToken_numberSign(){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.pos&amp;&amp;</span><span class="s1">this</span><span class="s0">.readToken_interpreter())</span><span class="s1">return</span><span class="s0">;const e=</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">,t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e);</span><span class="s1">if</span><span class="s0">(t&gt;=</span><span class="s2">48</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s2">57</span><span class="s0">)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.UnexpectedDigitAfterHash);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">123</span><span class="s0">===t||</span><span class="s2">91</span><span class="s0">===t&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">),</span><span class="s3">&quot;hash&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s3">&quot;syntaxType&quot;</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s2">123</span><span class="s0">===t?x.RecordExpressionHashIncorrectStartSyntaxType:x.TupleExpressionHashIncorrectStartSyntaxType);</span><span class="s2">123</span><span class="s0">===t?</span><span class="s1">this</span><span class="s0">.finishToken(c.braceHashL):</span><span class="s1">this</span><span class="s0">.finishToken(c.bracketHashL),</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">}</span><span class="s1">else this</span><span class="s0">.finishOp(c.hash,</span><span class="s2">1</span><span class="s0">)}readToken_dot(){const e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);e&gt;=</span><span class="s2">48</span><span class="s0">&amp;&amp;e&lt;=</span><span class="s2">57</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.readNumber(!</span><span class="s2">0</span><span class="s0">):</span><span class="s2">46</span><span class="s0">===e&amp;&amp;</span><span class="s2">46</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">)?(</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">3</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishToken(c.ellipsis)):(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.dot))}readToken_slash(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.exprAllowed&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.inType)</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.readRegexp();</span><span class="s2">61</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.finishOp(c.assign,</span><span class="s2">2</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(c.slash,</span><span class="s2">1</span><span class="s0">)}readToken_interpreter(){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">0</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.state.pos||</span><span class="s1">this</span><span class="s0">.length&lt;</span><span class="s2">2</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;let e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">33</span><span class="s0">!==e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">1</span><span class="s0">;!h(e)&amp;&amp;++</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length;)e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);const r=</span><span class="s1">this</span><span class="s0">.input.slice(t+</span><span class="s2">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">return this</span><span class="s0">.finishToken(c.interpreterDirective,r),!</span><span class="s2">0</span><span class="s0">}readToken_mult_modulo(e){let t=</span><span class="s2">42</span><span class="s0">===e?c.star:c.modulo,r=</span><span class="s2">1</span><span class="s0">,n=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);const i=</span><span class="s1">this</span><span class="s0">.state.exprAllowed;</span><span class="s2">42</span><span class="s0">===e&amp;&amp;</span><span class="s2">42</span><span class="s0">===n&amp;&amp;(r++,n=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">),t=c.exponent),</span><span class="s2">61</span><span class="s0">!==n||i||(r++,t=c.assign),</span><span class="s1">this</span><span class="s0">.finishOp(t,r)}readToken_pipe_amp(e){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(t!==e){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">124</span><span class="s0">===e){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">62</span><span class="s0">===t)</span><span class="s1">return void this</span><span class="s0">.finishOp(c.pipeline,</span><span class="s2">2</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">125</span><span class="s0">===t){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;bar&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s3">&quot;syntaxType&quot;</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.RecordExpressionBarIncorrectEndSyntaxType);</span><span class="s1">return void this</span><span class="s0">.finishOp(c.braceBarR,</span><span class="s2">2</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">93</span><span class="s0">===t){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;bar&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s3">&quot;syntaxType&quot;</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.TupleExpressionBarIncorrectEndSyntaxType);</span><span class="s1">return void this</span><span class="s0">.finishOp(c.bracketBarR,</span><span class="s2">2</span><span class="s0">)}}</span><span class="s2">61</span><span class="s0">!==t?</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s2">124</span><span class="s0">===e?c.bitwiseOR:c.bitwiseAND,</span><span class="s2">1</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(c.assign,</span><span class="s2">2</span><span class="s0">)}</span><span class="s1">else </span><span class="s2">61</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.finishOp(c.assign,</span><span class="s2">3</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s2">124</span><span class="s0">===e?c.logicalOR:c.logicalAND,</span><span class="s2">2</span><span class="s0">)}readToken_caret(){</span><span class="s2">61</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.finishOp(c.assign,</span><span class="s2">2</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(c.bitwiseXOR,</span><span class="s2">1</span><span class="s0">)}readToken_plus_min(e){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(t===e)</span><span class="s1">return </span><span class="s2">45</span><span class="s0">!==t||</span><span class="s1">this</span><span class="s0">.inModule||</span><span class="s2">62</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">)||</span><span class="s2">0</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.state.lastTokEnd&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()?</span><span class="s1">void this</span><span class="s0">.finishOp(c.incDec,</span><span class="s2">2</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.skipLineComment(</span><span class="s2">3</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.skipSpace(),</span><span class="s1">void this</span><span class="s0">.nextToken());</span><span class="s2">61</span><span class="s0">===t?</span><span class="s1">this</span><span class="s0">.finishOp(c.assign,</span><span class="s2">2</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(c.plusMin,</span><span class="s2">1</span><span class="s0">)}readToken_lt_gt(e){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);let r=</span><span class="s2">1</span><span class="s0">;</span><span class="s1">return </span><span class="s0">t===e?(r=</span><span class="s2">62</span><span class="s0">===e&amp;&amp;</span><span class="s2">62</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">)?</span><span class="s2">3</span><span class="s0">:</span><span class="s2">2</span><span class="s0">,</span><span class="s2">61</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+r)?</span><span class="s1">void this</span><span class="s0">.finishOp(c.assign,r+</span><span class="s2">1</span><span class="s0">):</span><span class="s1">void this</span><span class="s0">.finishOp(c.bitShift,r)):</span><span class="s2">33</span><span class="s0">!==t||</span><span class="s2">60</span><span class="s0">!==e||</span><span class="s1">this</span><span class="s0">.inModule||</span><span class="s2">45</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">)||</span><span class="s2">45</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">3</span><span class="s0">)?(</span><span class="s2">61</span><span class="s0">===t&amp;&amp;(r=</span><span class="s2">2</span><span class="s0">),</span><span class="s1">void this</span><span class="s0">.finishOp(c.relational,r)):(</span><span class="s1">this</span><span class="s0">.skipLineComment(</span><span class="s2">4</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.skipSpace(),</span><span class="s1">void this</span><span class="s0">.nextToken())}readToken_eq_excl(e){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">61</span><span class="s0">!==t)</span><span class="s1">return </span><span class="s2">61</span><span class="s0">===e&amp;&amp;</span><span class="s2">62</span><span class="s0">===t?(</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">,</span><span class="s1">void this</span><span class="s0">.finishToken(c.arrow)):</span><span class="s1">void this</span><span class="s0">.finishOp(</span><span class="s2">61</span><span class="s0">===e?c.eq:c.bang,</span><span class="s2">1</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.finishOp(c.equality,</span><span class="s2">61</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">)?</span><span class="s2">3</span><span class="s0">:</span><span class="s2">2</span><span class="s0">)}readToken_question(){const e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">),t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">2</span><span class="s0">);</span><span class="s2">63</span><span class="s0">===e?</span><span class="s2">61</span><span class="s0">===t?</span><span class="s1">this</span><span class="s0">.finishOp(c.assign,</span><span class="s2">3</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(c.nullishCoalescing,</span><span class="s2">2</span><span class="s0">):</span><span class="s2">46</span><span class="s0">!==e||t&gt;=</span><span class="s2">48</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s2">57</span><span class="s0">?(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.question)):(</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishToken(c.questionDot))}getTokenFromCode(e){</span><span class="s1">switch</span><span class="s0">(e){</span><span class="s1">case </span><span class="s2">46</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_dot();</span><span class="s1">case </span><span class="s2">40</span><span class="s0">:</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.parenL);</span><span class="s1">case </span><span class="s2">41</span><span class="s0">:</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.parenR);</span><span class="s1">case </span><span class="s2">59</span><span class="s0">:</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.semi);</span><span class="s1">case </span><span class="s2">44</span><span class="s0">:</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.comma);</span><span class="s1">case </span><span class="s2">91</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">124</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;bar&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s3">&quot;syntaxType&quot;</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.TupleExpressionBarIncorrectStartSyntaxType);</span><span class="s1">this</span><span class="s0">.finishToken(c.bracketBarL),</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">}</span><span class="s1">else</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.bracketL);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s2">93</span><span class="s0">:</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.bracketR);</span><span class="s1">case </span><span class="s2">123</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">124</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;bar&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s3">&quot;syntaxType&quot;</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.RecordExpressionBarIncorrectStartSyntaxType);</span><span class="s1">this</span><span class="s0">.finishToken(c.braceBarL),</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">}</span><span class="s1">else</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.braceL);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s2">125</span><span class="s0">:</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.braceR);</span><span class="s1">case </span><span class="s2">58</span><span class="s0">:</span><span class="s1">return void</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;functionBind&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">58</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.finishOp(c.doubleColon,</span><span class="s2">2</span><span class="s0">):(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(c.colon)));</span><span class="s1">case </span><span class="s2">63</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_question();</span><span class="s1">case </span><span class="s2">96</span><span class="s0">:</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.backQuote);</span><span class="s1">case </span><span class="s2">48</span><span class="s0">:{const e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">120</span><span class="s0">===e||</span><span class="s2">88</span><span class="s0">===e)</span><span class="s1">return void this</span><span class="s0">.readRadixNumber(</span><span class="s2">16</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">111</span><span class="s0">===e||</span><span class="s2">79</span><span class="s0">===e)</span><span class="s1">return void this</span><span class="s0">.readRadixNumber(</span><span class="s2">8</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">98</span><span class="s0">===e||</span><span class="s2">66</span><span class="s0">===e)</span><span class="s1">return void this</span><span class="s0">.readRadixNumber(</span><span class="s2">2</span><span class="s0">)}</span><span class="s1">case </span><span class="s2">49</span><span class="s0">:</span><span class="s1">case </span><span class="s2">50</span><span class="s0">:</span><span class="s1">case </span><span class="s2">51</span><span class="s0">:</span><span class="s1">case </span><span class="s2">52</span><span class="s0">:</span><span class="s1">case </span><span class="s2">53</span><span class="s0">:</span><span class="s1">case </span><span class="s2">54</span><span class="s0">:</span><span class="s1">case </span><span class="s2">55</span><span class="s0">:</span><span class="s1">case </span><span class="s2">56</span><span class="s0">:</span><span class="s1">case </span><span class="s2">57</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readNumber(!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">case </span><span class="s2">34</span><span class="s0">:</span><span class="s1">case </span><span class="s2">39</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readString(e);</span><span class="s1">case </span><span class="s2">47</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_slash();</span><span class="s1">case </span><span class="s2">37</span><span class="s0">:</span><span class="s1">case </span><span class="s2">42</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_mult_modulo(e);</span><span class="s1">case </span><span class="s2">124</span><span class="s0">:</span><span class="s1">case </span><span class="s2">38</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_pipe_amp(e);</span><span class="s1">case </span><span class="s2">94</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_caret();</span><span class="s1">case </span><span class="s2">43</span><span class="s0">:</span><span class="s1">case </span><span class="s2">45</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_plus_min(e);</span><span class="s1">case </span><span class="s2">60</span><span class="s0">:</span><span class="s1">case </span><span class="s2">62</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_lt_gt(e);</span><span class="s1">case </span><span class="s2">61</span><span class="s0">:</span><span class="s1">case </span><span class="s2">33</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_eq_excl(e);</span><span class="s1">case </span><span class="s2">126</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.finishOp(c.tilde,</span><span class="s2">1</span><span class="s0">);</span><span class="s1">case </span><span class="s2">64</span><span class="s0">:</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.at);</span><span class="s1">case </span><span class="s2">35</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readToken_numberSign();</span><span class="s1">case </span><span class="s2">92</span><span class="s0">:</span><span class="s1">return void this</span><span class="s0">.readWord();</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(_(e))</span><span class="s1">return void this</span><span class="s0">.readWord()}</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.InvalidOrUnexpectedToken,String.fromCodePoint(e))}finishOp(e,t){const r=</span><span class="s1">this</span><span class="s0">.input.slice(</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.state.pos+t);</span><span class="s1">this</span><span class="s0">.state.pos+=t,</span><span class="s1">this</span><span class="s0">.finishToken(e,r)}readRegexp(){const e=</span><span class="s1">this</span><span class="s0">.state.pos;let t,r;</span><span class="s1">for</span><span class="s0">(;;){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos&gt;=</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">throw this</span><span class="s0">.raise(e,x.UnterminatedRegExp);const n=</span><span class="s1">this</span><span class="s0">.input.charAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(u.test(n))</span><span class="s1">throw this</span><span class="s0">.raise(e,x.UnterminatedRegExp);</span><span class="s1">if</span><span class="s0">(t)t=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;[&quot;</span><span class="s0">===n)r=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;]&quot;</span><span class="s0">===n&amp;&amp;r)r=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;/&quot;</span><span class="s0">===n&amp;&amp;!r)</span><span class="s1">break</span><span class="s0">;t=</span><span class="s3">&quot;</span><span class="s4">\\</span><span class="s3">&quot;</span><span class="s0">===n}++</span><span class="s1">this</span><span class="s0">.state.pos}const n=</span><span class="s1">this</span><span class="s0">.input.slice(e,</span><span class="s1">this</span><span class="s0">.state.pos);++</span><span class="s1">this</span><span class="s0">.state.pos;let i=</span><span class="s3">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length;){const e=</span><span class="s1">this</span><span class="s0">.input[</span><span class="s1">this</span><span class="s0">.state.pos],t=</span><span class="s1">this</span><span class="s0">.input.codePointAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(Se.has(e))i.indexOf(e)&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">,x.DuplicateRegExpFlags);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!L(t)&amp;&amp;</span><span class="s2">92</span><span class="s0">!==t)</span><span class="s1">break</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">,x.MalformedRegExpFlags)}++</span><span class="s1">this</span><span class="s0">.state.pos,i+=e}</span><span class="s1">this</span><span class="s0">.finishToken(c.regexp,{pattern:n,flags:i})}readInt(e,t,r,n=!</span><span class="s2">0</span><span class="s0">){const i=</span><span class="s1">this</span><span class="s0">.state.pos,s=</span><span class="s2">16</span><span class="s0">===e?xe.hex:xe.decBinOct,a=</span><span class="s2">16</span><span class="s0">===e?Ee.hex:</span><span class="s2">10</span><span class="s0">===e?Ee.dec:</span><span class="s2">8</span><span class="s0">===e?Ee.oct:Ee.bin;let o=!</span><span class="s2">1</span><span class="s0">,l=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let i=</span><span class="s2">0</span><span class="s0">,p=</span><span class="s1">null</span><span class="s0">==t?</span><span class="s2">1</span><span class="s0">/</span><span class="s2">0</span><span class="s0">:t;i&lt;p;++i){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);let p;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">95</span><span class="s0">!==t){</span><span class="s1">if</span><span class="s0">(p=t&gt;=</span><span class="s2">97</span><span class="s0">?t-97+</span><span class="s2">10</span><span class="s0">:t&gt;=</span><span class="s2">65</span><span class="s0">?t-65+</span><span class="s2">10</span><span class="s0">:ge(t)?t-48:</span><span class="s2">1</span><span class="s0">/</span><span class="s2">0</span><span class="s0">,p&gt;=e)</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.options.errorRecovery&amp;&amp;p&lt;=</span><span class="s2">9</span><span class="s0">)p=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start+i+</span><span class="s2">2</span><span class="s0">,x.InvalidDigit,e);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!r)</span><span class="s1">break</span><span class="s0">;p=</span><span class="s2">0</span><span class="s0">,o=!</span><span class="s2">0</span><span class="s0">}++</span><span class="s1">this</span><span class="s0">.state.pos,l=l*e+p}</span><span class="s1">else</span><span class="s0">{const e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos-1),t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">);(-</span><span class="s2">1</span><span class="s0">===a.indexOf(t)||s.indexOf(e)&gt;-</span><span class="s2">1</span><span class="s0">||s.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">||Number.isNaN(t))&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.UnexpectedNumericSeparator),n||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.NumericSeparatorInEscapeSequence),++</span><span class="s1">this</span><span class="s0">.state.pos}}</span><span class="s1">return this</span><span class="s0">.state.pos===i||</span><span class="s1">null</span><span class="s0">!=t&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.pos-i!==t||o?</span><span class="s1">null</span><span class="s0">:l}readRadixNumber(e){const t=</span><span class="s1">this</span><span class="s0">.state.pos;let r=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">;const n=</span><span class="s1">this</span><span class="s0">.readInt(e);</span><span class="s1">null</span><span class="s0">==n&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start+</span><span class="s2">2</span><span class="s0">,x.InvalidDigit,e);const i=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">110</span><span class="s0">===i)++</span><span class="s1">this</span><span class="s0">.state.pos,r=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s2">109</span><span class="s0">===i)</span><span class="s1">throw this</span><span class="s0">.raise(t,x.InvalidDecimal);</span><span class="s1">if</span><span class="s0">(_(</span><span class="s1">this</span><span class="s0">.input.codePointAt(</span><span class="s1">this</span><span class="s0">.state.pos)))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.NumberIdentifier);</span><span class="s1">if</span><span class="s0">(r){const e=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos).replace(/[_n]/g,</span><span class="s3">&quot;&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.finishToken(c.bigint,e)}</span><span class="s1">else this</span><span class="s0">.finishToken(c.num,n)}readNumber(e){const t=</span><span class="s1">this</span><span class="s0">.state.pos;let r=!</span><span class="s2">1</span><span class="s0">,n=!</span><span class="s2">1</span><span class="s0">,i=!</span><span class="s2">1</span><span class="s0">,s=!</span><span class="s2">1</span><span class="s0">,a=!</span><span class="s2">1</span><span class="s0">;e||</span><span class="s1">null</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.readInt(</span><span class="s2">10</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.raise(t,x.InvalidNumber);const o=</span><span class="s1">this</span><span class="s0">.state.pos-t&gt;=</span><span class="s2">2</span><span class="s0">&amp;&amp;</span><span class="s2">48</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(t);</span><span class="s1">if</span><span class="s0">(o){const e=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.strict)</span><span class="s1">this</span><span class="s0">.raise(t,x.StrictOctalLiteral);</span><span class="s1">else</span><span class="s0">{const r=e.indexOf(</span><span class="s3">&quot;_&quot;</span><span class="s0">);r&gt;</span><span class="s2">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r+t,x.ZeroDigitNumericSeparator)}a=o&amp;&amp;!/[</span><span class="s2">89</span><span class="s0">]/.test(e)}let l=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">46</span><span class="s0">!==l||a||(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.readInt(</span><span class="s2">10</span><span class="s0">),r=!</span><span class="s2">0</span><span class="s0">,l=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)),</span><span class="s2">69</span><span class="s0">!==l&amp;&amp;</span><span class="s2">101</span><span class="s0">!==l||a||(l=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(++</span><span class="s1">this</span><span class="s0">.state.pos),</span><span class="s2">43</span><span class="s0">!==l&amp;&amp;</span><span class="s2">45</span><span class="s0">!==l||++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">null</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.readInt(</span><span class="s2">10</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,x.InvalidOrMissingExponent),r=!</span><span class="s2">0</span><span class="s0">,s=!</span><span class="s2">0</span><span class="s0">,l=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)),</span><span class="s2">110</span><span class="s0">===l&amp;&amp;((r||o)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,x.InvalidBigIntLiteral),++</span><span class="s1">this</span><span class="s0">.state.pos,n=!</span><span class="s2">0</span><span class="s0">),</span><span class="s2">109</span><span class="s0">===l&amp;&amp;(</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;decimal&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos),(s||o)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,x.InvalidDecimal),++</span><span class="s1">this</span><span class="s0">.state.pos,i=!</span><span class="s2">0</span><span class="s0">),_(</span><span class="s1">this</span><span class="s0">.input.codePointAt(</span><span class="s1">this</span><span class="s0">.state.pos)))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.NumberIdentifier);const p=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos).replace(/[_mn]/g,</span><span class="s3">&quot;&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(n)</span><span class="s1">return void this</span><span class="s0">.finishToken(c.bigint,p);</span><span class="s1">if</span><span class="s0">(i)</span><span class="s1">return void this</span><span class="s0">.finishToken(c.decimal,p);const u=a?parseInt(p,</span><span class="s2">8</span><span class="s0">):parseFloat(p);</span><span class="s1">this</span><span class="s0">.finishToken(c.num,u)}readCodePoint(e){let t;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">123</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)){const r=++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">if</span><span class="s0">(t=</span><span class="s1">this</span><span class="s0">.readHexChar(</span><span class="s1">this</span><span class="s0">.input.indexOf(</span><span class="s3">&quot;}&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos)-</span><span class="s1">this</span><span class="s0">.state.pos,!</span><span class="s2">0</span><span class="s0">,e),++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">null</span><span class="s0">!==t&amp;&amp;t&gt;</span><span class="s2">1114111</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.raise(r,x.InvalidCodePoint)}}</span><span class="s1">else </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.readHexChar(</span><span class="s2">4</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,e);</span><span class="s1">return </span><span class="s0">t}readString(e){let t=</span><span class="s3">&quot;&quot;</span><span class="s0">,r=++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">for</span><span class="s0">(;;){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos&gt;=</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.UnterminatedString);const n=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(n===e)</span><span class="s1">break</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">92</span><span class="s0">===n)t+=</span><span class="s1">this</span><span class="s0">.input.slice(r,</span><span class="s1">this</span><span class="s0">.state.pos),t+=</span><span class="s1">this</span><span class="s0">.readEscapedChar(!</span><span class="s2">1</span><span class="s0">),r=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">else if</span><span class="s0">(</span><span class="s2">8232</span><span class="s0">===n||</span><span class="s2">8233</span><span class="s0">===n)++</span><span class="s1">this</span><span class="s0">.state.pos,++</span><span class="s1">this</span><span class="s0">.state.curLine,</span><span class="s1">this</span><span class="s0">.state.lineStart=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(h(n))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.UnterminatedString);++</span><span class="s1">this</span><span class="s0">.state.pos}}t+=</span><span class="s1">this</span><span class="s0">.input.slice(r,</span><span class="s1">this</span><span class="s0">.state.pos++),</span><span class="s1">this</span><span class="s0">.finishToken(c.string,t)}readTmplToken(){let e=</span><span class="s3">&quot;&quot;</span><span class="s0">,t=</span><span class="s1">this</span><span class="s0">.state.pos,r=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;;){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos&gt;=</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.UnterminatedTemplate);const n=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">96</span><span class="s0">===n||</span><span class="s2">36</span><span class="s0">===n&amp;&amp;</span><span class="s2">123</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s2">1</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.state.pos===</span><span class="s1">this</span><span class="s0">.state.start&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.template)?</span><span class="s2">36</span><span class="s0">===n?(</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s2">2</span><span class="s0">,</span><span class="s1">void this</span><span class="s0">.finishToken(c.dollarBraceL)):(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">void this</span><span class="s0">.finishToken(c.backQuote)):(e+=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos),</span><span class="s1">void this</span><span class="s0">.finishToken(c.template,r?</span><span class="s1">null</span><span class="s0">:e));</span><span class="s1">if</span><span class="s0">(</span><span class="s2">92</span><span class="s0">===n){e+=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos);const n=</span><span class="s1">this</span><span class="s0">.readEscapedChar(!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">null</span><span class="s0">===n?r=!</span><span class="s2">0</span><span class="s0">:e+=n,t=</span><span class="s1">this</span><span class="s0">.state.pos}</span><span class="s1">else if</span><span class="s0">(h(n)){</span><span class="s1">switch</span><span class="s0">(e+=</span><span class="s1">this</span><span class="s0">.input.slice(t,</span><span class="s1">this</span><span class="s0">.state.pos),++</span><span class="s1">this</span><span class="s0">.state.pos,n){</span><span class="s1">case </span><span class="s2">13</span><span class="s0">:</span><span class="s2">10</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)&amp;&amp;++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">case </span><span class="s2">10</span><span class="s0">:e+=</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:e+=String.fromCharCode(n)}++</span><span class="s1">this</span><span class="s0">.state.curLine,</span><span class="s1">this</span><span class="s0">.state.lineStart=</span><span class="s1">this</span><span class="s0">.state.pos,t=</span><span class="s1">this</span><span class="s0">.state.pos}</span><span class="s1">else</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos}}readEscapedChar(e){const t=!e,r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(++</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">switch</span><span class="s0">(++</span><span class="s1">this</span><span class="s0">.state.pos,r){</span><span class="s1">case </span><span class="s2">110</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">;</span><span class="s1">case </span><span class="s2">114</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;</span><span class="s4">\r</span><span class="s3">&quot;</span><span class="s0">;</span><span class="s1">case </span><span class="s2">120</span><span class="s0">:{const e=</span><span class="s1">this</span><span class="s0">.readHexChar(</span><span class="s2">2</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,t);</span><span class="s1">return null</span><span class="s0">===e?</span><span class="s1">null</span><span class="s0">:String.fromCharCode(e)}</span><span class="s1">case </span><span class="s2">117</span><span class="s0">:{const e=</span><span class="s1">this</span><span class="s0">.readCodePoint(t);</span><span class="s1">return null</span><span class="s0">===e?</span><span class="s1">null</span><span class="s0">:String.fromCodePoint(e)}</span><span class="s1">case </span><span class="s2">116</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;</span><span class="s4">\t</span><span class="s3">&quot;</span><span class="s0">;</span><span class="s1">case </span><span class="s2">98</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;</span><span class="s4">\b</span><span class="s3">&quot;</span><span class="s0">;</span><span class="s1">case </span><span class="s2">118</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;</span><span class="s5">\v</span><span class="s3">&quot;</span><span class="s0">;</span><span class="s1">case </span><span class="s2">102</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;</span><span class="s4">\f</span><span class="s3">&quot;</span><span class="s0">;</span><span class="s1">case </span><span class="s2">13</span><span class="s0">:</span><span class="s2">10</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)&amp;&amp;++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">case </span><span class="s2">10</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.state.lineStart=</span><span class="s1">this</span><span class="s0">.state.pos,++</span><span class="s1">this</span><span class="s0">.state.curLine;</span><span class="s1">case </span><span class="s2">8232</span><span class="s0">:</span><span class="s1">case </span><span class="s2">8233</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;&quot;</span><span class="s0">;</span><span class="s1">case </span><span class="s2">56</span><span class="s0">:</span><span class="s1">case </span><span class="s2">57</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos-1,x.StrictNumericEscape);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(r&gt;=</span><span class="s2">48</span><span class="s0">&amp;&amp;r&lt;=</span><span class="s2">55</span><span class="s0">){const t=</span><span class="s1">this</span><span class="s0">.state.pos-1;let r=</span><span class="s1">this</span><span class="s0">.input.substr(</span><span class="s1">this</span><span class="s0">.state.pos-1,</span><span class="s2">3</span><span class="s0">).match(/^[</span><span class="s2">0</span><span class="s0">-</span><span class="s2">7</span><span class="s0">]+/)[</span><span class="s2">0</span><span class="s0">],n=parseInt(r,</span><span class="s2">8</span><span class="s0">);n&gt;</span><span class="s2">255</span><span class="s0">&amp;&amp;(r=r.slice(</span><span class="s2">0</span><span class="s0">,-</span><span class="s2">1</span><span class="s0">),n=parseInt(r,</span><span class="s2">8</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.state.pos+=r.length-1;const i=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;0&quot;</span><span class="s0">!==r||</span><span class="s2">56</span><span class="s0">===i||</span><span class="s2">57</span><span class="s0">===i){</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.state.strict?</span><span class="s1">this</span><span class="s0">.raise(t,x.StrictNumericEscape):</span><span class="s1">this</span><span class="s0">.state.octalPositions.push(t)}</span><span class="s1">return </span><span class="s0">String.fromCharCode(n)}</span><span class="s1">return </span><span class="s0">String.fromCharCode(r)}}readHexChar(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.state.pos,i=</span><span class="s1">this</span><span class="s0">.readInt(</span><span class="s2">16</span><span class="s0">,e,t,!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">return null</span><span class="s0">===i&amp;&amp;(r?</span><span class="s1">this</span><span class="s0">.raise(n,x.InvalidEscapeSequence):</span><span class="s1">this</span><span class="s0">.state.pos=n-1),i}readWord1(){let e=</span><span class="s3">&quot;&quot;</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.state.containsEsc=!</span><span class="s2">1</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.state.pos;let r=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length;){const n=</span><span class="s1">this</span><span class="s0">.input.codePointAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(L(n))</span><span class="s1">this</span><span class="s0">.state.pos+=n&lt;=</span><span class="s2">65535</span><span class="s0">?</span><span class="s2">1</span><span class="s0">:</span><span class="s2">2</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.isIterator&amp;&amp;</span><span class="s2">64</span><span class="s0">===n)++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s2">92</span><span class="s0">!==n)</span><span class="s1">break</span><span class="s0">;{</span><span class="s1">this</span><span class="s0">.state.containsEsc=!</span><span class="s2">0</span><span class="s0">,e+=</span><span class="s1">this</span><span class="s0">.input.slice(r,</span><span class="s1">this</span><span class="s0">.state.pos);const n=</span><span class="s1">this</span><span class="s0">.state.pos,i=</span><span class="s1">this</span><span class="s0">.state.pos===t?_:L;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">117</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.input.charCodeAt(++</span><span class="s1">this</span><span class="s0">.state.pos)){</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.MissingUnicodeEscape);</span><span class="s1">continue</span><span class="s0">}++</span><span class="s1">this</span><span class="s0">.state.pos;const s=</span><span class="s1">this</span><span class="s0">.readCodePoint(!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">null</span><span class="s0">!==s&amp;&amp;(i(s)||</span><span class="s1">this</span><span class="s0">.raise(n,x.EscapedCharNotAnIdentifier),e+=String.fromCodePoint(s)),r=</span><span class="s1">this</span><span class="s0">.state.pos}}}</span><span class="s1">return </span><span class="s0">e+</span><span class="s1">this</span><span class="s0">.input.slice(r,</span><span class="s1">this</span><span class="s0">.state.pos)}isIterator(e){</span><span class="s1">return</span><span class="s3">&quot;@@iterator&quot;</span><span class="s0">===e||</span><span class="s3">&quot;@@asyncIterator&quot;</span><span class="s0">===e}readWord(){const e=</span><span class="s1">this</span><span class="s0">.readWord1(),t=o.get(e)||c.name;!</span><span class="s1">this</span><span class="s0">.state.isIterator||</span><span class="s1">this</span><span class="s0">.isIterator(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.inType||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.InvalidIdentifier,e),</span><span class="s1">this</span><span class="s0">.finishToken(t,e)}checkKeywordEscapes(){const e=</span><span class="s1">this</span><span class="s0">.state.type.keyword;e&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.containsEsc&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.InvalidEscapedReservedWord,e)}braceIsBlock(e){const t=</span><span class="s1">this</span><span class="s0">.curContext();</span><span class="s1">return </span><span class="s0">t===A.functionExpression||t===A.functionStatement||(e!==c.colon||t!==A.braceStatement&amp;&amp;t!==A.braceExpression?e===c._return||e===c.name&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.exprAllowed?</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak():e===c._else||e===c.semi||e===c.eof||e===c.parenR||e===c.arrow||(e===c.braceL?t===A.braceStatement:e!==c._var&amp;&amp;e!==c._const&amp;&amp;e!==c.name&amp;&amp;(e===c.relational||!</span><span class="s1">this</span><span class="s0">.state.exprAllowed)):!t.isExpr)}updateContext(e){const t=</span><span class="s1">this</span><span class="s0">.state.type;let r;!t.keyword||e!==c.dot&amp;&amp;e!==c.questionDot?(r=t.updateContext)?r.call(</span><span class="s1">this</span><span class="s0">,e):</span><span class="s1">this</span><span class="s0">.state.exprAllowed=t.beforeExpr:</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">}}class Ae extends ve{addExtra(e,t,r){e&amp;&amp;((e.extra=e.extra||{})[t]=r)}isRelational(e){</span><span class="s1">return this</span><span class="s0">.match(c.relational)&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.value===e}expectRelational(e){</span><span class="s1">this</span><span class="s0">.isRelational(e)?</span><span class="s1">this</span><span class="s0">.next():</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,c.relational)}isContextual(e){</span><span class="s1">return this</span><span class="s0">.match(c.name)&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.value===e&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.containsEsc}isUnparsedContextual(e,t){const r=e+t.length;</span><span class="s1">return this</span><span class="s0">.input.slice(e,r)===t&amp;&amp;(r===</span><span class="s1">this</span><span class="s0">.input.length||!L(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(r)))}isLookaheadContextual(e){const t=</span><span class="s1">this</span><span class="s0">.nextTokenStart();</span><span class="s1">return this</span><span class="s0">.isUnparsedContextual(t,e)}eatContextual(e){</span><span class="s1">return this</span><span class="s0">.isContextual(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.name)}expectContextual(e,t){</span><span class="s1">this</span><span class="s0">.eatContextual(e)||</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,t)}canInsertSemicolon(){</span><span class="s1">return this</span><span class="s0">.match(c.eof)||</span><span class="s1">this</span><span class="s0">.match(c.braceR)||</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()}hasPrecedingLineBreak(){</span><span class="s1">return </span><span class="s0">u.test(</span><span class="s1">this</span><span class="s0">.input.slice(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,</span><span class="s1">this</span><span class="s0">.state.start))}isLineTerminator(){</span><span class="s1">return this</span><span class="s0">.eat(c.semi)||</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()}semicolon(){</span><span class="s1">this</span><span class="s0">.isLineTerminator()||</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,c.semi)}expect(e,t){</span><span class="s1">this</span><span class="s0">.eat(e)||</span><span class="s1">this</span><span class="s0">.unexpected(t,e)}assertNoSpace(e=</span><span class="s3">&quot;Unexpected space.&quot;</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.state.start&gt;</span><span class="s1">this</span><span class="s0">.state.lastTokEnd&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,e)}unexpected(e,t=</span><span class="s3">&quot;Unexpected token&quot;</span><span class="s0">){</span><span class="s1">throw</span><span class="s3">&quot;string&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;(t=`Unexpected token, expected </span><span class="s3">&quot;${t.label}&quot;</span><span class="s0">`),</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">null</span><span class="s0">!=e?e:</span><span class="s1">this</span><span class="s0">.state.start,t)}expectPlugin(e,t){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.hasPlugin(e))</span><span class="s1">throw this</span><span class="s0">.raiseWithData(</span><span class="s1">null</span><span class="s0">!=t?t:</span><span class="s1">this</span><span class="s0">.state.start,{missingPlugin:[e]},`This experimental syntax requires enabling the parser plugin: </span><span class="s3">'${e}'</span><span class="s0">`);</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}expectOnePlugin(e,t){</span><span class="s1">if</span><span class="s0">(!e.some((e=&gt;</span><span class="s1">this</span><span class="s0">.hasPlugin(e))))</span><span class="s1">throw this</span><span class="s0">.raiseWithData(</span><span class="s1">null</span><span class="s0">!=t?t:</span><span class="s1">this</span><span class="s0">.state.start,{missingPlugin:e},`This experimental syntax requires enabling one of the following parser plugin(s): </span><span class="s3">'${e.join(&quot;, &quot;)}'</span><span class="s0">`)}tryParse(e,t=</span><span class="s1">this</span><span class="s0">.state.clone()){const r={node:</span><span class="s1">null</span><span class="s0">};</span><span class="s1">try</span><span class="s0">{const n=e(((e=</span><span class="s1">null</span><span class="s0">)=&gt;{</span><span class="s1">throw </span><span class="s0">r.node=e,r}));</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.errors.length&gt;t.errors.length){const e=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">return this</span><span class="s0">.state=t,{node:n,error:e.errors[t.errors.length],thrown:!</span><span class="s2">1</span><span class="s0">,aborted:!</span><span class="s2">1</span><span class="s0">,failState:e}}</span><span class="s1">return</span><span class="s0">{node:n,error:</span><span class="s1">null</span><span class="s0">,thrown:!</span><span class="s2">1</span><span class="s0">,aborted:!</span><span class="s2">1</span><span class="s0">,failState:</span><span class="s1">null</span><span class="s0">}}</span><span class="s1">catch</span><span class="s0">(e){const n=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state=t,e </span><span class="s1">instanceof </span><span class="s0">SyntaxError)</span><span class="s1">return</span><span class="s0">{node:</span><span class="s1">null</span><span class="s0">,error:e,thrown:!</span><span class="s2">0</span><span class="s0">,aborted:!</span><span class="s2">1</span><span class="s0">,failState:n};</span><span class="s1">if</span><span class="s0">(e===r)</span><span class="s1">return</span><span class="s0">{node:r.node,error:</span><span class="s1">null</span><span class="s0">,thrown:!</span><span class="s2">1</span><span class="s0">,aborted:!</span><span class="s2">0</span><span class="s0">,failState:n};</span><span class="s1">throw </span><span class="s0">e}}checkExpressionErrors(e,t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const{shorthandAssign:r,doubleProto:n}=e;</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return </span><span class="s0">r&gt;=</span><span class="s2">0</span><span class="s0">||n&gt;=</span><span class="s2">0</span><span class="s0">;r&gt;=</span><span class="s2">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(r),n&gt;=</span><span class="s2">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(n,x.DuplicateProto)}isLiteralPropertyName(){</span><span class="s1">return this</span><span class="s0">.match(c.name)||!!</span><span class="s1">this</span><span class="s0">.state.type.keyword||</span><span class="s1">this</span><span class="s0">.match(c.string)||</span><span class="s1">this</span><span class="s0">.match(c.num)||</span><span class="s1">this</span><span class="s0">.match(c.bigint)||</span><span class="s1">this</span><span class="s0">.match(c.decimal)}}class we{constructor(){</span><span class="s1">this</span><span class="s0">.shorthandAssign=-</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.doubleProto=-</span><span class="s2">1</span><span class="s0">}}class Oe{constructor(e,t,r){</span><span class="s1">this</span><span class="s0">.type=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.start=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.end=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.loc=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.range=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.leadingComments=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.trailingComments=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.innerComments=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.extra=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.type=</span><span class="s3">&quot;&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.start=t,</span><span class="s1">this</span><span class="s0">.end=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.loc=</span><span class="s1">new </span><span class="s0">T(r),(</span><span class="s1">null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:e.options.ranges)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.range=[t,</span><span class="s2">0</span><span class="s0">]),(</span><span class="s1">null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:e.filename)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.loc.filename=e.filename)}__clone(){const e=</span><span class="s1">new </span><span class="s0">Oe,t=Object.keys(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s2">0</span><span class="s0">,n=t.length;r&lt;n;r++){const n=t[r];</span><span class="s3">&quot;leadingComments&quot;</span><span class="s0">!==n&amp;&amp;</span><span class="s3">&quot;trailingComments&quot;</span><span class="s0">!==n&amp;&amp;</span><span class="s3">&quot;innerComments&quot;</span><span class="s0">!==n&amp;&amp;(e[n]=</span><span class="s1">this</span><span class="s0">[n])}</span><span class="s1">return </span><span class="s0">e}}class Ie extends Ae{startNode(){</span><span class="s1">return new </span><span class="s0">Oe(</span><span class="s1">this</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.start,</span><span class="s1">this</span><span class="s0">.state.startLoc)}startNodeAt(e,t){</span><span class="s1">return new </span><span class="s0">Oe(</span><span class="s1">this</span><span class="s0">,e,t)}startNodeAtNode(e){</span><span class="s1">return this</span><span class="s0">.startNodeAt(e.start,e.loc.start)}finishNode(e,t){</span><span class="s1">return this</span><span class="s0">.finishNodeAt(e,t,</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc)}finishNodeAt(e,t,r,n){</span><span class="s1">return </span><span class="s0">e.type=t,e.end=r,e.loc.end=n,</span><span class="s1">this</span><span class="s0">.options.ranges&amp;&amp;(e.range[</span><span class="s2">1</span><span class="s0">]=r),</span><span class="s1">this</span><span class="s0">.processComment(e),e}resetStartLocation(e,t,r){e.start=t,e.loc.start=r,</span><span class="s1">this</span><span class="s0">.options.ranges&amp;&amp;(e.range[</span><span class="s2">0</span><span class="s0">]=t)}resetEndLocation(e,t=</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,r=</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc){e.end=t,e.loc.end=r,</span><span class="s1">this</span><span class="s0">.options.ranges&amp;&amp;(e.range[</span><span class="s2">1</span><span class="s0">]=t)}resetStartLocationFromNode(e,t){</span><span class="s1">this</span><span class="s0">.resetStartLocation(e,t.start,t.loc.start)}}const Ne=e=&gt;</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">===e.type?Ne(e.expression):e;class Ce extends Ie{toAssignable(e){</span><span class="s1">var </span><span class="s0">t,r;let n;</span><span class="s1">switch</span><span class="s0">((</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">===e.type||(</span><span class="s1">null</span><span class="s0">==(t=e.extra)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.parenthesized))&amp;&amp;(n=Ne(e),</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==n.type&amp;&amp;</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">!==n.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,x.InvalidParenthesizedAssignment)),e.type){</span><span class="s1">case</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">:</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s0">:e.type=</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">,r=e.properties.length,n=r-1;t&lt;r;t++){</span><span class="s1">var </span><span class="s0">i;const r=e.properties[t],s=t===n;</span><span class="s1">this</span><span class="s0">.toAssignableObjectExpressionProp(r,s),s&amp;&amp;</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">===r.type&amp;&amp;(</span><span class="s1">null</span><span class="s0">==(i=e.extra)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:i.trailingComma)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raiseRestNotLast(e.extra.trailingComma)}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.toAssignable(e.value);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">:{</span><span class="s1">this</span><span class="s0">.checkToRestConversion(e),e.type=</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">;const t=e.argument;</span><span class="s1">this</span><span class="s0">.toAssignable(t);</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case</span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s0">:e.type=</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.toAssignableList(e.elements,</span><span class="s1">null</span><span class="s0">==(r=e.extra)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.trailingComma);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s0">:</span><span class="s3">&quot;=&quot;</span><span class="s0">!==e.operator&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.left.end,x.MissingEqInAssignment),e.type=</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">,</span><span class="s1">delete </span><span class="s0">e.operator,</span><span class="s1">this</span><span class="s0">.toAssignable(e.left);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.toAssignable(n)}</span><span class="s1">return </span><span class="s0">e}toAssignableObjectExpressionProp(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">===e.type){const t=</span><span class="s3">&quot;get&quot;</span><span class="s0">===e.kind||</span><span class="s3">&quot;set&quot;</span><span class="s0">===e.kind?x.PatternHasAccessor:x.PatternHasMethod;</span><span class="s1">this</span><span class="s0">.raise(e.key.start,t)}</span><span class="s1">else</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">!==e.type||t?</span><span class="s1">this</span><span class="s0">.toAssignable(e):</span><span class="s1">this</span><span class="s0">.raiseRestNotLast(e.start)}toAssignableList(e,t){let r=e.length;</span><span class="s1">if</span><span class="s0">(r){const n=e[r-1];</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">===(</span><span class="s1">null</span><span class="s0">==n?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:n.type))--r;</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">===(</span><span class="s1">null</span><span class="s0">==n?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:n.type)){n.type=</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">;const e=n.argument;</span><span class="s1">this</span><span class="s0">.toAssignable(e),</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(e.start),t&amp;&amp;</span><span class="s1">this</span><span class="s0">.raiseTrailingCommaAfterRest(t),--r}}</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">;t&lt;r;t++){const r=e[t];r&amp;&amp;(</span><span class="s1">this</span><span class="s0">.toAssignable(r),</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">===r.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raiseRestNotLast(r.start))}</span><span class="s1">return </span><span class="s0">e}toReferencedList(e,t){</span><span class="s1">return </span><span class="s0">e}toReferencedListDeep(e,t){</span><span class="s1">this</span><span class="s0">.toReferencedList(e,t);</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">;t&lt;e.length;t++){const r=e[t];</span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s0">===(</span><span class="s1">null</span><span class="s0">==r?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.type)&amp;&amp;</span><span class="s1">this</span><span class="s0">.toReferencedListDeep(r.elements)}}parseSpread(e,t){const r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),r.argument=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(e,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,t),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">)}parseRestBinding(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),e.argument=</span><span class="s1">this</span><span class="s0">.parseBindingAtom(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">)}parseBindingAtom(){</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c.bracketL:{const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),e.elements=</span><span class="s1">this</span><span class="s0">.parseBindingList(c.bracketR,</span><span class="s2">93</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">)}</span><span class="s1">case </span><span class="s0">c.braceL:</span><span class="s1">return this</span><span class="s0">.parseObjectLike(c.braceR,!</span><span class="s2">0</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.parseIdentifier()}parseBindingList(e,t,r,n){const i=[];let s=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.eat(e);)</span><span class="s1">if</span><span class="s0">(s?s=!</span><span class="s2">1</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.expect(c.comma),r&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.comma))i.push(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(e))</span><span class="s1">break</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.ellipsis)){i.push(</span><span class="s1">this</span><span class="s0">.parseAssignableListItemTypes(</span><span class="s1">this</span><span class="s0">.parseRestBinding())),</span><span class="s1">this</span><span class="s0">.checkCommaAfterRest(t),</span><span class="s1">this</span><span class="s0">.expect(e);</span><span class="s1">break</span><span class="s0">}{const e=[];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.at)&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.UnsupportedParameterDecorator);</span><span class="s1">this</span><span class="s0">.match(c.at);)e.push(</span><span class="s1">this</span><span class="s0">.parseDecorator());i.push(</span><span class="s1">this</span><span class="s0">.parseAssignableListItem(n,e))}}</span><span class="s1">return </span><span class="s0">i}parseAssignableListItem(e,t){const r=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault();</span><span class="s1">this</span><span class="s0">.parseAssignableListItemTypes(r);const n=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault(r.start,r.loc.start,r);</span><span class="s1">return </span><span class="s0">t.length&amp;&amp;(r.decorators=t),n}parseAssignableListItemTypes(e){</span><span class="s1">return </span><span class="s0">e}parseMaybeDefault(e,t,r){</span><span class="s1">var </span><span class="s0">n,i,s;</span><span class="s1">if</span><span class="s0">(t=</span><span class="s1">null</span><span class="s0">!=(n=t)?n:</span><span class="s1">this</span><span class="s0">.state.startLoc,e=</span><span class="s1">null</span><span class="s0">!=(i=e)?i:</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">null</span><span class="s0">!=(s=r)?s:</span><span class="s1">this</span><span class="s0">.parseBindingAtom(),!</span><span class="s1">this</span><span class="s0">.eat(c.eq))</span><span class="s1">return </span><span class="s0">r;const a=</span><span class="s1">this</span><span class="s0">.startNodeAt(e,t);</span><span class="s1">return </span><span class="s0">a.left=r,a.right=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">)}checkLVal(e,t=</span><span class="s2">64</span><span class="s0">,r,n,i,s=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">switch</span><span class="s0">(e.type){</span><span class="s1">case</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;(s?V(e.name,</span><span class="s1">this</span><span class="s0">.inModule):U(e.name))&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,</span><span class="s2">64</span><span class="s0">===t?x.StrictEvalArguments:x.StrictEvalArgumentsBinding,e.name),r){const t=`_${e.name}`;r[t]?</span><span class="s1">this</span><span class="s0">.raise(e.start,x.ParamDupe):r[t]=!</span><span class="s2">0</span><span class="s0">}i&amp;&amp;</span><span class="s3">&quot;let&quot;</span><span class="s0">===e.name&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,x.LetInLexicalBinding),</span><span class="s2">64</span><span class="s0">&amp;t||</span><span class="s1">this</span><span class="s0">.scope.declareName(e.name,t,e.start);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">:</span><span class="s2">64</span><span class="s0">!==t&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,x.InvalidPropertyBindingPattern);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">:</span><span class="s1">for</span><span class="s0">(let n=</span><span class="s2">0</span><span class="s0">,s=e.properties;n&lt;s.length;n++){let e=s[n];</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">===e.type)e=e.value;</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">===e.type)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.checkLVal(e,t,r,</span><span class="s3">&quot;object destructuring pattern&quot;</span><span class="s0">,i)}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">:</span><span class="s1">for</span><span class="s0">(let n=</span><span class="s2">0</span><span class="s0">,s=e.elements;n&lt;s.length;n++){const e=s[n];e&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkLVal(e,t,r,</span><span class="s3">&quot;array destructuring pattern&quot;</span><span class="s0">,i)}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.checkLVal(e.left,t,r,</span><span class="s3">&quot;assignment pattern&quot;</span><span class="s0">);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.checkLVal(e.argument,t,r,</span><span class="s3">&quot;rest element&quot;</span><span class="s0">);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.checkLVal(e.expression,t,r,</span><span class="s3">&quot;parenthesized expression&quot;</span><span class="s0">);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.raise(e.start,</span><span class="s2">64</span><span class="s0">===t?x.InvalidLhs:x.InvalidLhsBinding,n)}}checkToRestConversion(e){</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==e.argument.type&amp;&amp;</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">!==e.argument.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.argument.start,x.InvalidRestAssignmentPattern)}checkCommaAfterRest(e){</span><span class="s1">this</span><span class="s0">.match(c.comma)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()===e?</span><span class="s1">this</span><span class="s0">.raiseTrailingCommaAfterRest(</span><span class="s1">this</span><span class="s0">.state.start):</span><span class="s1">this</span><span class="s0">.raiseRestNotLast(</span><span class="s1">this</span><span class="s0">.state.start))}raiseRestNotLast(e){</span><span class="s1">throw this</span><span class="s0">.raise(e,x.ElementAfterRest)}raiseTrailingCommaAfterRest(e){</span><span class="s1">this</span><span class="s0">.raise(e,x.RestTrailingComma)}}class ke{constructor(e=</span><span class="s2">0</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.type=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.type=e}canBeArrowParameterDeclaration(){</span><span class="s1">return </span><span class="s2">2</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.type||</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.type}isCertainlyParameterDeclaration(){</span><span class="s1">return </span><span class="s2">3</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.type}}class De extends ke{constructor(e){super(e),</span><span class="s1">this</span><span class="s0">.errors=</span><span class="s1">new </span><span class="s0">Map}recordDeclarationError(e,t){</span><span class="s1">this</span><span class="s0">.errors.set(e,t)}clearDeclarationError(e){</span><span class="s1">this</span><span class="s0">.errors.</span><span class="s1">delete</span><span class="s0">(e)}iterateErrors(e){</span><span class="s1">this</span><span class="s0">.errors.forEach(e)}}class _e{constructor(e){</span><span class="s1">this</span><span class="s0">.stack=[</span><span class="s1">new </span><span class="s0">ke],</span><span class="s1">this</span><span class="s0">.raise=e}enter(e){</span><span class="s1">this</span><span class="s0">.stack.push(e)}exit(){</span><span class="s1">this</span><span class="s0">.stack.pop()}recordParameterInitializerError(e,t){const{stack:r}=</span><span class="s1">this</span><span class="s0">;let n=r.length-1,i=r[n];</span><span class="s1">for</span><span class="s0">(;!i.isCertainlyParameterDeclaration();){</span><span class="s1">if</span><span class="s0">(!i.canBeArrowParameterDeclaration())</span><span class="s1">return</span><span class="s0">;i.recordDeclarationError(e,t),i=r[--n]}</span><span class="s1">this</span><span class="s0">.raise(e,t)}recordAsyncArrowParametersError(e,t){const{stack:r}=</span><span class="s1">this</span><span class="s0">;let n=r.length-1,i=r[n];</span><span class="s1">for</span><span class="s0">(;i.canBeArrowParameterDeclaration();)</span><span class="s2">2</span><span class="s0">===i.type&amp;&amp;i.recordDeclarationError(e,t),i=r[--n]}validateAsPattern(){const{stack:e}=</span><span class="s1">this</span><span class="s0">,t=e[e.length-1];t.canBeArrowParameterDeclaration()&amp;&amp;t.iterateErrors(((t,r)=&gt;{</span><span class="s1">this</span><span class="s0">.raise(r,t);let n=e.length-2,i=e[n];</span><span class="s1">for</span><span class="s0">(;i.canBeArrowParameterDeclaration();)i.clearDeclarationError(r),i=e[--n]}))}}</span><span class="s1">function </span><span class="s0">Le(){</span><span class="s1">return new </span><span class="s0">ke}class Me extends Ce{checkProto(e,t,r,n){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">===e.type||</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">===e.type||e.computed||e.shorthand)</span><span class="s1">return</span><span class="s0">;const i=e.key;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;__proto__&quot;</span><span class="s0">===(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===i.type?i.name:i.value)){</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return void this</span><span class="s0">.raise(i.start,x.RecordNoProto);r.used&amp;&amp;(n?-</span><span class="s2">1</span><span class="s0">===n.doubleProto&amp;&amp;(n.doubleProto=i.start):</span><span class="s1">this</span><span class="s0">.raise(i.start,x.DuplicateProto)),r.used=!</span><span class="s2">0</span><span class="s0">}}shouldExitDescending(e,t){</span><span class="s1">return</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">===e.type&amp;&amp;e.start===t}getExpression(){let e=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;topLevelAwait&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;(e|=</span><span class="s2">2</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.enter(e),</span><span class="s1">this</span><span class="s0">.nextToken();const t=</span><span class="s1">this</span><span class="s0">.parseExpression();</span><span class="s1">return this</span><span class="s0">.match(c.eof)||</span><span class="s1">this</span><span class="s0">.unexpected(),t.comments=</span><span class="s1">this</span><span class="s0">.state.comments,t.errors=</span><span class="s1">this</span><span class="s0">.state.errors,t}parseExpression(e,t){</span><span class="s1">return </span><span class="s0">e?</span><span class="s1">this</span><span class="s0">.disallowInAnd((()=&gt;</span><span class="s1">this</span><span class="s0">.parseExpressionBase(t))):</span><span class="s1">this</span><span class="s0">.allowInAnd((()=&gt;</span><span class="s1">this</span><span class="s0">.parseExpressionBase(t)))}parseExpressionBase(e){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.state.startLoc,n=</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.comma)){const i=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">for</span><span class="s0">(i.expressions=[n];</span><span class="s1">this</span><span class="s0">.eat(c.comma);)i.expressions.push(</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(e));</span><span class="s1">return this</span><span class="s0">.toReferencedList(i.expressions),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">n}parseMaybeAssignDisallowIn(e,t,r){</span><span class="s1">return this</span><span class="s0">.disallowInAnd((()=&gt;</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(e,t,r)))}parseMaybeAssignAllowIn(e,t,r){</span><span class="s1">return this</span><span class="s0">.allowInAnd((()=&gt;</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(e,t,r)))}parseMaybeAssign(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.state.start,i=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;yield&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.prodParam.hasYield){</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">0</span><span class="s0">;let e=</span><span class="s1">this</span><span class="s0">.parseYield();</span><span class="s1">return </span><span class="s0">t&amp;&amp;(e=t.call(</span><span class="s1">this</span><span class="s0">,e,n,i)),e}let s;e?s=!</span><span class="s2">1</span><span class="s0">:(e=</span><span class="s1">new </span><span class="s0">we,s=!</span><span class="s2">0</span><span class="s0">),(</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.match(c.name))&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt=</span><span class="s1">this</span><span class="s0">.state.start);let a=</span><span class="s1">this</span><span class="s0">.parseMaybeConditional(e,r);</span><span class="s1">if</span><span class="s0">(t&amp;&amp;(a=t.call(</span><span class="s1">this</span><span class="s0">,a,n,i)),</span><span class="s1">this</span><span class="s0">.state.type.isAssign){const t=</span><span class="s1">this</span><span class="s0">.startNodeAt(n,i),r=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">return </span><span class="s0">t.operator=r,</span><span class="s1">this</span><span class="s0">.match(c.eq)?(t.left=</span><span class="s1">this</span><span class="s0">.toAssignable(a),e.doubleProto=-</span><span class="s2">1</span><span class="s0">):t.left=a,e.shorthandAssign&gt;=t.left.start&amp;&amp;(e.shorthandAssign=-</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.checkLVal(a,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s3">&quot;assignment expression&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),t.right=</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">s&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkExpressionErrors(e,!</span><span class="s2">0</span><span class="s0">),a}parseMaybeConditional(e,t){const r=</span><span class="s1">this</span><span class="s0">.state.start,n=</span><span class="s1">this</span><span class="s0">.state.startLoc,i=</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt,s=</span><span class="s1">this</span><span class="s0">.parseExprOps(e);</span><span class="s1">return this</span><span class="s0">.shouldExitDescending(s,i)?s:</span><span class="s1">this</span><span class="s0">.parseConditional(s,r,n,t)}parseConditional(e,t,r,n){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.question)){const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">n.test=e,n.consequent=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),</span><span class="s1">this</span><span class="s0">.expect(c.colon),n.alternate=</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(),</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}parseExprOps(e){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.state.startLoc,n=</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt,i=</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(e);</span><span class="s1">return this</span><span class="s0">.shouldExitDescending(i,n)?i:</span><span class="s1">this</span><span class="s0">.parseExprOp(i,t,r,-</span><span class="s2">1</span><span class="s0">)}parseExprOp(e,t,r,n){let i=</span><span class="s1">this</span><span class="s0">.state.type.binop;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=i&amp;&amp;(</span><span class="s1">this</span><span class="s0">.prodParam.hasIn||!</span><span class="s1">this</span><span class="s0">.match(c._in))&amp;&amp;i&gt;n){const s=</span><span class="s1">this</span><span class="s0">.state.type;</span><span class="s1">if</span><span class="s0">(s===c.pipeline){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;pipelineOperator&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">this</span><span class="s0">.state.inPipeline=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.checkPipelineAtInfixOperator(e,t)}const a=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);a.left=e,a.operator=</span><span class="s1">this</span><span class="s0">.state.value,s!==c.exponent||</span><span class="s3">&quot;UnaryExpression&quot;</span><span class="s0">!==e.type||!</span><span class="s1">this</span><span class="s0">.options.createParenthesizedExpressions&amp;&amp;e.extra&amp;&amp;e.extra.parenthesized||</span><span class="s1">this</span><span class="s0">.raise(e.argument.start,x.UnexpectedTokenUnaryExponentiation);const o=s===c.logicalOR||s===c.logicalAND,l=s===c.nullishCoalescing;</span><span class="s1">if</span><span class="s0">(l&amp;&amp;(i=c.logicalAND.binop),</span><span class="s1">this</span><span class="s0">.next(),s===c.pipeline&amp;&amp;</span><span class="s3">&quot;minimal&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;pipelineOperator&quot;</span><span class="s0">,</span><span class="s3">&quot;proposal&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.name)&amp;&amp;</span><span class="s3">&quot;await&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value&amp;&amp;</span><span class="s1">this</span><span class="s0">.prodParam.hasAwait)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.UnexpectedAwaitAfterPipelineBody);a.right=</span><span class="s1">this</span><span class="s0">.parseExprOpRightExpr(s,i),</span><span class="s1">this</span><span class="s0">.finishNode(a,o||l?</span><span class="s3">&quot;LogicalExpression&quot;</span><span class="s0">:</span><span class="s3">&quot;BinaryExpression&quot;</span><span class="s0">);const p=</span><span class="s1">this</span><span class="s0">.state.type;</span><span class="s1">if</span><span class="s0">(l&amp;&amp;(p===c.logicalOR||p===c.logicalAND)||o&amp;&amp;p===c.nullishCoalescing)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.MixingCoalesceWithLogical);</span><span class="s1">return this</span><span class="s0">.parseExprOp(a,t,r,n)}</span><span class="s1">return </span><span class="s0">e}parseExprOpRightExpr(e,t){const r=</span><span class="s1">this</span><span class="s0">.state.start,n=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">if</span><span class="s0">(e===c.pipeline)</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;pipelineOperator&quot;</span><span class="s0">,</span><span class="s3">&quot;proposal&quot;</span><span class="s0">)){</span><span class="s1">case</span><span class="s3">&quot;smart&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.withTopicPermittingContext((()=&gt;</span><span class="s1">this</span><span class="s0">.parseSmartPipelineBody(</span><span class="s1">this</span><span class="s0">.parseExprOpBaseRightExpr(e,t),r,n)));</span><span class="s1">case</span><span class="s3">&quot;fsharp&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.withSoloAwaitPermittingContext((()=&gt;</span><span class="s1">this</span><span class="s0">.parseFSharpPipelineBody(t)))}</span><span class="s1">return this</span><span class="s0">.parseExprOpBaseRightExpr(e,t)}parseExprOpBaseRightExpr(e,t){const r=</span><span class="s1">this</span><span class="s0">.state.start,n=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">return this</span><span class="s0">.parseExprOp(</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(),r,n,e.rightAssociative?t-1:t)}parseMaybeUnary(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;await&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isAwaitAllowed())</span><span class="s1">return this</span><span class="s0">.parseAwait();const t=</span><span class="s1">this</span><span class="s0">.match(c.incDec),r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type.prefix){r.operator=</span><span class="s1">this</span><span class="s0">.state.value,r.prefix=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(c._throw)&amp;&amp;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;throwExpressions&quot;</span><span class="s0">);const n=</span><span class="s1">this</span><span class="s0">.match(c._delete);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),r.argument=</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(),</span><span class="s1">this</span><span class="s0">.checkExpressionErrors(e,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;n){const e=r.argument;</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type?</span><span class="s1">this</span><span class="s0">.raise(r.start,x.StrictDelete):</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">!==e.type||</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">!==e.property.type||</span><span class="s1">this</span><span class="s0">.raise(r.start,x.DeletePrivateField)}</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;UnaryExpression&quot;</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.parseUpdate(r,t,e)}parseUpdate(e,t,r){</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return this</span><span class="s0">.checkLVal(e.argument,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s3">&quot;prefix operation&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;UpdateExpression&quot;</span><span class="s0">);const n=</span><span class="s1">this</span><span class="s0">.state.start,i=</span><span class="s1">this</span><span class="s0">.state.startLoc;let s=</span><span class="s1">this</span><span class="s0">.parseExprSubscripts(r);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.checkExpressionErrors(r,!</span><span class="s2">1</span><span class="s0">))</span><span class="s1">return </span><span class="s0">s;</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.state.type.postfix&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon();){const e=</span><span class="s1">this</span><span class="s0">.startNodeAt(n,i);e.operator=</span><span class="s1">this</span><span class="s0">.state.value,e.prefix=!</span><span class="s2">1</span><span class="s0">,e.argument=s,</span><span class="s1">this</span><span class="s0">.checkLVal(s,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s3">&quot;postfix operation&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),s=</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;UpdateExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">s}parseExprSubscripts(e){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.state.startLoc,n=</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt,i=</span><span class="s1">this</span><span class="s0">.parseExprAtom(e);</span><span class="s1">return this</span><span class="s0">.shouldExitDescending(i,n)?i:</span><span class="s1">this</span><span class="s0">.parseSubscripts(i,t,r)}parseSubscripts(e,t,r,n){const i={optionalChainMember:!</span><span class="s2">1</span><span class="s0">,maybeAsyncArrow:</span><span class="s1">this</span><span class="s0">.atPossibleAsyncArrow(e),stop:!</span><span class="s2">1</span><span class="s0">};</span><span class="s1">do</span><span class="s0">{e=</span><span class="s1">this</span><span class="s0">.parseSubscript(e,t,r,n,i),i.maybeAsyncArrow=!</span><span class="s2">1</span><span class="s0">}</span><span class="s1">while</span><span class="s0">(!i.stop);</span><span class="s1">return </span><span class="s0">e}parseSubscript(e,t,r,n,i){</span><span class="s1">if</span><span class="s0">(!n&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.doubleColon))</span><span class="s1">return this</span><span class="s0">.parseBind(e,t,r,n,i);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.backQuote))</span><span class="s1">return this</span><span class="s0">.parseTaggedTemplateExpression(e,t,r,i);let s=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.questionDot)){</span><span class="s1">if</span><span class="s0">(i.optionalChainMember=s=!</span><span class="s2">0</span><span class="s0">,n&amp;&amp;</span><span class="s2">40</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.lookaheadCharCode())</span><span class="s1">return </span><span class="s0">i.stop=!</span><span class="s2">0</span><span class="s0">,e;</span><span class="s1">this</span><span class="s0">.next()}</span><span class="s1">return</span><span class="s0">!n&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.parenL)?</span><span class="s1">this</span><span class="s0">.parseCoverCallAndAsyncArrowHead(e,t,r,i,s):s||</span><span class="s1">this</span><span class="s0">.match(c.bracketL)||</span><span class="s1">this</span><span class="s0">.eat(c.dot)?</span><span class="s1">this</span><span class="s0">.parseMember(e,t,r,i,s):(i.stop=!</span><span class="s2">0</span><span class="s0">,e)}parseMember(e,t,r,n,i){const s=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r),a=</span><span class="s1">this</span><span class="s0">.eat(c.bracketL);s.object=e,s.computed=a;const o=a?</span><span class="s1">this</span><span class="s0">.parseExpression():</span><span class="s1">this</span><span class="s0">.parseMaybePrivateName(!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">return</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">===o.type&amp;&amp;(</span><span class="s3">&quot;Super&quot;</span><span class="s0">===s.object.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,x.SuperPrivateField),</span><span class="s1">this</span><span class="s0">.classScope.usePrivateName(o.id.name,o.start)),s.property=o,a&amp;&amp;</span><span class="s1">this</span><span class="s0">.expect(c.bracketR),n.optionalChainMember?(s.optional=i,</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">)}parseBind(e,t,r,n,i){const s=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">s.object=e,s.callee=</span><span class="s1">this</span><span class="s0">.parseNoCallExpr(),i.stop=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseSubscripts(</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s3">&quot;BindExpression&quot;</span><span class="s0">),t,r,n)}parseCoverCallAndAsyncArrowHead(e,t,r,n,i){const s=</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters;</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next();let a=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">a.callee=e,n.maybeAsyncArrow&amp;&amp;</span><span class="s1">this</span><span class="s0">.expressionScope.enter(</span><span class="s1">new </span><span class="s0">De(</span><span class="s2">2</span><span class="s0">)),n.optionalChainMember&amp;&amp;(a.optional=i),a.arguments=i?</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(c.parenR,!</span><span class="s2">1</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(c.parenR,n.maybeAsyncArrow,</span><span class="s3">&quot;Import&quot;</span><span class="s0">===e.type,</span><span class="s3">&quot;Super&quot;</span><span class="s0">!==e.type,a),</span><span class="s1">this</span><span class="s0">.finishCallExpression(a,n.optionalChainMember),n.maybeAsyncArrow&amp;&amp;</span><span class="s1">this</span><span class="s0">.shouldParseAsyncArrow()&amp;&amp;!i?(n.stop=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expressionScope.validateAsPattern(),</span><span class="s1">this</span><span class="s0">.expressionScope.exit(),a=</span><span class="s1">this</span><span class="s0">.parseAsyncArrowFromCallExpression(</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r),a)):(n.maybeAsyncArrow&amp;&amp;</span><span class="s1">this</span><span class="s0">.expressionScope.exit(),</span><span class="s1">this</span><span class="s0">.toReferencedArguments(a)),</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=s,a}toReferencedArguments(e,t){</span><span class="s1">this</span><span class="s0">.toReferencedListDeep(e.arguments,t)}parseTaggedTemplateExpression(e,t,r,n){const i=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">i.tag=e,i.quasi=</span><span class="s1">this</span><span class="s0">.parseTemplate(!</span><span class="s2">0</span><span class="s0">),n.optionalChainMember&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,x.OptionalChainingNoTemplate),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s3">&quot;TaggedTemplateExpression&quot;</span><span class="s0">)}atPossibleAsyncArrow(e){</span><span class="s1">return</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;async&quot;</span><span class="s0">===e.name&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.lastTokEnd===e.end&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()&amp;&amp;e.end-e.start==</span><span class="s2">5</span><span class="s0">&amp;&amp;e.start===</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt}finishCallExpression(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;Import&quot;</span><span class="s0">===e.callee.type)</span><span class="s1">if</span><span class="s0">(</span><span class="s2">2</span><span class="s0">===e.arguments.length&amp;&amp;(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;moduleAttributes&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;importAssertions&quot;</span><span class="s0">)),</span><span class="s2">0</span><span class="s0">===e.arguments.length||e.arguments.length&gt;</span><span class="s2">2</span><span class="s0">)</span><span class="s1">this</span><span class="s0">.raise(e.start,x.ImportCallArity,</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;importAssertions&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;moduleAttributes&quot;</span><span class="s0">)?</span><span class="s3">&quot;one or two arguments&quot;</span><span class="s0">:</span><span class="s3">&quot;one argument&quot;</span><span class="s0">);</span><span class="s1">else for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">,r=e.arguments;t&lt;r.length;t++){const e=r[t];</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,x.ImportCallSpreadArgument)}</span><span class="s1">return this</span><span class="s0">.finishNode(e,t?</span><span class="s3">&quot;OptionalCallExpression&quot;</span><span class="s0">:</span><span class="s3">&quot;CallExpression&quot;</span><span class="s0">)}parseCallExpressionArguments(e,t,r,n,i){const s=[];let a,o=!</span><span class="s2">0</span><span class="s0">;const l=</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=!</span><span class="s2">1</span><span class="s0">;!</span><span class="s1">this</span><span class="s0">.eat(e);){</span><span class="s1">if</span><span class="s0">(o)o=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.comma),</span><span class="s1">this</span><span class="s0">.match(e)){!r||</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;importAssertions&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;moduleAttributes&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,x.ImportCallArgumentTrailingComma),i&amp;&amp;</span><span class="s1">this</span><span class="s0">.addExtra(i,</span><span class="s3">&quot;trailingComma&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.lastTokStart),</span><span class="s1">this</span><span class="s0">.next();</span><span class="s1">break</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.match(c.parenL)&amp;&amp;!a&amp;&amp;(a=</span><span class="s1">this</span><span class="s0">.state.start),s.push(</span><span class="s1">this</span><span class="s0">.parseExprListItem(!</span><span class="s2">1</span><span class="s0">,t?</span><span class="s1">new </span><span class="s0">we:</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,t?{start:</span><span class="s2">0</span><span class="s0">}:</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,n))}</span><span class="s1">return </span><span class="s0">t&amp;&amp;a&amp;&amp;</span><span class="s1">this</span><span class="s0">.shouldParseAsyncArrow()&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=l,s}shouldParseAsyncArrow(){</span><span class="s1">return this</span><span class="s0">.match(c.arrow)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()}parseAsyncArrowFromCallExpression(e,t){</span><span class="s1">var </span><span class="s0">r;</span><span class="s1">return this</span><span class="s0">.expect(c.arrow),</span><span class="s1">this</span><span class="s0">.parseArrowExpression(e,t.arguments,!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">null</span><span class="s0">==(r=t.extra)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.trailingComma),e}parseNoCallExpr(){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">return this</span><span class="s0">.parseSubscripts(</span><span class="s1">this</span><span class="s0">.parseExprAtom(),e,t,!</span><span class="s2">0</span><span class="s0">)}parseExprAtom(e){</span><span class="s1">this</span><span class="s0">.state.type===c.slash&amp;&amp;</span><span class="s1">this</span><span class="s0">.readRegexp();const t=</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt===</span><span class="s1">this</span><span class="s0">.state.start;let r;</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s0">c._super:</span><span class="s1">return this</span><span class="s0">.parseSuper();</span><span class="s1">case </span><span class="s0">c._import:</span><span class="s1">return </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.dot)?</span><span class="s1">this</span><span class="s0">.parseImportMetaProperty(r):(</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,x.UnsupportedImport),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;Import&quot;</span><span class="s0">));</span><span class="s1">case </span><span class="s0">c._this:</span><span class="s1">return </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;ThisExpression&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.name:{const e=</span><span class="s1">this</span><span class="s0">.state.containsEsc,r=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">if</span><span class="s0">(!e&amp;&amp;</span><span class="s3">&quot;async&quot;</span><span class="s0">===r.name&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._function)){const e=</span><span class="s1">this</span><span class="s0">.state.context.length-1;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.context[e]!==A.functionStatement)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Internal error&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.state.context[e]=A.functionExpression,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseFunction(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(r),</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.name))</span><span class="s1">return this</span><span class="s0">.parseAsyncArrowUnaryFunction(r)}</span><span class="s1">return </span><span class="s0">t&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.arrow)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()?(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseArrowExpression(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(r),[r],!</span><span class="s2">1</span><span class="s0">)):r}</span><span class="s1">case </span><span class="s0">c._do:</span><span class="s1">return this</span><span class="s0">.parseDo();</span><span class="s1">case </span><span class="s0">c.regexp:{const e=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">return </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.parseLiteral(e.value,</span><span class="s3">&quot;RegExpLiteral&quot;</span><span class="s0">),r.pattern=e.pattern,r.flags=e.flags,r}</span><span class="s1">case </span><span class="s0">c.num:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;NumericLiteral&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.bigint:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;BigIntLiteral&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.decimal:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;DecimalLiteral&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.string:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._null:</span><span class="s1">return </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;NullLiteral&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._true:</span><span class="s1">case </span><span class="s0">c._false:</span><span class="s1">return this</span><span class="s0">.parseBooleanLiteral();</span><span class="s1">case </span><span class="s0">c.parenL:</span><span class="s1">return this</span><span class="s0">.parseParenAndDistinguishExpression(t);</span><span class="s1">case </span><span class="s0">c.bracketBarL:</span><span class="s1">case </span><span class="s0">c.bracketHashL:</span><span class="s1">return this</span><span class="s0">.parseArrayLike(</span><span class="s1">this</span><span class="s0">.state.type===c.bracketBarL?c.bracketBarR:c.bracketR,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">,e);</span><span class="s1">case </span><span class="s0">c.bracketL:</span><span class="s1">return this</span><span class="s0">.parseArrayLike(c.bracketR,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,e);</span><span class="s1">case </span><span class="s0">c.braceBarL:</span><span class="s1">case </span><span class="s0">c.braceHashL:</span><span class="s1">return this</span><span class="s0">.parseObjectLike(</span><span class="s1">this</span><span class="s0">.state.type===c.braceBarL?c.braceBarR:c.braceR,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">,e);</span><span class="s1">case </span><span class="s0">c.braceL:</span><span class="s1">return this</span><span class="s0">.parseObjectLike(c.braceR,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,e);</span><span class="s1">case </span><span class="s0">c._function:</span><span class="s1">return this</span><span class="s0">.parseFunctionOrFunctionSent();</span><span class="s1">case </span><span class="s0">c.at:</span><span class="s1">this</span><span class="s0">.parseDecorators();</span><span class="s1">case </span><span class="s0">c._class:</span><span class="s1">return </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.takeDecorators(r),</span><span class="s1">this</span><span class="s0">.parseClass(r,!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._new:</span><span class="s1">return this</span><span class="s0">.parseNewOrNewTarget();</span><span class="s1">case </span><span class="s0">c.backQuote:</span><span class="s1">return this</span><span class="s0">.parseTemplate(!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c.doubleColon:{r=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.next(),r.object=</span><span class="s1">null</span><span class="s0">;const e=r.callee=</span><span class="s1">this</span><span class="s0">.parseNoCallExpr();</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">===e.type)</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;BindExpression&quot;</span><span class="s0">);</span><span class="s1">throw this</span><span class="s0">.raise(e.start,x.UnsupportedBind)}</span><span class="s1">case </span><span class="s0">c.hash:{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.inPipeline)</span><span class="s1">return </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s3">&quot;smart&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;pipelineOperator&quot;</span><span class="s0">,</span><span class="s3">&quot;proposal&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r.start,x.PrimaryTopicRequiresSmartPipeline),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.primaryTopicReferenceIsAllowedInCurrentTopicContext()||</span><span class="s1">this</span><span class="s0">.raise(r.start,x.PrimaryTopicNotAllowed),</span><span class="s1">this</span><span class="s0">.registerTopicReference(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;PipelinePrimaryTopicReference&quot;</span><span class="s0">);const e=</span><span class="s1">this</span><span class="s0">.input.codePointAt(</span><span class="s1">this</span><span class="s0">.state.end);</span><span class="s1">if</span><span class="s0">(_(e)||</span><span class="s2">92</span><span class="s0">===e){const e=</span><span class="s1">this</span><span class="s0">.state.start;</span><span class="s1">if</span><span class="s0">(r=</span><span class="s1">this</span><span class="s0">.parseMaybePrivateName(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(c._in))</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;privateIn&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.classScope.usePrivateName(r.id.name,r.start);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;privateIn&quot;</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.unexpected(e);</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.PrivateInExpectedIn,r.id.name)}</span><span class="s1">return </span><span class="s0">r}}</span><span class="s1">case </span><span class="s0">c.relational:</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value){const e=</span><span class="s1">this</span><span class="s0">.input.codePointAt(</span><span class="s1">this</span><span class="s0">.nextTokenStart());(_(e)||</span><span class="s2">62</span><span class="s0">===e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.expectOnePlugin([</span><span class="s3">&quot;jsx&quot;</span><span class="s0">,</span><span class="s3">&quot;flow&quot;</span><span class="s0">,</span><span class="s3">&quot;typescript&quot;</span><span class="s0">])}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw this</span><span class="s0">.unexpected()}}parseAsyncArrowUnaryFunction(e){const t=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e);</span><span class="s1">this</span><span class="s0">.prodParam.enter(oe(!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.prodParam.hasYield));const r=[</span><span class="s1">this</span><span class="s0">.parseIdentifier()];</span><span class="s1">return this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.LineTerminatorBeforeArrow),</span><span class="s1">this</span><span class="s0">.expect(c.arrow),</span><span class="s1">this</span><span class="s0">.parseArrowExpression(t,r,!</span><span class="s2">0</span><span class="s0">),t}parseDo(){</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;doExpressions&quot;</span><span class="s0">);const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.next();const t=</span><span class="s1">this</span><span class="s0">.state.labels;</span><span class="s1">return this</span><span class="s0">.state.labels=[],e.body=</span><span class="s1">this</span><span class="s0">.parseBlock(),</span><span class="s1">this</span><span class="s0">.state.labels=t,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DoExpression&quot;</span><span class="s0">)}parseSuper(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),!</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.scope.allowDirectSuper||</span><span class="s1">this</span><span class="s0">.options.allowSuperOutsideMethod?</span><span class="s1">this</span><span class="s0">.scope.allowSuper||</span><span class="s1">this</span><span class="s0">.options.allowSuperOutsideMethod||</span><span class="s1">this</span><span class="s0">.raise(e.start,x.UnexpectedSuper):</span><span class="s1">this</span><span class="s0">.raise(e.start,x.SuperNotAllowed),</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.match(c.bracketL)||</span><span class="s1">this</span><span class="s0">.match(c.dot)||</span><span class="s1">this</span><span class="s0">.raise(e.start,x.UnsupportedSuper),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;Super&quot;</span><span class="s0">)}parseBooleanLiteral(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.value=</span><span class="s1">this</span><span class="s0">.match(c._true),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;BooleanLiteral&quot;</span><span class="s0">)}parseMaybePrivateName(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.hash)){</span><span class="s1">this</span><span class="s0">.expectOnePlugin([</span><span class="s3">&quot;classPrivateProperties&quot;</span><span class="s0">,</span><span class="s3">&quot;classPrivateMethods&quot;</span><span class="s0">]),e||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.UnexpectedPrivateField);const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.assertNoSpace(</span><span class="s3">&quot;Unexpected space between # and identifier&quot;</span><span class="s0">),t.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">)}parseFunctionOrFunctionSent(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.prodParam.hasYield&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.dot)){const t=</span><span class="s1">this</span><span class="s0">.createIdentifier(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e),</span><span class="s3">&quot;function&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseMetaProperty(e,t,</span><span class="s3">&quot;sent&quot;</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.parseFunction(e)}parseMetaProperty(e,t,r){e.meta=t,</span><span class="s3">&quot;function&quot;</span><span class="s0">===t.name&amp;&amp;</span><span class="s3">&quot;sent&quot;</span><span class="s0">===r&amp;&amp;(</span><span class="s1">this</span><span class="s0">.isContextual(r)?</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;functionSent&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;functionSent&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.unexpected());const n=</span><span class="s1">this</span><span class="s0">.state.containsEsc;</span><span class="s1">return </span><span class="s0">e.property=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),(e.property.name!==r||n)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.property.start,x.UnsupportedMetaProperty,t.name,r),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;MetaProperty&quot;</span><span class="s0">)}parseImportMetaProperty(e){const t=</span><span class="s1">this</span><span class="s0">.createIdentifier(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e),</span><span class="s3">&quot;import&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;meta&quot;</span><span class="s0">)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.inModule||</span><span class="s1">this</span><span class="s0">.raiseWithData(t.start,{code:</span><span class="s3">&quot;BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED&quot;</span><span class="s0">},x.ImportMetaOutsideModule),</span><span class="s1">this</span><span class="s0">.sawUnambiguousESM=!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parseMetaProperty(e,t,</span><span class="s3">&quot;meta&quot;</span><span class="s0">)}parseLiteral(e,t,r,n){r=r||</span><span class="s1">this</span><span class="s0">.state.start,n=n||</span><span class="s1">this</span><span class="s0">.state.startLoc;const i=</span><span class="s1">this</span><span class="s0">.startNodeAt(r,n);</span><span class="s1">return this</span><span class="s0">.addExtra(i,</span><span class="s3">&quot;rawValue&quot;</span><span class="s0">,e),</span><span class="s1">this</span><span class="s0">.addExtra(i,</span><span class="s3">&quot;raw&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.input.slice(r,</span><span class="s1">this</span><span class="s0">.state.end)),i.value=e,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(i,t)}parseParenAndDistinguishExpression(e){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.state.startLoc;let n;</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expressionScope.enter(</span><span class="s1">new </span><span class="s0">De(</span><span class="s2">1</span><span class="s0">));const i=</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters,s=</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody;</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=!</span><span class="s2">1</span><span class="s0">;const a=</span><span class="s1">this</span><span class="s0">.state.start,o=</span><span class="s1">this</span><span class="s0">.state.startLoc,l=[],p=</span><span class="s1">new </span><span class="s0">we,u={start:</span><span class="s2">0</span><span class="s0">};let d,h,f=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.match(c.parenR);){</span><span class="s1">if</span><span class="s0">(f)f=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.comma,u.start||</span><span class="s1">null</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(c.parenR)){h=</span><span class="s1">this</span><span class="s0">.state.start;</span><span class="s1">break</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.ellipsis)){const e=</span><span class="s1">this</span><span class="s0">.state.start,t=</span><span class="s1">this</span><span class="s0">.state.startLoc;d=</span><span class="s1">this</span><span class="s0">.state.start,l.push(</span><span class="s1">this</span><span class="s0">.parseParenItem(</span><span class="s1">this</span><span class="s0">.parseRestBinding(),e,t)),</span><span class="s1">this</span><span class="s0">.checkCommaAfterRest(</span><span class="s2">41</span><span class="s0">);</span><span class="s1">break</span><span class="s0">}l.push(</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(p,</span><span class="s1">this</span><span class="s0">.parseParenItem,u))}const m=</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,y=</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc;</span><span class="s1">this</span><span class="s0">.expect(c.parenR),</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=i,</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=s;let T=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">if</span><span class="s0">(e&amp;&amp;</span><span class="s1">this</span><span class="s0">.shouldParseArrow()&amp;&amp;(T=</span><span class="s1">this</span><span class="s0">.parseArrow(T))){</span><span class="s1">this</span><span class="s0">.expressionScope.validateAsPattern(),</span><span class="s1">this</span><span class="s0">.expressionScope.exit();</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">;e&lt;l.length;e++){const t=l[e];t.extra&amp;&amp;t.extra.parenthesized&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(t.extra.parenStart)}</span><span class="s1">return this</span><span class="s0">.parseArrowExpression(T,l,!</span><span class="s2">1</span><span class="s0">),T}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expressionScope.exit(),l.length||</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">this</span><span class="s0">.state.lastTokStart),h&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(h),d&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(d),</span><span class="s1">this</span><span class="s0">.checkExpressionErrors(p,!</span><span class="s2">0</span><span class="s0">),u.start&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(u.start),</span><span class="s1">this</span><span class="s0">.toReferencedListDeep(l,!</span><span class="s2">0</span><span class="s0">),l.length&gt;</span><span class="s2">1</span><span class="s0">?(n=</span><span class="s1">this</span><span class="s0">.startNodeAt(a,o),n.expressions=l,</span><span class="s1">this</span><span class="s0">.finishNodeAt(n,</span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s0">,m,y)):n=l[</span><span class="s2">0</span><span class="s0">],!</span><span class="s1">this</span><span class="s0">.options.createParenthesizedExpressions)</span><span class="s1">return this</span><span class="s0">.addExtra(n,</span><span class="s3">&quot;parenthesized&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.addExtra(n,</span><span class="s3">&quot;parenStart&quot;</span><span class="s0">,t),n;const b=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);</span><span class="s1">return </span><span class="s0">b.expression=n,</span><span class="s1">this</span><span class="s0">.finishNode(b,</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">),b}shouldParseArrow(){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()}parseArrow(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.arrow))</span><span class="s1">return </span><span class="s0">e}parseParenItem(e,t,r){</span><span class="s1">return </span><span class="s0">e}parseNewOrNewTarget(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.dot)){const t=</span><span class="s1">this</span><span class="s0">.createIdentifier(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e),</span><span class="s3">&quot;new&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.next();const r=</span><span class="s1">this</span><span class="s0">.parseMetaProperty(e,t,</span><span class="s3">&quot;target&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.scope.inNonArrowFunction&amp;&amp;!</span><span class="s1">this</span><span class="s0">.scope.inClass){let e=x.UnexpectedNewTarget;</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;classProperties&quot;</span><span class="s0">)&amp;&amp;(e+=</span><span class="s3">&quot; or class properties&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.raise(r.start,e)}</span><span class="s1">return </span><span class="s0">r}</span><span class="s1">return this</span><span class="s0">.parseNew(e)}parseNew(e){</span><span class="s1">return </span><span class="s0">e.callee=</span><span class="s1">this</span><span class="s0">.parseNoCallExpr(),</span><span class="s3">&quot;Import&quot;</span><span class="s0">===e.callee.type?</span><span class="s1">this</span><span class="s0">.raise(e.callee.start,x.ImportCallNotNewExpression):</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">===e.callee.type||</span><span class="s3">&quot;OptionalCallExpression&quot;</span><span class="s0">===e.callee.type?</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,x.OptionalChainingNoNew):</span><span class="s1">this</span><span class="s0">.eat(c.questionDot)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.OptionalChainingNoNew),</span><span class="s1">this</span><span class="s0">.parseNewArguments(e),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;NewExpression&quot;</span><span class="s0">)}parseNewArguments(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.parenL)){const t=</span><span class="s1">this</span><span class="s0">.parseExprList(c.parenR);</span><span class="s1">this</span><span class="s0">.toReferencedList(t),e.arguments=t}</span><span class="s1">else </span><span class="s0">e.arguments=[]}parseTemplateElement(e){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return null</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.value&amp;&amp;(e||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start+</span><span class="s2">1</span><span class="s0">,x.InvalidEscapeSequenceTemplate)),t.value={raw:</span><span class="s1">this</span><span class="s0">.input.slice(</span><span class="s1">this</span><span class="s0">.state.start,</span><span class="s1">this</span><span class="s0">.state.end).replace(/\r\n?/g,</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">),cooked:</span><span class="s1">this</span><span class="s0">.state.value},</span><span class="s1">this</span><span class="s0">.next(),t.tail=</span><span class="s1">this</span><span class="s0">.match(c.backQuote),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TemplateElement&quot;</span><span class="s0">)}parseTemplate(e){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.next(),t.expressions=[];let r=</span><span class="s1">this</span><span class="s0">.parseTemplateElement(e);</span><span class="s1">for</span><span class="s0">(t.quasis=[r];!r.tail;)</span><span class="s1">this</span><span class="s0">.expect(c.dollarBraceL),t.expressions.push(</span><span class="s1">this</span><span class="s0">.parseTemplateSubstitution()),</span><span class="s1">this</span><span class="s0">.expect(c.braceR),t.quasis.push(r=</span><span class="s1">this</span><span class="s0">.parseTemplateElement(e));</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;TemplateLiteral&quot;</span><span class="s0">)}parseTemplateSubstitution(){</span><span class="s1">return this</span><span class="s0">.parseExpression()}parseObjectLike(e,t,r,n){r&amp;&amp;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">);const i=</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody;</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=!</span><span class="s2">1</span><span class="s0">;const s=Object.create(</span><span class="s1">null</span><span class="s0">);let a=!</span><span class="s2">0</span><span class="s0">;const o=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">for</span><span class="s0">(o.properties=[],</span><span class="s1">this</span><span class="s0">.next();!</span><span class="s1">this</span><span class="s0">.match(e);){</span><span class="s1">if</span><span class="s0">(a)a=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.comma),</span><span class="s1">this</span><span class="s0">.match(e)){</span><span class="s1">this</span><span class="s0">.addExtra(o,</span><span class="s3">&quot;trailingComma&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.lastTokStart);</span><span class="s1">break</span><span class="s0">}const i=</span><span class="s1">this</span><span class="s0">.parsePropertyDefinition(t,n);t||</span><span class="s1">this</span><span class="s0">.checkProto(i,r,s,n),r&amp;&amp;</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">!==i.type&amp;&amp;</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">!==i.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(i.start,x.InvalidRecordProperty),i.shorthand&amp;&amp;</span><span class="s1">this</span><span class="s0">.addExtra(i,</span><span class="s3">&quot;shorthand&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),o.properties.push(i)}</span><span class="s1">this</span><span class="s0">.state.exprAllowed=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=i;let l=</span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s0">;</span><span class="s1">return </span><span class="s0">t?l=</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">:r&amp;&amp;(l=</span><span class="s3">&quot;RecordExpression&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(o,l)}maybeAsyncOrAccessorProp(e){</span><span class="s1">return</span><span class="s0">!e.computed&amp;&amp;</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.key.type&amp;&amp;(</span><span class="s1">this</span><span class="s0">.isLiteralPropertyName()||</span><span class="s1">this</span><span class="s0">.match(c.bracketL)||</span><span class="s1">this</span><span class="s0">.match(c.star))}parsePropertyDefinition(e,t){let r=[];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.at))</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.UnsupportedPropertyDecorator);</span><span class="s1">this</span><span class="s0">.match(c.at);)r.push(</span><span class="s1">this</span><span class="s0">.parseDecorator());const n=</span><span class="s1">this</span><span class="s0">.startNode();let i,s,a=!</span><span class="s2">1</span><span class="s0">,o=!</span><span class="s2">1</span><span class="s0">,l=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.ellipsis))</span><span class="s1">return </span><span class="s0">r.length&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),e?(</span><span class="s1">this</span><span class="s0">.next(),n.argument=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkCommaAfterRest(</span><span class="s2">125</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.parseSpread();r.length&amp;&amp;(n.decorators=r,r=[]),n.method=!</span><span class="s2">1</span><span class="s0">,(e||t)&amp;&amp;(i=</span><span class="s1">this</span><span class="s0">.state.start,s=</span><span class="s1">this</span><span class="s0">.state.startLoc),e||(a=</span><span class="s1">this</span><span class="s0">.eat(c.star));const p=</span><span class="s1">this</span><span class="s0">.state.containsEsc,u=</span><span class="s1">this</span><span class="s0">.parsePropertyName(n,!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!e&amp;&amp;!a&amp;&amp;!p&amp;&amp;</span><span class="s1">this</span><span class="s0">.maybeAsyncOrAccessorProp(n)){const e=u.name;</span><span class="s3">&quot;async&quot;</span><span class="s0">!==e||</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()||(o=!</span><span class="s2">0</span><span class="s0">,a=</span><span class="s1">this</span><span class="s0">.eat(c.star),</span><span class="s1">this</span><span class="s0">.parsePropertyName(n,!</span><span class="s2">1</span><span class="s0">)),</span><span class="s3">&quot;get&quot;</span><span class="s0">!==e&amp;&amp;</span><span class="s3">&quot;set&quot;</span><span class="s0">!==e||(l=!</span><span class="s2">0</span><span class="s0">,n.kind=e,</span><span class="s1">this</span><span class="s0">.match(c.star)&amp;&amp;(a=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.AccessorIsGenerator,e),</span><span class="s1">this</span><span class="s0">.next()),</span><span class="s1">this</span><span class="s0">.parsePropertyName(n,!</span><span class="s2">1</span><span class="s0">))}</span><span class="s1">return this</span><span class="s0">.parseObjPropValue(n,i,s,a,o,e,l,t),n}getGetterSetterExpectedParamCount(e){</span><span class="s1">return</span><span class="s3">&quot;get&quot;</span><span class="s0">===e.kind?</span><span class="s2">0</span><span class="s0">:</span><span class="s2">1</span><span class="s0">}getObjectOrClassMethodParams(e){</span><span class="s1">return </span><span class="s0">e.params}checkGetterSetterParams(e){</span><span class="s1">var </span><span class="s0">t;const r=</span><span class="s1">this</span><span class="s0">.getGetterSetterExpectedParamCount(e),n=</span><span class="s1">this</span><span class="s0">.getObjectOrClassMethodParams(e),i=e.start;n.length!==r&amp;&amp;(</span><span class="s3">&quot;get&quot;</span><span class="s0">===e.kind?</span><span class="s1">this</span><span class="s0">.raise(i,x.BadGetterArity):</span><span class="s1">this</span><span class="s0">.raise(i,x.BadSetterArity)),</span><span class="s3">&quot;set&quot;</span><span class="s0">===e.kind&amp;&amp;</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">===(</span><span class="s1">null</span><span class="s0">==(t=n[n.length-1])?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.type)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(i,x.BadSetterRestParameter)}parseObjectMethod(e,t,r,n,i){</span><span class="s1">return </span><span class="s0">i?(</span><span class="s1">this</span><span class="s0">.parseMethod(e,t,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.checkGetterSetterParams(e),e):r||t||</span><span class="s1">this</span><span class="s0">.match(c.parenL)?(n&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),e.kind=</span><span class="s3">&quot;method&quot;</span><span class="s0">,e.method=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseMethod(e,t,r,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">)):</span><span class="s1">void </span><span class="s2">0</span><span class="s0">}parseObjectProperty(e,t,r,n,i){</span><span class="s1">return </span><span class="s0">e.shorthand=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.eat(c.colon)?(e.value=n?</span><span class="s1">this</span><span class="s0">.parseMaybeDefault(</span><span class="s1">this</span><span class="s0">.state.start,</span><span class="s1">this</span><span class="s0">.state.startLoc):</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(i),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">)):e.computed||</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==e.key.type?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:(</span><span class="s1">this</span><span class="s0">.checkReservedWord(e.key.name,e.key.start,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),n?e.value=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault(t,r,e.key.__clone()):</span><span class="s1">this</span><span class="s0">.match(c.eq)&amp;&amp;i?(-</span><span class="s2">1</span><span class="s0">===i.shorthandAssign&amp;&amp;(i.shorthandAssign=</span><span class="s1">this</span><span class="s0">.state.start),e.value=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault(t,r,e.key.__clone())):e.value=e.key.__clone(),e.shorthand=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">))}parseObjPropValue(e,t,r,n,i,s,a,o){const l=</span><span class="s1">this</span><span class="s0">.parseObjectMethod(e,n,i,s,a)||</span><span class="s1">this</span><span class="s0">.parseObjectProperty(e,t,r,s,o);</span><span class="s1">return </span><span class="s0">l||</span><span class="s1">this</span><span class="s0">.unexpected(),l}parsePropertyName(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.bracketL))e.computed=!</span><span class="s2">0</span><span class="s0">,e.key=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),</span><span class="s1">this</span><span class="s0">.expect(c.bracketR);</span><span class="s1">else</span><span class="s0">{const r=</span><span class="s1">this</span><span class="s0">.state.inPropertyName;</span><span class="s1">this</span><span class="s0">.state.inPropertyName=!</span><span class="s2">0</span><span class="s0">,e.key=</span><span class="s1">this</span><span class="s0">.match(c.num)||</span><span class="s1">this</span><span class="s0">.match(c.string)||</span><span class="s1">this</span><span class="s0">.match(c.bigint)||</span><span class="s1">this</span><span class="s0">.match(c.decimal)?</span><span class="s1">this</span><span class="s0">.parseExprAtom():</span><span class="s1">this</span><span class="s0">.parseMaybePrivateName(t),</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">!==e.key.type&amp;&amp;(e.computed=!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.inPropertyName=r}</span><span class="s1">return </span><span class="s0">e.key}initFunction(e,t){e.id=</span><span class="s1">null</span><span class="s0">,e.generator=!</span><span class="s2">1</span><span class="s0">,e.async=!!t}parseMethod(e,t,r,n,i,s,a=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.initFunction(e,r),e.generator=!!t;const o=n;</span><span class="s1">return this</span><span class="s0">.scope.enter(</span><span class="s2">18</span><span class="s0">|(a?</span><span class="s2">64</span><span class="s0">:</span><span class="s2">0</span><span class="s0">)|(i?</span><span class="s2">32</span><span class="s0">:</span><span class="s2">0</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.prodParam.enter(oe(r,e.generator)),</span><span class="s1">this</span><span class="s0">.parseFunctionParams(e,o),</span><span class="s1">this</span><span class="s0">.parseFunctionBodyAndFinish(e,s,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit(),e}parseArrayLike(e,t,r,n){r&amp;&amp;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">);const i=</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody;</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=!</span><span class="s2">1</span><span class="s0">;const s=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),s.elements=</span><span class="s1">this</span><span class="s0">.parseExprList(e,!r,n,s),</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=i,</span><span class="s1">this</span><span class="s0">.finishNode(s,r?</span><span class="s3">&quot;TupleExpression&quot;</span><span class="s0">:</span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s0">)}parseArrowExpression(e,t,r,n){</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">6</span><span class="s0">);let i=oe(r,!</span><span class="s2">1</span><span class="s0">);!</span><span class="s1">this</span><span class="s0">.match(c.bracketL)&amp;&amp;</span><span class="s1">this</span><span class="s0">.prodParam.hasIn&amp;&amp;(i|=</span><span class="s2">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.enter(i),</span><span class="s1">this</span><span class="s0">.initFunction(e,r);const s=</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters;</span><span class="s1">return </span><span class="s0">t&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.setArrowFunctionParameters(e,t,n)),</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseFunctionBody(e,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=s,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s0">)}setArrowFunctionParameters(e,t,r){e.params=</span><span class="s1">this</span><span class="s0">.toAssignableList(t,r)}parseFunctionBodyAndFinish(e,t,r=!</span><span class="s2">1</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.parseFunctionBody(e,!</span><span class="s2">1</span><span class="s0">,r),</span><span class="s1">this</span><span class="s0">.finishNode(e,t)}parseFunctionBody(e,t,r=!</span><span class="s2">1</span><span class="s0">){const n=t&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.braceL);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expressionScope.enter(Le()),n)e.body=</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(),</span><span class="s1">this</span><span class="s0">.checkParams(e,!</span><span class="s2">1</span><span class="s0">,t,!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">else</span><span class="s0">{const n=</span><span class="s1">this</span><span class="s0">.state.strict,i=</span><span class="s1">this</span><span class="s0">.state.labels;</span><span class="s1">this</span><span class="s0">.state.labels=[],</span><span class="s1">this</span><span class="s0">.prodParam.enter(</span><span class="s2">4</span><span class="s0">|</span><span class="s1">this</span><span class="s0">.prodParam.currentFlags()),e.body=</span><span class="s1">this</span><span class="s0">.parseBlock(!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,(i=&gt;{const s=!</span><span class="s1">this</span><span class="s0">.isSimpleParamList(e.params);</span><span class="s1">if</span><span class="s0">(i&amp;&amp;s){const t=</span><span class="s3">&quot;method&quot;</span><span class="s0">!==e.kind&amp;&amp;</span><span class="s3">&quot;constructor&quot;</span><span class="s0">!==e.kind||!e.key?e.start:e.key.end;</span><span class="s1">this</span><span class="s0">.raise(t,x.IllegalLanguageModeDirective)}const a=!n&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.strict;</span><span class="s1">this</span><span class="s0">.checkParams(e,!(</span><span class="s1">this</span><span class="s0">.state.strict||t||r||s),t,a),</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;e.id&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,</span><span class="s2">65</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s3">&quot;function name&quot;</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,a)})),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.expressionScope.exit(),</span><span class="s1">this</span><span class="s0">.state.labels=i}}isSimpleParamList(e){</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">,r=e.length;t&lt;r;t++)</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==e[t].type)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}checkParams(e,t,r,n=!</span><span class="s2">0</span><span class="s0">){const i=Object.create(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s2">0</span><span class="s0">;r&lt;e.params.length;r++)</span><span class="s1">this</span><span class="s0">.checkLVal(e.params[r],</span><span class="s2">5</span><span class="s0">,t?</span><span class="s1">null</span><span class="s0">:i,</span><span class="s3">&quot;function parameter list&quot;</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,n)}parseExprList(e,t,r,n){const i=[];let s=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.eat(e);){</span><span class="s1">if</span><span class="s0">(s)s=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.comma),</span><span class="s1">this</span><span class="s0">.match(e)){n&amp;&amp;</span><span class="s1">this</span><span class="s0">.addExtra(n,</span><span class="s3">&quot;trailingComma&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.lastTokStart),</span><span class="s1">this</span><span class="s0">.next();</span><span class="s1">break</span><span class="s0">}i.push(</span><span class="s1">this</span><span class="s0">.parseExprListItem(t,r))}</span><span class="s1">return </span><span class="s0">i}parseExprListItem(e,t,r,n){let i;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.comma))e||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.pos,x.UnexpectedToken,</span><span class="s3">&quot;,&quot;</span><span class="s0">),i=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.ellipsis)){const e=</span><span class="s1">this</span><span class="s0">.state.start,n=</span><span class="s1">this</span><span class="s0">.state.startLoc;i=</span><span class="s1">this</span><span class="s0">.parseParenItem(</span><span class="s1">this</span><span class="s0">.parseSpread(t,r),e,n)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.question)){</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;partialApplication&quot;</span><span class="s0">),n||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.UnexpectedArgumentPlaceholder);const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.next(),i=</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ArgumentPlaceholder&quot;</span><span class="s0">)}</span><span class="s1">else </span><span class="s0">i=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(t,</span><span class="s1">this</span><span class="s0">.parseParenItem,r);</span><span class="s1">return </span><span class="s0">i}parseIdentifier(e){const t=</span><span class="s1">this</span><span class="s0">.startNode(),r=</span><span class="s1">this</span><span class="s0">.parseIdentifierName(t.start,e);</span><span class="s1">return this</span><span class="s0">.createIdentifier(t,r)}createIdentifier(e,t){</span><span class="s1">return </span><span class="s0">e.name=t,e.loc.identifierName=t,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">)}parseIdentifierName(e,t){let r;const{start:n,type:i}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">if</span><span class="s0">(i===c.name)r=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!i.keyword)</span><span class="s1">throw this</span><span class="s0">.unexpected();{r=i.keyword;const e=</span><span class="s1">this</span><span class="s0">.curContext();i!==c._class&amp;&amp;i!==c._function||e!==A.functionStatement&amp;&amp;e!==A.functionExpression||</span><span class="s1">this</span><span class="s0">.state.context.pop()}}</span><span class="s1">return </span><span class="s0">t?</span><span class="s1">this</span><span class="s0">.state.type=c.name:</span><span class="s1">this</span><span class="s0">.checkReservedWord(r,n,!!i.keyword,!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),r}checkReservedWord(e,t,r,n){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.prodParam.hasYield&amp;&amp;</span><span class="s3">&quot;yield&quot;</span><span class="s0">===e)</span><span class="s1">this</span><span class="s0">.raise(t,x.YieldBindingIdentifier);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;await&quot;</span><span class="s0">===e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.prodParam.hasAwait)</span><span class="s1">return void this</span><span class="s0">.raise(t,x.AwaitBindingIdentifier);</span><span class="s1">this</span><span class="s0">.expressionScope.recordAsyncArrowParametersError(t,x.AwaitBindingIdentifier)}!</span><span class="s1">this</span><span class="s0">.scope.inClass||</span><span class="s1">this</span><span class="s0">.scope.inNonArrowFunction||</span><span class="s3">&quot;arguments&quot;</span><span class="s0">!==e?r&amp;&amp;K(e)?</span><span class="s1">this</span><span class="s0">.raise(t,x.UnexpectedKeyword,e):(</span><span class="s1">this</span><span class="s0">.state.strict?n?V:R:B)(e,</span><span class="s1">this</span><span class="s0">.inModule)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.prodParam.hasAwait||</span><span class="s3">&quot;await&quot;</span><span class="s0">!==e?</span><span class="s1">this</span><span class="s0">.raise(t,x.UnexpectedReservedWord,e):</span><span class="s1">this</span><span class="s0">.raise(t,</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;topLevelAwait&quot;</span><span class="s0">)?x.AwaitNotInAsyncContext:x.AwaitNotInAsyncFunction)):</span><span class="s1">this</span><span class="s0">.raise(t,x.ArgumentsInClass)}}isAwaitAllowed(){</span><span class="s1">return this</span><span class="s0">.scope.inFunction?</span><span class="s1">this</span><span class="s0">.prodParam.hasAwait:!!</span><span class="s1">this</span><span class="s0">.options.allowAwaitOutsideFunction||!!</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;topLevelAwait&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;</span><span class="s1">this</span><span class="s0">.prodParam.hasAwait}parseAwait(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expressionScope.recordParameterInitializerError(e.start,x.AwaitExpressionFormalParameter),</span><span class="s1">this</span><span class="s0">.eat(c.star)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,x.ObsoleteAwaitStar),</span><span class="s1">this</span><span class="s0">.scope.inFunction||</span><span class="s1">this</span><span class="s0">.options.allowAwaitOutsideFunction||(</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()||</span><span class="s1">this</span><span class="s0">.match(c.plusMin)||</span><span class="s1">this</span><span class="s0">.match(c.parenL)||</span><span class="s1">this</span><span class="s0">.match(c.bracketL)||</span><span class="s1">this</span><span class="s0">.match(c.backQuote)||</span><span class="s1">this</span><span class="s0">.match(c.regexp)||</span><span class="s1">this</span><span class="s0">.match(c.slash)||</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;v8intrinsic&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(c.modulo)?</span><span class="s1">this</span><span class="s0">.ambiguousScriptDifferentAst=!</span><span class="s2">0</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.sawUnambiguousESM=!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.soloAwait||(e.argument=</span><span class="s1">this</span><span class="s0">.parseMaybeUnary()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;AwaitExpression&quot;</span><span class="s0">)}parseYield(){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expressionScope.recordParameterInitializerError(e.start,x.YieldInParameter),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.semi)||!</span><span class="s1">this</span><span class="s0">.match(c.star)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.type.startsExpr||</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()?(e.delegate=!</span><span class="s2">1</span><span class="s0">,e.argument=</span><span class="s1">null</span><span class="s0">):(e.delegate=</span><span class="s1">this</span><span class="s0">.eat(c.star),e.argument=</span><span class="s1">this</span><span class="s0">.parseMaybeAssign()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;YieldExpression&quot;</span><span class="s0">)}checkPipelineAtInfixOperator(e,t){</span><span class="s3">&quot;smart&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;pipelineOperator&quot;</span><span class="s0">,</span><span class="s3">&quot;proposal&quot;</span><span class="s0">)&amp;&amp;</span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,x.PipelineHeadSequenceExpression)}parseSmartPipelineBody(e,t,r){</span><span class="s1">return this</span><span class="s0">.checkSmartPipelineBodyEarlyErrors(e,t),</span><span class="s1">this</span><span class="s0">.parseSmartPipelineBodyInStyle(e,t,r)}checkSmartPipelineBodyEarlyErrors(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.arrow))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.PipelineBodyNoArrow);</span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t,x.PipelineBodySequenceExpression)}parseSmartPipelineBodyInStyle(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r),i=</span><span class="s1">this</span><span class="s0">.isSimpleReference(e);</span><span class="s1">return </span><span class="s0">i?n.callee=e:(</span><span class="s1">this</span><span class="s0">.topicReferenceWasUsedInCurrentTopicContext()||</span><span class="s1">this</span><span class="s0">.raise(t,x.PipelineTopicUnused),n.expression=e),</span><span class="s1">this</span><span class="s0">.finishNode(n,i?</span><span class="s3">&quot;PipelineBareFunction&quot;</span><span class="s0">:</span><span class="s3">&quot;PipelineTopicExpression&quot;</span><span class="s0">)}isSimpleReference(e){</span><span class="s1">switch</span><span class="s0">(e.type){</span><span class="s1">case</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!e.computed&amp;&amp;</span><span class="s1">this</span><span class="s0">.isSimpleReference(e.object);</span><span class="s1">case</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}}withTopicPermittingContext(e){const t=</span><span class="s1">this</span><span class="s0">.state.topicContext;</span><span class="s1">this</span><span class="s0">.state.topicContext={maxNumOfResolvableTopics:</span><span class="s2">1</span><span class="s0">,maxTopicIndex:</span><span class="s1">null</span><span class="s0">};</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.topicContext=t}}withTopicForbiddingContext(e){const t=</span><span class="s1">this</span><span class="s0">.state.topicContext;</span><span class="s1">this</span><span class="s0">.state.topicContext={maxNumOfResolvableTopics:</span><span class="s2">0</span><span class="s0">,maxTopicIndex:</span><span class="s1">null</span><span class="s0">};</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.topicContext=t}}withSoloAwaitPermittingContext(e){const t=</span><span class="s1">this</span><span class="s0">.state.soloAwait;</span><span class="s1">this</span><span class="s0">.state.soloAwait=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.soloAwait=t}}allowInAnd(e){const t=</span><span class="s1">this</span><span class="s0">.prodParam.currentFlags();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">8</span><span class="s0">&amp;~t){</span><span class="s1">this</span><span class="s0">.prodParam.enter(</span><span class="s2">8</span><span class="s0">|t);</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.prodParam.exit()}}</span><span class="s1">return </span><span class="s0">e()}disallowInAnd(e){const t=</span><span class="s1">this</span><span class="s0">.prodParam.currentFlags();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">8</span><span class="s0">&amp;t){</span><span class="s1">this</span><span class="s0">.prodParam.enter(-</span><span class="s2">9</span><span class="s0">&amp;t);</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.prodParam.exit()}}</span><span class="s1">return </span><span class="s0">e()}registerTopicReference(){</span><span class="s1">this</span><span class="s0">.state.topicContext.maxTopicIndex=</span><span class="s2">0</span><span class="s0">}primaryTopicReferenceIsAllowedInCurrentTopicContext(){</span><span class="s1">return this</span><span class="s0">.state.topicContext.maxNumOfResolvableTopics&gt;=</span><span class="s2">1</span><span class="s0">}topicReferenceWasUsedInCurrentTopicContext(){</span><span class="s1">return null</span><span class="s0">!=</span><span class="s1">this</span><span class="s0">.state.topicContext.maxTopicIndex&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.topicContext.maxTopicIndex&gt;=</span><span class="s2">0</span><span class="s0">}parseFSharpPipelineBody(e){const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt=</span><span class="s1">this</span><span class="s0">.state.start;const n=</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody;</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=!</span><span class="s2">0</span><span class="s0">;const i=</span><span class="s1">this</span><span class="s0">.parseExprOp(</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(),t,r,e);</span><span class="s1">return this</span><span class="s0">.state.inFSharpPipelineDirectBody=n,i}}const je={kind:</span><span class="s3">&quot;loop&quot;</span><span class="s0">},Fe={kind:</span><span class="s3">&quot;switch&quot;</span><span class="s0">},Be=/[\uD800-\uDFFF]/u;class Re extends Me{parseTopLevel(e,t){</span><span class="s1">if</span><span class="s0">(t.sourceType=</span><span class="s1">this</span><span class="s0">.options.sourceType,t.interpreter=</span><span class="s1">this</span><span class="s0">.parseInterpreterDirective(),</span><span class="s1">this</span><span class="s0">.parseBlockBody(t,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">,c.eof),</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;!</span><span class="s1">this</span><span class="s0">.options.allowUndeclaredExports&amp;&amp;</span><span class="s1">this</span><span class="s0">.scope.undefinedExports.size&gt;</span><span class="s2">0</span><span class="s0">)</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">,t=Array.from(</span><span class="s1">this</span><span class="s0">.scope.undefinedExports);e&lt;t.length;e++){const[r]=t[e],n=</span><span class="s1">this</span><span class="s0">.scope.undefinedExports.get(r);</span><span class="s1">this</span><span class="s0">.raise(n,x.ModuleExportUndefined,r)}</span><span class="s1">return </span><span class="s0">e.program=</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;Program&quot;</span><span class="s0">),e.comments=</span><span class="s1">this</span><span class="s0">.state.comments,</span><span class="s1">this</span><span class="s0">.options.tokens&amp;&amp;(e.tokens=</span><span class="s1">this</span><span class="s0">.tokens),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;File&quot;</span><span class="s0">)}stmtToDirective(e){const t=e.expression,r=</span><span class="s1">this</span><span class="s0">.startNodeAt(t.start,t.loc.start),n=</span><span class="s1">this</span><span class="s0">.startNodeAt(e.start,e.loc.start),i=</span><span class="s1">this</span><span class="s0">.input.slice(t.start,t.end),s=r.value=i.slice(</span><span class="s2">1</span><span class="s0">,-</span><span class="s2">1</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.addExtra(r,</span><span class="s3">&quot;raw&quot;</span><span class="s0">,i),</span><span class="s1">this</span><span class="s0">.addExtra(r,</span><span class="s3">&quot;rawValue&quot;</span><span class="s0">,s),n.value=</span><span class="s1">this</span><span class="s0">.finishNodeAt(r,</span><span class="s3">&quot;DirectiveLiteral&quot;</span><span class="s0">,t.end,t.loc.end),</span><span class="s1">this</span><span class="s0">.finishNodeAt(n,</span><span class="s3">&quot;Directive&quot;</span><span class="s0">,e.end,e.loc.end)}parseInterpreterDirective(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c.interpreterDirective))</span><span class="s1">return null</span><span class="s0">;const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.value=</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;InterpreterDirective&quot;</span><span class="s0">)}isLet(e){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;let&quot;</span><span class="s0">))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.nextTokenStart(),r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(t);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">91</span><span class="s0">===r)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">123</span><span class="s0">===r)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(_(r)){let e=t+</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;L(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e));)++e;const r=</span><span class="s1">this</span><span class="s0">.input.slice(t,e);</span><span class="s1">if</span><span class="s0">(!q.test(r))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}parseStatement(e,t){</span><span class="s1">return this</span><span class="s0">.match(c.at)&amp;&amp;</span><span class="s1">this</span><span class="s0">.parseDecorators(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parseStatementContent(e,t)}parseStatementContent(e,t){let r=</span><span class="s1">this</span><span class="s0">.state.type;const n=</span><span class="s1">this</span><span class="s0">.startNode();let i;</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isLet(e)&amp;&amp;(r=c._var,i=</span><span class="s3">&quot;let&quot;</span><span class="s0">),r){</span><span class="s1">case </span><span class="s0">c._break:</span><span class="s1">case </span><span class="s0">c._continue:</span><span class="s1">return this</span><span class="s0">.parseBreakContinueStatement(n,r.keyword);</span><span class="s1">case </span><span class="s0">c._debugger:</span><span class="s1">return this</span><span class="s0">.parseDebuggerStatement(n);</span><span class="s1">case </span><span class="s0">c._do:</span><span class="s1">return this</span><span class="s0">.parseDoStatement(n);</span><span class="s1">case </span><span class="s0">c._for:</span><span class="s1">return this</span><span class="s0">.parseForStatement(n);</span><span class="s1">case </span><span class="s0">c._function:</span><span class="s1">if</span><span class="s0">(</span><span class="s2">46</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.lookaheadCharCode())</span><span class="s1">break</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.strict?</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.StrictFunction):</span><span class="s3">&quot;if&quot;</span><span class="s0">!==e&amp;&amp;</span><span class="s3">&quot;label&quot;</span><span class="s0">!==e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.SloppyFunction)),</span><span class="s1">this</span><span class="s0">.parseFunctionStatement(n,!</span><span class="s2">1</span><span class="s0">,!e);</span><span class="s1">case </span><span class="s0">c._class:</span><span class="s1">return </span><span class="s0">e&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.parseClass(n,!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">case </span><span class="s0">c._if:</span><span class="s1">return this</span><span class="s0">.parseIfStatement(n);</span><span class="s1">case </span><span class="s0">c._return:</span><span class="s1">return this</span><span class="s0">.parseReturnStatement(n);</span><span class="s1">case </span><span class="s0">c._switch:</span><span class="s1">return this</span><span class="s0">.parseSwitchStatement(n);</span><span class="s1">case </span><span class="s0">c._throw:</span><span class="s1">return this</span><span class="s0">.parseThrowStatement(n);</span><span class="s1">case </span><span class="s0">c._try:</span><span class="s1">return this</span><span class="s0">.parseTryStatement(n);</span><span class="s1">case </span><span class="s0">c._const:</span><span class="s1">case </span><span class="s0">c._var:</span><span class="s1">return </span><span class="s0">i=i||</span><span class="s1">this</span><span class="s0">.state.value,e&amp;&amp;</span><span class="s3">&quot;var&quot;</span><span class="s0">!==i&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.UnexpectedLexicalDeclaration),</span><span class="s1">this</span><span class="s0">.parseVarStatement(n,i);</span><span class="s1">case </span><span class="s0">c._while:</span><span class="s1">return this</span><span class="s0">.parseWhileStatement(n);</span><span class="s1">case </span><span class="s0">c._with:</span><span class="s1">return this</span><span class="s0">.parseWithStatement(n);</span><span class="s1">case </span><span class="s0">c.braceL:</span><span class="s1">return this</span><span class="s0">.parseBlock();</span><span class="s1">case </span><span class="s0">c.semi:</span><span class="s1">return this</span><span class="s0">.parseEmptyStatement(n);</span><span class="s1">case </span><span class="s0">c._import:{const e=</span><span class="s1">this</span><span class="s0">.lookaheadCharCode();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">40</span><span class="s0">===e||</span><span class="s2">46</span><span class="s0">===e)</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case </span><span class="s0">c._export:{let e;</span><span class="s1">return this</span><span class="s0">.options.allowImportExportEverywhere||t||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.UnexpectedImportExport),</span><span class="s1">this</span><span class="s0">.next(),r===c._import?(e=</span><span class="s1">this</span><span class="s0">.parseImport(n),</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">!==e.type||e.importKind&amp;&amp;</span><span class="s3">&quot;value&quot;</span><span class="s0">!==e.importKind||(</span><span class="s1">this</span><span class="s0">.sawUnambiguousESM=!</span><span class="s2">0</span><span class="s0">)):(e=</span><span class="s1">this</span><span class="s0">.parseExport(n),(</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">!==e.type||e.exportKind&amp;&amp;</span><span class="s3">&quot;value&quot;</span><span class="s0">!==e.exportKind)&amp;&amp;(</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">!==e.type||e.exportKind&amp;&amp;</span><span class="s3">&quot;value&quot;</span><span class="s0">!==e.exportKind)&amp;&amp;</span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">!==e.type||(</span><span class="s1">this</span><span class="s0">.sawUnambiguousESM=!</span><span class="s2">0</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.assertModuleNodeAllowed(n),e}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isAsyncFunction())</span><span class="s1">return </span><span class="s0">e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.AsyncFunctionInSingleStatementContext),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseFunctionStatement(n,!</span><span class="s2">0</span><span class="s0">,!e)}const s=</span><span class="s1">this</span><span class="s0">.state.value,a=</span><span class="s1">this</span><span class="s0">.parseExpression();</span><span class="s1">return </span><span class="s0">r===c.name&amp;&amp;</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===a.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(c.colon)?</span><span class="s1">this</span><span class="s0">.parseLabeledStatement(n,s,a,e):</span><span class="s1">this</span><span class="s0">.parseExpressionStatement(n,a)}assertModuleNodeAllowed(e){</span><span class="s1">this</span><span class="s0">.options.allowImportExportEverywhere||</span><span class="s1">this</span><span class="s0">.inModule||</span><span class="s1">this</span><span class="s0">.raiseWithData(e.start,{code:</span><span class="s3">&quot;BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED&quot;</span><span class="s0">},x.ImportOutsideModule)}takeDecorators(e){const t=</span><span class="s1">this</span><span class="s0">.state.decoratorStack[</span><span class="s1">this</span><span class="s0">.state.decoratorStack.length-1];t.length&amp;&amp;(e.decorators=t,</span><span class="s1">this</span><span class="s0">.resetStartLocationFromNode(e,t[</span><span class="s2">0</span><span class="s0">]),</span><span class="s1">this</span><span class="s0">.state.decoratorStack[</span><span class="s1">this</span><span class="s0">.state.decoratorStack.length-1]=[])}canHaveLeadingDecorator(){</span><span class="s1">return this</span><span class="s0">.match(c._class)}parseDecorators(e){const t=</span><span class="s1">this</span><span class="s0">.state.decoratorStack[</span><span class="s1">this</span><span class="s0">.state.decoratorStack.length-1];</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.match(c.at);){const e=</span><span class="s1">this</span><span class="s0">.parseDecorator();t.push(e)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._export))e||</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">,</span><span class="s3">&quot;decoratorsBeforeExport&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.DecoratorExportClass);</span><span class="s1">else if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.canHaveLeadingDecorator())</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.UnexpectedLeadingDecorator)}parseDecorator(){</span><span class="s1">this</span><span class="s0">.expectOnePlugin([</span><span class="s3">&quot;decorators-legacy&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">]);const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.state.decoratorStack.push([]);const t=</span><span class="s1">this</span><span class="s0">.state.start,r=</span><span class="s1">this</span><span class="s0">.state.startLoc;let n;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.parenL))n=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.expect(c.parenR);</span><span class="s1">else for</span><span class="s0">(n=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">1</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.eat(c.dot);){const e=</span><span class="s1">this</span><span class="s0">.startNodeAt(t,r);e.object=n,e.property=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),e.computed=!</span><span class="s2">1</span><span class="s0">,n=</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">)}e.expression=</span><span class="s1">this</span><span class="s0">.parseMaybeDecoratorArguments(n),</span><span class="s1">this</span><span class="s0">.state.decoratorStack.pop()}</span><span class="s1">else </span><span class="s0">e.expression=</span><span class="s1">this</span><span class="s0">.parseExprSubscripts();</span><span class="s1">return this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;Decorator&quot;</span><span class="s0">)}parseMaybeDecoratorArguments(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.parenL)){const t=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e);</span><span class="s1">return </span><span class="s0">t.callee=e,t.arguments=</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(c.parenR,!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.toReferencedList(t.arguments),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;CallExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}parseBreakContinueStatement(e,t){const r=</span><span class="s3">&quot;break&quot;</span><span class="s0">===t;</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.isLineTerminator()?e.label=</span><span class="s1">null</span><span class="s0">:(e.label=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.semicolon()),</span><span class="s1">this</span><span class="s0">.verifyBreakContinue(e,t),</span><span class="s1">this</span><span class="s0">.finishNode(e,r?</span><span class="s3">&quot;BreakStatement&quot;</span><span class="s0">:</span><span class="s3">&quot;ContinueStatement&quot;</span><span class="s0">)}verifyBreakContinue(e,t){const r=</span><span class="s3">&quot;break&quot;</span><span class="s0">===t;let n;</span><span class="s1">for</span><span class="s0">(n=</span><span class="s2">0</span><span class="s0">;n&lt;</span><span class="s1">this</span><span class="s0">.state.labels.length;++n){const t=</span><span class="s1">this</span><span class="s0">.state.labels[n];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==e.label||t.name===e.label.name){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=t.kind&amp;&amp;(r||</span><span class="s3">&quot;loop&quot;</span><span class="s0">===t.kind))</span><span class="s1">break</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e.label&amp;&amp;r)</span><span class="s1">break</span><span class="s0">}}n===</span><span class="s1">this</span><span class="s0">.state.labels.length&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,x.IllegalBreakContinue,t)}parseDebuggerStatement(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DebuggerStatement&quot;</span><span class="s0">)}parseHeaderExpression(){</span><span class="s1">this</span><span class="s0">.expect(c.parenL);const e=</span><span class="s1">this</span><span class="s0">.parseExpression();</span><span class="s1">return this</span><span class="s0">.expect(c.parenR),e}parseDoStatement(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.state.labels.push(je),e.body=</span><span class="s1">this</span><span class="s0">.withTopicForbiddingContext((()=&gt;</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s3">&quot;do&quot;</span><span class="s0">))),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),</span><span class="s1">this</span><span class="s0">.expect(c._while),e.test=</span><span class="s1">this</span><span class="s0">.parseHeaderExpression(),</span><span class="s1">this</span><span class="s0">.eat(c.semi),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s0">)}parseForStatement(e){</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.state.labels.push(je);let t=-</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isAwaitAllowed()&amp;&amp;</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;await&quot;</span><span class="s0">)&amp;&amp;(t=</span><span class="s1">this</span><span class="s0">.state.lastTokStart),</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.parenL),</span><span class="s1">this</span><span class="s0">.match(c.semi))</span><span class="s1">return </span><span class="s0">t&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(t),</span><span class="s1">this</span><span class="s0">.parseFor(e,</span><span class="s1">null</span><span class="s0">);const r=</span><span class="s1">this</span><span class="s0">.isLet();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._var)||</span><span class="s1">this</span><span class="s0">.match(c._const)||r){const n=</span><span class="s1">this</span><span class="s0">.startNode(),i=r?</span><span class="s3">&quot;let&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseVar(n,!</span><span class="s2">0</span><span class="s0">,i),</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">),(</span><span class="s1">this</span><span class="s0">.match(c._in)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;of&quot;</span><span class="s0">))&amp;&amp;</span><span class="s2">1</span><span class="s0">===n.declarations.length?</span><span class="s1">this</span><span class="s0">.parseForIn(e,n,t):(t&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(t),</span><span class="s1">this</span><span class="s0">.parseFor(e,n))}const n=</span><span class="s1">new </span><span class="s0">we,i=</span><span class="s1">this</span><span class="s0">.parseExpression(!</span><span class="s2">0</span><span class="s0">,n);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._in)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;of&quot;</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.toAssignable(i);const r=</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;of&quot;</span><span class="s0">)?</span><span class="s3">&quot;for-of statement&quot;</span><span class="s0">:</span><span class="s3">&quot;for-in statement&quot;</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.checkLVal(i,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,r),</span><span class="s1">this</span><span class="s0">.parseForIn(e,i,t)}</span><span class="s1">return this</span><span class="s0">.checkExpressionErrors(n,!</span><span class="s2">0</span><span class="s0">),t&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(t),</span><span class="s1">this</span><span class="s0">.parseFor(e,i)}parseFunctionStatement(e,t,r){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseFunction(e,</span><span class="s2">1</span><span class="s0">|(r?</span><span class="s2">0</span><span class="s0">:</span><span class="s2">2</span><span class="s0">),t)}parseIfStatement(e){</span><span class="s1">return this</span><span class="s0">.next(),e.test=</span><span class="s1">this</span><span class="s0">.parseHeaderExpression(),e.consequent=</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s3">&quot;if&quot;</span><span class="s0">),e.alternate=</span><span class="s1">this</span><span class="s0">.eat(c._else)?</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s3">&quot;if&quot;</span><span class="s0">):</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;IfStatement&quot;</span><span class="s0">)}parseReturnStatement(e){</span><span class="s1">return this</span><span class="s0">.prodParam.hasReturn||</span><span class="s1">this</span><span class="s0">.options.allowReturnOutsideFunction||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.IllegalReturn),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.isLineTerminator()?e.argument=</span><span class="s1">null</span><span class="s0">:(e.argument=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.semicolon()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ReturnStatement&quot;</span><span class="s0">)}parseSwitchStatement(e){</span><span class="s1">this</span><span class="s0">.next(),e.discriminant=</span><span class="s1">this</span><span class="s0">.parseHeaderExpression();const t=e.cases=[];let r;</span><span class="s1">this</span><span class="s0">.expect(c.braceL),</span><span class="s1">this</span><span class="s0">.state.labels.push(Fe),</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">0</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let e;!</span><span class="s1">this</span><span class="s0">.match(c.braceR);)</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._case)||</span><span class="s1">this</span><span class="s0">.match(c._default)){const n=</span><span class="s1">this</span><span class="s0">.match(c._case);r&amp;&amp;</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;SwitchCase&quot;</span><span class="s0">),t.push(r=</span><span class="s1">this</span><span class="s0">.startNode()),r.consequent=[],</span><span class="s1">this</span><span class="s0">.next(),n?r.test=</span><span class="s1">this</span><span class="s0">.parseExpression():(e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,x.MultipleDefaultsInSwitch),e=!</span><span class="s2">0</span><span class="s0">,r.test=</span><span class="s1">null</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.colon)}</span><span class="s1">else </span><span class="s0">r?r.consequent.push(</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s1">null</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.unexpected();</span><span class="s1">return this</span><span class="s0">.scope.exit(),r&amp;&amp;</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;SwitchCase&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;SwitchStatement&quot;</span><span class="s0">)}parseThrowStatement(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,x.NewlineAfterThrow),e.argument=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ThrowStatement&quot;</span><span class="s0">)}parseCatchClauseParam(){const e=</span><span class="s1">this</span><span class="s0">.parseBindingAtom(),t=</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type;</span><span class="s1">return this</span><span class="s0">.scope.enter(t?</span><span class="s2">8</span><span class="s0">:</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.checkLVal(e,</span><span class="s2">9</span><span class="s0">,</span><span class="s1">null</span><span class="s0">,</span><span class="s3">&quot;catch clause&quot;</span><span class="s0">),e}parseTryStatement(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),e.block=</span><span class="s1">this</span><span class="s0">.parseBlock(),e.handler=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(c._catch)){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(c.parenL)?(</span><span class="s1">this</span><span class="s0">.expect(c.parenL),t.param=</span><span class="s1">this</span><span class="s0">.parseCatchClauseParam(),</span><span class="s1">this</span><span class="s0">.expect(c.parenR)):(t.param=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">0</span><span class="s0">)),t.body=</span><span class="s1">this</span><span class="s0">.withTopicForbiddingContext((()=&gt;</span><span class="s1">this</span><span class="s0">.parseBlock(!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">))),</span><span class="s1">this</span><span class="s0">.scope.exit(),e.handler=</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;CatchClause&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e.finalizer=</span><span class="s1">this</span><span class="s0">.eat(c._finally)?</span><span class="s1">this</span><span class="s0">.parseBlock():</span><span class="s1">null</span><span class="s0">,e.handler||e.finalizer||</span><span class="s1">this</span><span class="s0">.raise(e.start,x.NoCatchOrFinally),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;TryStatement&quot;</span><span class="s0">)}parseVarStatement(e,t){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseVar(e,!</span><span class="s2">1</span><span class="s0">,t),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">)}parseWhileStatement(e){</span><span class="s1">return this</span><span class="s0">.next(),e.test=</span><span class="s1">this</span><span class="s0">.parseHeaderExpression(),</span><span class="s1">this</span><span class="s0">.state.labels.push(je),e.body=</span><span class="s1">this</span><span class="s0">.withTopicForbiddingContext((()=&gt;</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s3">&quot;while&quot;</span><span class="s0">))),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;WhileStatement&quot;</span><span class="s0">)}parseWithStatement(e){</span><span class="s1">return this</span><span class="s0">.state.strict&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.StrictWith),</span><span class="s1">this</span><span class="s0">.next(),e.object=</span><span class="s1">this</span><span class="s0">.parseHeaderExpression(),e.body=</span><span class="s1">this</span><span class="s0">.withTopicForbiddingContext((()=&gt;</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s3">&quot;with&quot;</span><span class="s0">))),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;WithStatement&quot;</span><span class="s0">)}parseEmptyStatement(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;EmptyStatement&quot;</span><span class="s0">)}parseLabeledStatement(e,t,r,n){</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">,n=</span><span class="s1">this</span><span class="s0">.state.labels;e&lt;n.length;e++)n[e].name===t&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r.start,x.LabelRedeclaration,t);const i=</span><span class="s1">this</span><span class="s0">.state.type.isLoop?</span><span class="s3">&quot;loop&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.match(c._switch)?</span><span class="s3">&quot;switch&quot;</span><span class="s0">:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s1">this</span><span class="s0">.state.labels.length-1;t&gt;=</span><span class="s2">0</span><span class="s0">;t--){const r=</span><span class="s1">this</span><span class="s0">.state.labels[t];</span><span class="s1">if</span><span class="s0">(r.statementStart!==e.start)</span><span class="s1">break</span><span class="s0">;r.statementStart=</span><span class="s1">this</span><span class="s0">.state.start,r.kind=i}</span><span class="s1">return this</span><span class="s0">.state.labels.push({name:t,kind:i,statementStart:</span><span class="s1">this</span><span class="s0">.state.start}),e.body=</span><span class="s1">this</span><span class="s0">.parseStatement(n?-</span><span class="s2">1</span><span class="s0">===n.indexOf(</span><span class="s3">&quot;label&quot;</span><span class="s0">)?n+</span><span class="s3">&quot;label&quot;</span><span class="s0">:n:</span><span class="s3">&quot;label&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),e.label=r,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;LabeledStatement&quot;</span><span class="s0">)}parseExpressionStatement(e,t){</span><span class="s1">return </span><span class="s0">e.expression=t,</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s0">)}parseBlock(e=!</span><span class="s2">1</span><span class="s0">,t=!</span><span class="s2">0</span><span class="s0">,r){const n=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(c.braceL),t&amp;&amp;</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parseBlockBody(n,e,!</span><span class="s2">1</span><span class="s0">,c.braceR,r),t&amp;&amp;</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">)}isValidDirective(e){</span><span class="s1">return</span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===e.expression.type&amp;&amp;!e.expression.extra.parenthesized}parseBlockBody(e,t,r,n,i){const s=e.body=[],a=e.directives=[];</span><span class="s1">this</span><span class="s0">.parseBlockOrModuleBlockBody(s,t?a:</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,r,n,i)}parseBlockOrModuleBlockBody(e,t,r,n,i){const s=[],a=</span><span class="s1">this</span><span class="s0">.state.strict;let o=!</span><span class="s2">1</span><span class="s0">,l=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.match(n);){!l&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.octalPositions.length&amp;&amp;s.push(...</span><span class="s1">this</span><span class="s0">.state.octalPositions);const n=</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s1">null</span><span class="s0">,r);</span><span class="s1">if</span><span class="s0">(t&amp;&amp;!l&amp;&amp;</span><span class="s1">this</span><span class="s0">.isValidDirective(n)){const e=</span><span class="s1">this</span><span class="s0">.stmtToDirective(n);t.push(e),o||</span><span class="s3">&quot;use strict&quot;</span><span class="s0">!==e.value.value||(o=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.setStrict(!</span><span class="s2">0</span><span class="s0">))}</span><span class="s1">else </span><span class="s0">l=!</span><span class="s2">0</span><span class="s0">,e.push(n)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;s.length)</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">;e&lt;s.length;e++){const t=s[e];</span><span class="s1">this</span><span class="s0">.raise(t,x.StrictOctalLiteral)}i&amp;&amp;i.call(</span><span class="s1">this</span><span class="s0">,o),a||</span><span class="s1">this</span><span class="s0">.setStrict(!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next()}parseFor(e,t){</span><span class="s1">return </span><span class="s0">e.init=t,</span><span class="s1">this</span><span class="s0">.expect(c.semi),e.test=</span><span class="s1">this</span><span class="s0">.match(c.semi)?</span><span class="s1">null</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.expect(c.semi),e.update=</span><span class="s1">this</span><span class="s0">.match(c.parenR)?</span><span class="s1">null</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.expect(c.parenR),e.body=</span><span class="s1">this</span><span class="s0">.withTopicForbiddingContext((()=&gt;</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s3">&quot;for&quot;</span><span class="s0">))),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ForStatement&quot;</span><span class="s0">)}parseForIn(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.match(c._in);</span><span class="s1">return this</span><span class="s0">.next(),n?r&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(r):e.await=r&gt;-</span><span class="s2">1</span><span class="s0">,</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">!==t.type||</span><span class="s1">null</span><span class="s0">==t.declarations[</span><span class="s2">0</span><span class="s0">].init||n&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;</span><span class="s3">&quot;var&quot;</span><span class="s0">===t.kind&amp;&amp;</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===t.declarations[</span><span class="s2">0</span><span class="s0">].id.type?</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">===t.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,x.InvalidLhs,</span><span class="s3">&quot;for-loop&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.raise(t.start,x.ForInOfLoopInitializer,n?</span><span class="s3">&quot;for-in&quot;</span><span class="s0">:</span><span class="s3">&quot;for-of&quot;</span><span class="s0">),e.left=t,e.right=n?</span><span class="s1">this</span><span class="s0">.parseExpression():</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),</span><span class="s1">this</span><span class="s0">.expect(c.parenR),e.body=</span><span class="s1">this</span><span class="s0">.withTopicForbiddingContext((()=&gt;</span><span class="s1">this</span><span class="s0">.parseStatement(</span><span class="s3">&quot;for&quot;</span><span class="s0">))),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),</span><span class="s1">this</span><span class="s0">.finishNode(e,n?</span><span class="s3">&quot;ForInStatement&quot;</span><span class="s0">:</span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s0">)}parseVar(e,t,r){const n=e.declarations=[],i=</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;typescript&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(e.kind=r;;){const e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parseVarId(e,r),</span><span class="s1">this</span><span class="s0">.eat(c.eq)?e.init=t?</span><span class="s1">this</span><span class="s0">.parseMaybeAssignDisallowIn():</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn():(</span><span class="s3">&quot;const&quot;</span><span class="s0">!==r||</span><span class="s1">this</span><span class="s0">.match(c._in)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;of&quot;</span><span class="s0">)?</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.id.type||t&amp;&amp;(</span><span class="s1">this</span><span class="s0">.match(c._in)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;of&quot;</span><span class="s0">))||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,x.DeclarationMissingInitializer,</span><span class="s3">&quot;Complex binding patterns&quot;</span><span class="s0">):i||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,x.DeclarationMissingInitializer,</span><span class="s3">&quot;Const declarations&quot;</span><span class="s0">),e.init=</span><span class="s1">null</span><span class="s0">),n.push(</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s0">)),!</span><span class="s1">this</span><span class="s0">.eat(c.comma))</span><span class="s1">break</span><span class="s0">}</span><span class="s1">return </span><span class="s0">e}parseVarId(e,t){e.id=</span><span class="s1">this</span><span class="s0">.parseBindingAtom(),</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,</span><span class="s3">&quot;var&quot;</span><span class="s0">===t?</span><span class="s2">5</span><span class="s0">:</span><span class="s2">9</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s3">&quot;variable declaration&quot;</span><span class="s0">,</span><span class="s3">&quot;var&quot;</span><span class="s0">!==t)}parseFunction(e,t=</span><span class="s2">0</span><span class="s0">,r=!</span><span class="s2">1</span><span class="s0">){const n=</span><span class="s2">1</span><span class="s0">&amp;t,i=</span><span class="s2">2</span><span class="s0">&amp;t,s=!(!n||</span><span class="s2">4</span><span class="s0">&amp;t);</span><span class="s1">this</span><span class="s0">.initFunction(e,r),</span><span class="s1">this</span><span class="s0">.match(c.star)&amp;&amp;i&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.GeneratorInSingleStatementContext),e.generator=</span><span class="s1">this</span><span class="s0">.eat(c.star),n&amp;&amp;(e.id=</span><span class="s1">this</span><span class="s0">.parseFunctionId(s));const a=</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters;</span><span class="s1">return this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">2</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.enter(oe(r,e.generator)),n||(e.id=</span><span class="s1">this</span><span class="s0">.parseFunctionId()),</span><span class="s1">this</span><span class="s0">.parseFunctionParams(e,!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.withTopicForbiddingContext((()=&gt;{</span><span class="s1">this</span><span class="s0">.parseFunctionBodyAndFinish(e,n?</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">:</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">)})),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit(),n&amp;&amp;!i&amp;&amp;</span><span class="s1">this</span><span class="s0">.registerFunctionStatementId(e),</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=a,e}parseFunctionId(e){</span><span class="s1">return </span><span class="s0">e||</span><span class="s1">this</span><span class="s0">.match(c.name)?</span><span class="s1">this</span><span class="s0">.parseIdentifier():</span><span class="s1">null</span><span class="s0">}parseFunctionParams(e,t){</span><span class="s1">this</span><span class="s0">.expect(c.parenL),</span><span class="s1">this</span><span class="s0">.expressionScope.enter(</span><span class="s1">new </span><span class="s0">ke(</span><span class="s2">3</span><span class="s0">)),e.params=</span><span class="s1">this</span><span class="s0">.parseBindingList(c.parenR,</span><span class="s2">41</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,t),</span><span class="s1">this</span><span class="s0">.expressionScope.exit()}registerFunctionStatementId(e){e.id&amp;&amp;</span><span class="s1">this</span><span class="s0">.scope.declareName(e.id.name,</span><span class="s1">this</span><span class="s0">.state.strict||e.generator||e.async?</span><span class="s1">this</span><span class="s0">.scope.treatFunctionsAsVar?</span><span class="s2">5</span><span class="s0">:</span><span class="s2">9</span><span class="s0">:</span><span class="s2">17</span><span class="s0">,e.id.start)}parseClass(e,t,r){</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.takeDecorators(e);const n=</span><span class="s1">this</span><span class="s0">.state.strict;</span><span class="s1">return this</span><span class="s0">.state.strict=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseClassId(e,t,r),</span><span class="s1">this</span><span class="s0">.parseClassSuper(e),e.body=</span><span class="s1">this</span><span class="s0">.parseClassBody(!!e.superClass,n),</span><span class="s1">this</span><span class="s0">.finishNode(e,t?</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">:</span><span class="s3">&quot;ClassExpression&quot;</span><span class="s0">)}isClassProperty(){</span><span class="s1">return this</span><span class="s0">.match(c.eq)||</span><span class="s1">this</span><span class="s0">.match(c.semi)||</span><span class="s1">this</span><span class="s0">.match(c.braceR)}isClassMethod(){</span><span class="s1">return this</span><span class="s0">.match(c.parenL)}isNonstaticConstructor(e){</span><span class="s1">return</span><span class="s0">!(e.computed||e.static||</span><span class="s3">&quot;constructor&quot;</span><span class="s0">!==e.key.name&amp;&amp;</span><span class="s3">&quot;constructor&quot;</span><span class="s0">!==e.key.value)}parseClassBody(e,t){</span><span class="s1">this</span><span class="s0">.classScope.enter();const r={constructorAllowsSuper:e,hadConstructor:!</span><span class="s2">1</span><span class="s0">,hadStaticBlock:!</span><span class="s2">1</span><span class="s0">};let n=[];const i=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(i.body=[],</span><span class="s1">this</span><span class="s0">.expect(c.braceL),</span><span class="s1">this</span><span class="s0">.withTopicForbiddingContext((()=&gt;{</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.match(c.braceR);){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.semi)){</span><span class="s1">if</span><span class="s0">(n.length&gt;</span><span class="s2">0</span><span class="s0">)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.lastTokEnd,x.DecoratorSemicolon);</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.at)){n.push(</span><span class="s1">this</span><span class="s0">.parseDecorator());</span><span class="s1">continue</span><span class="s0">}const e=</span><span class="s1">this</span><span class="s0">.startNode();n.length&amp;&amp;(e.decorators=n,</span><span class="s1">this</span><span class="s0">.resetStartLocationFromNode(e,n[</span><span class="s2">0</span><span class="s0">]),n=[]),</span><span class="s1">this</span><span class="s0">.parseClassMember(i,e,r),</span><span class="s3">&quot;constructor&quot;</span><span class="s0">===e.kind&amp;&amp;e.decorators&amp;&amp;e.decorators.length&gt;</span><span class="s2">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,x.DecoratorConstructor)}})),</span><span class="s1">this</span><span class="s0">.state.strict=t,</span><span class="s1">this</span><span class="s0">.next(),n.length)</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.TrailingDecorator);</span><span class="s1">return this</span><span class="s0">.classScope.exit(),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s3">&quot;ClassBody&quot;</span><span class="s0">)}parseClassMemberFromModifier(e,t){const r=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isClassMethod()){const n=t;</span><span class="s1">return </span><span class="s0">n.kind=</span><span class="s3">&quot;method&quot;</span><span class="s0">,n.computed=!</span><span class="s2">1</span><span class="s0">,n.key=r,n.static=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.pushClassMethod(e,n,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isClassProperty()){const n=t;</span><span class="s1">return </span><span class="s0">n.computed=!</span><span class="s2">1</span><span class="s0">,n.key=r,n.static=!</span><span class="s2">1</span><span class="s0">,e.body.push(</span><span class="s1">this</span><span class="s0">.parseClassProperty(n)),!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}parseClassMember(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;static&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(n){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parseClassMemberFromModifier(e,t))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.braceL))</span><span class="s1">return void this</span><span class="s0">.parseClassStaticBlock(e,t,r)}</span><span class="s1">this</span><span class="s0">.parseClassMemberWithIsStatic(e,t,r,n)}parseClassMemberWithIsStatic(e,t,r,n){const i=t,s=t,a=t,o=t,l=i,p=i;</span><span class="s1">if</span><span class="s0">(t.static=n,</span><span class="s1">this</span><span class="s0">.eat(c.star))</span><span class="s1">return </span><span class="s0">l.kind=</span><span class="s3">&quot;method&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseClassElementName(l),</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">===l.key.type?</span><span class="s1">void this</span><span class="s0">.pushClassPrivateMethod(e,s,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.isNonstaticConstructor(i)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(i.key.start,x.ConstructorIsGenerator),</span><span class="s1">void this</span><span class="s0">.pushClassMethod(e,i,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">));const u=</span><span class="s1">this</span><span class="s0">.state.containsEsc,d=</span><span class="s1">this</span><span class="s0">.parseClassElementName(t),h=</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">===d.type,f=</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===d.type,m=</span><span class="s1">this</span><span class="s0">.state.start;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parsePostMemberNameModifiers(p),</span><span class="s1">this</span><span class="s0">.isClassMethod()){</span><span class="s1">if</span><span class="s0">(l.kind=</span><span class="s3">&quot;method&quot;</span><span class="s0">,h)</span><span class="s1">return void this</span><span class="s0">.pushClassPrivateMethod(e,s,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.isNonstaticConstructor(i);let n=!</span><span class="s2">1</span><span class="s0">;t&amp;&amp;(i.kind=</span><span class="s3">&quot;constructor&quot;</span><span class="s0">,r.hadConstructor&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;typescript&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(d.start,x.DuplicateConstructor),r.hadConstructor=!</span><span class="s2">0</span><span class="s0">,n=r.constructorAllowsSuper),</span><span class="s1">this</span><span class="s0">.pushClassMethod(e,i,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,t,n)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isClassProperty())h?</span><span class="s1">this</span><span class="s0">.pushClassPrivateProperty(e,o):</span><span class="s1">this</span><span class="s0">.pushClassProperty(e,a);</span><span class="s1">else if</span><span class="s0">(!f||</span><span class="s3">&quot;async&quot;</span><span class="s0">!==d.name||u||</span><span class="s1">this</span><span class="s0">.isLineTerminator())!f||</span><span class="s3">&quot;get&quot;</span><span class="s0">!==d.name&amp;&amp;</span><span class="s3">&quot;set&quot;</span><span class="s0">!==d.name||u||</span><span class="s1">this</span><span class="s0">.match(c.star)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isLineTerminator()?</span><span class="s1">this</span><span class="s0">.isLineTerminator()?h?</span><span class="s1">this</span><span class="s0">.pushClassPrivateProperty(e,o):</span><span class="s1">this</span><span class="s0">.pushClassProperty(e,a):</span><span class="s1">this</span><span class="s0">.unexpected():(l.kind=d.name,</span><span class="s1">this</span><span class="s0">.parseClassElementName(i),</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">===l.key.type?</span><span class="s1">this</span><span class="s0">.pushClassPrivateMethod(e,s,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.isNonstaticConstructor(i)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(i.key.start,x.ConstructorIsAccessor),</span><span class="s1">this</span><span class="s0">.pushClassMethod(e,i,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.checkGetterSetterParams(i));</span><span class="s1">else</span><span class="s0">{const t=</span><span class="s1">this</span><span class="s0">.eat(c.star);p.optional&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(m),l.kind=</span><span class="s3">&quot;method&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseClassElementName(l),</span><span class="s1">this</span><span class="s0">.parsePostMemberNameModifiers(p),</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">===l.key.type?</span><span class="s1">this</span><span class="s0">.pushClassPrivateMethod(e,s,t,!</span><span class="s2">0</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.isNonstaticConstructor(i)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(i.key.start,x.ConstructorIsAsync),</span><span class="s1">this</span><span class="s0">.pushClassMethod(e,i,t,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">))}}parseClassElementName(e){const t=</span><span class="s1">this</span><span class="s0">.parsePropertyName(e,!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">return </span><span class="s0">e.computed||!e.static||</span><span class="s3">&quot;prototype&quot;</span><span class="s0">!==t.name&amp;&amp;</span><span class="s3">&quot;prototype&quot;</span><span class="s0">!==t.value||</span><span class="s1">this</span><span class="s0">.raise(t.start,x.StaticPrototype),</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">===t.type&amp;&amp;</span><span class="s3">&quot;constructor&quot;</span><span class="s0">===t.id.name&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,x.ConstructorClassPrivateField),t}parseClassStaticBlock(e,t,r){</span><span class="s1">var </span><span class="s0">n;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;classStaticBlock&quot;</span><span class="s0">,t.start),</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">80</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expressionScope.enter(Le());const i=</span><span class="s1">this</span><span class="s0">.state.labels;</span><span class="s1">this</span><span class="s0">.state.labels=[],</span><span class="s1">this</span><span class="s0">.prodParam.enter(</span><span class="s2">0</span><span class="s0">);const s=t.body=[];</span><span class="s1">this</span><span class="s0">.parseBlockOrModuleBlockBody(s,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,c.braceR),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.expressionScope.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.state.labels=i,e.body.push(</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;StaticBlock&quot;</span><span class="s0">)),r.hadStaticBlock&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,x.DuplicateStaticBlock),(</span><span class="s1">null</span><span class="s0">==(n=t.decorators)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:n.length)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.start,x.DecoratorStaticBlock),r.hadStaticBlock=!</span><span class="s2">0</span><span class="s0">}pushClassProperty(e,t){t.computed||</span><span class="s3">&quot;constructor&quot;</span><span class="s0">!==t.key.name&amp;&amp;</span><span class="s3">&quot;constructor&quot;</span><span class="s0">!==t.key.value||</span><span class="s1">this</span><span class="s0">.raise(t.key.start,x.ConstructorClassField),e.body.push(</span><span class="s1">this</span><span class="s0">.parseClassProperty(t))}pushClassPrivateProperty(e,t){</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;classPrivateProperties&quot;</span><span class="s0">,t.key.start);const r=</span><span class="s1">this</span><span class="s0">.parseClassPrivateProperty(t);e.body.push(r),</span><span class="s1">this</span><span class="s0">.classScope.declarePrivateName(r.key.id.name,</span><span class="s2">0</span><span class="s0">,r.key.start)}pushClassMethod(e,t,r,n,i,s){e.body.push(</span><span class="s1">this</span><span class="s0">.parseMethod(t,r,n,i,s,</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">))}pushClassPrivateMethod(e,t,r,n){</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;classPrivateMethods&quot;</span><span class="s0">,t.key.start);const i=</span><span class="s1">this</span><span class="s0">.parseMethod(t,r,n,!</span><span class="s2">1</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">);e.body.push(i);const s=</span><span class="s3">&quot;get&quot;</span><span class="s0">===i.kind?i.static?</span><span class="s2">6</span><span class="s0">:</span><span class="s2">2</span><span class="s0">:</span><span class="s3">&quot;set&quot;</span><span class="s0">===i.kind?i.static?</span><span class="s2">5</span><span class="s0">:</span><span class="s2">1</span><span class="s0">:</span><span class="s2">0</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.classScope.declarePrivateName(i.key.id.name,s,i.key.start)}parsePostMemberNameModifiers(e){}parseClassPrivateProperty(e){</span><span class="s1">return this</span><span class="s0">.parseInitializer(e),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ClassPrivateProperty&quot;</span><span class="s0">)}parseClassProperty(e){</span><span class="s1">return </span><span class="s0">e.typeAnnotation&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(c.eq)||</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;classProperties&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parseInitializer(e),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ClassProperty&quot;</span><span class="s0">)}parseInitializer(e){</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">80</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expressionScope.enter(Le()),</span><span class="s1">this</span><span class="s0">.prodParam.enter(</span><span class="s2">0</span><span class="s0">),e.value=</span><span class="s1">this</span><span class="s0">.eat(c.eq)?</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn():</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expressionScope.exit(),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit()}parseClassId(e,t,r,n=</span><span class="s2">139</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.match(c.name)?(e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),t&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkLVal(e.id,n,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s3">&quot;class name&quot;</span><span class="s0">)):r||!t?e.id=</span><span class="s1">null</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,x.MissingClassName)}parseClassSuper(e){e.superClass=</span><span class="s1">this</span><span class="s0">.eat(c._extends)?</span><span class="s1">this</span><span class="s0">.parseExprSubscripts():</span><span class="s1">null</span><span class="s0">}parseExport(e){const t=</span><span class="s1">this</span><span class="s0">.maybeParseExportDefaultSpecifier(e),r=!t||</span><span class="s1">this</span><span class="s0">.eat(c.comma),n=r&amp;&amp;</span><span class="s1">this</span><span class="s0">.eatExportStar(e),i=n&amp;&amp;</span><span class="s1">this</span><span class="s0">.maybeParseExportNamespaceSpecifier(e),s=r&amp;&amp;(!i||</span><span class="s1">this</span><span class="s0">.eat(c.comma)),a=t||n;</span><span class="s1">if</span><span class="s0">(n&amp;&amp;!i)</span><span class="s1">return </span><span class="s0">t&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.parseExportFrom(e,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s0">);const o=</span><span class="s1">this</span><span class="s0">.maybeParseExportNamedSpecifiers(e);</span><span class="s1">if</span><span class="s0">(t&amp;&amp;r&amp;&amp;!n&amp;&amp;!o||i&amp;&amp;s&amp;&amp;!o)</span><span class="s1">throw this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,c.braceL);let l;</span><span class="s1">if</span><span class="s0">(a||o?(l=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseExportFrom(e,a)):l=</span><span class="s1">this</span><span class="s0">.maybeParseExportDeclaration(e),a||o||l)</span><span class="s1">return this</span><span class="s0">.checkExport(e,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">,!!e.source),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c._default))</span><span class="s1">return </span><span class="s0">e.declaration=</span><span class="s1">this</span><span class="s0">.parseExportDefaultExpression(),</span><span class="s1">this</span><span class="s0">.checkExport(e,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">);</span><span class="s1">throw this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,c.braceL)}eatExportStar(e){</span><span class="s1">return this</span><span class="s0">.eat(c.star)}maybeParseExportDefaultSpecifier(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isExportDefaultSpecifier()){</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;exportDefaultFrom&quot;</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">t.exported=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),e.specifiers=[</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;ExportDefaultSpecifier&quot;</span><span class="s0">)],!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}maybeParseExportNamespaceSpecifier(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">)){e.specifiers||(e.specifiers=[]);const t=</span><span class="s1">this</span><span class="s0">.startNodeAt(</span><span class="s1">this</span><span class="s0">.state.lastTokStart,</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc);</span><span class="s1">return this</span><span class="s0">.next(),t.exported=</span><span class="s1">this</span><span class="s0">.parseModuleExportName(),e.specifiers.push(</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;ExportNamespaceSpecifier&quot;</span><span class="s0">)),!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}maybeParseExportNamedSpecifiers(e){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.match(c.braceL)&amp;&amp;(e.specifiers||(e.specifiers=[]),e.specifiers.push(...</span><span class="s1">this</span><span class="s0">.parseExportSpecifiers()),e.source=</span><span class="s1">null</span><span class="s0">,e.declaration=</span><span class="s1">null</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">)}maybeParseExportDeclaration(e){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.shouldParseExportDeclaration()&amp;&amp;(e.specifiers=[],e.source=</span><span class="s1">null</span><span class="s0">,e.declaration=</span><span class="s1">this</span><span class="s0">.parseExportDeclaration(e),!</span><span class="s2">0</span><span class="s0">)}isAsyncFunction(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;async&quot;</span><span class="s0">))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const e=</span><span class="s1">this</span><span class="s0">.nextTokenStart();</span><span class="s1">return</span><span class="s0">!u.test(</span><span class="s1">this</span><span class="s0">.input.slice(</span><span class="s1">this</span><span class="s0">.state.pos,e))&amp;&amp;</span><span class="s1">this</span><span class="s0">.isUnparsedContextual(e,</span><span class="s3">&quot;function&quot;</span><span class="s0">)}parseExportDefaultExpression(){const e=</span><span class="s1">this</span><span class="s0">.startNode(),t=</span><span class="s1">this</span><span class="s0">.isAsyncFunction();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._function)||t)</span><span class="s1">return this</span><span class="s0">.next(),t&amp;&amp;</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseFunction(e,</span><span class="s2">5</span><span class="s0">,t);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._class))</span><span class="s1">return this</span><span class="s0">.parseClass(e,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.at))</span><span class="s1">return this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">,</span><span class="s3">&quot;decoratorsBeforeExport&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.DecoratorBeforeExport),</span><span class="s1">this</span><span class="s0">.parseDecorators(!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parseClass(e,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._const)||</span><span class="s1">this</span><span class="s0">.match(c._var)||</span><span class="s1">this</span><span class="s0">.isLet())</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.UnsupportedDefaultExport);{const e=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn();</span><span class="s1">return this</span><span class="s0">.semicolon(),e}}parseExportDeclaration(e){</span><span class="s1">return this</span><span class="s0">.parseStatement(</span><span class="s1">null</span><span class="s0">)}isExportDefaultSpecifier(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.name)){const e=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;async&quot;</span><span class="s0">===e&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.containsEsc||</span><span class="s3">&quot;let&quot;</span><span class="s0">===e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">((</span><span class="s3">&quot;type&quot;</span><span class="s0">===e||</span><span class="s3">&quot;interface&quot;</span><span class="s0">===e)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.containsEsc){const e=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s1">if</span><span class="s0">(e.type===c.name&amp;&amp;</span><span class="s3">&quot;from&quot;</span><span class="s0">!==e.value||e.type===c.braceL)</span><span class="s1">return this</span><span class="s0">.expectOnePlugin([</span><span class="s3">&quot;flow&quot;</span><span class="s0">,</span><span class="s3">&quot;typescript&quot;</span><span class="s0">]),!</span><span class="s2">1</span><span class="s0">}}</span><span class="s1">else if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c._default))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const e=</span><span class="s1">this</span><span class="s0">.nextTokenStart(),t=</span><span class="s1">this</span><span class="s0">.isUnparsedContextual(e,</span><span class="s3">&quot;from&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">44</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e)||</span><span class="s1">this</span><span class="s0">.match(c.name)&amp;&amp;t)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c._default)&amp;&amp;t){const t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.nextTokenStartSince(e+</span><span class="s2">4</span><span class="s0">));</span><span class="s1">return </span><span class="s2">34</span><span class="s0">===t||</span><span class="s2">39</span><span class="s0">===t}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}parseExportFrom(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;from&quot;</span><span class="s0">)){e.source=</span><span class="s1">this</span><span class="s0">.parseImportSource(),</span><span class="s1">this</span><span class="s0">.checkExport(e);const t=</span><span class="s1">this</span><span class="s0">.maybeParseImportAssertions();t&amp;&amp;(e.assertions=t)}</span><span class="s1">else </span><span class="s0">t?</span><span class="s1">this</span><span class="s0">.unexpected():e.source=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.semicolon()}shouldParseExportDeclaration(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.at)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.expectOnePlugin([</span><span class="s3">&quot;decorators&quot;</span><span class="s0">,</span><span class="s3">&quot;decorators-legacy&quot;</span><span class="s0">]),</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">))){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s3">&quot;decorators&quot;</span><span class="s0">,</span><span class="s3">&quot;decoratorsBeforeExport&quot;</span><span class="s0">))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">this</span><span class="s0">.state.start,x.DecoratorBeforeExport)}</span><span class="s1">return</span><span class="s3">&quot;var&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.type.keyword||</span><span class="s3">&quot;const&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.type.keyword||</span><span class="s3">&quot;function&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.type.keyword||</span><span class="s3">&quot;class&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state.type.keyword||</span><span class="s1">this</span><span class="s0">.isLet()||</span><span class="s1">this</span><span class="s0">.isAsyncFunction()}checkExport(e,t,r,n){</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">if</span><span class="s0">(r){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.checkDuplicateExports(e,</span><span class="s3">&quot;default&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;exportDefaultFrom&quot;</span><span class="s0">)){</span><span class="s1">var </span><span class="s0">i;const t=e.declaration;</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">!==t.type||</span><span class="s3">&quot;from&quot;</span><span class="s0">!==t.name||t.end-t.start!=</span><span class="s2">4</span><span class="s0">||(</span><span class="s1">null</span><span class="s0">==(i=t.extra)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:i.parenthesized)||</span><span class="s1">this</span><span class="s0">.raise(t.start,x.ExportDefaultFromAsIdentifier)}}</span><span class="s1">else if</span><span class="s0">(e.specifiers&amp;&amp;e.specifiers.length)</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">,r=e.specifiers;t&lt;r.length;t++){const e=r[t],{exported:i}=e,s=</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===i.type?i.name:i.value;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.checkDuplicateExports(e,s),!n&amp;&amp;e.local){const{local:t}=e;</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===t.type?</span><span class="s1">this</span><span class="s0">.raise(e.start,x.ExportBindingIsString,t.extra.raw,s):(</span><span class="s1">this</span><span class="s0">.checkReservedWord(t.name,t.start,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.checkLocalExport(t))}}</span><span class="s1">else if</span><span class="s0">(e.declaration)</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">===e.declaration.type||</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">===e.declaration.type){const t=e.declaration.id;</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Assertion failure&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.checkDuplicateExports(e,t.name)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">===e.declaration.type)</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">,r=e.declaration.declarations;t&lt;r.length;t++){const e=r[t];</span><span class="s1">this</span><span class="s0">.checkDeclaration(e.id)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.decoratorStack[</span><span class="s1">this</span><span class="s0">.state.decoratorStack.length-1].length)</span><span class="s1">throw this</span><span class="s0">.raise(e.start,x.UnsupportedDecoratorExport)}checkDeclaration(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">===e.type)</span><span class="s1">this</span><span class="s0">.checkDuplicateExports(e,e.name);</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">===e.type)</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">,r=e.properties;t&lt;r.length;t++){const e=r[t];</span><span class="s1">this</span><span class="s0">.checkDeclaration(e)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s0">===e.type)</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">,r=e.elements;t&lt;r.length;t++){const e=r[t];e&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkDeclaration(e)}</span><span class="s1">else</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">===e.type?</span><span class="s1">this</span><span class="s0">.checkDeclaration(e.value):</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">===e.type?</span><span class="s1">this</span><span class="s0">.checkDeclaration(e.argument):</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkDeclaration(e.left)}checkDuplicateExports(e,t){</span><span class="s1">this</span><span class="s0">.state.exportedIdentifiers.indexOf(t)&gt;-</span><span class="s2">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,</span><span class="s3">&quot;default&quot;</span><span class="s0">===t?x.DuplicateDefaultExport:x.DuplicateExport,t),</span><span class="s1">this</span><span class="s0">.state.exportedIdentifiers.push(t)}parseExportSpecifiers(){const e=[];let t=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.braceL);!</span><span class="s1">this</span><span class="s0">.eat(c.braceR);){</span><span class="s1">if</span><span class="s0">(t)t=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.comma),</span><span class="s1">this</span><span class="s0">.eat(c.braceR))</span><span class="s1">break</span><span class="s0">;const r=</span><span class="s1">this</span><span class="s0">.startNode();r.local=</span><span class="s1">this</span><span class="s0">.parseModuleExportName(),r.exported=</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.parseModuleExportName():r.local.__clone(),e.push(</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;ExportSpecifier&quot;</span><span class="s0">))}</span><span class="s1">return </span><span class="s0">e}parseModuleExportName(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.string)){</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;moduleStringNames&quot;</span><span class="s0">);const e=</span><span class="s1">this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">),t=e.value.match(Be);</span><span class="s1">return </span><span class="s0">t&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.start,x.ModuleExportNameHasLoneSurrogate,t[</span><span class="s2">0</span><span class="s0">].charCodeAt(</span><span class="s2">0</span><span class="s0">).toString(</span><span class="s2">16</span><span class="s0">)),e}</span><span class="s1">return this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">)}parseImport(e){</span><span class="s1">if</span><span class="s0">(e.specifiers=[],!</span><span class="s1">this</span><span class="s0">.match(c.string)){const t=!</span><span class="s1">this</span><span class="s0">.maybeParseDefaultImportSpecifier(e)||</span><span class="s1">this</span><span class="s0">.eat(c.comma),r=t&amp;&amp;</span><span class="s1">this</span><span class="s0">.maybeParseStarImportSpecifier(e);t&amp;&amp;!r&amp;&amp;</span><span class="s1">this</span><span class="s0">.parseNamedImportSpecifiers(e),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;from&quot;</span><span class="s0">)}e.source=</span><span class="s1">this</span><span class="s0">.parseImportSource();const t=</span><span class="s1">this</span><span class="s0">.maybeParseImportAssertions();</span><span class="s1">if</span><span class="s0">(t)e.assertions=t;</span><span class="s1">else</span><span class="s0">{const t=</span><span class="s1">this</span><span class="s0">.maybeParseModuleAttributes();t&amp;&amp;(e.attributes=t)}</span><span class="s1">return this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">)}parseImportSource(){</span><span class="s1">return this</span><span class="s0">.match(c.string)||</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.parseExprAtom()}shouldParseDefaultImport(e){</span><span class="s1">return this</span><span class="s0">.match(c.name)}parseImportSpecifierLocal(e,t,r,n){t.local=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkLVal(t.local,</span><span class="s2">9</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,n),e.specifiers.push(</span><span class="s1">this</span><span class="s0">.finishNode(t,r))}parseAssertEntries(){const e=[],t=</span><span class="s1">new </span><span class="s0">Set;</span><span class="s1">do</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.braceR))</span><span class="s1">break</span><span class="s0">;const r=</span><span class="s1">this</span><span class="s0">.startNode(),n=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.string)?r.key=</span><span class="s1">this</span><span class="s0">.parseLiteral(n,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">):r.key=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(c.colon),</span><span class="s3">&quot;type&quot;</span><span class="s0">!==n&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r.key.start,x.ModuleAttributeDifferentFromType,n),t.has(n)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r.key.start,x.ModuleAttributesWithDuplicateKeys,n),t.add(n),!</span><span class="s1">this</span><span class="s0">.match(c.string))</span><span class="s1">throw this</span><span class="s0">.unexpected(</span><span class="s1">this</span><span class="s0">.state.start,x.ModuleAttributeInvalidValue);r.value=</span><span class="s1">this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;ImportAttribute&quot;</span><span class="s0">),e.push(r)}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.comma));</span><span class="s1">return </span><span class="s0">e}maybeParseModuleAttributes(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(c._with)||</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak())</span><span class="s1">return this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;moduleAttributes&quot;</span><span class="s0">)?[]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;moduleAttributes&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next();const e=[],t=</span><span class="s1">new </span><span class="s0">Set;</span><span class="s1">do</span><span class="s0">{const r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(r.key=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s2">0</span><span class="s0">),</span><span class="s3">&quot;type&quot;</span><span class="s0">!==r.key.name&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r.key.start,x.ModuleAttributeDifferentFromType,r.key.name),t.has(r.key.name)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r.key.start,x.ModuleAttributesWithDuplicateKeys,r.key.name),t.add(r.key.name),</span><span class="s1">this</span><span class="s0">.expect(c.colon),!</span><span class="s1">this</span><span class="s0">.match(c.string))</span><span class="s1">throw this</span><span class="s0">.unexpected(</span><span class="s1">this</span><span class="s0">.state.start,x.ModuleAttributeInvalidValue);r.value=</span><span class="s1">this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s3">&quot;ImportAttribute&quot;</span><span class="s0">),e.push(r)}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.comma));</span><span class="s1">return </span><span class="s0">e}maybeParseImportAssertions(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">&quot;assert&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak())</span><span class="s1">return this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;importAssertions&quot;</span><span class="s0">)?[]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s3">&quot;importAssertions&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.eat(c.braceL);const e=</span><span class="s1">this</span><span class="s0">.parseAssertEntries();</span><span class="s1">return this</span><span class="s0">.eat(c.braceR),e}maybeParseDefaultImportSpecifier(e){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.shouldParseDefaultImport(e)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.parseImportSpecifierLocal(e,</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">,</span><span class="s3">&quot;default import specifier&quot;</span><span class="s0">),!</span><span class="s2">0</span><span class="s0">)}maybeParseStarImportSpecifier(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(c.star)){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parseImportSpecifierLocal(e,t,</span><span class="s3">&quot;ImportNamespaceSpecifier&quot;</span><span class="s0">,</span><span class="s3">&quot;import namespace specifier&quot;</span><span class="s0">),!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}parseNamedImportSpecifiers(e){let t=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.braceL);!</span><span class="s1">this</span><span class="s0">.eat(c.braceR);){</span><span class="s1">if</span><span class="s0">(t)t=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(c.colon))</span><span class="s1">throw this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.start,x.DestructureNamedImport);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(c.comma),</span><span class="s1">this</span><span class="s0">.eat(c.braceR))</span><span class="s1">break</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.parseImportSpecifier(e)}}parseImportSpecifier(e){const t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(t.imported=</span><span class="s1">this</span><span class="s0">.parseModuleExportName(),</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">&quot;as&quot;</span><span class="s0">))t.local=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">else</span><span class="s0">{const{imported:e}=t;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;StringLiteral&quot;</span><span class="s0">===e.type)</span><span class="s1">throw this</span><span class="s0">.raise(t.start,x.ImportBindingIsString,e.value);</span><span class="s1">this</span><span class="s0">.checkReservedWord(e.name,t.start,!</span><span class="s2">0</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),t.local=e.__clone()}</span><span class="s1">this</span><span class="s0">.checkLVal(t.local,</span><span class="s2">9</span><span class="s0">,</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,</span><span class="s3">&quot;import specifier&quot;</span><span class="s0">),e.specifiers.push(</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s0">))}}class Ue{constructor(){</span><span class="s1">this</span><span class="s0">.privateNames=</span><span class="s1">new </span><span class="s0">Set,</span><span class="s1">this</span><span class="s0">.loneAccessors=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.undefinedPrivateNames=</span><span class="s1">new </span><span class="s0">Map}}class Ve{constructor(e){</span><span class="s1">this</span><span class="s0">.stack=[],</span><span class="s1">this</span><span class="s0">.undefinedPrivateNames=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.raise=e}current(){</span><span class="s1">return this</span><span class="s0">.stack[</span><span class="s1">this</span><span class="s0">.stack.length-1]}enter(){</span><span class="s1">this</span><span class="s0">.stack.push(</span><span class="s1">new </span><span class="s0">Ue)}exit(){const e=</span><span class="s1">this</span><span class="s0">.stack.pop(),t=</span><span class="s1">this</span><span class="s0">.current();</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s2">0</span><span class="s0">,n=Array.from(e.undefinedPrivateNames);r&lt;n.length;r++){const[e,i]=n[r];t?t.undefinedPrivateNames.has(e)||t.undefinedPrivateNames.set(e,i):</span><span class="s1">this</span><span class="s0">.raise(i,x.InvalidPrivateFieldResolution,e)}}declarePrivateName(e,t,r){const n=</span><span class="s1">this</span><span class="s0">.current();let i=n.privateNames.has(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">3</span><span class="s0">&amp;t){const r=i&amp;&amp;n.loneAccessors.get(e);r?(i=(</span><span class="s2">3</span><span class="s0">&amp;r)==(</span><span class="s2">3</span><span class="s0">&amp;t)||(</span><span class="s2">4</span><span class="s0">&amp;r)!=(</span><span class="s2">4</span><span class="s0">&amp;t),i||n.loneAccessors.</span><span class="s1">delete</span><span class="s0">(e)):i||n.loneAccessors.set(e,t)}i&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(r,x.PrivateNameRedeclaration,e),n.privateNames.add(e),n.undefinedPrivateNames.</span><span class="s1">delete</span><span class="s0">(e)}usePrivateName(e,t){let r;</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">,n=</span><span class="s1">this</span><span class="s0">.stack;t&lt;n.length;t++)</span><span class="s1">if</span><span class="s0">(r=n[t],r.privateNames.has(e))</span><span class="s1">return</span><span class="s0">;r?r.undefinedPrivateNames.set(e,t):</span><span class="s1">this</span><span class="s0">.raise(t,x.InvalidPrivateFieldResolution,e)}}class Ke extends Re{constructor(e,t){super(e=</span><span class="s1">function</span><span class="s0">(e){const t={};</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s2">0</span><span class="s0">,n=Object.keys(Te);r&lt;n.length;r++){const i=n[r];t[i]=e&amp;&amp;</span><span class="s1">null</span><span class="s0">!=e[i]?e[i]:Te[i]}</span><span class="s1">return </span><span class="s0">t}(e),t);const r=</span><span class="s1">this</span><span class="s0">.getScopeHandler();</span><span class="s1">this</span><span class="s0">.options=e,</span><span class="s1">this</span><span class="s0">.inModule=</span><span class="s3">&quot;module&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.options.sourceType,</span><span class="s1">this</span><span class="s0">.scope=</span><span class="s1">new </span><span class="s0">r(</span><span class="s1">this</span><span class="s0">.raise.bind(</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.inModule),</span><span class="s1">this</span><span class="s0">.prodParam=</span><span class="s1">new </span><span class="s0">ae,</span><span class="s1">this</span><span class="s0">.classScope=</span><span class="s1">new </span><span class="s0">Ve(</span><span class="s1">this</span><span class="s0">.raise.bind(</span><span class="s1">this</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.expressionScope=</span><span class="s1">new </span><span class="s0">_e(</span><span class="s1">this</span><span class="s0">.raise.bind(</span><span class="s1">this</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.plugins=</span><span class="s1">function</span><span class="s0">(e){const t=</span><span class="s1">new </span><span class="s0">Map;</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s2">0</span><span class="s0">;r&lt;e.length;r++){const n=e[r],[i,s]=Array.isArray(n)?n:[n,{}];t.has(i)||t.set(i,s||{})}</span><span class="s1">return </span><span class="s0">t}(</span><span class="s1">this</span><span class="s0">.options.plugins),</span><span class="s1">this</span><span class="s0">.filename=e.sourceFilename}getScopeHandler(){</span><span class="s1">return </span><span class="s0">ne}parse(){let e=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s3">&quot;topLevelAwait&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;(e|=</span><span class="s2">2</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.enter(</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.enter(e);const t=</span><span class="s1">this</span><span class="s0">.startNode(),r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.nextToken(),t.errors=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseTopLevel(t,r),t.errors=</span><span class="s1">this</span><span class="s0">.state.errors,t}}</span><span class="s1">function </span><span class="s0">qe(e,t){let r=Ke;</span><span class="s1">return</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:e.plugins)&amp;&amp;(</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(ue(e,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(ue(e,</span><span class="s3">&quot;decorators-legacy&quot;</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Cannot use the decorators and decorators-legacy plugin together&quot;</span><span class="s0">);const t=de(e,</span><span class="s3">&quot;decorators&quot;</span><span class="s0">,</span><span class="s3">&quot;decoratorsBeforeExport&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==t)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">t)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;'decoratorsBeforeExport' must be a boolean.&quot;</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(ue(e,</span><span class="s3">&quot;flow&quot;</span><span class="s0">)&amp;&amp;ue(e,</span><span class="s3">&quot;typescript&quot;</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Cannot combine flow and typescript plugins.&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(ue(e,</span><span class="s3">&quot;placeholders&quot;</span><span class="s0">)&amp;&amp;ue(e,</span><span class="s3">&quot;v8intrinsic&quot;</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Cannot combine placeholders and v8intrinsic plugins.&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(ue(e,</span><span class="s3">&quot;pipelineOperator&quot;</span><span class="s0">)&amp;&amp;!he.includes(de(e,</span><span class="s3">&quot;pipelineOperator&quot;</span><span class="s0">,</span><span class="s3">&quot;proposal&quot;</span><span class="s0">)))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;'pipelineOperator' requires 'proposal' option whose value should be one of: &quot;</span><span class="s0">+he.map((e=&gt;`</span><span class="s3">'${e}'</span><span class="s0">`)).join(</span><span class="s3">&quot;, &quot;</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(ue(e,</span><span class="s3">&quot;moduleAttributes&quot;</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(ue(e,</span><span class="s3">&quot;importAssertions&quot;</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Cannot combine importAssertions and moduleAttributes plugins.&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;may-2020&quot;</span><span class="s0">!==de(e,</span><span class="s3">&quot;moduleAttributes&quot;</span><span class="s0">,</span><span class="s3">&quot;version&quot;</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.&quot;</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(ue(e,</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">)&amp;&amp;!fe.includes(de(e,</span><span class="s3">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s3">&quot;syntaxType&quot;</span><span class="s0">)))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;'recordAndTuple' requires 'syntaxType' option whose value should be one of: &quot;</span><span class="s0">+fe.map((e=&gt;`</span><span class="s3">'${e}'</span><span class="s0">`)).join(</span><span class="s3">&quot;, &quot;</span><span class="s0">))}(e.plugins),r=</span><span class="s1">function</span><span class="s0">(e){const t=ye.filter((t=&gt;ue(e,t))),r=t.join(</span><span class="s3">&quot;/&quot;</span><span class="s0">);let n=Ye[r];</span><span class="s1">if</span><span class="s0">(!n){n=Ke;</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">;e&lt;t.length;e++){const r=t[e];n=me[r](n)}Ye[r]=n}</span><span class="s1">return </span><span class="s0">n}(e.plugins)),</span><span class="s1">new </span><span class="s0">r(e,t)}const Ye={};t.parse=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">var </span><span class="s0">r;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;unambiguous&quot;</span><span class="s0">!==(</span><span class="s1">null</span><span class="s0">==(r=t)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.sourceType))</span><span class="s1">return </span><span class="s0">qe(t,e).parse();t=Object.assign({},t);</span><span class="s1">try</span><span class="s0">{t.sourceType=</span><span class="s3">&quot;module&quot;</span><span class="s0">;const r=qe(t,e),n=r.parse();</span><span class="s1">if</span><span class="s0">(r.sawUnambiguousESM)</span><span class="s1">return </span><span class="s0">n;</span><span class="s1">if</span><span class="s0">(r.ambiguousScriptDifferentAst)</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">t.sourceType=</span><span class="s3">&quot;script&quot;</span><span class="s0">,qe(t,e).parse()}</span><span class="s1">catch</span><span class="s0">(e){}</span><span class="s1">else </span><span class="s0">n.program.sourceType=</span><span class="s3">&quot;script&quot;</span><span class="s0">;</span><span class="s1">return </span><span class="s0">n}</span><span class="s1">catch</span><span class="s0">(r){</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">t.sourceType=</span><span class="s3">&quot;script&quot;</span><span class="s0">,qe(t,e).parse()}</span><span class="s1">catch</span><span class="s0">(e){}</span><span class="s1">throw </span><span class="s0">r}},t.parseExpression=</span><span class="s1">function</span><span class="s0">(e,t){const r=qe(t,e);</span><span class="s1">return </span><span class="s0">r.options.strictMode&amp;&amp;(r.state.strict=!</span><span class="s2">0</span><span class="s0">),r.getExpression()},t.tokTypes=c},</span><span class="s2">1826</span><span class="s0">:(e,t)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.clear=</span><span class="s1">function</span><span class="s0">(){i(),s()},t.clearPath=i,t.clearScope=s,t.scope=t.path=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;let r=</span><span class="s1">new </span><span class="s0">WeakMap;t.path=r;let n=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">function </span><span class="s0">i(){t.path=r=</span><span class="s1">new </span><span class="s0">WeakMap}</span><span class="s1">function </span><span class="s0">s(){t.scope=n=</span><span class="s1">new </span><span class="s0">WeakMap}t.scope=n},</span><span class="s2">7193</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n,i=(n=r(</span><span class="s2">706</span><span class="s0">))&amp;&amp;n.__esModule?n:{</span><span class="s1">default</span><span class="s0">:n},s=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=a();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,i)){</span><span class="s1">var </span><span class="s0">s=n?Object.getOwnPropertyDescriptor(e,i):</span><span class="s1">null</span><span class="s0">;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">1710</span><span class="s0">));</span><span class="s1">function </span><span class="s0">a(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">a=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}t.</span><span class="s1">default</span><span class="s0">=class{constructor(e,t,r,n){</span><span class="s1">this</span><span class="s0">.queue=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parentPath=n,</span><span class="s1">this</span><span class="s0">.scope=e,</span><span class="s1">this</span><span class="s0">.state=r,</span><span class="s1">this</span><span class="s0">.opts=t}shouldVisit(e){const t=</span><span class="s1">this</span><span class="s0">.opts;</span><span class="s1">if</span><span class="s0">(t.enter||t.exit)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(t[e.type])</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;const r=s.VISITOR_KEYS[e.type];</span><span class="s1">if</span><span class="s0">(!(</span><span class="s1">null</span><span class="s0">==r?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.length))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const t of r)</span><span class="s1">if</span><span class="s0">(e[t])</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}create(e,t,r,n){</span><span class="s1">return </span><span class="s0">i.</span><span class="s1">default</span><span class="s0">.get({parentPath:</span><span class="s1">this</span><span class="s0">.parentPath,parent:e,container:t,key:r,listKey:n})}maybeQueue(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.trap)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Infinite cycle detected&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.queue&amp;&amp;(t?</span><span class="s1">this</span><span class="s0">.queue.push(e):</span><span class="s1">this</span><span class="s0">.priorityQueue.push(e))}visitMultiple(e,t,r){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">0</span><span class="s0">===e.length)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const n=[];</span><span class="s1">for</span><span class="s0">(let i=</span><span class="s2">0</span><span class="s0">;i&lt;e.length;i++){const s=e[i];s&amp;&amp;</span><span class="s1">this</span><span class="s0">.shouldVisit(s)&amp;&amp;n.push(</span><span class="s1">this</span><span class="s0">.create(t,e,i,r))}</span><span class="s1">return this</span><span class="s0">.visitQueue(n)}visitSingle(e,t){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.shouldVisit(e[t])&amp;&amp;</span><span class="s1">this</span><span class="s0">.visitQueue([</span><span class="s1">this</span><span class="s0">.create(e,e,t)])}visitQueue(e){</span><span class="s1">this</span><span class="s0">.queue=e,</span><span class="s1">this</span><span class="s0">.priorityQueue=[];const t=[];let r=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const n of e)</span><span class="s1">if</span><span class="s0">(n.resync(),</span><span class="s2">0</span><span class="s0">!==n.contexts.length&amp;&amp;n.contexts[n.contexts.length-1]===</span><span class="s1">this</span><span class="s0">||n.pushContext(</span><span class="s1">this</span><span class="s0">),</span><span class="s1">null</span><span class="s0">!==n.key&amp;&amp;!(t.indexOf(n.node)&gt;=</span><span class="s2">0</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(t.push(n.node),n.visit()){r=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">break</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.priorityQueue.length&amp;&amp;(r=</span><span class="s1">this</span><span class="s0">.visitQueue(</span><span class="s1">this</span><span class="s0">.priorityQueue),</span><span class="s1">this</span><span class="s0">.priorityQueue=[],</span><span class="s1">this</span><span class="s0">.queue=e,r))</span><span class="s1">break</span><span class="s0">}</span><span class="s1">for</span><span class="s0">(const t of e)t.popContext();</span><span class="s1">return this</span><span class="s0">.queue=</span><span class="s1">null</span><span class="s0">,r}visit(e,t){const r=e[t];</span><span class="s1">return</span><span class="s0">!!r&amp;&amp;(Array.isArray(r)?</span><span class="s1">this</span><span class="s0">.visitMultiple(r,e,t):</span><span class="s1">this</span><span class="s0">.visitSingle(e,t))}}},</span><span class="s2">8672</span><span class="s0">:(e,t)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,t.</span><span class="s1">default</span><span class="s0">=class{getCode(){}getScope(){}addHelper(){</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Helpers are not supported by the default hub.&quot;</span><span class="s0">)}buildError(e,t,r=TypeError){</span><span class="s1">return new </span><span class="s0">r(t)}}},</span><span class="s2">1910</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=h,Object.defineProperty(t,</span><span class="s3">&quot;NodePath&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">o.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;Scope&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">l.</span><span class="s1">default</span><span class="s0">}}),Object.defineProperty(t,</span><span class="s3">&quot;Hub&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">p.</span><span class="s1">default</span><span class="s0">}}),t.visitors=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=d(r(</span><span class="s2">7193</span><span class="s0">)),i=u(r(</span><span class="s2">8221</span><span class="s0">));t.visitors=i;</span><span class="s1">var </span><span class="s0">s=u(r(</span><span class="s2">1710</span><span class="s0">)),a=u(r(</span><span class="s2">1826</span><span class="s0">)),o=d(r(</span><span class="s2">706</span><span class="s0">)),l=d(r(</span><span class="s2">4639</span><span class="s0">)),p=d(r(</span><span class="s2">8672</span><span class="s0">));</span><span class="s1">function </span><span class="s0">c(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">c=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}</span><span class="s1">function </span><span class="s0">u(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=c();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,i)){</span><span class="s1">var </span><span class="s0">s=n?Object.getOwnPropertyDescriptor(e,i):</span><span class="s1">null</span><span class="s0">;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}</span><span class="s1">function </span><span class="s0">d(e){</span><span class="s1">return </span><span class="s0">e&amp;&amp;e.__esModule?e:{</span><span class="s1">default</span><span class="s0">:e}}</span><span class="s1">function </span><span class="s0">h(e,t,r,n,a){</span><span class="s1">if</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(t||(t={}),!t.noScope&amp;&amp;!r&amp;&amp;</span><span class="s3">&quot;Program&quot;</span><span class="s0">!==e.type&amp;&amp;</span><span class="s3">&quot;File&quot;</span><span class="s0">!==e.type)</span><span class="s1">throw new </span><span class="s0">Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${e.type} node without passing scope and parentPath.`);s.VISITOR_KEYS[e.type]&amp;&amp;(i.explode(t),h.node(e,t,r,n,a))}}</span><span class="s1">function </span><span class="s0">f(e,t){e.node.type===t.type&amp;&amp;(t.has=!</span><span class="s2">0</span><span class="s0">,e.stop())}h.visitors=i,h.verify=i.verify,h.explode=i.explode,h.cheap=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">s.traverseFast(e,t)},h.node=</span><span class="s1">function</span><span class="s0">(e,t,r,i,a,o){const l=s.VISITOR_KEYS[e.type];</span><span class="s1">if</span><span class="s0">(!l)</span><span class="s1">return</span><span class="s0">;const p=</span><span class="s1">new </span><span class="s0">n.</span><span class="s1">default</span><span class="s0">(r,t,i,a);</span><span class="s1">for</span><span class="s0">(const t of l)</span><span class="s1">if</span><span class="s0">((!o||!o[t])&amp;&amp;p.visit(e,t))</span><span class="s1">return</span><span class="s0">},h.clearNode=</span><span class="s1">function</span><span class="s0">(e,t){s.removeProperties(e,t),a.path.</span><span class="s1">delete</span><span class="s0">(e)},h.removeProperties=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">s.traverseFast(e,h.clearNode,t),e},h.hasType=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==r?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.includes(e.type))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e.type===t)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;const n={has:!</span><span class="s2">1</span><span class="s0">,type:t};</span><span class="s1">return </span><span class="s0">h(e,{noScope:!</span><span class="s2">0</span><span class="s0">,denylist:r,enter:f},</span><span class="s1">null</span><span class="s0">,n),n.has},h.cache=a},</span><span class="s2">8152</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.findParent=</span><span class="s1">function</span><span class="s0">(e){let t=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;t=t.parentPath;)</span><span class="s1">if</span><span class="s0">(e(t))</span><span class="s1">return </span><span class="s0">t;</span><span class="s1">return null</span><span class="s0">},t.find=</span><span class="s1">function</span><span class="s0">(e){let t=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(e(t))</span><span class="s1">return </span><span class="s0">t}</span><span class="s1">while</span><span class="s0">(t=t.parentPath);</span><span class="s1">return null</span><span class="s0">},t.getFunctionParent=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">.findParent((e=&gt;e.isFunction()))},t.getStatementParent=</span><span class="s1">function</span><span class="s0">(){let e=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!e.parentPath||Array.isArray(e.container)&amp;&amp;e.isStatement())</span><span class="s1">break</span><span class="s0">;e=e.parentPath}</span><span class="s1">while</span><span class="s0">(e);</span><span class="s1">if</span><span class="s0">(e&amp;&amp;(e.isProgram()||e.isFile()))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;File/Program node, we can't possibly find a statement parent to this&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">e},t.getEarliestCommonAncestorFrom=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return this</span><span class="s0">.getDeepestCommonAncestorFrom(e,(</span><span class="s1">function</span><span class="s0">(e,t,r){let n;const s=i.VISITOR_KEYS[e.type];</span><span class="s1">for</span><span class="s0">(const e of r){const r=e[t+</span><span class="s2">1</span><span class="s0">];n?(r.listKey&amp;&amp;n.listKey===r.listKey&amp;&amp;r.key&lt;n.key||s.indexOf(n.parentKey)&gt;s.indexOf(r.parentKey))&amp;&amp;(n=r):n=r}</span><span class="s1">return </span><span class="s0">n}))},t.getDeepestCommonAncestorFrom=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!e.length)</span><span class="s1">return this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">1</span><span class="s0">===e.length)</span><span class="s1">return </span><span class="s0">e[</span><span class="s2">0</span><span class="s0">];let r,n,i=</span><span class="s2">1</span><span class="s0">/</span><span class="s2">0</span><span class="s0">;const s=e.map((e=&gt;{const t=[];</span><span class="s1">do</span><span class="s0">{t.unshift(e)}</span><span class="s1">while</span><span class="s0">((e=e.parentPath)&amp;&amp;e!==</span><span class="s1">this</span><span class="s0">);</span><span class="s1">return </span><span class="s0">t.length&lt;i&amp;&amp;(i=t.length),t})),a=s[</span><span class="s2">0</span><span class="s0">];e:</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">;e&lt;i;e++){const t=a[e];</span><span class="s1">for</span><span class="s0">(const r of s)</span><span class="s1">if</span><span class="s0">(r[e]!==t)</span><span class="s1">break </span><span class="s0">e;r=e,n=t}</span><span class="s1">if</span><span class="s0">(n)</span><span class="s1">return </span><span class="s0">t?t(n,r,s):n;</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Couldn't find intersection&quot;</span><span class="s0">)},t.getAncestry=</span><span class="s1">function</span><span class="s0">(){let e=</span><span class="s1">this</span><span class="s0">;const t=[];</span><span class="s1">do</span><span class="s0">{t.push(e)}</span><span class="s1">while</span><span class="s0">(e=e.parentPath);</span><span class="s1">return </span><span class="s0">t},t.isAncestor=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">e.isDescendant(</span><span class="s1">this</span><span class="s0">)},t.isDescendant=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.findParent((t=&gt;t===e))},t.inType=</span><span class="s1">function</span><span class="s0">(){let e=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;e;){</span><span class="s1">for</span><span class="s0">(const t of arguments)</span><span class="s1">if</span><span class="s0">(e.node.type===t)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;e=e.parentPath}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">};</span><span class="s1">var </span><span class="s0">n,i=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=s();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,i)){</span><span class="s1">var </span><span class="s0">a=n?Object.getOwnPropertyDescriptor(e,i):</span><span class="s1">null</span><span class="s0">;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,i,a):r[i]=e[i]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">1710</span><span class="s0">));</span><span class="s1">function </span><span class="s0">s(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">s=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}(n=r(</span><span class="s2">706</span><span class="s0">))&amp;&amp;n.__esModule},</span><span class="s2">7403</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.shareCommentsWithSiblings=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof this</span><span class="s0">.key)</span><span class="s1">return</span><span class="s0">;const e=</span><span class="s1">this</span><span class="s0">.node;</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">;const t=e.trailingComments,r=e.leadingComments;</span><span class="s1">if</span><span class="s0">(!t&amp;&amp;!r)</span><span class="s1">return</span><span class="s0">;const n=</span><span class="s1">this</span><span class="s0">.getSibling(</span><span class="s1">this</span><span class="s0">.key-1),i=</span><span class="s1">this</span><span class="s0">.getSibling(</span><span class="s1">this</span><span class="s0">.key+</span><span class="s2">1</span><span class="s0">),s=Boolean(n.node),a=Boolean(i.node);s&amp;&amp;!a?n.addComments(</span><span class="s3">&quot;trailing&quot;</span><span class="s0">,t):a&amp;&amp;!s&amp;&amp;i.addComments(</span><span class="s3">&quot;leading&quot;</span><span class="s0">,r)},t.addComment=</span><span class="s1">function</span><span class="s0">(e,t,r){n.addComment(</span><span class="s1">this</span><span class="s0">.node,e,t,r)},t.addComments=</span><span class="s1">function</span><span class="s0">(e,t){n.addComments(</span><span class="s1">this</span><span class="s0">.node,e,t)};</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=i();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">s </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,s)){</span><span class="s1">var </span><span class="s0">a=n?Object.getOwnPropertyDescriptor(e,s):</span><span class="s1">null</span><span class="s0">;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">1710</span><span class="s0">));</span><span class="s1">function </span><span class="s0">i(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">i=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}},</span><span class="s2">7036</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.call=</span><span class="s1">function</span><span class="s0">(e){const t=</span><span class="s1">this</span><span class="s0">.opts;</span><span class="s1">return this</span><span class="s0">.debug(e),!(!</span><span class="s1">this</span><span class="s0">.node||!</span><span class="s1">this</span><span class="s0">._call(t[e]))||!!</span><span class="s1">this</span><span class="s0">.node&amp;&amp;</span><span class="s1">this</span><span class="s0">._call(t[</span><span class="s1">this</span><span class="s0">.node.type]&amp;&amp;t[</span><span class="s1">this</span><span class="s0">.node.type][e])},t._call=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const t of e){</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">continue</span><span class="s0">;const e=</span><span class="s1">this</span><span class="s0">.node;</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;const r=t.call(</span><span class="s1">this</span><span class="s0">.state,</span><span class="s1">this</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state);</span><span class="s1">if</span><span class="s0">(r&amp;&amp;</span><span class="s3">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r.then)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(r)</span><span class="s1">throw new </span><span class="s0">Error(`Unexpected </span><span class="s1">return </span><span class="s0">value from visitor method ${t}`);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.node!==e)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">._traverseFlags&gt;</span><span class="s2">0</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">},t.isBlacklisted=t.isDenylisted=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">var </span><span class="s0">e;const t=</span><span class="s1">null</span><span class="s0">!=(e=</span><span class="s1">this</span><span class="s0">.opts.denylist)?e:</span><span class="s1">this</span><span class="s0">.opts.blacklist;</span><span class="s1">return </span><span class="s0">t&amp;&amp;t.indexOf(</span><span class="s1">this</span><span class="s0">.node.type)&gt;-</span><span class="s2">1</span><span class="s0">},t.visit=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.node&amp;&amp;(!</span><span class="s1">this</span><span class="s0">.isDenylisted()&amp;&amp;((!</span><span class="s1">this</span><span class="s0">.opts.shouldSkip||!</span><span class="s1">this</span><span class="s0">.opts.shouldSkip(</span><span class="s1">this</span><span class="s0">))&amp;&amp;(</span><span class="s1">this</span><span class="s0">.shouldSkip||</span><span class="s1">this</span><span class="s0">.call(</span><span class="s3">&quot;enter&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.shouldSkip?(</span><span class="s1">this</span><span class="s0">.debug(</span><span class="s3">&quot;Skip...&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.shouldStop):(</span><span class="s1">this</span><span class="s0">.debug(</span><span class="s3">&quot;Recursing into...&quot;</span><span class="s0">),i.</span><span class="s1">default</span><span class="s0">.node(</span><span class="s1">this</span><span class="s0">.node,</span><span class="s1">this</span><span class="s0">.opts,</span><span class="s1">this</span><span class="s0">.scope,</span><span class="s1">this</span><span class="s0">.state,</span><span class="s1">this</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.skipKeys),</span><span class="s1">this</span><span class="s0">.call(</span><span class="s3">&quot;exit&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.shouldStop))))},t.skip=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">.shouldSkip=!</span><span class="s2">0</span><span class="s0">},t.skipKey=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">null</span><span class="s0">==</span><span class="s1">this</span><span class="s0">.skipKeys&amp;&amp;(</span><span class="s1">this</span><span class="s0">.skipKeys={}),</span><span class="s1">this</span><span class="s0">.skipKeys[e]=!</span><span class="s2">0</span><span class="s0">},t.stop=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">._traverseFlags|=s.SHOULD_SKIP|s.SHOULD_STOP},t.setScope=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.opts&amp;&amp;</span><span class="s1">this</span><span class="s0">.opts.noScope)</span><span class="s1">return</span><span class="s0">;let e,t=</span><span class="s1">this</span><span class="s0">.parentPath;</span><span class="s1">for</span><span class="s0">(;t&amp;&amp;!e;){</span><span class="s1">if</span><span class="s0">(t.opts&amp;&amp;t.opts.noScope)</span><span class="s1">return</span><span class="s0">;e=t.scope,t=t.parentPath}</span><span class="s1">this</span><span class="s0">.scope=</span><span class="s1">this</span><span class="s0">.getScope(e),</span><span class="s1">this</span><span class="s0">.scope&amp;&amp;</span><span class="s1">this</span><span class="s0">.scope.init()},t.setContext=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return null</span><span class="s0">!=</span><span class="s1">this</span><span class="s0">.skipKeys&amp;&amp;(</span><span class="s1">this</span><span class="s0">.skipKeys={}),</span><span class="s1">this</span><span class="s0">._traverseFlags=</span><span class="s2">0</span><span class="s0">,e&amp;&amp;(</span><span class="s1">this</span><span class="s0">.context=e,</span><span class="s1">this</span><span class="s0">.state=e.state,</span><span class="s1">this</span><span class="s0">.opts=e.opts),</span><span class="s1">this</span><span class="s0">.setScope(),</span><span class="s1">this</span><span class="s0">},t.resync=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">.removed||(</span><span class="s1">this</span><span class="s0">._resyncParent(),</span><span class="s1">this</span><span class="s0">._resyncList(),</span><span class="s1">this</span><span class="s0">._resyncKey())},t._resyncParent=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">.parentPath&amp;&amp;(</span><span class="s1">this</span><span class="s0">.parent=</span><span class="s1">this</span><span class="s0">.parentPath.node)},t._resyncKey=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.container&amp;&amp;</span><span class="s1">this</span><span class="s0">.node!==</span><span class="s1">this</span><span class="s0">.container[</span><span class="s1">this</span><span class="s0">.key]){</span><span class="s1">if</span><span class="s0">(Array.isArray(</span><span class="s1">this</span><span class="s0">.container)){</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">;e&lt;</span><span class="s1">this</span><span class="s0">.container.length;e++)</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.container[e]===</span><span class="s1">this</span><span class="s0">.node)</span><span class="s1">return this</span><span class="s0">.setKey(e)}</span><span class="s1">else for</span><span class="s0">(const e of Object.keys(</span><span class="s1">this</span><span class="s0">.container))</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.container[e]===</span><span class="s1">this</span><span class="s0">.node)</span><span class="s1">return this</span><span class="s0">.setKey(e);</span><span class="s1">this</span><span class="s0">.key=</span><span class="s1">null</span><span class="s0">}},t._resyncList=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.parent||!</span><span class="s1">this</span><span class="s0">.inList)</span><span class="s1">return</span><span class="s0">;const e=</span><span class="s1">this</span><span class="s0">.parent[</span><span class="s1">this</span><span class="s0">.listKey];</span><span class="s1">this</span><span class="s0">.container!==e&amp;&amp;(</span><span class="s1">this</span><span class="s0">.container=e||</span><span class="s1">null</span><span class="s0">)},t._resyncRemoved=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">null</span><span class="s0">!=</span><span class="s1">this</span><span class="s0">.key&amp;&amp;</span><span class="s1">this</span><span class="s0">.container&amp;&amp;</span><span class="s1">this</span><span class="s0">.container[</span><span class="s1">this</span><span class="s0">.key]===</span><span class="s1">this</span><span class="s0">.node||</span><span class="s1">this</span><span class="s0">._markRemoved()},t.popContext=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">.contexts.pop(),</span><span class="s1">this</span><span class="s0">.contexts.length&gt;</span><span class="s2">0</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.setContext(</span><span class="s1">this</span><span class="s0">.contexts[</span><span class="s1">this</span><span class="s0">.contexts.length-1]):</span><span class="s1">this</span><span class="s0">.setContext(</span><span class="s1">void </span><span class="s2">0</span><span class="s0">)},t.pushContext=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">this</span><span class="s0">.contexts.push(e),</span><span class="s1">this</span><span class="s0">.setContext(e)},t.setup=</span><span class="s1">function</span><span class="s0">(e,t,r,n){</span><span class="s1">this</span><span class="s0">.listKey=r,</span><span class="s1">this</span><span class="s0">.container=t,</span><span class="s1">this</span><span class="s0">.parentPath=e||</span><span class="s1">this</span><span class="s0">.parentPath,</span><span class="s1">this</span><span class="s0">.setKey(n)},t.setKey=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">var </span><span class="s0">t;</span><span class="s1">this</span><span class="s0">.key=e,</span><span class="s1">this</span><span class="s0">.node=</span><span class="s1">this</span><span class="s0">.container[</span><span class="s1">this</span><span class="s0">.key],</span><span class="s1">this</span><span class="s0">.type=</span><span class="s1">null</span><span class="s0">==(t=</span><span class="s1">this</span><span class="s0">.node)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.type},t.requeue=</span><span class="s1">function</span><span class="s0">(e=</span><span class="s1">this</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(e.removed)</span><span class="s1">return</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.contexts;</span><span class="s1">for</span><span class="s0">(const r of t)r.maybeQueue(e)},t._getQueueContexts=</span><span class="s1">function</span><span class="s0">(){let e=</span><span class="s1">this</span><span class="s0">,t=</span><span class="s1">this</span><span class="s0">.contexts;</span><span class="s1">for</span><span class="s0">(;!t.length&amp;&amp;(e=e.parentPath,e);)t=e.contexts;</span><span class="s1">return </span><span class="s0">t};</span><span class="s1">var </span><span class="s0">n,i=(n=r(</span><span class="s2">1910</span><span class="s0">))&amp;&amp;n.__esModule?n:{</span><span class="s1">default</span><span class="s0">:n},s=r(</span><span class="s2">706</span><span class="s0">)},</span><span class="s2">7926</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.toComputedKey=</span><span class="s1">function</span><span class="s0">(){const e=</span><span class="s1">this</span><span class="s0">.node;let t;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isMemberExpression())t=e.property;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isProperty()&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isMethod())</span><span class="s1">throw new </span><span class="s0">ReferenceError(</span><span class="s3">&quot;todo&quot;</span><span class="s0">);t=e.key}</span><span class="s1">return </span><span class="s0">e.computed||i.isIdentifier(t)&amp;&amp;(t=i.stringLiteral(t.name)),t},t.ensureBlock=</span><span class="s1">function</span><span class="s0">(){const e=</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;body&quot;</span><span class="s0">),t=e.node;</span><span class="s1">if</span><span class="s0">(Array.isArray(e))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Can't convert array path to a block statement&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Can't convert node without a body&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(e.isBlockStatement())</span><span class="s1">return </span><span class="s0">t;const r=[];let n,s,a=</span><span class="s3">&quot;body&quot;</span><span class="s0">;e.isStatement()?(s=</span><span class="s3">&quot;body&quot;</span><span class="s0">,n=</span><span class="s2">0</span><span class="s0">,r.push(e.node)):(a+=</span><span class="s3">&quot;.body.0&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isFunction()?(n=</span><span class="s3">&quot;argument&quot;</span><span class="s0">,r.push(i.returnStatement(e.node))):(n=</span><span class="s3">&quot;expression&quot;</span><span class="s0">,r.push(i.expressionStatement(e.node)))),</span><span class="s1">this</span><span class="s0">.node.body=i.blockStatement(r);const o=</span><span class="s1">this</span><span class="s0">.get(a);</span><span class="s1">return </span><span class="s0">e.setup(o,s?o.node[s]:o.node,s,n),</span><span class="s1">this</span><span class="s0">.node},t.arrowFunctionToShadowed=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">.isArrowFunctionExpression()&amp;&amp;</span><span class="s1">this</span><span class="s0">.arrowFunctionToExpression()},t.unwrapFunctionEnvironment=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isArrowFunctionExpression()&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isFunctionExpression()&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isFunctionDeclaration())</span><span class="s1">throw this</span><span class="s0">.buildCodeFrameError(</span><span class="s3">&quot;Can only unwrap the environment of a function.&quot;</span><span class="s0">);o(</span><span class="s1">this</span><span class="s0">)},t.arrowFunctionToExpression=</span><span class="s1">function</span><span class="s0">({allowInsertArrow:e=!</span><span class="s2">0</span><span class="s0">,specCompliant:t=!</span><span class="s2">1</span><span class="s0">}={}){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isArrowFunctionExpression())</span><span class="s1">throw this</span><span class="s0">.buildCodeFrameError(</span><span class="s3">&quot;Cannot convert non-arrow function to a function expression.&quot;</span><span class="s0">);const r=o(</span><span class="s1">this</span><span class="s0">,t,e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.ensureBlock(),</span><span class="s1">this</span><span class="s0">.node.type=</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">,t){const e=r?</span><span class="s1">null</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.parentPath.scope.generateUidIdentifier(</span><span class="s3">&quot;arrowCheckId&quot;</span><span class="s0">);e&amp;&amp;</span><span class="s1">this</span><span class="s0">.parentPath.scope.push({id:e,init:i.objectExpression([])}),</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;body&quot;</span><span class="s0">).unshiftContainer(</span><span class="s3">&quot;body&quot;</span><span class="s0">,i.expressionStatement(i.callExpression(</span><span class="s1">this</span><span class="s0">.hub.addHelper(</span><span class="s3">&quot;newArrowCheck&quot;</span><span class="s0">),[i.thisExpression(),e?i.identifier(e.name):i.identifier(r)]))),</span><span class="s1">this</span><span class="s0">.replaceWith(i.callExpression(i.memberExpression((</span><span class="s2">0</span><span class="s0">,s.</span><span class="s1">default</span><span class="s0">)(</span><span class="s1">this</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.node,i.identifier(</span><span class="s3">&quot;bind&quot;</span><span class="s0">)),[e?i.identifier(e.name):i.thisExpression()]))}};</span><span class="s1">var </span><span class="s0">n,i=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=a();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,i)){</span><span class="s1">var </span><span class="s0">s=n?Object.getOwnPropertyDescriptor(e,i):</span><span class="s1">null</span><span class="s0">;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">1710</span><span class="s0">)),s=(n=r(</span><span class="s2">6163</span><span class="s0">))&amp;&amp;n.__esModule?n:{</span><span class="s1">default</span><span class="s0">:n};</span><span class="s1">function </span><span class="s0">a(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">a=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}</span><span class="s1">function </span><span class="s0">o(e,t=!</span><span class="s2">1</span><span class="s0">,r=!</span><span class="s2">0</span><span class="s0">){const n=e.findParent((e=&gt;e.isFunction()&amp;&amp;!e.isArrowFunctionExpression()||e.isProgram()||e.isClassProperty({static:!</span><span class="s2">1</span><span class="s0">}))),s=</span><span class="s3">&quot;constructor&quot;</span><span class="s0">===(</span><span class="s1">null</span><span class="s0">==n?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:n.node.kind);</span><span class="s1">if</span><span class="s0">(n.isClassProperty())</span><span class="s1">throw </span><span class="s0">e.buildCodeFrameError(</span><span class="s3">&quot;Unable to transform arrow inside class property&quot;</span><span class="s0">);const{thisPaths:a,argumentsPaths:o,newTargetPaths:c,superProps:u,superCalls:d}=</span><span class="s1">function</span><span class="s0">(e){const t=[],r=[],n=[],i=[],s=[];</span><span class="s1">return </span><span class="s0">e.traverse({ClassProperty(e){e.skip()},Function(e){e.isArrowFunctionExpression()||e.skip()},ThisExpression(e){t.push(e)},JSXIdentifier(e){</span><span class="s3">&quot;this&quot;</span><span class="s0">===e.node.name&amp;&amp;(e.parentPath.isJSXMemberExpression({object:e.node})||e.parentPath.isJSXOpeningElement({name:e.node}))&amp;&amp;t.push(e)},CallExpression(e){e.get(</span><span class="s3">&quot;callee&quot;</span><span class="s0">).isSuper()&amp;&amp;s.push(e)},MemberExpression(e){e.get(</span><span class="s3">&quot;object&quot;</span><span class="s0">).isSuper()&amp;&amp;i.push(e)},ReferencedIdentifier(e){</span><span class="s3">&quot;arguments&quot;</span><span class="s0">===e.node.name&amp;&amp;r.push(e)},MetaProperty(e){e.get(</span><span class="s3">&quot;meta&quot;</span><span class="s0">).isIdentifier({name:</span><span class="s3">&quot;new&quot;</span><span class="s0">})&amp;&amp;e.get(</span><span class="s3">&quot;property&quot;</span><span class="s0">).isIdentifier({name:</span><span class="s3">&quot;target&quot;</span><span class="s0">})&amp;&amp;n.push(e)}}),{thisPaths:t,argumentsPaths:r,newTargetPaths:n,superProps:i,superCalls:s}}(e);</span><span class="s1">if</span><span class="s0">(s&amp;&amp;d.length&gt;</span><span class="s2">0</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(!r)</span><span class="s1">throw </span><span class="s0">d[</span><span class="s2">0</span><span class="s0">].buildCodeFrameError(</span><span class="s3">&quot;Unable to handle nested super() usage in arrow&quot;</span><span class="s0">);const e=[];n.traverse({Function(e){e.isArrowFunctionExpression()||e.skip()},ClassProperty(e){e.skip()},CallExpression(t){t.get(</span><span class="s3">&quot;callee&quot;</span><span class="s0">).isSuper()&amp;&amp;e.push(t)}});const t=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">p(e,</span><span class="s3">&quot;supercall&quot;</span><span class="s0">,(()=&gt;{const t=e.scope.generateUidIdentifier(</span><span class="s3">&quot;args&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">i.arrowFunctionExpression([i.restElement(t)],i.callExpression(i.super(),[i.spreadElement(i.identifier(t.name))]))}))}(n);e.forEach((e=&gt;{const r=i.identifier(t);r.loc=e.node.callee.loc,e.get(</span><span class="s3">&quot;callee&quot;</span><span class="s0">).replaceWith(r)}))}</span><span class="s1">if</span><span class="s0">(o.length&gt;</span><span class="s2">0</span><span class="s0">){const e=p(n,</span><span class="s3">&quot;arguments&quot;</span><span class="s0">,(()=&gt;i.identifier(</span><span class="s3">&quot;arguments&quot;</span><span class="s0">)));o.forEach((t=&gt;{const r=i.identifier(e);r.loc=t.node.loc,t.replaceWith(r)}))}</span><span class="s1">if</span><span class="s0">(c.length&gt;</span><span class="s2">0</span><span class="s0">){const e=p(n,</span><span class="s3">&quot;newtarget&quot;</span><span class="s0">,(()=&gt;i.metaProperty(i.identifier(</span><span class="s3">&quot;new&quot;</span><span class="s0">),i.identifier(</span><span class="s3">&quot;target&quot;</span><span class="s0">))));c.forEach((t=&gt;{const r=i.identifier(e);r.loc=t.node.loc,t.replaceWith(r)}))}</span><span class="s1">if</span><span class="s0">(u.length&gt;</span><span class="s2">0</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(!r)</span><span class="s1">throw </span><span class="s0">u[</span><span class="s2">0</span><span class="s0">].buildCodeFrameError(</span><span class="s3">&quot;Unable to handle nested super.prop usage&quot;</span><span class="s0">);u.reduce(((e,t)=&gt;e.concat(</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e.parentPath.isAssignmentExpression()&amp;&amp;</span><span class="s3">&quot;=&quot;</span><span class="s0">!==e.parentPath.node.operator){const t=e.parentPath,r=t.node.operator.slice(</span><span class="s2">0</span><span class="s0">,-</span><span class="s2">1</span><span class="s0">),n=t.node.right;</span><span class="s1">if</span><span class="s0">(t.node.operator=</span><span class="s3">&quot;=&quot;</span><span class="s0">,e.node.computed){const s=e.scope.generateDeclaredUidIdentifier(</span><span class="s3">&quot;tmp&quot;</span><span class="s0">);t.get(</span><span class="s3">&quot;left&quot;</span><span class="s0">).replaceWith(i.memberExpression(e.node.object,i.assignmentExpression(</span><span class="s3">&quot;=&quot;</span><span class="s0">,s,e.node.property),!</span><span class="s2">0</span><span class="s0">)),t.get(</span><span class="s3">&quot;right&quot;</span><span class="s0">).replaceWith(i.binaryExpression(r,i.memberExpression(e.node.object,i.identifier(s.name),!</span><span class="s2">0</span><span class="s0">),n))}</span><span class="s1">else </span><span class="s0">t.get(</span><span class="s3">&quot;left&quot;</span><span class="s0">).replaceWith(i.memberExpression(e.node.object,e.node.property)),t.get(</span><span class="s3">&quot;right&quot;</span><span class="s0">).replaceWith(i.binaryExpression(r,i.memberExpression(e.node.object,i.identifier(e.node.property.name)),n));</span><span class="s1">return</span><span class="s0">[t.get(</span><span class="s3">&quot;left&quot;</span><span class="s0">),t.get(</span><span class="s3">&quot;right&quot;</span><span class="s0">).get(</span><span class="s3">&quot;left&quot;</span><span class="s0">)]}</span><span class="s1">if</span><span class="s0">(e.parentPath.isUpdateExpression()){const t=e.parentPath,r=e.scope.generateDeclaredUidIdentifier(</span><span class="s3">&quot;tmp&quot;</span><span class="s0">),n=e.node.computed?e.scope.generateDeclaredUidIdentifier(</span><span class="s3">&quot;prop&quot;</span><span class="s0">):</span><span class="s1">null</span><span class="s0">,s=[i.assignmentExpression(</span><span class="s3">&quot;=&quot;</span><span class="s0">,r,i.memberExpression(e.node.object,n?i.assignmentExpression(</span><span class="s3">&quot;=&quot;</span><span class="s0">,n,e.node.property):e.node.property,e.node.computed)),i.assignmentExpression(</span><span class="s3">&quot;=&quot;</span><span class="s0">,i.memberExpression(e.node.object,n?i.identifier(n.name):e.node.property,e.node.computed),i.binaryExpression(</span><span class="s3">&quot;+&quot;</span><span class="s0">,i.identifier(r.name),i.numericLiteral(</span><span class="s2">1</span><span class="s0">)))];</span><span class="s1">return </span><span class="s0">e.parentPath.node.prefix||s.push(i.identifier(r.name)),t.replaceWith(i.sequenceExpression(s)),[t.get(</span><span class="s3">&quot;expressions.0.right&quot;</span><span class="s0">),t.get(</span><span class="s3">&quot;expressions.1.left&quot;</span><span class="s0">)]}</span><span class="s1">return</span><span class="s0">[e]}(t))),[]).forEach((e=&gt;{const t=e.node.computed?</span><span class="s3">&quot;&quot;</span><span class="s0">:e.get(</span><span class="s3">&quot;property&quot;</span><span class="s0">).node.name,r=e.parentPath.isAssignmentExpression({left:e.node}),s=e.parentPath.isCallExpression({callee:e.node}),o=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return </span><span class="s0">p(e,`superprop_${t?</span><span class="s3">&quot;set&quot;</span><span class="s0">:</span><span class="s3">&quot;get&quot;</span><span class="s0">}:${r||</span><span class="s3">&quot;&quot;</span><span class="s0">}`,(()=&gt;{const n=[];let s;</span><span class="s1">if</span><span class="s0">(r)s=i.memberExpression(i.super(),i.identifier(r));</span><span class="s1">else</span><span class="s0">{const t=e.scope.generateUidIdentifier(</span><span class="s3">&quot;prop&quot;</span><span class="s0">);n.unshift(t),s=i.memberExpression(i.super(),i.identifier(t.name),!</span><span class="s2">0</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(t){const t=e.scope.generateUidIdentifier(</span><span class="s3">&quot;value&quot;</span><span class="s0">);n.push(t),s=i.assignmentExpression(</span><span class="s3">&quot;=&quot;</span><span class="s0">,s,i.identifier(t.name))}</span><span class="s1">return </span><span class="s0">i.arrowFunctionExpression(n,s)}))}(n,r,t),l=[];</span><span class="s1">if</span><span class="s0">(e.node.computed&amp;&amp;l.push(e.get(</span><span class="s3">&quot;property&quot;</span><span class="s0">).node),r){const t=e.parentPath.node.right;l.push(t)}const c=i.callExpression(i.identifier(o),l);s?(e.parentPath.unshiftContainer(</span><span class="s3">&quot;arguments&quot;</span><span class="s0">,i.thisExpression()),e.replaceWith(i.memberExpression(c,i.identifier(</span><span class="s3">&quot;call&quot;</span><span class="s0">))),a.push(e.parentPath.get(</span><span class="s3">&quot;arguments.0&quot;</span><span class="s0">))):r?e.parentPath.replaceWith(c):e.replaceWith(c)}))}let h;</span><span class="s1">return</span><span class="s0">(a.length&gt;</span><span class="s2">0</span><span class="s0">||t)&amp;&amp;(h=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">p(e,</span><span class="s3">&quot;this&quot;</span><span class="s0">,(r=&gt;{</span><span class="s1">if</span><span class="s0">(!t||!l(e))</span><span class="s1">return </span><span class="s0">i.thisExpression();const n=</span><span class="s1">new </span><span class="s0">WeakSet;e.traverse({Function(e){e.isArrowFunctionExpression()||e.skip()},ClassProperty(e){e.skip()},CallExpression(e){e.get(</span><span class="s3">&quot;callee&quot;</span><span class="s0">).isSuper()&amp;&amp;(n.has(e.node)||(n.add(e.node),e.replaceWithMultiple([e.node,i.assignmentExpression(</span><span class="s3">&quot;=&quot;</span><span class="s0">,i.identifier(r),i.identifier(</span><span class="s3">&quot;this&quot;</span><span class="s0">))])))}})}))}(n,s),(!t||s&amp;&amp;l(n))&amp;&amp;(a.forEach((e=&gt;{const t=e.isJSX()?i.jsxIdentifier(h):i.identifier(h);t.loc=e.node.loc,e.replaceWith(t)})),t&amp;&amp;(h=</span><span class="s1">null</span><span class="s0">))),h}</span><span class="s1">function </span><span class="s0">l(e){</span><span class="s1">return </span><span class="s0">e.isClassMethod()&amp;&amp;!!e.parentPath.parentPath.node.superClass}</span><span class="s1">function </span><span class="s0">p(e,t,r){const n=</span><span class="s3">&quot;binding:&quot;</span><span class="s0">+t;let i=e.getData(n);</span><span class="s1">if</span><span class="s0">(!i){const s=e.scope.generateUidIdentifier(t);i=s.name,e.setData(n,i),e.scope.push({id:s,init:r(i)})}</span><span class="s1">return </span><span class="s0">i}},</span><span class="s2">5635</span><span class="s0">:(e,t)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.evaluateTruthy=</span><span class="s1">function</span><span class="s0">(){const e=</span><span class="s1">this</span><span class="s0">.evaluate();</span><span class="s1">if</span><span class="s0">(e.confident)</span><span class="s1">return</span><span class="s0">!!e.value},t.evaluate=</span><span class="s1">function</span><span class="s0">(){const e={confident:!</span><span class="s2">0</span><span class="s0">,deoptPath:</span><span class="s1">null</span><span class="s0">,seen:</span><span class="s1">new </span><span class="s0">Map};let t=s(</span><span class="s1">this</span><span class="s0">,e);</span><span class="s1">return </span><span class="s0">e.confident||(t=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">),{confident:e.confident,deopt:e.deoptPath,value:t}};const r=[</span><span class="s3">&quot;String&quot;</span><span class="s0">,</span><span class="s3">&quot;Number&quot;</span><span class="s0">,</span><span class="s3">&quot;Math&quot;</span><span class="s0">],n=[</span><span class="s3">&quot;random&quot;</span><span class="s0">];</span><span class="s1">function </span><span class="s0">i(e,t){t.confident&amp;&amp;(t.deoptPath=e,t.confident=!</span><span class="s2">1</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">s(e,t){const{node:o}=e,{seen:l}=t;</span><span class="s1">if</span><span class="s0">(l.has(o)){const r=l.get(o);</span><span class="s1">return </span><span class="s0">r.resolved?r.value:</span><span class="s1">void </span><span class="s0">i(e,t)}{const p={resolved:!</span><span class="s2">1</span><span class="s0">};l.set(o,p);const c=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!t.confident)</span><span class="s1">return</span><span class="s0">;const{node:o}=e;</span><span class="s1">if</span><span class="s0">(e.isSequenceExpression()){const r=e.get(</span><span class="s3">&quot;expressions&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">s(r[r.length-1],t)}</span><span class="s1">if</span><span class="s0">(e.isStringLiteral()||e.isNumericLiteral()||e.isBooleanLiteral())</span><span class="s1">return </span><span class="s0">o.value;</span><span class="s1">if</span><span class="s0">(e.isNullLiteral())</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e.isTemplateLiteral())</span><span class="s1">return </span><span class="s0">a(e,o.quasis,t);</span><span class="s1">if</span><span class="s0">(e.isTaggedTemplateExpression()&amp;&amp;e.get(</span><span class="s3">&quot;tag&quot;</span><span class="s0">).isMemberExpression()){const r=e.get(</span><span class="s3">&quot;tag.object&quot;</span><span class="s0">),{node:{name:n}}=r,i=e.get(</span><span class="s3">&quot;tag.property&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(r.isIdentifier()&amp;&amp;</span><span class="s3">&quot;String&quot;</span><span class="s0">===n&amp;&amp;!e.scope.getBinding(n,!</span><span class="s2">0</span><span class="s0">)&amp;&amp;i.isIdentifier&amp;&amp;</span><span class="s3">&quot;raw&quot;</span><span class="s0">===i.node.name)</span><span class="s1">return </span><span class="s0">a(e,o.quasi.quasis,t,!</span><span class="s2">0</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(e.isConditionalExpression()){const r=s(e.get(</span><span class="s3">&quot;test&quot;</span><span class="s0">),t);</span><span class="s1">if</span><span class="s0">(!t.confident)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">return </span><span class="s0">s(r?e.get(</span><span class="s3">&quot;consequent&quot;</span><span class="s0">):e.get(</span><span class="s3">&quot;alternate&quot;</span><span class="s0">),t)}</span><span class="s1">if</span><span class="s0">(e.isExpressionWrapper())</span><span class="s1">return </span><span class="s0">s(e.get(</span><span class="s3">&quot;expression&quot;</span><span class="s0">),t);</span><span class="s1">if</span><span class="s0">(e.isMemberExpression()&amp;&amp;!e.parentPath.isCallExpression({callee:o})){const t=e.get(</span><span class="s3">&quot;property&quot;</span><span class="s0">),r=e.get(</span><span class="s3">&quot;object&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(r.isLiteral()&amp;&amp;t.isIdentifier()){const e=r.node.value,n=</span><span class="s1">typeof </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;number&quot;</span><span class="s0">===n||</span><span class="s3">&quot;string&quot;</span><span class="s0">===n)</span><span class="s1">return </span><span class="s0">e[t.node.name]}}</span><span class="s1">if</span><span class="s0">(e.isReferencedIdentifier()){const r=e.scope.getBinding(o.name);</span><span class="s1">if</span><span class="s0">(r&amp;&amp;r.constantViolations.length&gt;</span><span class="s2">0</span><span class="s0">)</span><span class="s1">return </span><span class="s0">i(r.path,t);</span><span class="s1">if</span><span class="s0">(r&amp;&amp;e.node.start&lt;r.path.node.end)</span><span class="s1">return </span><span class="s0">i(r.path,t);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==r?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.hasValue)</span><span class="s1">return </span><span class="s0">r.value;{</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;undefined&quot;</span><span class="s0">===o.name)</span><span class="s1">return </span><span class="s0">r?i(r.path,t):</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;Infinity&quot;</span><span class="s0">===o.name)</span><span class="s1">return </span><span class="s0">r?i(r.path,t):</span><span class="s2">1</span><span class="s0">/</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;NaN&quot;</span><span class="s0">===o.name)</span><span class="s1">return </span><span class="s0">r?i(r.path,t):NaN;const n=e.resolve();</span><span class="s1">return </span><span class="s0">n===e?i(e,t):s(n,t)}}</span><span class="s1">if</span><span class="s0">(e.isUnaryExpression({prefix:!</span><span class="s2">0</span><span class="s0">})){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;void&quot;</span><span class="s0">===o.operator)</span><span class="s1">return</span><span class="s0">;const r=e.get(</span><span class="s3">&quot;argument&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;typeof&quot;</span><span class="s0">===o.operator&amp;&amp;(r.isFunction()||r.isClass()))</span><span class="s1">return</span><span class="s3">&quot;function&quot;</span><span class="s0">;const n=s(r,t);</span><span class="s1">if</span><span class="s0">(!t.confident)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">switch</span><span class="s0">(o.operator){</span><span class="s1">case</span><span class="s3">&quot;!&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!n;</span><span class="s1">case</span><span class="s3">&quot;+&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">+n;</span><span class="s1">case</span><span class="s3">&quot;-&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">-n;</span><span class="s1">case</span><span class="s3">&quot;~&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">~n;</span><span class="s1">case</span><span class="s3">&quot;typeof&quot;</span><span class="s0">:</span><span class="s1">return typeof </span><span class="s0">n}}</span><span class="s1">if</span><span class="s0">(e.isArrayExpression()){const r=[],n=e.get(</span><span class="s3">&quot;elements&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const e of n){const n=e.evaluate();</span><span class="s1">if</span><span class="s0">(!n.confident)</span><span class="s1">return </span><span class="s0">i(n.deopt,t);r.push(n.value)}</span><span class="s1">return </span><span class="s0">r}</span><span class="s1">if</span><span class="s0">(e.isObjectExpression()){const r={},n=e.get(</span><span class="s3">&quot;properties&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const e of n){</span><span class="s1">if</span><span class="s0">(e.isObjectMethod()||e.isSpreadElement())</span><span class="s1">return </span><span class="s0">i(e,t);let n=e.get(</span><span class="s3">&quot;key&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(e.node.computed){</span><span class="s1">if</span><span class="s0">(n=n.evaluate(),!n.confident)</span><span class="s1">return </span><span class="s0">i(n.deopt,t);n=n.value}</span><span class="s1">else </span><span class="s0">n=n.isIdentifier()?n.node.name:n.node.value;let s=e.get(</span><span class="s3">&quot;value&quot;</span><span class="s0">).evaluate();</span><span class="s1">if</span><span class="s0">(!s.confident)</span><span class="s1">return </span><span class="s0">i(s.deopt,t);s=s.value,r[n]=s}</span><span class="s1">return </span><span class="s0">r}</span><span class="s1">if</span><span class="s0">(e.isLogicalExpression()){const r=t.confident,n=s(e.get(</span><span class="s3">&quot;left&quot;</span><span class="s0">),t),i=t.confident;t.confident=r;const a=s(e.get(</span><span class="s3">&quot;right&quot;</span><span class="s0">),t),l=t.confident;</span><span class="s1">switch</span><span class="s0">(o.operator){</span><span class="s1">case</span><span class="s3">&quot;||&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(t.confident=i&amp;&amp;(!!n||l),!t.confident)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">return </span><span class="s0">n||a;</span><span class="s1">case</span><span class="s3">&quot;&amp;&amp;&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(t.confident=i&amp;&amp;(!n||l),!t.confident)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">return </span><span class="s0">n&amp;&amp;a}}</span><span class="s1">if</span><span class="s0">(e.isBinaryExpression()){const r=s(e.get(</span><span class="s3">&quot;left&quot;</span><span class="s0">),t);</span><span class="s1">if</span><span class="s0">(!t.confident)</span><span class="s1">return</span><span class="s0">;const n=s(e.get(</span><span class="s3">&quot;right&quot;</span><span class="s0">),t);</span><span class="s1">if</span><span class="s0">(!t.confident)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">switch</span><span class="s0">(o.operator){</span><span class="s1">case</span><span class="s3">&quot;-&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r-n;</span><span class="s1">case</span><span class="s3">&quot;+&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r+n;</span><span class="s1">case</span><span class="s3">&quot;/&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r/n;</span><span class="s1">case</span><span class="s3">&quot;*&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r*n;</span><span class="s1">case</span><span class="s3">&quot;%&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r%n;</span><span class="s1">case</span><span class="s3">&quot;**&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">Math.pow(r,n);</span><span class="s1">case</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r&lt;n;</span><span class="s1">case</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r&gt;n;</span><span class="s1">case</span><span class="s3">&quot;&lt;=&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r&lt;=n;</span><span class="s1">case</span><span class="s3">&quot;&gt;=&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r&gt;=n;</span><span class="s1">case</span><span class="s3">&quot;==&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r==n;</span><span class="s1">case</span><span class="s3">&quot;!=&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r!=n;</span><span class="s1">case</span><span class="s3">&quot;===&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r===n;</span><span class="s1">case</span><span class="s3">&quot;!==&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r!==n;</span><span class="s1">case</span><span class="s3">&quot;|&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r|n;</span><span class="s1">case</span><span class="s3">&quot;&amp;&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r&amp;n;</span><span class="s1">case</span><span class="s3">&quot;^&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r^n;</span><span class="s1">case</span><span class="s3">&quot;&lt;&lt;&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r&lt;&lt;n;</span><span class="s1">case</span><span class="s3">&quot;&gt;&gt;&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r&gt;&gt;n;</span><span class="s1">case</span><span class="s3">&quot;&gt;&gt;&gt;&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r&gt;&gt;&gt;n}}</span><span class="s1">if</span><span class="s0">(e.isCallExpression()){const i=e.get(</span><span class="s3">&quot;callee&quot;</span><span class="s0">);let a,l;</span><span class="s1">if</span><span class="s0">(i.isIdentifier()&amp;&amp;!e.scope.getBinding(i.node.name,!</span><span class="s2">0</span><span class="s0">)&amp;&amp;r.indexOf(i.node.name)&gt;=</span><span class="s2">0</span><span class="s0">&amp;&amp;(l=global[o.callee.name]),i.isMemberExpression()){const e=i.get(</span><span class="s3">&quot;object&quot;</span><span class="s0">),t=i.get(</span><span class="s3">&quot;property&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(e.isIdentifier()&amp;&amp;t.isIdentifier()&amp;&amp;r.indexOf(e.node.name)&gt;=</span><span class="s2">0</span><span class="s0">&amp;&amp;n.indexOf(t.node.name)&lt;</span><span class="s2">0</span><span class="s0">&amp;&amp;(a=global[e.node.name],l=a[t.node.name]),e.isLiteral()&amp;&amp;t.isIdentifier()){const r=</span><span class="s1">typeof </span><span class="s0">e.node.value;</span><span class="s3">&quot;string&quot;</span><span class="s0">!==r&amp;&amp;</span><span class="s3">&quot;number&quot;</span><span class="s0">!==r||(a=e.node.value,l=a[t.node.name])}}</span><span class="s1">if</span><span class="s0">(l){const r=e.get(</span><span class="s3">&quot;arguments&quot;</span><span class="s0">).map((e=&gt;s(e,t)));</span><span class="s1">if</span><span class="s0">(!t.confident)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">return </span><span class="s0">l.apply(a,r)}}i(e,t)}(e,t);</span><span class="s1">return </span><span class="s0">t.confident&amp;&amp;(p.resolved=!</span><span class="s2">0</span><span class="s0">,p.value=c),c}}</span><span class="s1">function </span><span class="s0">a(e,t,r,n=!</span><span class="s2">1</span><span class="s0">){let i=</span><span class="s3">&quot;&quot;</span><span class="s0">,a=</span><span class="s2">0</span><span class="s0">;const o=e.get(</span><span class="s3">&quot;expressions&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const e of t){</span><span class="s1">if</span><span class="s0">(!r.confident)</span><span class="s1">break</span><span class="s0">;i+=n?e.value.raw:e.value.cooked;const t=o[a++];t&amp;&amp;(i+=String(s(t,r)))}</span><span class="s1">if</span><span class="s0">(r.confident)</span><span class="s1">return </span><span class="s0">i}},</span><span class="s2">4189</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.getOpposite=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s3">&quot;left&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.key?</span><span class="s1">this</span><span class="s0">.getSibling(</span><span class="s3">&quot;right&quot;</span><span class="s0">):</span><span class="s3">&quot;right&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.key?</span><span class="s1">this</span><span class="s0">.getSibling(</span><span class="s3">&quot;left&quot;</span><span class="s0">):</span><span class="s1">void </span><span class="s2">0</span><span class="s0">},t.getCompletionRecords=</span><span class="s1">function</span><span class="s0">(){let e=[];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isIfStatement())e=o(</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;consequent&quot;</span><span class="s0">),e),e=o(</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;alternate&quot;</span><span class="s0">),e);</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isDoExpression()||</span><span class="s1">this</span><span class="s0">.isFor()||</span><span class="s1">this</span><span class="s0">.isWhile())e=o(</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;body&quot;</span><span class="s0">),e);</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isProgram()||</span><span class="s1">this</span><span class="s0">.isBlockStatement())e=o(</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;body&quot;</span><span class="s0">).pop(),e);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isFunction())</span><span class="s1">return this</span><span class="s0">.get(</span><span class="s3">&quot;body&quot;</span><span class="s0">).getCompletionRecords();</span><span class="s1">this</span><span class="s0">.isTryStatement()?(e=o(</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;block&quot;</span><span class="s0">),e),e=o(</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;handler&quot;</span><span class="s0">),e)):</span><span class="s1">this</span><span class="s0">.isCatchClause()?e=o(</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;body&quot;</span><span class="s0">),e):</span><span class="s1">this</span><span class="s0">.isSwitchStatement()?e=</span><span class="s1">function</span><span class="s0">(e,t){let r=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let n=e.length-1;n&gt;=</span><span class="s2">0</span><span class="s0">;n--){const i=e[n].get(</span><span class="s3">&quot;consequent&quot;</span><span class="s0">);let s=l(i);</span><span class="s1">if</span><span class="s0">(s){</span><span class="s1">for</span><span class="s0">(;</span><span class="s2">0</span><span class="s0">===s.key&amp;&amp;s.parentPath.isBlockStatement();)s=s.parentPath;const e=s.getPrevSibling();s.key&gt;</span><span class="s2">0</span><span class="s0">&amp;&amp;(e.isExpressionStatement()||e.isBlockStatement())?(t=o(e,t),s.remove()):(s.replaceWith(s.scope.buildUndefinedNode()),t=o(s,t))}</span><span class="s1">else if</span><span class="s0">(r){const e=t=&gt;!t.isBlockStatement()||t.get(</span><span class="s3">&quot;body&quot;</span><span class="s0">).some(e);i.some(e)&amp;&amp;(t=o(i[i.length-1],t),r=!</span><span class="s2">1</span><span class="s0">)}}</span><span class="s1">return </span><span class="s0">t}(</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;cases&quot;</span><span class="s0">),e):e.push(</span><span class="s1">this</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e},t.getSibling=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">i.</span><span class="s1">default</span><span class="s0">.get({parentPath:</span><span class="s1">this</span><span class="s0">.parentPath,parent:</span><span class="s1">this</span><span class="s0">.parent,container:</span><span class="s1">this</span><span class="s0">.container,listKey:</span><span class="s1">this</span><span class="s0">.listKey,key:e})},t.getPrevSibling=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">.getSibling(</span><span class="s1">this</span><span class="s0">.key-1)},t.getNextSibling=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">.getSibling(</span><span class="s1">this</span><span class="s0">.key+</span><span class="s2">1</span><span class="s0">)},t.getAllNextSiblings=</span><span class="s1">function</span><span class="s0">(){let e=</span><span class="s1">this</span><span class="s0">.key,t=</span><span class="s1">this</span><span class="s0">.getSibling(++e);const r=[];</span><span class="s1">for</span><span class="s0">(;t.node;)r.push(t),t=</span><span class="s1">this</span><span class="s0">.getSibling(++e);</span><span class="s1">return </span><span class="s0">r},t.getAllPrevSiblings=</span><span class="s1">function</span><span class="s0">(){let e=</span><span class="s1">this</span><span class="s0">.key,t=</span><span class="s1">this</span><span class="s0">.getSibling(--e);const r=[];</span><span class="s1">for</span><span class="s0">(;t.node;)r.push(t),t=</span><span class="s1">this</span><span class="s0">.getSibling(--e);</span><span class="s1">return </span><span class="s0">r},t.get=</span><span class="s1">function</span><span class="s0">(e,t){!</span><span class="s2">0</span><span class="s0">===t&amp;&amp;(t=</span><span class="s1">this</span><span class="s0">.context);const r=e.split(</span><span class="s3">&quot;.&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s2">1</span><span class="s0">===r.length?</span><span class="s1">this</span><span class="s0">._getKey(e,t):</span><span class="s1">this</span><span class="s0">._getPattern(r,t)},t._getKey=</span><span class="s1">function</span><span class="s0">(e,t){const r=</span><span class="s1">this</span><span class="s0">.node,n=r[e];</span><span class="s1">return </span><span class="s0">Array.isArray(n)?n.map(((s,a)=&gt;i.</span><span class="s1">default</span><span class="s0">.get({listKey:e,parentPath:</span><span class="s1">this</span><span class="s0">,parent:r,container:n,key:a}).setContext(t))):i.</span><span class="s1">default</span><span class="s0">.get({parentPath:</span><span class="s1">this</span><span class="s0">,parent:r,container:r,key:e}).setContext(t)},t._getPattern=</span><span class="s1">function</span><span class="s0">(e,t){let r=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const n of e)r=</span><span class="s3">&quot;.&quot;</span><span class="s0">===n?r.parentPath:Array.isArray(r)?r[n]:r.get(n,t);</span><span class="s1">return </span><span class="s0">r},t.getBindingIdentifiers=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">s.getBindingIdentifiers(</span><span class="s1">this</span><span class="s0">.node,e)},t.getOuterBindingIdentifiers=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">s.getOuterBindingIdentifiers(</span><span class="s1">this</span><span class="s0">.node,e)},t.getBindingIdentifierPaths=</span><span class="s1">function</span><span class="s0">(e=!</span><span class="s2">1</span><span class="s0">,t=!</span><span class="s2">1</span><span class="s0">){let r=[].concat(</span><span class="s1">this</span><span class="s0">);const n=Object.create(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(;r.length;){const i=r.shift();</span><span class="s1">if</span><span class="s0">(!i)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!i.node)</span><span class="s1">continue</span><span class="s0">;const a=s.getBindingIdentifiers.keys[i.node.type];</span><span class="s1">if</span><span class="s0">(i.isIdentifier())e?(n[i.node.name]=n[i.node.name]||[]).push(i):n[i.node.name]=i;</span><span class="s1">else if</span><span class="s0">(i.isExportDeclaration()){const e=i.get(</span><span class="s3">&quot;declaration&quot;</span><span class="s0">);e.isDeclaration()&amp;&amp;r.push(e)}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(t){</span><span class="s1">if</span><span class="s0">(i.isFunctionDeclaration()){r.push(i.get(</span><span class="s3">&quot;id&quot;</span><span class="s0">));</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(i.isFunctionExpression())</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(a)</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">;e&lt;a.length;e++){const t=a[e],n=i.get(t);(Array.isArray(n)||n.node)&amp;&amp;(r=r.concat(n))}}}</span><span class="s1">return </span><span class="s0">n},t.getOuterBindingIdentifierPaths=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return this</span><span class="s0">.getBindingIdentifierPaths(e,!</span><span class="s2">0</span><span class="s0">)};</span><span class="s1">var </span><span class="s0">n,i=(n=r(</span><span class="s2">706</span><span class="s0">))&amp;&amp;n.__esModule?n:{</span><span class="s1">default</span><span class="s0">:n},s=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=a();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,i)){</span><span class="s1">var </span><span class="s0">s=n?Object.getOwnPropertyDescriptor(e,i):</span><span class="s1">null</span><span class="s0">;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">1710</span><span class="s0">));</span><span class="s1">function </span><span class="s0">a(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">a=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}</span><span class="s1">function </span><span class="s0">o(e,t){</span><span class="s1">return </span><span class="s0">e?t.concat(e.getCompletionRecords()):t}</span><span class="s1">function </span><span class="s0">l(e){let t;Array.isArray(e)||(e=[e]);</span><span class="s1">for</span><span class="s0">(const i of e){</span><span class="s1">if</span><span class="s0">(i.isDoExpression()||i.isProgram()||i.isBlockStatement()||i.isCatchClause()||i.isLabeledStatement())t=l(i.get(</span><span class="s3">&quot;body&quot;</span><span class="s0">));</span><span class="s1">else if</span><span class="s0">(i.isIfStatement()){</span><span class="s1">var </span><span class="s0">r;t=</span><span class="s1">null</span><span class="s0">!=(r=l(i.get(</span><span class="s3">&quot;consequent&quot;</span><span class="s0">)))?r:l(i.get(</span><span class="s3">&quot;alternate&quot;</span><span class="s0">))}</span><span class="s1">else if</span><span class="s0">(i.isTryStatement()){</span><span class="s1">var </span><span class="s0">n;t=</span><span class="s1">null</span><span class="s0">!=(n=l(i.get(</span><span class="s3">&quot;block&quot;</span><span class="s0">)))?n:l(i.get(</span><span class="s3">&quot;handler&quot;</span><span class="s0">))}</span><span class="s1">else </span><span class="s0">i.isBreakStatement()&amp;&amp;(t=i);</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return </span><span class="s0">t}</span><span class="s1">return null</span><span class="s0">}},</span><span class="s2">706</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=t.SHOULD_SKIP=t.SHOULD_STOP=t.REMOVED=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=P(r(</span><span class="s2">1025</span><span class="s0">)),i=x(r(</span><span class="s2">4410</span><span class="s0">)),s=x(r(</span><span class="s2">1910</span><span class="s0">)),a=x(r(</span><span class="s2">4639</span><span class="s0">)),o=P(r(</span><span class="s2">1710</span><span class="s0">)),l=r(</span><span class="s2">1826</span><span class="s0">),p=x(r(</span><span class="s2">5386</span><span class="s0">)),c=P(r(</span><span class="s2">8152</span><span class="s0">)),u=P(r(</span><span class="s2">3078</span><span class="s0">)),d=P(r(</span><span class="s2">4638</span><span class="s0">)),h=P(r(</span><span class="s2">5635</span><span class="s0">)),f=P(r(</span><span class="s2">7926</span><span class="s0">)),m=P(r(</span><span class="s2">5201</span><span class="s0">)),y=P(r(</span><span class="s2">7036</span><span class="s0">)),T=P(r(</span><span class="s2">6788</span><span class="s0">)),b=P(r(</span><span class="s2">9613</span><span class="s0">)),g=P(r(</span><span class="s2">4189</span><span class="s0">)),S=P(r(</span><span class="s2">7403</span><span class="s0">));</span><span class="s1">function </span><span class="s0">x(e){</span><span class="s1">return </span><span class="s0">e&amp;&amp;e.__esModule?e:{</span><span class="s1">default</span><span class="s0">:e}}</span><span class="s1">function </span><span class="s0">E(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">E=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}</span><span class="s1">function </span><span class="s0">P(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=E();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,i)){</span><span class="s1">var </span><span class="s0">s=n?Object.getOwnPropertyDescriptor(e,i):</span><span class="s1">null</span><span class="s0">;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}const v=(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(</span><span class="s3">&quot;babel&quot;</span><span class="s0">);t.REMOVED=</span><span class="s2">1</span><span class="s0">,t.SHOULD_STOP=</span><span class="s2">2</span><span class="s0">,t.SHOULD_SKIP=</span><span class="s2">4</span><span class="s0">;class A{constructor(e,t){</span><span class="s1">this</span><span class="s0">.contexts=[],</span><span class="s1">this</span><span class="s0">.state=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.opts=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._traverseFlags=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.skipKeys=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parentPath=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.container=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.listKey=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.key=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.node=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.type=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parent=t,</span><span class="s1">this</span><span class="s0">.hub=e,</span><span class="s1">this</span><span class="s0">.data=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.context=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.scope=</span><span class="s1">null</span><span class="s0">}static get({hub:e,parentPath:t,parent:r,container:n,listKey:i,key:s}){</span><span class="s1">if</span><span class="s0">(!e&amp;&amp;t&amp;&amp;(e=t.hub),!r)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;To get a node path the parent needs to exist&quot;</span><span class="s0">);const a=n[s],o=l.path.get(r)||[];let p;l.path.has(r)||l.path.set(r,o);</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">;e&lt;o.length;e++){const t=o[e];</span><span class="s1">if</span><span class="s0">(t.node===a){p=t;</span><span class="s1">break</span><span class="s0">}}</span><span class="s1">return </span><span class="s0">p||(p=</span><span class="s1">new </span><span class="s0">A(e,r),o.push(p)),p.setup(t,n,i,s),p}getScope(e){</span><span class="s1">return this</span><span class="s0">.isScope()?</span><span class="s1">new </span><span class="s0">a.</span><span class="s1">default</span><span class="s0">(</span><span class="s1">this</span><span class="s0">):e}setData(e,t){</span><span class="s1">return null</span><span class="s0">==</span><span class="s1">this</span><span class="s0">.data&amp;&amp;(</span><span class="s1">this</span><span class="s0">.data=Object.create(</span><span class="s1">null</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.data[e]=t}getData(e,t){</span><span class="s1">null</span><span class="s0">==</span><span class="s1">this</span><span class="s0">.data&amp;&amp;(</span><span class="s1">this</span><span class="s0">.data=Object.create(</span><span class="s1">null</span><span class="s0">));let r=</span><span class="s1">this</span><span class="s0">.data[e];</span><span class="s1">return void </span><span class="s2">0</span><span class="s0">===r&amp;&amp;</span><span class="s1">void </span><span class="s2">0</span><span class="s0">!==t&amp;&amp;(r=</span><span class="s1">this</span><span class="s0">.data[e]=t),r}buildCodeFrameError(e,t=SyntaxError){</span><span class="s1">return this</span><span class="s0">.hub.buildError(</span><span class="s1">this</span><span class="s0">.node,e,t)}traverse(e,t){(</span><span class="s2">0</span><span class="s0">,s.</span><span class="s1">default</span><span class="s0">)(</span><span class="s1">this</span><span class="s0">.node,e,</span><span class="s1">this</span><span class="s0">.scope,t,</span><span class="s1">this</span><span class="s0">)}set(e,t){o.validate(</span><span class="s1">this</span><span class="s0">.node,e,t),</span><span class="s1">this</span><span class="s0">.node[e]=t}getPathLocation(){const e=[];let t=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{let r=t.key;t.inList&amp;&amp;(r=`${t.listKey}[${r}]`),e.unshift(r)}</span><span class="s1">while</span><span class="s0">(t=t.parentPath);</span><span class="s1">return </span><span class="s0">e.join(</span><span class="s3">&quot;.&quot;</span><span class="s0">)}debug(e){v.enabled&amp;&amp;v(`${</span><span class="s1">this</span><span class="s0">.getPathLocation()} ${</span><span class="s1">this</span><span class="s0">.type}: ${e}`)}toString(){</span><span class="s1">return</span><span class="s0">(</span><span class="s2">0</span><span class="s0">,p.</span><span class="s1">default</span><span class="s0">)(</span><span class="s1">this</span><span class="s0">.node).code}get inList(){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.listKey}set inList(e){e||(</span><span class="s1">this</span><span class="s0">.listKey=</span><span class="s1">null</span><span class="s0">)}get parentKey(){</span><span class="s1">return this</span><span class="s0">.listKey||</span><span class="s1">this</span><span class="s0">.key}get shouldSkip(){</span><span class="s1">return</span><span class="s0">!!(</span><span class="s2">4</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">._traverseFlags)}set shouldSkip(e){e?</span><span class="s1">this</span><span class="s0">._traverseFlags|=</span><span class="s2">4</span><span class="s0">:</span><span class="s1">this</span><span class="s0">._traverseFlags&amp;=-</span><span class="s2">5</span><span class="s0">}get shouldStop(){</span><span class="s1">return</span><span class="s0">!!(</span><span class="s2">2</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">._traverseFlags)}set shouldStop(e){e?</span><span class="s1">this</span><span class="s0">._traverseFlags|=</span><span class="s2">2</span><span class="s0">:</span><span class="s1">this</span><span class="s0">._traverseFlags&amp;=-</span><span class="s2">3</span><span class="s0">}get removed(){</span><span class="s1">return</span><span class="s0">!!(</span><span class="s2">1</span><span class="s0">&amp;</span><span class="s1">this</span><span class="s0">._traverseFlags)}set removed(e){e?</span><span class="s1">this</span><span class="s0">._traverseFlags|=</span><span class="s2">1</span><span class="s0">:</span><span class="s1">this</span><span class="s0">._traverseFlags&amp;=-</span><span class="s2">2</span><span class="s0">}}t.</span><span class="s1">default</span><span class="s0">=A,Object.assign(A.prototype,c,u,d,h,f,m,y,T,b,g,S);</span><span class="s1">for</span><span class="s0">(const e of o.TYPES){const t=`is${e}`,r=o[t];A.prototype[t]=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">r(</span><span class="s1">this</span><span class="s0">.node,e)},A.prototype[`assert${e}`]=</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">if</span><span class="s0">(!r(</span><span class="s1">this</span><span class="s0">.node,t))</span><span class="s1">throw new </span><span class="s0">TypeError(`Expected node path of type ${e}`)}}</span><span class="s1">for</span><span class="s0">(const e of Object.keys(n)){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;_&quot;</span><span class="s0">===e[</span><span class="s2">0</span><span class="s0">])</span><span class="s1">continue</span><span class="s0">;o.TYPES.indexOf(e)&lt;</span><span class="s2">0</span><span class="s0">&amp;&amp;o.TYPES.push(e);const t=n[e];A.prototype[`is${e}`]=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">t.checkPath(</span><span class="s1">this</span><span class="s0">,e)}}},</span><span class="s2">3078</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.getTypeAnnotation=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.typeAnnotation)</span><span class="s1">return this</span><span class="s0">.typeAnnotation;let e=</span><span class="s1">this</span><span class="s0">._getTypeAnnotation()||i.anyTypeAnnotation();</span><span class="s1">return </span><span class="s0">i.isTypeAnnotation(e)&amp;&amp;(e=e.typeAnnotation),</span><span class="s1">this</span><span class="s0">.typeAnnotation=e},t._getTypeAnnotation=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">var </span><span class="s0">e;const t=</span><span class="s1">this</span><span class="s0">.node;</span><span class="s1">if</span><span class="s0">(!t){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;init&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.key&amp;&amp;</span><span class="s1">this</span><span class="s0">.parentPath.isVariableDeclarator()){const e=</span><span class="s1">this</span><span class="s0">.parentPath.parentPath,t=e.parentPath;</span><span class="s1">return</span><span class="s3">&quot;left&quot;</span><span class="s0">===e.key&amp;&amp;t.isForInStatement()?i.stringTypeAnnotation():</span><span class="s3">&quot;left&quot;</span><span class="s0">===e.key&amp;&amp;t.isForOfStatement()?i.anyTypeAnnotation():i.voidTypeAnnotation()}</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(t.typeAnnotation)</span><span class="s1">return </span><span class="s0">t.typeAnnotation;let r=n[t.type];</span><span class="s1">return </span><span class="s0">r?r.call(</span><span class="s1">this</span><span class="s0">,t):(r=n[</span><span class="s1">this</span><span class="s0">.parentPath.type],(</span><span class="s1">null</span><span class="s0">==(e=r)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:e.validParent)?</span><span class="s1">this</span><span class="s0">.parentPath.getTypeAnnotation():</span><span class="s1">void </span><span class="s2">0</span><span class="s0">)},t.isBaseType=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">o(e,</span><span class="s1">this</span><span class="s0">.getTypeAnnotation(),t)},t.couldBeBaseType=</span><span class="s1">function</span><span class="s0">(e){const t=</span><span class="s1">this</span><span class="s0">.getTypeAnnotation();</span><span class="s1">if</span><span class="s0">(i.isAnyTypeAnnotation(t))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(i.isUnionTypeAnnotation(t)){</span><span class="s1">for</span><span class="s0">(const r of t.types)</span><span class="s1">if</span><span class="s0">(i.isAnyTypeAnnotation(r)||o(e,r,!</span><span class="s2">0</span><span class="s0">))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}</span><span class="s1">return </span><span class="s0">o(e,t,!</span><span class="s2">0</span><span class="s0">)},t.baseTypeStrictlyMatches=</span><span class="s1">function</span><span class="s0">(e){const t=</span><span class="s1">this</span><span class="s0">.getTypeAnnotation();</span><span class="s1">if</span><span class="s0">(e=e.getTypeAnnotation(),!i.isAnyTypeAnnotation(t)&amp;&amp;i.isFlowBaseAnnotation(t))</span><span class="s1">return </span><span class="s0">e.type===t.type},t.isGenericType=</span><span class="s1">function</span><span class="s0">(e){const t=</span><span class="s1">this</span><span class="s0">.getTypeAnnotation();</span><span class="s1">return </span><span class="s0">i.isGenericTypeAnnotation(t)&amp;&amp;i.isIdentifier(t.id,{name:e})};</span><span class="s1">var </span><span class="s0">n=a(r(</span><span class="s2">4606</span><span class="s0">)),i=a(r(</span><span class="s2">1710</span><span class="s0">));</span><span class="s1">function </span><span class="s0">s(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">s=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}</span><span class="s1">function </span><span class="s0">a(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=s();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,i)){</span><span class="s1">var </span><span class="s0">a=n?Object.getOwnPropertyDescriptor(e,i):</span><span class="s1">null</span><span class="s0">;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,i,a):r[i]=e[i]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}</span><span class="s1">function </span><span class="s0">o(e,t,r){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;string&quot;</span><span class="s0">===e)</span><span class="s1">return </span><span class="s0">i.isStringTypeAnnotation(t);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;number&quot;</span><span class="s0">===e)</span><span class="s1">return </span><span class="s0">i.isNumberTypeAnnotation(t);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;boolean&quot;</span><span class="s0">===e)</span><span class="s1">return </span><span class="s0">i.isBooleanTypeAnnotation(t);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;any&quot;</span><span class="s0">===e)</span><span class="s1">return </span><span class="s0">i.isAnyTypeAnnotation(t);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;mixed&quot;</span><span class="s0">===e)</span><span class="s1">return </span><span class="s0">i.isMixedTypeAnnotation(t);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;empty&quot;</span><span class="s0">===e)</span><span class="s1">return </span><span class="s0">i.isEmptyTypeAnnotation(t);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;void&quot;</span><span class="s0">===e)</span><span class="s1">return </span><span class="s0">i.isVoidTypeAnnotation(t);</span><span class="s1">if</span><span class="s0">(r)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">throw new </span><span class="s0">Error(`Unknown base type ${e}`)}},</span><span class="s2">7875</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isReferenced())</span><span class="s1">return</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.scope.getBinding(e.name);</span><span class="s1">return </span><span class="s0">t?t.identifier.typeAnnotation?t.identifier.typeAnnotation:</span><span class="s1">function</span><span class="s0">(e,t,r){const i=[],a=[];let l=s(e,t,a);const p=o(e,t,r);</span><span class="s1">if</span><span class="s0">(p){const t=s(e,p.ifStatement);l=l.filter((e=&gt;t.indexOf(e)&lt;</span><span class="s2">0</span><span class="s0">)),i.push(p.typeAnnotation)}</span><span class="s1">if</span><span class="s0">(l.length){l=l.concat(a);</span><span class="s1">for</span><span class="s0">(const e of l)i.push(e.getTypeAnnotation())}</span><span class="s1">if</span><span class="s0">(i.length)</span><span class="s1">return </span><span class="s0">n.isTSTypeAnnotation(i[</span><span class="s2">0</span><span class="s0">])&amp;&amp;n.createTSUnionType?n.createTSUnionType(i):n.createFlowUnionType?n.createFlowUnionType(i):n.createUnionTypeAnnotation(i)}(t,</span><span class="s1">this</span><span class="s0">,e.name):</span><span class="s3">&quot;undefined&quot;</span><span class="s0">===e.name?n.voidTypeAnnotation():</span><span class="s3">&quot;NaN&quot;</span><span class="s0">===e.name||</span><span class="s3">&quot;Infinity&quot;</span><span class="s0">===e.name?n.numberTypeAnnotation():</span><span class="s1">void </span><span class="s0">e.name};</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=i();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">s </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,s)){</span><span class="s1">var </span><span class="s0">a=n?Object.getOwnPropertyDescriptor(e,s):</span><span class="s1">null</span><span class="s0">;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">1710</span><span class="s0">));</span><span class="s1">function </span><span class="s0">i(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">i=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}</span><span class="s1">function </span><span class="s0">s(e,t,r){const n=e.constantViolations.slice();</span><span class="s1">return </span><span class="s0">n.unshift(e.path),n.filter((e=&gt;{const n=(e=e.resolve())._guessExecutionStatusRelativeTo(t);</span><span class="s1">return </span><span class="s0">r&amp;&amp;</span><span class="s3">&quot;unknown&quot;</span><span class="s0">===n&amp;&amp;r.push(e),</span><span class="s3">&quot;before&quot;</span><span class="s0">===n}))}</span><span class="s1">function </span><span class="s0">a(e,t){const r=t.node.operator,i=t.get(</span><span class="s3">&quot;right&quot;</span><span class="s0">).resolve(),s=t.get(</span><span class="s3">&quot;left&quot;</span><span class="s0">).resolve();let a,o,l;</span><span class="s1">if</span><span class="s0">(s.isIdentifier({name:e})?a=i:i.isIdentifier({name:e})&amp;&amp;(a=s),a)</span><span class="s1">return</span><span class="s3">&quot;===&quot;</span><span class="s0">===r?a.getTypeAnnotation():n.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(r)&gt;=</span><span class="s2">0</span><span class="s0">?n.numberTypeAnnotation():</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;===&quot;</span><span class="s0">!==r&amp;&amp;</span><span class="s3">&quot;==&quot;</span><span class="s0">!==r)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(s.isUnaryExpression({operator:</span><span class="s3">&quot;typeof&quot;</span><span class="s0">})?(o=s,l=i):i.isUnaryExpression({operator:</span><span class="s3">&quot;typeof&quot;</span><span class="s0">})&amp;&amp;(o=i,l=s),!o)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!o.get(</span><span class="s3">&quot;argument&quot;</span><span class="s0">).isIdentifier({name:e}))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(l=l.resolve(),!l.isLiteral())</span><span class="s1">return</span><span class="s0">;const p=l.node.value;</span><span class="s1">return</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">p?n.createTypeAnnotationBasedOnTypeof(p):</span><span class="s1">void </span><span class="s2">0</span><span class="s0">}</span><span class="s1">function </span><span class="s0">o(e,t,r){const i=</span><span class="s1">function</span><span class="s0">(e,t,r){let n;</span><span class="s1">for</span><span class="s0">(;n=t.parentPath;){</span><span class="s1">if</span><span class="s0">(n.isIfStatement()||n.isConditionalExpression()){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;test&quot;</span><span class="s0">===t.key)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">return </span><span class="s0">n}</span><span class="s1">if</span><span class="s0">(n.isFunction()&amp;&amp;n.parentPath.scope.getBinding(r)!==e)</span><span class="s1">return</span><span class="s0">;t=n}}(e,t,r);</span><span class="s1">if</span><span class="s0">(!i)</span><span class="s1">return</span><span class="s0">;const s=[i.get(</span><span class="s3">&quot;test&quot;</span><span class="s0">)],l=[];</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">;e&lt;s.length;e++){const t=s[e];</span><span class="s1">if</span><span class="s0">(t.isLogicalExpression())</span><span class="s3">&quot;&amp;&amp;&quot;</span><span class="s0">===t.node.operator&amp;&amp;(s.push(t.get(</span><span class="s3">&quot;left&quot;</span><span class="s0">)),s.push(t.get(</span><span class="s3">&quot;right&quot;</span><span class="s0">)));</span><span class="s1">else if</span><span class="s0">(t.isBinaryExpression()){const e=a(r,t);e&amp;&amp;l.push(e)}}</span><span class="s1">return </span><span class="s0">l.length?n.isTSTypeAnnotation(l[</span><span class="s2">0</span><span class="s0">])&amp;&amp;n.createTSUnionType?{typeAnnotation:n.createTSUnionType(l),ifStatement:i}:n.createFlowUnionType?{typeAnnotation:n.createFlowUnionType(l),ifStatement:i}:{typeAnnotation:n.createUnionTypeAnnotation(l),ifStatement:i}:o(i,r)}},</span><span class="s2">4606</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.VariableDeclarator=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">var </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;id&quot;</span><span class="s0">).isIdentifier())</span><span class="s1">return</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;init&quot;</span><span class="s0">);let r=t.getTypeAnnotation();</span><span class="s1">return</span><span class="s3">&quot;AnyTypeAnnotation&quot;</span><span class="s0">===(</span><span class="s1">null</span><span class="s0">==(e=r)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:e.type)&amp;&amp;t.isCallExpression()&amp;&amp;t.get(</span><span class="s3">&quot;callee&quot;</span><span class="s0">).isIdentifier({name:</span><span class="s3">&quot;Array&quot;</span><span class="s0">})&amp;&amp;!t.scope.hasBinding(</span><span class="s3">&quot;Array&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">)&amp;&amp;(r=l()),r},t.TypeCastExpression=o,t.NewExpression=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;callee&quot;</span><span class="s0">).isIdentifier())</span><span class="s1">return </span><span class="s0">i.genericTypeAnnotation(e.callee)},t.TemplateLiteral=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.stringTypeAnnotation()},t.UnaryExpression=</span><span class="s1">function</span><span class="s0">(e){const t=e.operator;</span><span class="s1">return</span><span class="s3">&quot;void&quot;</span><span class="s0">===t?i.voidTypeAnnotation():i.NUMBER_UNARY_OPERATORS.indexOf(t)&gt;=</span><span class="s2">0</span><span class="s0">?i.numberTypeAnnotation():i.STRING_UNARY_OPERATORS.indexOf(t)&gt;=</span><span class="s2">0</span><span class="s0">?i.stringTypeAnnotation():i.BOOLEAN_UNARY_OPERATORS.indexOf(t)&gt;=</span><span class="s2">0</span><span class="s0">?i.booleanTypeAnnotation():</span><span class="s1">void </span><span class="s2">0</span><span class="s0">},t.BinaryExpression=</span><span class="s1">function</span><span class="s0">(e){const t=e.operator;</span><span class="s1">if</span><span class="s0">(i.NUMBER_BINARY_OPERATORS.indexOf(t)&gt;=</span><span class="s2">0</span><span class="s0">)</span><span class="s1">return </span><span class="s0">i.numberTypeAnnotation();</span><span class="s1">if</span><span class="s0">(i.BOOLEAN_BINARY_OPERATORS.indexOf(t)&gt;=</span><span class="s2">0</span><span class="s0">)</span><span class="s1">return </span><span class="s0">i.booleanTypeAnnotation();</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;+&quot;</span><span class="s0">===t){const e=</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;right&quot;</span><span class="s0">),t=</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;left&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">t.isBaseType(</span><span class="s3">&quot;number&quot;</span><span class="s0">)&amp;&amp;e.isBaseType(</span><span class="s3">&quot;number&quot;</span><span class="s0">)?i.numberTypeAnnotation():t.isBaseType(</span><span class="s3">&quot;string&quot;</span><span class="s0">)||e.isBaseType(</span><span class="s3">&quot;string&quot;</span><span class="s0">)?i.stringTypeAnnotation():i.unionTypeAnnotation([i.stringTypeAnnotation(),i.numberTypeAnnotation()])}},t.LogicalExpression=</span><span class="s1">function</span><span class="s0">(){const e=[</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;left&quot;</span><span class="s0">).getTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;right&quot;</span><span class="s0">).getTypeAnnotation()];</span><span class="s1">return </span><span class="s0">i.isTSTypeAnnotation(e[</span><span class="s2">0</span><span class="s0">])&amp;&amp;i.createTSUnionType?i.createTSUnionType(e):i.createFlowUnionType?i.createFlowUnionType(e):i.createUnionTypeAnnotation(e)},t.ConditionalExpression=</span><span class="s1">function</span><span class="s0">(){const e=[</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;consequent&quot;</span><span class="s0">).getTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;alternate&quot;</span><span class="s0">).getTypeAnnotation()];</span><span class="s1">return </span><span class="s0">i.isTSTypeAnnotation(e[</span><span class="s2">0</span><span class="s0">])&amp;&amp;i.createTSUnionType?i.createTSUnionType(e):i.createFlowUnionType?i.createFlowUnionType(e):i.createUnionTypeAnnotation(e)},t.SequenceExpression=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">.get(</span><span class="s3">&quot;expressions&quot;</span><span class="s0">).pop().getTypeAnnotation()},t.ParenthesizedExpression=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">.get(</span><span class="s3">&quot;expression&quot;</span><span class="s0">).getTypeAnnotation()},t.AssignmentExpression=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">.get(</span><span class="s3">&quot;right&quot;</span><span class="s0">).getTypeAnnotation()},t.UpdateExpression=</span><span class="s1">function</span><span class="s0">(e){const t=e.operator;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;++&quot;</span><span class="s0">===t||</span><span class="s3">&quot;--&quot;</span><span class="s0">===t)</span><span class="s1">return </span><span class="s0">i.numberTypeAnnotation()},t.StringLiteral=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.stringTypeAnnotation()},t.NumericLiteral=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.numberTypeAnnotation()},t.BooleanLiteral=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.booleanTypeAnnotation()},t.NullLiteral=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.nullLiteralTypeAnnotation()},t.RegExpLiteral=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.genericTypeAnnotation(i.identifier(</span><span class="s3">&quot;RegExp&quot;</span><span class="s0">))},t.ObjectExpression=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.genericTypeAnnotation(i.identifier(</span><span class="s3">&quot;Object&quot;</span><span class="s0">))},t.ArrayExpression=l,t.RestElement=p,t.ClassDeclaration=t.ClassExpression=t.FunctionDeclaration=t.ArrowFunctionExpression=t.FunctionExpression=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">i.genericTypeAnnotation(i.identifier(</span><span class="s3">&quot;Function&quot;</span><span class="s0">))},t.CallExpression=</span><span class="s1">function</span><span class="s0">(){const{callee:e}=</span><span class="s1">this</span><span class="s0">.node;</span><span class="s1">return </span><span class="s0">u(e)?i.arrayTypeAnnotation(i.stringTypeAnnotation()):c(e)||d(e)?i.arrayTypeAnnotation(i.anyTypeAnnotation()):h(e)?i.arrayTypeAnnotation(i.tupleTypeAnnotation([i.stringTypeAnnotation(),i.anyTypeAnnotation()])):f(</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;callee&quot;</span><span class="s0">))},t.TaggedTemplateExpression=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">f(</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;tag&quot;</span><span class="s0">))},Object.defineProperty(t,</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,{enumerable:!</span><span class="s2">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">s.</span><span class="s1">default</span><span class="s0">}});</span><span class="s1">var </span><span class="s0">n,i=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=a();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,i)){</span><span class="s1">var </span><span class="s0">s=n?Object.getOwnPropertyDescriptor(e,i):</span><span class="s1">null</span><span class="s0">;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">1710</span><span class="s0">)),s=(n=r(</span><span class="s2">7875</span><span class="s0">))&amp;&amp;n.__esModule?n:{</span><span class="s1">default</span><span class="s0">:n};</span><span class="s1">function </span><span class="s0">a(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">a=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}</span><span class="s1">function </span><span class="s0">o(e){</span><span class="s1">return </span><span class="s0">e.typeAnnotation}</span><span class="s1">function </span><span class="s0">l(){</span><span class="s1">return </span><span class="s0">i.genericTypeAnnotation(i.identifier(</span><span class="s3">&quot;Array&quot;</span><span class="s0">))}</span><span class="s1">function </span><span class="s0">p(){</span><span class="s1">return </span><span class="s0">l()}o.validParent=!</span><span class="s2">0</span><span class="s0">,p.validParent=!</span><span class="s2">0</span><span class="s0">;const c=i.buildMatchMemberExpression(</span><span class="s3">&quot;Array.from&quot;</span><span class="s0">),u=i.buildMatchMemberExpression(</span><span class="s3">&quot;Object.keys&quot;</span><span class="s0">),d=i.buildMatchMemberExpression(</span><span class="s3">&quot;Object.values&quot;</span><span class="s0">),h=i.buildMatchMemberExpression(</span><span class="s3">&quot;Object.entries&quot;</span><span class="s0">);</span><span class="s1">function </span><span class="s0">f(e){</span><span class="s1">if</span><span class="s0">((e=e.resolve()).isFunction()){</span><span class="s1">if</span><span class="s0">(e.is(</span><span class="s3">&quot;async&quot;</span><span class="s0">))</span><span class="s1">return </span><span class="s0">e.is(</span><span class="s3">&quot;generator&quot;</span><span class="s0">)?i.genericTypeAnnotation(i.identifier(</span><span class="s3">&quot;AsyncIterator&quot;</span><span class="s0">)):i.genericTypeAnnotation(i.identifier(</span><span class="s3">&quot;Promise&quot;</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(e.node.returnType)</span><span class="s1">return </span><span class="s0">e.node.returnType}}},</span><span class="s2">5201</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.matchesPattern=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">n.matchesPattern(</span><span class="s1">this</span><span class="s0">.node,e,t)},t.has=s,t.isStatic=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">.scope.isStatic(</span><span class="s1">this</span><span class="s0">.node)},t.isnt=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.has(e)},t.equals=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return this</span><span class="s0">.node[e]===t},t.isNodeType=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">n.isType(</span><span class="s1">this</span><span class="s0">.type,e)},t.canHaveVariableDeclarationOrExpression=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">(</span><span class="s3">&quot;init&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.key||</span><span class="s3">&quot;left&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.key)&amp;&amp;</span><span class="s1">this</span><span class="s0">.parentPath.isFor()},t.canSwapBetweenExpressionAndStatement=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">!(</span><span class="s3">&quot;body&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.key||!</span><span class="s1">this</span><span class="s0">.parentPath.isArrowFunctionExpression())&amp;&amp;(</span><span class="s1">this</span><span class="s0">.isExpression()?n.isBlockStatement(e):!!</span><span class="s1">this</span><span class="s0">.isBlockStatement()&amp;&amp;n.isExpression(e))},t.isCompletionRecord=</span><span class="s1">function</span><span class="s0">(e){let t=</span><span class="s1">this</span><span class="s0">,r=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{const n=t.container;</span><span class="s1">if</span><span class="s0">(t.isFunction()&amp;&amp;!r)</span><span class="s1">return</span><span class="s0">!!e;</span><span class="s1">if</span><span class="s0">(r=!</span><span class="s2">1</span><span class="s0">,Array.isArray(n)&amp;&amp;t.key!==n.length-1)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}</span><span class="s1">while</span><span class="s0">((t=t.parentPath)&amp;&amp;!t.isProgram());</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">},t.isStatementOrBlock=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.parentPath.isLabeledStatement()&amp;&amp;!n.isBlockStatement(</span><span class="s1">this</span><span class="s0">.container)&amp;&amp;n.STATEMENT_OR_BLOCK_KEYS.includes(</span><span class="s1">this</span><span class="s0">.key)},t.referencesImport=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isReferencedIdentifier())</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const r=</span><span class="s1">this</span><span class="s0">.scope.getBinding(</span><span class="s1">this</span><span class="s0">.node.name);</span><span class="s1">if</span><span class="s0">(!r||</span><span class="s3">&quot;module&quot;</span><span class="s0">!==r.kind)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;const n=r.path,i=n.parentPath;</span><span class="s1">return</span><span class="s0">!!i.isImportDeclaration()&amp;&amp;(i.node.source.value===e&amp;&amp;(!t||(!(!n.isImportDefaultSpecifier()||</span><span class="s3">&quot;default&quot;</span><span class="s0">!==t)||(!(!n.isImportNamespaceSpecifier()||</span><span class="s3">&quot;*&quot;</span><span class="s0">!==t)||!(!n.isImportSpecifier()||n.node.imported.name!==t)))))},t.getSource=</span><span class="s1">function</span><span class="s0">(){const e=</span><span class="s1">this</span><span class="s0">.node;</span><span class="s1">if</span><span class="s0">(e.end){const t=</span><span class="s1">this</span><span class="s0">.hub.getCode();</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return </span><span class="s0">t.slice(e.start,e.end)}</span><span class="s1">return</span><span class="s3">&quot;&quot;</span><span class="s0">},t.willIMaybeExecuteBefore=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s3">&quot;after&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">._guessExecutionStatusRelativeTo(e)},t._guessExecutionStatusRelativeTo=</span><span class="s1">function</span><span class="s0">(e){const t={</span><span class="s1">this</span><span class="s0">:o(</span><span class="s1">this</span><span class="s0">),target:o(e)};</span><span class="s1">if</span><span class="s0">(t.target.node!==t.</span><span class="s1">this</span><span class="s0">.node)</span><span class="s1">return this</span><span class="s0">._guessExecutionStatusRelativeToDifferentFunctions(t.target);const r={target:e.getAncestry(),</span><span class="s1">this</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.getAncestry()};</span><span class="s1">if</span><span class="s0">(r.target.indexOf(</span><span class="s1">this</span><span class="s0">)&gt;=</span><span class="s2">0</span><span class="s0">)</span><span class="s1">return</span><span class="s3">&quot;after&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(r.</span><span class="s1">this</span><span class="s0">.indexOf(e)&gt;=</span><span class="s2">0</span><span class="s0">)</span><span class="s1">return</span><span class="s3">&quot;before&quot;</span><span class="s0">;let i;const s={target:</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">:</span><span class="s2">0</span><span class="s0">};</span><span class="s1">for</span><span class="s0">(;!i&amp;&amp;s.</span><span class="s1">this</span><span class="s0">&lt;r.</span><span class="s1">this</span><span class="s0">.length;){const e=r.</span><span class="s1">this</span><span class="s0">[s.</span><span class="s1">this</span><span class="s0">];s.target=r.target.indexOf(e),s.target&gt;=</span><span class="s2">0</span><span class="s0">?i=e:s.</span><span class="s1">this</span><span class="s0">++}</span><span class="s1">if</span><span class="s0">(!i)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Internal Babel error - The two compared nodes don't appear to belong to the same program.&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(p(r.</span><span class="s1">this</span><span class="s0">,s.</span><span class="s1">this</span><span class="s0">-</span><span class="s2">1</span><span class="s0">)||p(r.target,s.target-1))</span><span class="s1">return</span><span class="s3">&quot;unknown&quot;</span><span class="s0">;const a={</span><span class="s1">this</span><span class="s0">:r.</span><span class="s1">this</span><span class="s0">[s.</span><span class="s1">this</span><span class="s0">-</span><span class="s2">1</span><span class="s0">],target:r.target[s.target-1]};</span><span class="s1">if</span><span class="s0">(a.target.listKey&amp;&amp;a.</span><span class="s1">this</span><span class="s0">.listKey&amp;&amp;a.target.container===a.</span><span class="s1">this</span><span class="s0">.container)</span><span class="s1">return </span><span class="s0">a.target.key&gt;a.</span><span class="s1">this</span><span class="s0">.key?</span><span class="s3">&quot;before&quot;</span><span class="s0">:</span><span class="s3">&quot;after&quot;</span><span class="s0">;const l=n.VISITOR_KEYS[i.type],c=l.indexOf(a.</span><span class="s1">this</span><span class="s0">.parentKey);</span><span class="s1">return </span><span class="s0">l.indexOf(a.target.parentKey)&gt;c?</span><span class="s3">&quot;before&quot;</span><span class="s0">:</span><span class="s3">&quot;after&quot;</span><span class="s0">},t._guessExecutionStatusRelativeToDifferentFunctions=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(!e.isFunctionDeclaration()||e.parentPath.isExportDeclaration())</span><span class="s1">return</span><span class="s3">&quot;unknown&quot;</span><span class="s0">;const t=e.scope.getBinding(e.node.id.name);</span><span class="s1">if</span><span class="s0">(!t.references)</span><span class="s1">return</span><span class="s3">&quot;before&quot;</span><span class="s0">;const r=t.referencePaths;let n;</span><span class="s1">for</span><span class="s0">(const t of r){</span><span class="s1">if</span><span class="s0">(t.find((t=&gt;t.node===e.node)))</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;callee&quot;</span><span class="s0">!==t.key||!t.parentPath.isCallExpression())</span><span class="s1">return</span><span class="s3">&quot;unknown&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(c.has(t.node))</span><span class="s1">continue</span><span class="s0">;c.add(t.node);const r=</span><span class="s1">this</span><span class="s0">._guessExecutionStatusRelativeTo(t);</span><span class="s1">if</span><span class="s0">(c.</span><span class="s1">delete</span><span class="s0">(t.node),n&amp;&amp;n!==r)</span><span class="s1">return</span><span class="s3">&quot;unknown&quot;</span><span class="s0">;n=r}</span><span class="s1">return </span><span class="s0">n},t.resolve=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return this</span><span class="s0">._resolve(e,t)||</span><span class="s1">this</span><span class="s0">},t._resolve=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!(t&amp;&amp;t.indexOf(</span><span class="s1">this</span><span class="s0">)&gt;=</span><span class="s2">0</span><span class="s0">))</span><span class="s1">if</span><span class="s0">((t=t||[]).push(</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.isVariableDeclarator()){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;id&quot;</span><span class="s0">).isIdentifier())</span><span class="s1">return this</span><span class="s0">.get(</span><span class="s3">&quot;init&quot;</span><span class="s0">).resolve(e,t)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isReferencedIdentifier()){const r=</span><span class="s1">this</span><span class="s0">.scope.getBinding(</span><span class="s1">this</span><span class="s0">.node.name);</span><span class="s1">if</span><span class="s0">(!r)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!r.constant)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;module&quot;</span><span class="s0">===r.kind)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(r.path!==</span><span class="s1">this</span><span class="s0">){const n=r.path.resolve(e,t);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.find((e=&gt;e.node===n.node)))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">return </span><span class="s0">n}}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isTypeCastExpression())</span><span class="s1">return this</span><span class="s0">.get(</span><span class="s3">&quot;expression&quot;</span><span class="s0">).resolve(e,t);</span><span class="s1">if</span><span class="s0">(e&amp;&amp;</span><span class="s1">this</span><span class="s0">.isMemberExpression()){const r=</span><span class="s1">this</span><span class="s0">.toComputedKey();</span><span class="s1">if</span><span class="s0">(!n.isLiteral(r))</span><span class="s1">return</span><span class="s0">;const i=r.value,s=</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;object&quot;</span><span class="s0">).resolve(e,t);</span><span class="s1">if</span><span class="s0">(s.isObjectExpression()){const r=s.get(</span><span class="s3">&quot;properties&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const n of r){</span><span class="s1">if</span><span class="s0">(!n.isProperty())</span><span class="s1">continue</span><span class="s0">;const r=n.get(</span><span class="s3">&quot;key&quot;</span><span class="s0">);let s=n.isnt(</span><span class="s3">&quot;computed&quot;</span><span class="s0">)&amp;&amp;r.isIdentifier({name:i});</span><span class="s1">if</span><span class="s0">(s=s||r.isLiteral({value:i}),s)</span><span class="s1">return </span><span class="s0">n.get(</span><span class="s3">&quot;value&quot;</span><span class="s0">).resolve(e,t)}}</span><span class="s1">else if</span><span class="s0">(s.isArrayExpression()&amp;&amp;!isNaN(+i)){const r=s.get(</span><span class="s3">&quot;elements&quot;</span><span class="s0">)[i];</span><span class="s1">if</span><span class="s0">(r)</span><span class="s1">return </span><span class="s0">r.resolve(e,t)}}}},t.isConstantExpression=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isIdentifier()){const e=</span><span class="s1">this</span><span class="s0">.scope.getBinding(</span><span class="s1">this</span><span class="s0">.node.name);</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;e.constant}</span><span class="s1">return this</span><span class="s0">.isLiteral()?!</span><span class="s1">this</span><span class="s0">.isRegExpLiteral()&amp;&amp;(!</span><span class="s1">this</span><span class="s0">.isTemplateLiteral()||</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;expressions&quot;</span><span class="s0">).every((e=&gt;e.isConstantExpression()))):</span><span class="s1">this</span><span class="s0">.isUnaryExpression()?</span><span class="s3">&quot;void&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;operator&quot;</span><span class="s0">).node&amp;&amp;</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;argument&quot;</span><span class="s0">).isConstantExpression():!!</span><span class="s1">this</span><span class="s0">.isBinaryExpression()&amp;&amp;(</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;left&quot;</span><span class="s0">).isConstantExpression()&amp;&amp;</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;right&quot;</span><span class="s0">).isConstantExpression())},t.isInStrictMode=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">!!(</span><span class="s1">this</span><span class="s0">.isProgram()?</span><span class="s1">this</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.parentPath).find((e=&gt;{</span><span class="s1">if</span><span class="s0">(e.isProgram({sourceType:</span><span class="s3">&quot;module&quot;</span><span class="s0">}))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e.isClass())</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!e.isProgram()&amp;&amp;!e.isFunction())</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e.isArrowFunctionExpression()&amp;&amp;!e.get(</span><span class="s3">&quot;body&quot;</span><span class="s0">).isBlockStatement())</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;let{node:t}=e;e.isFunction()&amp;&amp;(t=t.body);</span><span class="s1">for</span><span class="s0">(const e of t.directives)</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;use strict&quot;</span><span class="s0">===e.value.value)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}))},t.is=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=i();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">s </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,s)){</span><span class="s1">var </span><span class="s0">a=n?Object.getOwnPropertyDescriptor(e,s):</span><span class="s1">null</span><span class="s0">;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">1710</span><span class="s0">));</span><span class="s1">function </span><span class="s0">i(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">i=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}</span><span class="s1">function </span><span class="s0">s(e){const t=</span><span class="s1">this</span><span class="s0">.node&amp;&amp;</span><span class="s1">this</span><span class="s0">.node[e];</span><span class="s1">return </span><span class="s0">t&amp;&amp;Array.isArray(t)?!!t.length:!!t}const a=s;</span><span class="s1">function </span><span class="s0">o(e){</span><span class="s1">return</span><span class="s0">(e.scope.getFunctionParent()||e.scope.getProgramParent()).path}</span><span class="s1">function </span><span class="s0">l(e,t){</span><span class="s1">switch</span><span class="s0">(e){</span><span class="s1">case</span><span class="s3">&quot;LogicalExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;right&quot;</span><span class="s0">===t;</span><span class="s1">case</span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;IfStatement&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;consequent&quot;</span><span class="s0">===t||</span><span class="s3">&quot;alternate&quot;</span><span class="s0">===t;</span><span class="s1">case</span><span class="s3">&quot;WhileStatement&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ForInStatement&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;body&quot;</span><span class="s0">===t;</span><span class="s1">case</span><span class="s3">&quot;ForStatement&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;body&quot;</span><span class="s0">===t||</span><span class="s3">&quot;update&quot;</span><span class="s0">===t;</span><span class="s1">case</span><span class="s3">&quot;SwitchStatement&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;cases&quot;</span><span class="s0">===t;</span><span class="s1">case</span><span class="s3">&quot;TryStatement&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;handler&quot;</span><span class="s0">===t;</span><span class="s1">case</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;property&quot;</span><span class="s0">===t;</span><span class="s1">case</span><span class="s3">&quot;OptionalCallExpression&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s3">&quot;arguments&quot;</span><span class="s0">===t;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}}</span><span class="s1">function </span><span class="s0">p(e,t){</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s2">0</span><span class="s0">;r&lt;t;r++){const t=e[r];</span><span class="s1">if</span><span class="s0">(l(t.parent.type,t.parentKey))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}t.is=a;const c=</span><span class="s1">new </span><span class="s0">WeakSet},</span><span class="s2">6019</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=i();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">s </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,s)){</span><span class="s1">var </span><span class="s0">a=n?Object.getOwnPropertyDescriptor(e,s):</span><span class="s1">null</span><span class="s0">;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">1710</span><span class="s0">));</span><span class="s1">function </span><span class="s0">i(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">i=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}const s={ReferencedIdentifier(e,t){</span><span class="s1">if</span><span class="s0">(e.isJSXIdentifier()&amp;&amp;n.react.isCompatTag(e.node.name)&amp;&amp;!e.parentPath.isJSXMemberExpression())</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;this&quot;</span><span class="s0">===e.node.name){let r=e.scope;</span><span class="s1">do</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(r.path.isFunction()&amp;&amp;!r.path.isArrowFunctionExpression())</span><span class="s1">break</span><span class="s0">}</span><span class="s1">while</span><span class="s0">(r=r.parent);r&amp;&amp;t.breakOnScopePaths.push(r.path)}const r=e.scope.getBinding(e.node.name);</span><span class="s1">if</span><span class="s0">(r){</span><span class="s1">for</span><span class="s0">(const n of r.constantViolations)</span><span class="s1">if</span><span class="s0">(n.scope!==r.path.scope)</span><span class="s1">return </span><span class="s0">t.mutableBinding=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">void </span><span class="s0">e.stop();r===t.scope.getBinding(e.node.name)&amp;&amp;(t.bindings[e.node.name]=r)}}};t.</span><span class="s1">default</span><span class="s0">=class{constructor(e,t){</span><span class="s1">this</span><span class="s0">.breakOnScopePaths=[],</span><span class="s1">this</span><span class="s0">.bindings={},</span><span class="s1">this</span><span class="s0">.mutableBinding=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.scopes=[],</span><span class="s1">this</span><span class="s0">.scope=t,</span><span class="s1">this</span><span class="s0">.path=e,</span><span class="s1">this</span><span class="s0">.attachAfter=!</span><span class="s2">1</span><span class="s0">}isCompatibleScope(e){</span><span class="s1">for</span><span class="s0">(const t of Object.keys(</span><span class="s1">this</span><span class="s0">.bindings)){const r=</span><span class="s1">this</span><span class="s0">.bindings[t];</span><span class="s1">if</span><span class="s0">(!e.bindingIdentifierEquals(t,r.identifier))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}getCompatibleScopes(){let e=</span><span class="s1">this</span><span class="s0">.path.scope;</span><span class="s1">do</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isCompatibleScope(e))</span><span class="s1">break</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.scopes.push(e),</span><span class="s1">this</span><span class="s0">.breakOnScopePaths.indexOf(e.path)&gt;=</span><span class="s2">0</span><span class="s0">)</span><span class="s1">break</span><span class="s0">}</span><span class="s1">while</span><span class="s0">(e=e.parent)}getAttachmentPath(){let e=</span><span class="s1">this</span><span class="s0">._getAttachmentPath();</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">;let t=e.scope;</span><span class="s1">if</span><span class="s0">(t.path===e&amp;&amp;(t=e.scope.parent),t.path.isProgram()||t.path.isFunction())</span><span class="s1">for</span><span class="s0">(const r of Object.keys(</span><span class="s1">this</span><span class="s0">.bindings)){</span><span class="s1">if</span><span class="s0">(!t.hasOwnBinding(r))</span><span class="s1">continue</span><span class="s0">;const n=</span><span class="s1">this</span><span class="s0">.bindings[r];</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;param&quot;</span><span class="s0">!==n.kind&amp;&amp;</span><span class="s3">&quot;params&quot;</span><span class="s0">!==n.path.parentKey&amp;&amp;</span><span class="s1">this</span><span class="s0">.getAttachmentParentForPath(n.path).key&gt;=e.key){</span><span class="s1">this</span><span class="s0">.attachAfter=!</span><span class="s2">0</span><span class="s0">,e=n.path;</span><span class="s1">for</span><span class="s0">(const t of n.constantViolations)</span><span class="s1">this</span><span class="s0">.getAttachmentParentForPath(t).key&gt;e.key&amp;&amp;(e=t)}}</span><span class="s1">return </span><span class="s0">e}_getAttachmentPath(){const e=</span><span class="s1">this</span><span class="s0">.scopes.pop();</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">if</span><span class="s0">(e.path.isFunction()){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.hasOwnParamBindings(e))</span><span class="s1">return this</span><span class="s0">.getNextScopeAttachmentParent();{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.scope===e)</span><span class="s1">return</span><span class="s0">;const t=e.path.get(</span><span class="s3">&quot;body&quot;</span><span class="s0">).get(</span><span class="s3">&quot;body&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s2">0</span><span class="s0">;e&lt;t.length;e++)</span><span class="s1">if</span><span class="s0">(!t[e].node._blockHoist)</span><span class="s1">return </span><span class="s0">t[e]}}</span><span class="s1">else if</span><span class="s0">(e.path.isProgram())</span><span class="s1">return this</span><span class="s0">.getNextScopeAttachmentParent()}getNextScopeAttachmentParent(){const e=</span><span class="s1">this</span><span class="s0">.scopes.pop();</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">return this</span><span class="s0">.getAttachmentParentForPath(e.path)}getAttachmentParentForPath(e){</span><span class="s1">do</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!e.parentPath||Array.isArray(e.container)&amp;&amp;e.isStatement())</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">while</span><span class="s0">(e=e.parentPath)}hasOwnParamBindings(e){</span><span class="s1">for</span><span class="s0">(const t of Object.keys(</span><span class="s1">this</span><span class="s0">.bindings)){</span><span class="s1">if</span><span class="s0">(!e.hasOwnBinding(t))</span><span class="s1">continue</span><span class="s0">;const r=</span><span class="s1">this</span><span class="s0">.bindings[t];</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;param&quot;</span><span class="s0">===r.kind&amp;&amp;r.constant)</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}run(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.path.traverse(s,</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.mutableBinding)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.getCompatibleScopes();const e=</span><span class="s1">this</span><span class="s0">.getAttachmentPath();</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e.getFunctionParent()===</span><span class="s1">this</span><span class="s0">.path.getFunctionParent())</span><span class="s1">return</span><span class="s0">;let t=e.scope.generateUidIdentifier(</span><span class="s3">&quot;ref&quot;</span><span class="s0">);const r=n.variableDeclarator(t,</span><span class="s1">this</span><span class="s0">.path.node),i=</span><span class="s1">this</span><span class="s0">.attachAfter?</span><span class="s3">&quot;insertAfter&quot;</span><span class="s0">:</span><span class="s3">&quot;insertBefore&quot;</span><span class="s0">,[a]=e[i]([e.isVariableDeclarator()?r:n.variableDeclaration(</span><span class="s3">&quot;var&quot;</span><span class="s0">,[r])]),o=</span><span class="s1">this</span><span class="s0">.path.parentPath;</span><span class="s1">return </span><span class="s0">o.isJSXElement()&amp;&amp;</span><span class="s1">this</span><span class="s0">.path.container===o.node.children&amp;&amp;(t=n.JSXExpressionContainer(t)),</span><span class="s1">this</span><span class="s0">.path.replaceWith(n.cloneNode(t)),e.isVariableDeclarator()?a.get(</span><span class="s3">&quot;init&quot;</span><span class="s0">):a.get(</span><span class="s3">&quot;declarations.0.init&quot;</span><span class="s0">)}}},</span><span class="s2">8004</span><span class="s0">:(e,t)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.hooks=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,t.hooks=[</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;test&quot;</span><span class="s0">===e.key&amp;&amp;(t.isWhile()||t.isSwitchCase())||</span><span class="s3">&quot;declaration&quot;</span><span class="s0">===e.key&amp;&amp;t.isExportDeclaration()||</span><span class="s3">&quot;body&quot;</span><span class="s0">===e.key&amp;&amp;t.isLabeledStatement()||</span><span class="s3">&quot;declarations&quot;</span><span class="s0">===e.listKey&amp;&amp;t.isVariableDeclaration()&amp;&amp;</span><span class="s2">1</span><span class="s0">===t.node.declarations.length||</span><span class="s3">&quot;expression&quot;</span><span class="s0">===e.key&amp;&amp;t.isExpressionStatement())</span><span class="s1">return </span><span class="s0">t.remove(),!</span><span class="s2">0</span><span class="s0">},</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(t.isSequenceExpression()&amp;&amp;</span><span class="s2">1</span><span class="s0">===t.node.expressions.length)</span><span class="s1">return </span><span class="s0">t.replaceWith(t.node.expressions[</span><span class="s2">0</span><span class="s0">]),!</span><span class="s2">0</span><span class="s0">},</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(t.isBinary())</span><span class="s1">return</span><span class="s3">&quot;left&quot;</span><span class="s0">===e.key?t.replaceWith(t.node.right):t.replaceWith(t.node.left),!</span><span class="s2">0</span><span class="s0">},</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(t.isIfStatement()&amp;&amp;(</span><span class="s3">&quot;consequent&quot;</span><span class="s0">===e.key||</span><span class="s3">&quot;alternate&quot;</span><span class="s0">===e.key)||</span><span class="s3">&quot;body&quot;</span><span class="s0">===e.key&amp;&amp;(t.isLoop()||t.isArrowFunctionExpression()))</span><span class="s1">return </span><span class="s0">e.replaceWith({type:</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s0">,body:[]}),!</span><span class="s2">0</span><span class="s0">}]},</span><span class="s2">1025</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.ForAwaitStatement=t.NumericLiteralTypeAnnotation=t.ExistentialTypeParam=t.SpreadProperty=t.RestProperty=t.Flow=t.Pure=t.Generated=t.User=t.Var=t.BlockScoped=t.Referenced=t.Scope=t.Expression=t.Statement=t.BindingIdentifier=t.ReferencedMemberExpression=t.ReferencedIdentifier=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=i();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">s </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,s)){</span><span class="s1">var </span><span class="s0">a=n?Object.getOwnPropertyDescriptor(e,s):</span><span class="s1">null</span><span class="s0">;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">1710</span><span class="s0">));</span><span class="s1">function </span><span class="s0">i(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">i=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}const s={types:[</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">],checkPath(e,t){const{node:r,parent:i}=e;</span><span class="s1">if</span><span class="s0">(!n.isIdentifier(r,t)&amp;&amp;!n.isJSXMemberExpression(i,t)){</span><span class="s1">if</span><span class="s0">(!n.isJSXIdentifier(r,t))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(n.react.isCompatTag(r.name))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}</span><span class="s1">return </span><span class="s0">n.isReferenced(r,i,e.parentPath.parent)}};t.ReferencedIdentifier=s;const a={types:[</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">],checkPath:({node:e,parent:t})=&gt;n.isMemberExpression(e)&amp;&amp;n.isReferenced(e,t)};t.ReferencedMemberExpression=a;const o={types:[</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">],checkPath(e){const{node:t,parent:r}=e,i=e.parentPath.parent;</span><span class="s1">return </span><span class="s0">n.isIdentifier(t)&amp;&amp;n.isBinding(t,r,i)}};t.BindingIdentifier=o;const l={types:[</span><span class="s3">&quot;Statement&quot;</span><span class="s0">],checkPath({node:e,parent:t}){</span><span class="s1">if</span><span class="s0">(n.isStatement(e)){</span><span class="s1">if</span><span class="s0">(n.isVariableDeclaration(e)){</span><span class="s1">if</span><span class="s0">(n.isForXStatement(t,{left:e}))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(n.isForStatement(t,{init:e}))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}};t.Statement=l;const p={types:[</span><span class="s3">&quot;Expression&quot;</span><span class="s0">],checkPath:e=&gt;e.isIdentifier()?e.isReferencedIdentifier():n.isExpression(e.node)};t.Expression=p;const c={types:[</span><span class="s3">&quot;Scopable&quot;</span><span class="s0">,</span><span class="s3">&quot;Pattern&quot;</span><span class="s0">],checkPath:e=&gt;n.isScope(e.node,e.parent)};t.Scope=c;const u={checkPath:e=&gt;n.isReferenced(e.node,e.parent)};t.Referenced=u;const d={checkPath:e=&gt;n.isBlockScoped(e.node)};t.BlockScoped=d;const h={types:[</span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s0">],checkPath:e=&gt;n.isVar(e.node)};t.Var=h;t.User={checkPath:e=&gt;e.node&amp;&amp;!!e.node.loc};t.Generated={checkPath:e=&gt;!e.isUser()};t.Pure={checkPath:(e,t)=&gt;e.scope.isPure(e.node,t)};const f={types:[</span><span class="s3">&quot;Flow&quot;</span><span class="s0">,</span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;ExportDeclaration&quot;</span><span class="s0">,</span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s0">],checkPath:({node:e})=&gt;!(!n.isFlow(e)&amp;&amp;(n.isImportDeclaration(e)?</span><span class="s3">&quot;type&quot;</span><span class="s0">!==e.importKind&amp;&amp;</span><span class="s3">&quot;typeof&quot;</span><span class="s0">!==e.importKind:n.isExportDeclaration(e)?</span><span class="s3">&quot;type&quot;</span><span class="s0">!==e.exportKind:!n.isImportSpecifier(e)||</span><span class="s3">&quot;type&quot;</span><span class="s0">!==e.importKind&amp;&amp;</span><span class="s3">&quot;typeof&quot;</span><span class="s0">!==e.importKind))};t.Flow=f;t.RestProperty={types:[</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">],checkPath:e=&gt;e.parentPath&amp;&amp;e.parentPath.isObjectPattern()};t.SpreadProperty={types:[</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">],checkPath:e=&gt;e.parentPath&amp;&amp;e.parentPath.isObjectExpression()},t.ExistentialTypeParam={types:[</span><span class="s3">&quot;ExistsTypeAnnotation&quot;</span><span class="s0">]},t.NumericLiteralTypeAnnotation={types:[</span><span class="s3">&quot;NumberLiteralTypeAnnotation&quot;</span><span class="s0">]};t.ForAwaitStatement={types:[</span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s0">],checkPath:({node:e})=&gt;!</span><span class="s2">0</span><span class="s0">===e.await}},</span><span class="s2">9613</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.insertBefore=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">this</span><span class="s0">._assertUnremoved(),e=</span><span class="s1">this</span><span class="s0">._verifyNodeList(e);const{parentPath:t}=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(t.isExpressionStatement()||t.isLabeledStatement()||t.isExportNamedDeclaration()||t.isExportDefaultDeclaration()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isDeclaration())</span><span class="s1">return </span><span class="s0">t.insertBefore(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isNodeType(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isJSXElement()||t.isForStatement()&amp;&amp;</span><span class="s3">&quot;init&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.key)</span><span class="s1">return this</span><span class="s0">.node&amp;&amp;e.push(</span><span class="s1">this</span><span class="s0">.node),</span><span class="s1">this</span><span class="s0">.replaceExpressionWithStatements(e);</span><span class="s1">if</span><span class="s0">(Array.isArray(</span><span class="s1">this</span><span class="s0">.container))</span><span class="s1">return this</span><span class="s0">._containerInsertBefore(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isStatementOrBlock()){const t=</span><span class="s1">this</span><span class="s0">.node&amp;&amp;(!</span><span class="s1">this</span><span class="s0">.isExpressionStatement()||</span><span class="s1">null</span><span class="s0">!=</span><span class="s1">this</span><span class="s0">.node.expression);</span><span class="s1">return this</span><span class="s0">.replaceWith(a.blockStatement(t?[</span><span class="s1">this</span><span class="s0">.node]:[])),</span><span class="s1">this</span><span class="s0">.unshiftContainer(</span><span class="s3">&quot;body&quot;</span><span class="s0">,e)}</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;We don't know what to do with this node type. We were previously a Statement but we can't fit in here?&quot;</span><span class="s0">)},t._containerInsert=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">this</span><span class="s0">.updateSiblingKeys(e,t.length);const r=[];</span><span class="s1">this</span><span class="s0">.container.splice(e,</span><span class="s2">0</span><span class="s0">,...t);</span><span class="s1">for</span><span class="s0">(let n=</span><span class="s2">0</span><span class="s0">;n&lt;t.length;n++){const t=e+n,i=</span><span class="s1">this</span><span class="s0">.getSibling(t);r.push(i),</span><span class="s1">this</span><span class="s0">.context&amp;&amp;</span><span class="s1">this</span><span class="s0">.context.queue&amp;&amp;i.pushContext(</span><span class="s1">this</span><span class="s0">.context)}const n=</span><span class="s1">this</span><span class="s0">._getQueueContexts();</span><span class="s1">for</span><span class="s0">(const e of r){e.setScope(),e.debug(</span><span class="s3">&quot;Inserted.&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const t of n)t.maybeQueue(e,!</span><span class="s2">0</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">r},t._containerInsertBefore=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return this</span><span class="s0">._containerInsert(</span><span class="s1">this</span><span class="s0">.key,e)},t._containerInsertAfter=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return this</span><span class="s0">._containerInsert(</span><span class="s1">this</span><span class="s0">.key+</span><span class="s2">1</span><span class="s0">,e)},t.insertAfter=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">this</span><span class="s0">._assertUnremoved(),e=</span><span class="s1">this</span><span class="s0">._verifyNodeList(e);const{parentPath:t}=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(t.isExpressionStatement()||t.isLabeledStatement()||t.isExportNamedDeclaration()||t.isExportDefaultDeclaration()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isDeclaration())</span><span class="s1">return </span><span class="s0">t.insertAfter(e.map((e=&gt;a.isExpression(e)?a.expressionStatement(e):e)));</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isNodeType(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isJSXElement()&amp;&amp;!t.isJSXElement()||t.isForStatement()&amp;&amp;</span><span class="s3">&quot;init&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.key){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.node){let{scope:r}=</span><span class="s1">this</span><span class="s0">;t.isMethod({computed:!</span><span class="s2">0</span><span class="s0">,key:</span><span class="s1">this</span><span class="s0">.node})&amp;&amp;(r=r.parent);const n=r.generateDeclaredUidIdentifier();e.unshift(a.expressionStatement(a.assignmentExpression(</span><span class="s3">&quot;=&quot;</span><span class="s0">,a.cloneNode(n),</span><span class="s1">this</span><span class="s0">.node))),e.push(a.expressionStatement(a.cloneNode(n)))}</span><span class="s1">return this</span><span class="s0">.replaceExpressionWithStatements(e)}</span><span class="s1">if</span><span class="s0">(Array.isArray(</span><span class="s1">this</span><span class="s0">.container))</span><span class="s1">return this</span><span class="s0">._containerInsertAfter(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isStatementOrBlock()){const t=</span><span class="s1">this</span><span class="s0">.node&amp;&amp;(!</span><span class="s1">this</span><span class="s0">.isExpressionStatement()||</span><span class="s1">null</span><span class="s0">!=</span><span class="s1">this</span><span class="s0">.node.expression);</span><span class="s1">return this</span><span class="s0">.replaceWith(a.blockStatement(t?[</span><span class="s1">this</span><span class="s0">.node]:[])),</span><span class="s1">this</span><span class="s0">.pushContainer(</span><span class="s3">&quot;body&quot;</span><span class="s0">,e)}</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;We don't know what to do with this node type. We were previously a Statement but we can't fit in here?&quot;</span><span class="s0">)},t.updateSiblingKeys=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.parent)</span><span class="s1">return</span><span class="s0">;const r=n.path.get(</span><span class="s1">this</span><span class="s0">.parent);</span><span class="s1">for</span><span class="s0">(let n=</span><span class="s2">0</span><span class="s0">;n&lt;r.length;n++){const i=r[n];i.key&gt;=e&amp;&amp;(i.key+=t)}},t._verifyNodeList=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">[];e.constructor!==Array&amp;&amp;(e=[e]);</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s2">0</span><span class="s0">;t&lt;e.length;t++){const r=e[t];let n;</span><span class="s1">if</span><span class="s0">(r?</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">r?n=</span><span class="s3">&quot;contains a non-object node&quot;</span><span class="s0">:r.type?r </span><span class="s1">instanceof </span><span class="s0">s.</span><span class="s1">default</span><span class="s0">&amp;&amp;(n=</span><span class="s3">&quot;has a NodePath when it expected a raw object&quot;</span><span class="s0">):n=</span><span class="s3">&quot;without a type&quot;</span><span class="s0">:n=</span><span class="s3">&quot;has falsy node&quot;</span><span class="s0">,n){const e=Array.isArray(r)?</span><span class="s3">&quot;array&quot;</span><span class="s0">:</span><span class="s1">typeof </span><span class="s0">r;</span><span class="s1">throw new </span><span class="s0">Error(`Node list ${n} </span><span class="s1">with </span><span class="s0">the index of ${t} and type of ${e}`)}}</span><span class="s1">return </span><span class="s0">e},t.unshiftContainer=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return this</span><span class="s0">._assertUnremoved(),t=</span><span class="s1">this</span><span class="s0">._verifyNodeList(t),s.</span><span class="s1">default</span><span class="s0">.get({parentPath:</span><span class="s1">this</span><span class="s0">,parent:</span><span class="s1">this</span><span class="s0">.node,container:</span><span class="s1">this</span><span class="s0">.node[e],listKey:e,key:</span><span class="s2">0</span><span class="s0">})._containerInsertBefore(t)},t.pushContainer=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">this</span><span class="s0">._assertUnremoved(),t=</span><span class="s1">this</span><span class="s0">._verifyNodeList(t);const r=</span><span class="s1">this</span><span class="s0">.node[e];</span><span class="s1">return </span><span class="s0">s.</span><span class="s1">default</span><span class="s0">.get({parentPath:</span><span class="s1">this</span><span class="s0">,parent:</span><span class="s1">this</span><span class="s0">.node,container:r,listKey:e,key:r.length}).replaceWithMultiple(t)},t.hoist=</span><span class="s1">function</span><span class="s0">(e=</span><span class="s1">this</span><span class="s0">.scope){</span><span class="s1">return new </span><span class="s0">i.</span><span class="s1">default</span><span class="s0">(</span><span class="s1">this</span><span class="s0">,e).run()};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">1826</span><span class="s0">),i=l(r(</span><span class="s2">6019</span><span class="s0">)),s=l(r(</span><span class="s2">706</span><span class="s0">)),a=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=o();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,i)){</span><span class="s1">var </span><span class="s0">s=n?Object.getOwnPropertyDescriptor(e,i):</span><span class="s1">null</span><span class="s0">;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">1710</span><span class="s0">));</span><span class="s1">function </span><span class="s0">o(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">o=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}</span><span class="s1">function </span><span class="s0">l(e){</span><span class="s1">return </span><span class="s0">e&amp;&amp;e.__esModule?e:{</span><span class="s1">default</span><span class="s0">:e}}},</span><span class="s2">6788</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.remove=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">var </span><span class="s0">e;</span><span class="s1">this</span><span class="s0">._assertUnremoved(),</span><span class="s1">this</span><span class="s0">.resync(),(</span><span class="s1">null</span><span class="s0">==(e=</span><span class="s1">this</span><span class="s0">.opts)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:e.noScope)||</span><span class="s1">this</span><span class="s0">._removeFromScope(),</span><span class="s1">this</span><span class="s0">._callRemovalHooks()||(</span><span class="s1">this</span><span class="s0">.shareCommentsWithSiblings(),</span><span class="s1">this</span><span class="s0">._remove()),</span><span class="s1">this</span><span class="s0">._markRemoved()},t._removeFromScope=</span><span class="s1">function</span><span class="s0">(){const e=</span><span class="s1">this</span><span class="s0">.getBindingIdentifiers();Object.keys(e).forEach((e=&gt;</span><span class="s1">this</span><span class="s0">.scope.removeBinding(e)))},t._callRemovalHooks=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">for</span><span class="s0">(const e of n.hooks)</span><span class="s1">if</span><span class="s0">(e(</span><span class="s1">this</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parentPath))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">},t._remove=</span><span class="s1">function</span><span class="s0">(){Array.isArray(</span><span class="s1">this</span><span class="s0">.container)?(</span><span class="s1">this</span><span class="s0">.container.splice(</span><span class="s1">this</span><span class="s0">.key,</span><span class="s2">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.updateSiblingKeys(</span><span class="s1">this</span><span class="s0">.key,-</span><span class="s2">1</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">._replaceWith(</span><span class="s1">null</span><span class="s0">)},t._markRemoved=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">this</span><span class="s0">._traverseFlags|=i.SHOULD_SKIP|i.REMOVED,</span><span class="s1">this</span><span class="s0">.node=</span><span class="s1">null</span><span class="s0">},t._assertUnremoved=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.removed)</span><span class="s1">throw this</span><span class="s0">.buildCodeFrameError(</span><span class="s3">&quot;NodePath has been removed so is read-only.&quot;</span><span class="s0">)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">8004</span><span class="s0">),i=r(</span><span class="s2">706</span><span class="s0">)},</span><span class="s2">4638</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.replaceWithMultiple=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">this</span><span class="s0">.resync(),e=</span><span class="s1">this</span><span class="s0">._verifyNodeList(e),o.inheritLeadingComments(e[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">this</span><span class="s0">.node),o.inheritTrailingComments(e[e.length-1],</span><span class="s1">this</span><span class="s0">.node),</span><span class="s1">this</span><span class="s0">.node=</span><span class="s1">this</span><span class="s0">.container[</span><span class="s1">this</span><span class="s0">.key]=</span><span class="s1">null</span><span class="s0">;const t=</span><span class="s1">this</span><span class="s0">.insertAfter(e);</span><span class="s1">return this</span><span class="s0">.node?</span><span class="s1">this</span><span class="s0">.requeue():</span><span class="s1">this</span><span class="s0">.remove(),t},t.replaceWithSourceString=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">this</span><span class="s0">.resync();</span><span class="s1">try</span><span class="s0">{e=`(${e})`,e=(</span><span class="s2">0</span><span class="s0">,a.parse)(e)}</span><span class="s1">catch</span><span class="s0">(t){const r=t.loc;</span><span class="s1">throw </span><span class="s0">r&amp;&amp;(t.message+=</span><span class="s3">&quot; - make sure this is an expression.</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s0">+(</span><span class="s2">0</span><span class="s0">,n.codeFrameColumns)(e,{start:{line:r.line,column:r.column+</span><span class="s2">1</span><span class="s0">}}),t.code=</span><span class="s3">&quot;BABEL_REPLACE_SOURCE_ERROR&quot;</span><span class="s0">),t}</span><span class="s1">return </span><span class="s0">e=e.program.body[</span><span class="s2">0</span><span class="s0">].expression,i.</span><span class="s1">default</span><span class="s0">.removeProperties(e),</span><span class="s1">this</span><span class="s0">.replaceWith(e)},t.replaceWith=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.resync(),</span><span class="s1">this</span><span class="s0">.removed)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;You can't replace this node, we've already removed it&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(e </span><span class="s1">instanceof </span><span class="s0">s.</span><span class="s1">default</span><span class="s0">&amp;&amp;(e=e.node),!e)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;You passed `path.replaceWith()` a falsy node, use `path.remove()` instead&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.node===e)</span><span class="s1">return</span><span class="s0">[</span><span class="s1">this</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isProgram()&amp;&amp;!o.isProgram(e))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;You can only replace a Program root node with another Program node&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(Array.isArray(e))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`&quot;</span><span class="s0">);let t=</span><span class="s3">&quot;&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isNodeType(</span><span class="s3">&quot;Statement&quot;</span><span class="s0">)&amp;&amp;o.isExpression(e)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.canHaveVariableDeclarationOrExpression()||</span><span class="s1">this</span><span class="s0">.canSwapBetweenExpressionAndStatement(e)||</span><span class="s1">this</span><span class="s0">.parentPath.isExportDefaultDeclaration()||(e=o.expressionStatement(e),t=</span><span class="s3">&quot;expression&quot;</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.isNodeType(</span><span class="s3">&quot;Expression&quot;</span><span class="s0">)&amp;&amp;o.isStatement(e)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canHaveVariableDeclarationOrExpression()&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canSwapBetweenExpressionAndStatement(e))</span><span class="s1">return this</span><span class="s0">.replaceExpressionWithStatements([e]);const r=</span><span class="s1">this</span><span class="s0">.node;</span><span class="s1">return </span><span class="s0">r&amp;&amp;(o.inheritsComments(e,r),o.removeComments(r)),</span><span class="s1">this</span><span class="s0">._replaceWith(e),</span><span class="s1">this</span><span class="s0">.type=e.type,</span><span class="s1">this</span><span class="s0">.setScope(),</span><span class="s1">this</span><span class="s0">.requeue(),[t?</span><span class="s1">this</span><span class="s0">.get(t):</span><span class="s1">this</span><span class="s0">]},t._replaceWith=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.container)</span><span class="s1">throw new </span><span class="s0">ReferenceError(</span><span class="s3">&quot;Container is falsy&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.inList?o.validate(</span><span class="s1">this</span><span class="s0">.parent,</span><span class="s1">this</span><span class="s0">.key,[e]):o.validate(</span><span class="s1">this</span><span class="s0">.parent,</span><span class="s1">this</span><span class="s0">.key,e),</span><span class="s1">this</span><span class="s0">.debug(`Replace </span><span class="s1">with </span><span class="s0">${</span><span class="s1">null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:e.type}`),</span><span class="s1">this</span><span class="s0">.node=</span><span class="s1">this</span><span class="s0">.container[</span><span class="s1">this</span><span class="s0">.key]=e},t.replaceExpressionWithStatements=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">this</span><span class="s0">.resync();const t=o.toSequenceExpression(e,</span><span class="s1">this</span><span class="s0">.scope);</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return this</span><span class="s0">.replaceWith(t)[</span><span class="s2">0</span><span class="s0">].get(</span><span class="s3">&quot;expressions&quot;</span><span class="s0">);const r=</span><span class="s1">this</span><span class="s0">.getFunctionParent(),n=</span><span class="s1">null</span><span class="s0">==r?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.is(</span><span class="s3">&quot;async&quot;</span><span class="s0">),s=o.arrowFunctionExpression([],o.blockStatement(e));</span><span class="s1">this</span><span class="s0">.replaceWith(o.callExpression(s,[])),</span><span class="s1">this</span><span class="s0">.traverse(c);const a=</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;callee&quot;</span><span class="s0">).getCompletionRecords();</span><span class="s1">for</span><span class="s0">(const e of a){</span><span class="s1">if</span><span class="s0">(!e.isExpressionStatement())</span><span class="s1">continue</span><span class="s0">;const t=e.findParent((e=&gt;e.isLoop()));</span><span class="s1">if</span><span class="s0">(t){let r=t.getData(</span><span class="s3">&quot;expressionReplacementReturnUid&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(r)r=o.identifier(r.name);</span><span class="s1">else</span><span class="s0">{const e=</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;callee&quot;</span><span class="s0">);r=e.scope.generateDeclaredUidIdentifier(</span><span class="s3">&quot;ret&quot;</span><span class="s0">),e.get(</span><span class="s3">&quot;body&quot;</span><span class="s0">).pushContainer(</span><span class="s3">&quot;body&quot;</span><span class="s0">,o.returnStatement(o.cloneNode(r))),t.setData(</span><span class="s3">&quot;expressionReplacementReturnUid&quot;</span><span class="s0">,r)}e.get(</span><span class="s3">&quot;expression&quot;</span><span class="s0">).replaceWith(o.assignmentExpression(</span><span class="s3">&quot;=&quot;</span><span class="s0">,o.cloneNode(r),e.node.expression))}</span><span class="s1">else </span><span class="s0">e.replaceWith(o.returnStatement(e.node.expression))}const l=</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;callee&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">l.arrowFunctionToExpression(),n&amp;&amp;i.</span><span class="s1">default</span><span class="s0">.hasType(</span><span class="s1">this</span><span class="s0">.get(</span><span class="s3">&quot;callee.body&quot;</span><span class="s0">).node,</span><span class="s3">&quot;AwaitExpression&quot;</span><span class="s0">,o.FUNCTION_TYPES)&amp;&amp;(l.set(</span><span class="s3">&quot;async&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.replaceWith(o.awaitExpression(</span><span class="s1">this</span><span class="s0">.node))),l.get(</span><span class="s3">&quot;body.body&quot;</span><span class="s0">)},t.replaceInline=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.resync(),Array.isArray(e)){</span><span class="s1">if</span><span class="s0">(Array.isArray(</span><span class="s1">this</span><span class="s0">.container)){e=</span><span class="s1">this</span><span class="s0">._verifyNodeList(e);const t=</span><span class="s1">this</span><span class="s0">._containerInsertAfter(e);</span><span class="s1">return this</span><span class="s0">.remove(),t}</span><span class="s1">return this</span><span class="s0">.replaceWithMultiple(e)}</span><span class="s1">return this</span><span class="s0">.replaceWith(e)};</span><span class="s1">var </span><span class="s0">n=r(</span><span class="s2">785</span><span class="s0">),i=p(r(</span><span class="s2">1910</span><span class="s0">)),s=p(r(</span><span class="s2">706</span><span class="s0">)),a=r(</span><span class="s2">7493</span><span class="s0">),o=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=l();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,i)){</span><span class="s1">var </span><span class="s0">s=n?Object.getOwnPropertyDescriptor(e,i):</span><span class="s1">null</span><span class="s0">;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">1710</span><span class="s0">));</span><span class="s1">function </span><span class="s0">l(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">l=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}</span><span class="s1">function </span><span class="s0">p(e){</span><span class="s1">return </span><span class="s0">e&amp;&amp;e.__esModule?e:{</span><span class="s1">default</span><span class="s0">:e}}const c={Function(e){e.skip()},VariableDeclaration(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;var&quot;</span><span class="s0">!==e.node.kind)</span><span class="s1">return</span><span class="s0">;const t=e.getBindingIdentifiers();</span><span class="s1">for</span><span class="s0">(const r of Object.keys(t))e.scope.push({id:t[r]});const r=[];</span><span class="s1">for</span><span class="s0">(const t of e.node.declarations)t.init&amp;&amp;r.push(o.expressionStatement(o.assignmentExpression(</span><span class="s3">&quot;=&quot;</span><span class="s0">,t.id,t.init)));e.replaceWithMultiple(r)}}},</span><span class="s2">2329</span><span class="s0">:(e,t)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,t.</span><span class="s1">default</span><span class="s0">=class{constructor({identifier:e,scope:t,path:r,kind:n}){</span><span class="s1">this</span><span class="s0">.constantViolations=[],</span><span class="s1">this</span><span class="s0">.constant=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.referencePaths=[],</span><span class="s1">this</span><span class="s0">.referenced=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.references=</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.identifier=e,</span><span class="s1">this</span><span class="s0">.scope=t,</span><span class="s1">this</span><span class="s0">.path=r,</span><span class="s1">this</span><span class="s0">.kind=n,</span><span class="s1">this</span><span class="s0">.clearValue()}deoptValue(){</span><span class="s1">this</span><span class="s0">.clearValue(),</span><span class="s1">this</span><span class="s0">.hasDeoptedValue=!</span><span class="s2">0</span><span class="s0">}setValue(e){</span><span class="s1">this</span><span class="s0">.hasDeoptedValue||(</span><span class="s1">this</span><span class="s0">.hasValue=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.value=e)}clearValue(){</span><span class="s1">this</span><span class="s0">.hasDeoptedValue=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.hasValue=!</span><span class="s2">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.value=</span><span class="s1">null</span><span class="s0">}reassign(e){</span><span class="s1">this</span><span class="s0">.constant=!</span><span class="s2">1</span><span class="s0">,-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.constantViolations.indexOf(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.constantViolations.push(e)}reference(e){-</span><span class="s2">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.referencePaths.indexOf(e)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.referenced=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.references++,</span><span class="s1">this</span><span class="s0">.referencePaths.push(e))}dereference(){</span><span class="s1">this</span><span class="s0">.references--,</span><span class="s1">this</span><span class="s0">.referenced=!!</span><span class="s1">this</span><span class="s0">.references}}},</span><span class="s2">4639</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">n=c(r(</span><span class="s2">1360</span><span class="s0">)),i=c(r(</span><span class="s2">1910</span><span class="s0">)),s=c(r(</span><span class="s2">2329</span><span class="s0">)),a=c(r(</span><span class="s2">2261</span><span class="s0">)),o=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=p();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,i)){</span><span class="s1">var </span><span class="s0">s=n?Object.getOwnPropertyDescriptor(e,i):</span><span class="s1">null</span><span class="s0">;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}(r(</span><span class="s2">1710</span><span class="s0">)),l=r(</span><span class="s2">1826</span><span class="s0">);</span><span class="s1">function </span><span class="s0">p(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">p=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}</span><span class="s1">function </span><span class="s0">c(e){</span><span class="s1">return </span><span class="s0">e&amp;&amp;e.__esModule?e:{</span><span class="s1">default</span><span class="s0">:e}}</span><span class="s1">function </span><span class="s0">u(e,t){</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:e.type){</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(o.isModuleDeclaration(e))</span><span class="s1">if</span><span class="s0">(e.source)u(e.source,t);</span><span class="s1">else if</span><span class="s0">(e.specifiers&amp;&amp;e.specifiers.length)</span><span class="s1">for</span><span class="s0">(const r of e.specifiers)u(r,t);</span><span class="s1">else </span><span class="s0">e.declaration&amp;&amp;u(e.declaration,t);</span><span class="s1">else </span><span class="s0">o.isModuleSpecifier(e)?u(e.local,t):o.isLiteral(e)&amp;&amp;t.push(e.value);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;MemberExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;OptionalMemberExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s0">:u(e.object,t),u(e.property,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;Identifier&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;JSXOpeningElement&quot;</span><span class="s0">:t.push(e.name);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;CallExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;OptionalCallExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;NewExpression&quot;</span><span class="s0">:u(e.callee,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s0">:</span><span class="s1">for</span><span class="s0">(const r of e.properties)u(r,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;SpreadElement&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;RestElement&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;UnaryExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;UpdateExpression&quot;</span><span class="s0">:u(e.argument,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ObjectProperty&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ObjectMethod&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ClassProperty&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ClassMethod&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ClassPrivateProperty&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ClassPrivateMethod&quot;</span><span class="s0">:u(e.key,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ThisExpression&quot;</span><span class="s0">:t.push(</span><span class="s3">&quot;this&quot;</span><span class="s0">);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;Super&quot;</span><span class="s0">:t.push(</span><span class="s3">&quot;super&quot;</span><span class="s0">);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;Import&quot;</span><span class="s0">:t.push(</span><span class="s3">&quot;import&quot;</span><span class="s0">);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;DoExpression&quot;</span><span class="s0">:t.push(</span><span class="s3">&quot;do&quot;</span><span class="s0">);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;YieldExpression&quot;</span><span class="s0">:t.push(</span><span class="s3">&quot;yield&quot;</span><span class="s0">),u(e.argument,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;AwaitExpression&quot;</span><span class="s0">:t.push(</span><span class="s3">&quot;await&quot;</span><span class="s0">),u(e.argument,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s0">:u(e.left,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ClassExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s3">&quot;PrivateName&quot;</span><span class="s0">:u(e.id,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s0">:u(e.expression,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;MetaProperty&quot;</span><span class="s0">:u(e.meta,t),u(e.property,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;JSXElement&quot;</span><span class="s0">:u(e.openingElement,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;JSXFragment&quot;</span><span class="s0">:u(e.openingFragment,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;JSXOpeningFragment&quot;</span><span class="s0">:t.push(</span><span class="s3">&quot;Fragment&quot;</span><span class="s0">);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s0">:u(e.namespace,t),u(e.name,t)}}const d={For(e){</span><span class="s1">for</span><span class="s0">(const t of o.FOR_INIT_KEYS){const r=e.get(t);r.isVar()&amp;&amp;(e.scope.getFunctionParent()||e.scope.getProgramParent()).registerBinding(</span><span class="s3">&quot;var&quot;</span><span class="s0">,r)}},Declaration(e){e.isBlockScoped()||e.isExportDeclaration()&amp;&amp;e.get(</span><span class="s3">&quot;declaration&quot;</span><span class="s0">).isDeclaration()||(e.scope.getFunctionParent()||e.scope.getProgramParent()).registerDeclaration(e)},ReferencedIdentifier(e,t){t.references.push(e)},ForXStatement(e,t){const r=e.get(</span><span class="s3">&quot;left&quot;</span><span class="s0">);(r.isPattern()||r.isIdentifier())&amp;&amp;t.constantViolations.push(e)},ExportDeclaration:{exit(e){const{node:t,scope:r}=e,n=t.declaration;</span><span class="s1">if</span><span class="s0">(o.isClassDeclaration(n)||o.isFunctionDeclaration(n)){const t=n.id;</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return</span><span class="s0">;const i=r.getBinding(t.name);i&amp;&amp;i.reference(e)}</span><span class="s1">else if</span><span class="s0">(o.isVariableDeclaration(n))</span><span class="s1">for</span><span class="s0">(const t of n.declarations)</span><span class="s1">for</span><span class="s0">(const n of Object.keys(o.getBindingIdentifiers(t))){const t=r.getBinding(n);t&amp;&amp;t.reference(e)}}},LabeledStatement(e){e.scope.getProgramParent().addGlobal(e.node),e.scope.getBlockParent().registerDeclaration(e)},AssignmentExpression(e,t){t.assignments.push(e)},UpdateExpression(e,t){t.constantViolations.push(e)},UnaryExpression(e,t){</span><span class="s3">&quot;delete&quot;</span><span class="s0">===e.node.operator&amp;&amp;t.constantViolations.push(e)},BlockScoped(e){let t=e.scope;</span><span class="s1">if</span><span class="s0">(t.path===e&amp;&amp;(t=t.parent),t.getBlockParent().registerDeclaration(e),e.isClassDeclaration()&amp;&amp;e.node.id){const t=e.node.id.name;e.scope.bindings[t]=e.scope.parent.getBinding(t)}},Block(e){const t=e.get(</span><span class="s3">&quot;body&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const r of t)r.isFunctionDeclaration()&amp;&amp;e.scope.getBlockParent().registerDeclaration(r)},CatchClause(e){e.scope.registerBinding(</span><span class="s3">&quot;let&quot;</span><span class="s0">,e)},Function(e){e.isFunctionExpression()&amp;&amp;e.has(</span><span class="s3">&quot;id&quot;</span><span class="s0">)&amp;&amp;!e.get(</span><span class="s3">&quot;id&quot;</span><span class="s0">).node[o.NOT_LOCAL_BINDING]&amp;&amp;e.scope.registerBinding(</span><span class="s3">&quot;local&quot;</span><span class="s0">,e.get(</span><span class="s3">&quot;id&quot;</span><span class="s0">),e);const t=e.get(</span><span class="s3">&quot;params&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const r of t)e.scope.registerBinding(</span><span class="s3">&quot;param&quot;</span><span class="s0">,r)},ClassExpression(e){e.has(</span><span class="s3">&quot;id&quot;</span><span class="s0">)&amp;&amp;!e.get(</span><span class="s3">&quot;id&quot;</span><span class="s0">).node[o.NOT_LOCAL_BINDING]&amp;&amp;e.scope.registerBinding(</span><span class="s3">&quot;local&quot;</span><span class="s0">,e)}};let h=</span><span class="s2">0</span><span class="s0">;class f{constructor(e){const{node:t}=e,r=l.scope.get(t);</span><span class="s1">if</span><span class="s0">((</span><span class="s1">null</span><span class="s0">==r?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.path)===e)</span><span class="s1">return </span><span class="s0">r;l.scope.set(t,</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.uid=h++,</span><span class="s1">this</span><span class="s0">.block=t,</span><span class="s1">this</span><span class="s0">.path=e,</span><span class="s1">this</span><span class="s0">.labels=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.inited=!</span><span class="s2">1</span><span class="s0">}get parent(){const e=</span><span class="s1">this</span><span class="s0">.path.findParent((e=&gt;e.isScope()));</span><span class="s1">return null</span><span class="s0">==e?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:e.scope}get parentBlock(){</span><span class="s1">return this</span><span class="s0">.path.parent}get hub(){</span><span class="s1">return this</span><span class="s0">.path.hub}traverse(e,t,r){(</span><span class="s2">0</span><span class="s0">,i.</span><span class="s1">default</span><span class="s0">)(e,t,</span><span class="s1">this</span><span class="s0">,r,</span><span class="s1">this</span><span class="s0">.path)}generateDeclaredUidIdentifier(e){const t=</span><span class="s1">this</span><span class="s0">.generateUidIdentifier(e);</span><span class="s1">return this</span><span class="s0">.push({id:t}),o.cloneNode(t)}generateUidIdentifier(e){</span><span class="s1">return </span><span class="s0">o.identifier(</span><span class="s1">this</span><span class="s0">.generateUid(e))}generateUid(e=</span><span class="s3">&quot;temp&quot;</span><span class="s0">){let t;e=o.toIdentifier(e).replace(/^_+/,</span><span class="s3">&quot;&quot;</span><span class="s0">).replace(/[</span><span class="s2">0</span><span class="s0">-</span><span class="s2">9</span><span class="s0">]+$/g,</span><span class="s3">&quot;&quot;</span><span class="s0">);let r=</span><span class="s2">1</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{t=</span><span class="s1">this</span><span class="s0">._generateUid(e,r),r++}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasLabel(t)||</span><span class="s1">this</span><span class="s0">.hasBinding(t)||</span><span class="s1">this</span><span class="s0">.hasGlobal(t)||</span><span class="s1">this</span><span class="s0">.hasReference(t));const n=</span><span class="s1">this</span><span class="s0">.getProgramParent();</span><span class="s1">return </span><span class="s0">n.references[t]=!</span><span class="s2">0</span><span class="s0">,n.uids[t]=!</span><span class="s2">0</span><span class="s0">,t}_generateUid(e,t){let r=e;</span><span class="s1">return </span><span class="s0">t&gt;</span><span class="s2">1</span><span class="s0">&amp;&amp;(r+=t),`_${r}`}generateUidBasedOnNode(e,t){const r=[];u(e,r);let n=r.join(</span><span class="s3">&quot;$&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">n=n.replace(/^_/,</span><span class="s3">&quot;&quot;</span><span class="s0">)||t||</span><span class="s3">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.generateUid(n.slice(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">20</span><span class="s0">))}generateUidIdentifierBasedOnNode(e,t){</span><span class="s1">return </span><span class="s0">o.identifier(</span><span class="s1">this</span><span class="s0">.generateUidBasedOnNode(e,t))}isStatic(e){</span><span class="s1">if</span><span class="s0">(o.isThisExpression(e)||o.isSuper(e))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(o.isIdentifier(e)){const t=</span><span class="s1">this</span><span class="s0">.getBinding(e.name);</span><span class="s1">return </span><span class="s0">t?t.constant:</span><span class="s1">this</span><span class="s0">.hasBinding(e.name)}</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}maybeGenerateMemoised(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isStatic(e))</span><span class="s1">return null</span><span class="s0">;{const r=</span><span class="s1">this</span><span class="s0">.generateUidIdentifierBasedOnNode(e);</span><span class="s1">return </span><span class="s0">t?r:(</span><span class="s1">this</span><span class="s0">.push({id:r}),o.cloneNode(r))}}checkBlockScopedCollisions(e,t,r,n){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;param&quot;</span><span class="s0">!==t&amp;&amp;</span><span class="s3">&quot;local&quot;</span><span class="s0">!==e.kind&amp;&amp;(</span><span class="s3">&quot;let&quot;</span><span class="s0">===t||</span><span class="s3">&quot;let&quot;</span><span class="s0">===e.kind||</span><span class="s3">&quot;const&quot;</span><span class="s0">===e.kind||</span><span class="s3">&quot;module&quot;</span><span class="s0">===e.kind||</span><span class="s3">&quot;param&quot;</span><span class="s0">===e.kind&amp;&amp;(</span><span class="s3">&quot;let&quot;</span><span class="s0">===t||</span><span class="s3">&quot;const&quot;</span><span class="s0">===t)))</span><span class="s1">throw this</span><span class="s0">.hub.buildError(n,`Duplicate declaration </span><span class="s3">&quot;${r}&quot;</span><span class="s0">`,TypeError)}rename(e,t,r){const i=</span><span class="s1">this</span><span class="s0">.getBinding(e);</span><span class="s1">if</span><span class="s0">(i)</span><span class="s1">return </span><span class="s0">t=t||</span><span class="s1">this</span><span class="s0">.generateUidIdentifier(e).name,</span><span class="s1">new </span><span class="s0">n.</span><span class="s1">default</span><span class="s0">(i,e,t).rename(r)}_renameFromMap(e,t,r,n){e[t]&amp;&amp;(e[r]=n,e[t]=</span><span class="s1">null</span><span class="s0">)}dump(){const e=</span><span class="s3">&quot;-&quot;</span><span class="s0">.repeat(</span><span class="s2">60</span><span class="s0">);console.log(e);let t=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{console.log(</span><span class="s3">&quot;#&quot;</span><span class="s0">,t.block.type);</span><span class="s1">for</span><span class="s0">(const e of Object.keys(t.bindings)){const r=t.bindings[e];console.log(</span><span class="s3">&quot; -&quot;</span><span class="s0">,e,{constant:r.constant,references:r.references,violations:r.constantViolations.length,kind:r.kind})}}</span><span class="s1">while</span><span class="s0">(t=t.parent);console.log(e)}toArray(e,t,r){</span><span class="s1">if</span><span class="s0">(o.isIdentifier(e)){const t=</span><span class="s1">this</span><span class="s0">.getBinding(e.name);</span><span class="s1">if</span><span class="s0">((</span><span class="s1">null</span><span class="s0">==t?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.constant)&amp;&amp;t.path.isGenericType(</span><span class="s3">&quot;Array&quot;</span><span class="s0">))</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">if</span><span class="s0">(o.isArrayExpression(e))</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(o.isIdentifier(e,{name:</span><span class="s3">&quot;arguments&quot;</span><span class="s0">}))</span><span class="s1">return </span><span class="s0">o.callExpression(o.memberExpression(o.memberExpression(o.memberExpression(o.identifier(</span><span class="s3">&quot;Array&quot;</span><span class="s0">),o.identifier(</span><span class="s3">&quot;prototype&quot;</span><span class="s0">)),o.identifier(</span><span class="s3">&quot;slice&quot;</span><span class="s0">)),o.identifier(</span><span class="s3">&quot;call&quot;</span><span class="s0">)),[e]);let n;const i=[e];</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">===t?n=</span><span class="s3">&quot;toConsumableArray&quot;</span><span class="s0">:t?(i.push(o.numericLiteral(t)),n=</span><span class="s3">&quot;slicedToArray&quot;</span><span class="s0">):n=</span><span class="s3">&quot;toArray&quot;</span><span class="s0">,r&amp;&amp;(i.unshift(</span><span class="s1">this</span><span class="s0">.hub.addHelper(n)),n=</span><span class="s3">&quot;maybeArrayLike&quot;</span><span class="s0">),o.callExpression(</span><span class="s1">this</span><span class="s0">.hub.addHelper(n),i)}hasLabel(e){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.getLabel(e)}getLabel(e){</span><span class="s1">return this</span><span class="s0">.labels.get(e)}registerLabel(e){</span><span class="s1">this</span><span class="s0">.labels.set(e.node.label.name,e)}registerDeclaration(e){</span><span class="s1">if</span><span class="s0">(e.isLabeledStatement())</span><span class="s1">this</span><span class="s0">.registerLabel(e);</span><span class="s1">else if</span><span class="s0">(e.isFunctionDeclaration())</span><span class="s1">this</span><span class="s0">.registerBinding(</span><span class="s3">&quot;hoisted&quot;</span><span class="s0">,e.get(</span><span class="s3">&quot;id&quot;</span><span class="s0">),e);</span><span class="s1">else if</span><span class="s0">(e.isVariableDeclaration()){const t=e.get(</span><span class="s3">&quot;declarations&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const r of t)</span><span class="s1">this</span><span class="s0">.registerBinding(e.node.kind,r)}</span><span class="s1">else if</span><span class="s0">(e.isClassDeclaration())</span><span class="s1">this</span><span class="s0">.registerBinding(</span><span class="s3">&quot;let&quot;</span><span class="s0">,e);</span><span class="s1">else if</span><span class="s0">(e.isImportDeclaration()){const t=e.get(</span><span class="s3">&quot;specifiers&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const e of t)</span><span class="s1">this</span><span class="s0">.registerBinding(</span><span class="s3">&quot;module&quot;</span><span class="s0">,e)}</span><span class="s1">else if</span><span class="s0">(e.isExportDeclaration()){const t=e.get(</span><span class="s3">&quot;declaration&quot;</span><span class="s0">);(t.isClassDeclaration()||t.isFunctionDeclaration()||t.isVariableDeclaration())&amp;&amp;</span><span class="s1">this</span><span class="s0">.registerDeclaration(t)}</span><span class="s1">else this</span><span class="s0">.registerBinding(</span><span class="s3">&quot;unknown&quot;</span><span class="s0">,e)}buildUndefinedNode(){</span><span class="s1">return </span><span class="s0">o.unaryExpression(</span><span class="s3">&quot;void&quot;</span><span class="s0">,o.numericLiteral(</span><span class="s2">0</span><span class="s0">),!</span><span class="s2">0</span><span class="s0">)}registerConstantViolation(e){const t=e.getBindingIdentifiers();</span><span class="s1">for</span><span class="s0">(const r of Object.keys(t)){const t=</span><span class="s1">this</span><span class="s0">.getBinding(r);t&amp;&amp;t.reassign(e)}}registerBinding(e,t,r=t){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">throw new </span><span class="s0">ReferenceError(</span><span class="s3">&quot;no `kind`&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(t.isVariableDeclaration()){const r=t.get(</span><span class="s3">&quot;declarations&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const t of r)</span><span class="s1">this</span><span class="s0">.registerBinding(e,t);</span><span class="s1">return</span><span class="s0">}const n=</span><span class="s1">this</span><span class="s0">.getProgramParent(),i=t.getOuterBindingIdentifiers(!</span><span class="s2">0</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const t of Object.keys(i)){n.references[t]=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const n of i[t]){const i=</span><span class="s1">this</span><span class="s0">.getOwnBinding(t);</span><span class="s1">if</span><span class="s0">(i){</span><span class="s1">if</span><span class="s0">(i.identifier===n)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.checkBlockScopedCollisions(i,e,t,n)}i?</span><span class="s1">this</span><span class="s0">.registerConstantViolation(r):</span><span class="s1">this</span><span class="s0">.bindings[t]=</span><span class="s1">new </span><span class="s0">s.</span><span class="s1">default</span><span class="s0">({identifier:n,scope:</span><span class="s1">this</span><span class="s0">,path:r,kind:e})}}}addGlobal(e){</span><span class="s1">this</span><span class="s0">.globals[e.name]=e}hasUid(e){let t=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(t.uids[e])</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">while</span><span class="s0">(t=t.parent);</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}hasGlobal(e){let t=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(t.globals[e])</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">while</span><span class="s0">(t=t.parent);</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">}hasReference(e){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.getProgramParent().references[e]}isPure(e,t){</span><span class="s1">if</span><span class="s0">(o.isIdentifier(e)){const r=</span><span class="s1">this</span><span class="s0">.getBinding(e.name);</span><span class="s1">return</span><span class="s0">!!r&amp;&amp;(!t||r.constant)}</span><span class="s1">if</span><span class="s0">(o.isClass(e))</span><span class="s1">return</span><span class="s0">!(e.superClass&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isPure(e.superClass,t))&amp;&amp;</span><span class="s1">this</span><span class="s0">.isPure(e.body,t);</span><span class="s1">if</span><span class="s0">(o.isClassBody(e)){</span><span class="s1">for</span><span class="s0">(const r of e.body)</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isPure(r,t))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(o.isBinary(e))</span><span class="s1">return this</span><span class="s0">.isPure(e.left,t)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isPure(e.right,t);</span><span class="s1">if</span><span class="s0">(o.isArrayExpression(e)){</span><span class="s1">for</span><span class="s0">(const r of e.elements)</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isPure(r,t))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(o.isObjectExpression(e)){</span><span class="s1">for</span><span class="s0">(const r of e.properties)</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isPure(r,t))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(o.isMethod(e))</span><span class="s1">return</span><span class="s0">!(e.computed&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isPure(e.key,t))&amp;&amp;</span><span class="s3">&quot;get&quot;</span><span class="s0">!==e.kind&amp;&amp;</span><span class="s3">&quot;set&quot;</span><span class="s0">!==e.kind;</span><span class="s1">if</span><span class="s0">(o.isProperty(e))</span><span class="s1">return</span><span class="s0">!(e.computed&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isPure(e.key,t))&amp;&amp;</span><span class="s1">this</span><span class="s0">.isPure(e.value,t);</span><span class="s1">if</span><span class="s0">(o.isUnaryExpression(e))</span><span class="s1">return this</span><span class="s0">.isPure(e.argument,t);</span><span class="s1">if</span><span class="s0">(o.isTaggedTemplateExpression(e))</span><span class="s1">return </span><span class="s0">o.matchesPattern(e.tag,</span><span class="s3">&quot;String.raw&quot;</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasBinding(</span><span class="s3">&quot;String&quot;</span><span class="s0">,!</span><span class="s2">0</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isPure(e.quasi,t);</span><span class="s1">if</span><span class="s0">(o.isTemplateLiteral(e)){</span><span class="s1">for</span><span class="s0">(const r of e.expressions)</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isPure(r,t))</span><span class="s1">return</span><span class="s0">!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s2">0</span><span class="s0">}</span><span class="s1">return </span><span class="s0">o.isPureish(e)}setData(e,t){</span><span class="s1">return this</span><span class="s0">.data[e]=t}getData(e){let t=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{const r=t.data[e];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=r)</span><span class="s1">return </span><span class="s0">r}</span><span class="s1">while</span><span class="s0">(t=t.parent)}removeData(e){let t=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{</span><span class="s1">null</span><span class="s0">!=t.data[e]&amp;&amp;(t.data[e]=</span><span class="s1">null</span><span class="s0">)}</span><span class="s1">while</span><span class="s0">(t=t.parent)}init(){</span><span class="s1">this</span><span class="s0">.inited||(</span><span class="s1">this</span><span class="s0">.inited=!</span><span class="s2">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.crawl())}crawl(){const e=</span><span class="s1">this</span><span class="s0">.path;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.references=Object.create(</span><span class="s1">null</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.bindings=Object.create(</span><span class="s1">null</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.globals=Object.create(</span><span class="s1">null</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.uids=Object.create(</span><span class="s1">null</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.data=Object.create(</span><span class="s1">null</span><span class="s0">),e.isFunction()){e.isFunctionExpression()&amp;&amp;e.has(</span><span class="s3">&quot;id&quot;</span><span class="s0">)&amp;&amp;!e.get(</span><span class="s3">&quot;id&quot;</span><span class="s0">).node[o.NOT_LOCAL_BINDING]&amp;&amp;</span><span class="s1">this</span><span class="s0">.registerBinding(</span><span class="s3">&quot;local&quot;</span><span class="s0">,e.get(</span><span class="s3">&quot;id&quot;</span><span class="s0">),e);const t=e.get(</span><span class="s3">&quot;params&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const e of t)</span><span class="s1">this</span><span class="s0">.registerBinding(</span><span class="s3">&quot;param&quot;</span><span class="s0">,e)}const t=</span><span class="s1">this</span><span class="s0">.getProgramParent();</span><span class="s1">if</span><span class="s0">(t.crawling)</span><span class="s1">return</span><span class="s0">;const r={references:[],constantViolations:[],assignments:[]};</span><span class="s1">this</span><span class="s0">.crawling=!</span><span class="s2">0</span><span class="s0">,e.traverse(d,r),</span><span class="s1">this</span><span class="s0">.crawling=!</span><span class="s2">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const e of r.assignments){const r=e.getBindingIdentifiers();</span><span class="s1">for</span><span class="s0">(const n of Object.keys(r))e.scope.getBinding(n)||t.addGlobal(r[n]);e.scope.registerConstantViolation(e)}</span><span class="s1">for</span><span class="s0">(const e of r.references){const r=e.scope.getBinding(e.node.name);r?r.reference(e):t.addGlobal(e.node)}</span><span class="s1">for</span><span class="s0">(const e of r.constantViolations)e.scope.registerConstantViolation(e)}push(e){let t=</span><span class="s1">this</span><span class="s0">.path;t.isBlockStatement()||t.isProgram()||(t=</span><span class="s1">this</span><span class="s0">.getBlockParent().path),t.isSwitchStatement()&amp;&amp;(t=(</span><span class="s1">this</span><span class="s0">.getFunctionParent()||</span><span class="s1">this</span><span class="s0">.getProgramParent()).path),(t.isLoop()||t.isCatchClause()||t.isFunction())&amp;&amp;(t.ensureBlock(),t=t.get(</span><span class="s3">&quot;body&quot;</span><span class="s0">));const r=e.unique,n=e.kind||</span><span class="s3">&quot;var&quot;</span><span class="s0">,i=</span><span class="s1">null</span><span class="s0">==e._blockHoist?</span><span class="s2">2</span><span class="s0">:e._blockHoist,s=`declaration:${n}:${i}`;let a=!r&amp;&amp;t.getData(s);</span><span class="s1">if</span><span class="s0">(!a){const e=o.variableDeclaration(n,[]);e._blockHoist=i,[a]=t.unshiftContainer(</span><span class="s3">&quot;body&quot;</span><span class="s0">,[e]),r||t.setData(s,a)}const l=o.variableDeclarator(e.id,e.init);a.node.declarations.push(l),</span><span class="s1">this</span><span class="s0">.registerBinding(n,a.get(</span><span class="s3">&quot;declarations&quot;</span><span class="s0">).pop())}getProgramParent(){let e=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(e.path.isProgram())</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">while</span><span class="s0">(e=e.parent);</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Couldn't find a Program&quot;</span><span class="s0">)}getFunctionParent(){let e=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(e.path.isFunctionParent())</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">while</span><span class="s0">(e=e.parent);</span><span class="s1">return null</span><span class="s0">}getBlockParent(){let e=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(e.path.isBlockParent())</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">while</span><span class="s0">(e=e.parent);</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...&quot;</span><span class="s0">)}getAllBindings(){const e=Object.create(</span><span class="s1">null</span><span class="s0">);let t=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{</span><span class="s1">for</span><span class="s0">(const r of Object.keys(t.bindings))r </span><span class="s1">in </span><span class="s0">e==</span><span class="s2">0</span><span class="s0">&amp;&amp;(e[r]=t.bindings[r]);t=t.parent}</span><span class="s1">while</span><span class="s0">(t);</span><span class="s1">return </span><span class="s0">e}getAllBindingsOfKind(){const e=Object.create(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const t of arguments){let r=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{</span><span class="s1">for</span><span class="s0">(const n of Object.keys(r.bindings)){const i=r.bindings[n];i.kind===t&amp;&amp;(e[n]=i)}r=r.parent}</span><span class="s1">while</span><span class="s0">(r)}</span><span class="s1">return </span><span class="s0">e}bindingIdentifierEquals(e,t){</span><span class="s1">return this</span><span class="s0">.getBindingIdentifier(e)===t}getBinding(e){let t,r=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{const i=r.getOwnBinding(e);</span><span class="s1">var </span><span class="s0">n;</span><span class="s1">if</span><span class="s0">(i&amp;&amp;(!(</span><span class="s1">null</span><span class="s0">==(n=t)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:n.isPattern())||</span><span class="s3">&quot;param&quot;</span><span class="s0">===i.kind))</span><span class="s1">return </span><span class="s0">i;t=r.path}</span><span class="s1">while</span><span class="s0">(r=r.parent)}getOwnBinding(e){</span><span class="s1">return this</span><span class="s0">.bindings[e]}getBindingIdentifier(e){</span><span class="s1">var </span><span class="s0">t;</span><span class="s1">return null</span><span class="s0">==(t=</span><span class="s1">this</span><span class="s0">.getBinding(e))?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.identifier}getOwnBindingIdentifier(e){const t=</span><span class="s1">this</span><span class="s0">.bindings[e];</span><span class="s1">return null</span><span class="s0">==t?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:t.identifier}hasOwnBinding(e){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.getOwnBinding(e)}hasBinding(e,t){</span><span class="s1">return</span><span class="s0">!(!e||!</span><span class="s1">this</span><span class="s0">.hasOwnBinding(e)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.parentHasBinding(e,t)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasUid(e)&amp;&amp;(t||!f.globals.includes(e))&amp;&amp;(t||!f.contextVariables.includes(e)))}parentHasBinding(e,t){</span><span class="s1">var </span><span class="s0">r;</span><span class="s1">return null</span><span class="s0">==(r=</span><span class="s1">this</span><span class="s0">.parent)?</span><span class="s1">void </span><span class="s2">0</span><span class="s0">:r.hasBinding(e,t)}moveBindingTo(e,t){const r=</span><span class="s1">this</span><span class="s0">.getBinding(e);r&amp;&amp;(r.scope.removeOwnBinding(e),r.scope=t,t.bindings[e]=r)}removeOwnBinding(e){</span><span class="s1">delete this</span><span class="s0">.bindings[e]}removeBinding(e){</span><span class="s1">var </span><span class="s0">t;</span><span class="s1">null</span><span class="s0">==(t=</span><span class="s1">this</span><span class="s0">.getBinding(e))||t.scope.removeOwnBinding(e);let r=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{r.uids[e]&amp;&amp;(r.uids[e]=!</span><span class="s2">1</span><span class="s0">)}</span><span class="s1">while</span><span class="s0">(r=r.parent)}}t.</span><span class="s1">default</span><span class="s0">=f,f.globals=Object.keys(a.</span><span class="s1">default</span><span class="s0">.builtin),f.contextVariables=[</span><span class="s3">&quot;arguments&quot;</span><span class="s0">,</span><span class="s3">&quot;undefined&quot;</span><span class="s0">,</span><span class="s3">&quot;Infinity&quot;</span><span class="s0">,</span><span class="s3">&quot;NaN&quot;</span><span class="s0">]},</span><span class="s2">1360</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">void </span><span class="s2">0</span><span class="s0">,s(r(</span><span class="s2">2329</span><span class="s0">));</span><span class="s1">var </span><span class="s0">n=s(r(</span><span class="s2">7224</span><span class="s0">));</span><span class="s1">function </span><span class="s0">i(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">i=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}</span><span class="s1">function </span><span class="s0">s(e){</span><span class="s1">return </span><span class="s0">e&amp;&amp;e.__esModule?e:{</span><span class="s1">default</span><span class="s0">:e}}!</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=i();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">s </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,s)){</span><span class="s1">var </span><span class="s0">a=n?Object.getOwnPropertyDescriptor(e,s):</span><span class="s1">null</span><span class="s0">;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r)}(r(</span><span class="s2">1710</span><span class="s0">));const a={ReferencedIdentifier({node:e},t){e.name===t.oldName&amp;&amp;(e.name=t.newName)},Scope(e,t){e.scope.bindingIdentifierEquals(t.oldName,t.binding.identifier)||e.skip()},</span><span class="s3">&quot;AssignmentExpression|Declaration|VariableDeclarator&quot;</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(e.isVariableDeclaration())</span><span class="s1">return</span><span class="s0">;const r=e.getOuterBindingIdentifiers();</span><span class="s1">for</span><span class="s0">(const e </span><span class="s1">in </span><span class="s0">r)e===t.oldName&amp;&amp;(r[e].name=t.newName)}};t.</span><span class="s1">default</span><span class="s0">=class{constructor(e,t,r){</span><span class="s1">this</span><span class="s0">.newName=r,</span><span class="s1">this</span><span class="s0">.oldName=t,</span><span class="s1">this</span><span class="s0">.binding=e}maybeConvertFromExportDeclaration(e){const t=e.parentPath;t.isExportDeclaration()&amp;&amp;(t.isExportDefaultDeclaration()&amp;&amp;!t.get(</span><span class="s3">&quot;declaration&quot;</span><span class="s0">).node.id||(</span><span class="s2">0</span><span class="s0">,n.</span><span class="s1">default</span><span class="s0">)(t))}maybeConvertFromClassFunctionDeclaration(e){}maybeConvertFromClassFunctionExpression(e){}rename(e){const{binding:t,oldName:r,newName:n}=</span><span class="s1">this</span><span class="s0">,{scope:i,path:s}=t,o=s.find((e=&gt;e.isDeclaration()||e.isFunctionExpression()||e.isClassExpression()));o&amp;&amp;o.getOuterBindingIdentifiers()[r]===t.identifier&amp;&amp;</span><span class="s1">this</span><span class="s0">.maybeConvertFromExportDeclaration(o),i.traverse(e||i.block,a,</span><span class="s1">this</span><span class="s0">),e||(i.removeOwnBinding(r),i.bindings[n]=t,</span><span class="s1">this</span><span class="s0">.binding.identifier.name=n),t.type,o&amp;&amp;(</span><span class="s1">this</span><span class="s0">.maybeConvertFromClassFunctionDeclaration(o),</span><span class="s1">this</span><span class="s0">.maybeConvertFromClassFunctionExpression(o))}}},</span><span class="s2">8221</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s3">&quot;use strict&quot;</span><span class="s0">;Object.defineProperty(t,</span><span class="s3">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s2">0</span><span class="s0">}),t.explode=o,t.verify=l,t.merge=</span><span class="s1">function</span><span class="s0">(e,t=[],r){const n={};</span><span class="s1">for</span><span class="s0">(let i=</span><span class="s2">0</span><span class="s0">;i&lt;e.length;i++){const s=e[i],a=t[i];o(s);</span><span class="s1">for</span><span class="s0">(const e of Object.keys(s)){let t=s[e];(a||r)&amp;&amp;(t=c(t,a,r)),f(n[e]=n[e]||{},t)}}</span><span class="s1">return </span><span class="s0">n};</span><span class="s1">var </span><span class="s0">n=a(r(</span><span class="s2">1025</span><span class="s0">)),i=a(r(</span><span class="s2">1710</span><span class="s0">));</span><span class="s1">function </span><span class="s0">s(){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">WeakMap)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">return </span><span class="s0">s=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e},e}</span><span class="s1">function </span><span class="s0">a(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.__esModule)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s3">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s3">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{</span><span class="s1">default</span><span class="s0">:e};</span><span class="s1">var </span><span class="s0">t=s();</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.has(e))</span><span class="s1">return </span><span class="s0">t.get(e);</span><span class="s1">var </span><span class="s0">r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(e,i)){</span><span class="s1">var </span><span class="s0">a=n?Object.getOwnPropertyDescriptor(e,i):</span><span class="s1">null</span><span class="s0">;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,i,a):r[i]=e[i]}</span><span class="s1">return </span><span class="s0">r.</span><span class="s1">default</span><span class="s0">=e,t&amp;&amp;t.set(e,r),r}</span><span class="s1">function </span><span class="s0">o(e){</span><span class="s1">if</span><span class="s0">(e._exploded)</span><span class="s1">return </span><span class="s0">e;e._exploded=!</span><span class="s2">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const t of Object.keys(e)){</span><span class="s1">if</span><span class="s0">(h(t))</span><span class="s1">continue</span><span class="s0">;const r=t.split(</span><span class="s3">&quot;|&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">1</span><span class="s0">===r.length)</span><span class="s1">continue</span><span class="s0">;const n=e[t];</span><span class="s1">delete </span><span class="s0">e[t];</span><span class="s1">for</span><span class="s0">(const t of r)e[t]=n}l(e),</span><span class="s1">delete </span><span class="s0">e.__esModule,</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">for</span><span class="s0">(const t of Object.keys(e)){</span><span class="s1">if</span><span class="s0">(h(t))</span><span class="s1">continue</span><span class="s0">;const r=e[t];</span><span class="s3">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r&amp;&amp;(e[t]={enter:r})}}(e),u(e);</span><span class="s1">for</span><span class="s0">(const t of Object.keys(e)){</span><span class="s1">if</span><span class="s0">(h(t))</span><span class="s1">continue</span><span class="s0">;const r=n[t];</span><span class="s1">if</span><span class="s0">(!r)</span><span class="s1">continue</span><span class="s0">;const i=e[t];</span><span class="s1">for</span><span class="s0">(const e of Object.keys(i))i[e]=d(r,i[e]);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">delete </span><span class="s0">e[t],r.types)</span><span class="s1">for</span><span class="s0">(const t of r.types)e[t]?f(e[t],i):e[t]=i;</span><span class="s1">else </span><span class="s0">f(e,i)}</span><span class="s1">for</span><span class="s0">(const t of Object.keys(e)){</span><span class="s1">if</span><span class="s0">(h(t))</span><span class="s1">continue</span><span class="s0">;const r=e[t];let n=i.FLIPPED_ALIAS_KEYS[t];const s=i.DEPRECATED_KEYS[t];</span><span class="s1">if</span><span class="s0">(s&amp;&amp;(console.trace(`Visitor defined </span><span class="s1">for </span><span class="s0">${t} but it has been renamed to ${s}`),n=[s]),n){</span><span class="s1">delete </span><span class="s0">e[t];</span><span class="s1">for</span><span class="s0">(const t of n){const n=e[t];n?f(n,r):e[t]=Object.assign({},r)}}}</span><span class="s1">for</span><span class="s0">(const t of Object.keys(e))h(t)||u(e[t]);</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">function </span><span class="s0">l(e){</span><span class="s1">if</span><span class="s0">(!e._verified){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const t of Object.keys(e)){</span><span class="s1">if</span><span class="s0">(</span><span class="s3">&quot;enter&quot;</span><span class="s0">!==t&amp;&amp;</span><span class="s3">&quot;exit&quot;</span><span class="s0">!==t||p(t,e[t]),h(t))</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(i.TYPES.indexOf(t)&lt;</span><span class="s2">0</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(`You gave us a visitor </span><span class="s1">for </span><span class="s0">the node type ${t} but it</span><span class="s3">'s not a valid type`);const r=e[t];if(&quot;object&quot;==typeof r)for(const e of Object.keys(r)){if(&quot;enter&quot;!==e&amp;&amp;&quot;exit&quot;!==e)throw new Error(`You passed </span><span class="s5">\`</span><span class="s3">traverse()</span><span class="s5">\` </span><span class="s3">a visitor object with the property ${t} that has the invalid property ${e}`);p(`${t}.${e}`,r[e])}}e._verified=!0}}function p(e,t){const r=[].concat(t);for(const t of r)if(&quot;function&quot;!=typeof t)throw new TypeError(`Non-function found defined in ${e} with type ${typeof t}`)}function c(e,t,r){const n={};for(const i of Object.keys(e)){let s=e[i];Array.isArray(s)&amp;&amp;(s=s.map((function(e){let n=e;return t&amp;&amp;(n=function(r){return e.call(t,r,t)}),r&amp;&amp;(n=r(t.key,i,n)),n!==e&amp;&amp;(n.toString=()=&gt;e.toString()),n})),n[i]=s)}return n}function u(e){e.enter&amp;&amp;!Array.isArray(e.enter)&amp;&amp;(e.enter=[e.enter]),e.exit&amp;&amp;!Array.isArray(e.exit)&amp;&amp;(e.exit=[e.exit])}function d(e,t){const r=function(r){if(e.checkPath(r))return t.apply(this,arguments)};return r.toString=()=&gt;t.toString(),r}function h(e){return&quot;_&quot;===e[0]||&quot;enter&quot;===e||&quot;exit&quot;===e||&quot;shouldSkip&quot;===e||&quot;denylist&quot;===e||&quot;noScope&quot;===e||&quot;skipKeys&quot;===e||&quot;blacklist&quot;===e}function f(e,t){for(const r of Object.keys(t))e[r]=[].concat(e[r]||[],t[r])}},7010:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e){if(!(0,i.default)(e)){var t;const r=null!=(t=null==e?void 0:e.type)?t:JSON.stringify(e);throw new TypeError(`Not a valid node of type &quot;${r}&quot;`)}};var n,i=(n=r(1784))&amp;&amp;n.__esModule?n:{default:n}},939:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.assertArrayExpression=function(e,t={}){s(&quot;ArrayExpression&quot;,e,t)},t.assertAssignmentExpression=function(e,t={}){s(&quot;AssignmentExpression&quot;,e,t)},t.assertBinaryExpression=function(e,t={}){s(&quot;BinaryExpression&quot;,e,t)},t.assertInterpreterDirective=function(e,t={}){s(&quot;InterpreterDirective&quot;,e,t)},t.assertDirective=function(e,t={}){s(&quot;Directive&quot;,e,t)},t.assertDirectiveLiteral=function(e,t={}){s(&quot;DirectiveLiteral&quot;,e,t)},t.assertBlockStatement=function(e,t={}){s(&quot;BlockStatement&quot;,e,t)},t.assertBreakStatement=function(e,t={}){s(&quot;BreakStatement&quot;,e,t)},t.assertCallExpression=function(e,t={}){s(&quot;CallExpression&quot;,e,t)},t.assertCatchClause=function(e,t={}){s(&quot;CatchClause&quot;,e,t)},t.assertConditionalExpression=function(e,t={}){s(&quot;ConditionalExpression&quot;,e,t)},t.assertContinueStatement=function(e,t={}){s(&quot;ContinueStatement&quot;,e,t)},t.assertDebuggerStatement=function(e,t={}){s(&quot;DebuggerStatement&quot;,e,t)},t.assertDoWhileStatement=function(e,t={}){s(&quot;DoWhileStatement&quot;,e,t)},t.assertEmptyStatement=function(e,t={}){s(&quot;EmptyStatement&quot;,e,t)},t.assertExpressionStatement=function(e,t={}){s(&quot;ExpressionStatement&quot;,e,t)},t.assertFile=function(e,t={}){s(&quot;File&quot;,e,t)},t.assertForInStatement=function(e,t={}){s(&quot;ForInStatement&quot;,e,t)},t.assertForStatement=function(e,t={}){s(&quot;ForStatement&quot;,e,t)},t.assertFunctionDeclaration=function(e,t={}){s(&quot;FunctionDeclaration&quot;,e,t)},t.assertFunctionExpression=function(e,t={}){s(&quot;FunctionExpression&quot;,e,t)},t.assertIdentifier=function(e,t={}){s(&quot;Identifier&quot;,e,t)},t.assertIfStatement=function(e,t={}){s(&quot;IfStatement&quot;,e,t)},t.assertLabeledStatement=function(e,t={}){s(&quot;LabeledStatement&quot;,e,t)},t.assertStringLiteral=function(e,t={}){s(&quot;StringLiteral&quot;,e,t)},t.assertNumericLiteral=function(e,t={}){s(&quot;NumericLiteral&quot;,e,t)},t.assertNullLiteral=function(e,t={}){s(&quot;NullLiteral&quot;,e,t)},t.assertBooleanLiteral=function(e,t={}){s(&quot;BooleanLiteral&quot;,e,t)},t.assertRegExpLiteral=function(e,t={}){s(&quot;RegExpLiteral&quot;,e,t)},t.assertLogicalExpression=function(e,t={}){s(&quot;LogicalExpression&quot;,e,t)},t.assertMemberExpression=function(e,t={}){s(&quot;MemberExpression&quot;,e,t)},t.assertNewExpression=function(e,t={}){s(&quot;NewExpression&quot;,e,t)},t.assertProgram=function(e,t={}){s(&quot;Program&quot;,e,t)},t.assertObjectExpression=function(e,t={}){s(&quot;ObjectExpression&quot;,e,t)},t.assertObjectMethod=function(e,t={}){s(&quot;ObjectMethod&quot;,e,t)},t.assertObjectProperty=function(e,t={}){s(&quot;ObjectProperty&quot;,e,t)},t.assertRestElement=function(e,t={}){s(&quot;RestElement&quot;,e,t)},t.assertReturnStatement=function(e,t={}){s(&quot;ReturnStatement&quot;,e,t)},t.assertSequenceExpression=function(e,t={}){s(&quot;SequenceExpression&quot;,e,t)},t.assertParenthesizedExpression=function(e,t={}){s(&quot;ParenthesizedExpression&quot;,e,t)},t.assertSwitchCase=function(e,t={}){s(&quot;SwitchCase&quot;,e,t)},t.assertSwitchStatement=function(e,t={}){s(&quot;SwitchStatement&quot;,e,t)},t.assertThisExpression=function(e,t={}){s(&quot;ThisExpression&quot;,e,t)},t.assertThrowStatement=function(e,t={}){s(&quot;ThrowStatement&quot;,e,t)},t.assertTryStatement=function(e,t={}){s(&quot;TryStatement&quot;,e,t)},t.assertUnaryExpression=function(e,t={}){s(&quot;UnaryExpression&quot;,e,t)},t.assertUpdateExpression=function(e,t={}){s(&quot;UpdateExpression&quot;,e,t)},t.assertVariableDeclaration=function(e,t={}){s(&quot;VariableDeclaration&quot;,e,t)},t.assertVariableDeclarator=function(e,t={}){s(&quot;VariableDeclarator&quot;,e,t)},t.assertWhileStatement=function(e,t={}){s(&quot;WhileStatement&quot;,e,t)},t.assertWithStatement=function(e,t={}){s(&quot;WithStatement&quot;,e,t)},t.assertAssignmentPattern=function(e,t={}){s(&quot;AssignmentPattern&quot;,e,t)},t.assertArrayPattern=function(e,t={}){s(&quot;ArrayPattern&quot;,e,t)},t.assertArrowFunctionExpression=function(e,t={}){s(&quot;ArrowFunctionExpression&quot;,e,t)},t.assertClassBody=function(e,t={}){s(&quot;ClassBody&quot;,e,t)},t.assertClassExpression=function(e,t={}){s(&quot;ClassExpression&quot;,e,t)},t.assertClassDeclaration=function(e,t={}){s(&quot;ClassDeclaration&quot;,e,t)},t.assertExportAllDeclaration=function(e,t={}){s(&quot;ExportAllDeclaration&quot;,e,t)},t.assertExportDefaultDeclaration=function(e,t={}){s(&quot;ExportDefaultDeclaration&quot;,e,t)},t.assertExportNamedDeclaration=function(e,t={}){s(&quot;ExportNamedDeclaration&quot;,e,t)},t.assertExportSpecifier=function(e,t={}){s(&quot;ExportSpecifier&quot;,e,t)},t.assertForOfStatement=function(e,t={}){s(&quot;ForOfStatement&quot;,e,t)},t.assertImportDeclaration=function(e,t={}){s(&quot;ImportDeclaration&quot;,e,t)},t.assertImportDefaultSpecifier=function(e,t={}){s(&quot;ImportDefaultSpecifier&quot;,e,t)},t.assertImportNamespaceSpecifier=function(e,t={}){s(&quot;ImportNamespaceSpecifier&quot;,e,t)},t.assertImportSpecifier=function(e,t={}){s(&quot;ImportSpecifier&quot;,e,t)},t.assertMetaProperty=function(e,t={}){s(&quot;MetaProperty&quot;,e,t)},t.assertClassMethod=function(e,t={}){s(&quot;ClassMethod&quot;,e,t)},t.assertObjectPattern=function(e,t={}){s(&quot;ObjectPattern&quot;,e,t)},t.assertSpreadElement=function(e,t={}){s(&quot;SpreadElement&quot;,e,t)},t.assertSuper=function(e,t={}){s(&quot;Super&quot;,e,t)},t.assertTaggedTemplateExpression=function(e,t={}){s(&quot;TaggedTemplateExpression&quot;,e,t)},t.assertTemplateElement=function(e,t={}){s(&quot;TemplateElement&quot;,e,t)},t.assertTemplateLiteral=function(e,t={}){s(&quot;TemplateLiteral&quot;,e,t)},t.assertYieldExpression=function(e,t={}){s(&quot;YieldExpression&quot;,e,t)},t.assertAwaitExpression=function(e,t={}){s(&quot;AwaitExpression&quot;,e,t)},t.assertImport=function(e,t={}){s(&quot;Import&quot;,e,t)},t.assertBigIntLiteral=function(e,t={}){s(&quot;BigIntLiteral&quot;,e,t)},t.assertExportNamespaceSpecifier=function(e,t={}){s(&quot;ExportNamespaceSpecifier&quot;,e,t)},t.assertOptionalMemberExpression=function(e,t={}){s(&quot;OptionalMemberExpression&quot;,e,t)},t.assertOptionalCallExpression=function(e,t={}){s(&quot;OptionalCallExpression&quot;,e,t)},t.assertAnyTypeAnnotation=function(e,t={}){s(&quot;AnyTypeAnnotation&quot;,e,t)},t.assertArrayTypeAnnotation=function(e,t={}){s(&quot;ArrayTypeAnnotation&quot;,e,t)},t.assertBooleanTypeAnnotation=function(e,t={}){s(&quot;BooleanTypeAnnotation&quot;,e,t)},t.assertBooleanLiteralTypeAnnotation=function(e,t={}){s(&quot;BooleanLiteralTypeAnnotation&quot;,e,t)},t.assertNullLiteralTypeAnnotation=function(e,t={}){s(&quot;NullLiteralTypeAnnotation&quot;,e,t)},t.assertClassImplements=function(e,t={}){s(&quot;ClassImplements&quot;,e,t)},t.assertDeclareClass=function(e,t={}){s(&quot;DeclareClass&quot;,e,t)},t.assertDeclareFunction=function(e,t={}){s(&quot;DeclareFunction&quot;,e,t)},t.assertDeclareInterface=function(e,t={}){s(&quot;DeclareInterface&quot;,e,t)},t.assertDeclareModule=function(e,t={}){s(&quot;DeclareModule&quot;,e,t)},t.assertDeclareModuleExports=function(e,t={}){s(&quot;DeclareModuleExports&quot;,e,t)},t.assertDeclareTypeAlias=function(e,t={}){s(&quot;DeclareTypeAlias&quot;,e,t)},t.assertDeclareOpaqueType=function(e,t={}){s(&quot;DeclareOpaqueType&quot;,e,t)},t.assertDeclareVariable=function(e,t={}){s(&quot;DeclareVariable&quot;,e,t)},t.assertDeclareExportDeclaration=function(e,t={}){s(&quot;DeclareExportDeclaration&quot;,e,t)},t.assertDeclareExportAllDeclaration=function(e,t={}){s(&quot;DeclareExportAllDeclaration&quot;,e,t)},t.assertDeclaredPredicate=function(e,t={}){s(&quot;DeclaredPredicate&quot;,e,t)},t.assertExistsTypeAnnotation=function(e,t={}){s(&quot;ExistsTypeAnnotation&quot;,e,t)},t.assertFunctionTypeAnnotation=function(e,t={}){s(&quot;FunctionTypeAnnotation&quot;,e,t)},t.assertFunctionTypeParam=function(e,t={}){s(&quot;FunctionTypeParam&quot;,e,t)},t.assertGenericTypeAnnotation=function(e,t={}){s(&quot;GenericTypeAnnotation&quot;,e,t)},t.assertInferredPredicate=function(e,t={}){s(&quot;InferredPredicate&quot;,e,t)},t.assertInterfaceExtends=function(e,t={}){s(&quot;InterfaceExtends&quot;,e,t)},t.assertInterfaceDeclaration=function(e,t={}){s(&quot;InterfaceDeclaration&quot;,e,t)},t.assertInterfaceTypeAnnotation=function(e,t={}){s(&quot;InterfaceTypeAnnotation&quot;,e,t)},t.assertIntersectionTypeAnnotation=function(e,t={}){s(&quot;IntersectionTypeAnnotation&quot;,e,t)},t.assertMixedTypeAnnotation=function(e,t={}){s(&quot;MixedTypeAnnotation&quot;,e,t)},t.assertEmptyTypeAnnotation=function(e,t={}){s(&quot;EmptyTypeAnnotation&quot;,e,t)},t.assertNullableTypeAnnotation=function(e,t={}){s(&quot;NullableTypeAnnotation&quot;,e,t)},t.assertNumberLiteralTypeAnnotation=function(e,t={}){s(&quot;NumberLiteralTypeAnnotation&quot;,e,t)},t.assertNumberTypeAnnotation=function(e,t={}){s(&quot;NumberTypeAnnotation&quot;,e,t)},t.assertObjectTypeAnnotation=function(e,t={}){s(&quot;ObjectTypeAnnotation&quot;,e,t)},t.assertObjectTypeInternalSlot=function(e,t={}){s(&quot;ObjectTypeInternalSlot&quot;,e,t)},t.assertObjectTypeCallProperty=function(e,t={}){s(&quot;ObjectTypeCallProperty&quot;,e,t)},t.assertObjectTypeIndexer=function(e,t={}){s(&quot;ObjectTypeIndexer&quot;,e,t)},t.assertObjectTypeProperty=function(e,t={}){s(&quot;ObjectTypeProperty&quot;,e,t)},t.assertObjectTypeSpreadProperty=function(e,t={}){s(&quot;ObjectTypeSpreadProperty&quot;,e,t)},t.assertOpaqueType=function(e,t={}){s(&quot;OpaqueType&quot;,e,t)},t.assertQualifiedTypeIdentifier=function(e,t={}){s(&quot;QualifiedTypeIdentifier&quot;,e,t)},t.assertStringLiteralTypeAnnotation=function(e,t={}){s(&quot;StringLiteralTypeAnnotation&quot;,e,t)},t.assertStringTypeAnnotation=function(e,t={}){s(&quot;StringTypeAnnotation&quot;,e,t)},t.assertSymbolTypeAnnotation=function(e,t={}){s(&quot;SymbolTypeAnnotation&quot;,e,t)},t.assertThisTypeAnnotation=function(e,t={}){s(&quot;ThisTypeAnnotation&quot;,e,t)},t.assertTupleTypeAnnotation=function(e,t={}){s(&quot;TupleTypeAnnotation&quot;,e,t)},t.assertTypeofTypeAnnotation=function(e,t={}){s(&quot;TypeofTypeAnnotation&quot;,e,t)},t.assertTypeAlias=function(e,t={}){s(&quot;TypeAlias&quot;,e,t)},t.assertTypeAnnotation=function(e,t={}){s(&quot;TypeAnnotation&quot;,e,t)},t.assertTypeCastExpression=function(e,t={}){s(&quot;TypeCastExpression&quot;,e,t)},t.assertTypeParameter=function(e,t={}){s(&quot;TypeParameter&quot;,e,t)},t.assertTypeParameterDeclaration=function(e,t={}){s(&quot;TypeParameterDeclaration&quot;,e,t)},t.assertTypeParameterInstantiation=function(e,t={}){s(&quot;TypeParameterInstantiation&quot;,e,t)},t.assertUnionTypeAnnotation=function(e,t={}){s(&quot;UnionTypeAnnotation&quot;,e,t)},t.assertVariance=function(e,t={}){s(&quot;Variance&quot;,e,t)},t.assertVoidTypeAnnotation=function(e,t={}){s(&quot;VoidTypeAnnotation&quot;,e,t)},t.assertEnumDeclaration=function(e,t={}){s(&quot;EnumDeclaration&quot;,e,t)},t.assertEnumBooleanBody=function(e,t={}){s(&quot;EnumBooleanBody&quot;,e,t)},t.assertEnumNumberBody=function(e,t={}){s(&quot;EnumNumberBody&quot;,e,t)},t.assertEnumStringBody=function(e,t={}){s(&quot;EnumStringBody&quot;,e,t)},t.assertEnumSymbolBody=function(e,t={}){s(&quot;EnumSymbolBody&quot;,e,t)},t.assertEnumBooleanMember=function(e,t={}){s(&quot;EnumBooleanMember&quot;,e,t)},t.assertEnumNumberMember=function(e,t={}){s(&quot;EnumNumberMember&quot;,e,t)},t.assertEnumStringMember=function(e,t={}){s(&quot;EnumStringMember&quot;,e,t)},t.assertEnumDefaultedMember=function(e,t={}){s(&quot;EnumDefaultedMember&quot;,e,t)},t.assertJSXAttribute=function(e,t={}){s(&quot;JSXAttribute&quot;,e,t)},t.assertJSXClosingElement=function(e,t={}){s(&quot;JSXClosingElement&quot;,e,t)},t.assertJSXElement=function(e,t={}){s(&quot;JSXElement&quot;,e,t)},t.assertJSXEmptyExpression=function(e,t={}){s(&quot;JSXEmptyExpression&quot;,e,t)},t.assertJSXExpressionContainer=function(e,t={}){s(&quot;JSXExpressionContainer&quot;,e,t)},t.assertJSXSpreadChild=function(e,t={}){s(&quot;JSXSpreadChild&quot;,e,t)},t.assertJSXIdentifier=function(e,t={}){s(&quot;JSXIdentifier&quot;,e,t)},t.assertJSXMemberExpression=function(e,t={}){s(&quot;JSXMemberExpression&quot;,e,t)},t.assertJSXNamespacedName=function(e,t={}){s(&quot;JSXNamespacedName&quot;,e,t)},t.assertJSXOpeningElement=function(e,t={}){s(&quot;JSXOpeningElement&quot;,e,t)},t.assertJSXSpreadAttribute=function(e,t={}){s(&quot;JSXSpreadAttribute&quot;,e,t)},t.assertJSXText=function(e,t={}){s(&quot;JSXText&quot;,e,t)},t.assertJSXFragment=function(e,t={}){s(&quot;JSXFragment&quot;,e,t)},t.assertJSXOpeningFragment=function(e,t={}){s(&quot;JSXOpeningFragment&quot;,e,t)},t.assertJSXClosingFragment=function(e,t={}){s(&quot;JSXClosingFragment&quot;,e,t)},t.assertNoop=function(e,t={}){s(&quot;Noop&quot;,e,t)},t.assertPlaceholder=function(e,t={}){s(&quot;Placeholder&quot;,e,t)},t.assertV8IntrinsicIdentifier=function(e,t={}){s(&quot;V8IntrinsicIdentifier&quot;,e,t)},t.assertArgumentPlaceholder=function(e,t={}){s(&quot;ArgumentPlaceholder&quot;,e,t)},t.assertBindExpression=function(e,t={}){s(&quot;BindExpression&quot;,e,t)},t.assertClassProperty=function(e,t={}){s(&quot;ClassProperty&quot;,e,t)},t.assertPipelineTopicExpression=function(e,t={}){s(&quot;PipelineTopicExpression&quot;,e,t)},t.assertPipelineBareFunction=function(e,t={}){s(&quot;PipelineBareFunction&quot;,e,t)},t.assertPipelinePrimaryTopicReference=function(e,t={}){s(&quot;PipelinePrimaryTopicReference&quot;,e,t)},t.assertClassPrivateProperty=function(e,t={}){s(&quot;ClassPrivateProperty&quot;,e,t)},t.assertClassPrivateMethod=function(e,t={}){s(&quot;ClassPrivateMethod&quot;,e,t)},t.assertImportAttribute=function(e,t={}){s(&quot;ImportAttribute&quot;,e,t)},t.assertDecorator=function(e,t={}){s(&quot;Decorator&quot;,e,t)},t.assertDoExpression=function(e,t={}){s(&quot;DoExpression&quot;,e,t)},t.assertExportDefaultSpecifier=function(e,t={}){s(&quot;ExportDefaultSpecifier&quot;,e,t)},t.assertPrivateName=function(e,t={}){s(&quot;PrivateName&quot;,e,t)},t.assertRecordExpression=function(e,t={}){s(&quot;RecordExpression&quot;,e,t)},t.assertTupleExpression=function(e,t={}){s(&quot;TupleExpression&quot;,e,t)},t.assertDecimalLiteral=function(e,t={}){s(&quot;DecimalLiteral&quot;,e,t)},t.assertStaticBlock=function(e,t={}){s(&quot;StaticBlock&quot;,e,t)},t.assertTSParameterProperty=function(e,t={}){s(&quot;TSParameterProperty&quot;,e,t)},t.assertTSDeclareFunction=function(e,t={}){s(&quot;TSDeclareFunction&quot;,e,t)},t.assertTSDeclareMethod=function(e,t={}){s(&quot;TSDeclareMethod&quot;,e,t)},t.assertTSQualifiedName=function(e,t={}){s(&quot;TSQualifiedName&quot;,e,t)},t.assertTSCallSignatureDeclaration=function(e,t={}){s(&quot;TSCallSignatureDeclaration&quot;,e,t)},t.assertTSConstructSignatureDeclaration=function(e,t={}){s(&quot;TSConstructSignatureDeclaration&quot;,e,t)},t.assertTSPropertySignature=function(e,t={}){s(&quot;TSPropertySignature&quot;,e,t)},t.assertTSMethodSignature=function(e,t={}){s(&quot;TSMethodSignature&quot;,e,t)},t.assertTSIndexSignature=function(e,t={}){s(&quot;TSIndexSignature&quot;,e,t)},t.assertTSAnyKeyword=function(e,t={}){s(&quot;TSAnyKeyword&quot;,e,t)},t.assertTSBooleanKeyword=function(e,t={}){s(&quot;TSBooleanKeyword&quot;,e,t)},t.assertTSBigIntKeyword=function(e,t={}){s(&quot;TSBigIntKeyword&quot;,e,t)},t.assertTSIntrinsicKeyword=function(e,t={}){s(&quot;TSIntrinsicKeyword&quot;,e,t)},t.assertTSNeverKeyword=function(e,t={}){s(&quot;TSNeverKeyword&quot;,e,t)},t.assertTSNullKeyword=function(e,t={}){s(&quot;TSNullKeyword&quot;,e,t)},t.assertTSNumberKeyword=function(e,t={}){s(&quot;TSNumberKeyword&quot;,e,t)},t.assertTSObjectKeyword=function(e,t={}){s(&quot;TSObjectKeyword&quot;,e,t)},t.assertTSStringKeyword=function(e,t={}){s(&quot;TSStringKeyword&quot;,e,t)},t.assertTSSymbolKeyword=function(e,t={}){s(&quot;TSSymbolKeyword&quot;,e,t)},t.assertTSUndefinedKeyword=function(e,t={}){s(&quot;TSUndefinedKeyword&quot;,e,t)},t.assertTSUnknownKeyword=function(e,t={}){s(&quot;TSUnknownKeyword&quot;,e,t)},t.assertTSVoidKeyword=function(e,t={}){s(&quot;TSVoidKeyword&quot;,e,t)},t.assertTSThisType=function(e,t={}){s(&quot;TSThisType&quot;,e,t)},t.assertTSFunctionType=function(e,t={}){s(&quot;TSFunctionType&quot;,e,t)},t.assertTSConstructorType=function(e,t={}){s(&quot;TSConstructorType&quot;,e,t)},t.assertTSTypeReference=function(e,t={}){s(&quot;TSTypeReference&quot;,e,t)},t.assertTSTypePredicate=function(e,t={}){s(&quot;TSTypePredicate&quot;,e,t)},t.assertTSTypeQuery=function(e,t={}){s(&quot;TSTypeQuery&quot;,e,t)},t.assertTSTypeLiteral=function(e,t={}){s(&quot;TSTypeLiteral&quot;,e,t)},t.assertTSArrayType=function(e,t={}){s(&quot;TSArrayType&quot;,e,t)},t.assertTSTupleType=function(e,t={}){s(&quot;TSTupleType&quot;,e,t)},t.assertTSOptionalType=function(e,t={}){s(&quot;TSOptionalType&quot;,e,t)},t.assertTSRestType=function(e,t={}){s(&quot;TSRestType&quot;,e,t)},t.assertTSNamedTupleMember=function(e,t={}){s(&quot;TSNamedTupleMember&quot;,e,t)},t.assertTSUnionType=function(e,t={}){s(&quot;TSUnionType&quot;,e,t)},t.assertTSIntersectionType=function(e,t={}){s(&quot;TSIntersectionType&quot;,e,t)},t.assertTSConditionalType=function(e,t={}){s(&quot;TSConditionalType&quot;,e,t)},t.assertTSInferType=function(e,t={}){s(&quot;TSInferType&quot;,e,t)},t.assertTSParenthesizedType=function(e,t={}){s(&quot;TSParenthesizedType&quot;,e,t)},t.assertTSTypeOperator=function(e,t={}){s(&quot;TSTypeOperator&quot;,e,t)},t.assertTSIndexedAccessType=function(e,t={}){s(&quot;TSIndexedAccessType&quot;,e,t)},t.assertTSMappedType=function(e,t={}){s(&quot;TSMappedType&quot;,e,t)},t.assertTSLiteralType=function(e,t={}){s(&quot;TSLiteralType&quot;,e,t)},t.assertTSExpressionWithTypeArguments=function(e,t={}){s(&quot;TSExpressionWithTypeArguments&quot;,e,t)},t.assertTSInterfaceDeclaration=function(e,t={}){s(&quot;TSInterfaceDeclaration&quot;,e,t)},t.assertTSInterfaceBody=function(e,t={}){s(&quot;TSInterfaceBody&quot;,e,t)},t.assertTSTypeAliasDeclaration=function(e,t={}){s(&quot;TSTypeAliasDeclaration&quot;,e,t)},t.assertTSAsExpression=function(e,t={}){s(&quot;TSAsExpression&quot;,e,t)},t.assertTSTypeAssertion=function(e,t={}){s(&quot;TSTypeAssertion&quot;,e,t)},t.assertTSEnumDeclaration=function(e,t={}){s(&quot;TSEnumDeclaration&quot;,e,t)},t.assertTSEnumMember=function(e,t={}){s(&quot;TSEnumMember&quot;,e,t)},t.assertTSModuleDeclaration=function(e,t={}){s(&quot;TSModuleDeclaration&quot;,e,t)},t.assertTSModuleBlock=function(e,t={}){s(&quot;TSModuleBlock&quot;,e,t)},t.assertTSImportType=function(e,t={}){s(&quot;TSImportType&quot;,e,t)},t.assertTSImportEqualsDeclaration=function(e,t={}){s(&quot;TSImportEqualsDeclaration&quot;,e,t)},t.assertTSExternalModuleReference=function(e,t={}){s(&quot;TSExternalModuleReference&quot;,e,t)},t.assertTSNonNullExpression=function(e,t={}){s(&quot;TSNonNullExpression&quot;,e,t)},t.assertTSExportAssignment=function(e,t={}){s(&quot;TSExportAssignment&quot;,e,t)},t.assertTSNamespaceExportDeclaration=function(e,t={}){s(&quot;TSNamespaceExportDeclaration&quot;,e,t)},t.assertTSTypeAnnotation=function(e,t={}){s(&quot;TSTypeAnnotation&quot;,e,t)},t.assertTSTypeParameterInstantiation=function(e,t={}){s(&quot;TSTypeParameterInstantiation&quot;,e,t)},t.assertTSTypeParameterDeclaration=function(e,t={}){s(&quot;TSTypeParameterDeclaration&quot;,e,t)},t.assertTSTypeParameter=function(e,t={}){s(&quot;TSTypeParameter&quot;,e,t)},t.assertExpression=function(e,t={}){s(&quot;Expression&quot;,e,t)},t.assertBinary=function(e,t={}){s(&quot;Binary&quot;,e,t)},t.assertScopable=function(e,t={}){s(&quot;Scopable&quot;,e,t)},t.assertBlockParent=function(e,t={}){s(&quot;BlockParent&quot;,e,t)},t.assertBlock=function(e,t={}){s(&quot;Block&quot;,e,t)},t.assertStatement=function(e,t={}){s(&quot;Statement&quot;,e,t)},t.assertTerminatorless=function(e,t={}){s(&quot;Terminatorless&quot;,e,t)},t.assertCompletionStatement=function(e,t={}){s(&quot;CompletionStatement&quot;,e,t)},t.assertConditional=function(e,t={}){s(&quot;Conditional&quot;,e,t)},t.assertLoop=function(e,t={}){s(&quot;Loop&quot;,e,t)},t.assertWhile=function(e,t={}){s(&quot;While&quot;,e,t)},t.assertExpressionWrapper=function(e,t={}){s(&quot;ExpressionWrapper&quot;,e,t)},t.assertFor=function(e,t={}){s(&quot;For&quot;,e,t)},t.assertForXStatement=function(e,t={}){s(&quot;ForXStatement&quot;,e,t)},t.assertFunction=function(e,t={}){s(&quot;Function&quot;,e,t)},t.assertFunctionParent=function(e,t={}){s(&quot;FunctionParent&quot;,e,t)},t.assertPureish=function(e,t={}){s(&quot;Pureish&quot;,e,t)},t.assertDeclaration=function(e,t={}){s(&quot;Declaration&quot;,e,t)},t.assertPatternLike=function(e,t={}){s(&quot;PatternLike&quot;,e,t)},t.assertLVal=function(e,t={}){s(&quot;LVal&quot;,e,t)},t.assertTSEntityName=function(e,t={}){s(&quot;TSEntityName&quot;,e,t)},t.assertLiteral=function(e,t={}){s(&quot;Literal&quot;,e,t)},t.assertImmutable=function(e,t={}){s(&quot;Immutable&quot;,e,t)},t.assertUserWhitespacable=function(e,t={}){s(&quot;UserWhitespacable&quot;,e,t)},t.assertMethod=function(e,t={}){s(&quot;Method&quot;,e,t)},t.assertObjectMember=function(e,t={}){s(&quot;ObjectMember&quot;,e,t)},t.assertProperty=function(e,t={}){s(&quot;Property&quot;,e,t)},t.assertUnaryLike=function(e,t={}){s(&quot;UnaryLike&quot;,e,t)},t.assertPattern=function(e,t={}){s(&quot;Pattern&quot;,e,t)},t.assertClass=function(e,t={}){s(&quot;Class&quot;,e,t)},t.assertModuleDeclaration=function(e,t={}){s(&quot;ModuleDeclaration&quot;,e,t)},t.assertExportDeclaration=function(e,t={}){s(&quot;ExportDeclaration&quot;,e,t)},t.assertModuleSpecifier=function(e,t={}){s(&quot;ModuleSpecifier&quot;,e,t)},t.assertFlow=function(e,t={}){s(&quot;Flow&quot;,e,t)},t.assertFlowType=function(e,t={}){s(&quot;FlowType&quot;,e,t)},t.assertFlowBaseAnnotation=function(e,t={}){s(&quot;FlowBaseAnnotation&quot;,e,t)},t.assertFlowDeclaration=function(e,t={}){s(&quot;FlowDeclaration&quot;,e,t)},t.assertFlowPredicate=function(e,t={}){s(&quot;FlowPredicate&quot;,e,t)},t.assertEnumBody=function(e,t={}){s(&quot;EnumBody&quot;,e,t)},t.assertEnumMember=function(e,t={}){s(&quot;EnumMember&quot;,e,t)},t.assertJSX=function(e,t={}){s(&quot;JSX&quot;,e,t)},t.assertPrivate=function(e,t={}){s(&quot;Private&quot;,e,t)},t.assertTSTypeElement=function(e,t={}){s(&quot;TSTypeElement&quot;,e,t)},t.assertTSType=function(e,t={}){s(&quot;TSType&quot;,e,t)},t.assertTSBaseType=function(e,t={}){s(&quot;TSBaseType&quot;,e,t)},t.assertNumberLiteral=function(e,t){console.trace(&quot;The node type NumberLiteral has been renamed to NumericLiteral&quot;),s(&quot;NumberLiteral&quot;,e,t)},t.assertRegexLiteral=function(e,t){console.trace(&quot;The node type RegexLiteral has been renamed to RegExpLiteral&quot;),s(&quot;RegexLiteral&quot;,e,t)},t.assertRestProperty=function(e,t){console.trace(&quot;The node type RestProperty has been renamed to RestElement&quot;),s(&quot;RestProperty&quot;,e,t)},t.assertSpreadProperty=function(e,t){console.trace(&quot;The node type SpreadProperty has been renamed to SpreadElement&quot;),s(&quot;SpreadProperty&quot;,e,t)};var n,i=(n=r(6593))&amp;&amp;n.__esModule?n:{default:n};function s(e,t,r){if(!(0,i.default)(e,t,r))throw new Error(`Expected type &quot;${e}&quot; with option ${JSON.stringify(r)}, but instead got &quot;${t.type}&quot;.`)}},1739:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e,...t){const r=i.BUILDER_KEYS[e],a=t.length;if(a&gt;r.length)throw new Error(`${e}: Too many arguments passed. Received ${a} but can receive no more than ${r.length}`);const o={type:e};let l=0;r.forEach((r=&gt;{const s=i.NODE_FIELDS[e][r];let p;l&lt;a&amp;&amp;(p=t[l]),void 0===p&amp;&amp;(p=(0,n.default)(s.default)),o[r]=p,l++}));for(const e of Object.keys(o))(0,s.default)(o,e,o[e]);return o};var n=a(r(8269)),i=r(9829),s=a(r(9623));function a(e){return e&amp;&amp;e.__esModule?e:{default:e}}},6535:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e){const t=(0,s.default)(e);return 1===t.length?t[0]:(0,i.unionTypeAnnotation)(t)};var n,i=r(3894),s=(n=r(4485))&amp;&amp;n.__esModule?n:{default:n}},5209:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e){if(&quot;string&quot;===e)return(0,n.stringTypeAnnotation)();if(&quot;number&quot;===e)return(0,n.numberTypeAnnotation)();if(&quot;undefined&quot;===e)return(0,n.voidTypeAnnotation)();if(&quot;boolean&quot;===e)return(0,n.booleanTypeAnnotation)();if(&quot;function&quot;===e)return(0,n.genericTypeAnnotation)((0,n.identifier)(&quot;Function&quot;));if(&quot;object&quot;===e)return(0,n.genericTypeAnnotation)((0,n.identifier)(&quot;Object&quot;));if(&quot;symbol&quot;===e)return(0,n.genericTypeAnnotation)((0,n.identifier)(&quot;Symbol&quot;));throw new Error(&quot;Invalid typeof value&quot;)};var n=r(3894)},3894:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.ArrayExpression=t.arrayExpression=function(...e){return(0,i.default)(&quot;ArrayExpression&quot;,...e)},t.AssignmentExpression=t.assignmentExpression=function(...e){return(0,i.default)(&quot;AssignmentExpression&quot;,...e)},t.BinaryExpression=t.binaryExpression=function(...e){return(0,i.default)(&quot;BinaryExpression&quot;,...e)},t.InterpreterDirective=t.interpreterDirective=function(...e){return(0,i.default)(&quot;InterpreterDirective&quot;,...e)},t.Directive=t.directive=function(...e){return(0,i.default)(&quot;Directive&quot;,...e)},t.DirectiveLiteral=t.directiveLiteral=function(...e){return(0,i.default)(&quot;DirectiveLiteral&quot;,...e)},t.BlockStatement=t.blockStatement=function(...e){return(0,i.default)(&quot;BlockStatement&quot;,...e)},t.BreakStatement=t.breakStatement=function(...e){return(0,i.default)(&quot;BreakStatement&quot;,...e)},t.CallExpression=t.callExpression=function(...e){return(0,i.default)(&quot;CallExpression&quot;,...e)},t.CatchClause=t.catchClause=function(...e){return(0,i.default)(&quot;CatchClause&quot;,...e)},t.ConditionalExpression=t.conditionalExpression=function(...e){return(0,i.default)(&quot;ConditionalExpression&quot;,...e)},t.ContinueStatement=t.continueStatement=function(...e){return(0,i.default)(&quot;ContinueStatement&quot;,...e)},t.DebuggerStatement=t.debuggerStatement=function(...e){return(0,i.default)(&quot;DebuggerStatement&quot;,...e)},t.DoWhileStatement=t.doWhileStatement=function(...e){return(0,i.default)(&quot;DoWhileStatement&quot;,...e)},t.EmptyStatement=t.emptyStatement=function(...e){return(0,i.default)(&quot;EmptyStatement&quot;,...e)},t.ExpressionStatement=t.expressionStatement=function(...e){return(0,i.default)(&quot;ExpressionStatement&quot;,...e)},t.File=t.file=function(...e){return(0,i.default)(&quot;File&quot;,...e)},t.ForInStatement=t.forInStatement=function(...e){return(0,i.default)(&quot;ForInStatement&quot;,...e)},t.ForStatement=t.forStatement=function(...e){return(0,i.default)(&quot;ForStatement&quot;,...e)},t.FunctionDeclaration=t.functionDeclaration=function(...e){return(0,i.default)(&quot;FunctionDeclaration&quot;,...e)},t.FunctionExpression=t.functionExpression=function(...e){return(0,i.default)(&quot;FunctionExpression&quot;,...e)},t.Identifier=t.identifier=function(...e){return(0,i.default)(&quot;Identifier&quot;,...e)},t.IfStatement=t.ifStatement=function(...e){return(0,i.default)(&quot;IfStatement&quot;,...e)},t.LabeledStatement=t.labeledStatement=function(...e){return(0,i.default)(&quot;LabeledStatement&quot;,...e)},t.StringLiteral=t.stringLiteral=function(...e){return(0,i.default)(&quot;StringLiteral&quot;,...e)},t.NumericLiteral=t.numericLiteral=function(...e){return(0,i.default)(&quot;NumericLiteral&quot;,...e)},t.NullLiteral=t.nullLiteral=function(...e){return(0,i.default)(&quot;NullLiteral&quot;,...e)},t.BooleanLiteral=t.booleanLiteral=function(...e){return(0,i.default)(&quot;BooleanLiteral&quot;,...e)},t.RegExpLiteral=t.regExpLiteral=function(...e){return(0,i.default)(&quot;RegExpLiteral&quot;,...e)},t.LogicalExpression=t.logicalExpression=function(...e){return(0,i.default)(&quot;LogicalExpression&quot;,...e)},t.MemberExpression=t.memberExpression=function(...e){return(0,i.default)(&quot;MemberExpression&quot;,...e)},t.NewExpression=t.newExpression=function(...e){return(0,i.default)(&quot;NewExpression&quot;,...e)},t.Program=t.program=function(...e){return(0,i.default)(&quot;Program&quot;,...e)},t.ObjectExpression=t.objectExpression=function(...e){return(0,i.default)(&quot;ObjectExpression&quot;,...e)},t.ObjectMethod=t.objectMethod=function(...e){return(0,i.default)(&quot;ObjectMethod&quot;,...e)},t.ObjectProperty=t.objectProperty=function(...e){return(0,i.default)(&quot;ObjectProperty&quot;,...e)},t.RestElement=t.restElement=function(...e){return(0,i.default)(&quot;RestElement&quot;,...e)},t.ReturnStatement=t.returnStatement=function(...e){return(0,i.default)(&quot;ReturnStatement&quot;,...e)},t.SequenceExpression=t.sequenceExpression=function(...e){return(0,i.default)(&quot;SequenceExpression&quot;,...e)},t.ParenthesizedExpression=t.parenthesizedExpression=function(...e){return(0,i.default)(&quot;ParenthesizedExpression&quot;,...e)},t.SwitchCase=t.switchCase=function(...e){return(0,i.default)(&quot;SwitchCase&quot;,...e)},t.SwitchStatement=t.switchStatement=function(...e){return(0,i.default)(&quot;SwitchStatement&quot;,...e)},t.ThisExpression=t.thisExpression=function(...e){return(0,i.default)(&quot;ThisExpression&quot;,...e)},t.ThrowStatement=t.throwStatement=function(...e){return(0,i.default)(&quot;ThrowStatement&quot;,...e)},t.TryStatement=t.tryStatement=function(...e){return(0,i.default)(&quot;TryStatement&quot;,...e)},t.UnaryExpression=t.unaryExpression=function(...e){return(0,i.default)(&quot;UnaryExpression&quot;,...e)},t.UpdateExpression=t.updateExpression=function(...e){return(0,i.default)(&quot;UpdateExpression&quot;,...e)},t.VariableDeclaration=t.variableDeclaration=function(...e){return(0,i.default)(&quot;VariableDeclaration&quot;,...e)},t.VariableDeclarator=t.variableDeclarator=function(...e){return(0,i.default)(&quot;VariableDeclarator&quot;,...e)},t.WhileStatement=t.whileStatement=function(...e){return(0,i.default)(&quot;WhileStatement&quot;,...e)},t.WithStatement=t.withStatement=function(...e){return(0,i.default)(&quot;WithStatement&quot;,...e)},t.AssignmentPattern=t.assignmentPattern=function(...e){return(0,i.default)(&quot;AssignmentPattern&quot;,...e)},t.ArrayPattern=t.arrayPattern=function(...e){return(0,i.default)(&quot;ArrayPattern&quot;,...e)},t.ArrowFunctionExpression=t.arrowFunctionExpression=function(...e){return(0,i.default)(&quot;ArrowFunctionExpression&quot;,...e)},t.ClassBody=t.classBody=function(...e){return(0,i.default)(&quot;ClassBody&quot;,...e)},t.ClassExpression=t.classExpression=function(...e){return(0,i.default)(&quot;ClassExpression&quot;,...e)},t.ClassDeclaration=t.classDeclaration=function(...e){return(0,i.default)(&quot;ClassDeclaration&quot;,...e)},t.ExportAllDeclaration=t.exportAllDeclaration=function(...e){return(0,i.default)(&quot;ExportAllDeclaration&quot;,...e)},t.ExportDefaultDeclaration=t.exportDefaultDeclaration=function(...e){return(0,i.default)(&quot;ExportDefaultDeclaration&quot;,...e)},t.ExportNamedDeclaration=t.exportNamedDeclaration=function(...e){return(0,i.default)(&quot;ExportNamedDeclaration&quot;,...e)},t.ExportSpecifier=t.exportSpecifier=function(...e){return(0,i.default)(&quot;ExportSpecifier&quot;,...e)},t.ForOfStatement=t.forOfStatement=function(...e){return(0,i.default)(&quot;ForOfStatement&quot;,...e)},t.ImportDeclaration=t.importDeclaration=function(...e){return(0,i.default)(&quot;ImportDeclaration&quot;,...e)},t.ImportDefaultSpecifier=t.importDefaultSpecifier=function(...e){return(0,i.default)(&quot;ImportDefaultSpecifier&quot;,...e)},t.ImportNamespaceSpecifier=t.importNamespaceSpecifier=function(...e){return(0,i.default)(&quot;ImportNamespaceSpecifier&quot;,...e)},t.ImportSpecifier=t.importSpecifier=function(...e){return(0,i.default)(&quot;ImportSpecifier&quot;,...e)},t.MetaProperty=t.metaProperty=function(...e){return(0,i.default)(&quot;MetaProperty&quot;,...e)},t.ClassMethod=t.classMethod=function(...e){return(0,i.default)(&quot;ClassMethod&quot;,...e)},t.ObjectPattern=t.objectPattern=function(...e){return(0,i.default)(&quot;ObjectPattern&quot;,...e)},t.SpreadElement=t.spreadElement=function(...e){return(0,i.default)(&quot;SpreadElement&quot;,...e)},t.super=t.Super=function(...e){return(0,i.default)(&quot;Super&quot;,...e)},t.TaggedTemplateExpression=t.taggedTemplateExpression=function(...e){return(0,i.default)(&quot;TaggedTemplateExpression&quot;,...e)},t.TemplateElement=t.templateElement=function(...e){return(0,i.default)(&quot;TemplateElement&quot;,...e)},t.TemplateLiteral=t.templateLiteral=function(...e){return(0,i.default)(&quot;TemplateLiteral&quot;,...e)},t.YieldExpression=t.yieldExpression=function(...e){return(0,i.default)(&quot;YieldExpression&quot;,...e)},t.AwaitExpression=t.awaitExpression=function(...e){return(0,i.default)(&quot;AwaitExpression&quot;,...e)},t.import=t.Import=function(...e){return(0,i.default)(&quot;Import&quot;,...e)},t.BigIntLiteral=t.bigIntLiteral=function(...e){return(0,i.default)(&quot;BigIntLiteral&quot;,...e)},t.ExportNamespaceSpecifier=t.exportNamespaceSpecifier=function(...e){return(0,i.default)(&quot;ExportNamespaceSpecifier&quot;,...e)},t.OptionalMemberExpression=t.optionalMemberExpression=function(...e){return(0,i.default)(&quot;OptionalMemberExpression&quot;,...e)},t.OptionalCallExpression=t.optionalCallExpression=function(...e){return(0,i.default)(&quot;OptionalCallExpression&quot;,...e)},t.AnyTypeAnnotation=t.anyTypeAnnotation=function(...e){return(0,i.default)(&quot;AnyTypeAnnotation&quot;,...e)},t.ArrayTypeAnnotation=t.arrayTypeAnnotation=function(...e){return(0,i.default)(&quot;ArrayTypeAnnotation&quot;,...e)},t.BooleanTypeAnnotation=t.booleanTypeAnnotation=function(...e){return(0,i.default)(&quot;BooleanTypeAnnotation&quot;,...e)},t.BooleanLiteralTypeAnnotation=t.booleanLiteralTypeAnnotation=function(...e){return(0,i.default)(&quot;BooleanLiteralTypeAnnotation&quot;,...e)},t.NullLiteralTypeAnnotation=t.nullLiteralTypeAnnotation=function(...e){return(0,i.default)(&quot;NullLiteralTypeAnnotation&quot;,...e)},t.ClassImplements=t.classImplements=function(...e){return(0,i.default)(&quot;ClassImplements&quot;,...e)},t.DeclareClass=t.declareClass=function(...e){return(0,i.default)(&quot;DeclareClass&quot;,...e)},t.DeclareFunction=t.declareFunction=function(...e){return(0,i.default)(&quot;DeclareFunction&quot;,...e)},t.DeclareInterface=t.declareInterface=function(...e){return(0,i.default)(&quot;DeclareInterface&quot;,...e)},t.DeclareModule=t.declareModule=function(...e){return(0,i.default)(&quot;DeclareModule&quot;,...e)},t.DeclareModuleExports=t.declareModuleExports=function(...e){return(0,i.default)(&quot;DeclareModuleExports&quot;,...e)},t.DeclareTypeAlias=t.declareTypeAlias=function(...e){return(0,i.default)(&quot;DeclareTypeAlias&quot;,...e)},t.DeclareOpaqueType=t.declareOpaqueType=function(...e){return(0,i.default)(&quot;DeclareOpaqueType&quot;,...e)},t.DeclareVariable=t.declareVariable=function(...e){return(0,i.default)(&quot;DeclareVariable&quot;,...e)},t.DeclareExportDeclaration=t.declareExportDeclaration=function(...e){return(0,i.default)(&quot;DeclareExportDeclaration&quot;,...e)},t.DeclareExportAllDeclaration=t.declareExportAllDeclaration=function(...e){return(0,i.default)(&quot;DeclareExportAllDeclaration&quot;,...e)},t.DeclaredPredicate=t.declaredPredicate=function(...e){return(0,i.default)(&quot;DeclaredPredicate&quot;,...e)},t.ExistsTypeAnnotation=t.existsTypeAnnotation=function(...e){return(0,i.default)(&quot;ExistsTypeAnnotation&quot;,...e)},t.FunctionTypeAnnotation=t.functionTypeAnnotation=function(...e){return(0,i.default)(&quot;FunctionTypeAnnotation&quot;,...e)},t.FunctionTypeParam=t.functionTypeParam=function(...e){return(0,i.default)(&quot;FunctionTypeParam&quot;,...e)},t.GenericTypeAnnotation=t.genericTypeAnnotation=function(...e){return(0,i.default)(&quot;GenericTypeAnnotation&quot;,...e)},t.InferredPredicate=t.inferredPredicate=function(...e){return(0,i.default)(&quot;InferredPredicate&quot;,...e)},t.InterfaceExtends=t.interfaceExtends=function(...e){return(0,i.default)(&quot;InterfaceExtends&quot;,...e)},t.InterfaceDeclaration=t.interfaceDeclaration=function(...e){return(0,i.default)(&quot;InterfaceDeclaration&quot;,...e)},t.InterfaceTypeAnnotation=t.interfaceTypeAnnotation=function(...e){return(0,i.default)(&quot;InterfaceTypeAnnotation&quot;,...e)},t.IntersectionTypeAnnotation=t.intersectionTypeAnnotation=function(...e){return(0,i.default)(&quot;IntersectionTypeAnnotation&quot;,...e)},t.MixedTypeAnnotation=t.mixedTypeAnnotation=function(...e){return(0,i.default)(&quot;MixedTypeAnnotation&quot;,...e)},t.EmptyTypeAnnotation=t.emptyTypeAnnotation=function(...e){return(0,i.default)(&quot;EmptyTypeAnnotation&quot;,...e)},t.NullableTypeAnnotation=t.nullableTypeAnnotation=function(...e){return(0,i.default)(&quot;NullableTypeAnnotation&quot;,...e)},t.NumberLiteralTypeAnnotation=t.numberLiteralTypeAnnotation=function(...e){return(0,i.default)(&quot;NumberLiteralTypeAnnotation&quot;,...e)},t.NumberTypeAnnotation=t.numberTypeAnnotation=function(...e){return(0,i.default)(&quot;NumberTypeAnnotation&quot;,...e)},t.ObjectTypeAnnotation=t.objectTypeAnnotation=function(...e){return(0,i.default)(&quot;ObjectTypeAnnotation&quot;,...e)},t.ObjectTypeInternalSlot=t.objectTypeInternalSlot=function(...e){return(0,i.default)(&quot;ObjectTypeInternalSlot&quot;,...e)},t.ObjectTypeCallProperty=t.objectTypeCallProperty=function(...e){return(0,i.default)(&quot;ObjectTypeCallProperty&quot;,...e)},t.ObjectTypeIndexer=t.objectTypeIndexer=function(...e){return(0,i.default)(&quot;ObjectTypeIndexer&quot;,...e)},t.ObjectTypeProperty=t.objectTypeProperty=function(...e){return(0,i.default)(&quot;ObjectTypeProperty&quot;,...e)},t.ObjectTypeSpreadProperty=t.objectTypeSpreadProperty=function(...e){return(0,i.default)(&quot;ObjectTypeSpreadProperty&quot;,...e)},t.OpaqueType=t.opaqueType=function(...e){return(0,i.default)(&quot;OpaqueType&quot;,...e)},t.QualifiedTypeIdentifier=t.qualifiedTypeIdentifier=function(...e){return(0,i.default)(&quot;QualifiedTypeIdentifier&quot;,...e)},t.StringLiteralTypeAnnotation=t.stringLiteralTypeAnnotation=function(...e){return(0,i.default)(&quot;StringLiteralTypeAnnotation&quot;,...e)},t.StringTypeAnnotation=t.stringTypeAnnotation=function(...e){return(0,i.default)(&quot;StringTypeAnnotation&quot;,...e)},t.SymbolTypeAnnotation=t.symbolTypeAnnotation=function(...e){return(0,i.default)(&quot;SymbolTypeAnnotation&quot;,...e)},t.ThisTypeAnnotation=t.thisTypeAnnotation=function(...e){return(0,i.default)(&quot;ThisTypeAnnotation&quot;,...e)},t.TupleTypeAnnotation=t.tupleTypeAnnotation=function(...e){return(0,i.default)(&quot;TupleTypeAnnotation&quot;,...e)},t.TypeofTypeAnnotation=t.typeofTypeAnnotation=function(...e){return(0,i.default)(&quot;TypeofTypeAnnotation&quot;,...e)},t.TypeAlias=t.typeAlias=function(...e){return(0,i.default)(&quot;TypeAlias&quot;,...e)},t.TypeAnnotation=t.typeAnnotation=function(...e){return(0,i.default)(&quot;TypeAnnotation&quot;,...e)},t.TypeCastExpression=t.typeCastExpression=function(...e){return(0,i.default)(&quot;TypeCastExpression&quot;,...e)},t.TypeParameter=t.typeParameter=function(...e){return(0,i.default)(&quot;TypeParameter&quot;,...e)},t.TypeParameterDeclaration=t.typeParameterDeclaration=function(...e){return(0,i.default)(&quot;TypeParameterDeclaration&quot;,...e)},t.TypeParameterInstantiation=t.typeParameterInstantiation=function(...e){return(0,i.default)(&quot;TypeParameterInstantiation&quot;,...e)},t.UnionTypeAnnotation=t.unionTypeAnnotation=function(...e){return(0,i.default)(&quot;UnionTypeAnnotation&quot;,...e)},t.Variance=t.variance=function(...e){return(0,i.default)(&quot;Variance&quot;,...e)},t.VoidTypeAnnotation=t.voidTypeAnnotation=function(...e){return(0,i.default)(&quot;VoidTypeAnnotation&quot;,...e)},t.EnumDeclaration=t.enumDeclaration=function(...e){return(0,i.default)(&quot;EnumDeclaration&quot;,...e)},t.EnumBooleanBody=t.enumBooleanBody=function(...e){return(0,i.default)(&quot;EnumBooleanBody&quot;,...e)},t.EnumNumberBody=t.enumNumberBody=function(...e){return(0,i.default)(&quot;EnumNumberBody&quot;,...e)},t.EnumStringBody=t.enumStringBody=function(...e){return(0,i.default)(&quot;EnumStringBody&quot;,...e)},t.EnumSymbolBody=t.enumSymbolBody=function(...e){return(0,i.default)(&quot;EnumSymbolBody&quot;,...e)},t.EnumBooleanMember=t.enumBooleanMember=function(...e){return(0,i.default)(&quot;EnumBooleanMember&quot;,...e)},t.EnumNumberMember=t.enumNumberMember=function(...e){return(0,i.default)(&quot;EnumNumberMember&quot;,...e)},t.EnumStringMember=t.enumStringMember=function(...e){return(0,i.default)(&quot;EnumStringMember&quot;,...e)},t.EnumDefaultedMember=t.enumDefaultedMember=function(...e){return(0,i.default)(&quot;EnumDefaultedMember&quot;,...e)},t.jSXAttribute=t.JSXAttribute=t.jsxAttribute=function(...e){return(0,i.default)(&quot;JSXAttribute&quot;,...e)},t.jSXClosingElement=t.JSXClosingElement=t.jsxClosingElement=function(...e){return(0,i.default)(&quot;JSXClosingElement&quot;,...e)},t.jSXElement=t.JSXElement=t.jsxElement=function(...e){return(0,i.default)(&quot;JSXElement&quot;,...e)},t.jSXEmptyExpression=t.JSXEmptyExpression=t.jsxEmptyExpression=function(...e){return(0,i.default)(&quot;JSXEmptyExpression&quot;,...e)},t.jSXExpressionContainer=t.JSXExpressionContainer=t.jsxExpressionContainer=function(...e){return(0,i.default)(&quot;JSXExpressionContainer&quot;,...e)},t.jSXSpreadChild=t.JSXSpreadChild=t.jsxSpreadChild=function(...e){return(0,i.default)(&quot;JSXSpreadChild&quot;,...e)},t.jSXIdentifier=t.JSXIdentifier=t.jsxIdentifier=function(...e){return(0,i.default)(&quot;JSXIdentifier&quot;,...e)},t.jSXMemberExpression=t.JSXMemberExpression=t.jsxMemberExpression=function(...e){return(0,i.default)(&quot;JSXMemberExpression&quot;,...e)},t.jSXNamespacedName=t.JSXNamespacedName=t.jsxNamespacedName=function(...e){return(0,i.default)(&quot;JSXNamespacedName&quot;,...e)},t.jSXOpeningElement=t.JSXOpeningElement=t.jsxOpeningElement=function(...e){return(0,i.default)(&quot;JSXOpeningElement&quot;,...e)},t.jSXSpreadAttribute=t.JSXSpreadAttribute=t.jsxSpreadAttribute=function(...e){return(0,i.default)(&quot;JSXSpreadAttribute&quot;,...e)},t.jSXText=t.JSXText=t.jsxText=function(...e){return(0,i.default)(&quot;JSXText&quot;,...e)},t.jSXFragment=t.JSXFragment=t.jsxFragment=function(...e){return(0,i.default)(&quot;JSXFragment&quot;,...e)},t.jSXOpeningFragment=t.JSXOpeningFragment=t.jsxOpeningFragment=function(...e){return(0,i.default)(&quot;JSXOpeningFragment&quot;,...e)},t.jSXClosingFragment=t.JSXClosingFragment=t.jsxClosingFragment=function(...e){return(0,i.default)(&quot;JSXClosingFragment&quot;,...e)},t.Noop=t.noop=function(...e){return(0,i.default)(&quot;Noop&quot;,...e)},t.Placeholder=t.placeholder=function(...e){return(0,i.default)(&quot;Placeholder&quot;,...e)},t.V8IntrinsicIdentifier=t.v8IntrinsicIdentifier=function(...e){return(0,i.default)(&quot;V8IntrinsicIdentifier&quot;,...e)},t.ArgumentPlaceholder=t.argumentPlaceholder=function(...e){return(0,i.default)(&quot;ArgumentPlaceholder&quot;,...e)},t.BindExpression=t.bindExpression=function(...e){return(0,i.default)(&quot;BindExpression&quot;,...e)},t.ClassProperty=t.classProperty=function(...e){return(0,i.default)(&quot;ClassProperty&quot;,...e)},t.PipelineTopicExpression=t.pipelineTopicExpression=function(...e){return(0,i.default)(&quot;PipelineTopicExpression&quot;,...e)},t.PipelineBareFunction=t.pipelineBareFunction=function(...e){return(0,i.default)(&quot;PipelineBareFunction&quot;,...e)},t.PipelinePrimaryTopicReference=t.pipelinePrimaryTopicReference=function(...e){return(0,i.default)(&quot;PipelinePrimaryTopicReference&quot;,...e)},t.ClassPrivateProperty=t.classPrivateProperty=function(...e){return(0,i.default)(&quot;ClassPrivateProperty&quot;,...e)},t.ClassPrivateMethod=t.classPrivateMethod=function(...e){return(0,i.default)(&quot;ClassPrivateMethod&quot;,...e)},t.ImportAttribute=t.importAttribute=function(...e){return(0,i.default)(&quot;ImportAttribute&quot;,...e)},t.Decorator=t.decorator=function(...e){return(0,i.default)(&quot;Decorator&quot;,...e)},t.DoExpression=t.doExpression=function(...e){return(0,i.default)(&quot;DoExpression&quot;,...e)},t.ExportDefaultSpecifier=t.exportDefaultSpecifier=function(...e){return(0,i.default)(&quot;ExportDefaultSpecifier&quot;,...e)},t.PrivateName=t.privateName=function(...e){return(0,i.default)(&quot;PrivateName&quot;,...e)},t.RecordExpression=t.recordExpression=function(...e){return(0,i.default)(&quot;RecordExpression&quot;,...e)},t.TupleExpression=t.tupleExpression=function(...e){return(0,i.default)(&quot;TupleExpression&quot;,...e)},t.DecimalLiteral=t.decimalLiteral=function(...e){return(0,i.default)(&quot;DecimalLiteral&quot;,...e)},t.StaticBlock=t.staticBlock=function(...e){return(0,i.default)(&quot;StaticBlock&quot;,...e)},t.tSParameterProperty=t.TSParameterProperty=t.tsParameterProperty=function(...e){return(0,i.default)(&quot;TSParameterProperty&quot;,...e)},t.tSDeclareFunction=t.TSDeclareFunction=t.tsDeclareFunction=function(...e){return(0,i.default)(&quot;TSDeclareFunction&quot;,...e)},t.tSDeclareMethod=t.TSDeclareMethod=t.tsDeclareMethod=function(...e){return(0,i.default)(&quot;TSDeclareMethod&quot;,...e)},t.tSQualifiedName=t.TSQualifiedName=t.tsQualifiedName=function(...e){return(0,i.default)(&quot;TSQualifiedName&quot;,...e)},t.tSCallSignatureDeclaration=t.TSCallSignatureDeclaration=t.tsCallSignatureDeclaration=function(...e){return(0,i.default)(&quot;TSCallSignatureDeclaration&quot;,...e)},t.tSConstructSignatureDeclaration=t.TSConstructSignatureDeclaration=t.tsConstructSignatureDeclaration=function(...e){return(0,i.default)(&quot;TSConstructSignatureDeclaration&quot;,...e)},t.tSPropertySignature=t.TSPropertySignature=t.tsPropertySignature=function(...e){return(0,i.default)(&quot;TSPropertySignature&quot;,...e)},t.tSMethodSignature=t.TSMethodSignature=t.tsMethodSignature=function(...e){return(0,i.default)(&quot;TSMethodSignature&quot;,...e)},t.tSIndexSignature=t.TSIndexSignature=t.tsIndexSignature=function(...e){return(0,i.default)(&quot;TSIndexSignature&quot;,...e)},t.tSAnyKeyword=t.TSAnyKeyword=t.tsAnyKeyword=function(...e){return(0,i.default)(&quot;TSAnyKeyword&quot;,...e)},t.tSBooleanKeyword=t.TSBooleanKeyword=t.tsBooleanKeyword=function(...e){return(0,i.default)(&quot;TSBooleanKeyword&quot;,...e)},t.tSBigIntKeyword=t.TSBigIntKeyword=t.tsBigIntKeyword=function(...e){return(0,i.default)(&quot;TSBigIntKeyword&quot;,...e)},t.tSIntrinsicKeyword=t.TSIntrinsicKeyword=t.tsIntrinsicKeyword=function(...e){return(0,i.default)(&quot;TSIntrinsicKeyword&quot;,...e)},t.tSNeverKeyword=t.TSNeverKeyword=t.tsNeverKeyword=function(...e){return(0,i.default)(&quot;TSNeverKeyword&quot;,...e)},t.tSNullKeyword=t.TSNullKeyword=t.tsNullKeyword=function(...e){return(0,i.default)(&quot;TSNullKeyword&quot;,...e)},t.tSNumberKeyword=t.TSNumberKeyword=t.tsNumberKeyword=function(...e){return(0,i.default)(&quot;TSNumberKeyword&quot;,...e)},t.tSObjectKeyword=t.TSObjectKeyword=t.tsObjectKeyword=function(...e){return(0,i.default)(&quot;TSObjectKeyword&quot;,...e)},t.tSStringKeyword=t.TSStringKeyword=t.tsStringKeyword=function(...e){return(0,i.default)(&quot;TSStringKeyword&quot;,...e)},t.tSSymbolKeyword=t.TSSymbolKeyword=t.tsSymbolKeyword=function(...e){return(0,i.default)(&quot;TSSymbolKeyword&quot;,...e)},t.tSUndefinedKeyword=t.TSUndefinedKeyword=t.tsUndefinedKeyword=function(...e){return(0,i.default)(&quot;TSUndefinedKeyword&quot;,...e)},t.tSUnknownKeyword=t.TSUnknownKeyword=t.tsUnknownKeyword=function(...e){return(0,i.default)(&quot;TSUnknownKeyword&quot;,...e)},t.tSVoidKeyword=t.TSVoidKeyword=t.tsVoidKeyword=function(...e){return(0,i.default)(&quot;TSVoidKeyword&quot;,...e)},t.tSThisType=t.TSThisType=t.tsThisType=function(...e){return(0,i.default)(&quot;TSThisType&quot;,...e)},t.tSFunctionType=t.TSFunctionType=t.tsFunctionType=function(...e){return(0,i.default)(&quot;TSFunctionType&quot;,...e)},t.tSConstructorType=t.TSConstructorType=t.tsConstructorType=function(...e){return(0,i.default)(&quot;TSConstructorType&quot;,...e)},t.tSTypeReference=t.TSTypeReference=t.tsTypeReference=function(...e){return(0,i.default)(&quot;TSTypeReference&quot;,...e)},t.tSTypePredicate=t.TSTypePredicate=t.tsTypePredicate=function(...e){return(0,i.default)(&quot;TSTypePredicate&quot;,...e)},t.tSTypeQuery=t.TSTypeQuery=t.tsTypeQuery=function(...e){return(0,i.default)(&quot;TSTypeQuery&quot;,...e)},t.tSTypeLiteral=t.TSTypeLiteral=t.tsTypeLiteral=function(...e){return(0,i.default)(&quot;TSTypeLiteral&quot;,...e)},t.tSArrayType=t.TSArrayType=t.tsArrayType=function(...e){return(0,i.default)(&quot;TSArrayType&quot;,...e)},t.tSTupleType=t.TSTupleType=t.tsTupleType=function(...e){return(0,i.default)(&quot;TSTupleType&quot;,...e)},t.tSOptionalType=t.TSOptionalType=t.tsOptionalType=function(...e){return(0,i.default)(&quot;TSOptionalType&quot;,...e)},t.tSRestType=t.TSRestType=t.tsRestType=function(...e){return(0,i.default)(&quot;TSRestType&quot;,...e)},t.tSNamedTupleMember=t.TSNamedTupleMember=t.tsNamedTupleMember=function(...e){return(0,i.default)(&quot;TSNamedTupleMember&quot;,...e)},t.tSUnionType=t.TSUnionType=t.tsUnionType=function(...e){return(0,i.default)(&quot;TSUnionType&quot;,...e)},t.tSIntersectionType=t.TSIntersectionType=t.tsIntersectionType=function(...e){return(0,i.default)(&quot;TSIntersectionType&quot;,...e)},t.tSConditionalType=t.TSConditionalType=t.tsConditionalType=function(...e){return(0,i.default)(&quot;TSConditionalType&quot;,...e)},t.tSInferType=t.TSInferType=t.tsInferType=function(...e){return(0,i.default)(&quot;TSInferType&quot;,...e)},t.tSParenthesizedType=t.TSParenthesizedType=t.tsParenthesizedType=function(...e){return(0,i.default)(&quot;TSParenthesizedType&quot;,...e)},t.tSTypeOperator=t.TSTypeOperator=t.tsTypeOperator=function(...e){return(0,i.default)(&quot;TSTypeOperator&quot;,...e)},t.tSIndexedAccessType=t.TSIndexedAccessType=t.tsIndexedAccessType=function(...e){return(0,i.default)(&quot;TSIndexedAccessType&quot;,...e)},t.tSMappedType=t.TSMappedType=t.tsMappedType=function(...e){return(0,i.default)(&quot;TSMappedType&quot;,...e)},t.tSLiteralType=t.TSLiteralType=t.tsLiteralType=function(...e){return(0,i.default)(&quot;TSLiteralType&quot;,...e)},t.tSExpressionWithTypeArguments=t.TSExpressionWithTypeArguments=t.tsExpressionWithTypeArguments=function(...e){return(0,i.default)(&quot;TSExpressionWithTypeArguments&quot;,...e)},t.tSInterfaceDeclaration=t.TSInterfaceDeclaration=t.tsInterfaceDeclaration=function(...e){return(0,i.default)(&quot;TSInterfaceDeclaration&quot;,...e)},t.tSInterfaceBody=t.TSInterfaceBody=t.tsInterfaceBody=function(...e){return(0,i.default)(&quot;TSInterfaceBody&quot;,...e)},t.tSTypeAliasDeclaration=t.TSTypeAliasDeclaration=t.tsTypeAliasDeclaration=function(...e){return(0,i.default)(&quot;TSTypeAliasDeclaration&quot;,...e)},t.tSAsExpression=t.TSAsExpression=t.tsAsExpression=function(...e){return(0,i.default)(&quot;TSAsExpression&quot;,...e)},t.tSTypeAssertion=t.TSTypeAssertion=t.tsTypeAssertion=function(...e){return(0,i.default)(&quot;TSTypeAssertion&quot;,...e)},t.tSEnumDeclaration=t.TSEnumDeclaration=t.tsEnumDeclaration=function(...e){return(0,i.default)(&quot;TSEnumDeclaration&quot;,...e)},t.tSEnumMember=t.TSEnumMember=t.tsEnumMember=function(...e){return(0,i.default)(&quot;TSEnumMember&quot;,...e)},t.tSModuleDeclaration=t.TSModuleDeclaration=t.tsModuleDeclaration=function(...e){return(0,i.default)(&quot;TSModuleDeclaration&quot;,...e)},t.tSModuleBlock=t.TSModuleBlock=t.tsModuleBlock=function(...e){return(0,i.default)(&quot;TSModuleBlock&quot;,...e)},t.tSImportType=t.TSImportType=t.tsImportType=function(...e){return(0,i.default)(&quot;TSImportType&quot;,...e)},t.tSImportEqualsDeclaration=t.TSImportEqualsDeclaration=t.tsImportEqualsDeclaration=function(...e){return(0,i.default)(&quot;TSImportEqualsDeclaration&quot;,...e)},t.tSExternalModuleReference=t.TSExternalModuleReference=t.tsExternalModuleReference=function(...e){return(0,i.default)(&quot;TSExternalModuleReference&quot;,...e)},t.tSNonNullExpression=t.TSNonNullExpression=t.tsNonNullExpression=function(...e){return(0,i.default)(&quot;TSNonNullExpression&quot;,...e)},t.tSExportAssignment=t.TSExportAssignment=t.tsExportAssignment=function(...e){return(0,i.default)(&quot;TSExportAssignment&quot;,...e)},t.tSNamespaceExportDeclaration=t.TSNamespaceExportDeclaration=t.tsNamespaceExportDeclaration=function(...e){return(0,i.default)(&quot;TSNamespaceExportDeclaration&quot;,...e)},t.tSTypeAnnotation=t.TSTypeAnnotation=t.tsTypeAnnotation=function(...e){return(0,i.default)(&quot;TSTypeAnnotation&quot;,...e)},t.tSTypeParameterInstantiation=t.TSTypeParameterInstantiation=t.tsTypeParameterInstantiation=function(...e){return(0,i.default)(&quot;TSTypeParameterInstantiation&quot;,...e)},t.tSTypeParameterDeclaration=t.TSTypeParameterDeclaration=t.tsTypeParameterDeclaration=function(...e){return(0,i.default)(&quot;TSTypeParameterDeclaration&quot;,...e)},t.tSTypeParameter=t.TSTypeParameter=t.tsTypeParameter=function(...e){return(0,i.default)(&quot;TSTypeParameter&quot;,...e)},t.numberLiteral=t.NumberLiteral=function(...e){return console.trace(&quot;The node type NumberLiteral has been renamed to NumericLiteral&quot;),(0,i.default)(&quot;NumberLiteral&quot;,...e)},t.regexLiteral=t.RegexLiteral=function(...e){return console.trace(&quot;The node type RegexLiteral has been renamed to RegExpLiteral&quot;),(0,i.default)(&quot;RegexLiteral&quot;,...e)},t.restProperty=t.RestProperty=function(...e){return console.trace(&quot;The node type RestProperty has been renamed to RestElement&quot;),(0,i.default)(&quot;RestProperty&quot;,...e)},t.spreadProperty=t.SpreadProperty=function(...e){return console.trace(&quot;The node type SpreadProperty has been renamed to SpreadElement&quot;),(0,i.default)(&quot;SpreadProperty&quot;,...e)};var n,i=(n=r(1739))&amp;&amp;n.__esModule?n:{default:n}},4986:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e){const t=[];for(let r=0;r&lt;e.children.length;r++){let n=e.children[r];(0,i.isJSXText)(n)?(0,s.default)(n,t):((0,i.isJSXExpressionContainer)(n)&amp;&amp;(n=n.expression),(0,i.isJSXEmptyExpression)(n)||t.push(n))}return t};var n,i=r(8037),s=(n=r(586))&amp;&amp;n.__esModule?n:{default:n}},7329:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e){const t=e.map((e=&gt;e.typeAnnotations)),r=(0,s.default)(t);return 1===r.length?r[0]:(0,i.tsUnionType)(r)};var n,i=r(3894),s=(n=r(2493))&amp;&amp;n.__esModule?n:{default:n}},5509:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e){return(0,i.default)(e,!1)};var n,i=(n=r(539))&amp;&amp;n.__esModule?n:{default:n}},2107:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e){return(0,i.default)(e)};var n,i=(n=r(539))&amp;&amp;n.__esModule?n:{default:n}},2634:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e){return(0,i.default)(e,!0,!0)};var n,i=(n=r(539))&amp;&amp;n.__esModule?n:{default:n}},539:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=o;var n=r(9829);const i=Function.call.bind(Object.prototype.hasOwnProperty);function s(e,t,r){return e&amp;&amp;&quot;string&quot;==typeof e.type?o(e,t,r):e}function a(e,t,r){return Array.isArray(e)?e.map((e=&gt;s(e,t,r))):s(e,t,r)}function o(e,t=!0,r=!1){if(!e)return e;const{type:s}=e,o={type:s};if(&quot;Identifier&quot;===s)o.name=e.name,i(e,&quot;optional&quot;)&amp;&amp;&quot;boolean&quot;==typeof e.optional&amp;&amp;(o.optional=e.optional),i(e,&quot;typeAnnotation&quot;)&amp;&amp;(o.typeAnnotation=t?a(e.typeAnnotation,!0,r):e.typeAnnotation);else{if(!i(n.NODE_FIELDS,s))throw new Error(`Unknown node type: &quot;${s}&quot;`);for(const p of Object.keys(n.NODE_FIELDS[s]))i(e,p)&amp;&amp;(o[p]=t?&quot;File&quot;===s&amp;&amp;&quot;comments&quot;===p?l(e.comments,t,r):a(e[p],!0,r):e[p])}return i(e,&quot;loc&quot;)&amp;&amp;(o.loc=r?null:e.loc),i(e,&quot;leadingComments&quot;)&amp;&amp;(o.leadingComments=l(e.leadingComments,t,r)),i(e,&quot;innerComments&quot;)&amp;&amp;(o.innerComments=l(e.innerComments,t,r)),i(e,&quot;trailingComments&quot;)&amp;&amp;(o.trailingComments=l(e.trailingComments,t,r)),i(e,&quot;extra&quot;)&amp;&amp;(o.extra=Object.assign({},e.extra)),o}function l(e,t,r){return t&amp;&amp;r?function(e){return e.map((({type:e,value:t})=&gt;({type:e,value:t,loc:null})))}(e):e}},1225:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e){return(0,i.default)(e,!1,!0)};var n,i=(n=r(539))&amp;&amp;n.__esModule?n:{default:n}},8184:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e,t,r,n){return(0,i.default)(e,t,[{type:n?&quot;CommentLine&quot;:&quot;CommentBlock&quot;,value:r}])};var n,i=(n=r(2243))&amp;&amp;n.__esModule?n:{default:n}},2243:(e,t)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e,t,r){if(!r||!e)return e;const n=`${t}Comments`;return e[n]?e[n]=&quot;leading&quot;===t?r.concat(e[n]):e[n].concat(r):e[n]=r,e}},440:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e,t){(0,i.default)(&quot;innerComments&quot;,e,t)};var n,i=(n=r(3450))&amp;&amp;n.__esModule?n:{default:n}},9622:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e,t){(0,i.default)(&quot;leadingComments&quot;,e,t)};var n,i=(n=r(3450))&amp;&amp;n.__esModule?n:{default:n}},9868:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e,t){(0,i.default)(&quot;trailingComments&quot;,e,t)};var n,i=(n=r(3450))&amp;&amp;n.__esModule?n:{default:n}},6168:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e,t){return(0,n.default)(e,t),(0,i.default)(e,t),(0,s.default)(e,t),e};var n=a(r(9868)),i=a(r(9622)),s=a(r(440));function a(e){return e&amp;&amp;e.__esModule?e:{default:e}}},4670:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e){return n.COMMENT_KEYS.forEach((t=&gt;{e[t]=null})),e};var n=r(9660)},1798:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.TSBASETYPE_TYPES=t.TSTYPE_TYPES=t.TSTYPEELEMENT_TYPES=t.PRIVATE_TYPES=t.JSX_TYPES=t.ENUMMEMBER_TYPES=t.ENUMBODY_TYPES=t.FLOWPREDICATE_TYPES=t.FLOWDECLARATION_TYPES=t.FLOWBASEANNOTATION_TYPES=t.FLOWTYPE_TYPES=t.FLOW_TYPES=t.MODULESPECIFIER_TYPES=t.EXPORTDECLARATION_TYPES=t.MODULEDECLARATION_TYPES=t.CLASS_TYPES=t.PATTERN_TYPES=t.UNARYLIKE_TYPES=t.PROPERTY_TYPES=t.OBJECTMEMBER_TYPES=t.METHOD_TYPES=t.USERWHITESPACABLE_TYPES=t.IMMUTABLE_TYPES=t.LITERAL_TYPES=t.TSENTITYNAME_TYPES=t.LVAL_TYPES=t.PATTERNLIKE_TYPES=t.DECLARATION_TYPES=t.PUREISH_TYPES=t.FUNCTIONPARENT_TYPES=t.FUNCTION_TYPES=t.FORXSTATEMENT_TYPES=t.FOR_TYPES=t.EXPRESSIONWRAPPER_TYPES=t.WHILE_TYPES=t.LOOP_TYPES=t.CONDITIONAL_TYPES=t.COMPLETIONSTATEMENT_TYPES=t.TERMINATORLESS_TYPES=t.STATEMENT_TYPES=t.BLOCK_TYPES=t.BLOCKPARENT_TYPES=t.SCOPABLE_TYPES=t.BINARY_TYPES=t.EXPRESSION_TYPES=void 0;var n=r(9829);const i=n.FLIPPED_ALIAS_KEYS.Expression;t.EXPRESSION_TYPES=i;const s=n.FLIPPED_ALIAS_KEYS.Binary;t.BINARY_TYPES=s;const a=n.FLIPPED_ALIAS_KEYS.Scopable;t.SCOPABLE_TYPES=a;const o=n.FLIPPED_ALIAS_KEYS.BlockParent;t.BLOCKPARENT_TYPES=o;const l=n.FLIPPED_ALIAS_KEYS.Block;t.BLOCK_TYPES=l;const p=n.FLIPPED_ALIAS_KEYS.Statement;t.STATEMENT_TYPES=p;const c=n.FLIPPED_ALIAS_KEYS.Terminatorless;t.TERMINATORLESS_TYPES=c;const u=n.FLIPPED_ALIAS_KEYS.CompletionStatement;t.COMPLETIONSTATEMENT_TYPES=u;const d=n.FLIPPED_ALIAS_KEYS.Conditional;t.CONDITIONAL_TYPES=d;const h=n.FLIPPED_ALIAS_KEYS.Loop;t.LOOP_TYPES=h;const f=n.FLIPPED_ALIAS_KEYS.While;t.WHILE_TYPES=f;const m=n.FLIPPED_ALIAS_KEYS.ExpressionWrapper;t.EXPRESSIONWRAPPER_TYPES=m;const y=n.FLIPPED_ALIAS_KEYS.For;t.FOR_TYPES=y;const T=n.FLIPPED_ALIAS_KEYS.ForXStatement;t.FORXSTATEMENT_TYPES=T;const b=n.FLIPPED_ALIAS_KEYS.Function;t.FUNCTION_TYPES=b;const g=n.FLIPPED_ALIAS_KEYS.FunctionParent;t.FUNCTIONPARENT_TYPES=g;const S=n.FLIPPED_ALIAS_KEYS.Pureish;t.PUREISH_TYPES=S;const x=n.FLIPPED_ALIAS_KEYS.Declaration;t.DECLARATION_TYPES=x;const E=n.FLIPPED_ALIAS_KEYS.PatternLike;t.PATTERNLIKE_TYPES=E;const P=n.FLIPPED_ALIAS_KEYS.LVal;t.LVAL_TYPES=P;const v=n.FLIPPED_ALIAS_KEYS.TSEntityName;t.TSENTITYNAME_TYPES=v;const A=n.FLIPPED_ALIAS_KEYS.Literal;t.LITERAL_TYPES=A;const w=n.FLIPPED_ALIAS_KEYS.Immutable;t.IMMUTABLE_TYPES=w;const O=n.FLIPPED_ALIAS_KEYS.UserWhitespacable;t.USERWHITESPACABLE_TYPES=O;const I=n.FLIPPED_ALIAS_KEYS.Method;t.METHOD_TYPES=I;const N=n.FLIPPED_ALIAS_KEYS.ObjectMember;t.OBJECTMEMBER_TYPES=N;const C=n.FLIPPED_ALIAS_KEYS.Property;t.PROPERTY_TYPES=C;const k=n.FLIPPED_ALIAS_KEYS.UnaryLike;t.UNARYLIKE_TYPES=k;const D=n.FLIPPED_ALIAS_KEYS.Pattern;t.PATTERN_TYPES=D;const _=n.FLIPPED_ALIAS_KEYS.Class;t.CLASS_TYPES=_;const L=n.FLIPPED_ALIAS_KEYS.ModuleDeclaration;t.MODULEDECLARATION_TYPES=L;const M=n.FLIPPED_ALIAS_KEYS.ExportDeclaration;t.EXPORTDECLARATION_TYPES=M;const j=n.FLIPPED_ALIAS_KEYS.ModuleSpecifier;t.MODULESPECIFIER_TYPES=j;const F=n.FLIPPED_ALIAS_KEYS.Flow;t.FLOW_TYPES=F;const B=n.FLIPPED_ALIAS_KEYS.FlowType;t.FLOWTYPE_TYPES=B;const R=n.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;t.FLOWBASEANNOTATION_TYPES=R;const U=n.FLIPPED_ALIAS_KEYS.FlowDeclaration;t.FLOWDECLARATION_TYPES=U;const V=n.FLIPPED_ALIAS_KEYS.FlowPredicate;t.FLOWPREDICATE_TYPES=V;const K=n.FLIPPED_ALIAS_KEYS.EnumBody;t.ENUMBODY_TYPES=K;const q=n.FLIPPED_ALIAS_KEYS.EnumMember;t.ENUMMEMBER_TYPES=q;const Y=n.FLIPPED_ALIAS_KEYS.JSX;t.JSX_TYPES=Y;const W=n.FLIPPED_ALIAS_KEYS.Private;t.PRIVATE_TYPES=W;const X=n.FLIPPED_ALIAS_KEYS.TSTypeElement;t.TSTYPEELEMENT_TYPES=X;const J=n.FLIPPED_ALIAS_KEYS.TSType;t.TSTYPE_TYPES=J;const H=n.FLIPPED_ALIAS_KEYS.TSBaseType;t.TSBASETYPE_TYPES=H},9660:(e,t)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.NOT_LOCAL_BINDING=t.BLOCK_SCOPED_SYMBOL=t.INHERIT_KEYS=t.UNARY_OPERATORS=t.STRING_UNARY_OPERATORS=t.NUMBER_UNARY_OPERATORS=t.BOOLEAN_UNARY_OPERATORS=t.ASSIGNMENT_OPERATORS=t.BINARY_OPERATORS=t.NUMBER_BINARY_OPERATORS=t.BOOLEAN_BINARY_OPERATORS=t.COMPARISON_BINARY_OPERATORS=t.EQUALITY_BINARY_OPERATORS=t.BOOLEAN_NUMBER_BINARY_OPERATORS=t.UPDATE_OPERATORS=t.LOGICAL_OPERATORS=t.COMMENT_KEYS=t.FOR_INIT_KEYS=t.FLATTENABLE_KEYS=t.STATEMENT_OR_BLOCK_KEYS=void 0,t.STATEMENT_OR_BLOCK_KEYS=[&quot;consequent&quot;,&quot;body&quot;,&quot;alternate&quot;],t.FLATTENABLE_KEYS=[&quot;body&quot;,&quot;expressions&quot;],t.FOR_INIT_KEYS=[&quot;left&quot;,&quot;init&quot;],t.COMMENT_KEYS=[&quot;leadingComments&quot;,&quot;trailingComments&quot;,&quot;innerComments&quot;];const r=[&quot;||&quot;,&quot;&amp;&amp;&quot;,&quot;??&quot;];t.LOGICAL_OPERATORS=r,t.UPDATE_OPERATORS=[&quot;++&quot;,&quot;--&quot;];const n=[&quot;&gt;&quot;,&quot;&lt;&quot;,&quot;&gt;=&quot;,&quot;&lt;=&quot;];t.BOOLEAN_NUMBER_BINARY_OPERATORS=n;const i=[&quot;==&quot;,&quot;===&quot;,&quot;!=&quot;,&quot;!==&quot;];t.EQUALITY_BINARY_OPERATORS=i;const s=[...i,&quot;in&quot;,&quot;instanceof&quot;];t.COMPARISON_BINARY_OPERATORS=s;const a=[...s,...n];t.BOOLEAN_BINARY_OPERATORS=a;const o=[&quot;-&quot;,&quot;/&quot;,&quot;%&quot;,&quot;*&quot;,&quot;**&quot;,&quot;&amp;&quot;,&quot;|&quot;,&quot;&gt;&gt;&quot;,&quot;&gt;&gt;&gt;&quot;,&quot;&lt;&lt;&quot;,&quot;^&quot;];t.NUMBER_BINARY_OPERATORS=o;const l=[&quot;+&quot;,...o,...a];t.BINARY_OPERATORS=l;const p=[&quot;=&quot;,&quot;+=&quot;,...o.map((e=&gt;e+&quot;=&quot;)),...r.map((e=&gt;e+&quot;=&quot;))];t.ASSIGNMENT_OPERATORS=p;const c=[&quot;delete&quot;,&quot;!&quot;];t.BOOLEAN_UNARY_OPERATORS=c;const u=[&quot;+&quot;,&quot;-&quot;,&quot;~&quot;];t.NUMBER_UNARY_OPERATORS=u;const d=[&quot;typeof&quot;];t.STRING_UNARY_OPERATORS=d;const h=[&quot;void&quot;,&quot;throw&quot;,...c,...u,...d];t.UNARY_OPERATORS=h,t.INHERIT_KEYS={optional:[&quot;typeAnnotation&quot;,&quot;typeParameters&quot;,&quot;returnType&quot;],force:[&quot;start&quot;,&quot;loc&quot;,&quot;end&quot;]};const f=Symbol.for(&quot;var used to be block scoped&quot;);t.BLOCK_SCOPED_SYMBOL=f;const m=Symbol.for(&quot;should not be considered a local binding&quot;);t.NOT_LOCAL_BINDING=m},6450:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e,t=&quot;body&quot;){return e[t]=(0,i.default)(e[t],e)};var n,i=(n=r(130))&amp;&amp;n.__esModule?n:{default:n}},5366:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function e(t,r,o){const l=[];let p=!0;for(const c of t)if((0,i.isEmptyStatement)(c)||(p=!1),(0,i.isExpression)(c))l.push(c);else if((0,i.isExpressionStatement)(c))l.push(c.expression);else if((0,i.isVariableDeclaration)(c)){if(&quot;var&quot;!==c.kind)return;for(const e of c.declarations){const t=(0,n.default)(e);for(const e of Object.keys(t))o.push({kind:c.kind,id:(0,a.default)(t[e])});e.init&amp;&amp;l.push((0,s.assignmentExpression)(&quot;=&quot;,e.id,e.init))}p=!0}else if((0,i.isIfStatement)(c)){const t=c.consequent?e([c.consequent],r,o):r.buildUndefinedNode(),n=c.alternate?e([c.alternate],r,o):r.buildUndefinedNode();if(!t||!n)return;l.push((0,s.conditionalExpression)(c.test,t,n))}else if((0,i.isBlockStatement)(c)){const t=e(c.body,r,o);if(!t)return;l.push(t)}else{if(!(0,i.isEmptyStatement)(c))return;0===t.indexOf(c)&amp;&amp;(p=!0)}return p&amp;&amp;l.push(r.buildUndefinedNode()),1===l.length?l[0]:(0,s.sequenceExpression)(l)};var n=o(r(3407)),i=r(8037),s=r(3894),a=o(r(539));function o(e){return e&amp;&amp;e.__esModule?e:{default:e}}},8681:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e){return&quot;eval&quot;!==(e=(0,i.default)(e))&amp;&amp;&quot;arguments&quot;!==e||(e=&quot;_&quot;+e),e};var n,i=(n=r(5450))&amp;&amp;n.__esModule?n:{default:n}},130:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e,t){if((0,n.isBlockStatement)(e))return e;let r=[];return(0,n.isEmptyStatement)(e)?r=[]:((0,n.isStatement)(e)||(e=(0,n.isFunction)(t)?(0,i.returnStatement)(e):(0,i.expressionStatement)(e)),r=[e]),(0,i.blockStatement)(r)};var n=r(8037),i=r(3894)},940:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e,t=e.key||e.property){return!e.computed&amp;&amp;(0,n.isIdentifier)(t)&amp;&amp;(t=(0,i.stringLiteral)(t.name)),t};var n=r(8037),i=r(3894)},2858:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e){if((0,n.isExpressionStatement)(e)&amp;&amp;(e=e.expression),(0,n.isExpression)(e))return e;if((0,n.isClass)(e)?e.type=&quot;ClassExpression&quot;:(0,n.isFunction)(e)&amp;&amp;(e.type=&quot;FunctionExpression&quot;),!(0,n.isExpression)(e))throw new Error(`cannot turn ${e.type} to an expression`);return e};var n=r(8037)},5450:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e){return e=(e=(e=(e+=&quot;&quot;).replace(/[^a-zA-Z0-9$_]/g,&quot;-&quot;)).replace(/^[-0-9]+/,&quot;&quot;)).replace(/[-</span><span class="s5">\s</span><span class="s3">]+(.)?/g,(function(e,t){return t?t.toUpperCase():&quot;&quot;})),(0,i.default)(e)||(e=`_${e}`),e||&quot;_&quot;};var n,i=(n=r(380))&amp;&amp;n.__esModule?n:{default:n}},8100:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=o;var n=r(8037),i=a(r(539)),s=a(r(4888));function a(e){return e&amp;&amp;e.__esModule?e:{default:e}}function o(e,t=e.key){let r;return&quot;method&quot;===e.kind?o.increment()+&quot;&quot;:(r=(0,n.isIdentifier)(t)?t.name:(0,n.isStringLiteral)(t)?JSON.stringify(t.value):JSON.stringify((0,s.default)((0,i.default)(t))),e.computed&amp;&amp;(r=`[${r}]`),e.static&amp;&amp;(r=`static:${r}`),r)}o.uid=0,o.increment=function(){return o.uid&gt;=Number.MAX_SAFE_INTEGER?o.uid=0:o.uid++}},4914:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e,t){if(!(null==e?void 0:e.length))return;const r=[],n=(0,i.default)(e,t,r);if(n){for(const e of r)t.push(e);return n}};var n,i=(n=r(5366))&amp;&amp;n.__esModule?n:{default:n}},2469:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function(e,t){if((0,n.isStatement)(e))return e;let r,s=!1;if((0,n.isClass)(e))s=!0,r=&quot;ClassDeclaration&quot;;else if((0,n.isFunction)(e))s=!0,r=&quot;FunctionDeclaration&quot;;else if((0,n.isAssignmentExpression)(e))return(0,i.expressionStatement)(e);if(s&amp;&amp;!e.id&amp;&amp;(r=!1),!r){if(t)return!1;throw new Error(`cannot turn ${e.type} to a statement`)}return e.type=r,e};var n=r(8037),i=r(3894)},8626:(e,t,r)=&gt;{&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0}),t.default=function e(t){if(void 0===t)return(0,a.identifier)(&quot;undefined&quot;);if(!0===t||!1===t)return(0,a.booleanLiteral)(t);if(null===t)return(0,a.nullLiteral)();if(&quot;string&quot;==typeof t)return(0,a.stringLiteral)(t);if(&quot;number&quot;==typeof t){let e;if(Number.isFinite(t))e=(0,a.numericLiteral)(Math.abs(t));else{let r;r=Number.isNaN(t)?(0,a.numericLiteral)(0):(0,a.numericLiteral)(1),e=(0,a.binaryExpression)(&quot;/&quot;,r,(0,a.numericLiteral)(0))}return(t&lt;0||Object.is(t,-0))&amp;&amp;(e=(0,a.unaryExpression)(&quot;-&quot;,e)),e}if((0,i.default)(t)){const e=t.source,r=t.toString().match(/</span><span class="s5">\/</span><span class="s3">([a-z]+|)$/)[1];return(0,a.regExpLiteral)(e,r)}if(Array.isArray(t))return(0,a.arrayExpression)(t.map(e));if((0,n.default)(t)){const r=[];for(const n of Object.keys(t)){let i;i=(0,s.default)(n)?(0,a.identifier)(n):(0,a.stringLiteral)(n),r.push((0,a.objectProperty)(i,e(t[n])))}return(0,a.objectExpression)(r)}throw new Error(&quot;don'</span><span class="s0">t know how to turn </span><span class="s1">this </span><span class="s0">value into a node</span><span class="s3">&quot;)};var n=o(r(4994)),i=o(r(956)),s=o(r(380)),a=r(3894);function o(e){return e&amp;&amp;e.__esModule?e:{default:e}}},4613:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;var n=r(397);Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.classMethodOrDeclareMethodCommon=t.classMethodOrPropertyCommon=t.patternLikeCommon=t.functionDeclarationCommon=t.functionTypeAnnotationCommon=t.functionCommon=void 0;var i=c(r(6593)),s=c(r(380)),a=r(7075),o=r(9660),l=function(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;</span><span class="s0">object</span><span class="s3">&quot;!=typeof e&amp;&amp;&quot;</span><span class="s1">function</span><span class="s3">&quot;!=typeof e)return{default:e};var t=p();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var s=n?Object.getOwnPropertyDescriptor(e,i):null;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}return r.default=e,t&amp;&amp;t.set(e,r),r}(r(6343));function p(){if(&quot;</span><span class="s1">function</span><span class="s3">&quot;!=typeof WeakMap)return null;var e=new WeakMap;return p=function(){return e},e}function c(e){return e&amp;&amp;e.__esModule?e:{default:e}}(0,l.default)(&quot;</span><span class="s0">ArrayExpression</span><span class="s3">&quot;,{fields:{elements:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeOrValueType)(&quot;</span><span class="s1">null</span><span class="s3">&quot;,&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">SpreadElement</span><span class="s3">&quot;))),default:n.env.BABEL_TYPES_8_BREAKING?void 0:[]}},visitor:[&quot;</span><span class="s0">elements</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">AssignmentExpression</span><span class="s3">&quot;,{fields:{operator:{validate:function(){if(!n.env.BABEL_TYPES_8_BREAKING)return(0,l.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;);const e=(0,l.assertOneOf)(...o.ASSIGNMENT_OPERATORS),t=(0,l.assertOneOf)(&quot;</span><span class="s0">=</span><span class="s3">&quot;);return function(r,n,s){((0,i.default)(&quot;</span><span class="s0">Pattern</span><span class="s3">&quot;,r.left)?t:e)(r,n,s)}}()},left:{validate:n.env.BABEL_TYPES_8_BREAKING?(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">MemberExpression</span><span class="s3">&quot;,&quot;</span><span class="s0">ArrayPattern</span><span class="s3">&quot;,&quot;</span><span class="s0">ObjectPattern</span><span class="s3">&quot;):(0,l.assertNodeType)(&quot;</span><span class="s0">LVal</span><span class="s3">&quot;)},right:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}},builder:[&quot;</span><span class="s0">operator</span><span class="s3">&quot;,&quot;</span><span class="s0">left</span><span class="s3">&quot;,&quot;</span><span class="s0">right</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">left</span><span class="s3">&quot;,&quot;</span><span class="s0">right</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">BinaryExpression</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">operator</span><span class="s3">&quot;,&quot;</span><span class="s0">left</span><span class="s3">&quot;,&quot;</span><span class="s0">right</span><span class="s3">&quot;],fields:{operator:{validate:(0,l.assertOneOf)(...o.BINARY_OPERATORS)},left:{validate:function(){const e=(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;),t=(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">PrivateName</span><span class="s3">&quot;),r=function(r,n,i){(&quot;</span><span class="s1">in</span><span class="s3">&quot;===r.operator?t:e)(r,n,i)};return r.oneOfNodeTypes=[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">PrivateName</span><span class="s3">&quot;],r}()},right:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}},visitor:[&quot;</span><span class="s0">left</span><span class="s3">&quot;,&quot;</span><span class="s0">right</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Binary</span><span class="s3">&quot;,&quot;</span><span class="s0">Expression</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">InterpreterDirective</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">value</span><span class="s3">&quot;],fields:{value:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">Directive</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">value</span><span class="s3">&quot;],fields:{value:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">DirectiveLiteral</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">DirectiveLiteral</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">value</span><span class="s3">&quot;],fields:{value:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">body</span><span class="s3">&quot;,&quot;</span><span class="s0">directives</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">directives</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],fields:{directives:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Directive</span><span class="s3">&quot;))),default:[]},body:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Statement</span><span class="s3">&quot;)))}},aliases:[&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;,&quot;</span><span class="s0">Block</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">BreakStatement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">label</span><span class="s3">&quot;],fields:{label:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),optional:!0}},aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Terminatorless</span><span class="s3">&quot;,&quot;</span><span class="s0">CompletionStatement</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">CallExpression</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">callee</span><span class="s3">&quot;,&quot;</span><span class="s0">arguments</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">typeArguments</span><span class="s3">&quot;],builder:[&quot;</span><span class="s0">callee</span><span class="s3">&quot;,&quot;</span><span class="s0">arguments</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],fields:Object.assign({callee:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">V8IntrinsicIdentifier</span><span class="s3">&quot;)},arguments:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">SpreadElement</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXNamespacedName</span><span class="s3">&quot;,&quot;</span><span class="s0">ArgumentPlaceholder</span><span class="s3">&quot;)))}},n.env.BABEL_TYPES_8_BREAKING?{}:{optional:{validate:(0,l.assertOneOf)(!0,!1),optional:!0}},{typeArguments:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">TypeParameterInstantiation</span><span class="s3">&quot;),optional:!0},typeParameters:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">TSTypeParameterInstantiation</span><span class="s3">&quot;),optional:!0}})}),(0,l.default)(&quot;</span><span class="s0">CatchClause</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">param</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],fields:{param:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">ArrayPattern</span><span class="s3">&quot;,&quot;</span><span class="s0">ObjectPattern</span><span class="s3">&quot;),optional:!0},body:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;)}},aliases:[&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">ConditionalExpression</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">test</span><span class="s3">&quot;,&quot;</span><span class="s0">consequent</span><span class="s3">&quot;,&quot;</span><span class="s0">alternate</span><span class="s3">&quot;],fields:{test:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},consequent:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},alternate:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}},aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Conditional</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">ContinueStatement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">label</span><span class="s3">&quot;],fields:{label:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),optional:!0}},aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Terminatorless</span><span class="s3">&quot;,&quot;</span><span class="s0">CompletionStatement</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">DebuggerStatement</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">DoWhileStatement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">test</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],fields:{test:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},body:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Statement</span><span class="s3">&quot;)}},aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;,&quot;</span><span class="s0">Loop</span><span class="s3">&quot;,&quot;</span><span class="s0">While</span><span class="s3">&quot;,&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">EmptyStatement</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">ExpressionStatement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">expression</span><span class="s3">&quot;],fields:{expression:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}},aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">ExpressionWrapper</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">File</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">program</span><span class="s3">&quot;,&quot;</span><span class="s0">comments</span><span class="s3">&quot;,&quot;</span><span class="s0">tokens</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">program</span><span class="s3">&quot;],fields:{program:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Program</span><span class="s3">&quot;)},comments:{validate:n.env.BABEL_TYPES_8_BREAKING?(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">CommentBlock</span><span class="s3">&quot;,&quot;</span><span class="s0">CommentLine</span><span class="s3">&quot;)):Object.assign((()=&gt;{}),{each:{oneOfNodeTypes:[&quot;</span><span class="s0">CommentBlock</span><span class="s3">&quot;,&quot;</span><span class="s0">CommentLine</span><span class="s3">&quot;]}}),optional:!0},tokens:{validate:(0,l.assertEach)(Object.assign((()=&gt;{}),{type:&quot;</span><span class="s0">any</span><span class="s3">&quot;})),optional:!0}}}),(0,l.default)(&quot;</span><span class="s0">ForInStatement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">left</span><span class="s3">&quot;,&quot;</span><span class="s0">right</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">For</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;,&quot;</span><span class="s0">Loop</span><span class="s3">&quot;,&quot;</span><span class="s0">ForXStatement</span><span class="s3">&quot;],fields:{left:{validate:n.env.BABEL_TYPES_8_BREAKING?(0,l.assertNodeType)(&quot;</span><span class="s0">VariableDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">MemberExpression</span><span class="s3">&quot;,&quot;</span><span class="s0">ArrayPattern</span><span class="s3">&quot;,&quot;</span><span class="s0">ObjectPattern</span><span class="s3">&quot;):(0,l.assertNodeType)(&quot;</span><span class="s0">VariableDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">LVal</span><span class="s3">&quot;)},right:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},body:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Statement</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">ForStatement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">init</span><span class="s3">&quot;,&quot;</span><span class="s0">test</span><span class="s3">&quot;,&quot;</span><span class="s0">update</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">For</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;,&quot;</span><span class="s0">Loop</span><span class="s3">&quot;],fields:{init:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">VariableDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Expression</span><span class="s3">&quot;),optional:!0},test:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;),optional:!0},update:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;),optional:!0},body:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Statement</span><span class="s3">&quot;)}}});const u={params:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">Pattern</span><span class="s3">&quot;,&quot;</span><span class="s0">RestElement</span><span class="s3">&quot;,&quot;</span><span class="s0">TSParameterProperty</span><span class="s3">&quot;)))},generator:{default:!1},async:{default:!1}};t.functionCommon=u;const d={returnType:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">TypeAnnotation</span><span class="s3">&quot;,&quot;</span><span class="s0">TSTypeAnnotation</span><span class="s3">&quot;,&quot;</span><span class="s0">Noop</span><span class="s3">&quot;),optional:!0},typeParameters:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">TypeParameterDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">TSTypeParameterDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Noop</span><span class="s3">&quot;),optional:!0}};t.functionTypeAnnotationCommon=d;const h=Object.assign({},u,{declare:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),optional:!0},id:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),optional:!0}});t.functionDeclarationCommon=h,(0,l.default)(&quot;</span><span class="s0">FunctionDeclaration</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">params</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;,&quot;</span><span class="s0">generator</span><span class="s3">&quot;,&quot;</span><span class="s0">async</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">params</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;,&quot;</span><span class="s0">returnType</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;],fields:Object.assign({},h,d,{body:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;)}}),aliases:[&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;,&quot;</span><span class="s0">Function</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;,&quot;</span><span class="s0">FunctionParent</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Pureish</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],validate:function(){if(!n.env.BABEL_TYPES_8_BREAKING)return()=&gt;{};const e=(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;);return function(t,r,n){(0,i.default)(&quot;</span><span class="s0">ExportDefaultDeclaration</span><span class="s3">&quot;,t)||e(n,&quot;</span><span class="s0">id</span><span class="s3">&quot;,n.id)}}()}),(0,l.default)(&quot;</span><span class="s0">FunctionExpression</span><span class="s3">&quot;,{inherits:&quot;</span><span class="s0">FunctionDeclaration</span><span class="s3">&quot;,aliases:[&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;,&quot;</span><span class="s0">Function</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;,&quot;</span><span class="s0">FunctionParent</span><span class="s3">&quot;,&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Pureish</span><span class="s3">&quot;],fields:Object.assign({},u,d,{id:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),optional:!0},body:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;)}})});const f={typeAnnotation:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">TypeAnnotation</span><span class="s3">&quot;,&quot;</span><span class="s0">TSTypeAnnotation</span><span class="s3">&quot;,&quot;</span><span class="s0">Noop</span><span class="s3">&quot;),optional:!0},decorators:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Decorator</span><span class="s3">&quot;)))}};t.patternLikeCommon=f,(0,l.default)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">name</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;,&quot;</span><span class="s0">decorators</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">PatternLike</span><span class="s3">&quot;,&quot;</span><span class="s0">LVal</span><span class="s3">&quot;,&quot;</span><span class="s0">TSEntityName</span><span class="s3">&quot;],fields:Object.assign({},f,{name:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;),Object.assign((function(e,t,r){if(n.env.BABEL_TYPES_8_BREAKING&amp;&amp;!(0,s.default)(r,!1))throw new TypeError(`&quot;</span><span class="s0">${r}</span><span class="s3">&quot; is not a valid identifier name`)}),{type:&quot;</span><span class="s0">string</span><span class="s3">&quot;}))},optional:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),optional:!0}}),validate(e,t,r){if(!n.env.BABEL_TYPES_8_BREAKING)return;const s=/</span><span class="s5">\.</span><span class="s3">(</span><span class="s5">\w</span><span class="s3">+)$/.exec(t);if(!s)return;const[,o]=s,l={computed:!1};if(&quot;</span><span class="s0">property</span><span class="s3">&quot;===o){if((0,i.default)(&quot;</span><span class="s0">MemberExpression</span><span class="s3">&quot;,e,l))return;if((0,i.default)(&quot;</span><span class="s0">OptionalMemberExpression</span><span class="s3">&quot;,e,l))return}else if(&quot;</span><span class="s0">key</span><span class="s3">&quot;===o){if((0,i.default)(&quot;</span><span class="s0">Property</span><span class="s3">&quot;,e,l))return;if((0,i.default)(&quot;</span><span class="s0">Method</span><span class="s3">&quot;,e,l))return}else if(&quot;</span><span class="s0">exported</span><span class="s3">&quot;===o){if((0,i.default)(&quot;</span><span class="s0">ExportSpecifier</span><span class="s3">&quot;,e))return}else if(&quot;</span><span class="s0">imported</span><span class="s3">&quot;===o){if((0,i.default)(&quot;</span><span class="s0">ImportSpecifier</span><span class="s3">&quot;,e,{imported:r}))return}else if(&quot;</span><span class="s0">meta</span><span class="s3">&quot;===o&amp;&amp;(0,i.default)(&quot;</span><span class="s0">MetaProperty</span><span class="s3">&quot;,e,{meta:r}))return;if(((0,a.isKeyword)(r.name)||(0,a.isReservedWord)(r.name))&amp;&amp;&quot;</span><span class="s1">this</span><span class="s3">&quot;!==r.name)throw new TypeError(`&quot;</span><span class="s0">${r.name}</span><span class="s3">&quot; is not a valid identifier`)}}),(0,l.default)(&quot;</span><span class="s0">IfStatement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">test</span><span class="s3">&quot;,&quot;</span><span class="s0">consequent</span><span class="s3">&quot;,&quot;</span><span class="s0">alternate</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Conditional</span><span class="s3">&quot;],fields:{test:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},consequent:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Statement</span><span class="s3">&quot;)},alternate:{optional:!0,validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Statement</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">LabeledStatement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">label</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;],fields:{label:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;)},body:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Statement</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">value</span><span class="s3">&quot;],fields:{value:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;)}},aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Pureish</span><span class="s3">&quot;,&quot;</span><span class="s0">Literal</span><span class="s3">&quot;,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">NumericLiteral</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">value</span><span class="s3">&quot;],deprecatedAlias:&quot;</span><span class="s0">NumberLiteral</span><span class="s3">&quot;,fields:{value:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">number</span><span class="s3">&quot;)}},aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Pureish</span><span class="s3">&quot;,&quot;</span><span class="s0">Literal</span><span class="s3">&quot;,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">NullLiteral</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Pureish</span><span class="s3">&quot;,&quot;</span><span class="s0">Literal</span><span class="s3">&quot;,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">BooleanLiteral</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">value</span><span class="s3">&quot;],fields:{value:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;)}},aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Pureish</span><span class="s3">&quot;,&quot;</span><span class="s0">Literal</span><span class="s3">&quot;,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">RegExpLiteral</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">pattern</span><span class="s3">&quot;,&quot;</span><span class="s0">flags</span><span class="s3">&quot;],deprecatedAlias:&quot;</span><span class="s0">RegexLiteral</span><span class="s3">&quot;,aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Pureish</span><span class="s3">&quot;,&quot;</span><span class="s0">Literal</span><span class="s3">&quot;],fields:{pattern:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;)},flags:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;),Object.assign((function(e,t,r){if(!n.env.BABEL_TYPES_8_BREAKING)return;const i=/[^gimsuy]/.exec(r);if(i)throw new TypeError(`&quot;</span><span class="s0">${i[</span><span class="s2">0</span><span class="s0">]}</span><span class="s3">&quot; is not a valid RegExp flag`)}),{type:&quot;</span><span class="s0">string</span><span class="s3">&quot;})),default:&quot;&quot;}}}),(0,l.default)(&quot;</span><span class="s0">LogicalExpression</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">operator</span><span class="s3">&quot;,&quot;</span><span class="s0">left</span><span class="s3">&quot;,&quot;</span><span class="s0">right</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">left</span><span class="s3">&quot;,&quot;</span><span class="s0">right</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Binary</span><span class="s3">&quot;,&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],fields:{operator:{validate:(0,l.assertOneOf)(...o.LOGICAL_OPERATORS)},left:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},right:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">MemberExpression</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">object</span><span class="s3">&quot;,&quot;</span><span class="s0">property</span><span class="s3">&quot;,&quot;</span><span class="s0">computed</span><span class="s3">&quot;,&quot;</span><span class="s0">optional</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">object</span><span class="s3">&quot;,&quot;</span><span class="s0">property</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">LVal</span><span class="s3">&quot;],fields:Object.assign({object:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},property:{validate:function(){const e=(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">PrivateName</span><span class="s3">&quot;),t=(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;),r=function(r,n,i){(r.computed?t:e)(r,n,i)};return r.oneOfNodeTypes=[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">PrivateName</span><span class="s3">&quot;],r}()},computed:{default:!1}},n.env.BABEL_TYPES_8_BREAKING?{}:{optional:{validate:(0,l.assertOneOf)(!0,!1),optional:!0}})}),(0,l.default)(&quot;</span><span class="s0">NewExpression</span><span class="s3">&quot;,{inherits:&quot;</span><span class="s0">CallExpression</span><span class="s3">&quot;}),(0,l.default)(&quot;</span><span class="s0">Program</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">directives</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],builder:[&quot;</span><span class="s0">body</span><span class="s3">&quot;,&quot;</span><span class="s0">directives</span><span class="s3">&quot;,&quot;</span><span class="s0">sourceType</span><span class="s3">&quot;,&quot;</span><span class="s0">interpreter</span><span class="s3">&quot;],fields:{sourceFile:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;)},sourceType:{validate:(0,l.assertOneOf)(&quot;</span><span class="s0">script</span><span class="s3">&quot;,&quot;</span><span class="s0">module</span><span class="s3">&quot;),default:&quot;</span><span class="s0">script</span><span class="s3">&quot;},interpreter:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">InterpreterDirective</span><span class="s3">&quot;),default:null,optional:!0},directives:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Directive</span><span class="s3">&quot;))),default:[]},body:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Statement</span><span class="s3">&quot;)))}},aliases:[&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;,&quot;</span><span class="s0">Block</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">ObjectExpression</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">properties</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],fields:{properties:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">ObjectMethod</span><span class="s3">&quot;,&quot;</span><span class="s0">ObjectProperty</span><span class="s3">&quot;,&quot;</span><span class="s0">SpreadElement</span><span class="s3">&quot;)))}}}),(0,l.default)(&quot;</span><span class="s0">ObjectMethod</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">kind</span><span class="s3">&quot;,&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">params</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;,&quot;</span><span class="s0">computed</span><span class="s3">&quot;,&quot;</span><span class="s0">generator</span><span class="s3">&quot;,&quot;</span><span class="s0">async</span><span class="s3">&quot;],fields:Object.assign({},u,d,{kind:Object.assign({validate:(0,l.assertOneOf)(&quot;</span><span class="s0">method</span><span class="s3">&quot;,&quot;</span><span class="s0">get</span><span class="s3">&quot;,&quot;</span><span class="s0">set</span><span class="s3">&quot;)},n.env.BABEL_TYPES_8_BREAKING?{}:{default:&quot;</span><span class="s0">method</span><span class="s3">&quot;}),computed:{default:!1},key:{validate:function(){const e=(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;,&quot;</span><span class="s0">NumericLiteral</span><span class="s3">&quot;),t=(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;),r=function(r,n,i){(r.computed?t:e)(r,n,i)};return r.oneOfNodeTypes=[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;,&quot;</span><span class="s0">NumericLiteral</span><span class="s3">&quot;],r}()},decorators:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Decorator</span><span class="s3">&quot;))),optional:!0},body:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;)}}),visitor:[&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">params</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;,&quot;</span><span class="s0">decorators</span><span class="s3">&quot;,&quot;</span><span class="s0">returnType</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">UserWhitespacable</span><span class="s3">&quot;,&quot;</span><span class="s0">Function</span><span class="s3">&quot;,&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;,&quot;</span><span class="s0">FunctionParent</span><span class="s3">&quot;,&quot;</span><span class="s0">Method</span><span class="s3">&quot;,&quot;</span><span class="s0">ObjectMember</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">ObjectProperty</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">value</span><span class="s3">&quot;,&quot;</span><span class="s0">computed</span><span class="s3">&quot;,&quot;</span><span class="s0">shorthand</span><span class="s3">&quot;,...n.env.BABEL_TYPES_8_BREAKING?[]:[&quot;</span><span class="s0">decorators</span><span class="s3">&quot;]],fields:{computed:{default:!1},key:{validate:function(){const e=(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;,&quot;</span><span class="s0">NumericLiteral</span><span class="s3">&quot;),t=(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;),r=function(r,n,i){(r.computed?t:e)(r,n,i)};return r.oneOfNodeTypes=[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;,&quot;</span><span class="s0">NumericLiteral</span><span class="s3">&quot;],r}()},value:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">PatternLike</span><span class="s3">&quot;)},shorthand:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),Object.assign((function(e,t,r){if(n.env.BABEL_TYPES_8_BREAKING&amp;&amp;r&amp;&amp;e.computed)throw new TypeError(&quot;</span><span class="s0">Property shorthand of ObjectProperty cannot be </span><span class="s1">true if </span><span class="s0">computed is </span><span class="s1">true</span><span class="s3">&quot;)}),{type:&quot;</span><span class="s0">boolean</span><span class="s3">&quot;}),(function(e,t,r){if(n.env.BABEL_TYPES_8_BREAKING&amp;&amp;r&amp;&amp;!(0,i.default)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,e.key))throw new TypeError(&quot;</span><span class="s0">Property shorthand of ObjectProperty cannot be </span><span class="s1">true if </span><span class="s0">key is not an Identifier</span><span class="s3">&quot;)})),default:!1},decorators:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Decorator</span><span class="s3">&quot;))),optional:!0}},visitor:[&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">value</span><span class="s3">&quot;,&quot;</span><span class="s0">decorators</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">UserWhitespacable</span><span class="s3">&quot;,&quot;</span><span class="s0">Property</span><span class="s3">&quot;,&quot;</span><span class="s0">ObjectMember</span><span class="s3">&quot;],validate:function(){const e=(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">Pattern</span><span class="s3">&quot;),t=(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;);return function(r,s,a){n.env.BABEL_TYPES_8_BREAKING&amp;&amp;((0,i.default)(&quot;</span><span class="s0">ObjectPattern</span><span class="s3">&quot;,r)?e:t)(a,&quot;</span><span class="s0">value</span><span class="s3">&quot;,a.value)}}()}),(0,l.default)(&quot;</span><span class="s0">RestElement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],builder:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">LVal</span><span class="s3">&quot;,&quot;</span><span class="s0">PatternLike</span><span class="s3">&quot;],deprecatedAlias:&quot;</span><span class="s0">RestProperty</span><span class="s3">&quot;,fields:Object.assign({},f,{argument:{validate:n.env.BABEL_TYPES_8_BREAKING?(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">Pattern</span><span class="s3">&quot;,&quot;</span><span class="s0">MemberExpression</span><span class="s3">&quot;):(0,l.assertNodeType)(&quot;</span><span class="s0">LVal</span><span class="s3">&quot;)}}),validate(e,t){if(!n.env.BABEL_TYPES_8_BREAKING)return;const r=/(</span><span class="s5">\w</span><span class="s3">+)</span><span class="s5">\[</span><span class="s3">(</span><span class="s5">\d</span><span class="s3">+)</span><span class="s5">\]</span><span class="s3">/.exec(t);if(!r)throw new Error(&quot;</span><span class="s0">Internal Babel error: malformed key.</span><span class="s3">&quot;);const[,i,s]=r;if(e[i].length&gt;s+1)throw new TypeError(`RestElement must be last element of ${i}`)}}),(0,l.default)(&quot;</span><span class="s0">ReturnStatement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Terminatorless</span><span class="s3">&quot;,&quot;</span><span class="s0">CompletionStatement</span><span class="s3">&quot;],fields:{argument:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;),optional:!0}}}),(0,l.default)(&quot;</span><span class="s0">SequenceExpression</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">expressions</span><span class="s3">&quot;],fields:{expressions:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)))}},aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">ParenthesizedExpression</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">expression</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">ExpressionWrapper</span><span class="s3">&quot;],fields:{expression:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">SwitchCase</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">test</span><span class="s3">&quot;,&quot;</span><span class="s0">consequent</span><span class="s3">&quot;],fields:{test:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;),optional:!0},consequent:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Statement</span><span class="s3">&quot;)))}}}),(0,l.default)(&quot;</span><span class="s0">SwitchStatement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">discriminant</span><span class="s3">&quot;,&quot;</span><span class="s0">cases</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;,&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;],fields:{discriminant:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},cases:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">SwitchCase</span><span class="s3">&quot;)))}}}),(0,l.default)(&quot;</span><span class="s0">ThisExpression</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">ThrowStatement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Terminatorless</span><span class="s3">&quot;,&quot;</span><span class="s0">CompletionStatement</span><span class="s3">&quot;],fields:{argument:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">TryStatement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">block</span><span class="s3">&quot;,&quot;</span><span class="s0">handler</span><span class="s3">&quot;,&quot;</span><span class="s0">finalizer</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;],fields:{block:{validate:(0,l.chain)((0,l.assertNodeType)(&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;),Object.assign((function(e){if(n.env.BABEL_TYPES_8_BREAKING&amp;&amp;!e.handler&amp;&amp;!e.finalizer)throw new TypeError(&quot;</span><span class="s0">TryStatement expects either a handler or finalizer, or both</span><span class="s3">&quot;)}),{oneOfNodeTypes:[&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;]}))},handler:{optional:!0,validate:(0,l.assertNodeType)(&quot;</span><span class="s0">CatchClause</span><span class="s3">&quot;)},finalizer:{optional:!0,validate:(0,l.assertNodeType)(&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">UnaryExpression</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">operator</span><span class="s3">&quot;,&quot;</span><span class="s0">argument</span><span class="s3">&quot;,&quot;</span><span class="s0">prefix</span><span class="s3">&quot;],fields:{prefix:{default:!0},argument:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},operator:{validate:(0,l.assertOneOf)(...o.UNARY_OPERATORS)}},visitor:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">UnaryLike</span><span class="s3">&quot;,&quot;</span><span class="s0">Expression</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">UpdateExpression</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">operator</span><span class="s3">&quot;,&quot;</span><span class="s0">argument</span><span class="s3">&quot;,&quot;</span><span class="s0">prefix</span><span class="s3">&quot;],fields:{prefix:{default:!1},argument:{validate:n.env.BABEL_TYPES_8_BREAKING?(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">MemberExpression</span><span class="s3">&quot;):(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},operator:{validate:(0,l.assertOneOf)(...o.UPDATE_OPERATORS)}},visitor:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">VariableDeclaration</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">kind</span><span class="s3">&quot;,&quot;</span><span class="s0">declarations</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">declarations</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],fields:{declare:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),optional:!0},kind:{validate:(0,l.assertOneOf)(&quot;</span><span class="s1">var</span><span class="s3">&quot;,&quot;</span><span class="s0">let</span><span class="s3">&quot;,&quot;</span><span class="s0">const</span><span class="s3">&quot;)},declarations:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">VariableDeclarator</span><span class="s3">&quot;)))}},validate(e,t,r){if(n.env.BABEL_TYPES_8_BREAKING&amp;&amp;(0,i.default)(&quot;</span><span class="s0">ForXStatement</span><span class="s3">&quot;,e,{left:r})&amp;&amp;1!==r.declarations.length)throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${e.type}`)}}),(0,l.default)(&quot;</span><span class="s0">VariableDeclarator</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">init</span><span class="s3">&quot;],fields:{id:{validate:function(){if(!n.env.BABEL_TYPES_8_BREAKING)return(0,l.assertNodeType)(&quot;</span><span class="s0">LVal</span><span class="s3">&quot;);const e=(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">ArrayPattern</span><span class="s3">&quot;,&quot;</span><span class="s0">ObjectPattern</span><span class="s3">&quot;),t=(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;);return function(r,n,i){(r.init?e:t)(r,n,i)}}()},definite:{optional:!0,validate:(0,l.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;)},init:{optional:!0,validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">WhileStatement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">test</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;,&quot;</span><span class="s0">Loop</span><span class="s3">&quot;,&quot;</span><span class="s0">While</span><span class="s3">&quot;,&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;],fields:{test:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},body:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Statement</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">WithStatement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">object</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;],fields:{object:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},body:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Statement</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">AssignmentPattern</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">left</span><span class="s3">&quot;,&quot;</span><span class="s0">right</span><span class="s3">&quot;,&quot;</span><span class="s0">decorators</span><span class="s3">&quot;],builder:[&quot;</span><span class="s0">left</span><span class="s3">&quot;,&quot;</span><span class="s0">right</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Pattern</span><span class="s3">&quot;,&quot;</span><span class="s0">PatternLike</span><span class="s3">&quot;,&quot;</span><span class="s0">LVal</span><span class="s3">&quot;],fields:Object.assign({},f,{left:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">ObjectPattern</span><span class="s3">&quot;,&quot;</span><span class="s0">ArrayPattern</span><span class="s3">&quot;,&quot;</span><span class="s0">MemberExpression</span><span class="s3">&quot;)},right:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},decorators:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Decorator</span><span class="s3">&quot;))),optional:!0}})}),(0,l.default)(&quot;</span><span class="s0">ArrayPattern</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">elements</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],builder:[&quot;</span><span class="s0">elements</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Pattern</span><span class="s3">&quot;,&quot;</span><span class="s0">PatternLike</span><span class="s3">&quot;,&quot;</span><span class="s0">LVal</span><span class="s3">&quot;],fields:Object.assign({},f,{elements:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeOrValueType)(&quot;</span><span class="s1">null</span><span class="s3">&quot;,&quot;</span><span class="s0">PatternLike</span><span class="s3">&quot;)))},decorators:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Decorator</span><span class="s3">&quot;))),optional:!0}})}),(0,l.default)(&quot;</span><span class="s0">ArrowFunctionExpression</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">params</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;,&quot;</span><span class="s0">async</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">params</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;,&quot;</span><span class="s0">returnType</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;,&quot;</span><span class="s0">Function</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;,&quot;</span><span class="s0">FunctionParent</span><span class="s3">&quot;,&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Pureish</span><span class="s3">&quot;],fields:Object.assign({},u,d,{expression:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;)},body:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;,&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}})}),(0,l.default)(&quot;</span><span class="s0">ClassBody</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">body</span><span class="s3">&quot;],fields:{body:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">ClassMethod</span><span class="s3">&quot;,&quot;</span><span class="s0">ClassPrivateMethod</span><span class="s3">&quot;,&quot;</span><span class="s0">ClassProperty</span><span class="s3">&quot;,&quot;</span><span class="s0">ClassPrivateProperty</span><span class="s3">&quot;,&quot;</span><span class="s0">TSDeclareMethod</span><span class="s3">&quot;,&quot;</span><span class="s0">TSIndexSignature</span><span class="s3">&quot;)))}}}),(0,l.default)(&quot;</span><span class="s0">ClassExpression</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">superClass</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;,&quot;</span><span class="s0">decorators</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;,&quot;</span><span class="s0">superClass</span><span class="s3">&quot;,&quot;</span><span class="s0">mixins</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">superTypeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">implements</span><span class="s3">&quot;,&quot;</span><span class="s0">decorators</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;,&quot;</span><span class="s0">Class</span><span class="s3">&quot;,&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],fields:{id:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),optional:!0},typeParameters:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">TypeParameterDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">TSTypeParameterDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Noop</span><span class="s3">&quot;),optional:!0},body:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">ClassBody</span><span class="s3">&quot;)},superClass:{optional:!0,validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},superTypeParameters:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">TypeParameterInstantiation</span><span class="s3">&quot;,&quot;</span><span class="s0">TSTypeParameterInstantiation</span><span class="s3">&quot;),optional:!0},implements:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">TSExpressionWithTypeArguments</span><span class="s3">&quot;,&quot;</span><span class="s0">ClassImplements</span><span class="s3">&quot;))),optional:!0},decorators:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Decorator</span><span class="s3">&quot;))),optional:!0},mixins:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">InterfaceExtends</span><span class="s3">&quot;),optional:!0}}}),(0,l.default)(&quot;</span><span class="s0">ClassDeclaration</span><span class="s3">&quot;,{inherits:&quot;</span><span class="s0">ClassExpression</span><span class="s3">&quot;,aliases:[&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;,&quot;</span><span class="s0">Class</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],fields:{id:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;)},typeParameters:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">TypeParameterDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">TSTypeParameterDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Noop</span><span class="s3">&quot;),optional:!0},body:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">ClassBody</span><span class="s3">&quot;)},superClass:{optional:!0,validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},superTypeParameters:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">TypeParameterInstantiation</span><span class="s3">&quot;,&quot;</span><span class="s0">TSTypeParameterInstantiation</span><span class="s3">&quot;),optional:!0},implements:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">TSExpressionWithTypeArguments</span><span class="s3">&quot;,&quot;</span><span class="s0">ClassImplements</span><span class="s3">&quot;))),optional:!0},decorators:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Decorator</span><span class="s3">&quot;))),optional:!0},mixins:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">InterfaceExtends</span><span class="s3">&quot;),optional:!0},declare:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),optional:!0},abstract:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),optional:!0}},validate:function(){const e=(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;);return function(t,r,s){n.env.BABEL_TYPES_8_BREAKING&amp;&amp;((0,i.default)(&quot;</span><span class="s0">ExportDefaultDeclaration</span><span class="s3">&quot;,t)||e(s,&quot;</span><span class="s0">id</span><span class="s3">&quot;,s.id))}}()}),(0,l.default)(&quot;</span><span class="s0">ExportAllDeclaration</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">source</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;,&quot;</span><span class="s0">ModuleDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">ExportDeclaration</span><span class="s3">&quot;],fields:{source:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;)},assertions:{optional:!0,validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertNodeType)(&quot;</span><span class="s0">ImportAttribute</span><span class="s3">&quot;))}}}),(0,l.default)(&quot;</span><span class="s0">ExportDefaultDeclaration</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">declaration</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;,&quot;</span><span class="s0">ModuleDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">ExportDeclaration</span><span class="s3">&quot;],fields:{declaration:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">FunctionDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">TSDeclareFunction</span><span class="s3">&quot;,&quot;</span><span class="s0">ClassDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">ExportNamedDeclaration</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">declaration</span><span class="s3">&quot;,&quot;</span><span class="s0">specifiers</span><span class="s3">&quot;,&quot;</span><span class="s0">source</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;,&quot;</span><span class="s0">ModuleDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">ExportDeclaration</span><span class="s3">&quot;],fields:{declaration:{optional:!0,validate:(0,l.chain)((0,l.assertNodeType)(&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;),Object.assign((function(e,t,r){if(n.env.BABEL_TYPES_8_BREAKING&amp;&amp;r&amp;&amp;e.specifiers.length)throw new TypeError(&quot;</span><span class="s0">Only declaration or specifiers is allowed on ExportNamedDeclaration</span><span class="s3">&quot;)}),{oneOfNodeTypes:[&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;]}),(function(e,t,r){if(n.env.BABEL_TYPES_8_BREAKING&amp;&amp;r&amp;&amp;e.source)throw new TypeError(&quot;</span><span class="s0">Cannot export a declaration from a source</span><span class="s3">&quot;)}))},assertions:{optional:!0,validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertNodeType)(&quot;</span><span class="s0">ImportAttribute</span><span class="s3">&quot;))},specifiers:{default:[],validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)(function(){const e=(0,l.assertNodeType)(&quot;</span><span class="s0">ExportSpecifier</span><span class="s3">&quot;,&quot;</span><span class="s0">ExportDefaultSpecifier</span><span class="s3">&quot;,&quot;</span><span class="s0">ExportNamespaceSpecifier</span><span class="s3">&quot;),t=(0,l.assertNodeType)(&quot;</span><span class="s0">ExportSpecifier</span><span class="s3">&quot;);return n.env.BABEL_TYPES_8_BREAKING?function(r,n,i){(r.source?e:t)(r,n,i)}:e}()))},source:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;),optional:!0},exportKind:(0,l.validateOptional)((0,l.assertOneOf)(&quot;</span><span class="s0">type</span><span class="s3">&quot;,&quot;</span><span class="s0">value</span><span class="s3">&quot;))}}),(0,l.default)(&quot;</span><span class="s0">ExportSpecifier</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">local</span><span class="s3">&quot;,&quot;</span><span class="s0">exported</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">ModuleSpecifier</span><span class="s3">&quot;],fields:{local:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;)},exported:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">ForOfStatement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">left</span><span class="s3">&quot;,&quot;</span><span class="s0">right</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],builder:[&quot;</span><span class="s0">left</span><span class="s3">&quot;,&quot;</span><span class="s0">right</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;,&quot;</span><span class="s0">await</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">For</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;,&quot;</span><span class="s0">Loop</span><span class="s3">&quot;,&quot;</span><span class="s0">ForXStatement</span><span class="s3">&quot;],fields:{left:{validate:function(){if(!n.env.BABEL_TYPES_8_BREAKING)return(0,l.assertNodeType)(&quot;</span><span class="s0">VariableDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">LVal</span><span class="s3">&quot;);const e=(0,l.assertNodeType)(&quot;</span><span class="s0">VariableDeclaration</span><span class="s3">&quot;),t=(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">MemberExpression</span><span class="s3">&quot;,&quot;</span><span class="s0">ArrayPattern</span><span class="s3">&quot;,&quot;</span><span class="s0">ObjectPattern</span><span class="s3">&quot;);return function(r,n,s){(0,i.default)(&quot;</span><span class="s0">VariableDeclaration</span><span class="s3">&quot;,s)?e(r,n,s):t(r,n,s)}}()},right:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},body:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Statement</span><span class="s3">&quot;)},await:{default:!1}}}),(0,l.default)(&quot;</span><span class="s0">ImportDeclaration</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">specifiers</span><span class="s3">&quot;,&quot;</span><span class="s0">source</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;,&quot;</span><span class="s0">ModuleDeclaration</span><span class="s3">&quot;],fields:{assertions:{optional:!0,validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertNodeType)(&quot;</span><span class="s0">ImportAttribute</span><span class="s3">&quot;))},specifiers:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">ImportSpecifier</span><span class="s3">&quot;,&quot;</span><span class="s0">ImportDefaultSpecifier</span><span class="s3">&quot;,&quot;</span><span class="s0">ImportNamespaceSpecifier</span><span class="s3">&quot;)))},source:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;)},importKind:{validate:(0,l.assertOneOf)(&quot;</span><span class="s0">type</span><span class="s3">&quot;,&quot;</span><span class="s1">typeof</span><span class="s3">&quot;,&quot;</span><span class="s0">value</span><span class="s3">&quot;),optional:!0}}}),(0,l.default)(&quot;</span><span class="s0">ImportDefaultSpecifier</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">local</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">ModuleSpecifier</span><span class="s3">&quot;],fields:{local:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">ImportNamespaceSpecifier</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">local</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">ModuleSpecifier</span><span class="s3">&quot;],fields:{local:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">ImportSpecifier</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">local</span><span class="s3">&quot;,&quot;</span><span class="s0">imported</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">ModuleSpecifier</span><span class="s3">&quot;],fields:{local:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;)},imported:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;)},importKind:{validate:(0,l.assertOneOf)(&quot;</span><span class="s0">type</span><span class="s3">&quot;,&quot;</span><span class="s1">typeof</span><span class="s3">&quot;),optional:!0}}}),(0,l.default)(&quot;</span><span class="s0">MetaProperty</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">meta</span><span class="s3">&quot;,&quot;</span><span class="s0">property</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],fields:{meta:{validate:(0,l.chain)((0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),Object.assign((function(e,t,r){if(!n.env.BABEL_TYPES_8_BREAKING)return;let s;switch(r.name){case&quot;</span><span class="s1">function</span><span class="s3">&quot;:s=&quot;</span><span class="s0">sent</span><span class="s3">&quot;;break;case&quot;</span><span class="s1">new</span><span class="s3">&quot;:s=&quot;</span><span class="s0">target</span><span class="s3">&quot;;break;case&quot;</span><span class="s0">import</span><span class="s3">&quot;:s=&quot;</span><span class="s0">meta</span><span class="s3">&quot;}if(!(0,i.default)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,e.property,{name:s}))throw new TypeError(&quot;</span><span class="s0">Unrecognised MetaProperty</span><span class="s3">&quot;)}),{oneOfNodeTypes:[&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;]}))},property:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;)}}});const m={abstract:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),optional:!0},accessibility:{validate:(0,l.assertOneOf)(&quot;</span><span class="s0">public</span><span class="s3">&quot;,&quot;</span><span class="s0">private</span><span class="s3">&quot;,&quot;</span><span class="s0">protected</span><span class="s3">&quot;),optional:!0},static:{default:!1},computed:{default:!1},optional:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),optional:!0},key:{validate:(0,l.chain)(function(){const e=(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;,&quot;</span><span class="s0">NumericLiteral</span><span class="s3">&quot;),t=(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;);return function(r,n,i){(r.computed?t:e)(r,n,i)}}(),(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;,&quot;</span><span class="s0">NumericLiteral</span><span class="s3">&quot;,&quot;</span><span class="s0">Expression</span><span class="s3">&quot;))}};t.classMethodOrPropertyCommon=m;const y=Object.assign({},u,m,{kind:{validate:(0,l.assertOneOf)(&quot;</span><span class="s0">get</span><span class="s3">&quot;,&quot;</span><span class="s0">set</span><span class="s3">&quot;,&quot;</span><span class="s0">method</span><span class="s3">&quot;,&quot;</span><span class="s0">constructor</span><span class="s3">&quot;),default:&quot;</span><span class="s0">method</span><span class="s3">&quot;},access:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;),(0,l.assertOneOf)(&quot;</span><span class="s0">public</span><span class="s3">&quot;,&quot;</span><span class="s0">private</span><span class="s3">&quot;,&quot;</span><span class="s0">protected</span><span class="s3">&quot;)),optional:!0},decorators:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Decorator</span><span class="s3">&quot;))),optional:!0}});t.classMethodOrDeclareMethodCommon=y,(0,l.default)(&quot;</span><span class="s0">ClassMethod</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Function</span><span class="s3">&quot;,&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;,&quot;</span><span class="s0">FunctionParent</span><span class="s3">&quot;,&quot;</span><span class="s0">Method</span><span class="s3">&quot;],builder:[&quot;</span><span class="s0">kind</span><span class="s3">&quot;,&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">params</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;,&quot;</span><span class="s0">computed</span><span class="s3">&quot;,&quot;</span><span class="s0">static</span><span class="s3">&quot;,&quot;</span><span class="s0">generator</span><span class="s3">&quot;,&quot;</span><span class="s0">async</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">params</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;,&quot;</span><span class="s0">decorators</span><span class="s3">&quot;,&quot;</span><span class="s0">returnType</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;],fields:Object.assign({},y,d,{body:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;)}})}),(0,l.default)(&quot;</span><span class="s0">ObjectPattern</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">properties</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;,&quot;</span><span class="s0">decorators</span><span class="s3">&quot;],builder:[&quot;</span><span class="s0">properties</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Pattern</span><span class="s3">&quot;,&quot;</span><span class="s0">PatternLike</span><span class="s3">&quot;,&quot;</span><span class="s0">LVal</span><span class="s3">&quot;],fields:Object.assign({},f,{properties:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">RestElement</span><span class="s3">&quot;,&quot;</span><span class="s0">ObjectProperty</span><span class="s3">&quot;)))}})}),(0,l.default)(&quot;</span><span class="s0">SpreadElement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">UnaryLike</span><span class="s3">&quot;],deprecatedAlias:&quot;</span><span class="s0">SpreadProperty</span><span class="s3">&quot;,fields:{argument:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">Super</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">TaggedTemplateExpression</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">tag</span><span class="s3">&quot;,&quot;</span><span class="s0">quasi</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],fields:{tag:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},quasi:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">TemplateLiteral</span><span class="s3">&quot;)},typeParameters:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">TypeParameterInstantiation</span><span class="s3">&quot;,&quot;</span><span class="s0">TSTypeParameterInstantiation</span><span class="s3">&quot;),optional:!0}}}),(0,l.default)(&quot;</span><span class="s0">TemplateElement</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">value</span><span class="s3">&quot;,&quot;</span><span class="s0">tail</span><span class="s3">&quot;],fields:{value:{validate:(0,l.assertShape)({raw:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;)},cooked:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;),optional:!0}})},tail:{default:!1}}}),(0,l.default)(&quot;</span><span class="s0">TemplateLiteral</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">quasis</span><span class="s3">&quot;,&quot;</span><span class="s0">expressions</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Literal</span><span class="s3">&quot;],fields:{quasis:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">TemplateElement</span><span class="s3">&quot;)))},expressions:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">TSType</span><span class="s3">&quot;)),(function(e,t,r){if(e.quasis.length!==r.length+1)throw new TypeError(`Number of ${e.type} quasis should be exactly one more than the number of expressions.</span><span class="s4">\n</span><span class="s3">Expected ${r.length+1} quasis but got ${e.quasis.length}`)}))}}}),(0,l.default)(&quot;</span><span class="s0">YieldExpression</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;,&quot;</span><span class="s0">delegate</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Terminatorless</span><span class="s3">&quot;],fields:{delegate:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),Object.assign((function(e,t,r){if(n.env.BABEL_TYPES_8_BREAKING&amp;&amp;r&amp;&amp;!e.argument)throw new TypeError(&quot;</span><span class="s0">Property delegate of YieldExpression cannot be </span><span class="s1">true if </span><span class="s0">there is no argument</span><span class="s3">&quot;)}),{type:&quot;</span><span class="s0">boolean</span><span class="s3">&quot;})),default:!1},argument:{optional:!0,validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">AwaitExpression</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Terminatorless</span><span class="s3">&quot;],fields:{argument:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">Import</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">BigIntLiteral</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">value</span><span class="s3">&quot;],fields:{value:{validate:(0,l.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;)}},aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Pureish</span><span class="s3">&quot;,&quot;</span><span class="s0">Literal</span><span class="s3">&quot;,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;]}),(0,l.default)(&quot;</span><span class="s0">ExportNamespaceSpecifier</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">exported</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">ModuleSpecifier</span><span class="s3">&quot;],fields:{exported:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">OptionalMemberExpression</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">object</span><span class="s3">&quot;,&quot;</span><span class="s0">property</span><span class="s3">&quot;,&quot;</span><span class="s0">computed</span><span class="s3">&quot;,&quot;</span><span class="s0">optional</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">object</span><span class="s3">&quot;,&quot;</span><span class="s0">property</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],fields:{object:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},property:{validate:function(){const e=(0,l.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),t=(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;),r=function(r,n,i){(r.computed?t:e)(r,n,i)};return r.oneOfNodeTypes=[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;],r}()},computed:{default:!1},optional:{validate:n.env.BABEL_TYPES_8_BREAKING?(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),(0,l.assertOptionalChainStart)()):(0,l.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;)}}}),(0,l.default)(&quot;</span><span class="s0">OptionalCallExpression</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">callee</span><span class="s3">&quot;,&quot;</span><span class="s0">arguments</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">typeArguments</span><span class="s3">&quot;],builder:[&quot;</span><span class="s0">callee</span><span class="s3">&quot;,&quot;</span><span class="s0">arguments</span><span class="s3">&quot;,&quot;</span><span class="s0">optional</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],fields:{callee:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},arguments:{validate:(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,l.assertEach)((0,l.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">SpreadElement</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXNamespacedName</span><span class="s3">&quot;)))},optional:{validate:n.env.BABEL_TYPES_8_BREAKING?(0,l.chain)((0,l.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),(0,l.assertOptionalChainStart)()):(0,l.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;)},typeArguments:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">TypeParameterInstantiation</span><span class="s3">&quot;),optional:!0},typeParameters:{validate:(0,l.assertNodeType)(&quot;</span><span class="s0">TSTypeParameterInstantiation</span><span class="s3">&quot;),optional:!0}}})},3008:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;var n=r(397),i=function(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;</span><span class="s0">object</span><span class="s3">&quot;!=typeof e&amp;&amp;&quot;</span><span class="s1">function</span><span class="s3">&quot;!=typeof e)return{default:e};var t=a();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var s=n?Object.getOwnPropertyDescriptor(e,i):null;s&amp;&amp;(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}return r.default=e,t&amp;&amp;t.set(e,r),r}(r(6343)),s=r(4613);function a(){if(&quot;</span><span class="s1">function</span><span class="s3">&quot;!=typeof WeakMap)return null;var e=new WeakMap;return a=function(){return e},e}(0,i.default)(&quot;</span><span class="s0">ArgumentPlaceholder</span><span class="s3">&quot;,{}),(0,i.default)(&quot;</span><span class="s0">BindExpression</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">object</span><span class="s3">&quot;,&quot;</span><span class="s0">callee</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],fields:n.env.BABEL_TYPES_8_BREAKING?{object:{validate:(0,i.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)},callee:{validate:(0,i.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}:{object:{validate:Object.assign((()=&gt;{}),{oneOfNodeTypes:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;]})},callee:{validate:Object.assign((()=&gt;{}),{oneOfNodeTypes:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;]})}}}),(0,i.default)(&quot;</span><span class="s0">ClassProperty</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">value</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;,&quot;</span><span class="s0">decorators</span><span class="s3">&quot;],builder:[&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">value</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;,&quot;</span><span class="s0">decorators</span><span class="s3">&quot;,&quot;</span><span class="s0">computed</span><span class="s3">&quot;,&quot;</span><span class="s0">static</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Property</span><span class="s3">&quot;],fields:Object.assign({},s.classMethodOrPropertyCommon,{value:{validate:(0,i.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;),optional:!0},definite:{validate:(0,i.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),optional:!0},typeAnnotation:{validate:(0,i.assertNodeType)(&quot;</span><span class="s0">TypeAnnotation</span><span class="s3">&quot;,&quot;</span><span class="s0">TSTypeAnnotation</span><span class="s3">&quot;,&quot;</span><span class="s0">Noop</span><span class="s3">&quot;),optional:!0},decorators:{validate:(0,i.chain)((0,i.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,i.assertEach)((0,i.assertNodeType)(&quot;</span><span class="s0">Decorator</span><span class="s3">&quot;))),optional:!0},readonly:{validate:(0,i.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),optional:!0},declare:{validate:(0,i.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),optional:!0}})}),(0,i.default)(&quot;</span><span class="s0">PipelineTopicExpression</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">expression</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">expression</span><span class="s3">&quot;],fields:{expression:{validate:(0,i.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}}),(0,i.default)(&quot;</span><span class="s0">PipelineBareFunction</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">callee</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">callee</span><span class="s3">&quot;],fields:{callee:{validate:(0,i.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}}),(0,i.default)(&quot;</span><span class="s0">PipelinePrimaryTopicReference</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;]}),(0,i.default)(&quot;</span><span class="s0">ClassPrivateProperty</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">value</span><span class="s3">&quot;,&quot;</span><span class="s0">decorators</span><span class="s3">&quot;],builder:[&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">value</span><span class="s3">&quot;,&quot;</span><span class="s0">decorators</span><span class="s3">&quot;,&quot;</span><span class="s0">static</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Property</span><span class="s3">&quot;,&quot;</span><span class="s0">Private</span><span class="s3">&quot;],fields:{key:{validate:(0,i.assertNodeType)(&quot;</span><span class="s0">PrivateName</span><span class="s3">&quot;)},value:{validate:(0,i.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;),optional:!0},decorators:{validate:(0,i.chain)((0,i.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,i.assertEach)((0,i.assertNodeType)(&quot;</span><span class="s0">Decorator</span><span class="s3">&quot;))),optional:!0}}}),(0,i.default)(&quot;</span><span class="s0">ClassPrivateMethod</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">kind</span><span class="s3">&quot;,&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">params</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;,&quot;</span><span class="s0">static</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">params</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;,&quot;</span><span class="s0">decorators</span><span class="s3">&quot;,&quot;</span><span class="s0">returnType</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Function</span><span class="s3">&quot;,&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;,&quot;</span><span class="s0">FunctionParent</span><span class="s3">&quot;,&quot;</span><span class="s0">Method</span><span class="s3">&quot;,&quot;</span><span class="s0">Private</span><span class="s3">&quot;],fields:Object.assign({},s.classMethodOrDeclareMethodCommon,s.functionTypeAnnotationCommon,{key:{validate:(0,i.assertNodeType)(&quot;</span><span class="s0">PrivateName</span><span class="s3">&quot;)},body:{validate:(0,i.assertNodeType)(&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;)}})}),(0,i.default)(&quot;</span><span class="s0">ImportAttribute</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">value</span><span class="s3">&quot;],fields:{key:{validate:(0,i.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;)},value:{validate:(0,i.assertNodeType)(&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;)}}}),(0,i.default)(&quot;</span><span class="s0">Decorator</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">expression</span><span class="s3">&quot;],fields:{expression:{validate:(0,i.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}}),(0,i.default)(&quot;</span><span class="s0">DoExpression</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">body</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],fields:{body:{validate:(0,i.assertNodeType)(&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;)}}}),(0,i.default)(&quot;</span><span class="s0">ExportDefaultSpecifier</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">exported</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">ModuleSpecifier</span><span class="s3">&quot;],fields:{exported:{validate:(0,i.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;)}}}),(0,i.default)(&quot;</span><span class="s0">PrivateName</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Private</span><span class="s3">&quot;],fields:{id:{validate:(0,i.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;)}}}),(0,i.default)(&quot;</span><span class="s0">RecordExpression</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">properties</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],fields:{properties:{validate:(0,i.chain)((0,i.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,i.assertEach)((0,i.assertNodeType)(&quot;</span><span class="s0">ObjectProperty</span><span class="s3">&quot;,&quot;</span><span class="s0">SpreadElement</span><span class="s3">&quot;)))}}}),(0,i.default)(&quot;</span><span class="s0">TupleExpression</span><span class="s3">&quot;,{fields:{elements:{validate:(0,i.chain)((0,i.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,i.assertEach)((0,i.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">SpreadElement</span><span class="s3">&quot;))),default:[]}},visitor:[&quot;</span><span class="s0">elements</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;]}),(0,i.default)(&quot;</span><span class="s0">DecimalLiteral</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">value</span><span class="s3">&quot;],fields:{value:{validate:(0,i.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;)}},aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Pureish</span><span class="s3">&quot;,&quot;</span><span class="s0">Literal</span><span class="s3">&quot;,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;]}),(0,i.default)(&quot;</span><span class="s0">StaticBlock</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">body</span><span class="s3">&quot;],fields:{body:{validate:(0,i.chain)((0,i.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,i.assertEach)((0,i.assertNodeType)(&quot;</span><span class="s0">Statement</span><span class="s3">&quot;)))}},aliases:[&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;]})},3081:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;var n=function(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;</span><span class="s0">object</span><span class="s3">&quot;!=typeof e&amp;&amp;&quot;</span><span class="s1">function</span><span class="s3">&quot;!=typeof e)return{default:e};var t=i();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var a=n?Object.getOwnPropertyDescriptor(e,s):null;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}return r.default=e,t&amp;&amp;t.set(e,r),r}(r(6343));function i(){if(&quot;</span><span class="s1">function</span><span class="s3">&quot;!=typeof WeakMap)return null;var e=new WeakMap;return i=function(){return e},e}const s=(e,t=&quot;</span><span class="s0">TypeParameterDeclaration</span><span class="s3">&quot;)=&gt;{(0,n.default)(e,{builder:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">extends</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">extends</span><span class="s3">&quot;,&quot;</span><span class="s0">mixins</span><span class="s3">&quot;,&quot;</span><span class="s0">implements</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],fields:{id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),typeParameters:(0,n.validateOptionalType)(t),extends:(0,n.validateOptional)((0,n.arrayOfType)(&quot;</span><span class="s0">InterfaceExtends</span><span class="s3">&quot;)),mixins:(0,n.validateOptional)((0,n.arrayOfType)(&quot;</span><span class="s0">InterfaceExtends</span><span class="s3">&quot;)),implements:(0,n.validateOptional)((0,n.arrayOfType)(&quot;</span><span class="s0">ClassImplements</span><span class="s3">&quot;)),body:(0,n.validateType)(&quot;</span><span class="s0">ObjectTypeAnnotation</span><span class="s3">&quot;)}})};(0,n.default)(&quot;</span><span class="s0">AnyTypeAnnotation</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowBaseAnnotation</span><span class="s3">&quot;]}),(0,n.default)(&quot;</span><span class="s0">ArrayTypeAnnotation</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">elementType</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;],fields:{elementType:(0,n.validateType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">BooleanTypeAnnotation</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowBaseAnnotation</span><span class="s3">&quot;]}),(0,n.default)(&quot;</span><span class="s0">BooleanLiteralTypeAnnotation</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">value</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;],fields:{value:(0,n.validate)((0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;))}}),(0,n.default)(&quot;</span><span class="s0">NullLiteralTypeAnnotation</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowBaseAnnotation</span><span class="s3">&quot;]}),(0,n.default)(&quot;</span><span class="s0">ClassImplements</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;],fields:{id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),typeParameters:(0,n.validateOptionalType)(&quot;</span><span class="s0">TypeParameterInstantiation</span><span class="s3">&quot;)}}),s(&quot;</span><span class="s0">DeclareClass</span><span class="s3">&quot;),(0,n.default)(&quot;</span><span class="s0">DeclareFunction</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],fields:{id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),predicate:(0,n.validateOptionalType)(&quot;</span><span class="s0">DeclaredPredicate</span><span class="s3">&quot;)}}),s(&quot;</span><span class="s0">DeclareInterface</span><span class="s3">&quot;),(0,n.default)(&quot;</span><span class="s0">DeclareModule</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;,&quot;</span><span class="s0">kind</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],fields:{id:(0,n.validateType)([&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;]),body:(0,n.validateType)(&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;),kind:(0,n.validateOptional)((0,n.assertOneOf)(&quot;</span><span class="s0">CommonJS</span><span class="s3">&quot;,&quot;</span><span class="s0">ES</span><span class="s3">&quot;))}}),(0,n.default)(&quot;</span><span class="s0">DeclareModuleExports</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],fields:{typeAnnotation:(0,n.validateType)(&quot;</span><span class="s0">TypeAnnotation</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">DeclareTypeAlias</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">right</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],fields:{id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),typeParameters:(0,n.validateOptionalType)(&quot;</span><span class="s0">TypeParameterDeclaration</span><span class="s3">&quot;),right:(0,n.validateType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">DeclareOpaqueType</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">supertype</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],fields:{id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),typeParameters:(0,n.validateOptionalType)(&quot;</span><span class="s0">TypeParameterDeclaration</span><span class="s3">&quot;),supertype:(0,n.validateOptionalType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">DeclareVariable</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],fields:{id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">DeclareExportDeclaration</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">declaration</span><span class="s3">&quot;,&quot;</span><span class="s0">specifiers</span><span class="s3">&quot;,&quot;</span><span class="s0">source</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],fields:{declaration:(0,n.validateOptionalType)(&quot;</span><span class="s0">Flow</span><span class="s3">&quot;),specifiers:(0,n.validateOptional)((0,n.arrayOfType)([&quot;</span><span class="s0">ExportSpecifier</span><span class="s3">&quot;,&quot;</span><span class="s0">ExportNamespaceSpecifier</span><span class="s3">&quot;])),source:(0,n.validateOptionalType)(&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;),default:(0,n.validateOptional)((0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;))}}),(0,n.default)(&quot;</span><span class="s0">DeclareExportAllDeclaration</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">source</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],fields:{source:(0,n.validateType)(&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;),exportKind:(0,n.validateOptional)((0,n.assertOneOf)(&quot;</span><span class="s0">type</span><span class="s3">&quot;,&quot;</span><span class="s0">value</span><span class="s3">&quot;))}}),(0,n.default)(&quot;</span><span class="s0">DeclaredPredicate</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">value</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowPredicate</span><span class="s3">&quot;],fields:{value:(0,n.validateType)(&quot;</span><span class="s0">Flow</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">ExistsTypeAnnotation</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;]}),(0,n.default)(&quot;</span><span class="s0">FunctionTypeAnnotation</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">params</span><span class="s3">&quot;,&quot;</span><span class="s0">rest</span><span class="s3">&quot;,&quot;</span><span class="s0">returnType</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;],fields:{typeParameters:(0,n.validateOptionalType)(&quot;</span><span class="s0">TypeParameterDeclaration</span><span class="s3">&quot;),params:(0,n.validate)((0,n.arrayOfType)(&quot;</span><span class="s0">FunctionTypeParam</span><span class="s3">&quot;)),rest:(0,n.validateOptionalType)(&quot;</span><span class="s0">FunctionTypeParam</span><span class="s3">&quot;),returnType:(0,n.validateType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">FunctionTypeParam</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">name</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;],fields:{name:(0,n.validateOptionalType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),typeAnnotation:(0,n.validateType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;),optional:(0,n.validateOptional)((0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;))}}),(0,n.default)(&quot;</span><span class="s0">GenericTypeAnnotation</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;],fields:{id:(0,n.validateType)([&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">QualifiedTypeIdentifier</span><span class="s3">&quot;]),typeParameters:(0,n.validateOptionalType)(&quot;</span><span class="s0">TypeParameterInstantiation</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">InferredPredicate</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowPredicate</span><span class="s3">&quot;]}),(0,n.default)(&quot;</span><span class="s0">InterfaceExtends</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;],fields:{id:(0,n.validateType)([&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">QualifiedTypeIdentifier</span><span class="s3">&quot;]),typeParameters:(0,n.validateOptionalType)(&quot;</span><span class="s0">TypeParameterInstantiation</span><span class="s3">&quot;)}}),s(&quot;</span><span class="s0">InterfaceDeclaration</span><span class="s3">&quot;),(0,n.default)(&quot;</span><span class="s0">InterfaceTypeAnnotation</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">extends</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;],fields:{extends:(0,n.validateOptional)((0,n.arrayOfType)(&quot;</span><span class="s0">InterfaceExtends</span><span class="s3">&quot;)),body:(0,n.validateType)(&quot;</span><span class="s0">ObjectTypeAnnotation</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">IntersectionTypeAnnotation</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">types</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;],fields:{types:(0,n.validate)((0,n.arrayOfType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;))}}),(0,n.default)(&quot;</span><span class="s0">MixedTypeAnnotation</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowBaseAnnotation</span><span class="s3">&quot;]}),(0,n.default)(&quot;</span><span class="s0">EmptyTypeAnnotation</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowBaseAnnotation</span><span class="s3">&quot;]}),(0,n.default)(&quot;</span><span class="s0">NullableTypeAnnotation</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;],fields:{typeAnnotation:(0,n.validateType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">NumberLiteralTypeAnnotation</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">value</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;],fields:{value:(0,n.validate)((0,n.assertValueType)(&quot;</span><span class="s0">number</span><span class="s3">&quot;))}}),(0,n.default)(&quot;</span><span class="s0">NumberTypeAnnotation</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowBaseAnnotation</span><span class="s3">&quot;]}),(0,n.default)(&quot;</span><span class="s0">ObjectTypeAnnotation</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">properties</span><span class="s3">&quot;,&quot;</span><span class="s0">indexers</span><span class="s3">&quot;,&quot;</span><span class="s0">callProperties</span><span class="s3">&quot;,&quot;</span><span class="s0">internalSlots</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;],builder:[&quot;</span><span class="s0">properties</span><span class="s3">&quot;,&quot;</span><span class="s0">indexers</span><span class="s3">&quot;,&quot;</span><span class="s0">callProperties</span><span class="s3">&quot;,&quot;</span><span class="s0">internalSlots</span><span class="s3">&quot;,&quot;</span><span class="s0">exact</span><span class="s3">&quot;],fields:{properties:(0,n.validate)((0,n.arrayOfType)([&quot;</span><span class="s0">ObjectTypeProperty</span><span class="s3">&quot;,&quot;</span><span class="s0">ObjectTypeSpreadProperty</span><span class="s3">&quot;])),indexers:(0,n.validateOptional)((0,n.arrayOfType)(&quot;</span><span class="s0">ObjectTypeIndexer</span><span class="s3">&quot;)),callProperties:(0,n.validateOptional)((0,n.arrayOfType)(&quot;</span><span class="s0">ObjectTypeCallProperty</span><span class="s3">&quot;)),internalSlots:(0,n.validateOptional)((0,n.arrayOfType)(&quot;</span><span class="s0">ObjectTypeInternalSlot</span><span class="s3">&quot;)),exact:{validate:(0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),default:!1},inexact:(0,n.validateOptional)((0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;))}}),(0,n.default)(&quot;</span><span class="s0">ObjectTypeInternalSlot</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">value</span><span class="s3">&quot;,&quot;</span><span class="s0">optional</span><span class="s3">&quot;,&quot;</span><span class="s0">static</span><span class="s3">&quot;,&quot;</span><span class="s0">method</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">UserWhitespacable</span><span class="s3">&quot;],fields:{id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),value:(0,n.validateType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;),optional:(0,n.validate)((0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;)),static:(0,n.validate)((0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;)),method:(0,n.validate)((0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;))}}),(0,n.default)(&quot;</span><span class="s0">ObjectTypeCallProperty</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">value</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">UserWhitespacable</span><span class="s3">&quot;],fields:{value:(0,n.validateType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;),static:(0,n.validate)((0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;))}}),(0,n.default)(&quot;</span><span class="s0">ObjectTypeIndexer</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">value</span><span class="s3">&quot;,&quot;</span><span class="s0">variance</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">UserWhitespacable</span><span class="s3">&quot;],fields:{id:(0,n.validateOptionalType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),key:(0,n.validateType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;),value:(0,n.validateType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;),static:(0,n.validate)((0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;)),variance:(0,n.validateOptionalType)(&quot;</span><span class="s0">Variance</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">ObjectTypeProperty</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">value</span><span class="s3">&quot;,&quot;</span><span class="s0">variance</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">UserWhitespacable</span><span class="s3">&quot;],fields:{key:(0,n.validateType)([&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;]),value:(0,n.validateType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;),kind:(0,n.validate)((0,n.assertOneOf)(&quot;</span><span class="s0">init</span><span class="s3">&quot;,&quot;</span><span class="s0">get</span><span class="s3">&quot;,&quot;</span><span class="s0">set</span><span class="s3">&quot;)),static:(0,n.validate)((0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;)),proto:(0,n.validate)((0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;)),optional:(0,n.validate)((0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;)),variance:(0,n.validateOptionalType)(&quot;</span><span class="s0">Variance</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">ObjectTypeSpreadProperty</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">UserWhitespacable</span><span class="s3">&quot;],fields:{argument:(0,n.validateType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">OpaqueType</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">supertype</span><span class="s3">&quot;,&quot;</span><span class="s0">impltype</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],fields:{id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),typeParameters:(0,n.validateOptionalType)(&quot;</span><span class="s0">TypeParameterDeclaration</span><span class="s3">&quot;),supertype:(0,n.validateOptionalType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;),impltype:(0,n.validateType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">QualifiedTypeIdentifier</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">qualification</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;],fields:{id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),qualification:(0,n.validateType)([&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">QualifiedTypeIdentifier</span><span class="s3">&quot;])}}),(0,n.default)(&quot;</span><span class="s0">StringLiteralTypeAnnotation</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">value</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;],fields:{value:(0,n.validate)((0,n.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;))}}),(0,n.default)(&quot;</span><span class="s0">StringTypeAnnotation</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowBaseAnnotation</span><span class="s3">&quot;]}),(0,n.default)(&quot;</span><span class="s0">SymbolTypeAnnotation</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowBaseAnnotation</span><span class="s3">&quot;]}),(0,n.default)(&quot;</span><span class="s0">ThisTypeAnnotation</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowBaseAnnotation</span><span class="s3">&quot;]}),(0,n.default)(&quot;</span><span class="s0">TupleTypeAnnotation</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">types</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;],fields:{types:(0,n.validate)((0,n.arrayOfType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;))}}),(0,n.default)(&quot;</span><span class="s0">TypeofTypeAnnotation</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;],fields:{argument:(0,n.validateType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TypeAlias</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">right</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],fields:{id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),typeParameters:(0,n.validateOptionalType)(&quot;</span><span class="s0">TypeParameterDeclaration</span><span class="s3">&quot;),right:(0,n.validateType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TypeAnnotation</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],fields:{typeAnnotation:(0,n.validateType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TypeCastExpression</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">expression</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">ExpressionWrapper</span><span class="s3">&quot;,&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],fields:{expression:(0,n.validateType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;),typeAnnotation:(0,n.validateType)(&quot;</span><span class="s0">TypeAnnotation</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TypeParameter</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">bound</span><span class="s3">&quot;,&quot;</span><span class="s1">default</span><span class="s3">&quot;,&quot;</span><span class="s0">variance</span><span class="s3">&quot;],fields:{name:(0,n.validate)((0,n.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;)),bound:(0,n.validateOptionalType)(&quot;</span><span class="s0">TypeAnnotation</span><span class="s3">&quot;),default:(0,n.validateOptionalType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;),variance:(0,n.validateOptionalType)(&quot;</span><span class="s0">Variance</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TypeParameterDeclaration</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">params</span><span class="s3">&quot;],fields:{params:(0,n.validate)((0,n.arrayOfType)(&quot;</span><span class="s0">TypeParameter</span><span class="s3">&quot;))}}),(0,n.default)(&quot;</span><span class="s0">TypeParameterInstantiation</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">params</span><span class="s3">&quot;],fields:{params:(0,n.validate)((0,n.arrayOfType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;))}}),(0,n.default)(&quot;</span><span class="s0">UnionTypeAnnotation</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">types</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;],fields:{types:(0,n.validate)((0,n.arrayOfType)(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;))}}),(0,n.default)(&quot;</span><span class="s0">Variance</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;],builder:[&quot;</span><span class="s0">kind</span><span class="s3">&quot;],fields:{kind:(0,n.validate)((0,n.assertOneOf)(&quot;</span><span class="s0">minus</span><span class="s3">&quot;,&quot;</span><span class="s0">plus</span><span class="s3">&quot;))}}),(0,n.default)(&quot;</span><span class="s0">VoidTypeAnnotation</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Flow</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;,&quot;</span><span class="s0">FlowBaseAnnotation</span><span class="s3">&quot;]}),(0,n.default)(&quot;</span><span class="s0">EnumDeclaration</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],fields:{id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),body:(0,n.validateType)([&quot;</span><span class="s0">EnumBooleanBody</span><span class="s3">&quot;,&quot;</span><span class="s0">EnumNumberBody</span><span class="s3">&quot;,&quot;</span><span class="s0">EnumStringBody</span><span class="s3">&quot;,&quot;</span><span class="s0">EnumSymbolBody</span><span class="s3">&quot;])}}),(0,n.default)(&quot;</span><span class="s0">EnumBooleanBody</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">EnumBody</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">members</span><span class="s3">&quot;],fields:{explicit:(0,n.validate)((0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;)),members:(0,n.validateArrayOfType)(&quot;</span><span class="s0">EnumBooleanMember</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">EnumNumberBody</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">EnumBody</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">members</span><span class="s3">&quot;],fields:{explicit:(0,n.validate)((0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;)),members:(0,n.validateArrayOfType)(&quot;</span><span class="s0">EnumNumberMember</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">EnumStringBody</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">EnumBody</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">members</span><span class="s3">&quot;],fields:{explicit:(0,n.validate)((0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;)),members:(0,n.validateArrayOfType)([&quot;</span><span class="s0">EnumStringMember</span><span class="s3">&quot;,&quot;</span><span class="s0">EnumDefaultedMember</span><span class="s3">&quot;])}}),(0,n.default)(&quot;</span><span class="s0">EnumSymbolBody</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">EnumBody</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">members</span><span class="s3">&quot;],fields:{members:(0,n.validateArrayOfType)(&quot;</span><span class="s0">EnumDefaultedMember</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">EnumBooleanMember</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">EnumMember</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],fields:{id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),init:(0,n.validateType)(&quot;</span><span class="s0">BooleanLiteral</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">EnumNumberMember</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">EnumMember</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">init</span><span class="s3">&quot;],fields:{id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),init:(0,n.validateType)(&quot;</span><span class="s0">NumericLiteral</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">EnumStringMember</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">EnumMember</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">init</span><span class="s3">&quot;],fields:{id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),init:(0,n.validateType)(&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">EnumDefaultedMember</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">EnumMember</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],fields:{id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;)}})},9829:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),Object.defineProperty(t,&quot;</span><span class="s0">VISITOR_KEYS</span><span class="s3">&quot;,{enumerable:!0,get:function(){return s.VISITOR_KEYS}}),Object.defineProperty(t,&quot;</span><span class="s0">ALIAS_KEYS</span><span class="s3">&quot;,{enumerable:!0,get:function(){return s.ALIAS_KEYS}}),Object.defineProperty(t,&quot;</span><span class="s0">FLIPPED_ALIAS_KEYS</span><span class="s3">&quot;,{enumerable:!0,get:function(){return s.FLIPPED_ALIAS_KEYS}}),Object.defineProperty(t,&quot;</span><span class="s0">NODE_FIELDS</span><span class="s3">&quot;,{enumerable:!0,get:function(){return s.NODE_FIELDS}}),Object.defineProperty(t,&quot;</span><span class="s0">BUILDER_KEYS</span><span class="s3">&quot;,{enumerable:!0,get:function(){return s.BUILDER_KEYS}}),Object.defineProperty(t,&quot;</span><span class="s0">DEPRECATED_KEYS</span><span class="s3">&quot;,{enumerable:!0,get:function(){return s.DEPRECATED_KEYS}}),Object.defineProperty(t,&quot;</span><span class="s0">NODE_PARENT_VALIDATIONS</span><span class="s3">&quot;,{enumerable:!0,get:function(){return s.NODE_PARENT_VALIDATIONS}}),Object.defineProperty(t,&quot;</span><span class="s0">PLACEHOLDERS</span><span class="s3">&quot;,{enumerable:!0,get:function(){return a.PLACEHOLDERS}}),Object.defineProperty(t,&quot;</span><span class="s0">PLACEHOLDERS_ALIAS</span><span class="s3">&quot;,{enumerable:!0,get:function(){return a.PLACEHOLDERS_ALIAS}}),Object.defineProperty(t,&quot;</span><span class="s0">PLACEHOLDERS_FLIPPED_ALIAS</span><span class="s3">&quot;,{enumerable:!0,get:function(){return a.PLACEHOLDERS_FLIPPED_ALIAS}}),t.TYPES=void 0;var n,i=(n=r(1138))&amp;&amp;n.__esModule?n:{default:n};r(4613),r(3081),r(765),r(9710),r(3008),r(4544);var s=r(6343),a=r(1093);(0,i.default)(s.VISITOR_KEYS),(0,i.default)(s.ALIAS_KEYS),(0,i.default)(s.FLIPPED_ALIAS_KEYS),(0,i.default)(s.NODE_FIELDS),(0,i.default)(s.BUILDER_KEYS),(0,i.default)(s.DEPRECATED_KEYS),(0,i.default)(a.PLACEHOLDERS_ALIAS),(0,i.default)(a.PLACEHOLDERS_FLIPPED_ALIAS);const o=Object.keys(s.VISITOR_KEYS).concat(Object.keys(s.FLIPPED_ALIAS_KEYS)).concat(Object.keys(s.DEPRECATED_KEYS));t.TYPES=o},765:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;var n=function(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;</span><span class="s0">object</span><span class="s3">&quot;!=typeof e&amp;&amp;&quot;</span><span class="s1">function</span><span class="s3">&quot;!=typeof e)return{default:e};var t=i();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var a=n?Object.getOwnPropertyDescriptor(e,s):null;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,s,a):r[s]=e[s]}return r.default=e,t&amp;&amp;t.set(e,r),r}(r(6343));function i(){if(&quot;</span><span class="s1">function</span><span class="s3">&quot;!=typeof WeakMap)return null;var e=new WeakMap;return i=function(){return e},e}(0,n.default)(&quot;</span><span class="s0">JSXAttribute</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">name</span><span class="s3">&quot;,&quot;</span><span class="s0">value</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">JSX</span><span class="s3">&quot;,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;],fields:{name:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">JSXIdentifier</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXNamespacedName</span><span class="s3">&quot;)},value:{optional:!0,validate:(0,n.assertNodeType)(&quot;</span><span class="s0">JSXElement</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXFragment</span><span class="s3">&quot;,&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXExpressionContainer</span><span class="s3">&quot;)}}}),(0,n.default)(&quot;</span><span class="s0">JSXClosingElement</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">name</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">JSX</span><span class="s3">&quot;,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;],fields:{name:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">JSXIdentifier</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXMemberExpression</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXNamespacedName</span><span class="s3">&quot;)}}}),(0,n.default)(&quot;</span><span class="s0">JSXElement</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">openingElement</span><span class="s3">&quot;,&quot;</span><span class="s0">closingElement</span><span class="s3">&quot;,&quot;</span><span class="s0">children</span><span class="s3">&quot;,&quot;</span><span class="s0">selfClosing</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">openingElement</span><span class="s3">&quot;,&quot;</span><span class="s0">children</span><span class="s3">&quot;,&quot;</span><span class="s0">closingElement</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">JSX</span><span class="s3">&quot;,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;,&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],fields:{openingElement:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">JSXOpeningElement</span><span class="s3">&quot;)},closingElement:{optional:!0,validate:(0,n.assertNodeType)(&quot;</span><span class="s0">JSXClosingElement</span><span class="s3">&quot;)},children:{validate:(0,n.chain)((0,n.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,n.assertEach)((0,n.assertNodeType)(&quot;</span><span class="s0">JSXText</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXExpressionContainer</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXSpreadChild</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXElement</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXFragment</span><span class="s3">&quot;)))},selfClosing:{validate:(0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),optional:!0}}}),(0,n.default)(&quot;</span><span class="s0">JSXEmptyExpression</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">JSX</span><span class="s3">&quot;]}),(0,n.default)(&quot;</span><span class="s0">JSXExpressionContainer</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">expression</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">JSX</span><span class="s3">&quot;,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;],fields:{expression:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXEmptyExpression</span><span class="s3">&quot;)}}}),(0,n.default)(&quot;</span><span class="s0">JSXSpreadChild</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">expression</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">JSX</span><span class="s3">&quot;,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;],fields:{expression:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}}),(0,n.default)(&quot;</span><span class="s0">JSXIdentifier</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">name</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">JSX</span><span class="s3">&quot;],fields:{name:{validate:(0,n.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;)}}}),(0,n.default)(&quot;</span><span class="s0">JSXMemberExpression</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">object</span><span class="s3">&quot;,&quot;</span><span class="s0">property</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">JSX</span><span class="s3">&quot;],fields:{object:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">JSXMemberExpression</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXIdentifier</span><span class="s3">&quot;)},property:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">JSXIdentifier</span><span class="s3">&quot;)}}}),(0,n.default)(&quot;</span><span class="s0">JSXNamespacedName</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">namespace</span><span class="s3">&quot;,&quot;</span><span class="s0">name</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">JSX</span><span class="s3">&quot;],fields:{namespace:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">JSXIdentifier</span><span class="s3">&quot;)},name:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">JSXIdentifier</span><span class="s3">&quot;)}}}),(0,n.default)(&quot;</span><span class="s0">JSXOpeningElement</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">name</span><span class="s3">&quot;,&quot;</span><span class="s0">attributes</span><span class="s3">&quot;,&quot;</span><span class="s0">selfClosing</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">name</span><span class="s3">&quot;,&quot;</span><span class="s0">attributes</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">JSX</span><span class="s3">&quot;,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;],fields:{name:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">JSXIdentifier</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXMemberExpression</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXNamespacedName</span><span class="s3">&quot;)},selfClosing:{default:!1},attributes:{validate:(0,n.chain)((0,n.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,n.assertEach)((0,n.assertNodeType)(&quot;</span><span class="s0">JSXAttribute</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXSpreadAttribute</span><span class="s3">&quot;)))},typeParameters:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">TypeParameterInstantiation</span><span class="s3">&quot;,&quot;</span><span class="s0">TSTypeParameterInstantiation</span><span class="s3">&quot;),optional:!0}}}),(0,n.default)(&quot;</span><span class="s0">JSXSpreadAttribute</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">JSX</span><span class="s3">&quot;],fields:{argument:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}}),(0,n.default)(&quot;</span><span class="s0">JSXText</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">JSX</span><span class="s3">&quot;,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;],builder:[&quot;</span><span class="s0">value</span><span class="s3">&quot;],fields:{value:{validate:(0,n.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;)}}}),(0,n.default)(&quot;</span><span class="s0">JSXFragment</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">openingFragment</span><span class="s3">&quot;,&quot;</span><span class="s0">closingFragment</span><span class="s3">&quot;,&quot;</span><span class="s0">children</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">openingFragment</span><span class="s3">&quot;,&quot;</span><span class="s0">children</span><span class="s3">&quot;,&quot;</span><span class="s0">closingFragment</span><span class="s3">&quot;],aliases:[&quot;</span><span class="s0">JSX</span><span class="s3">&quot;,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;,&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],fields:{openingFragment:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">JSXOpeningFragment</span><span class="s3">&quot;)},closingFragment:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">JSXClosingFragment</span><span class="s3">&quot;)},children:{validate:(0,n.chain)((0,n.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,n.assertEach)((0,n.assertNodeType)(&quot;</span><span class="s0">JSXText</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXExpressionContainer</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXSpreadChild</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXElement</span><span class="s3">&quot;,&quot;</span><span class="s0">JSXFragment</span><span class="s3">&quot;)))}}}),(0,n.default)(&quot;</span><span class="s0">JSXOpeningFragment</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">JSX</span><span class="s3">&quot;,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;]}),(0,n.default)(&quot;</span><span class="s0">JSXClosingFragment</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">JSX</span><span class="s3">&quot;,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;]})},9710:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;var n=function(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;</span><span class="s0">object</span><span class="s3">&quot;!=typeof e&amp;&amp;&quot;</span><span class="s1">function</span><span class="s3">&quot;!=typeof e)return{default:e};var t=s();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=n?Object.getOwnPropertyDescriptor(e,i):null;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,i,a):r[i]=e[i]}return r.default=e,t&amp;&amp;t.set(e,r),r}(r(6343)),i=r(1093);function s(){if(&quot;</span><span class="s1">function</span><span class="s3">&quot;!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}(0,n.default)(&quot;</span><span class="s0">Noop</span><span class="s3">&quot;,{visitor:[]}),(0,n.default)(&quot;</span><span class="s0">Placeholder</span><span class="s3">&quot;,{visitor:[],builder:[&quot;</span><span class="s0">expectedNode</span><span class="s3">&quot;,&quot;</span><span class="s0">name</span><span class="s3">&quot;],fields:{name:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;)},expectedNode:{validate:(0,n.assertOneOf)(...i.PLACEHOLDERS)}}}),(0,n.default)(&quot;</span><span class="s0">V8IntrinsicIdentifier</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">name</span><span class="s3">&quot;],fields:{name:{validate:(0,n.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;)}}})},1093:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.PLACEHOLDERS_FLIPPED_ALIAS=t.PLACEHOLDERS_ALIAS=t.PLACEHOLDERS=void 0;var n=r(6343);const i=[&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;,&quot;</span><span class="s0">Expression</span><span class="s3">&quot;,&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;,&quot;</span><span class="s0">ClassBody</span><span class="s3">&quot;,&quot;</span><span class="s0">Pattern</span><span class="s3">&quot;];t.PLACEHOLDERS=i;const s={Declaration:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;],Pattern:[&quot;</span><span class="s0">PatternLike</span><span class="s3">&quot;,&quot;</span><span class="s0">LVal</span><span class="s3">&quot;]};t.PLACEHOLDERS_ALIAS=s;for(const e of i){const t=n.ALIAS_KEYS[e];(null==t?void 0:t.length)&amp;&amp;(s[e]=t)}const a={};t.PLACEHOLDERS_FLIPPED_ALIAS=a,Object.keys(s).forEach((e=&gt;{s[e].forEach((t=&gt;{Object.hasOwnProperty.call(a,t)||(a[t]=[]),a[t].push(e)}))}))},4544:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;var n=function(e){if(e&amp;&amp;e.__esModule)return e;if(null===e||&quot;</span><span class="s0">object</span><span class="s3">&quot;!=typeof e&amp;&amp;&quot;</span><span class="s1">function</span><span class="s3">&quot;!=typeof e)return{default:e};var t=s();if(t&amp;&amp;t.has(e))return t.get(e);var r={},n=Object.defineProperty&amp;&amp;Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=n?Object.getOwnPropertyDescriptor(e,i):null;a&amp;&amp;(a.get||a.set)?Object.defineProperty(r,i,a):r[i]=e[i]}return r.default=e,t&amp;&amp;t.set(e,r),r}(r(6343)),i=r(4613);function s(){if(&quot;</span><span class="s1">function</span><span class="s3">&quot;!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}const a=(0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),o={returnType:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">TSTypeAnnotation</span><span class="s3">&quot;,&quot;</span><span class="s0">Noop</span><span class="s3">&quot;),optional:!0},typeParameters:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">TSTypeParameterDeclaration</span><span class="s3">&quot;,&quot;</span><span class="s0">Noop</span><span class="s3">&quot;),optional:!0}};(0,n.default)(&quot;</span><span class="s0">TSParameterProperty</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">LVal</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">parameter</span><span class="s3">&quot;],fields:{accessibility:{validate:(0,n.assertOneOf)(&quot;</span><span class="s0">public</span><span class="s3">&quot;,&quot;</span><span class="s0">private</span><span class="s3">&quot;,&quot;</span><span class="s0">protected</span><span class="s3">&quot;),optional:!0},readonly:{validate:(0,n.assertValueType)(&quot;</span><span class="s0">boolean</span><span class="s3">&quot;),optional:!0},parameter:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">AssignmentPattern</span><span class="s3">&quot;)}}}),(0,n.default)(&quot;</span><span class="s0">TSDeclareFunction</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">params</span><span class="s3">&quot;,&quot;</span><span class="s0">returnType</span><span class="s3">&quot;],fields:Object.assign({},i.functionDeclarationCommon,o)}),(0,n.default)(&quot;</span><span class="s0">TSDeclareMethod</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">decorators</span><span class="s3">&quot;,&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">params</span><span class="s3">&quot;,&quot;</span><span class="s0">returnType</span><span class="s3">&quot;],fields:Object.assign({},i.classMethodOrDeclareMethodCommon,o)}),(0,n.default)(&quot;</span><span class="s0">TSQualifiedName</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSEntityName</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">left</span><span class="s3">&quot;,&quot;</span><span class="s0">right</span><span class="s3">&quot;],fields:{left:(0,n.validateType)(&quot;</span><span class="s0">TSEntityName</span><span class="s3">&quot;),right:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;)}});const l={typeParameters:(0,n.validateOptionalType)(&quot;</span><span class="s0">TSTypeParameterDeclaration</span><span class="s3">&quot;),parameters:(0,n.validateArrayOfType)([&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">RestElement</span><span class="s3">&quot;]),typeAnnotation:(0,n.validateOptionalType)(&quot;</span><span class="s0">TSTypeAnnotation</span><span class="s3">&quot;)},p={aliases:[&quot;</span><span class="s0">TSTypeElement</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">parameters</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],fields:l};(0,n.default)(&quot;</span><span class="s0">TSCallSignatureDeclaration</span><span class="s3">&quot;,p),(0,n.default)(&quot;</span><span class="s0">TSConstructSignatureDeclaration</span><span class="s3">&quot;,p);const c={key:(0,n.validateType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;),computed:(0,n.validate)(a),optional:(0,n.validateOptional)(a)};(0,n.default)(&quot;</span><span class="s0">TSPropertySignature</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSTypeElement</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;,&quot;</span><span class="s0">initializer</span><span class="s3">&quot;],fields:Object.assign({},c,{readonly:(0,n.validateOptional)(a),typeAnnotation:(0,n.validateOptionalType)(&quot;</span><span class="s0">TSTypeAnnotation</span><span class="s3">&quot;),initializer:(0,n.validateOptionalType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)})}),(0,n.default)(&quot;</span><span class="s0">TSMethodSignature</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSTypeElement</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">key</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">parameters</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],fields:Object.assign({},l,c)}),(0,n.default)(&quot;</span><span class="s0">TSIndexSignature</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSTypeElement</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">parameters</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],fields:{readonly:(0,n.validateOptional)(a),parameters:(0,n.validateArrayOfType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),typeAnnotation:(0,n.validateOptionalType)(&quot;</span><span class="s0">TSTypeAnnotation</span><span class="s3">&quot;)}});const u=[&quot;</span><span class="s0">TSAnyKeyword</span><span class="s3">&quot;,&quot;</span><span class="s0">TSBooleanKeyword</span><span class="s3">&quot;,&quot;</span><span class="s0">TSBigIntKeyword</span><span class="s3">&quot;,&quot;</span><span class="s0">TSIntrinsicKeyword</span><span class="s3">&quot;,&quot;</span><span class="s0">TSNeverKeyword</span><span class="s3">&quot;,&quot;</span><span class="s0">TSNullKeyword</span><span class="s3">&quot;,&quot;</span><span class="s0">TSNumberKeyword</span><span class="s3">&quot;,&quot;</span><span class="s0">TSObjectKeyword</span><span class="s3">&quot;,&quot;</span><span class="s0">TSStringKeyword</span><span class="s3">&quot;,&quot;</span><span class="s0">TSSymbolKeyword</span><span class="s3">&quot;,&quot;</span><span class="s0">TSUndefinedKeyword</span><span class="s3">&quot;,&quot;</span><span class="s0">TSUnknownKeyword</span><span class="s3">&quot;,&quot;</span><span class="s0">TSVoidKeyword</span><span class="s3">&quot;];for(const e of u)(0,n.default)(e,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;,&quot;</span><span class="s0">TSBaseType</span><span class="s3">&quot;],visitor:[],fields:{}});(0,n.default)(&quot;</span><span class="s0">TSThisType</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;,&quot;</span><span class="s0">TSBaseType</span><span class="s3">&quot;],visitor:[],fields:{}});const d={aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">parameters</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],fields:l};(0,n.default)(&quot;</span><span class="s0">TSFunctionType</span><span class="s3">&quot;,d),(0,n.default)(&quot;</span><span class="s0">TSConstructorType</span><span class="s3">&quot;,d),(0,n.default)(&quot;</span><span class="s0">TSTypeReference</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">typeName</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;],fields:{typeName:(0,n.validateType)(&quot;</span><span class="s0">TSEntityName</span><span class="s3">&quot;),typeParameters:(0,n.validateOptionalType)(&quot;</span><span class="s0">TSTypeParameterInstantiation</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSTypePredicate</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">parameterName</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],builder:[&quot;</span><span class="s0">parameterName</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;,&quot;</span><span class="s0">asserts</span><span class="s3">&quot;],fields:{parameterName:(0,n.validateType)([&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">TSThisType</span><span class="s3">&quot;]),typeAnnotation:(0,n.validateOptionalType)(&quot;</span><span class="s0">TSTypeAnnotation</span><span class="s3">&quot;),asserts:(0,n.validateOptional)(a)}}),(0,n.default)(&quot;</span><span class="s0">TSTypeQuery</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">exprName</span><span class="s3">&quot;],fields:{exprName:(0,n.validateType)([&quot;</span><span class="s0">TSEntityName</span><span class="s3">&quot;,&quot;</span><span class="s0">TSImportType</span><span class="s3">&quot;])}}),(0,n.default)(&quot;</span><span class="s0">TSTypeLiteral</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">members</span><span class="s3">&quot;],fields:{members:(0,n.validateArrayOfType)(&quot;</span><span class="s0">TSTypeElement</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSArrayType</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">elementType</span><span class="s3">&quot;],fields:{elementType:(0,n.validateType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSTupleType</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">elementTypes</span><span class="s3">&quot;],fields:{elementTypes:(0,n.validateArrayOfType)([&quot;</span><span class="s0">TSType</span><span class="s3">&quot;,&quot;</span><span class="s0">TSNamedTupleMember</span><span class="s3">&quot;])}}),(0,n.default)(&quot;</span><span class="s0">TSOptionalType</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],fields:{typeAnnotation:(0,n.validateType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSRestType</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],fields:{typeAnnotation:(0,n.validateType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSNamedTupleMember</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">label</span><span class="s3">&quot;,&quot;</span><span class="s0">elementType</span><span class="s3">&quot;],builder:[&quot;</span><span class="s0">label</span><span class="s3">&quot;,&quot;</span><span class="s0">elementType</span><span class="s3">&quot;,&quot;</span><span class="s0">optional</span><span class="s3">&quot;],fields:{label:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),optional:{validate:a,default:!1},elementType:(0,n.validateType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;)}});const h={aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">types</span><span class="s3">&quot;],fields:{types:(0,n.validateArrayOfType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;)}};(0,n.default)(&quot;</span><span class="s0">TSUnionType</span><span class="s3">&quot;,h),(0,n.default)(&quot;</span><span class="s0">TSIntersectionType</span><span class="s3">&quot;,h),(0,n.default)(&quot;</span><span class="s0">TSConditionalType</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">checkType</span><span class="s3">&quot;,&quot;</span><span class="s0">extendsType</span><span class="s3">&quot;,&quot;</span><span class="s0">trueType</span><span class="s3">&quot;,&quot;</span><span class="s0">falseType</span><span class="s3">&quot;],fields:{checkType:(0,n.validateType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;),extendsType:(0,n.validateType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;),trueType:(0,n.validateType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;),falseType:(0,n.validateType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSInferType</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">typeParameter</span><span class="s3">&quot;],fields:{typeParameter:(0,n.validateType)(&quot;</span><span class="s0">TSTypeParameter</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSParenthesizedType</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],fields:{typeAnnotation:(0,n.validateType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSTypeOperator</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],fields:{operator:(0,n.validate)((0,n.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;)),typeAnnotation:(0,n.validateType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSIndexedAccessType</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">objectType</span><span class="s3">&quot;,&quot;</span><span class="s0">indexType</span><span class="s3">&quot;],fields:{objectType:(0,n.validateType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;),indexType:(0,n.validateType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSMappedType</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">typeParameter</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;,&quot;</span><span class="s0">nameType</span><span class="s3">&quot;],fields:{readonly:(0,n.validateOptional)(a),typeParameter:(0,n.validateType)(&quot;</span><span class="s0">TSTypeParameter</span><span class="s3">&quot;),optional:(0,n.validateOptional)(a),typeAnnotation:(0,n.validateOptionalType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;),nameType:(0,n.validateOptionalType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSLiteralType</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;,&quot;</span><span class="s0">TSBaseType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">literal</span><span class="s3">&quot;],fields:{literal:(0,n.validateType)([&quot;</span><span class="s0">NumericLiteral</span><span class="s3">&quot;,&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;,&quot;</span><span class="s0">BooleanLiteral</span><span class="s3">&quot;,&quot;</span><span class="s0">BigIntLiteral</span><span class="s3">&quot;])}}),(0,n.default)(&quot;</span><span class="s0">TSExpressionWithTypeArguments</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">expression</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;],fields:{expression:(0,n.validateType)(&quot;</span><span class="s0">TSEntityName</span><span class="s3">&quot;),typeParameters:(0,n.validateOptionalType)(&quot;</span><span class="s0">TSTypeParameterInstantiation</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSInterfaceDeclaration</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">extends</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],fields:{declare:(0,n.validateOptional)(a),id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),typeParameters:(0,n.validateOptionalType)(&quot;</span><span class="s0">TSTypeParameterDeclaration</span><span class="s3">&quot;),extends:(0,n.validateOptional)((0,n.arrayOfType)(&quot;</span><span class="s0">TSExpressionWithTypeArguments</span><span class="s3">&quot;)),body:(0,n.validateType)(&quot;</span><span class="s0">TSInterfaceBody</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSInterfaceBody</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">body</span><span class="s3">&quot;],fields:{body:(0,n.validateArrayOfType)(&quot;</span><span class="s0">TSTypeElement</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSTypeAliasDeclaration</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],fields:{declare:(0,n.validateOptional)(a),id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),typeParameters:(0,n.validateOptionalType)(&quot;</span><span class="s0">TSTypeParameterDeclaration</span><span class="s3">&quot;),typeAnnotation:(0,n.validateType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSAsExpression</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">expression</span><span class="s3">&quot;,&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],fields:{expression:(0,n.validateType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;),typeAnnotation:(0,n.validateType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSTypeAssertion</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;,&quot;</span><span class="s0">expression</span><span class="s3">&quot;],fields:{typeAnnotation:(0,n.validateType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;),expression:(0,n.validateType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSEnumDeclaration</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">members</span><span class="s3">&quot;],fields:{declare:(0,n.validateOptional)(a),const:(0,n.validateOptional)(a),id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),members:(0,n.validateArrayOfType)(&quot;</span><span class="s0">TSEnumMember</span><span class="s3">&quot;),initializer:(0,n.validateOptionalType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSEnumMember</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">initializer</span><span class="s3">&quot;],fields:{id:(0,n.validateType)([&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;]),initializer:(0,n.validateOptionalType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSModuleDeclaration</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;,&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">body</span><span class="s3">&quot;],fields:{declare:(0,n.validateOptional)(a),global:(0,n.validateOptional)(a),id:(0,n.validateType)([&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;,&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;]),body:(0,n.validateType)([&quot;</span><span class="s0">TSModuleBlock</span><span class="s3">&quot;,&quot;</span><span class="s0">TSModuleDeclaration</span><span class="s3">&quot;])}}),(0,n.default)(&quot;</span><span class="s0">TSModuleBlock</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;,&quot;</span><span class="s0">Block</span><span class="s3">&quot;,&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">body</span><span class="s3">&quot;],fields:{body:(0,n.validateArrayOfType)(&quot;</span><span class="s0">Statement</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSImportType</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">TSType</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;,&quot;</span><span class="s0">qualifier</span><span class="s3">&quot;,&quot;</span><span class="s0">typeParameters</span><span class="s3">&quot;],fields:{argument:(0,n.validateType)(&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;),qualifier:(0,n.validateOptionalType)(&quot;</span><span class="s0">TSEntityName</span><span class="s3">&quot;),typeParameters:(0,n.validateOptionalType)(&quot;</span><span class="s0">TSTypeParameterInstantiation</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSImportEqualsDeclaration</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">moduleReference</span><span class="s3">&quot;],fields:{isExport:(0,n.validate)(a),id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;),moduleReference:(0,n.validateType)([&quot;</span><span class="s0">TSEntityName</span><span class="s3">&quot;,&quot;</span><span class="s0">TSExternalModuleReference</span><span class="s3">&quot;])}}),(0,n.default)(&quot;</span><span class="s0">TSExternalModuleReference</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">expression</span><span class="s3">&quot;],fields:{expression:(0,n.validateType)(&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSNonNullExpression</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Expression</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">expression</span><span class="s3">&quot;],fields:{expression:(0,n.validateType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSExportAssignment</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">expression</span><span class="s3">&quot;],fields:{expression:(0,n.validateType)(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSNamespaceExportDeclaration</span><span class="s3">&quot;,{aliases:[&quot;</span><span class="s0">Statement</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],fields:{id:(0,n.validateType)(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;)}}),(0,n.default)(&quot;</span><span class="s0">TSTypeAnnotation</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">typeAnnotation</span><span class="s3">&quot;],fields:{typeAnnotation:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;)}}}),(0,n.default)(&quot;</span><span class="s0">TSTypeParameterInstantiation</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">params</span><span class="s3">&quot;],fields:{params:{validate:(0,n.chain)((0,n.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,n.assertEach)((0,n.assertNodeType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;)))}}}),(0,n.default)(&quot;</span><span class="s0">TSTypeParameterDeclaration</span><span class="s3">&quot;,{visitor:[&quot;</span><span class="s0">params</span><span class="s3">&quot;],fields:{params:{validate:(0,n.chain)((0,n.assertValueType)(&quot;</span><span class="s0">array</span><span class="s3">&quot;),(0,n.assertEach)((0,n.assertNodeType)(&quot;</span><span class="s0">TSTypeParameter</span><span class="s3">&quot;)))}}}),(0,n.default)(&quot;</span><span class="s0">TSTypeParameter</span><span class="s3">&quot;,{builder:[&quot;</span><span class="s0">constraint</span><span class="s3">&quot;,&quot;</span><span class="s1">default</span><span class="s3">&quot;,&quot;</span><span class="s0">name</span><span class="s3">&quot;],visitor:[&quot;</span><span class="s0">constraint</span><span class="s3">&quot;,&quot;</span><span class="s1">default</span><span class="s3">&quot;],fields:{name:{validate:(0,n.assertValueType)(&quot;</span><span class="s0">string</span><span class="s3">&quot;)},constraint:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;),optional:!0},default:{validate:(0,n.assertNodeType)(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;),optional:!0}}})},6343:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;var n=r(397);Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.validate=m,t.typeIs=y,t.validateType=function(e){return m(y(e))},t.validateOptional=function(e){return{validate:e,optional:!0}},t.validateOptionalType=function(e){return{validate:y(e),optional:!0}},t.arrayOf=T,t.arrayOfType=b,t.validateArrayOfType=function(e){return m(b(e))},t.assertEach=g,t.assertOneOf=function(...e){function t(t,r,n){if(e.indexOf(n)&lt;0)throw new TypeError(`Property ${r} expected value to be one of ${JSON.stringify(e)} but got ${JSON.stringify(n)}`)}return t.oneOf=e,t},t.assertNodeType=S,t.assertNodeOrValueType=function(...e){function t(t,r,n){for(const i of e)if(f(n)===i||(0,s.default)(i,n))return void(0,a.validateChild)(t,r,n);throw new TypeError(`Property ${r} of ${t.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(null==n?void 0:n.type)}`)}return t.oneOfNodeOrValueTypes=e,t},t.assertValueType=x,t.assertShape=function(e){function t(t,r,n){const i=[];for(const r of Object.keys(e))try{(0,a.validateField)(t,r,n[r],e[r])}catch(e){if(e instanceof TypeError){i.push(e.message);continue}throw e}if(i.length)throw new TypeError(`Property ${r} of ${t.type} expected to have the following:</span><span class="s4">\n</span><span class="s3">${i.join(&quot;</span><span class="s0">\n</span><span class="s3">&quot;)}`)}return t.shapeOf=e,t},t.assertOptionalChainStart=function(){return function(e){var t;let r=e;for(;e;){const{type:e}=r;if(&quot;</span><span class="s0">OptionalCallExpression</span><span class="s3">&quot;!==e){if(&quot;</span><span class="s0">OptionalMemberExpression</span><span class="s3">&quot;!==e)break;if(r.optional)return;r=r.object}else{if(r.optional)return;r=r.callee}}throw new TypeError(`Non-optional ${e.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${null==(t=r)?void 0:t.type}`)}},t.chain=E,t.default=function(e,t={}){const r=t.inherits&amp;&amp;A[t.inherits]||{};let n=t.fields;if(!n&amp;&amp;(n={},r.fields)){const e=Object.getOwnPropertyNames(r.fields);for(const t of e){const e=r.fields[t];n[t]={default:e.default,optional:e.optional,validate:e.validate}}}const i=t.visitor||r.visitor||[],s=t.aliases||r.aliases||[],a=t.builder||r.builder||t.visitor||[];for(const r of Object.keys(t))if(-1===P.indexOf(r))throw new Error(`Unknown type option &quot;</span><span class="s0">${r}</span><span class="s3">&quot; on ${e}`);t.deprecatedAlias&amp;&amp;(d[t.deprecatedAlias]=e);for(const e of i.concat(a))n[e]=n[e]||{};for(const t of Object.keys(n)){const r=n[t];void 0!==r.default&amp;&amp;-1===a.indexOf(t)&amp;&amp;(r.optional=!0),void 0===r.default?r.default=null:r.validate||null==r.default||(r.validate=x(f(r.default)));for(const n of Object.keys(r))if(-1===v.indexOf(n))throw new Error(`Unknown field key &quot;</span><span class="s0">${n}</span><span class="s3">&quot; on ${e}.${t}`)}o[e]=t.visitor=i,u[e]=t.builder=a,c[e]=t.fields=n,l[e]=t.aliases=s,s.forEach((t=&gt;{p[t]=p[t]||[],p[t].push(e)})),t.validate&amp;&amp;(h[e]=t.validate),A[e]=t},t.NODE_PARENT_VALIDATIONS=t.DEPRECATED_KEYS=t.BUILDER_KEYS=t.NODE_FIELDS=t.FLIPPED_ALIAS_KEYS=t.ALIAS_KEYS=t.VISITOR_KEYS=void 0;var i,s=(i=r(6593))&amp;&amp;i.__esModule?i:{default:i},a=r(9623);const o={};t.VISITOR_KEYS=o;const l={};t.ALIAS_KEYS=l;const p={};t.FLIPPED_ALIAS_KEYS=p;const c={};t.NODE_FIELDS=c;const u={};t.BUILDER_KEYS=u;const d={};t.DEPRECATED_KEYS=d;const h={};function f(e){return Array.isArray(e)?&quot;</span><span class="s0">array</span><span class="s3">&quot;:null===e?&quot;</span><span class="s1">null</span><span class="s3">&quot;:typeof e}function m(e){return{validate:e}}function y(e){return&quot;</span><span class="s0">string</span><span class="s3">&quot;==typeof e?S(e):S(...e)}function T(e){return E(x(&quot;</span><span class="s0">array</span><span class="s3">&quot;),g(e))}function b(e){return T(y(e))}function g(e){function t(t,r,i){if(Array.isArray(i))for(let s=0;s&lt;i.length;s++){const o=`${r}[${s}]`,l=i[s];e(t,o,l),n.env.BABEL_TYPES_8_BREAKING&amp;&amp;(0,a.validateChild)(t,o,l)}}return t.each=e,t}function S(...e){function t(t,r,n){for(const i of e)if((0,s.default)(i,n))return void(0,a.validateChild)(t,r,n);throw new TypeError(`Property ${r} of ${t.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(null==n?void 0:n.type)}`)}return t.oneOfNodeTypes=e,t}function x(e){function t(t,r,n){if(f(n)!==e)throw new TypeError(`Property ${r} expected type of ${e} but got ${f(n)}`)}return t.type=e,t}function E(...e){function t(...t){for(const r of e)r(...t)}return t.chainOf=e,t}t.NODE_PARENT_VALIDATIONS=h;const P=[&quot;</span><span class="s0">aliases</span><span class="s3">&quot;,&quot;</span><span class="s0">builder</span><span class="s3">&quot;,&quot;</span><span class="s0">deprecatedAlias</span><span class="s3">&quot;,&quot;</span><span class="s0">fields</span><span class="s3">&quot;,&quot;</span><span class="s0">inherits</span><span class="s3">&quot;,&quot;</span><span class="s0">visitor</span><span class="s3">&quot;,&quot;</span><span class="s0">validate</span><span class="s3">&quot;],v=[&quot;</span><span class="s1">default</span><span class="s3">&quot;,&quot;</span><span class="s0">optional</span><span class="s3">&quot;,&quot;</span><span class="s0">validate</span><span class="s3">&quot;],A={}},1710:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0});var n={react:!0,assertNode:!0,createTypeAnnotationBasedOnTypeof:!0,createUnionTypeAnnotation:!0,createFlowUnionType:!0,createTSUnionType:!0,cloneNode:!0,clone:!0,cloneDeep:!0,cloneDeepWithoutLoc:!0,cloneWithoutLoc:!0,addComment:!0,addComments:!0,inheritInnerComments:!0,inheritLeadingComments:!0,inheritsComments:!0,inheritTrailingComments:!0,removeComments:!0,ensureBlock:!0,toBindingIdentifierName:!0,toBlock:!0,toComputedKey:!0,toExpression:!0,toIdentifier:!0,toKeyAlias:!0,toSequenceExpression:!0,toStatement:!0,valueToNode:!0,appendToMemberExpression:!0,inherits:!0,prependToMemberExpression:!0,removeProperties:!0,removePropertiesDeep:!0,removeTypeDuplicates:!0,getBindingIdentifiers:!0,getOuterBindingIdentifiers:!0,traverse:!0,traverseFast:!0,shallowEqual:!0,is:!0,isBinding:!0,isBlockScoped:!0,isImmutable:!0,isLet:!0,isNode:!0,isNodesEquivalent:!0,isPlaceholderType:!0,isReferenced:!0,isScope:!0,isSpecifierDefault:!0,isType:!0,isValidES3Identifier:!0,isValidIdentifier:!0,isVar:!0,matchesPattern:!0,validate:!0,buildMatchMemberExpression:!0};Object.defineProperty(t,&quot;</span><span class="s0">assertNode</span><span class="s3">&quot;,{enumerable:!0,get:function(){return o.default}}),Object.defineProperty(t,&quot;</span><span class="s0">createTypeAnnotationBasedOnTypeof</span><span class="s3">&quot;,{enumerable:!0,get:function(){return p.default}}),Object.defineProperty(t,&quot;</span><span class="s0">createUnionTypeAnnotation</span><span class="s3">&quot;,{enumerable:!0,get:function(){return c.default}}),Object.defineProperty(t,&quot;</span><span class="s0">createFlowUnionType</span><span class="s3">&quot;,{enumerable:!0,get:function(){return c.default}}),Object.defineProperty(t,&quot;</span><span class="s0">createTSUnionType</span><span class="s3">&quot;,{enumerable:!0,get:function(){return u.default}}),Object.defineProperty(t,&quot;</span><span class="s0">cloneNode</span><span class="s3">&quot;,{enumerable:!0,get:function(){return h.default}}),Object.defineProperty(t,&quot;</span><span class="s0">clone</span><span class="s3">&quot;,{enumerable:!0,get:function(){return f.default}}),Object.defineProperty(t,&quot;</span><span class="s0">cloneDeep</span><span class="s3">&quot;,{enumerable:!0,get:function(){return m.default}}),Object.defineProperty(t,&quot;</span><span class="s0">cloneDeepWithoutLoc</span><span class="s3">&quot;,{enumerable:!0,get:function(){return y.default}}),Object.defineProperty(t,&quot;</span><span class="s0">cloneWithoutLoc</span><span class="s3">&quot;,{enumerable:!0,get:function(){return T.default}}),Object.defineProperty(t,&quot;</span><span class="s0">addComment</span><span class="s3">&quot;,{enumerable:!0,get:function(){return b.default}}),Object.defineProperty(t,&quot;</span><span class="s0">addComments</span><span class="s3">&quot;,{enumerable:!0,get:function(){return g.default}}),Object.defineProperty(t,&quot;</span><span class="s0">inheritInnerComments</span><span class="s3">&quot;,{enumerable:!0,get:function(){return S.default}}),Object.defineProperty(t,&quot;</span><span class="s0">inheritLeadingComments</span><span class="s3">&quot;,{enumerable:!0,get:function(){return x.default}}),Object.defineProperty(t,&quot;</span><span class="s0">inheritsComments</span><span class="s3">&quot;,{enumerable:!0,get:function(){return E.default}}),Object.defineProperty(t,&quot;</span><span class="s0">inheritTrailingComments</span><span class="s3">&quot;,{enumerable:!0,get:function(){return P.default}}),Object.defineProperty(t,&quot;</span><span class="s0">removeComments</span><span class="s3">&quot;,{enumerable:!0,get:function(){return v.default}}),Object.defineProperty(t,&quot;</span><span class="s0">ensureBlock</span><span class="s3">&quot;,{enumerable:!0,get:function(){return O.default}}),Object.defineProperty(t,&quot;</span><span class="s0">toBindingIdentifierName</span><span class="s3">&quot;,{enumerable:!0,get:function(){return I.default}}),Object.defineProperty(t,&quot;</span><span class="s0">toBlock</span><span class="s3">&quot;,{enumerable:!0,get:function(){return N.default}}),Object.defineProperty(t,&quot;</span><span class="s0">toComputedKey</span><span class="s3">&quot;,{enumerable:!0,get:function(){return C.default}}),Object.defineProperty(t,&quot;</span><span class="s0">toExpression</span><span class="s3">&quot;,{enumerable:!0,get:function(){return k.default}}),Object.defineProperty(t,&quot;</span><span class="s0">toIdentifier</span><span class="s3">&quot;,{enumerable:!0,get:function(){return D.default}}),Object.defineProperty(t,&quot;</span><span class="s0">toKeyAlias</span><span class="s3">&quot;,{enumerable:!0,get:function(){return _.default}}),Object.defineProperty(t,&quot;</span><span class="s0">toSequenceExpression</span><span class="s3">&quot;,{enumerable:!0,get:function(){return L.default}}),Object.defineProperty(t,&quot;</span><span class="s0">toStatement</span><span class="s3">&quot;,{enumerable:!0,get:function(){return M.default}}),Object.defineProperty(t,&quot;</span><span class="s0">valueToNode</span><span class="s3">&quot;,{enumerable:!0,get:function(){return j.default}}),Object.defineProperty(t,&quot;</span><span class="s0">appendToMemberExpression</span><span class="s3">&quot;,{enumerable:!0,get:function(){return B.default}}),Object.defineProperty(t,&quot;</span><span class="s0">inherits</span><span class="s3">&quot;,{enumerable:!0,get:function(){return R.default}}),Object.defineProperty(t,&quot;</span><span class="s0">prependToMemberExpression</span><span class="s3">&quot;,{enumerable:!0,get:function(){return U.default}}),Object.defineProperty(t,&quot;</span><span class="s0">removeProperties</span><span class="s3">&quot;,{enumerable:!0,get:function(){return V.default}}),Object.defineProperty(t,&quot;</span><span class="s0">removePropertiesDeep</span><span class="s3">&quot;,{enumerable:!0,get:function(){return K.default}}),Object.defineProperty(t,&quot;</span><span class="s0">removeTypeDuplicates</span><span class="s3">&quot;,{enumerable:!0,get:function(){return q.default}}),Object.defineProperty(t,&quot;</span><span class="s0">getBindingIdentifiers</span><span class="s3">&quot;,{enumerable:!0,get:function(){return Y.default}}),Object.defineProperty(t,&quot;</span><span class="s0">getOuterBindingIdentifiers</span><span class="s3">&quot;,{enumerable:!0,get:function(){return W.default}}),Object.defineProperty(t,&quot;</span><span class="s0">traverse</span><span class="s3">&quot;,{enumerable:!0,get:function(){return X.default}}),Object.defineProperty(t,&quot;</span><span class="s0">traverseFast</span><span class="s3">&quot;,{enumerable:!0,get:function(){return J.default}}),Object.defineProperty(t,&quot;</span><span class="s0">shallowEqual</span><span class="s3">&quot;,{enumerable:!0,get:function(){return H.default}}),Object.defineProperty(t,&quot;</span><span class="s0">is</span><span class="s3">&quot;,{enumerable:!0,get:function(){return G.default}}),Object.defineProperty(t,&quot;</span><span class="s0">isBinding</span><span class="s3">&quot;,{enumerable:!0,get:function(){return z.default}}),Object.defineProperty(t,&quot;</span><span class="s0">isBlockScoped</span><span class="s3">&quot;,{enumerable:!0,get:function(){return $.default}}),Object.defineProperty(t,&quot;</span><span class="s0">isImmutable</span><span class="s3">&quot;,{enumerable:!0,get:function(){return Q.default}}),Object.defineProperty(t,&quot;</span><span class="s0">isLet</span><span class="s3">&quot;,{enumerable:!0,get:function(){return Z.default}}),Object.defineProperty(t,&quot;</span><span class="s0">isNode</span><span class="s3">&quot;,{enumerable:!0,get:function(){return ee.default}}),Object.defineProperty(t,&quot;</span><span class="s0">isNodesEquivalent</span><span class="s3">&quot;,{enumerable:!0,get:function(){return te.default}}),Object.defineProperty(t,&quot;</span><span class="s0">isPlaceholderType</span><span class="s3">&quot;,{enumerable:!0,get:function(){return re.default}}),Object.defineProperty(t,&quot;</span><span class="s0">isReferenced</span><span class="s3">&quot;,{enumerable:!0,get:function(){return ne.default}}),Object.defineProperty(t,&quot;</span><span class="s0">isScope</span><span class="s3">&quot;,{enumerable:!0,get:function(){return ie.default}}),Object.defineProperty(t,&quot;</span><span class="s0">isSpecifierDefault</span><span class="s3">&quot;,{enumerable:!0,get:function(){return se.default}}),Object.defineProperty(t,&quot;</span><span class="s0">isType</span><span class="s3">&quot;,{enumerable:!0,get:function(){return ae.default}}),Object.defineProperty(t,&quot;</span><span class="s0">isValidES3Identifier</span><span class="s3">&quot;,{enumerable:!0,get:function(){return oe.default}}),Object.defineProperty(t,&quot;</span><span class="s0">isValidIdentifier</span><span class="s3">&quot;,{enumerable:!0,get:function(){return le.default}}),Object.defineProperty(t,&quot;</span><span class="s0">isVar</span><span class="s3">&quot;,{enumerable:!0,get:function(){return pe.default}}),Object.defineProperty(t,&quot;</span><span class="s0">matchesPattern</span><span class="s3">&quot;,{enumerable:!0,get:function(){return ce.default}}),Object.defineProperty(t,&quot;</span><span class="s0">validate</span><span class="s3">&quot;,{enumerable:!0,get:function(){return ue.default}}),Object.defineProperty(t,&quot;</span><span class="s0">buildMatchMemberExpression</span><span class="s3">&quot;,{enumerable:!0,get:function(){return de.default}}),t.react=void 0;var i=fe(r(5631)),s=fe(r(5124)),a=fe(r(4986)),o=fe(r(7010)),l=r(939);Object.keys(l).forEach((function(e){&quot;</span><span class="s1">default</span><span class="s3">&quot;!==e&amp;&amp;&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;!==e&amp;&amp;(Object.prototype.hasOwnProperty.call(n,e)||e in t&amp;&amp;t[e]===l[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return l[e]}}))}));var p=fe(r(5209)),c=fe(r(6535)),u=fe(r(7329)),d=r(3894);Object.keys(d).forEach((function(e){&quot;</span><span class="s1">default</span><span class="s3">&quot;!==e&amp;&amp;&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;!==e&amp;&amp;(Object.prototype.hasOwnProperty.call(n,e)||e in t&amp;&amp;t[e]===d[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return d[e]}}))}));var h=fe(r(539)),f=fe(r(5509)),m=fe(r(2107)),y=fe(r(2634)),T=fe(r(1225)),b=fe(r(8184)),g=fe(r(2243)),S=fe(r(440)),x=fe(r(9622)),E=fe(r(6168)),P=fe(r(9868)),v=fe(r(4670)),A=r(1798);Object.keys(A).forEach((function(e){&quot;</span><span class="s1">default</span><span class="s3">&quot;!==e&amp;&amp;&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;!==e&amp;&amp;(Object.prototype.hasOwnProperty.call(n,e)||e in t&amp;&amp;t[e]===A[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return A[e]}}))}));var w=r(9660);Object.keys(w).forEach((function(e){&quot;</span><span class="s1">default</span><span class="s3">&quot;!==e&amp;&amp;&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;!==e&amp;&amp;(Object.prototype.hasOwnProperty.call(n,e)||e in t&amp;&amp;t[e]===w[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return w[e]}}))}));var O=fe(r(6450)),I=fe(r(8681)),N=fe(r(130)),C=fe(r(940)),k=fe(r(2858)),D=fe(r(5450)),_=fe(r(8100)),L=fe(r(4914)),M=fe(r(2469)),j=fe(r(8626)),F=r(9829);Object.keys(F).forEach((function(e){&quot;</span><span class="s1">default</span><span class="s3">&quot;!==e&amp;&amp;&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;!==e&amp;&amp;(Object.prototype.hasOwnProperty.call(n,e)||e in t&amp;&amp;t[e]===F[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return F[e]}}))}));var B=fe(r(5854)),R=fe(r(9146)),U=fe(r(1274)),V=fe(r(1390)),K=fe(r(4888)),q=fe(r(4485)),Y=fe(r(3407)),W=fe(r(369)),X=fe(r(3877)),J=fe(r(5138)),H=fe(r(4951)),G=fe(r(6593)),z=fe(r(8979)),$=fe(r(4920)),Q=fe(r(738)),Z=fe(r(9954)),ee=fe(r(1784)),te=fe(r(5082)),re=fe(r(9186)),ne=fe(r(5794)),ie=fe(r(9057)),se=fe(r(9935)),ae=fe(r(9530)),oe=fe(r(6256)),le=fe(r(380)),pe=fe(r(1330)),ce=fe(r(6636)),ue=fe(r(9623)),de=fe(r(3972)),he=r(8037);function fe(e){return e&amp;&amp;e.__esModule?e:{default:e}}Object.keys(he).forEach((function(e){&quot;</span><span class="s1">default</span><span class="s3">&quot;!==e&amp;&amp;&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;!==e&amp;&amp;(Object.prototype.hasOwnProperty.call(n,e)||e in t&amp;&amp;t[e]===he[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return he[e]}}))}));const me={isReactComponent:i.default,isCompatTag:s.default,buildChildren:a.default};t.react=me},5854:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t,r=!1){return e.object=(0,n.memberExpression)(e.object,e.property,e.computed),e.property=t,e.computed=!!r,e};var n=r(3894)},4485:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function e(t){const r={},i={},s=[],a=[];for(let o=0;o&lt;t.length;o++){const l=t[o];if(l&amp;&amp;!(a.indexOf(l)&gt;=0)){if((0,n.isAnyTypeAnnotation)(l))return[l];if((0,n.isFlowBaseAnnotation)(l))i[l.type]=l;else if((0,n.isUnionTypeAnnotation)(l))s.indexOf(l.types)&lt;0&amp;&amp;(t=t.concat(l.types),s.push(l.types));else if((0,n.isGenericTypeAnnotation)(l)){const t=l.id.name;if(r[t]){let n=r[t];n.typeParameters?l.typeParameters&amp;&amp;(n.typeParameters.params=e(n.typeParameters.params.concat(l.typeParameters.params))):n=l.typeParameters}else r[t]=l}else a.push(l)}}for(const e of Object.keys(i))a.push(i[e]);for(const e of Object.keys(r))a.push(r[e]);return a};var n=r(8037)},9146:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t){if(!e||!t)return e;for(const r of i.INHERIT_KEYS.optional)null==e[r]&amp;&amp;(e[r]=t[r]);for(const r of Object.keys(t))&quot;</span><span class="s0">_</span><span class="s3">&quot;===r[0]&amp;&amp;&quot;</span><span class="s0">__clone</span><span class="s3">&quot;!==r&amp;&amp;(e[r]=t[r]);for(const r of i.INHERIT_KEYS.force)e[r]=t[r];return(0,s.default)(e,t),e};var n,i=r(9660),s=(n=r(6168))&amp;&amp;n.__esModule?n:{default:n}},1274:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t){return e.object=(0,n.memberExpression)(t,e.object),e};var n=r(3894)},1390:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t={}){const r=t.preserveComments?i:s;for(const t of r)null!=e[t]&amp;&amp;(e[t]=void 0);for(const t of Object.keys(e))&quot;</span><span class="s0">_</span><span class="s3">&quot;===t[0]&amp;&amp;null!=e[t]&amp;&amp;(e[t]=void 0);const n=Object.getOwnPropertySymbols(e);for(const t of n)e[t]=null};var n=r(9660);const i=[&quot;</span><span class="s0">tokens</span><span class="s3">&quot;,&quot;</span><span class="s0">start</span><span class="s3">&quot;,&quot;</span><span class="s0">end</span><span class="s3">&quot;,&quot;</span><span class="s0">loc</span><span class="s3">&quot;,&quot;</span><span class="s0">raw</span><span class="s3">&quot;,&quot;</span><span class="s0">rawValue</span><span class="s3">&quot;],s=n.COMMENT_KEYS.concat([&quot;</span><span class="s0">comments</span><span class="s3">&quot;]).concat(i)},4888:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t){return(0,n.default)(e,i.default,t),e};var n=s(r(5138)),i=s(r(1390));function s(e){return e&amp;&amp;e.__esModule?e:{default:e}}},2493:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e){const t={},r={},i=[],s=[];for(let t=0;t&lt;e.length;t++){const a=e[t];if(a&amp;&amp;!(s.indexOf(a)&gt;=0)){if((0,n.isTSAnyKeyword)(a.type))return[a];(0,n.isTSBaseType)(a)?r[a.type]=a:(0,n.isTSUnionType)(a)?i.indexOf(a.types)&lt;0&amp;&amp;(e=e.concat(a.types),i.push(a.types)):s.push(a)}}for(const e of Object.keys(r))s.push(r[e]);for(const e of Object.keys(t))s.push(t[e]);return s};var n=r(8037)},3407:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=i;var n=r(8037);function i(e,t,r){let s=[].concat(e);const a=Object.create(null);for(;s.length;){const e=s.shift();if(!e)continue;const o=i.keys[e.type];if((0,n.isIdentifier)(e))t?(a[e.name]=a[e.name]||[]).push(e):a[e.name]=e;else if((0,n.isExportDeclaration)(e))(0,n.isDeclaration)(e.declaration)&amp;&amp;s.push(e.declaration);else{if(r){if((0,n.isFunctionDeclaration)(e)){s.push(e.id);continue}if((0,n.isFunctionExpression)(e))continue}if(o)for(let t=0;t&lt;o.length;t++){const r=o[t];e[r]&amp;&amp;(s=s.concat(e[r]))}}}return a}i.keys={DeclareClass:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],DeclareFunction:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],DeclareModule:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],DeclareVariable:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],DeclareInterface:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],DeclareTypeAlias:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],DeclareOpaqueType:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],InterfaceDeclaration:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],TypeAlias:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],OpaqueType:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],CatchClause:[&quot;</span><span class="s0">param</span><span class="s3">&quot;],LabeledStatement:[&quot;</span><span class="s0">label</span><span class="s3">&quot;],UnaryExpression:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;],AssignmentExpression:[&quot;</span><span class="s0">left</span><span class="s3">&quot;],ImportSpecifier:[&quot;</span><span class="s0">local</span><span class="s3">&quot;],ImportNamespaceSpecifier:[&quot;</span><span class="s0">local</span><span class="s3">&quot;],ImportDefaultSpecifier:[&quot;</span><span class="s0">local</span><span class="s3">&quot;],ImportDeclaration:[&quot;</span><span class="s0">specifiers</span><span class="s3">&quot;],ExportSpecifier:[&quot;</span><span class="s0">exported</span><span class="s3">&quot;],ExportNamespaceSpecifier:[&quot;</span><span class="s0">exported</span><span class="s3">&quot;],ExportDefaultSpecifier:[&quot;</span><span class="s0">exported</span><span class="s3">&quot;],FunctionDeclaration:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">params</span><span class="s3">&quot;],FunctionExpression:[&quot;</span><span class="s0">id</span><span class="s3">&quot;,&quot;</span><span class="s0">params</span><span class="s3">&quot;],ArrowFunctionExpression:[&quot;</span><span class="s0">params</span><span class="s3">&quot;],ObjectMethod:[&quot;</span><span class="s0">params</span><span class="s3">&quot;],ClassMethod:[&quot;</span><span class="s0">params</span><span class="s3">&quot;],ForInStatement:[&quot;</span><span class="s0">left</span><span class="s3">&quot;],ForOfStatement:[&quot;</span><span class="s0">left</span><span class="s3">&quot;],ClassDeclaration:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],ClassExpression:[&quot;</span><span class="s0">id</span><span class="s3">&quot;],RestElement:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;],UpdateExpression:[&quot;</span><span class="s0">argument</span><span class="s3">&quot;],ObjectProperty:[&quot;</span><span class="s0">value</span><span class="s3">&quot;],AssignmentPattern:[&quot;</span><span class="s0">left</span><span class="s3">&quot;],ArrayPattern:[&quot;</span><span class="s0">elements</span><span class="s3">&quot;],ObjectPattern:[&quot;</span><span class="s0">properties</span><span class="s3">&quot;],VariableDeclaration:[&quot;</span><span class="s0">declarations</span><span class="s3">&quot;],VariableDeclarator:[&quot;</span><span class="s0">id</span><span class="s3">&quot;]}},369:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t){return(0,i.default)(e,t,!0)};var n,i=(n=r(3407))&amp;&amp;n.__esModule?n:{default:n}},3877:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t,r){&quot;</span><span class="s1">function</span><span class="s3">&quot;==typeof t&amp;&amp;(t={enter:t});const{enter:n,exit:s}=t;i(e,n,s,r,[])};var n=r(9829);function i(e,t,r,s,a){const o=n.VISITOR_KEYS[e.type];if(o){t&amp;&amp;t(e,a,s);for(const n of o){const o=e[n];if(Array.isArray(o))for(let l=0;l&lt;o.length;l++){const p=o[l];p&amp;&amp;(a.push({node:e,key:n,index:l}),i(p,t,r,s,a),a.pop())}else o&amp;&amp;(a.push({node:e,key:n}),i(o,t,r,s,a),a.pop())}r&amp;&amp;r(e,a,s)}}},5138:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function e(t,r,i){if(!t)return;const s=n.VISITOR_KEYS[t.type];if(s){r(t,i=i||{});for(const n of s){const s=t[n];if(Array.isArray(s))for(const t of s)e(t,r,i);else e(s,r,i)}}};var n=r(9829)},3450:(e,t)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t,r){t&amp;&amp;r&amp;&amp;(t[e]=Array.from(new Set([].concat(t[e],r[e]).filter(Boolean))))}},586:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t){const r=e.value.split(/</span><span class="s4">\r\n</span><span class="s3">|</span><span class="s4">\n</span><span class="s3">|</span><span class="s4">\r</span><span class="s3">/);let i=0;for(let e=0;e&lt;r.length;e++)r[e].match(/[^ </span><span class="s4">\t</span><span class="s3">]/)&amp;&amp;(i=e);let s=&quot;&quot;;for(let e=0;e&lt;r.length;e++){const t=r[e],n=0===e,a=e===r.length-1,o=e===i;let l=t.replace(/</span><span class="s4">\t</span><span class="s3">/g,&quot; &quot;);n||(l=l.replace(/^[ ]+/,&quot;&quot;)),a||(l=l.replace(/[ ]+$/,&quot;&quot;)),l&amp;&amp;(o||(l+=&quot; &quot;),s+=l)}s&amp;&amp;t.push((0,n.stringLiteral)(s))};var n=r(3894)},4951:(e,t)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t){const r=Object.keys(t);for(const n of r)if(e[n]!==t[n])return!1;return!0}},3972:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t){const r=e.split(&quot;</span><span class="s0">.</span><span class="s3">&quot;);return e=&gt;(0,i.default)(e,r,t)};var n,i=(n=r(6636))&amp;&amp;n.__esModule?n:{default:n}},8037:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.isArrayExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ArrayExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isAssignmentExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">AssignmentExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isBinaryExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">BinaryExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isInterpreterDirective=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">InterpreterDirective</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDirective=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">Directive</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDirectiveLiteral=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">DirectiveLiteral</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isBlockStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isBreakStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">BreakStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isCallExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">CallExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isCatchClause=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">CatchClause</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isConditionalExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ConditionalExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isContinueStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ContinueStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDebuggerStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">DebuggerStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDoWhileStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">DoWhileStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isEmptyStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">EmptyStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isExpressionStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ExpressionStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isFile=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">File</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isForInStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ForInStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isForStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ForStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isFunctionDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">FunctionDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isFunctionExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">FunctionExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isIdentifier=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isIfStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">IfStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isLabeledStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">LabeledStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isStringLiteral=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isNumericLiteral=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">NumericLiteral</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isNullLiteral=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">NullLiteral</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isBooleanLiteral=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">BooleanLiteral</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isRegExpLiteral=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">RegExpLiteral</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isLogicalExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">LogicalExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isMemberExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">MemberExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isNewExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">NewExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isProgram=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">Program</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isObjectExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ObjectExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isObjectMethod=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ObjectMethod</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isObjectProperty=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ObjectProperty</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isRestElement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">RestElement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isReturnStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ReturnStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isSequenceExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">SequenceExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isParenthesizedExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ParenthesizedExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isSwitchCase=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">SwitchCase</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isSwitchStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">SwitchStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isThisExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ThisExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isThrowStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ThrowStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTryStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TryStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isUnaryExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">UnaryExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isUpdateExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">UpdateExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isVariableDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">VariableDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isVariableDeclarator=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">VariableDeclarator</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isWhileStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">WhileStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isWithStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">WithStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isAssignmentPattern=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">AssignmentPattern</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isArrayPattern=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ArrayPattern</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isArrowFunctionExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ArrowFunctionExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isClassBody=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ClassBody</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isClassExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ClassExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isClassDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ClassDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isExportAllDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ExportAllDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isExportDefaultDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ExportDefaultDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isExportNamedDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ExportNamedDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isExportSpecifier=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ExportSpecifier</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isForOfStatement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ForOfStatement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isImportDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ImportDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isImportDefaultSpecifier=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ImportDefaultSpecifier</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isImportNamespaceSpecifier=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ImportNamespaceSpecifier</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isImportSpecifier=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ImportSpecifier</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isMetaProperty=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">MetaProperty</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isClassMethod=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ClassMethod</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isObjectPattern=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ObjectPattern</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isSpreadElement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">SpreadElement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isSuper=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">Super</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTaggedTemplateExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TaggedTemplateExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTemplateElement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TemplateElement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTemplateLiteral=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TemplateLiteral</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isYieldExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">YieldExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isAwaitExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">AwaitExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isImport=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">Import</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isBigIntLiteral=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">BigIntLiteral</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isExportNamespaceSpecifier=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ExportNamespaceSpecifier</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isOptionalMemberExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">OptionalMemberExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isOptionalCallExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">OptionalCallExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isAnyTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">AnyTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isArrayTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ArrayTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isBooleanTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">BooleanTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isBooleanLiteralTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">BooleanLiteralTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isNullLiteralTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">NullLiteralTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isClassImplements=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ClassImplements</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDeclareClass=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">DeclareClass</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDeclareFunction=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">DeclareFunction</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDeclareInterface=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">DeclareInterface</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDeclareModule=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">DeclareModule</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDeclareModuleExports=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">DeclareModuleExports</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDeclareTypeAlias=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">DeclareTypeAlias</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDeclareOpaqueType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">DeclareOpaqueType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDeclareVariable=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">DeclareVariable</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDeclareExportDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">DeclareExportDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDeclareExportAllDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">DeclareExportAllDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDeclaredPredicate=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">DeclaredPredicate</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isExistsTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ExistsTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isFunctionTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">FunctionTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isFunctionTypeParam=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">FunctionTypeParam</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isGenericTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">GenericTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isInferredPredicate=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">InferredPredicate</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isInterfaceExtends=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">InterfaceExtends</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isInterfaceDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">InterfaceDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isInterfaceTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">InterfaceTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isIntersectionTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">IntersectionTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isMixedTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">MixedTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isEmptyTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">EmptyTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isNullableTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">NullableTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isNumberLiteralTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">NumberLiteralTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isNumberTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">NumberTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isObjectTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ObjectTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isObjectTypeInternalSlot=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ObjectTypeInternalSlot</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isObjectTypeCallProperty=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ObjectTypeCallProperty</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isObjectTypeIndexer=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ObjectTypeIndexer</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isObjectTypeProperty=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ObjectTypeProperty</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isObjectTypeSpreadProperty=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ObjectTypeSpreadProperty</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isOpaqueType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">OpaqueType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isQualifiedTypeIdentifier=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">QualifiedTypeIdentifier</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isStringLiteralTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">StringLiteralTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isStringTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">StringTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isSymbolTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">SymbolTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isThisTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ThisTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTupleTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TupleTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTypeofTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TypeofTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTypeAlias=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TypeAlias</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTypeCastExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TypeCastExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTypeParameter=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TypeParameter</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTypeParameterDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TypeParameterDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTypeParameterInstantiation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TypeParameterInstantiation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isUnionTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">UnionTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isVariance=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">Variance</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isVoidTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">VoidTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isEnumDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">EnumDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isEnumBooleanBody=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">EnumBooleanBody</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isEnumNumberBody=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">EnumNumberBody</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isEnumStringBody=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">EnumStringBody</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isEnumSymbolBody=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">EnumSymbolBody</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isEnumBooleanMember=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">EnumBooleanMember</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isEnumNumberMember=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">EnumNumberMember</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isEnumStringMember=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">EnumStringMember</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isEnumDefaultedMember=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">EnumDefaultedMember</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isJSXAttribute=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">JSXAttribute</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isJSXClosingElement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">JSXClosingElement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isJSXElement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">JSXElement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isJSXEmptyExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">JSXEmptyExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isJSXExpressionContainer=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">JSXExpressionContainer</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isJSXSpreadChild=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">JSXSpreadChild</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isJSXIdentifier=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">JSXIdentifier</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isJSXMemberExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">JSXMemberExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isJSXNamespacedName=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">JSXNamespacedName</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isJSXOpeningElement=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">JSXOpeningElement</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isJSXSpreadAttribute=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">JSXSpreadAttribute</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isJSXText=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">JSXText</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isJSXFragment=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">JSXFragment</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isJSXOpeningFragment=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">JSXOpeningFragment</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isJSXClosingFragment=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">JSXClosingFragment</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isNoop=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">Noop</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isPlaceholder=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">Placeholder</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isV8IntrinsicIdentifier=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">V8IntrinsicIdentifier</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isArgumentPlaceholder=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ArgumentPlaceholder</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isBindExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">BindExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isClassProperty=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ClassProperty</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isPipelineTopicExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">PipelineTopicExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isPipelineBareFunction=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">PipelineBareFunction</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isPipelinePrimaryTopicReference=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">PipelinePrimaryTopicReference</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isClassPrivateProperty=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ClassPrivateProperty</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isClassPrivateMethod=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ClassPrivateMethod</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isImportAttribute=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ImportAttribute</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDecorator=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">Decorator</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDoExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">DoExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isExportDefaultSpecifier=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">ExportDefaultSpecifier</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isPrivateName=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">PrivateName</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isRecordExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">RecordExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTupleExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TupleExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isDecimalLiteral=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">DecimalLiteral</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isStaticBlock=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">StaticBlock</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSParameterProperty=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSParameterProperty</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSDeclareFunction=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSDeclareFunction</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSDeclareMethod=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSDeclareMethod</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSQualifiedName=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSQualifiedName</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSCallSignatureDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSCallSignatureDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSConstructSignatureDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSConstructSignatureDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSPropertySignature=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSPropertySignature</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSMethodSignature=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSMethodSignature</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSIndexSignature=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSIndexSignature</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSAnyKeyword=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSAnyKeyword</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSBooleanKeyword=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSBooleanKeyword</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSBigIntKeyword=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSBigIntKeyword</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSIntrinsicKeyword=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSIntrinsicKeyword</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSNeverKeyword=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSNeverKeyword</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSNullKeyword=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSNullKeyword</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSNumberKeyword=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSNumberKeyword</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSObjectKeyword=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSObjectKeyword</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSStringKeyword=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSStringKeyword</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSSymbolKeyword=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSSymbolKeyword</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSUndefinedKeyword=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSUndefinedKeyword</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSUnknownKeyword=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSUnknownKeyword</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSVoidKeyword=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSVoidKeyword</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSThisType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSThisType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSFunctionType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSFunctionType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSConstructorType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSConstructorType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSTypeReference=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSTypeReference</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSTypePredicate=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSTypePredicate</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSTypeQuery=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSTypeQuery</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSTypeLiteral=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSTypeLiteral</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSArrayType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSArrayType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSTupleType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSTupleType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSOptionalType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSOptionalType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSRestType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSRestType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSNamedTupleMember=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSNamedTupleMember</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSUnionType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSUnionType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSIntersectionType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSIntersectionType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSConditionalType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSConditionalType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSInferType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSInferType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSParenthesizedType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSParenthesizedType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSTypeOperator=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSTypeOperator</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSIndexedAccessType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSIndexedAccessType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSMappedType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSMappedType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSLiteralType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSLiteralType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSExpressionWithTypeArguments=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSExpressionWithTypeArguments</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSInterfaceDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSInterfaceDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSInterfaceBody=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSInterfaceBody</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSTypeAliasDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSTypeAliasDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSAsExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSAsExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSTypeAssertion=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSTypeAssertion</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSEnumDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSEnumDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSEnumMember=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSEnumMember</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSModuleDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSModuleDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSModuleBlock=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSModuleBlock</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSImportType=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSImportType</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSImportEqualsDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSImportEqualsDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSExternalModuleReference=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSExternalModuleReference</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSNonNullExpression=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSNonNullExpression</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSExportAssignment=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSExportAssignment</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSNamespaceExportDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSNamespaceExportDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSTypeAnnotation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSTypeAnnotation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSTypeParameterInstantiation=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSTypeParameterInstantiation</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSTypeParameterDeclaration=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSTypeParameterDeclaration</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isTSTypeParameter=function(e,t){return!!e&amp;&amp;(&quot;</span><span class="s0">TSTypeParameter</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isExpression=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ArrayExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">AssignmentExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BinaryExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">CallExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ConditionalExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">FunctionExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;===r||&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NumericLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NullLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BooleanLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">RegExpLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">LogicalExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">MemberExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NewExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">SequenceExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ParenthesizedExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ThisExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">UnaryExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">UpdateExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ArrowFunctionExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">MetaProperty</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Super</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TaggedTemplateExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TemplateLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">YieldExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">AwaitExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Import</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BigIntLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">OptionalMemberExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">OptionalCallExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TypeCastExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXElement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXFragment</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BindExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">PipelinePrimaryTopicReference</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DoExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">RecordExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TupleExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DecimalLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSAsExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSTypeAssertion</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSNonNullExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Placeholder</span><span class="s3">&quot;===r&amp;&amp;(&quot;</span><span class="s0">Expression</span><span class="s3">&quot;===e.expectedNode||&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;===e.expectedNode||&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;===e.expectedNode))&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isBinary=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Binary</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BinaryExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">LogicalExpression</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isScopable=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Scopable</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">CatchClause</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DoWhileStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForInStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">FunctionDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">FunctionExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Program</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectMethod</span><span class="s3">&quot;===r||&quot;</span><span class="s0">SwitchStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">WhileStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ArrowFunctionExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForOfStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassMethod</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassPrivateMethod</span><span class="s3">&quot;===r||&quot;</span><span class="s0">StaticBlock</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSModuleBlock</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Placeholder</span><span class="s3">&quot;===r&amp;&amp;&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;===e.expectedNode)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isBlockParent=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">BlockParent</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">CatchClause</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DoWhileStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForInStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">FunctionDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">FunctionExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Program</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectMethod</span><span class="s3">&quot;===r||&quot;</span><span class="s0">SwitchStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">WhileStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ArrowFunctionExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForOfStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassMethod</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassPrivateMethod</span><span class="s3">&quot;===r||&quot;</span><span class="s0">StaticBlock</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSModuleBlock</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Placeholder</span><span class="s3">&quot;===r&amp;&amp;&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;===e.expectedNode)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isBlock=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Block</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Program</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSModuleBlock</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Placeholder</span><span class="s3">&quot;===r&amp;&amp;&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;===e.expectedNode)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isStatement=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Statement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BreakStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ContinueStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DebuggerStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DoWhileStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">EmptyStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExpressionStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForInStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">FunctionDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">IfStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">LabeledStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ReturnStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">SwitchStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ThrowStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TryStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">VariableDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">WhileStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">WithStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExportAllDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExportDefaultDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExportNamedDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForOfStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ImportDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareClass</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareFunction</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareInterface</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareModule</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareModuleExports</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareTypeAlias</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareOpaqueType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareVariable</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareExportDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareExportAllDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">InterfaceDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">OpaqueType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TypeAlias</span><span class="s3">&quot;===r||&quot;</span><span class="s0">EnumDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSDeclareFunction</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSInterfaceDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSTypeAliasDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSEnumDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSModuleDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSImportEqualsDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSExportAssignment</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSNamespaceExportDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Placeholder</span><span class="s3">&quot;===r&amp;&amp;(&quot;</span><span class="s0">Statement</span><span class="s3">&quot;===e.expectedNode||&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;===e.expectedNode||&quot;</span><span class="s0">BlockStatement</span><span class="s3">&quot;===e.expectedNode))&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isTerminatorless=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Terminatorless</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BreakStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ContinueStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ReturnStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ThrowStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">YieldExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">AwaitExpression</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isCompletionStatement=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">CompletionStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BreakStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ContinueStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ReturnStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ThrowStatement</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isConditional=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Conditional</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ConditionalExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">IfStatement</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isLoop=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Loop</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DoWhileStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForInStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">WhileStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForOfStatement</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isWhile=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">While</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DoWhileStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">WhileStatement</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isExpressionWrapper=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">ExpressionWrapper</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExpressionStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ParenthesizedExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TypeCastExpression</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isFor=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">For</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForInStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForOfStatement</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isForXStatement=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">ForXStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForInStatement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ForOfStatement</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isFunction=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Function</span><span class="s3">&quot;===r||&quot;</span><span class="s0">FunctionDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">FunctionExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectMethod</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ArrowFunctionExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassMethod</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassPrivateMethod</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isFunctionParent=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">FunctionParent</span><span class="s3">&quot;===r||&quot;</span><span class="s0">FunctionDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">FunctionExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectMethod</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ArrowFunctionExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassMethod</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassPrivateMethod</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isPureish=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Pureish</span><span class="s3">&quot;===r||&quot;</span><span class="s0">FunctionDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">FunctionExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NumericLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NullLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BooleanLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">RegExpLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ArrowFunctionExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BigIntLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DecimalLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Placeholder</span><span class="s3">&quot;===r&amp;&amp;&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;===e.expectedNode)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isDeclaration=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">FunctionDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">VariableDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExportAllDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExportDefaultDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExportNamedDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ImportDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareClass</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareFunction</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareInterface</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareModule</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareModuleExports</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareTypeAlias</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareOpaqueType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareVariable</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareExportDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareExportAllDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">InterfaceDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">OpaqueType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TypeAlias</span><span class="s3">&quot;===r||&quot;</span><span class="s0">EnumDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSDeclareFunction</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSInterfaceDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSTypeAliasDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSEnumDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSModuleDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Placeholder</span><span class="s3">&quot;===r&amp;&amp;&quot;</span><span class="s0">Declaration</span><span class="s3">&quot;===e.expectedNode)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isPatternLike=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">PatternLike</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;===r||&quot;</span><span class="s0">RestElement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">AssignmentPattern</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ArrayPattern</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectPattern</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Placeholder</span><span class="s3">&quot;===r&amp;&amp;(&quot;</span><span class="s0">Pattern</span><span class="s3">&quot;===e.expectedNode||&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;===e.expectedNode))&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isLVal=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">LVal</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;===r||&quot;</span><span class="s0">MemberExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">RestElement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">AssignmentPattern</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ArrayPattern</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectPattern</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSParameterProperty</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Placeholder</span><span class="s3">&quot;===r&amp;&amp;(&quot;</span><span class="s0">Pattern</span><span class="s3">&quot;===e.expectedNode||&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;===e.expectedNode))&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isTSEntityName=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">TSEntityName</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSQualifiedName</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Placeholder</span><span class="s3">&quot;===r&amp;&amp;&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;===e.expectedNode)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isLiteral=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Literal</span><span class="s3">&quot;===r||&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NumericLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NullLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BooleanLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">RegExpLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TemplateLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BigIntLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DecimalLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Placeholder</span><span class="s3">&quot;===r&amp;&amp;&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;===e.expectedNode)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isImmutable=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;===r||&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NumericLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NullLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BooleanLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BigIntLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXAttribute</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXClosingElement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXElement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXExpressionContainer</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXSpreadChild</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXOpeningElement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXText</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXFragment</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXOpeningFragment</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXClosingFragment</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DecimalLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Placeholder</span><span class="s3">&quot;===r&amp;&amp;&quot;</span><span class="s0">StringLiteral</span><span class="s3">&quot;===e.expectedNode)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isUserWhitespacable=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">UserWhitespacable</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectMethod</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectProperty</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectTypeInternalSlot</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectTypeCallProperty</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectTypeIndexer</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectTypeProperty</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectTypeSpreadProperty</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isMethod=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Method</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectMethod</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassMethod</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassPrivateMethod</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isObjectMember=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">ObjectMember</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectMethod</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectProperty</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isProperty=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Property</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectProperty</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassProperty</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassPrivateProperty</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isUnaryLike=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">UnaryLike</span><span class="s3">&quot;===r||&quot;</span><span class="s0">UnaryExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">SpreadElement</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isPattern=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Pattern</span><span class="s3">&quot;===r||&quot;</span><span class="s0">AssignmentPattern</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ArrayPattern</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectPattern</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Placeholder</span><span class="s3">&quot;===r&amp;&amp;&quot;</span><span class="s0">Pattern</span><span class="s3">&quot;===e.expectedNode)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isClass=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Class</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassDeclaration</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isModuleDeclaration=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">ModuleDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExportAllDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExportDefaultDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExportNamedDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ImportDeclaration</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isExportDeclaration=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">ExportDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExportAllDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExportDefaultDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExportNamedDeclaration</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isModuleSpecifier=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">ModuleSpecifier</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExportSpecifier</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ImportDefaultSpecifier</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ImportNamespaceSpecifier</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ImportSpecifier</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExportNamespaceSpecifier</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExportDefaultSpecifier</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isFlow=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Flow</span><span class="s3">&quot;===r||&quot;</span><span class="s0">AnyTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ArrayTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BooleanTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BooleanLiteralTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NullLiteralTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassImplements</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareClass</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareFunction</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareInterface</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareModule</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareModuleExports</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareTypeAlias</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareOpaqueType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareVariable</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareExportDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareExportAllDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclaredPredicate</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExistsTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">FunctionTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">FunctionTypeParam</span><span class="s3">&quot;===r||&quot;</span><span class="s0">GenericTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">InferredPredicate</span><span class="s3">&quot;===r||&quot;</span><span class="s0">InterfaceExtends</span><span class="s3">&quot;===r||&quot;</span><span class="s0">InterfaceDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">InterfaceTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">IntersectionTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">MixedTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">EmptyTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NullableTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NumberLiteralTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NumberTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectTypeInternalSlot</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectTypeCallProperty</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectTypeIndexer</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectTypeProperty</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectTypeSpreadProperty</span><span class="s3">&quot;===r||&quot;</span><span class="s0">OpaqueType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">QualifiedTypeIdentifier</span><span class="s3">&quot;===r||&quot;</span><span class="s0">StringLiteralTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">StringTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">SymbolTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ThisTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TupleTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TypeofTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TypeAlias</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TypeCastExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TypeParameter</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TypeParameterDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TypeParameterInstantiation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">UnionTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">Variance</span><span class="s3">&quot;===r||&quot;</span><span class="s0">VoidTypeAnnotation</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isFlowType=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">FlowType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">AnyTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ArrayTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BooleanTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BooleanLiteralTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NullLiteralTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ExistsTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">FunctionTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">GenericTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">InterfaceTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">IntersectionTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">MixedTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">EmptyTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NullableTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NumberLiteralTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NumberTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ObjectTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">StringLiteralTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">StringTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">SymbolTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ThisTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TupleTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TypeofTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">UnionTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">VoidTypeAnnotation</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isFlowBaseAnnotation=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">FlowBaseAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">AnyTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">BooleanTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NullLiteralTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">MixedTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">EmptyTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">NumberTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">StringTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">SymbolTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ThisTypeAnnotation</span><span class="s3">&quot;===r||&quot;</span><span class="s0">VoidTypeAnnotation</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isFlowDeclaration=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">FlowDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareClass</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareFunction</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareInterface</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareModule</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareModuleExports</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareTypeAlias</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareOpaqueType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareVariable</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareExportDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclareExportAllDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">InterfaceDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">OpaqueType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TypeAlias</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isFlowPredicate=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">FlowPredicate</span><span class="s3">&quot;===r||&quot;</span><span class="s0">DeclaredPredicate</span><span class="s3">&quot;===r||&quot;</span><span class="s0">InferredPredicate</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isEnumBody=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">EnumBody</span><span class="s3">&quot;===r||&quot;</span><span class="s0">EnumBooleanBody</span><span class="s3">&quot;===r||&quot;</span><span class="s0">EnumNumberBody</span><span class="s3">&quot;===r||&quot;</span><span class="s0">EnumStringBody</span><span class="s3">&quot;===r||&quot;</span><span class="s0">EnumSymbolBody</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isEnumMember=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">EnumMember</span><span class="s3">&quot;===r||&quot;</span><span class="s0">EnumBooleanMember</span><span class="s3">&quot;===r||&quot;</span><span class="s0">EnumNumberMember</span><span class="s3">&quot;===r||&quot;</span><span class="s0">EnumStringMember</span><span class="s3">&quot;===r||&quot;</span><span class="s0">EnumDefaultedMember</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isJSX=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">JSX</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXAttribute</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXClosingElement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXElement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXEmptyExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXExpressionContainer</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXSpreadChild</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXIdentifier</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXMemberExpression</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXNamespacedName</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXOpeningElement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXSpreadAttribute</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXText</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXFragment</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXOpeningFragment</span><span class="s3">&quot;===r||&quot;</span><span class="s0">JSXClosingFragment</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isPrivate=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">Private</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassPrivateProperty</span><span class="s3">&quot;===r||&quot;</span><span class="s0">ClassPrivateMethod</span><span class="s3">&quot;===r||&quot;</span><span class="s0">PrivateName</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isTSTypeElement=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">TSTypeElement</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSCallSignatureDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSConstructSignatureDeclaration</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSPropertySignature</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSMethodSignature</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSIndexSignature</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isTSType=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">TSType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSAnyKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSBooleanKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSBigIntKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSIntrinsicKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSNeverKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSNullKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSNumberKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSObjectKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSStringKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSSymbolKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSUndefinedKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSUnknownKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSVoidKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSThisType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSFunctionType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSConstructorType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSTypeReference</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSTypePredicate</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSTypeQuery</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSTypeLiteral</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSArrayType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSTupleType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSOptionalType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSRestType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSUnionType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSIntersectionType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSConditionalType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSInferType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSParenthesizedType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSTypeOperator</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSIndexedAccessType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSMappedType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSLiteralType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSExpressionWithTypeArguments</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSImportType</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isTSBaseType=function(e,t){if(!e)return!1;const r=e.type;return(&quot;</span><span class="s0">TSBaseType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSAnyKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSBooleanKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSBigIntKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSIntrinsicKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSNeverKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSNullKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSNumberKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSObjectKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSStringKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSSymbolKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSUndefinedKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSUnknownKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSVoidKeyword</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSThisType</span><span class="s3">&quot;===r||&quot;</span><span class="s0">TSLiteralType</span><span class="s3">&quot;===r)&amp;&amp;(void 0===t||(0,i.default)(e,t))},t.isNumberLiteral=function(e,t){return console.trace(&quot;</span><span class="s0">The node type NumberLiteral has been renamed to NumericLiteral</span><span class="s3">&quot;),!!e&amp;&amp;(&quot;</span><span class="s0">NumberLiteral</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isRegexLiteral=function(e,t){return console.trace(&quot;</span><span class="s0">The node type RegexLiteral has been renamed to RegExpLiteral</span><span class="s3">&quot;),!!e&amp;&amp;(&quot;</span><span class="s0">RegexLiteral</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isRestProperty=function(e,t){return console.trace(&quot;</span><span class="s0">The node type RestProperty has been renamed to RestElement</span><span class="s3">&quot;),!!e&amp;&amp;(&quot;</span><span class="s0">RestProperty</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))},t.isSpreadProperty=function(e,t){return console.trace(&quot;</span><span class="s0">The node type SpreadProperty has been renamed to SpreadElement</span><span class="s3">&quot;),!!e&amp;&amp;(&quot;</span><span class="s0">SpreadProperty</span><span class="s3">&quot;===e.type&amp;&amp;(void 0===t||(0,i.default)(e,t)))};var n,i=(n=r(4951))&amp;&amp;n.__esModule?n:{default:n}},6593:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t,r){return!!t&amp;&amp;((0,i.default)(t.type,e)?void 0===r||(0,n.default)(t,r):!r&amp;&amp;&quot;</span><span class="s0">Placeholder</span><span class="s3">&quot;===t.type&amp;&amp;e in a.FLIPPED_ALIAS_KEYS&amp;&amp;(0,s.default)(t.expectedNode,e))};var n=o(r(4951)),i=o(r(9530)),s=o(r(9186)),a=r(9829);function o(e){return e&amp;&amp;e.__esModule?e:{default:e}}},8979:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t,r){if(r&amp;&amp;&quot;</span><span class="s0">Identifier</span><span class="s3">&quot;===e.type&amp;&amp;&quot;</span><span class="s0">ObjectProperty</span><span class="s3">&quot;===t.type&amp;&amp;&quot;</span><span class="s0">ObjectExpression</span><span class="s3">&quot;===r.type)return!1;const n=i.default.keys[t.type];if(n)for(let r=0;r&lt;n.length;r++){const i=t[n[r]];if(Array.isArray(i)){if(i.indexOf(e)&gt;=0)return!0}else if(i===e)return!0}return!1};var n,i=(n=r(3407))&amp;&amp;n.__esModule?n:{default:n}},4920:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e){return(0,i.isFunctionDeclaration)(e)||(0,i.isClassDeclaration)(e)||(0,s.default)(e)};var n,i=r(8037),s=(n=r(9954))&amp;&amp;n.__esModule?n:{default:n}},738:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e){return!!(0,i.default)(e.type,&quot;</span><span class="s0">Immutable</span><span class="s3">&quot;)||!!(0,s.isIdentifier)(e)&amp;&amp;&quot;</span><span class="s0">undefined</span><span class="s3">&quot;===e.name};var n,i=(n=r(9530))&amp;&amp;n.__esModule?n:{default:n},s=r(8037)},9954:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e){return(0,n.isVariableDeclaration)(e)&amp;&amp;(&quot;</span><span class="s1">var</span><span class="s3">&quot;!==e.kind||e[i.BLOCK_SCOPED_SYMBOL])};var n=r(8037),i=r(9660)},1784:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e){return!(!e||!n.VISITOR_KEYS[e.type])};var n=r(9829)},5082:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function e(t,r){if(&quot;</span><span class="s0">object</span><span class="s3">&quot;!=typeof t||&quot;</span><span class="s0">object</span><span class="s3">&quot;!=typeof r||null==t||null==r)return t===r;if(t.type!==r.type)return!1;const i=Object.keys(n.NODE_FIELDS[t.type]||t.type),s=n.VISITOR_KEYS[t.type];for(const n of i){if(typeof t[n]!=typeof r[n])return!1;if(null!=t[n]||null!=r[n]){if(null==t[n]||null==r[n])return!1;if(Array.isArray(t[n])){if(!Array.isArray(r[n]))return!1;if(t[n].length!==r[n].length)return!1;for(let i=0;i&lt;t[n].length;i++)if(!e(t[n][i],r[n][i]))return!1}else if(&quot;</span><span class="s0">object</span><span class="s3">&quot;!=typeof t[n]||(null==s?void 0:s.includes(n))){if(!e(t[n],r[n]))return!1}else for(const e of Object.keys(t[n]))if(t[n][e]!==r[n][e])return!1}}return!0};var n=r(9829)},9186:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t){if(e===t)return!0;const r=n.PLACEHOLDERS_ALIAS[e];if(r)for(const e of r)if(t===e)return!0;return!1};var n=r(9829)},5794:(e,t)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t,r){switch(t.type){case&quot;</span><span class="s0">MemberExpression</span><span class="s3">&quot;:case&quot;</span><span class="s0">JSXMemberExpression</span><span class="s3">&quot;:case&quot;</span><span class="s0">OptionalMemberExpression</span><span class="s3">&quot;:return t.property===e?!!t.computed:t.object===e;case&quot;</span><span class="s0">VariableDeclarator</span><span class="s3">&quot;:return t.init===e;case&quot;</span><span class="s0">ArrowFunctionExpression</span><span class="s3">&quot;:return t.body===e;case&quot;</span><span class="s0">ExportSpecifier</span><span class="s3">&quot;:return!t.source&amp;&amp;t.local===e;case&quot;</span><span class="s0">PrivateName</span><span class="s3">&quot;:return!1;case&quot;</span><span class="s0">ClassMethod</span><span class="s3">&quot;:case&quot;</span><span class="s0">ClassPrivateMethod</span><span class="s3">&quot;:case&quot;</span><span class="s0">ObjectMethod</span><span class="s3">&quot;:if(t.params.includes(e))return!1;case&quot;</span><span class="s0">ObjectProperty</span><span class="s3">&quot;:case&quot;</span><span class="s0">ClassProperty</span><span class="s3">&quot;:case&quot;</span><span class="s0">ClassPrivateProperty</span><span class="s3">&quot;:return t.key===e?!!t.computed:t.value!==e||!r||&quot;</span><span class="s0">ObjectPattern</span><span class="s3">&quot;!==r.type;case&quot;</span><span class="s0">ClassDeclaration</span><span class="s3">&quot;:case&quot;</span><span class="s0">ClassExpression</span><span class="s3">&quot;:return t.superClass===e;case&quot;</span><span class="s0">AssignmentExpression</span><span class="s3">&quot;:case&quot;</span><span class="s0">AssignmentPattern</span><span class="s3">&quot;:return t.right===e;case&quot;</span><span class="s0">LabeledStatement</span><span class="s3">&quot;:case&quot;</span><span class="s0">CatchClause</span><span class="s3">&quot;:case&quot;</span><span class="s0">RestElement</span><span class="s3">&quot;:case&quot;</span><span class="s0">BreakStatement</span><span class="s3">&quot;:case&quot;</span><span class="s0">ContinueStatement</span><span class="s3">&quot;:case&quot;</span><span class="s0">FunctionDeclaration</span><span class="s3">&quot;:case&quot;</span><span class="s0">FunctionExpression</span><span class="s3">&quot;:case&quot;</span><span class="s0">ExportNamespaceSpecifier</span><span class="s3">&quot;:case&quot;</span><span class="s0">ExportDefaultSpecifier</span><span class="s3">&quot;:case&quot;</span><span class="s0">ImportDefaultSpecifier</span><span class="s3">&quot;:case&quot;</span><span class="s0">ImportNamespaceSpecifier</span><span class="s3">&quot;:case&quot;</span><span class="s0">ImportSpecifier</span><span class="s3">&quot;:case&quot;</span><span class="s0">JSXAttribute</span><span class="s3">&quot;:case&quot;</span><span class="s0">ObjectPattern</span><span class="s3">&quot;:case&quot;</span><span class="s0">ArrayPattern</span><span class="s3">&quot;:case&quot;</span><span class="s0">MetaProperty</span><span class="s3">&quot;:return!1;case&quot;</span><span class="s0">ObjectTypeProperty</span><span class="s3">&quot;:return t.key!==e;case&quot;</span><span class="s0">TSEnumMember</span><span class="s3">&quot;:return t.id!==e;case&quot;</span><span class="s0">TSPropertySignature</span><span class="s3">&quot;:return t.key!==e||!!t.computed}return!0}},9057:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t){return(!(0,n.isBlockStatement)(e)||!(0,n.isFunction)(t)&amp;&amp;!(0,n.isCatchClause)(t))&amp;&amp;(!(!(0,n.isPattern)(e)||!(0,n.isFunction)(t)&amp;&amp;!(0,n.isCatchClause)(t))||(0,n.isScopable)(e))};var n=r(8037)},9935:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e){return(0,n.isImportDefaultSpecifier)(e)||(0,n.isIdentifier)(e.imported||e.exported,{name:&quot;</span><span class="s1">default</span><span class="s3">&quot;})};var n=r(8037)},9530:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t){if(e===t)return!0;if(n.ALIAS_KEYS[t])return!1;const r=n.FLIPPED_ALIAS_KEYS[t];if(r){if(r[0]===e)return!0;for(const t of r)if(e===t)return!0}return!1};var n=r(9829)},6256:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e){return(0,i.default)(e)&amp;&amp;!s.has(e)};var n,i=(n=r(380))&amp;&amp;n.__esModule?n:{default:n};const s=new Set([&quot;</span><span class="s0">abstract</span><span class="s3">&quot;,&quot;</span><span class="s0">boolean</span><span class="s3">&quot;,&quot;</span><span class="s0">byte</span><span class="s3">&quot;,&quot;</span><span class="s0">char</span><span class="s3">&quot;,&quot;</span><span class="s0">double</span><span class="s3">&quot;,&quot;</span><span class="s0">enum</span><span class="s3">&quot;,&quot;</span><span class="s0">final</span><span class="s3">&quot;,&quot;</span><span class="s0">float</span><span class="s3">&quot;,&quot;</span><span class="s0">goto</span><span class="s3">&quot;,&quot;</span><span class="s0">implements</span><span class="s3">&quot;,&quot;</span><span class="s0">int</span><span class="s3">&quot;,&quot;</span><span class="s0">interface</span><span class="s3">&quot;,&quot;</span><span class="s0">long</span><span class="s3">&quot;,&quot;</span><span class="s0">native</span><span class="s3">&quot;,&quot;</span><span class="s0">package</span><span class="s3">&quot;,&quot;</span><span class="s0">private</span><span class="s3">&quot;,&quot;</span><span class="s0">protected</span><span class="s3">&quot;,&quot;</span><span class="s0">public</span><span class="s3">&quot;,&quot;</span><span class="s0">short</span><span class="s3">&quot;,&quot;</span><span class="s0">static</span><span class="s3">&quot;,&quot;</span><span class="s0">synchronized</span><span class="s3">&quot;,&quot;</span><span class="s0">throws</span><span class="s3">&quot;,&quot;</span><span class="s0">transient</span><span class="s3">&quot;,&quot;</span><span class="s0">volatile</span><span class="s3">&quot;])},380:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t=!0){if(&quot;</span><span class="s0">string</span><span class="s3">&quot;!=typeof e)return!1;if(t){if((0,n.isKeyword)(e)||(0,n.isStrictReservedWord)(e))return!1;if(&quot;</span><span class="s0">await</span><span class="s3">&quot;===e)return!1}return(0,n.isIdentifierName)(e)};var n=r(7075)},1330:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e){return(0,n.isVariableDeclaration)(e,{kind:&quot;</span><span class="s1">var</span><span class="s3">&quot;})&amp;&amp;!e[i.BLOCK_SCOPED_SYMBOL]};var n=r(8037),i=r(9660)},6636:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t,r){if(!(0,n.isMemberExpression)(e))return!1;const i=Array.isArray(t)?t:t.split(&quot;</span><span class="s0">.</span><span class="s3">&quot;),s=[];let a;for(a=e;(0,n.isMemberExpression)(a);a=a.object)s.push(a.property);if(s.push(a),s.length&lt;i.length)return!1;if(!r&amp;&amp;s.length&gt;i.length)return!1;for(let e=0,t=s.length-1;e&lt;i.length;e++,t--){const r=s[t];let a;if((0,n.isIdentifier)(r))a=r.name;else{if(!(0,n.isStringLiteral)(r))return!1;a=r.value}if(i[e]!==a)return!1}return!0};var n=r(8037)},5124:(e,t)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e){return!!e&amp;&amp;/^[a-z]/.test(e)}},5631:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;var n;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=void 0;var i=(0,((n=r(3972))&amp;&amp;n.__esModule?n:{default:n}).default)(&quot;</span><span class="s0">React.Component</span><span class="s3">&quot;);t.default=i},9623:(e,t,r)=&gt;{&quot;</span><span class="s0">use strict</span><span class="s3">&quot;;Object.defineProperty(t,&quot;</span><span class="s0">__esModule</span><span class="s3">&quot;,{value:!0}),t.default=function(e,t,r){if(!e)return;const a=n.NODE_FIELDS[e.type];if(!a)return;i(e,t,r,a[t]),s(e,t,r)},t.validateField=i,t.validateChild=s;var n=r(9829);function i(e,t,r,n){(null==n?void 0:n.validate)&amp;&amp;(n.optional&amp;&amp;null==r||n.validate(e,t,r))}function s(e,t,r){if(null==r)return;const i=n.NODE_PARENT_VALIDATIONS[r.type];i&amp;&amp;i(e,t,r)}},949:(e,t,r)=&gt;{var n=r(6635)(r(5686),&quot;</span><span class="s0">DataView</span><span class="s3">&quot;);e.exports=n},4108:(e,t,r)=&gt;{var n=r(2874),i=r(4916),s=r(4739),a=r(945),o=r(5081);function l(e){var t=-1,r=null==e?0:e.length;for(this.clear();++t&lt;r;){var n=e[t];this.set(n[0],n[1])}}l.prototype.clear=n,l.prototype.delete=i,l.prototype.get=s,l.prototype.has=a,l.prototype.set=o,e.exports=l},1662:(e,t,r)=&gt;{var n=r(8477),i=r(1302),s=r(9438),a=r(2628),o=r(4852);function l(e){var t=-1,r=null==e?0:e.length;for(this.clear();++t&lt;r;){var n=e[t];this.set(n[0],n[1])}}l.prototype.clear=n,l.prototype.delete=i,l.prototype.get=s,l.prototype.has=a,l.prototype.set=o,e.exports=l},5480:(e,t,r)=&gt;{var n=r(6635)(r(5686),&quot;</span><span class="s0">Map</span><span class="s3">&quot;);e.exports=n},2237:(e,t,r)=&gt;{var n=r(9271),i=r(6385),s=r(5675),a=r(2649),o=r(297);function l(e){var t=-1,r=null==e?0:e.length;for(this.clear();++t&lt;r;){var n=e[t];this.set(n[0],n[1])}}l.prototype.clear=n,l.prototype.delete=i,l.prototype.get=s,l.prototype.has=a,l.prototype.set=o,e.exports=l},3364:(e,t,r)=&gt;{var n=r(6635)(r(5686),&quot;</span><span class="s0">Promise</span><span class="s3">&quot;);e.exports=n},159:(e,t,r)=&gt;{var n=r(6635)(r(5686),&quot;</span><span class="s0">Set</span><span class="s3">&quot;);e.exports=n},2779:(e,t,r)=&gt;{var n=r(1662),i=r(6349),s=r(9137),a=r(4922),o=r(8790),l=r(9928);function p(e){var t=this.__data__=new n(e);this.size=t.size}p.prototype.clear=i,p.prototype.delete=s,p.prototype.get=a,p.prototype.has=o,p.prototype.set=l,e.exports=p},1414:(e,t,r)=&gt;{var n=r(5686).Symbol;e.exports=n},1684:(e,t,r)=&gt;{var n=r(5686).Uint8Array;e.exports=n},8065:(e,t,r)=&gt;{var n=r(6635)(r(5686),&quot;</span><span class="s0">WeakMap</span><span class="s3">&quot;);e.exports=n},8374:e=&gt;{e.exports=function(e,t){for(var r=-1,n=null==e?0:e.length;++r&lt;n&amp;&amp;!1!==t(e[r],r,e););return e}},3649:e=&gt;{e.exports=function(e,t){for(var r=-1,n=null==e?0:e.length,i=0,s=[];++r&lt;n;){var a=e[r];t(a,r,e)&amp;&amp;(s[i++]=a)}return s}},2670:(e,t,r)=&gt;{var n=r(5601),i=r(6151),s=r(4930),a=r(1092),o=r(2197),l=r(1870),p=Object.prototype.hasOwnProperty;e.exports=function(e,t){var r=s(e),c=!r&amp;&amp;i(e),u=!r&amp;&amp;!c&amp;&amp;a(e),d=!r&amp;&amp;!c&amp;&amp;!u&amp;&amp;l(e),h=r||c||u||d,f=h?n(e.length,String):[],m=f.length;for(var y in e)!t&amp;&amp;!p.call(e,y)||h&amp;&amp;(&quot;</span><span class="s0">length</span><span class="s3">&quot;==y||u&amp;&amp;(&quot;</span><span class="s0">offset</span><span class="s3">&quot;==y||&quot;</span><span class="s0">parent</span><span class="s3">&quot;==y)||d&amp;&amp;(&quot;</span><span class="s0">buffer</span><span class="s3">&quot;==y||&quot;</span><span class="s0">byteLength</span><span class="s3">&quot;==y||&quot;</span><span class="s0">byteOffset</span><span class="s3">&quot;==y)||o(y,m))||f.push(y);return f}},484:e=&gt;{e.exports=function(e,t){for(var r=-1,n=t.length,i=e.length;++r&lt;n;)e[i+r]=t[r];return e}},4995:(e,t,r)=&gt;{var n=r(9493),i=r(2226),s=Object.prototype.hasOwnProperty;e.exports=function(e,t,r){var a=e[t];s.call(e,t)&amp;&amp;i(a,r)&amp;&amp;(void 0!==r||t in e)||n(e,t,r)}},5412:(e,t,r)=&gt;{var n=r(2226);e.exports=function(e,t){for(var r=e.length;r--;)if(n(e[r][0],t))return r;return-1}},2897:(e,t,r)=&gt;{var n=r(730),i=r(1089);e.exports=function(e,t){return e&amp;&amp;n(t,i(t),e)}},5504:(e,t,r)=&gt;{var n=r(730),i=r(2990);e.exports=function(e,t){return e&amp;&amp;n(t,i(t),e)}},9493:(e,t,r)=&gt;{var n=r(4466);e.exports=function(e,t,r){&quot;</span><span class="s0">__proto__</span><span class="s3">&quot;==t&amp;&amp;n?n(e,t,{configurable:!0,enumerable:!0,value:r,writable:!0}):e[t]=r}},8002:(e,t,r)=&gt;{var n=r(2779),i=r(8374),s=r(4995),a=r(2897),o=r(5504),l=r(3126),p=r(4074),c=r(3399),u=r(3736),d=r(2396),h=r(1419),f=r(9545),m=r(4921),y=r(7465),T=r(5244),b=r(4930),g=r(1092),S=r(4157),x=r(4825),E=r(1940),P=r(1089),v=r(2990),A=&quot;</span><span class="s0">[object Arguments]</span><span class="s3">&quot;,w=&quot;</span><span class="s0">[object Function]</span><span class="s3">&quot;,O=&quot;</span><span class="s0">[object Object]</span><span class="s3">&quot;,I={};I[A]=I[&quot;</span><span class="s0">[object Array]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object ArrayBuffer]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object DataView]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object Boolean]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object Date]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object Float32Array]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object Float64Array]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object Int8Array]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object Int16Array]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object Int32Array]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object Map]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object Number]</span><span class="s3">&quot;]=I[O]=I[&quot;</span><span class="s0">[object RegExp]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object Set]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object String]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object Symbol]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object Uint8Array]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object Uint8ClampedArray]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object Uint16Array]</span><span class="s3">&quot;]=I[&quot;</span><span class="s0">[object Uint32Array]</span><span class="s3">&quot;]=!0,I[&quot;</span><span class="s0">[object Error]</span><span class="s3">&quot;]=I[w]=I[&quot;</span><span class="s0">[object WeakMap]</span><span class="s3">&quot;]=!1,e.exports=function e(t,r,N,C,k,D){var _,L=1&amp;r,M=2&amp;r,j=4&amp;r;if(N&amp;&amp;(_=k?N(t,C,k,D):N(t)),void 0!==_)return _;if(!x(t))return t;var F=b(t);if(F){if(_=m(t),!L)return p(t,_)}else{var B=f(t),R=B==w||&quot;</span><span class="s0">[object GeneratorFunction]</span><span class="s3">&quot;==B;if(g(t))return l(t,L);if(B==O||B==A||R&amp;&amp;!k){if(_=M||R?{}:T(t),!L)return M?u(t,o(_,t)):c(t,a(_,t))}else{if(!I[B])return k?t:{};_=y(t,B,L)}}D||(D=new n);var U=D.get(t);if(U)return U;D.set(t,_),E(t)?t.forEach((function(n){_.add(e(n,r,N,n,t,D))})):S(t)&amp;&amp;t.forEach((function(n,i){_.set(i,e(n,r,N,i,t,D))}));var V=F?void 0:(j?M?h:d:M?v:P)(t);return i(V||t,(function(n,i){V&amp;&amp;(n=t[i=n]),s(_,i,e(n,r,N,i,t,D))})),_}},3538:(e,t,r)=&gt;{var n=r(4825),i=Object.create,s=function(){function e(){}return function(t){if(!n(t))return{};if(i)return i(t);e.prototype=t;var r=new e;return e.prototype=void 0,r}}();e.exports=s},7131:(e,t,r)=&gt;{var n=r(484),i=r(4930);e.exports=function(e,t,r){var s=t(e);return i(e)?s:n(s,r(e))}},2928:(e,t,r)=&gt;{var n=r(1414),i=r(2809),s=r(275),a=n?n.toStringTag:void 0;e.exports=function(e){return null==e?void 0===e?&quot;</span><span class="s0">[object Undefined]</span><span class="s3">&quot;:&quot;</span><span class="s0">[object Null]</span><span class="s3">&quot;:a&amp;&amp;a in Object(e)?i(e):s(e)}},7892:(e,t,r)=&gt;{var n=r(2928),i=r(5834);e.exports=function(e){return i(e)&amp;&amp;&quot;</span><span class="s0">[object Arguments]</span><span class="s3">&quot;==n(e)}},8381:(e,t,r)=&gt;{var n=r(9545),i=r(5834);e.exports=function(e){return i(e)&amp;&amp;&quot;</span><span class="s0">[object Map]</span><span class="s3">&quot;==n(e)}},6752:(e,t,r)=&gt;{var n=r(8903),i=r(2650),s=r(4825),a=r(2726),o=/^</span><span class="s5">\[</span><span class="s3">object .+?Constructor</span><span class="s5">\]</span><span class="s3">$/,l=Function.prototype,p=Object.prototype,c=l.toString,u=p.hasOwnProperty,d=RegExp(&quot;</span><span class="s0">^</span><span class="s3">&quot;+c.call(u).replace(/[</span><span class="s4">\\</span><span class="s3">^$.*+?()[</span><span class="s5">\]</span><span class="s3">{}|]/g,&quot;</span><span class="s0">\\$&amp;</span><span class="s3">&quot;).replace(/hasOwnProperty|(function).*?(?=</span><span class="s4">\\</span><span class="s5">\(</span><span class="s3">)| for .+?(?=</span><span class="s4">\\</span><span class="s5">\]</span><span class="s3">)/g,&quot;</span><span class="s0">$1.*?</span><span class="s3">&quot;)+&quot;</span><span class="s0">$</span><span class="s3">&quot;);e.exports=function(e){return!(!s(e)||i(e))&amp;&amp;(n(e)?d:o).test(a(e))}},9152:(e,t,r)=&gt;{var n=r(2928),i=r(5834);e.exports=function(e){return i(e)&amp;&amp;&quot;</span><span class="s0">[object RegExp]</span><span class="s3">&quot;==n(e)}},1449:(e,t,r)=&gt;{var n=r(9545),i=r(5834);e.exports=function(e){return i(e)&amp;&amp;&quot;</span><span class="s0">[object Set]</span><span class="s3">&quot;==n(e)}},3715:(e,t,r)=&gt;{var n=r(2928),i=r(727),s=r(5834),a={};a[&quot;</span><span class="s0">[object Float32Array]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Float64Array]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Int8Array]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Int16Array]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Int32Array]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Uint8Array]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Uint8ClampedArray]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Uint16Array]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Uint32Array]</span><span class="s3">&quot;]=!0,a[&quot;</span><span class="s0">[object Arguments]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Array]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object ArrayBuffer]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Boolean]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object DataView]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Date]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Error]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Function]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Map]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Number]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Object]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object RegExp]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object Set]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object String]</span><span class="s3">&quot;]=a[&quot;</span><span class="s0">[object WeakMap]</span><span class="s3">&quot;]=!1,e.exports=function(e){return s(e)&amp;&amp;i(e.length)&amp;&amp;!!a[n(e)]}},2987:(e,t,r)=&gt;{var n=r(8621),i=r(9626),s=Object.prototype.hasOwnProperty;e.exports=function(e){if(!n(e))return i(e);var t=[];for(var r in Object(e))s.call(e,r)&amp;&amp;&quot;</span><span class="s0">constructor</span><span class="s3">&quot;!=r&amp;&amp;t.push(r);return t}},3181:(e,t,r)=&gt;{var n=r(4825),i=r(8621),s=r(3083),a=Object.prototype.hasOwnProperty;e.exports=function(e){if(!n(e))return s(e);var t=i(e),r=[];for(var o in e)(&quot;</span><span class="s0">constructor</span><span class="s3">&quot;!=o||!t&amp;&amp;a.call(e,o))&amp;&amp;r.push(o);return r}},5601:e=&gt;{e.exports=function(e,t){for(var r=-1,n=Array(e);++r&lt;e;)n[r]=t(r);return n}},2587:e=&gt;{e.exports=function(e){return function(t){return e(t)}}},5726:(e,t,r)=&gt;{var n=r(1684);e.exports=function(e){var t=new e.constructor(e.byteLength);return new n(t).set(new n(e)),t}},3126:(e,t,r)=&gt;{e=r.nmd(e);var n=r(5686),i=t&amp;&amp;!t.nodeType&amp;&amp;t,s=i&amp;&amp;e&amp;&amp;!e.nodeType&amp;&amp;e,a=s&amp;&amp;s.exports===i?n.Buffer:void 0,o=a?a.allocUnsafe:void 0;e.exports=function(e,t){if(t)return e.slice();var r=e.length,n=o?o(r):new e.constructor(r);return e.copy(n),n}},6977:(e,t,r)=&gt;{var n=r(5726);e.exports=function(e,t){var r=t?n(e.buffer):e.buffer;return new e.constructor(r,e.byteOffset,e.byteLength)}},3327:e=&gt;{var t=/</span><span class="s5">\w</span><span class="s3">*$/;e.exports=function(e){var r=new e.constructor(e.source,t.exec(e));return r.lastIndex=e.lastIndex,r}},9674:(e,t,r)=&gt;{var n=r(1414),i=n?n.prototype:void 0,s=i?i.valueOf:void 0;e.exports=function(e){return s?Object(s.call(e)):{}}},6363:(e,t,r)=&gt;{var n=r(5726);e.exports=function(e,t){var r=t?n(e.buffer):e.buffer;return new e.constructor(r,e.byteOffset,e.length)}},4074:e=&gt;{e.exports=function(e,t){var r=-1,n=e.length;for(t||(t=Array(n));++r&lt;n;)t[r]=e[r];return t}},730:(e,t,r)=&gt;{var n=r(4995),i=r(9493);e.exports=function(e,t,r,s){var a=!r;r||(r={});for(var o=-1,l=t.length;++o&lt;l;){var p=t[o],c=s?s(r[p],e[p],p,r,e):void 0;void 0===c&amp;&amp;(c=e[p]),a?i(r,p,c):n(r,p,c)}return r}},3399:(e,t,r)=&gt;{var n=r(730),i=r(5984);e.exports=function(e,t){return n(e,i(e),t)}},3736:(e,t,r)=&gt;{var n=r(730),i=r(8741);e.exports=function(e,t){return n(e,i(e),t)}},4718:(e,t,r)=&gt;{var n=r(5686)[&quot;</span><span class="s0">__core-js_shared__</span><span class="s3">&quot;];e.exports=n},4466:(e,t,r)=&gt;{var n=r(6635),i=function(){try{var e=n(Object,&quot;</span><span class="s0">defineProperty</span><span class="s3">&quot;);return e({},&quot;&quot;,{}),e}catch(e){}}();e.exports=i},524:e=&gt;{var t=&quot;</span><span class="s0">object</span><span class="s3">&quot;==typeof global&amp;&amp;global&amp;&amp;global.Object===Object&amp;&amp;global;e.exports=t},2396:(e,t,r)=&gt;{var n=r(7131),i=r(5984),s=r(1089);e.exports=function(e){return n(e,s,i)}},1419:(e,t,r)=&gt;{var n=r(7131),i=r(8741),s=r(2990);e.exports=function(e){return n(e,s,i)}},9872:(e,t,r)=&gt;{var n=r(1796);e.exports=function(e,t){var r=e.__data__;return n(t)?r[&quot;</span><span class="s0">string</span><span class="s3">&quot;==typeof t?&quot;</span><span class="s0">string</span><span class="s3">&quot;:&quot;</span><span class="s0">hash</span><span class="s3">&quot;]:r.map}},6635:(e,t,r)=&gt;{var n=r(6752),i=r(8459);e.exports=function(e,t){var r=i(e,t);return n(r)?r:void 0}},2722:(e,t,r)=&gt;{var n=r(2167)(Object.getPrototypeOf,Object);e.exports=n},2809:(e,t,r)=&gt;{var n=r(1414),i=Object.prototype,s=i.hasOwnProperty,a=i.toString,o=n?n.toStringTag:void 0;e.exports=function(e){var t=s.call(e,o),r=e[o];try{e[o]=void 0;var n=!0}catch(e){}var i=a.call(e);return n&amp;&amp;(t?e[o]=r:delete e[o]),i}},5984:(e,t,r)=&gt;{var n=r(3649),i=r(3614),s=Object.prototype.propertyIsEnumerable,a=Object.getOwnPropertySymbols,o=a?function(e){return null==e?[]:(e=Object(e),n(a(e),(function(t){return s.call(e,t)})))}:i;e.exports=o},8741:(e,t,r)=&gt;{var n=r(484),i=r(2722),s=r(5984),a=r(3614),o=Object.getOwnPropertySymbols?function(e){for(var t=[];e;)n(t,s(e)),e=i(e);return t}:a;e.exports=o},9545:(e,t,r)=&gt;{var n=r(949),i=r(5480),s=r(3364),a=r(159),o=r(8065),l=r(2928),p=r(2726),c=&quot;</span><span class="s0">[object Map]</span><span class="s3">&quot;,u=&quot;</span><span class="s0">[object Promise]</span><span class="s3">&quot;,d=&quot;</span><span class="s0">[object Set]</span><span class="s3">&quot;,h=&quot;</span><span class="s0">[object WeakMap]</span><span class="s3">&quot;,f=&quot;</span><span class="s0">[object DataView]</span><span class="s3">&quot;,m=p(n),y=p(i),T=p(s),b=p(a),g=p(o),S=l;(n&amp;&amp;S(new n(new ArrayBuffer(1)))!=f||i&amp;&amp;S(new i)!=c||s&amp;&amp;S(s.resolve())!=u||a&amp;&amp;S(new a)!=d||o&amp;&amp;S(new o)!=h)&amp;&amp;(S=function(e){var t=l(e),r=&quot;</span><span class="s0">[object Object]</span><span class="s3">&quot;==t?e.constructor:void 0,n=r?p(r):&quot;&quot;;if(n)switch(n){case m:return f;case y:return c;case T:return u;case b:return d;case g:return h}return t}),e.exports=S},8459:e=&gt;{e.exports=function(e,t){return null==e?void 0:e[t]}},2874:(e,t,r)=&gt;{var n=r(5441);e.exports=function(){this.__data__=n?n(null):{},this.size=0}},4916:e=&gt;{e.exports=function(e){var t=this.has(e)&amp;&amp;delete this.__data__[e];return this.size-=t?1:0,t}},4739:(e,t,r)=&gt;{var n=r(5441),i=Object.prototype.hasOwnProperty;e.exports=function(e){var t=this.__data__;if(n){var r=t[e];return&quot;</span><span class="s0">__lodash_hash_undefined__</span><span class="s3">&quot;===r?void 0:r}return i.call(t,e)?t[e]:void 0}},945:(e,t,r)=&gt;{var n=r(5441),i=Object.prototype.hasOwnProperty;e.exports=function(e){var t=this.__data__;return n?void 0!==t[e]:i.call(t,e)}},5081:(e,t,r)=&gt;{var n=r(5441);e.exports=function(e,t){var r=this.__data__;return this.size+=this.has(e)?0:1,r[e]=n&amp;&amp;void 0===t?&quot;</span><span class="s0">__lodash_hash_undefined__</span><span class="s3">&quot;:t,this}},4921:e=&gt;{var t=Object.prototype.hasOwnProperty;e.exports=function(e){var r=e.length,n=new e.constructor(r);return r&amp;&amp;&quot;</span><span class="s0">string</span><span class="s3">&quot;==typeof e[0]&amp;&amp;t.call(e,&quot;</span><span class="s0">index</span><span class="s3">&quot;)&amp;&amp;(n.index=e.index,n.input=e.input),n}},7465:(e,t,r)=&gt;{var n=r(5726),i=r(6977),s=r(3327),a=r(9674),o=r(6363);e.exports=function(e,t,r){var l=e.constructor;switch(t){case&quot;</span><span class="s0">[object ArrayBuffer]</span><span class="s3">&quot;:return n(e);case&quot;</span><span class="s0">[object Boolean]</span><span class="s3">&quot;:case&quot;</span><span class="s0">[object Date]</span><span class="s3">&quot;:return new l(+e);case&quot;</span><span class="s0">[object DataView]</span><span class="s3">&quot;:return i(e,r);case&quot;</span><span class="s0">[object Float32Array]</span><span class="s3">&quot;:case&quot;</span><span class="s0">[object Float64Array]</span><span class="s3">&quot;:case&quot;</span><span class="s0">[object Int8Array]</span><span class="s3">&quot;:case&quot;</span><span class="s0">[object Int16Array]</span><span class="s3">&quot;:case&quot;</span><span class="s0">[object Int32Array]</span><span class="s3">&quot;:case&quot;</span><span class="s0">[object Uint8Array]</span><span class="s3">&quot;:case&quot;</span><span class="s0">[object Uint8ClampedArray]</span><span class="s3">&quot;:case&quot;</span><span class="s0">[object Uint16Array]</span><span class="s3">&quot;:case&quot;</span><span class="s0">[object Uint32Array]</span><span class="s3">&quot;:return o(e,r);case&quot;</span><span class="s0">[object Map]</span><span class="s3">&quot;:case&quot;</span><span class="s0">[object Set]</span><span class="s3">&quot;:return new l;case&quot;</span><span class="s0">[object Number]</span><span class="s3">&quot;:case&quot;</span><span class="s0">[object String]</span><span class="s3">&quot;:return new l(e);case&quot;</span><span class="s0">[object RegExp]</span><span class="s3">&quot;:return s(e);case&quot;</span><span class="s0">[object Symbol]</span><span class="s3">&quot;:return a(e)}}},5244:(e,t,r)=&gt;{var n=r(3538),i=r(2722),s=r(8621);e.exports=function(e){return&quot;</span><span class="s1">function</span><span class="s3">&quot;!=typeof e.constructor||s(e)?{}:n(i(e))}},2197:e=&gt;{var t=/^(?:0|[1-9]</span><span class="s5">\d</span><span class="s3">*)$/;e.exports=function(e,r){var n=typeof e;return!!(r=null==r?9007199254740991:r)&amp;&amp;(&quot;</span><span class="s0">number</span><span class="s3">&quot;==n||&quot;</span><span class="s0">symbol</span><span class="s3">&quot;!=n&amp;&amp;t.test(e))&amp;&amp;e&gt;-1&amp;&amp;e%1==0&amp;&amp;e&lt;r}},1796:e=&gt;{e.exports=function(e){var t=typeof e;return&quot;</span><span class="s0">string</span><span class="s3">&quot;==t||&quot;</span><span class="s0">number</span><span class="s3">&quot;==t||&quot;</span><span class="s0">symbol</span><span class="s3">&quot;==t||&quot;</span><span class="s0">boolean</span><span class="s3">&quot;==t?&quot;</span><span class="s0">__proto__</span><span class="s3">&quot;!==e:null===e}},2650:(e,t,r)=&gt;{var n,i=r(4718),s=(n=/[^.]+$/.exec(i&amp;&amp;i.keys&amp;&amp;i.keys.IE_PROTO||&quot;&quot;))?&quot;</span><span class="s0">Symbol(src)_1.</span><span class="s3">&quot;+n:&quot;&quot;;e.exports=function(e){return!!s&amp;&amp;s in e}},8621:e=&gt;{var t=Object.prototype;e.exports=function(e){var r=e&amp;&amp;e.constructor;return e===(&quot;</span><span class="s1">function</span><span class="s3">&quot;==typeof r&amp;&amp;r.prototype||t)}},8477:e=&gt;{e.exports=function(){this.__data__=[],this.size=0}},1302:(e,t,r)=&gt;{var n=r(5412),i=Array.prototype.splice;e.exports=function(e){var t=this.__data__,r=n(t,e);return!(r&lt;0||(r==t.length-1?t.pop():i.call(t,r,1),--this.size,0))}},9438:(e,t,r)=&gt;{var n=r(5412);e.exports=function(e){var t=this.__data__,r=n(t,e);return r&lt;0?void 0:t[r][1]}},2628:(e,t,r)=&gt;{var n=r(5412);e.exports=function(e){return n(this.__data__,e)&gt;-1}},4852:(e,t,r)=&gt;{var n=r(5412);e.exports=function(e,t){var r=this.__data__,i=n(r,e);return i&lt;0?(++this.size,r.push([e,t])):r[i][1]=t,this}},9271:(e,t,r)=&gt;{var n=r(4108),i=r(1662),s=r(5480);e.exports=function(){this.size=0,this.__data__={hash:new n,map:new(s||i),string:new n}}},6385:(e,t,r)=&gt;{var n=r(9872);e.exports=function(e){var t=n(this,e).delete(e);return this.size-=t?1:0,t}},5675:(e,t,r)=&gt;{var n=r(9872);e.exports=function(e){return n(this,e).get(e)}},2649:(e,t,r)=&gt;{var n=r(9872);e.exports=function(e){return n(this,e).has(e)}},297:(e,t,r)=&gt;{var n=r(9872);e.exports=function(e,t){var r=n(this,e),i=r.size;return r.set(e,t),this.size+=r.size==i?0:1,this}},5441:(e,t,r)=&gt;{var n=r(6635)(Object,&quot;</span><span class="s0">create</span><span class="s3">&quot;);e.exports=n},9626:(e,t,r)=&gt;{var n=r(2167)(Object.keys,Object);e.exports=n},3083:e=&gt;{e.exports=function(e){var t=[];if(null!=e)for(var r in Object(e))t.push(r);return t}},9989:(e,t,r)=&gt;{e=r.nmd(e);var n=r(524),i=t&amp;&amp;!t.nodeType&amp;&amp;t,s=i&amp;&amp;e&amp;&amp;!e.nodeType&amp;&amp;e,a=s&amp;&amp;s.exports===i&amp;&amp;n.process,o=function(){try{return s&amp;&amp;s.require&amp;&amp;s.require(&quot;</span><span class="s0">util</span><span class="s3">&quot;).types||a&amp;&amp;a.binding&amp;&amp;a.binding(&quot;</span><span class="s0">util</span><span class="s3">&quot;)}catch(e){}}();e.exports=o},275:e=&gt;{var t=Object.prototype.toString;e.exports=function(e){return t.call(e)}},2167:e=&gt;{e.exports=function(e,t){return function(r){return e(t(r))}}},5686:(e,t,r)=&gt;{var n=r(524),i=&quot;</span><span class="s0">object</span><span class="s3">&quot;==typeof self&amp;&amp;self&amp;&amp;self.Object===Object&amp;&amp;self,s=n||i||Function(&quot;</span><span class="s1">return this</span><span class="s3">&quot;)();e.exports=s},6349:(e,t,r)=&gt;{var n=r(1662);e.exports=function(){this.__data__=new n,this.size=0}},9137:e=&gt;{e.exports=function(e){var t=this.__data__,r=t.delete(e);return this.size=t.size,r}},4922:e=&gt;{e.exports=function(e){return this.__data__.get(e)}},8790:e=&gt;{e.exports=function(e){return this.__data__.has(e)}},9928:(e,t,r)=&gt;{var n=r(1662),i=r(5480),s=r(2237);e.exports=function(e,t){var r=this.__data__;if(r instanceof n){var a=r.__data__;if(!i||a.length&lt;199)return a.push([e,t]),this.size=++r.size,this;r=this.__data__=new s(a)}return r.set(e,t),this.size=r.size,this}},2726:e=&gt;{var t=Function.prototype.toString;e.exports=function(e){if(null!=e){try{return t.call(e)}catch(e){}try{return e+&quot;&quot;}catch(e){}}return&quot;&quot;}},8269:(e,t,r)=&gt;{var n=r(8002);e.exports=function(e){return n(e,4)}},2226:e=&gt;{e.exports=function(e,t){return e===t||e!=e&amp;&amp;t!=t}},6151:(e,t,r)=&gt;{var n=r(7892),i=r(5834),s=Object.prototype,a=s.hasOwnProperty,o=s.propertyIsEnumerable,l=n(function(){return arguments}())?n:function(e){return i(e)&amp;&amp;a.call(e,&quot;</span><span class="s0">callee</span><span class="s3">&quot;)&amp;&amp;!o.call(e,&quot;</span><span class="s0">callee</span><span class="s3">&quot;)};e.exports=l},4930:e=&gt;{var t=Array.isArray;e.exports=t},1085:(e,t,r)=&gt;{var n=r(8903),i=r(727);e.exports=function(e){return null!=e&amp;&amp;i(e.length)&amp;&amp;!n(e)}},1092:(e,t,r)=&gt;{e=r.nmd(e);var n=r(5686),i=r(9007),s=t&amp;&amp;!t.nodeType&amp;&amp;t,a=s&amp;&amp;e&amp;&amp;!e.nodeType&amp;&amp;e,o=a&amp;&amp;a.exports===s?n.Buffer:void 0,l=(o?o.isBuffer:void 0)||i;e.exports=l},8903:(e,t,r)=&gt;{var n=r(2928),i=r(4825);e.exports=function(e){if(!i(e))return!1;var t=n(e);return&quot;</span><span class="s0">[object Function]</span><span class="s3">&quot;==t||&quot;</span><span class="s0">[object GeneratorFunction]</span><span class="s3">&quot;==t||&quot;</span><span class="s0">[object AsyncFunction]</span><span class="s3">&quot;==t||&quot;</span><span class="s0">[object Proxy]</span><span class="s3">&quot;==t}},727:e=&gt;{e.exports=function(e){return&quot;</span><span class="s0">number</span><span class="s3">&quot;==typeof e&amp;&amp;e&gt;-1&amp;&amp;e%1==0&amp;&amp;e&lt;=9007199254740991}},4157:(e,t,r)=&gt;{var n=r(8381),i=r(2587),s=r(9989),a=s&amp;&amp;s.isMap,o=a?i(a):n;e.exports=o},4825:e=&gt;{e.exports=function(e){var t=typeof e;return null!=e&amp;&amp;(&quot;</span><span class="s0">object</span><span class="s3">&quot;==t||&quot;</span><span class="s1">function</span><span class="s3">&quot;==t)}},5834:e=&gt;{e.exports=function(e){return null!=e&amp;&amp;&quot;</span><span class="s0">object</span><span class="s3">&quot;==typeof e}},4994:(e,t,r)=&gt;{var n=r(2928),i=r(2722),s=r(5834),a=Function.prototype,o=Object.prototype,l=a.toString,p=o.hasOwnProperty,c=l.call(Object);e.exports=function(e){if(!s(e)||&quot;</span><span class="s0">[object Object]</span><span class="s3">&quot;!=n(e))return!1;var t=i(e);if(null===t)return!0;var r=p.call(t,&quot;</span><span class="s0">constructor</span><span class="s3">&quot;)&amp;&amp;t.constructor;return&quot;</span><span class="s1">function</span><span class="s3">&quot;==typeof r&amp;&amp;r instanceof r&amp;&amp;l.call(r)==c}},956:(e,t,r)=&gt;{var n=r(9152),i=r(2587),s=r(9989),a=s&amp;&amp;s.isRegExp,o=a?i(a):n;e.exports=o},1940:(e,t,r)=&gt;{var n=r(1449),i=r(2587),s=r(9989),a=s&amp;&amp;s.isSet,o=a?i(a):n;e.exports=o},1870:(e,t,r)=&gt;{var n=r(3715),i=r(2587),s=r(9989),a=s&amp;&amp;s.isTypedArray,o=a?i(a):n;e.exports=o},1089:(e,t,r)=&gt;{var n=r(2670),i=r(2987),s=r(1085);e.exports=function(e){return s(e)?n(e):i(e)}},2990:(e,t,r)=&gt;{var n=r(2670),i=r(3181),s=r(1085);e.exports=function(e){return s(e)?n(e,!0):i(e)}},3614:e=&gt;{e.exports=function(){return[]}},9007:e=&gt;{e.exports=function(){return!1}},2579:(e,t,r)=&gt;{var n=r(1639),i=Object.prototype.hasOwnProperty,s=&quot;</span><span class="s0">undefined</span><span class="s3">&quot;!=typeof Map;function a(){this._array=[],this._set=s?new Map:Object.create(null)}a.fromArray=function(e,t){for(var r=new a,n=0,i=e.length;n&lt;i;n++)r.add(e[n],t);return r},a.prototype.size=function(){return s?this._set.size:Object.getOwnPropertyNames(this._set).length},a.prototype.add=function(e,t){var r=s?e:n.toSetString(e),a=s?this.has(e):i.call(this._set,r),o=this._array.length;a&amp;&amp;!t||this._array.push(e),a||(s?this._set.set(e,o):this._set[r]=o)},a.prototype.has=function(e){if(s)return this._set.has(e);var t=n.toSetString(e);return i.call(this._set,t)},a.prototype.indexOf=function(e){if(s){var t=this._set.get(e);if(t&gt;=0)return t}else{var r=n.toSetString(e);if(i.call(this._set,r))return this._set[r]}throw new Error('&quot;'+e+'&quot; is not in the set.')},a.prototype.at=function(e){if(e&gt;=0&amp;&amp;e&lt;this._array.length)return this._array[e];throw new Error(&quot;</span><span class="s0">No element indexed by </span><span class="s3">&quot;+e)},a.prototype.toArray=function(){return this._array.slice()},t.I=a},7810:(e,t,r)=&gt;{var n=r(7382);t.encode=function(e){var t,r=&quot;&quot;,i=function(e){return e&lt;0?1+(-e&lt;&lt;1):0+(e&lt;&lt;1)}(e);do{t=31&amp;i,(i&gt;&gt;&gt;=5)&gt;0&amp;&amp;(t|=32),r+=n.encode(t)}while(i&gt;0);return r},t.decode=function(e,t,r){var i,s,a,o,l=e.length,p=0,c=0;do{if(t&gt;=l)throw new Error(&quot;</span><span class="s0">Expected more digits </span><span class="s1">in </span><span class="s0">base </span><span class="s2">64 </span><span class="s0">VLQ value.</span><span class="s3">&quot;);if(-1===(s=n.decode(e.charCodeAt(t++))))throw new Error(&quot;</span><span class="s0">Invalid base64 digit: </span><span class="s3">&quot;+e.charAt(t-1));i=!!(32&amp;s),p+=(s&amp;=31)&lt;&lt;c,c+=5}while(i);r.value=(o=(a=p)&gt;&gt;1,1==(1&amp;a)?-o:o),r.rest=t}},7382:(e,t)=&gt;{var r=&quot;</span><span class="s0">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</span><span class="s3">&quot;.split(&quot;&quot;);t.encode=function(e){if(0&lt;=e&amp;&amp;e&lt;r.length)return r[e];throw new TypeError(&quot;</span><span class="s0">Must be between </span><span class="s2">0 </span><span class="s0">and </span><span class="s2">63</span><span class="s0">: </span><span class="s3">&quot;+e)},t.decode=function(e){return 65&lt;=e&amp;&amp;e&lt;=90?e-65:97&lt;=e&amp;&amp;e&lt;=122?e-97+26:48&lt;=e&amp;&amp;e&lt;=57?e-48+52:43==e?62:47==e?63:-1}},5698:(e,t)=&gt;{function r(e,n,i,s,a,o){var l=Math.floor((n-e)/2)+e,p=a(i,s[l],!0);return 0===p?l:p&gt;0?n-l&gt;1?r(l,n,i,s,a,o):o==t.LEAST_UPPER_BOUND?n&lt;s.length?n:-1:l:l-e&gt;1?r(e,l,i,s,a,o):o==t.LEAST_UPPER_BOUND?l:e&lt;0?-1:e}t.GREATEST_LOWER_BOUND=1,t.LEAST_UPPER_BOUND=2,t.search=function(e,n,i,s){if(0===n.length)return-1;var a=r(-1,n.length,e,n,i,s||t.GREATEST_LOWER_BOUND);if(a&lt;0)return-1;for(;a-1&gt;=0&amp;&amp;0===i(n[a],n[a-1],!0);)--a;return a}},7898:(e,t,r)=&gt;{var n=r(1639);function i(){this._array=[],this._sorted=!0,this._last={generatedLine:-1,generatedColumn:0}}i.prototype.unsortedForEach=function(e,t){this._array.forEach(e,t)},i.prototype.add=function(e){var t,r,i,s,a,o;r=e,i=(t=this._last).generatedLine,s=r.generatedLine,a=t.generatedColumn,o=r.generatedColumn,s&gt;i||s==i&amp;&amp;o&gt;=a||n.compareByGeneratedPositionsInflated(t,r)&lt;=0?(this._last=e,this._array.push(e)):(this._sorted=!1,this._array.push(e))},i.prototype.toArray=function(){return this._sorted||(this._array.sort(n.compareByGeneratedPositionsInflated),this._sorted=!0),this._array},t.H=i},4820:(e,t)=&gt;{function r(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function n(e,t,i,s){if(i&lt;s){var a=i-1;r(e,(c=i,u=s,Math.round(c+Math.random()*(u-c))),s);for(var o=e[s],l=i;l&lt;s;l++)t(e[l],o)&lt;=0&amp;&amp;r(e,a+=1,l);r(e,a+1,l);var p=a+1;n(e,t,i,p-1),n(e,t,p+1,s)}var c,u}t.U=function(e,t){n(e,t,0,e.length-1)}},8596:(e,t,r)=&gt;{var n=r(1639),i=r(5698),s=r(2579).I,a=r(7810),o=r(4820).U;function l(e){var t=e;return&quot;</span><span class="s0">string</span><span class="s3">&quot;==typeof e&amp;&amp;(t=JSON.parse(e.replace(/^</span><span class="s5">\)\]\}</span><span class="s3">'/,&quot;&quot;))),null!=t.sections?new u(t):new p(t)}function p(e){var t=e;&quot;</span><span class="s0">string</span><span class="s3">&quot;==typeof e&amp;&amp;(t=JSON.parse(e.replace(/^</span><span class="s5">\)\]\}</span><span class="s3">'/,&quot;&quot;)));var r=n.getArg(t,&quot;</span><span class="s0">version</span><span class="s3">&quot;),i=n.getArg(t,&quot;</span><span class="s0">sources</span><span class="s3">&quot;),a=n.getArg(t,&quot;</span><span class="s0">names</span><span class="s3">&quot;,[]),o=n.getArg(t,&quot;</span><span class="s0">sourceRoot</span><span class="s3">&quot;,null),l=n.getArg(t,&quot;</span><span class="s0">sourcesContent</span><span class="s3">&quot;,null),p=n.getArg(t,&quot;</span><span class="s0">mappings</span><span class="s3">&quot;),c=n.getArg(t,&quot;</span><span class="s0">file</span><span class="s3">&quot;,null);if(r!=this._version)throw new Error(&quot;</span><span class="s0">Unsupported version: </span><span class="s3">&quot;+r);i=i.map(String).map(n.normalize).map((function(e){return o&amp;&amp;n.isAbsolute(o)&amp;&amp;n.isAbsolute(e)?n.relative(o,e):e})),this._names=s.fromArray(a.map(String),!0),this._sources=s.fromArray(i,!0),this.sourceRoot=o,this.sourcesContent=l,this._mappings=p,this.file=c}function c(){this.generatedLine=0,this.generatedColumn=0,this.source=null,this.originalLine=null,this.originalColumn=null,this.name=null}function u(e){var t=e;&quot;</span><span class="s0">string</span><span class="s3">&quot;==typeof e&amp;&amp;(t=JSON.parse(e.replace(/^</span><span class="s5">\)\]\}</span><span class="s3">'/,&quot;&quot;)));var r=n.getArg(t,&quot;</span><span class="s0">version</span><span class="s3">&quot;),i=n.getArg(t,&quot;</span><span class="s0">sections</span><span class="s3">&quot;);if(r!=this._version)throw new Error(&quot;</span><span class="s0">Unsupported version: </span><span class="s3">&quot;+r);this._sources=new s,this._names=new s;var a={line:-1,column:0};this._sections=i.map((function(e){if(e.url)throw new Error(&quot;</span><span class="s0">Support </span><span class="s1">for </span><span class="s0">url field </span><span class="s1">in </span><span class="s0">sections not implemented.</span><span class="s3">&quot;);var t=n.getArg(e,&quot;</span><span class="s0">offset</span><span class="s3">&quot;),r=n.getArg(t,&quot;</span><span class="s0">line</span><span class="s3">&quot;),i=n.getArg(t,&quot;</span><span class="s0">column</span><span class="s3">&quot;);if(r&lt;a.line||r===a.line&amp;&amp;i&lt;a.column)throw new Error(&quot;</span><span class="s0">Section offsets must be ordered and non-overlapping.</span><span class="s3">&quot;);return a=t,{generatedOffset:{generatedLine:r+1,generatedColumn:i+1},consumer:new l(n.getArg(e,&quot;</span><span class="s0">map</span><span class="s3">&quot;))}}))}l.fromSourceMap=function(e){return p.fromSourceMap(e)},l.prototype._version=3,l.prototype.__generatedMappings=null,Object.defineProperty(l.prototype,&quot;</span><span class="s0">_generatedMappings</span><span class="s3">&quot;,{get:function(){return this.__generatedMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__generatedMappings}}),l.prototype.__originalMappings=null,Object.defineProperty(l.prototype,&quot;</span><span class="s0">_originalMappings</span><span class="s3">&quot;,{get:function(){return this.__originalMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__originalMappings}}),l.prototype._charIsMappingSeparator=function(e,t){var r=e.charAt(t);return&quot;</span><span class="s0">;</span><span class="s3">&quot;===r||&quot;</span><span class="s0">,</span><span class="s3">&quot;===r},l.prototype._parseMappings=function(e,t){throw new Error(&quot;</span><span class="s0">Subclasses must implement _parseMappings</span><span class="s3">&quot;)},l.GENERATED_ORDER=1,l.ORIGINAL_ORDER=2,l.GREATEST_LOWER_BOUND=1,l.LEAST_UPPER_BOUND=2,l.prototype.eachMapping=function(e,t,r){var i,s=t||null;switch(r||l.GENERATED_ORDER){case l.GENERATED_ORDER:i=this._generatedMappings;break;case l.ORIGINAL_ORDER:i=this._originalMappings;break;default:throw new Error(&quot;</span><span class="s0">Unknown order of iteration.</span><span class="s3">&quot;)}var a=this.sourceRoot;i.map((function(e){var t=null===e.source?null:this._sources.at(e.source);return null!=t&amp;&amp;null!=a&amp;&amp;(t=n.join(a,t)),{source:t,generatedLine:e.generatedLine,generatedColumn:e.generatedColumn,originalLine:e.originalLine,originalColumn:e.originalColumn,name:null===e.name?null:this._names.at(e.name)}}),this).forEach(e,s)},l.prototype.allGeneratedPositionsFor=function(e){var t=n.getArg(e,&quot;</span><span class="s0">line</span><span class="s3">&quot;),r={source:n.getArg(e,&quot;</span><span class="s0">source</span><span class="s3">&quot;),originalLine:t,originalColumn:n.getArg(e,&quot;</span><span class="s0">column</span><span class="s3">&quot;,0)};if(null!=this.sourceRoot&amp;&amp;(r.source=n.relative(this.sourceRoot,r.source)),!this._sources.has(r.source))return[];r.source=this._sources.indexOf(r.source);var s=[],a=this._findMapping(r,this._originalMappings,&quot;</span><span class="s0">originalLine</span><span class="s3">&quot;,&quot;</span><span class="s0">originalColumn</span><span class="s3">&quot;,n.compareByOriginalPositions,i.LEAST_UPPER_BOUND);if(a&gt;=0){var o=this._originalMappings[a];if(void 0===e.column)for(var l=o.originalLine;o&amp;&amp;o.originalLine===l;)s.push({line:n.getArg(o,&quot;</span><span class="s0">generatedLine</span><span class="s3">&quot;,null),column:n.getArg(o,&quot;</span><span class="s0">generatedColumn</span><span class="s3">&quot;,null),lastColumn:n.getArg(o,&quot;</span><span class="s0">lastGeneratedColumn</span><span class="s3">&quot;,null)}),o=this._originalMappings[++a];else for(var p=o.originalColumn;o&amp;&amp;o.originalLine===t&amp;&amp;o.originalColumn==p;)s.push({line:n.getArg(o,&quot;</span><span class="s0">generatedLine</span><span class="s3">&quot;,null),column:n.getArg(o,&quot;</span><span class="s0">generatedColumn</span><span class="s3">&quot;,null),lastColumn:n.getArg(o,&quot;</span><span class="s0">lastGeneratedColumn</span><span class="s3">&quot;,null)}),o=this._originalMappings[++a]}return s},t.SourceMapConsumer=l,p.prototype=Object.create(l.prototype),p.prototype.consumer=l,p.fromSourceMap=function(e){var t=Object.create(p.prototype),r=t._names=s.fromArray(e._names.toArray(),!0),i=t._sources=s.fromArray(e._sources.toArray(),!0);t.sourceRoot=e._sourceRoot,t.sourcesContent=e._generateSourcesContent(t._sources.toArray(),t.sourceRoot),t.file=e._file;for(var a=e._mappings.toArray().slice(),l=t.__generatedMappings=[],u=t.__originalMappings=[],d=0,h=a.length;d&lt;h;d++){var f=a[d],m=new c;m.generatedLine=f.generatedLine,m.generatedColumn=f.generatedColumn,f.source&amp;&amp;(m.source=i.indexOf(f.source),m.originalLine=f.originalLine,m.originalColumn=f.originalColumn,f.name&amp;&amp;(m.name=r.indexOf(f.name)),u.push(m)),l.push(m)}return o(t.__originalMappings,n.compareByOriginalPositions),t},p.prototype._version=3,Object.defineProperty(p.prototype,&quot;</span><span class="s0">sources</span><span class="s3">&quot;,{get:function(){return this._sources.toArray().map((function(e){return null!=this.sourceRoot?n.join(this.sourceRoot,e):e}),this)}}),p.prototype._parseMappings=function(e,t){for(var r,i,s,l,p,u=1,d=0,h=0,f=0,m=0,y=0,T=e.length,b=0,g={},S={},x=[],E=[];b&lt;T;)if(&quot;</span><span class="s0">;</span><span class="s3">&quot;===e.charAt(b))u++,b++,d=0;else if(&quot;</span><span class="s0">,</span><span class="s3">&quot;===e.charAt(b))b++;else{for((r=new c).generatedLine=u,l=b;l&lt;T&amp;&amp;!this._charIsMappingSeparator(e,l);l++);if(s=g[i=e.slice(b,l)])b+=i.length;else{for(s=[];b&lt;l;)a.decode(e,b,S),p=S.value,b=S.rest,s.push(p);if(2===s.length)throw new Error(&quot;</span><span class="s0">Found a source, but no line and column</span><span class="s3">&quot;);if(3===s.length)throw new Error(&quot;</span><span class="s0">Found a source and line, but no column</span><span class="s3">&quot;);g[i]=s}r.generatedColumn=d+s[0],d=r.generatedColumn,s.length&gt;1&amp;&amp;(r.source=m+s[1],m+=s[1],r.originalLine=h+s[2],h=r.originalLine,r.originalLine+=1,r.originalColumn=f+s[3],f=r.originalColumn,s.length&gt;4&amp;&amp;(r.name=y+s[4],y+=s[4])),E.push(r),&quot;</span><span class="s0">number</span><span class="s3">&quot;==typeof r.originalLine&amp;&amp;x.push(r)}o(E,n.compareByGeneratedPositionsDeflated),this.__generatedMappings=E,o(x,n.compareByOriginalPositions),this.__originalMappings=x},p.prototype._findMapping=function(e,t,r,n,s,a){if(e[r]&lt;=0)throw new TypeError(&quot;</span><span class="s0">Line must be greater than or equal to </span><span class="s2">1</span><span class="s0">, got </span><span class="s3">&quot;+e[r]);if(e[n]&lt;0)throw new TypeError(&quot;</span><span class="s0">Column must be greater than or equal to </span><span class="s2">0</span><span class="s0">, got </span><span class="s3">&quot;+e[n]);return i.search(e,t,s,a)},p.prototype.computeColumnSpans=function(){for(var e=0;e&lt;this._generatedMappings.length;++e){var t=this._generatedMappings[e];if(e+1&lt;this._generatedMappings.length){var r=this._generatedMappings[e+1];if(t.generatedLine===r.generatedLine){t.lastGeneratedColumn=r.generatedColumn-1;continue}}t.lastGeneratedColumn=1/0}},p.prototype.originalPositionFor=function(e){var t={generatedLine:n.getArg(e,&quot;</span><span class="s0">line</span><span class="s3">&quot;),generatedColumn:n.getArg(e,&quot;</span><span class="s0">column</span><span class="s3">&quot;)},r=this._findMapping(t,this._generatedMappings,&quot;</span><span class="s0">generatedLine</span><span class="s3">&quot;,&quot;</span><span class="s0">generatedColumn</span><span class="s3">&quot;,n.compareByGeneratedPositionsDeflated,n.getArg(e,&quot;</span><span class="s0">bias</span><span class="s3">&quot;,l.GREATEST_LOWER_BOUND));if(r&gt;=0){var i=this._generatedMappings[r];if(i.generatedLine===t.generatedLine){var s=n.getArg(i,&quot;</span><span class="s0">source</span><span class="s3">&quot;,null);null!==s&amp;&amp;(s=this._sources.at(s),null!=this.sourceRoot&amp;&amp;(s=n.join(this.sourceRoot,s)));var a=n.getArg(i,&quot;</span><span class="s0">name</span><span class="s3">&quot;,null);return null!==a&amp;&amp;(a=this._names.at(a)),{source:s,line:n.getArg(i,&quot;</span><span class="s0">originalLine</span><span class="s3">&quot;,null),column:n.getArg(i,&quot;</span><span class="s0">originalColumn</span><span class="s3">&quot;,null),name:a}}}return{source:null,line:null,column:null,name:null}},p.prototype.hasContentsOfAllSources=function(){return!!this.sourcesContent&amp;&amp;this.sourcesContent.length&gt;=this._sources.size()&amp;&amp;!this.sourcesContent.some((function(e){return null==e}))},p.prototype.sourceContentFor=function(e,t){if(!this.sourcesContent)return null;if(null!=this.sourceRoot&amp;&amp;(e=n.relative(this.sourceRoot,e)),this._sources.has(e))return this.sourcesContent[this._sources.indexOf(e)];var r;if(null!=this.sourceRoot&amp;&amp;(r=n.urlParse(this.sourceRoot))){var i=e.replace(/^file:</span><span class="s5">\/\/</span><span class="s3">/,&quot;&quot;);if(&quot;</span><span class="s0">file</span><span class="s3">&quot;==r.scheme&amp;&amp;this._sources.has(i))return this.sourcesContent[this._sources.indexOf(i)];if((!r.path||&quot;</span><span class="s0">/</span><span class="s3">&quot;==r.path)&amp;&amp;this._sources.has(&quot;</span><span class="s0">/</span><span class="s3">&quot;+e))return this.sourcesContent[this._sources.indexOf(&quot;</span><span class="s0">/</span><span class="s3">&quot;+e)]}if(t)return null;throw new Error('&quot;'+e+'&quot; is not in the SourceMap.')},p.prototype.generatedPositionFor=function(e){var t=n.getArg(e,&quot;</span><span class="s0">source</span><span class="s3">&quot;);if(null!=this.sourceRoot&amp;&amp;(t=n.relative(this.sourceRoot,t)),!this._sources.has(t))return{line:null,column:null,lastColumn:null};var r={source:t=this._sources.indexOf(t),originalLine:n.getArg(e,&quot;</span><span class="s0">line</span><span class="s3">&quot;),originalColumn:n.getArg(e,&quot;</span><span class="s0">column</span><span class="s3">&quot;)},i=this._findMapping(r,this._originalMappings,&quot;</span><span class="s0">originalLine</span><span class="s3">&quot;,&quot;</span><span class="s0">originalColumn</span><span class="s3">&quot;,n.compareByOriginalPositions,n.getArg(e,&quot;</span><span class="s0">bias</span><span class="s3">&quot;,l.GREATEST_LOWER_BOUND));if(i&gt;=0){var s=this._originalMappings[i];if(s.source===r.source)return{line:n.getArg(s,&quot;</span><span class="s0">generatedLine</span><span class="s3">&quot;,null),column:n.getArg(s,&quot;</span><span class="s0">generatedColumn</span><span class="s3">&quot;,null),lastColumn:n.getArg(s,&quot;</span><span class="s0">lastGeneratedColumn</span><span class="s3">&quot;,null)}}return{line:null,column:null,lastColumn:null}},u.prototype=Object.create(l.prototype),u.prototype.constructor=l,u.prototype._version=3,Object.defineProperty(u.prototype,&quot;</span><span class="s0">sources</span><span class="s3">&quot;,{get:function(){for(var e=[],t=0;t&lt;this._sections.length;t++)for(var r=0;r&lt;this._sections[t].consumer.sources.length;r++)e.push(this._sections[t].consumer.sources[r]);return e}}),u.prototype.originalPositionFor=function(e){var t={generatedLine:n.getArg(e,&quot;</span><span class="s0">line</span><span class="s3">&quot;),generatedColumn:n.getArg(e,&quot;</span><span class="s0">column</span><span class="s3">&quot;)},r=i.search(t,this._sections,(function(e,t){return e.generatedLine-t.generatedOffset.generatedLine||e.generatedColumn-t.generatedOffset.generatedColumn})),s=this._sections[r];return s?s.consumer.originalPositionFor({line:t.generatedLine-(s.generatedOffset.generatedLine-1),column:t.generatedColumn-(s.generatedOffset.generatedLine===t.generatedLine?s.generatedOffset.generatedColumn-1:0),bias:e.bias}):{source:null,line:null,column:null,name:null}},u.prototype.hasContentsOfAllSources=function(){return this._sections.every((function(e){return e.consumer.hasContentsOfAllSources()}))},u.prototype.sourceContentFor=function(e,t){for(var r=0;r&lt;this._sections.length;r++){var n=this._sections[r].consumer.sourceContentFor(e,!0);if(n)return n}if(t)return null;throw new Error('&quot;'+e+'&quot; is not in the SourceMap.')},u.prototype.generatedPositionFor=function(e){for(var t=0;t&lt;this._sections.length;t++){var r=this._sections[t];if(-1!==r.consumer.sources.indexOf(n.getArg(e,&quot;</span><span class="s0">source</span><span class="s3">&quot;))){var i=r.consumer.generatedPositionFor(e);if(i)return{line:i.line+(r.generatedOffset.generatedLine-1),column:i.column+(r.generatedOffset.generatedLine===i.line?r.generatedOffset.generatedColumn-1:0)}}}return{line:null,column:null}},u.prototype._parseMappings=function(e,t){this.__generatedMappings=[],this.__originalMappings=[];for(var r=0;r&lt;this._sections.length;r++)for(var i=this._sections[r],s=i.consumer._generatedMappings,a=0;a&lt;s.length;a++){var l=s[a],p=i.consumer._sources.at(l.source);null!==i.consumer.sourceRoot&amp;&amp;(p=n.join(i.consumer.sourceRoot,p)),this._sources.add(p),p=this._sources.indexOf(p);var c=i.consumer._names.at(l.name);this._names.add(c),c=this._names.indexOf(c);var u={source:p,generatedLine:l.generatedLine+(i.generatedOffset.generatedLine-1),generatedColumn:l.generatedColumn+(i.generatedOffset.generatedLine===l.generatedLine?i.generatedOffset.generatedColumn-1:0),originalLine:l.originalLine,originalColumn:l.originalColumn,name:c};this.__generatedMappings.push(u),&quot;</span><span class="s0">number</span><span class="s3">&quot;==typeof u.originalLine&amp;&amp;this.__originalMappings.push(u)}o(this.__generatedMappings,n.compareByGeneratedPositionsDeflated),o(this.__originalMappings,n.compareByOriginalPositions)}},7969:(e,t,r)=&gt;{var n=r(7810),i=r(1639),s=r(2579).I,a=r(7898).H;function o(e){e||(e={}),this._file=i.getArg(e,&quot;</span><span class="s0">file</span><span class="s3">&quot;,null),this._sourceRoot=i.getArg(e,&quot;</span><span class="s0">sourceRoot</span><span class="s3">&quot;,null),this._skipValidation=i.getArg(e,&quot;</span><span class="s0">skipValidation</span><span class="s3">&quot;,!1),this._sources=new s,this._names=new s,this._mappings=new a,this._sourcesContents=null}o.prototype._version=3,o.fromSourceMap=function(e){var t=e.sourceRoot,r=new o({file:e.file,sourceRoot:t});return e.eachMapping((function(e){var n={generated:{line:e.generatedLine,column:e.generatedColumn}};null!=e.source&amp;&amp;(n.source=e.source,null!=t&amp;&amp;(n.source=i.relative(t,n.source)),n.original={line:e.originalLine,column:e.originalColumn},null!=e.name&amp;&amp;(n.name=e.name)),r.addMapping(n)})),e.sources.forEach((function(t){var n=e.sourceContentFor(t);null!=n&amp;&amp;r.setSourceContent(t,n)})),r},o.prototype.addMapping=function(e){var t=i.getArg(e,&quot;</span><span class="s0">generated</span><span class="s3">&quot;),r=i.getArg(e,&quot;</span><span class="s0">original</span><span class="s3">&quot;,null),n=i.getArg(e,&quot;</span><span class="s0">source</span><span class="s3">&quot;,null),s=i.getArg(e,&quot;</span><span class="s0">name</span><span class="s3">&quot;,null);this._skipValidation||this._validateMapping(t,r,n,s),null!=n&amp;&amp;(n=String(n),this._sources.has(n)||this._sources.add(n)),null!=s&amp;&amp;(s=String(s),this._names.has(s)||this._names.add(s)),this._mappings.add({generatedLine:t.line,generatedColumn:t.column,originalLine:null!=r&amp;&amp;r.line,originalColumn:null!=r&amp;&amp;r.column,source:n,name:s})},o.prototype.setSourceContent=function(e,t){var r=e;null!=this._sourceRoot&amp;&amp;(r=i.relative(this._sourceRoot,r)),null!=t?(this._sourcesContents||(this._sourcesContents=Object.create(null)),this._sourcesContents[i.toSetString(r)]=t):this._sourcesContents&amp;&amp;(delete this._sourcesContents[i.toSetString(r)],0===Object.keys(this._sourcesContents).length&amp;&amp;(this._sourcesContents=null))},o.prototype.applySourceMap=function(e,t,r){var n=t;if(null==t){if(null==e.file)throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map</span><span class="s4">\'</span><span class="s3">s &quot;</span><span class="s0">file</span><span class="s3">&quot; property. Both were omitted.');n=e.file}var a=this._sourceRoot;null!=a&amp;&amp;(n=i.relative(a,n));var o=new s,l=new s;this._mappings.unsortedForEach((function(t){if(t.source===n&amp;&amp;null!=t.originalLine){var s=e.originalPositionFor({line:t.originalLine,column:t.originalColumn});null!=s.source&amp;&amp;(t.source=s.source,null!=r&amp;&amp;(t.source=i.join(r,t.source)),null!=a&amp;&amp;(t.source=i.relative(a,t.source)),t.originalLine=s.line,t.originalColumn=s.column,null!=s.name&amp;&amp;(t.name=s.name))}var p=t.source;null==p||o.has(p)||o.add(p);var c=t.name;null==c||l.has(c)||l.add(c)}),this),this._sources=o,this._names=l,e.sources.forEach((function(t){var n=e.sourceContentFor(t);null!=n&amp;&amp;(null!=r&amp;&amp;(t=i.join(r,t)),null!=a&amp;&amp;(t=i.relative(a,t)),this.setSourceContent(t,n))}),this)},o.prototype._validateMapping=function(e,t,r,n){if(t&amp;&amp;&quot;</span><span class="s0">number</span><span class="s3">&quot;!=typeof t.line&amp;&amp;&quot;</span><span class="s0">number</span><span class="s3">&quot;!=typeof t.column)throw new Error(&quot;</span><span class="s0">original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass </span><span class="s1">null for </span><span class="s0">the original mapping instead of an object </span><span class="s1">with </span><span class="s0">empty or </span><span class="s1">null </span><span class="s0">values.</span><span class="s3">&quot;);if((!(e&amp;&amp;&quot;</span><span class="s0">line</span><span class="s3">&quot;in e&amp;&amp;&quot;</span><span class="s0">column</span><span class="s3">&quot;in e&amp;&amp;e.line&gt;0&amp;&amp;e.column&gt;=0)||t||r||n)&amp;&amp;!(e&amp;&amp;&quot;</span><span class="s0">line</span><span class="s3">&quot;in e&amp;&amp;&quot;</span><span class="s0">column</span><span class="s3">&quot;in e&amp;&amp;t&amp;&amp;&quot;</span><span class="s0">line</span><span class="s3">&quot;in t&amp;&amp;&quot;</span><span class="s0">column</span><span class="s3">&quot;in t&amp;&amp;e.line&gt;0&amp;&amp;e.column&gt;=0&amp;&amp;t.line&gt;0&amp;&amp;t.column&gt;=0&amp;&amp;r))throw new Error(&quot;</span><span class="s0">Invalid mapping: </span><span class="s3">&quot;+JSON.stringify({generated:e,source:r,original:t,name:n}))},o.prototype._serializeMappings=function(){for(var e,t,r,s,a=0,o=1,l=0,p=0,c=0,u=0,d=&quot;&quot;,h=this._mappings.toArray(),f=0,m=h.length;f&lt;m;f++){if(e=&quot;&quot;,(t=h[f]).generatedLine!==o)for(a=0;t.generatedLine!==o;)e+=&quot;</span><span class="s0">;</span><span class="s3">&quot;,o++;else if(f&gt;0){if(!i.compareByGeneratedPositionsInflated(t,h[f-1]))continue;e+=&quot;</span><span class="s0">,</span><span class="s3">&quot;}e+=n.encode(t.generatedColumn-a),a=t.generatedColumn,null!=t.source&amp;&amp;(s=this._sources.indexOf(t.source),e+=n.encode(s-u),u=s,e+=n.encode(t.originalLine-1-p),p=t.originalLine-1,e+=n.encode(t.originalColumn-l),l=t.originalColumn,null!=t.name&amp;&amp;(r=this._names.indexOf(t.name),e+=n.encode(r-c),c=r)),d+=e}return d},o.prototype._generateSourcesContent=function(e,t){return e.map((function(e){if(!this._sourcesContents)return null;null!=t&amp;&amp;(e=i.relative(t,e));var r=i.toSetString(e);return Object.prototype.hasOwnProperty.call(this._sourcesContents,r)?this._sourcesContents[r]:null}),this)},o.prototype.toJSON=function(){var e={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};return null!=this._file&amp;&amp;(e.file=this._file),null!=this._sourceRoot&amp;&amp;(e.sourceRoot=this._sourceRoot),this._sourcesContents&amp;&amp;(e.sourcesContent=this._generateSourcesContent(e.sources,e.sourceRoot)),e},o.prototype.toString=function(){return JSON.stringify(this.toJSON())},t.SourceMapGenerator=o},9123:(e,t,r)=&gt;{var n=r(7969).SourceMapGenerator,i=r(1639),s=/(</span><span class="s4">\r</span><span class="s3">?</span><span class="s4">\n</span><span class="s3">)/,a=&quot;</span><span class="s0">$$$isSourceNode$$$</span><span class="s3">&quot;;function o(e,t,r,n,i){this.children=[],this.sourceContents={},this.line=null==e?null:e,this.column=null==t?null:t,this.source=null==r?null:r,this.name=null==i?null:i,this[a]=!0,null!=n&amp;&amp;this.add(n)}o.fromStringWithSourceMap=function(e,t,r){var n=new o,a=e.split(s),l=0,p=function(){return e()+(e()||&quot;&quot;);function e(){return l&lt;a.length?a[l++]:void 0}},c=1,u=0,d=null;return t.eachMapping((function(e){if(null!==d){if(!(c&lt;e.generatedLine)){var t=(r=a[l]).substr(0,e.generatedColumn-u);return a[l]=r.substr(e.generatedColumn-u),u=e.generatedColumn,h(d,t),void(d=e)}h(d,p()),c++,u=0}for(;c&lt;e.generatedLine;)n.add(p()),c++;if(u&lt;e.generatedColumn){var r=a[l];n.add(r.substr(0,e.generatedColumn)),a[l]=r.substr(e.generatedColumn),u=e.generatedColumn}d=e}),this),l&lt;a.length&amp;&amp;(d&amp;&amp;h(d,p()),n.add(a.splice(l).join(&quot;&quot;))),t.sources.forEach((function(e){var s=t.sourceContentFor(e);null!=s&amp;&amp;(null!=r&amp;&amp;(e=i.join(r,e)),n.setSourceContent(e,s))})),n;function h(e,t){if(null===e||void 0===e.source)n.add(t);else{var s=r?i.join(r,e.source):e.source;n.add(new o(e.originalLine,e.originalColumn,s,t,e.name))}}},o.prototype.add=function(e){if(Array.isArray(e))e.forEach((function(e){this.add(e)}),this);else{if(!e[a]&amp;&amp;&quot;</span><span class="s0">string</span><span class="s3">&quot;!=typeof e)throw new TypeError(&quot;</span><span class="s0">Expected a SourceNode, string, or an array of SourceNodes and strings. Got </span><span class="s3">&quot;+e);e&amp;&amp;this.children.push(e)}return this},o.prototype.prepend=function(e){if(Array.isArray(e))for(var t=e.length-1;t&gt;=0;t--)this.prepend(e[t]);else{if(!e[a]&amp;&amp;&quot;</span><span class="s0">string</span><span class="s3">&quot;!=typeof e)throw new TypeError(&quot;</span><span class="s0">Expected a SourceNode, string, or an array of SourceNodes and strings. Got </span><span class="s3">&quot;+e);this.children.unshift(e)}return this},o.prototype.walk=function(e){for(var t,r=0,n=this.children.length;r&lt;n;r++)(t=this.children[r])[a]?t.walk(e):&quot;&quot;!==t&amp;&amp;e(t,{source:this.source,line:this.line,column:this.column,name:this.name})},o.prototype.join=function(e){var t,r,n=this.children.length;if(n&gt;0){for(t=[],r=0;r&lt;n-1;r++)t.push(this.children[r]),t.push(e);t.push(this.children[r]),this.children=t}return this},o.prototype.replaceRight=function(e,t){var r=this.children[this.children.length-1];return r[a]?r.replaceRight(e,t):&quot;</span><span class="s0">string</span><span class="s3">&quot;==typeof r?this.children[this.children.length-1]=r.replace(e,t):this.children.push(&quot;&quot;.replace(e,t)),this},o.prototype.setSourceContent=function(e,t){this.sourceContents[i.toSetString(e)]=t},o.prototype.walkSourceContents=function(e){for(var t=0,r=this.children.length;t&lt;r;t++)this.children[t][a]&amp;&amp;this.children[t].walkSourceContents(e);var n=Object.keys(this.sourceContents);for(t=0,r=n.length;t&lt;r;t++)e(i.fromSetString(n[t]),this.sourceContents[n[t]])},o.prototype.toString=function(){var e=&quot;&quot;;return this.walk((function(t){e+=t})),e},o.prototype.toStringWithSourceMap=function(e){var t={code:&quot;&quot;,line:1,column:0},r=new n(e),i=!1,s=null,a=null,o=null,l=null;return this.walk((function(e,n){t.code+=e,null!==n.source&amp;&amp;null!==n.line&amp;&amp;null!==n.column?(s===n.source&amp;&amp;a===n.line&amp;&amp;o===n.column&amp;&amp;l===n.name||r.addMapping({source:n.source,original:{line:n.line,column:n.column},generated:{line:t.line,column:t.column},name:n.name}),s=n.source,a=n.line,o=n.column,l=n.name,i=!0):i&amp;&amp;(r.addMapping({generated:{line:t.line,column:t.column}}),s=null,i=!1);for(var p=0,c=e.length;p&lt;c;p++)10===e.charCodeAt(p)?(t.line++,t.column=0,p+1===c?(s=null,i=!1):i&amp;&amp;r.addMapping({source:n.source,original:{line:n.line,column:n.column},generated:{line:t.line,column:t.column},name:n.name})):t.column++})),this.walkSourceContents((function(e,t){r.setSourceContent(e,t)})),{code:t.code,map:r}},t.SourceNode=o},1639:(e,t)=&gt;{t.getArg=function(e,t,r){if(t in e)return e[t];if(3===arguments.length)return r;throw new Error('&quot;'+t+'&quot; is a required argument.')};var r=/^(?:([</span><span class="s5">\w</span><span class="s3">+</span><span class="s5">\-</span><span class="s3">.]+):)?</span><span class="s5">\/\/</span><span class="s3">(?:(</span><span class="s5">\w</span><span class="s3">+:</span><span class="s5">\w</span><span class="s3">+)@)?([</span><span class="s5">\w</span><span class="s3">.]*)(?::(</span><span class="s5">\d</span><span class="s3">+))?(</span><span class="s5">\S</span><span class="s3">*)$/,n=/^data:.+</span><span class="s5">\,</span><span class="s3">.+$/;function i(e){var t=e.match(r);return t?{scheme:t[1],auth:t[2],host:t[3],port:t[4],path:t[5]}:null}function s(e){var t=&quot;&quot;;return e.scheme&amp;&amp;(t+=e.scheme+&quot;</span><span class="s0">:</span><span class="s3">&quot;),t+=&quot;</span><span class="s6">//&quot;,e.auth&amp;&amp;(t+=e.auth+&quot;@&quot;),e.host&amp;&amp;(t+=e.host),e.port&amp;&amp;(t+=&quot;:&quot;+e.port),e.path&amp;&amp;(t+=e.path),t}function a(e){var r=e,n=i(e);if(n){if(!n.path)return e;r=n.path}for(var a,o=t.isAbsolute(r),l=r.split(/\/+/),p=0,c=l.length-1;c&gt;=0;c--)&quot;.&quot;===(a=l[c])?l.splice(c,1):&quot;..&quot;===a?p++:p&gt;0&amp;&amp;(&quot;&quot;===a?(l.splice(c+1,p),p=0):(l.splice(c,2),p--));return&quot;&quot;===(r=l.join(&quot;/&quot;))&amp;&amp;(r=o?&quot;/&quot;:&quot;.&quot;),n?(n.path=r,s(n)):r}t.urlParse=i,t.urlGenerate=s,t.normalize=a,t.join=function(e,t){&quot;&quot;===e&amp;&amp;(e=&quot;.&quot;),&quot;&quot;===t&amp;&amp;(t=&quot;.&quot;);var r=i(t),o=i(e);if(o&amp;&amp;(e=o.path||&quot;/&quot;),r&amp;&amp;!r.scheme)return o&amp;&amp;(r.scheme=o.scheme),s(r);if(r||t.match(n))return t;if(o&amp;&amp;!o.host&amp;&amp;!o.path)return o.host=t,s(o);var l=&quot;/&quot;===t.charAt(0)?t:a(e.replace(/\/+$/,&quot;&quot;)+&quot;/&quot;+t);return o?(o.path=l,s(o)):l},t.isAbsolute=function(e){return&quot;/&quot;===e.charAt(0)||!!e.match(r)},t.relative=function(e,t){&quot;&quot;===e&amp;&amp;(e=&quot;.&quot;),e=e.replace(/\/$/,&quot;&quot;);for(var r=0;0!==t.indexOf(e+&quot;/&quot;);){var n=e.lastIndexOf(&quot;/&quot;);if(n&lt;0)return t;if((e=e.slice(0,n)).match(/^([^\/]+:\/)?\/*$/))return t;++r}return Array(r+1).join(&quot;../&quot;)+t.substr(e.length+1)};var o=!(&quot;__proto__&quot;in Object.create(null));function l(e){return e}function p(e){if(!e)return!1;var t=e.length;if(t&lt;9)return!1;if(95!==e.charCodeAt(t-1)||95!==e.charCodeAt(t-2)||111!==e.charCodeAt(t-3)||116!==e.charCodeAt(t-4)||111!==e.charCodeAt(t-5)||114!==e.charCodeAt(t-6)||112!==e.charCodeAt(t-7)||95!==e.charCodeAt(t-8)||95!==e.charCodeAt(t-9))return!1;for(var r=t-10;r&gt;=0;r--)if(36!==e.charCodeAt(r))return!1;return!0}function c(e,t){return e===t?0:e&gt;t?1:-1}t.toSetString=o?l:function(e){return p(e)?&quot;$&quot;+e:e},t.fromSetString=o?l:function(e){return p(e)?e.slice(1):e},t.compareByOriginalPositions=function(e,t,r){var n=e.source-t.source;return 0!==n||0!=(n=e.originalLine-t.originalLine)||0!=(n=e.originalColumn-t.originalColumn)||r||0!=(n=e.generatedColumn-t.generatedColumn)||0!=(n=e.generatedLine-t.generatedLine)?n:e.name-t.name},t.compareByGeneratedPositionsDeflated=function(e,t,r){var n=e.generatedLine-t.generatedLine;return 0!==n||0!=(n=e.generatedColumn-t.generatedColumn)||r||0!=(n=e.source-t.source)||0!=(n=e.originalLine-t.originalLine)||0!=(n=e.originalColumn-t.originalColumn)?n:e.name-t.name},t.compareByGeneratedPositionsInflated=function(e,t){var r=e.generatedLine-t.generatedLine;return 0!==r||0!=(r=e.generatedColumn-t.generatedColumn)||0!==(r=c(e.source,t.source))||0!=(r=e.originalLine-t.originalLine)||0!=(r=e.originalColumn-t.originalColumn)?r:c(e.name,t.name)}},8737:(e,t,r)=&gt;{t.SourceMapGenerator=r(7969).SourceMapGenerator,t.SourceMapConsumer=r(8596).SourceMapConsumer,t.SourceNode=r(9123).SourceNode},4468:(e,t)=&gt;{&quot;use strict&quot;;t.ZP=function(){throw Error(&quot;Test Error stack&quot;)},t.U1=void 0,t.U1=12},2037:e=&gt;{&quot;use strict&quot;;e.exports=require(&quot;os&quot;)},6224:e=&gt;{&quot;use strict&quot;;e.exports=require(&quot;tty&quot;)},3837:e=&gt;{&quot;use strict&quot;;e.exports=require(&quot;util&quot;)},964:e=&gt;{&quot;use strict&quot;;e.exports=JSON.parse('{&quot;builtin&quot;:{&quot;Array&quot;:false,&quot;ArrayBuffer&quot;:false,&quot;Atomics&quot;:false,&quot;BigInt&quot;:false,&quot;BigInt64Array&quot;:false,&quot;BigUint64Array&quot;:false,&quot;Boolean&quot;:false,&quot;constructor&quot;:false,&quot;DataView&quot;:false,&quot;Date&quot;:false,&quot;decodeURI&quot;:false,&quot;decodeURIComponent&quot;:false,&quot;encodeURI&quot;:false,&quot;encodeURIComponent&quot;:false,&quot;Error&quot;:false,&quot;escape&quot;:false,&quot;eval&quot;:false,&quot;EvalError&quot;:false,&quot;Float32Array&quot;:false,&quot;Float64Array&quot;:false,&quot;Function&quot;:false,&quot;globalThis&quot;:false,&quot;hasOwnProperty&quot;:false,&quot;Infinity&quot;:false,&quot;Int16Array&quot;:false,&quot;Int32Array&quot;:false,&quot;Int8Array&quot;:false,&quot;isFinite&quot;:false,&quot;isNaN&quot;:false,&quot;isPrototypeOf&quot;:false,&quot;JSON&quot;:false,&quot;Map&quot;:false,&quot;Math&quot;:false,&quot;NaN&quot;:false,&quot;Number&quot;:false,&quot;Object&quot;:false,&quot;parseFloat&quot;:false,&quot;parseInt&quot;:false,&quot;Promise&quot;:false,&quot;propertyIsEnumerable&quot;:false,&quot;Proxy&quot;:false,&quot;RangeError&quot;:false,&quot;ReferenceError&quot;:false,&quot;Reflect&quot;:false,&quot;RegExp&quot;:false,&quot;Set&quot;:false,&quot;SharedArrayBuffer&quot;:false,&quot;String&quot;:false,&quot;Symbol&quot;:false,&quot;SyntaxError&quot;:false,&quot;toLocaleString&quot;:false,&quot;toString&quot;:false,&quot;TypeError&quot;:false,&quot;Uint16Array&quot;:false,&quot;Uint32Array&quot;:false,&quot;Uint8Array&quot;:false,&quot;Uint8ClampedArray&quot;:false,&quot;undefined&quot;:false,&quot;unescape&quot;:false,&quot;URIError&quot;:false,&quot;valueOf&quot;:false,&quot;WeakMap&quot;:false,&quot;WeakSet&quot;:false},&quot;es5&quot;:{&quot;Array&quot;:false,&quot;Boolean&quot;:false,&quot;constructor&quot;:false,&quot;Date&quot;:false,&quot;decodeURI&quot;:false,&quot;decodeURIComponent&quot;:false,&quot;encodeURI&quot;:false,&quot;encodeURIComponent&quot;:false,&quot;Error&quot;:false,&quot;escape&quot;:false,&quot;eval&quot;:false,&quot;EvalError&quot;:false,&quot;Function&quot;:false,&quot;hasOwnProperty&quot;:false,&quot;Infinity&quot;:false,&quot;isFinite&quot;:false,&quot;isNaN&quot;:false,&quot;isPrototypeOf&quot;:false,&quot;JSON&quot;:false,&quot;Math&quot;:false,&quot;NaN&quot;:false,&quot;Number&quot;:false,&quot;Object&quot;:false,&quot;parseFloat&quot;:false,&quot;parseInt&quot;:false,&quot;propertyIsEnumerable&quot;:false,&quot;RangeError&quot;:false,&quot;ReferenceError&quot;:false,&quot;RegExp&quot;:false,&quot;String&quot;:false,&quot;SyntaxError&quot;:false,&quot;toLocaleString&quot;:false,&quot;toString&quot;:false,&quot;TypeError&quot;:false,&quot;undefined&quot;:false,&quot;unescape&quot;:false,&quot;URIError&quot;:false,&quot;valueOf&quot;:false},&quot;es2015&quot;:{&quot;Array&quot;:false,&quot;ArrayBuffer&quot;:false,&quot;Boolean&quot;:false,&quot;constructor&quot;:false,&quot;DataView&quot;:false,&quot;Date&quot;:false,&quot;decodeURI&quot;:false,&quot;decodeURIComponent&quot;:false,&quot;encodeURI&quot;:false,&quot;encodeURIComponent&quot;:false,&quot;Error&quot;:false,&quot;escape&quot;:false,&quot;eval&quot;:false,&quot;EvalError&quot;:false,&quot;Float32Array&quot;:false,&quot;Float64Array&quot;:false,&quot;Function&quot;:false,&quot;hasOwnProperty&quot;:false,&quot;Infinity&quot;:false,&quot;Int16Array&quot;:false,&quot;Int32Array&quot;:false,&quot;Int8Array&quot;:false,&quot;isFinite&quot;:false,&quot;isNaN&quot;:false,&quot;isPrototypeOf&quot;:false,&quot;JSON&quot;:false,&quot;Map&quot;:false,&quot;Math&quot;:false,&quot;NaN&quot;:false,&quot;Number&quot;:false,&quot;Object&quot;:false,&quot;parseFloat&quot;:false,&quot;parseInt&quot;:false,&quot;Promise&quot;:false,&quot;propertyIsEnumerable&quot;:false,&quot;Proxy&quot;:false,&quot;RangeError&quot;:false,&quot;ReferenceError&quot;:false,&quot;Reflect&quot;:false,&quot;RegExp&quot;:false,&quot;Set&quot;:false,&quot;String&quot;:false,&quot;Symbol&quot;:false,&quot;SyntaxError&quot;:false,&quot;toLocaleString&quot;:false,&quot;toString&quot;:false,&quot;TypeError&quot;:false,&quot;Uint16Array&quot;:false,&quot;Uint32Array&quot;:false,&quot;Uint8Array&quot;:false,&quot;Uint8ClampedArray&quot;:false,&quot;undefined&quot;:false,&quot;unescape&quot;:false,&quot;URIError&quot;:false,&quot;valueOf&quot;:false,&quot;WeakMap&quot;:false,&quot;WeakSet&quot;:false},&quot;es2017&quot;:{&quot;Array&quot;:false,&quot;ArrayBuffer&quot;:false,&quot;Atomics&quot;:false,&quot;Boolean&quot;:false,&quot;constructor&quot;:false,&quot;DataView&quot;:false,&quot;Date&quot;:false,&quot;decodeURI&quot;:false,&quot;decodeURIComponent&quot;:false,&quot;encodeURI&quot;:false,&quot;encodeURIComponent&quot;:false,&quot;Error&quot;:false,&quot;escape&quot;:false,&quot;eval&quot;:false,&quot;EvalError&quot;:false,&quot;Float32Array&quot;:false,&quot;Float64Array&quot;:false,&quot;Function&quot;:false,&quot;hasOwnProperty&quot;:false,&quot;Infinity&quot;:false,&quot;Int16Array&quot;:false,&quot;Int32Array&quot;:false,&quot;Int8Array&quot;:false,&quot;isFinite&quot;:false,&quot;isNaN&quot;:false,&quot;isPrototypeOf&quot;:false,&quot;JSON&quot;:false,&quot;Map&quot;:false,&quot;Math&quot;:false,&quot;NaN&quot;:false,&quot;Number&quot;:false,&quot;Object&quot;:false,&quot;parseFloat&quot;:false,&quot;parseInt&quot;:false,&quot;Promise&quot;:false,&quot;propertyIsEnumerable&quot;:false,&quot;Proxy&quot;:false,&quot;RangeError&quot;:false,&quot;ReferenceError&quot;:false,&quot;Reflect&quot;:false,&quot;RegExp&quot;:false,&quot;Set&quot;:false,&quot;SharedArrayBuffer&quot;:false,&quot;String&quot;:false,&quot;Symbol&quot;:false,&quot;SyntaxError&quot;:false,&quot;toLocaleString&quot;:false,&quot;toString&quot;:false,&quot;TypeError&quot;:false,&quot;Uint16Array&quot;:false,&quot;Uint32Array&quot;:false,&quot;Uint8Array&quot;:false,&quot;Uint8ClampedArray&quot;:false,&quot;undefined&quot;:false,&quot;unescape&quot;:false,&quot;URIError&quot;:false,&quot;valueOf&quot;:false,&quot;WeakMap&quot;:false,&quot;WeakSet&quot;:false},&quot;browser&quot;:{&quot;AbortController&quot;:false,&quot;AbortSignal&quot;:false,&quot;addEventListener&quot;:false,&quot;alert&quot;:false,&quot;AnalyserNode&quot;:false,&quot;Animation&quot;:false,&quot;AnimationEffectReadOnly&quot;:false,&quot;AnimationEffectTiming&quot;:false,&quot;AnimationEffectTimingReadOnly&quot;:false,&quot;AnimationEvent&quot;:false,&quot;AnimationPlaybackEvent&quot;:false,&quot;AnimationTimeline&quot;:false,&quot;applicationCache&quot;:false,&quot;ApplicationCache&quot;:false,&quot;ApplicationCacheErrorEvent&quot;:false,&quot;atob&quot;:false,&quot;Attr&quot;:false,&quot;Audio&quot;:false,&quot;AudioBuffer&quot;:false,&quot;AudioBufferSourceNode&quot;:false,&quot;AudioContext&quot;:false,&quot;AudioDestinationNode&quot;:false,&quot;AudioListener&quot;:false,&quot;AudioNode&quot;:false,&quot;AudioParam&quot;:false,&quot;AudioProcessingEvent&quot;:false,&quot;AudioScheduledSourceNode&quot;:false,&quot;AudioWorkletGlobalScope &quot;:false,&quot;AudioWorkletNode&quot;:false,&quot;AudioWorkletProcessor&quot;:false,&quot;BarProp&quot;:false,&quot;BaseAudioContext&quot;:false,&quot;BatteryManager&quot;:false,&quot;BeforeUnloadEvent&quot;:false,&quot;BiquadFilterNode&quot;:false,&quot;Blob&quot;:false,&quot;BlobEvent&quot;:false,&quot;blur&quot;:false,&quot;BroadcastChannel&quot;:false,&quot;btoa&quot;:false,&quot;BudgetService&quot;:false,&quot;ByteLengthQueuingStrategy&quot;:false,&quot;Cache&quot;:false,&quot;caches&quot;:false,&quot;CacheStorage&quot;:false,&quot;cancelAnimationFrame&quot;:false,&quot;cancelIdleCallback&quot;:false,&quot;CanvasCaptureMediaStreamTrack&quot;:false,&quot;CanvasGradient&quot;:false,&quot;CanvasPattern&quot;:false,&quot;CanvasRenderingContext2D&quot;:false,&quot;ChannelMergerNode&quot;:false,&quot;ChannelSplitterNode&quot;:false,&quot;CharacterData&quot;:false,&quot;clearInterval&quot;:false,&quot;clearTimeout&quot;:false,&quot;clientInformation&quot;:false,&quot;ClipboardEvent&quot;:false,&quot;close&quot;:false,&quot;closed&quot;:false,&quot;CloseEvent&quot;:false,&quot;Comment&quot;:false,&quot;CompositionEvent&quot;:false,&quot;confirm&quot;:false,&quot;console&quot;:false,&quot;ConstantSourceNode&quot;:false,&quot;ConvolverNode&quot;:false,&quot;CountQueuingStrategy&quot;:false,&quot;createImageBitmap&quot;:false,&quot;Credential&quot;:false,&quot;CredentialsContainer&quot;:false,&quot;crypto&quot;:false,&quot;Crypto&quot;:false,&quot;CryptoKey&quot;:false,&quot;CSS&quot;:false,&quot;CSSConditionRule&quot;:false,&quot;CSSFontFaceRule&quot;:false,&quot;CSSGroupingRule&quot;:false,&quot;CSSImportRule&quot;:false,&quot;CSSKeyframeRule&quot;:false,&quot;CSSKeyframesRule&quot;:false,&quot;CSSMediaRule&quot;:false,&quot;CSSNamespaceRule&quot;:false,&quot;CSSPageRule&quot;:false,&quot;CSSRule&quot;:false,&quot;CSSRuleList&quot;:false,&quot;CSSStyleDeclaration&quot;:false,&quot;CSSStyleRule&quot;:false,&quot;CSSStyleSheet&quot;:false,&quot;CSSSupportsRule&quot;:false,&quot;CustomElementRegistry&quot;:false,&quot;customElements&quot;:false,&quot;CustomEvent&quot;:false,&quot;DataTransfer&quot;:false,&quot;DataTransferItem&quot;:false,&quot;DataTransferItemList&quot;:false,&quot;defaultstatus&quot;:false,&quot;defaultStatus&quot;:false,&quot;DelayNode&quot;:false,&quot;DeviceMotionEvent&quot;:false,&quot;DeviceOrientationEvent&quot;:false,&quot;devicePixelRatio&quot;:false,&quot;dispatchEvent&quot;:false,&quot;document&quot;:false,&quot;Document&quot;:false,&quot;DocumentFragment&quot;:false,&quot;DocumentType&quot;:false,&quot;DOMError&quot;:false,&quot;DOMException&quot;:false,&quot;DOMImplementation&quot;:false,&quot;DOMMatrix&quot;:false,&quot;DOMMatrixReadOnly&quot;:false,&quot;DOMParser&quot;:false,&quot;DOMPoint&quot;:false,&quot;DOMPointReadOnly&quot;:false,&quot;DOMQuad&quot;:false,&quot;DOMRect&quot;:false,&quot;DOMRectReadOnly&quot;:false,&quot;DOMStringList&quot;:false,&quot;DOMStringMap&quot;:false,&quot;DOMTokenList&quot;:false,&quot;DragEvent&quot;:false,&quot;DynamicsCompressorNode&quot;:false,&quot;Element&quot;:false,&quot;ErrorEvent&quot;:false,&quot;event&quot;:false,&quot;Event&quot;:false,&quot;EventSource&quot;:false,&quot;EventTarget&quot;:false,&quot;external&quot;:false,&quot;fetch&quot;:false,&quot;File&quot;:false,&quot;FileList&quot;:false,&quot;FileReader&quot;:false,&quot;find&quot;:false,&quot;focus&quot;:false,&quot;FocusEvent&quot;:false,&quot;FontFace&quot;:false,&quot;FontFaceSetLoadEvent&quot;:false,&quot;FormData&quot;:false,&quot;frameElement&quot;:false,&quot;frames&quot;:false,&quot;GainNode&quot;:false,&quot;Gamepad&quot;:false,&quot;GamepadButton&quot;:false,&quot;GamepadEvent&quot;:false,&quot;getComputedStyle&quot;:false,&quot;getSelection&quot;:false,&quot;HashChangeEvent&quot;:false,&quot;Headers&quot;:false,&quot;history&quot;:false,&quot;History&quot;:false,&quot;HTMLAllCollection&quot;:false,&quot;HTMLAnchorElement&quot;:false,&quot;HTMLAreaElement&quot;:false,&quot;HTMLAudioElement&quot;:false,&quot;HTMLBaseElement&quot;:false,&quot;HTMLBodyElement&quot;:false,&quot;HTMLBRElement&quot;:false,&quot;HTMLButtonElement&quot;:false,&quot;HTMLCanvasElement&quot;:false,&quot;HTMLCollection&quot;:false,&quot;HTMLContentElement&quot;:false,&quot;HTMLDataElement&quot;:false,&quot;HTMLDataListElement&quot;:false,&quot;HTMLDetailsElement&quot;:false,&quot;HTMLDialogElement&quot;:false,&quot;HTMLDirectoryElement&quot;:false,&quot;HTMLDivElement&quot;:false,&quot;HTMLDListElement&quot;:false,&quot;HTMLDocument&quot;:false,&quot;HTMLElement&quot;:false,&quot;HTMLEmbedElement&quot;:false,&quot;HTMLFieldSetElement&quot;:false,&quot;HTMLFontElement&quot;:false,&quot;HTMLFormControlsCollection&quot;:false,&quot;HTMLFormElement&quot;:false,&quot;HTMLFrameElement&quot;:false,&quot;HTMLFrameSetElement&quot;:false,&quot;HTMLHeadElement&quot;:false,&quot;HTMLHeadingElement&quot;:false,&quot;HTMLHRElement&quot;:false,&quot;HTMLHtmlElement&quot;:false,&quot;HTMLIFrameElement&quot;:false,&quot;HTMLImageElement&quot;:false,&quot;HTMLInputElement&quot;:false,&quot;HTMLLabelElement&quot;:false,&quot;HTMLLegendElement&quot;:false,&quot;HTMLLIElement&quot;:false,&quot;HTMLLinkElement&quot;:false,&quot;HTMLMapElement&quot;:false,&quot;HTMLMarqueeElement&quot;:false,&quot;HTMLMediaElement&quot;:false,&quot;HTMLMenuElement&quot;:false,&quot;HTMLMetaElement&quot;:false,&quot;HTMLMeterElement&quot;:false,&quot;HTMLModElement&quot;:false,&quot;HTMLObjectElement&quot;:false,&quot;HTMLOListElement&quot;:false,&quot;HTMLOptGroupElement&quot;:false,&quot;HTMLOptionElement&quot;:false,&quot;HTMLOptionsCollection&quot;:false,&quot;HTMLOutputElement&quot;:false,&quot;HTMLParagraphElement&quot;:false,&quot;HTMLParamElement&quot;:false,&quot;HTMLPictureElement&quot;:false,&quot;HTMLPreElement&quot;:false,&quot;HTMLProgressElement&quot;:false,&quot;HTMLQuoteElement&quot;:false,&quot;HTMLScriptElement&quot;:false,&quot;HTMLSelectElement&quot;:false,&quot;HTMLShadowElement&quot;:false,&quot;HTMLSlotElement&quot;:false,&quot;HTMLSourceElement&quot;:false,&quot;HTMLSpanElement&quot;:false,&quot;HTMLStyleElement&quot;:false,&quot;HTMLTableCaptionElement&quot;:false,&quot;HTMLTableCellElement&quot;:false,&quot;HTMLTableColElement&quot;:false,&quot;HTMLTableElement&quot;:false,&quot;HTMLTableRowElement&quot;:false,&quot;HTMLTableSectionElement&quot;:false,&quot;HTMLTemplateElement&quot;:false,&quot;HTMLTextAreaElement&quot;:false,&quot;HTMLTimeElement&quot;:false,&quot;HTMLTitleElement&quot;:false,&quot;HTMLTrackElement&quot;:false,&quot;HTMLUListElement&quot;:false,&quot;HTMLUnknownElement&quot;:false,&quot;HTMLVideoElement&quot;:false,&quot;IDBCursor&quot;:false,&quot;IDBCursorWithValue&quot;:false,&quot;IDBDatabase&quot;:false,&quot;IDBFactory&quot;:false,&quot;IDBIndex&quot;:false,&quot;IDBKeyRange&quot;:false,&quot;IDBObjectStore&quot;:false,&quot;IDBOpenDBRequest&quot;:false,&quot;IDBRequest&quot;:false,&quot;IDBTransaction&quot;:false,&quot;IDBVersionChangeEvent&quot;:false,&quot;IdleDeadline&quot;:false,&quot;IIRFilterNode&quot;:false,&quot;Image&quot;:false,&quot;ImageBitmap&quot;:false,&quot;ImageBitmapRenderingContext&quot;:false,&quot;ImageCapture&quot;:false,&quot;ImageData&quot;:false,&quot;indexedDB&quot;:false,&quot;innerHeight&quot;:false,&quot;innerWidth&quot;:false,&quot;InputEvent&quot;:false,&quot;IntersectionObserver&quot;:false,&quot;IntersectionObserverEntry&quot;:false,&quot;Intl&quot;:false,&quot;isSecureContext&quot;:false,&quot;KeyboardEvent&quot;:false,&quot;KeyframeEffect&quot;:false,&quot;KeyframeEffectReadOnly&quot;:false,&quot;length&quot;:false,&quot;localStorage&quot;:false,&quot;location&quot;:true,&quot;Location&quot;:false,&quot;locationbar&quot;:false,&quot;matchMedia&quot;:false,&quot;MediaDeviceInfo&quot;:false,&quot;MediaDevices&quot;:false,&quot;MediaElementAudioSourceNode&quot;:false,&quot;MediaEncryptedEvent&quot;:false,&quot;MediaError&quot;:false,&quot;MediaKeyMessageEvent&quot;:false,&quot;MediaKeySession&quot;:false,&quot;MediaKeyStatusMap&quot;:false,&quot;MediaKeySystemAccess&quot;:false,&quot;MediaList&quot;:false,&quot;MediaQueryList&quot;:false,&quot;MediaQueryListEvent&quot;:false,&quot;MediaRecorder&quot;:false,&quot;MediaSettingsRange&quot;:false,&quot;MediaSource&quot;:false,&quot;MediaStream&quot;:false,&quot;MediaStreamAudioDestinationNode&quot;:false,&quot;MediaStreamAudioSourceNode&quot;:false,&quot;MediaStreamEvent&quot;:false,&quot;MediaStreamTrack&quot;:false,&quot;MediaStreamTrackEvent&quot;:false,&quot;menubar&quot;:false,&quot;MessageChannel&quot;:false,&quot;MessageEvent&quot;:false,&quot;MessagePort&quot;:false,&quot;MIDIAccess&quot;:false,&quot;MIDIConnectionEvent&quot;:false,&quot;MIDIInput&quot;:false,&quot;MIDIInputMap&quot;:false,&quot;MIDIMessageEvent&quot;:false,&quot;MIDIOutput&quot;:false,&quot;MIDIOutputMap&quot;:false,&quot;MIDIPort&quot;:false,&quot;MimeType&quot;:false,&quot;MimeTypeArray&quot;:false,&quot;MouseEvent&quot;:false,&quot;moveBy&quot;:false,&quot;moveTo&quot;:false,&quot;MutationEvent&quot;:false,&quot;MutationObserver&quot;:false,&quot;MutationRecord&quot;:false,&quot;name&quot;:false,&quot;NamedNodeMap&quot;:false,&quot;NavigationPreloadManager&quot;:false,&quot;navigator&quot;:false,&quot;Navigator&quot;:false,&quot;NetworkInformation&quot;:false,&quot;Node&quot;:false,&quot;NodeFilter&quot;:false,&quot;NodeIterator&quot;:false,&quot;NodeList&quot;:false,&quot;Notification&quot;:false,&quot;OfflineAudioCompletionEvent&quot;:false,&quot;OfflineAudioContext&quot;:false,&quot;offscreenBuffering&quot;:false,&quot;OffscreenCanvas&quot;:true,&quot;onabort&quot;:true,&quot;onafterprint&quot;:true,&quot;onanimationend&quot;:true,&quot;onanimationiteration&quot;:true,&quot;onanimationstart&quot;:true,&quot;onappinstalled&quot;:true,&quot;onauxclick&quot;:true,&quot;onbeforeinstallprompt&quot;:true,&quot;onbeforeprint&quot;:true,&quot;onbeforeunload&quot;:true,&quot;onblur&quot;:true,&quot;oncancel&quot;:true,&quot;oncanplay&quot;:true,&quot;oncanplaythrough&quot;:true,&quot;onchange&quot;:true,&quot;onclick&quot;:true,&quot;onclose&quot;:true,&quot;oncontextmenu&quot;:true,&quot;oncuechange&quot;:true,&quot;ondblclick&quot;:true,&quot;ondevicemotion&quot;:true,&quot;ondeviceorientation&quot;:true,&quot;ondeviceorientationabsolute&quot;:true,&quot;ondrag&quot;:true,&quot;ondragend&quot;:true,&quot;ondragenter&quot;:true,&quot;ondragleave&quot;:true,&quot;ondragover&quot;:true,&quot;ondragstart&quot;:true,&quot;ondrop&quot;:true,&quot;ondurationchange&quot;:true,&quot;onemptied&quot;:true,&quot;onended&quot;:true,&quot;onerror&quot;:true,&quot;onfocus&quot;:true,&quot;ongotpointercapture&quot;:true,&quot;onhashchange&quot;:true,&quot;oninput&quot;:true,&quot;oninvalid&quot;:true,&quot;onkeydown&quot;:true,&quot;onkeypress&quot;:true,&quot;onkeyup&quot;:true,&quot;onlanguagechange&quot;:true,&quot;onload&quot;:true,&quot;onloadeddata&quot;:true,&quot;onloadedmetadata&quot;:true,&quot;onloadstart&quot;:true,&quot;onlostpointercapture&quot;:true,&quot;onmessage&quot;:true,&quot;onmessageerror&quot;:true,&quot;onmousedown&quot;:true,&quot;onmouseenter&quot;:true,&quot;onmouseleave&quot;:true,&quot;onmousemove&quot;:true,&quot;onmouseout&quot;:true,&quot;onmouseover&quot;:true,&quot;onmouseup&quot;:true,&quot;onmousewheel&quot;:true,&quot;onoffline&quot;:true,&quot;ononline&quot;:true,&quot;onpagehide&quot;:true,&quot;onpageshow&quot;:true,&quot;onpause&quot;:true,&quot;onplay&quot;:true,&quot;onplaying&quot;:true,&quot;onpointercancel&quot;:true,&quot;onpointerdown&quot;:true,&quot;onpointerenter&quot;:true,&quot;onpointerleave&quot;:true,&quot;onpointermove&quot;:true,&quot;onpointerout&quot;:true,&quot;onpointerover&quot;:true,&quot;onpointerup&quot;:true,&quot;onpopstate&quot;:true,&quot;onprogress&quot;:true,&quot;onratechange&quot;:true,&quot;onrejectionhandled&quot;:true,&quot;onreset&quot;:true,&quot;onresize&quot;:true,&quot;onscroll&quot;:true,&quot;onsearch&quot;:true,&quot;onseeked&quot;:true,&quot;onseeking&quot;:true,&quot;onselect&quot;:true,&quot;onstalled&quot;:true,&quot;onstorage&quot;:true,&quot;onsubmit&quot;:true,&quot;onsuspend&quot;:true,&quot;ontimeupdate&quot;:true,&quot;ontoggle&quot;:true,&quot;ontransitionend&quot;:true,&quot;onunhandledrejection&quot;:true,&quot;onunload&quot;:true,&quot;onvolumechange&quot;:true,&quot;onwaiting&quot;:true,&quot;onwheel&quot;:true,&quot;open&quot;:false,&quot;openDatabase&quot;:false,&quot;opener&quot;:false,&quot;Option&quot;:false,&quot;origin&quot;:false,&quot;OscillatorNode&quot;:false,&quot;outerHeight&quot;:false,&quot;outerWidth&quot;:false,&quot;PageTransitionEvent&quot;:false,&quot;pageXOffset&quot;:false,&quot;pageYOffset&quot;:false,&quot;PannerNode&quot;:false,&quot;parent&quot;:false,&quot;Path2D&quot;:false,&quot;PaymentAddress&quot;:false,&quot;PaymentRequest&quot;:false,&quot;PaymentRequestUpdateEvent&quot;:false,&quot;PaymentResponse&quot;:false,&quot;performance&quot;:false,&quot;Performance&quot;:false,&quot;PerformanceEntry&quot;:false,&quot;PerformanceLongTaskTiming&quot;:false,&quot;PerformanceMark&quot;:false,&quot;PerformanceMeasure&quot;:false,&quot;PerformanceNavigation&quot;:false,&quot;PerformanceNavigationTiming&quot;:false,&quot;PerformanceObserver&quot;:false,&quot;PerformanceObserverEntryList&quot;:false,&quot;PerformancePaintTiming&quot;:false,&quot;PerformanceResourceTiming&quot;:false,&quot;PerformanceTiming&quot;:false,&quot;PeriodicWave&quot;:false,&quot;Permissions&quot;:false,&quot;PermissionStatus&quot;:false,&quot;personalbar&quot;:false,&quot;PhotoCapabilities&quot;:false,&quot;Plugin&quot;:false,&quot;PluginArray&quot;:false,&quot;PointerEvent&quot;:false,&quot;PopStateEvent&quot;:false,&quot;postMessage&quot;:false,&quot;Presentation&quot;:false,&quot;PresentationAvailability&quot;:false,&quot;PresentationConnection&quot;:false,&quot;PresentationConnectionAvailableEvent&quot;:false,&quot;PresentationConnectionCloseEvent&quot;:false,&quot;PresentationConnectionList&quot;:false,&quot;PresentationReceiver&quot;:false,&quot;PresentationRequest&quot;:false,&quot;print&quot;:false,&quot;ProcessingInstruction&quot;:false,&quot;ProgressEvent&quot;:false,&quot;PromiseRejectionEvent&quot;:false,&quot;prompt&quot;:false,&quot;PushManager&quot;:false,&quot;PushSubscription&quot;:false,&quot;PushSubscriptionOptions&quot;:false,&quot;queueMicrotask&quot;:false,&quot;RadioNodeList&quot;:false,&quot;Range&quot;:false,&quot;ReadableStream&quot;:false,&quot;registerProcessor&quot;:false,&quot;RemotePlayback&quot;:false,&quot;removeEventListener&quot;:false,&quot;Request&quot;:false,&quot;requestAnimationFrame&quot;:false,&quot;requestIdleCallback&quot;:false,&quot;resizeBy&quot;:false,&quot;ResizeObserver&quot;:false,&quot;ResizeObserverEntry&quot;:false,&quot;resizeTo&quot;:false,&quot;Response&quot;:false,&quot;RTCCertificate&quot;:false,&quot;RTCDataChannel&quot;:false,&quot;RTCDataChannelEvent&quot;:false,&quot;RTCDtlsTransport&quot;:false,&quot;RTCIceCandidate&quot;:false,&quot;RTCIceGatherer&quot;:false,&quot;RTCIceTransport&quot;:false,&quot;RTCPeerConnection&quot;:false,&quot;RTCPeerConnectionIceEvent&quot;:false,&quot;RTCRtpContributingSource&quot;:false,&quot;RTCRtpReceiver&quot;:false,&quot;RTCRtpSender&quot;:false,&quot;RTCSctpTransport&quot;:false,&quot;RTCSessionDescription&quot;:false,&quot;RTCStatsReport&quot;:false,&quot;RTCTrackEvent&quot;:false,&quot;screen&quot;:false,&quot;Screen&quot;:false,&quot;screenLeft&quot;:false,&quot;ScreenOrientation&quot;:false,&quot;screenTop&quot;:false,&quot;screenX&quot;:false,&quot;screenY&quot;:false,&quot;ScriptProcessorNode&quot;:false,&quot;scroll&quot;:false,&quot;scrollbars&quot;:false,&quot;scrollBy&quot;:false,&quot;scrollTo&quot;:false,&quot;scrollX&quot;:false,&quot;scrollY&quot;:false,&quot;SecurityPolicyViolationEvent&quot;:false,&quot;Selection&quot;:false,&quot;self&quot;:false,&quot;ServiceWorker&quot;:false,&quot;ServiceWorkerContainer&quot;:false,&quot;ServiceWorkerRegistration&quot;:false,&quot;sessionStorage&quot;:false,&quot;setInterval&quot;:false,&quot;setTimeout&quot;:false,&quot;ShadowRoot&quot;:false,&quot;SharedWorker&quot;:false,&quot;SourceBuffer&quot;:false,&quot;SourceBufferList&quot;:false,&quot;speechSynthesis&quot;:false,&quot;SpeechSynthesisEvent&quot;:false,&quot;SpeechSynthesisUtterance&quot;:false,&quot;StaticRange&quot;:false,&quot;status&quot;:false,&quot;statusbar&quot;:false,&quot;StereoPannerNode&quot;:false,&quot;stop&quot;:false,&quot;Storage&quot;:false,&quot;StorageEvent&quot;:false,&quot;StorageManager&quot;:false,&quot;styleMedia&quot;:false,&quot;StyleSheet&quot;:false,&quot;StyleSheetList&quot;:false,&quot;SubtleCrypto&quot;:false,&quot;SVGAElement&quot;:false,&quot;SVGAngle&quot;:false,&quot;SVGAnimatedAngle&quot;:false,&quot;SVGAnimatedBoolean&quot;:false,&quot;SVGAnimatedEnumeration&quot;:false,&quot;SVGAnimatedInteger&quot;:false,&quot;SVGAnimatedLength&quot;:false,&quot;SVGAnimatedLengthList&quot;:false,&quot;SVGAnimatedNumber&quot;:false,&quot;SVGAnimatedNumberList&quot;:false,&quot;SVGAnimatedPreserveAspectRatio&quot;:false,&quot;SVGAnimatedRect&quot;:false,&quot;SVGAnimatedString&quot;:false,&quot;SVGAnimatedTransformList&quot;:false,&quot;SVGAnimateElement&quot;:false,&quot;SVGAnimateMotionElement&quot;:false,&quot;SVGAnimateTransformElement&quot;:false,&quot;SVGAnimationElement&quot;:false,&quot;SVGCircleElement&quot;:false,&quot;SVGClipPathElement&quot;:false,&quot;SVGComponentTransferFunctionElement&quot;:false,&quot;SVGDefsElement&quot;:false,&quot;SVGDescElement&quot;:false,&quot;SVGDiscardElement&quot;:false,&quot;SVGElement&quot;:false,&quot;SVGEllipseElement&quot;:false,&quot;SVGFEBlendElement&quot;:false,&quot;SVGFEColorMatrixElement&quot;:false,&quot;SVGFEComponentTransferElement&quot;:false,&quot;SVGFECompositeElement&quot;:false,&quot;SVGFEConvolveMatrixElement&quot;:false,&quot;SVGFEDiffuseLightingElement&quot;:false,&quot;SVGFEDisplacementMapElement&quot;:false,&quot;SVGFEDistantLightElement&quot;:false,&quot;SVGFEDropShadowElement&quot;:false,&quot;SVGFEFloodElement&quot;:false,&quot;SVGFEFuncAElement&quot;:false,&quot;SVGFEFuncBElement&quot;:false,&quot;SVGFEFuncGElement&quot;:false,&quot;SVGFEFuncRElement&quot;:false,&quot;SVGFEGaussianBlurElement&quot;:false,&quot;SVGFEImageElement&quot;:false,&quot;SVGFEMergeElement&quot;:false,&quot;SVGFEMergeNodeElement&quot;:false,&quot;SVGFEMorphologyElement&quot;:false,&quot;SVGFEOffsetElement&quot;:false,&quot;SVGFEPointLightElement&quot;:false,&quot;SVGFESpecularLightingElement&quot;:false,&quot;SVGFESpotLightElement&quot;:false,&quot;SVGFETileElement&quot;:false,&quot;SVGFETurbulenceElement&quot;:false,&quot;SVGFilterElement&quot;:false,&quot;SVGForeignObjectElement&quot;:false,&quot;SVGGElement&quot;:false,&quot;SVGGeometryElement&quot;:false,&quot;SVGGradientElement&quot;:false,&quot;SVGGraphicsElement&quot;:false,&quot;SVGImageElement&quot;:false,&quot;SVGLength&quot;:false,&quot;SVGLengthList&quot;:false,&quot;SVGLinearGradientElement&quot;:false,&quot;SVGLineElement&quot;:false,&quot;SVGMarkerElement&quot;:false,&quot;SVGMaskElement&quot;:false,&quot;SVGMatrix&quot;:false,&quot;SVGMetadataElement&quot;:false,&quot;SVGMPathElement&quot;:false,&quot;SVGNumber&quot;:false,&quot;SVGNumberList&quot;:false,&quot;SVGPathElement&quot;:false,&quot;SVGPatternElement&quot;:false,&quot;SVGPoint&quot;:false,&quot;SVGPointList&quot;:false,&quot;SVGPolygonElement&quot;:false,&quot;SVGPolylineElement&quot;:false,&quot;SVGPreserveAspectRatio&quot;:false,&quot;SVGRadialGradientElement&quot;:false,&quot;SVGRect&quot;:false,&quot;SVGRectElement&quot;:false,&quot;SVGScriptElement&quot;:false,&quot;SVGSetElement&quot;:false,&quot;SVGStopElement&quot;:false,&quot;SVGStringList&quot;:false,&quot;SVGStyleElement&quot;:false,&quot;SVGSVGElement&quot;:false,&quot;SVGSwitchElement&quot;:false,&quot;SVGSymbolElement&quot;:false,&quot;SVGTextContentElement&quot;:false,&quot;SVGTextElement&quot;:false,&quot;SVGTextPathElement&quot;:false,&quot;SVGTextPositioningElement&quot;:false,&quot;SVGTitleElement&quot;:false,&quot;SVGTransform&quot;:false,&quot;SVGTransformList&quot;:false,&quot;SVGTSpanElement&quot;:false,&quot;SVGUnitTypes&quot;:false,&quot;SVGUseElement&quot;:false,&quot;SVGViewElement&quot;:false,&quot;TaskAttributionTiming&quot;:false,&quot;Text&quot;:false,&quot;TextDecoder&quot;:false,&quot;TextEncoder&quot;:false,&quot;TextEvent&quot;:false,&quot;TextMetrics&quot;:false,&quot;TextTrack&quot;:false,&quot;TextTrackCue&quot;:false,&quot;TextTrackCueList&quot;:false,&quot;TextTrackList&quot;:false,&quot;TimeRanges&quot;:false,&quot;toolbar&quot;:false,&quot;top&quot;:false,&quot;Touch&quot;:false,&quot;TouchEvent&quot;:false,&quot;TouchList&quot;:false,&quot;TrackEvent&quot;:false,&quot;TransitionEvent&quot;:false,&quot;TreeWalker&quot;:false,&quot;UIEvent&quot;:false,&quot;URL&quot;:false,&quot;URLSearchParams&quot;:false,&quot;ValidityState&quot;:false,&quot;visualViewport&quot;:false,&quot;VisualViewport&quot;:false,&quot;VTTCue&quot;:false,&quot;WaveShaperNode&quot;:false,&quot;WebAssembly&quot;:false,&quot;WebGL2RenderingContext&quot;:false,&quot;WebGLActiveInfo&quot;:false,&quot;WebGLBuffer&quot;:false,&quot;WebGLContextEvent&quot;:false,&quot;WebGLFramebuffer&quot;:false,&quot;WebGLProgram&quot;:false,&quot;WebGLQuery&quot;:false,&quot;WebGLRenderbuffer&quot;:false,&quot;WebGLRenderingContext&quot;:false,&quot;WebGLSampler&quot;:false,&quot;WebGLShader&quot;:false,&quot;WebGLShaderPrecisionFormat&quot;:false,&quot;WebGLSync&quot;:false,&quot;WebGLTexture&quot;:false,&quot;WebGLTransformFeedback&quot;:false,&quot;WebGLUniformLocation&quot;:false,&quot;WebGLVertexArrayObject&quot;:false,&quot;WebSocket&quot;:false,&quot;WheelEvent&quot;:false,&quot;window&quot;:false,&quot;Window&quot;:false,&quot;Worker&quot;:false,&quot;WritableStream&quot;:false,&quot;XMLDocument&quot;:false,&quot;XMLHttpRequest&quot;:false,&quot;XMLHttpRequestEventTarget&quot;:false,&quot;XMLHttpRequestUpload&quot;:false,&quot;XMLSerializer&quot;:false,&quot;XPathEvaluator&quot;:false,&quot;XPathExpression&quot;:false,&quot;XPathResult&quot;:false,&quot;XSLTProcessor&quot;:false},&quot;worker&quot;:{&quot;addEventListener&quot;:false,&quot;applicationCache&quot;:false,&quot;atob&quot;:false,&quot;Blob&quot;:false,&quot;BroadcastChannel&quot;:false,&quot;btoa&quot;:false,&quot;Cache&quot;:false,&quot;caches&quot;:false,&quot;clearInterval&quot;:false,&quot;clearTimeout&quot;:false,&quot;close&quot;:true,&quot;console&quot;:false,&quot;fetch&quot;:false,&quot;FileReaderSync&quot;:false,&quot;FormData&quot;:false,&quot;Headers&quot;:false,&quot;IDBCursor&quot;:false,&quot;IDBCursorWithValue&quot;:false,&quot;IDBDatabase&quot;:false,&quot;IDBFactory&quot;:false,&quot;IDBIndex&quot;:false,&quot;IDBKeyRange&quot;:false,&quot;IDBObjectStore&quot;:false,&quot;IDBOpenDBRequest&quot;:false,&quot;IDBRequest&quot;:false,&quot;IDBTransaction&quot;:false,&quot;IDBVersionChangeEvent&quot;:false,&quot;ImageData&quot;:false,&quot;importScripts&quot;:true,&quot;indexedDB&quot;:false,&quot;location&quot;:false,&quot;MessageChannel&quot;:false,&quot;MessagePort&quot;:false,&quot;name&quot;:false,&quot;navigator&quot;:false,&quot;Notification&quot;:false,&quot;onclose&quot;:true,&quot;onconnect&quot;:true,&quot;onerror&quot;:true,&quot;onlanguagechange&quot;:true,&quot;onmessage&quot;:true,&quot;onoffline&quot;:true,&quot;ononline&quot;:true,&quot;onrejectionhandled&quot;:true,&quot;onunhandledrejection&quot;:true,&quot;performance&quot;:false,&quot;Performance&quot;:false,&quot;PerformanceEntry&quot;:false,&quot;PerformanceMark&quot;:false,&quot;PerformanceMeasure&quot;:false,&quot;PerformanceNavigation&quot;:false,&quot;PerformanceResourceTiming&quot;:false,&quot;PerformanceTiming&quot;:false,&quot;postMessage&quot;:true,&quot;Promise&quot;:false,&quot;queueMicrotask&quot;:false,&quot;removeEventListener&quot;:false,&quot;Request&quot;:false,&quot;Response&quot;:false,&quot;self&quot;:true,&quot;ServiceWorkerRegistration&quot;:false,&quot;setInterval&quot;:false,&quot;setTimeout&quot;:false,&quot;TextDecoder&quot;:false,&quot;TextEncoder&quot;:false,&quot;URL&quot;:false,&quot;URLSearchParams&quot;:false,&quot;WebSocket&quot;:false,&quot;Worker&quot;:false,&quot;WorkerGlobalScope&quot;:false,&quot;XMLHttpRequest&quot;:false},&quot;node&quot;:{&quot;__dirname&quot;:false,&quot;__filename&quot;:false,&quot;Buffer&quot;:false,&quot;clearImmediate&quot;:false,&quot;clearInterval&quot;:false,&quot;clearTimeout&quot;:false,&quot;console&quot;:false,&quot;exports&quot;:true,&quot;global&quot;:false,&quot;Intl&quot;:false,&quot;module&quot;:false,&quot;process&quot;:false,&quot;queueMicrotask&quot;:false,&quot;require&quot;:false,&quot;setImmediate&quot;:false,&quot;setInterval&quot;:false,&quot;setTimeout&quot;:false,&quot;TextDecoder&quot;:false,&quot;TextEncoder&quot;:false,&quot;URL&quot;:false,&quot;URLSearchParams&quot;:false},&quot;commonjs&quot;:{&quot;exports&quot;:true,&quot;global&quot;:false,&quot;module&quot;:false,&quot;require&quot;:false},&quot;amd&quot;:{&quot;define&quot;:false,&quot;require&quot;:false},&quot;mocha&quot;:{&quot;after&quot;:false,&quot;afterEach&quot;:false,&quot;before&quot;:false,&quot;beforeEach&quot;:false,&quot;context&quot;:false,&quot;describe&quot;:false,&quot;it&quot;:false,&quot;mocha&quot;:false,&quot;run&quot;:false,&quot;setup&quot;:false,&quot;specify&quot;:false,&quot;suite&quot;:false,&quot;suiteSetup&quot;:false,&quot;suiteTeardown&quot;:false,&quot;teardown&quot;:false,&quot;test&quot;:false,&quot;xcontext&quot;:false,&quot;xdescribe&quot;:false,&quot;xit&quot;:false,&quot;xspecify&quot;:false},&quot;jasmine&quot;:{&quot;afterAll&quot;:false,&quot;afterEach&quot;:false,&quot;beforeAll&quot;:false,&quot;beforeEach&quot;:false,&quot;describe&quot;:false,&quot;expect&quot;:false,&quot;fail&quot;:false,&quot;fdescribe&quot;:false,&quot;fit&quot;:false,&quot;it&quot;:false,&quot;jasmine&quot;:false,&quot;pending&quot;:false,&quot;runs&quot;:false,&quot;spyOn&quot;:false,&quot;spyOnProperty&quot;:false,&quot;waits&quot;:false,&quot;waitsFor&quot;:false,&quot;xdescribe&quot;:false,&quot;xit&quot;:false},&quot;jest&quot;:{&quot;afterAll&quot;:false,&quot;afterEach&quot;:false,&quot;beforeAll&quot;:false,&quot;beforeEach&quot;:false,&quot;describe&quot;:false,&quot;expect&quot;:false,&quot;fdescribe&quot;:false,&quot;fit&quot;:false,&quot;it&quot;:false,&quot;jest&quot;:false,&quot;pit&quot;:false,&quot;require&quot;:false,&quot;test&quot;:false,&quot;xdescribe&quot;:false,&quot;xit&quot;:false,&quot;xtest&quot;:false},&quot;qunit&quot;:{&quot;asyncTest&quot;:false,&quot;deepEqual&quot;:false,&quot;equal&quot;:false,&quot;expect&quot;:false,&quot;module&quot;:false,&quot;notDeepEqual&quot;:false,&quot;notEqual&quot;:false,&quot;notOk&quot;:false,&quot;notPropEqual&quot;:false,&quot;notStrictEqual&quot;:false,&quot;ok&quot;:false,&quot;propEqual&quot;:false,&quot;QUnit&quot;:false,&quot;raises&quot;:false,&quot;start&quot;:false,&quot;stop&quot;:false,&quot;strictEqual&quot;:false,&quot;test&quot;:false,&quot;throws&quot;:false},&quot;phantomjs&quot;:{&quot;console&quot;:true,&quot;exports&quot;:true,&quot;phantom&quot;:true,&quot;require&quot;:true,&quot;WebPage&quot;:true},&quot;couch&quot;:{&quot;emit&quot;:false,&quot;exports&quot;:false,&quot;getRow&quot;:false,&quot;log&quot;:false,&quot;module&quot;:false,&quot;provides&quot;:false,&quot;require&quot;:false,&quot;respond&quot;:false,&quot;send&quot;:false,&quot;start&quot;:false,&quot;sum&quot;:false},&quot;rhino&quot;:{&quot;defineClass&quot;:false,&quot;deserialize&quot;:false,&quot;gc&quot;:false,&quot;help&quot;:false,&quot;importClass&quot;:false,&quot;importPackage&quot;:false,&quot;java&quot;:false,&quot;load&quot;:false,&quot;loadClass&quot;:false,&quot;Packages&quot;:false,&quot;print&quot;:false,&quot;quit&quot;:false,&quot;readFile&quot;:false,&quot;readUrl&quot;:false,&quot;runCommand&quot;:false,&quot;seal&quot;:false,&quot;serialize&quot;:false,&quot;spawn&quot;:false,&quot;sync&quot;:false,&quot;toint32&quot;:false,&quot;version&quot;:false},&quot;nashorn&quot;:{&quot;__DIR__&quot;:false,&quot;__FILE__&quot;:false,&quot;__LINE__&quot;:false,&quot;com&quot;:false,&quot;edu&quot;:false,&quot;exit&quot;:false,&quot;java&quot;:false,&quot;Java&quot;:false,&quot;javafx&quot;:false,&quot;JavaImporter&quot;:false,&quot;javax&quot;:false,&quot;JSAdapter&quot;:false,&quot;load&quot;:false,&quot;loadWithNewGlobal&quot;:false,&quot;org&quot;:false,&quot;Packages&quot;:false,&quot;print&quot;:false,&quot;quit&quot;:false},&quot;wsh&quot;:{&quot;ActiveXObject&quot;:true,&quot;Enumerator&quot;:true,&quot;GetObject&quot;:true,&quot;ScriptEngine&quot;:true,&quot;ScriptEngineBuildVersion&quot;:true,&quot;ScriptEngineMajorVersion&quot;:true,&quot;ScriptEngineMinorVersion&quot;:true,&quot;VBArray&quot;:true,&quot;WScript&quot;:true,&quot;WSH&quot;:true,&quot;XDomainRequest&quot;:true},&quot;jquery&quot;:{&quot;$&quot;:false,&quot;jQuery&quot;:false},&quot;yui&quot;:{&quot;YAHOO&quot;:false,&quot;YAHOO_config&quot;:false,&quot;YUI&quot;:false,&quot;YUI_config&quot;:false},&quot;shelljs&quot;:{&quot;cat&quot;:false,&quot;cd&quot;:false,&quot;chmod&quot;:false,&quot;config&quot;:false,&quot;cp&quot;:false,&quot;dirs&quot;:false,&quot;echo&quot;:false,&quot;env&quot;:false,&quot;error&quot;:false,&quot;exec&quot;:false,&quot;exit&quot;:false,&quot;find&quot;:false,&quot;grep&quot;:false,&quot;ln&quot;:false,&quot;ls&quot;:false,&quot;mkdir&quot;:false,&quot;mv&quot;:false,&quot;popd&quot;:false,&quot;pushd&quot;:false,&quot;pwd&quot;:false,&quot;rm&quot;:false,&quot;sed&quot;:false,&quot;set&quot;:false,&quot;target&quot;:false,&quot;tempdir&quot;:false,&quot;test&quot;:false,&quot;touch&quot;:false,&quot;which&quot;:false},&quot;prototypejs&quot;:{&quot;$&quot;:false,&quot;$$&quot;:false,&quot;$A&quot;:false,&quot;$break&quot;:false,&quot;$continue&quot;:false,&quot;$F&quot;:false,&quot;$H&quot;:false,&quot;$R&quot;:false,&quot;$w&quot;:false,&quot;Abstract&quot;:false,&quot;Ajax&quot;:false,&quot;Autocompleter&quot;:false,&quot;Builder&quot;:false,&quot;Class&quot;:false,&quot;Control&quot;:false,&quot;Draggable&quot;:false,&quot;Draggables&quot;:false,&quot;Droppables&quot;:false,&quot;Effect&quot;:false,&quot;Element&quot;:false,&quot;Enumerable&quot;:false,&quot;Event&quot;:false,&quot;Field&quot;:false,&quot;Form&quot;:false,&quot;Hash&quot;:false,&quot;Insertion&quot;:false,&quot;ObjectRange&quot;:false,&quot;PeriodicalExecuter&quot;:false,&quot;Position&quot;:false,&quot;Prototype&quot;:false,&quot;Scriptaculous&quot;:false,&quot;Selector&quot;:false,&quot;Sortable&quot;:false,&quot;SortableObserver&quot;:false,&quot;Sound&quot;:false,&quot;Template&quot;:false,&quot;Toggle&quot;:false,&quot;Try&quot;:false},&quot;meteor&quot;:{&quot;_&quot;:false,&quot;$&quot;:false,&quot;Accounts&quot;:false,&quot;AccountsClient&quot;:false,&quot;AccountsCommon&quot;:false,&quot;AccountsServer&quot;:false,&quot;App&quot;:false,&quot;Assets&quot;:false,&quot;Blaze&quot;:false,&quot;check&quot;:false,&quot;Cordova&quot;:false,&quot;DDP&quot;:false,&quot;DDPRateLimiter&quot;:false,&quot;DDPServer&quot;:false,&quot;Deps&quot;:false,&quot;EJSON&quot;:false,&quot;Email&quot;:false,&quot;HTTP&quot;:false,&quot;Log&quot;:false,&quot;Match&quot;:false,&quot;Meteor&quot;:false,&quot;Mongo&quot;:false,&quot;MongoInternals&quot;:false,&quot;Npm&quot;:false,&quot;Package&quot;:false,&quot;Plugin&quot;:false,&quot;process&quot;:false,&quot;Random&quot;:false,&quot;ReactiveDict&quot;:false,&quot;ReactiveVar&quot;:false,&quot;Router&quot;:false,&quot;ServiceConfiguration&quot;:false,&quot;Session&quot;:false,&quot;share&quot;:false,&quot;Spacebars&quot;:false,&quot;Template&quot;:false,&quot;Tinytest&quot;:false,&quot;Tracker&quot;:false,&quot;UI&quot;:false,&quot;Utils&quot;:false,&quot;WebApp&quot;:false,&quot;WebAppInternals&quot;:false},&quot;mongo&quot;:{&quot;_isWindows&quot;:false,&quot;_rand&quot;:false,&quot;BulkWriteResult&quot;:false,&quot;cat&quot;:false,&quot;cd&quot;:false,&quot;connect&quot;:false,&quot;db&quot;:false,&quot;getHostName&quot;:false,&quot;getMemInfo&quot;:false,&quot;hostname&quot;:false,&quot;ISODate&quot;:false,&quot;listFiles&quot;:false,&quot;load&quot;:false,&quot;ls&quot;:false,&quot;md5sumFile&quot;:false,&quot;mkdir&quot;:false,&quot;Mongo&quot;:false,&quot;NumberInt&quot;:false,&quot;NumberLong&quot;:false,&quot;ObjectId&quot;:false,&quot;PlanCache&quot;:false,&quot;print&quot;:false,&quot;printjson&quot;:false,&quot;pwd&quot;:false,&quot;quit&quot;:false,&quot;removeFile&quot;:false,&quot;rs&quot;:false,&quot;sh&quot;:false,&quot;UUID&quot;:false,&quot;version&quot;:false,&quot;WriteResult&quot;:false},&quot;applescript&quot;:{&quot;$&quot;:false,&quot;Application&quot;:false,&quot;Automation&quot;:false,&quot;console&quot;:false,&quot;delay&quot;:false,&quot;Library&quot;:false,&quot;ObjC&quot;:false,&quot;ObjectSpecifier&quot;:false,&quot;Path&quot;:false,&quot;Progress&quot;:false,&quot;Ref&quot;:false},&quot;serviceworker&quot;:{&quot;addEventListener&quot;:false,&quot;applicationCache&quot;:false,&quot;atob&quot;:false,&quot;Blob&quot;:false,&quot;BroadcastChannel&quot;:false,&quot;btoa&quot;:false,&quot;Cache&quot;:false,&quot;caches&quot;:false,&quot;CacheStorage&quot;:false,&quot;clearInterval&quot;:false,&quot;clearTimeout&quot;:false,&quot;Client&quot;:false,&quot;clients&quot;:false,&quot;Clients&quot;:false,&quot;close&quot;:true,&quot;console&quot;:false,&quot;ExtendableEvent&quot;:false,&quot;ExtendableMessageEvent&quot;:false,&quot;fetch&quot;:false,&quot;FetchEvent&quot;:false,&quot;FileReaderSync&quot;:false,&quot;FormData&quot;:false,&quot;Headers&quot;:false,&quot;IDBCursor&quot;:false,&quot;IDBCursorWithValue&quot;:false,&quot;IDBDatabase&quot;:false,&quot;IDBFactory&quot;:false,&quot;IDBIndex&quot;:false,&quot;IDBKeyRange&quot;:false,&quot;IDBObjectStore&quot;:false,&quot;IDBOpenDBRequest&quot;:false,&quot;IDBRequest&quot;:false,&quot;IDBTransaction&quot;:false,&quot;IDBVersionChangeEvent&quot;:false,&quot;ImageData&quot;:false,&quot;importScripts&quot;:false,&quot;indexedDB&quot;:false,&quot;location&quot;:false,&quot;MessageChannel&quot;:false,&quot;MessagePort&quot;:false,&quot;name&quot;:false,&quot;navigator&quot;:false,&quot;Notification&quot;:false,&quot;onclose&quot;:true,&quot;onconnect&quot;:true,&quot;onerror&quot;:true,&quot;onfetch&quot;:true,&quot;oninstall&quot;:true,&quot;onlanguagechange&quot;:true,&quot;onmessage&quot;:true,&quot;onmessageerror&quot;:true,&quot;onnotificationclick&quot;:true,&quot;onnotificationclose&quot;:true,&quot;onoffline&quot;:true,&quot;ononline&quot;:true,&quot;onpush&quot;:true,&quot;onpushsubscriptionchange&quot;:true,&quot;onrejectionhandled&quot;:true,&quot;onsync&quot;:true,&quot;onunhandledrejection&quot;:true,&quot;performance&quot;:false,&quot;Performance&quot;:false,&quot;PerformanceEntry&quot;:false,&quot;PerformanceMark&quot;:false,&quot;PerformanceMeasure&quot;:false,&quot;PerformanceNavigation&quot;:false,&quot;PerformanceResourceTiming&quot;:false,&quot;PerformanceTiming&quot;:false,&quot;postMessage&quot;:true,&quot;Promise&quot;:false,&quot;queueMicrotask&quot;:false,&quot;registration&quot;:false,&quot;removeEventListener&quot;:false,&quot;Request&quot;:false,&quot;Response&quot;:false,&quot;self&quot;:false,&quot;ServiceWorker&quot;:false,&quot;ServiceWorkerContainer&quot;:false,&quot;ServiceWorkerGlobalScope&quot;:false,&quot;ServiceWorkerMessageEvent&quot;:false,&quot;ServiceWorkerRegistration&quot;:false,&quot;setInterval&quot;:false,&quot;setTimeout&quot;:false,&quot;skipWaiting&quot;:false,&quot;TextDecoder&quot;:false,&quot;TextEncoder&quot;:false,&quot;URL&quot;:false,&quot;URLSearchParams&quot;:false,&quot;WebSocket&quot;:false,&quot;WindowClient&quot;:false,&quot;Worker&quot;:false,&quot;WorkerGlobalScope&quot;:false,&quot;XMLHttpRequest&quot;:false},&quot;atomtest&quot;:{&quot;advanceClock&quot;:false,&quot;fakeClearInterval&quot;:false,&quot;fakeClearTimeout&quot;:false,&quot;fakeSetInterval&quot;:false,&quot;fakeSetTimeout&quot;:false,&quot;resetTimeouts&quot;:false,&quot;waitsForPromise&quot;:false},&quot;embertest&quot;:{&quot;andThen&quot;:false,&quot;click&quot;:false,&quot;currentPath&quot;:false,&quot;currentRouteName&quot;:false,&quot;currentURL&quot;:false,&quot;fillIn&quot;:false,&quot;find&quot;:false,&quot;findAll&quot;:false,&quot;findWithAssert&quot;:false,&quot;keyEvent&quot;:false,&quot;pauseTest&quot;:false,&quot;resumeTest&quot;:false,&quot;triggerEvent&quot;:false,&quot;visit&quot;:false,&quot;wait&quot;:false},&quot;protractor&quot;:{&quot;$&quot;:false,&quot;$$&quot;:false,&quot;browser&quot;:false,&quot;by&quot;:false,&quot;By&quot;:false,&quot;DartObject&quot;:false,&quot;element&quot;:false,&quot;protractor&quot;:false},&quot;shared-node-browser&quot;:{&quot;clearInterval&quot;:false,&quot;clearTimeout&quot;:false,&quot;console&quot;:false,&quot;setInterval&quot;:false,&quot;setTimeout&quot;:false,&quot;URL&quot;:false,&quot;URLSearchParams&quot;:false},&quot;webextensions&quot;:{&quot;browser&quot;:false,&quot;chrome&quot;:false,&quot;opr&quot;:false},&quot;greasemonkey&quot;:{&quot;cloneInto&quot;:false,&quot;createObjectIn&quot;:false,&quot;exportFunction&quot;:false,&quot;GM&quot;:false,&quot;GM_addStyle&quot;:false,&quot;GM_deleteValue&quot;:false,&quot;GM_getResourceText&quot;:false,&quot;GM_getResourceURL&quot;:false,&quot;GM_getValue&quot;:false,&quot;GM_info&quot;:false,&quot;GM_listValues&quot;:false,&quot;GM_log&quot;:false,&quot;GM_openInTab&quot;:false,&quot;GM_registerMenuCommand&quot;:false,&quot;GM_setClipboard&quot;:false,&quot;GM_setValue&quot;:false,&quot;GM_xmlhttpRequest&quot;:false,&quot;unsafeWindow&quot;:false},&quot;devtools&quot;:{&quot;$&quot;:false,&quot;$_&quot;:false,&quot;$$&quot;:false,&quot;$0&quot;:false,&quot;$1&quot;:false,&quot;$2&quot;:false,&quot;$3&quot;:false,&quot;$4&quot;:false,&quot;$x&quot;:false,&quot;chrome&quot;:false,&quot;clear&quot;:false,&quot;copy&quot;:false,&quot;debug&quot;:false,&quot;dir&quot;:false,&quot;dirxml&quot;:false,&quot;getEventListeners&quot;:false,&quot;inspect&quot;:false,&quot;keys&quot;:false,&quot;monitor&quot;:false,&quot;monitorEvents&quot;:false,&quot;profile&quot;:false,&quot;profileEnd&quot;:false,&quot;queryObjects&quot;:false,&quot;table&quot;:false,&quot;undebug&quot;:false,&quot;unmonitor&quot;:false,&quot;unmonitorEvents&quot;:false,&quot;values&quot;:false}}')}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var s=t[n]={id:n,loaded:!1,exports:{}};return e[n].call(s.exports,s,s.exports,r),s.loaded=!0,s.exports}r.n=e=&gt;{var t=e&amp;&amp;e.__esModule?()=&gt;e.default:()=&gt;e;return r.d(t,{a:t}),t},r.d=(e,t)=&gt;{for(var n in t)r.o(t,n)&amp;&amp;!r.o(e,n)&amp;&amp;Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=&gt;Object.prototype.hasOwnProperty.call(e,t),r.nmd=e=&gt;(e.paths=[],e.children||(e.children=[]),e);var n={};(()=&gt;{&quot;use strict&quot;;r.d(n,{parseSourceAndMetadata:()=&gt;Y,purgeCachedMetadata:()=&gt;W});var e=r(7493),t=r(3018),i=r.n(t);const s=!1,a=&quot;undefined&quot;!=typeof performance&amp;&amp;&quot;function&quot;==typeof performance.mark&amp;&amp;&quot;function&quot;==typeof performance.clearMarks,o=&quot;undefined&quot;!=typeof performance&amp;&amp;&quot;function&quot;==typeof performance.now;function l(e){a&amp;&amp;performance.mark(e+&quot;-start&quot;)}function p(e){a&amp;&amp;(performance.mark(e+&quot;-end&quot;),performance.measure(e,e+&quot;-start&quot;,e+&quot;-end&quot;),performance.clearMarks(e+&quot;-start&quot;),performance.clearMarks(e+&quot;-end&quot;))}function c(){return o?performance.now():Date.now()}function u(e,t,r){const n=c();s&amp;&amp;l(e);const i=t();return s&amp;&amp;p(e),null!=r&amp;&amp;r(c()-n),i}var d=r(1910);const h=Object.freeze({PROGRAM:&quot;Program&quot;,CALL_EXPRESSION:&quot;CallExpression&quot;,MEMBER_EXPRESSION:&quot;MemberExpression&quot;,ARRAY_PATTERN:&quot;ArrayPattern&quot;,IDENTIFIER:&quot;Identifier&quot;,NUMERIC_LITERAL:&quot;NumericLiteral&quot;,VARIABLE_DECLARATOR:&quot;VariableDeclarator&quot;});function f(e,t,r=null){const{start:n,end:i}=e.node.loc;return t===n.line&amp;&amp;!(null!==r&amp;&amp;(r-=1,t===n.line&amp;&amp;r&lt;n.column||t===i.line&amp;&amp;r&gt;i.column))}function m(e,t,r){let n=[];return function(e){const t=e.node.id;return t.type===h.ARRAY_PATTERN||t.type===h.IDENTIFIER&amp;&amp;!function(e){const t=e.node.init.callee;return S(t,&quot;useState&quot;)||S(t,&quot;useReducer&quot;)||S(t,&quot;useTransition&quot;)}(e)}(e)?n.unshift(e):n=t.filter((t=&gt;function(e,t){const r=e.node.id.name;return null!=r&amp;&amp;(r===(t.node.init.object&amp;&amp;t.node.init.object.name)||r===t.node.init.name)}(e,t))),n}function y(e,t,r,n,i){const s=u(&quot;getPotentialHookDeclarationsFromAST(originalSourceAST)&quot;,(()=&gt;function(e){const t=[];return u(&quot;traverse(sourceAST)&quot;,(()=&gt;(0,d.default)(e,{enter(e){e.isVariableDeclarator()&amp;&amp;function(e){const t=e.node.init;if(null!=t){if(t.type===h.CALL_EXPRESSION)return g(t.callee);if(t.type===h.MEMBER_EXPRESSION||t.type===h.IDENTIFIER)return!0}return!1}(e)&amp;&amp;t.push(e)}}))),t}(t)));let a=null;if(0===i){const e=s.filter((e=&gt;{const t=f(e,n),r=b(e);return t&amp;&amp;r}));1===e.length&amp;&amp;(a=e[0])}else a=s.find((e=&gt;{const t=f(e,n,i),r=b(e);return t&amp;&amp;r}));if(!a)return null;try{const t=u(&quot;getFilteredHookASTNodes()&quot;,(()=&gt;m(a,s))),r=u(&quot;getHookNameFromNode()&quot;,(()=&gt;function(e,t,r){let n;const i=null===e.id;switch(t.length){case 1:if(i&amp;&amp;t[0]===r){n=T(r,i);break}n=T(t[0]);break;case 2:if(1!==(t=t.filter((e=&gt;function(e){return e.node.init.property.type===h.NUMERIC_LITERAL&amp;&amp;0===e.node.init.property.value}(e)))).length)throw new Error(&quot;Couldn't isolate AST Node containing hook variable.&quot;);n=T(t[0]);break;default:n=T(r)}return n}(e,t,a)));return r}catch(e){return console.error(e),null}}function T(e,t=!1){var r,n;switch(e.node.id.type){case h.ARRAY_PATTERN:return t?null:null!==(r=null===(n=e.node.id.elements[0])||void 0===n?void 0:n.name)&amp;&amp;void 0!==r?r:null;case h.IDENTIFIER:return e.node.id.name;default:return null}}function b(e){const t=e.node.init;return null!=t&amp;&amp;t.type===h.CALL_EXPRESSION&amp;&amp;g(t.callee)}function g(e){if(e.type===h.IDENTIFIER)return t=e.name,/^use[A-Z0-9].*$/.test(t);if(e.type===h.MEMBER_EXPRESSION&amp;&amp;!e.computed&amp;&amp;g(e.property)){const t=e.object,r=/^[A-Z].*/;return t.type===h.IDENTIFIER&amp;&amp;r.test(t.name)}return!1;var t}function S(e,t){return e.name===t||&quot;MemberExpression&quot;===e.type&amp;&amp;&quot;React&quot;===e.object.name&amp;&amp;e.property.name===t}var x=r(8715),E=r.n(x),P=r(4468);let v=null;function A({fileName:e,lineNumber:t,columnNumber:r}){if(null==e||null==t||null==r)throw Error(&quot;Hook source code location not found.&quot;);return`${e}:${t}:${r}`}new WeakMap;for(var w=r(6651),O={},I=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;,N=0;N&lt;65;N++)O[I.charCodeAt(N)]=N;function C(e){for(var t=[],r=[],n=[0,0,0,0,0],i=0,s=0,a=0,o=0;s&lt;e.length;s++){var l=e.charCodeAt(s);if(44===l)k(r,n,i),i=0;else if(59===l)k(r,n,i),i=0,t.push(r),r=[],n[0]=0;else{var p=O[l];if(void 0===p)throw new Error(&quot;Invalid character (&quot;+String.fromCharCode(l)+&quot;)&quot;);var c=32&amp;p;if(o+=(p&amp;=31)&lt;&lt;a,c)a+=5;else{var u=1&amp;o;o&gt;&gt;&gt;=1,u&amp;&amp;(o=0===o?-2147483648:-o),n[i]+=o,i++,o=a=0}}}return k(r,n,i),t.push(r),t}function k(e,t,r){4===r?e.push([t[0],t[1],t[2],t[3]]):5===r?e.push([t[0],t[1],t[2],t[3],t[4]]):1===r&amp;&amp;e.push([t[0]])}function D(e,t,r){let n,i=t.length,s=0,a=0;for(;i&gt;0;){s=a,n=Math.floor(i/2),s+=n;const o=r(e,t,s);if(0===o.direction){if(null==o.index)throw new Error(&quot;Expected an index when matching element is found.&quot;);a=o.index;break}o.direction&gt;0?(s++,a=s,i-=n+1):i=n}return null!=a?t[a]:null}function _(e,t,r){const n=r,i=t[n];if(null==i)throw new Error(`Unexpected line missing in HookMap at index ${r}.`);const s=M(i);let a,o=r+1;const l=t[o];return null!=l?a=M(l):(o=n,a=s),s===e.line?{index:n,direction:0}:a===e.line||e.line&gt;a&amp;&amp;null==l?{index:o,direction:0}:s&lt;e.line&amp;&amp;e.line&lt;a?{index:n,direction:0}:{index:null,direction:e.line-s}}function L(e,t,r){const n=r,i=t[r];if(null==i)throw new Error(`Unexpected mapping missing in HookMap line at index ${r}.`);const s=j(i);let a,o=r+1;const l=t[o];return null!=l?a=j(l):(o=n,a=s),s===e.column?{index:n,direction:0}:a===e.column||e.column&gt;a&amp;&amp;null==l?{index:o,direction:0}:s&lt;e.column&amp;&amp;e.column&lt;a?{index:n,direction:0}:{index:null,direction:e.column-s}}function M(e){return function(e){const t=e[0];if(null==t)throw new Error(&quot;Unexpected line number missing in entry in HookMap&quot;);return t}(e[0])}function j(e){const t=e[1];if(null==t)throw new Error(&quot;Unexpected column number missing in entry in HookMap&quot;);return t}const F=&quot;x_react_sources&quot;,B=&quot;x_facebook_sources&quot;;function R(e,t){const{sourceRoot:r}=t;let n=e;return n=String(n),n=w.normalize(n),n=null!=r&amp;&amp;w.isAbsolute(r)&amp;&amp;w.isAbsolute(n)?w.relative(r,n):n,w.computeSourceURL(r,n)}class U{constructor(e){this._sourceMap=e,this._decodedHookMapCache=new Map,this._metadataBySource=null}hookNameFor({line:e,column:t,source:r}){if(null==r)return null;const n=this._getHookMapForSource(r);return null==n?null:function(e,t){const{names:r,mappings:n}=t,i=D(e,n,_);if(null==i)throw new Error(`Expected to find a line in the HookMap that covers the target location at line: ${e.line}, column: ${e.column}`);let s;if(s=M(i)!==e.line?i[i.length-1]:D(e,i,L),null==s)throw new Error(`Expected to find a mapping in the HookMap that covers the target location at line: ${e.line}, column: ${e.column}`);const a=function(e){const t=e[2];if(null==t)throw new Error(&quot;Unexpected hook name index missing in entry in HookMap&quot;);return t}(s);if(null==a)throw new Error(`Expected to find a name index in the HookMap that covers the target location at line: ${e.line}, column: ${e.column}`);const o=r[a];if(null==o)throw new Error(`Expected to find a name in the HookMap that covers the target location at line: ${e.line}, column: ${e.column}`);return&quot;&lt;no-hook&gt;&quot;===o?null:o}({line:e,column:t},n)}hasHookMap(e){return null!=e&amp;&amp;null!=this._getHookMapForSource(e)}_getMetadataBySource(){return null==this._metadataBySource&amp;&amp;(this._metadataBySource=this._getMetadataObjectsBySourceNames(this._sourceMap)),this._metadataBySource}_getMetadataObjectsBySourceNames(e){if(void 0===e.mappings){const t=e,r=new Map;return t.sections.forEach((e=&gt;{this._getMetadataObjectsBySourceNames(e.map).forEach(((e,t)=&gt;{r.set(t,e)}))})),r}const t=new Map,r=e,n=(e,n)=&gt;{let i=r.sources[n];null!=i&amp;&amp;(i=R(i,r),t.set(i,e))};if(e.hasOwnProperty(F)&amp;&amp;null!=e[F])e[F].filter(Boolean).forEach(n);else if(e.hasOwnProperty(B)&amp;&amp;null!=e[B]){const t=e[B];null!=t&amp;&amp;t.forEach(((e,t)=&gt;{const r=null!=e?e[1]:null;null!=r&amp;&amp;n(r,t)}))}return t}_getHookMapForSource(e){if(this._decodedHookMapCache.has(e))return this._decodedHookMapCache.get(e);let t=null;const r=this._getMetadataBySource(),n=R(e,this._sourceMap),i=r.get(n);if(null!=i){const e=i[0];t=null!=e?function(e){return{names:e.names,mappings:C(e.mappings)}}(e):null}return null!=t&amp;&amp;this._decodedHookMapCache.set(e,t),t}}function V(e){return null!=e.sections?function(e){let t={line:-1,column:0};const r=e.sections.map((e=&gt;{const r=e.offset,n=r.line,i=r.column;if(n&lt;t.line||n===t.line&amp;&amp;i&lt;t.column)throw new Error(&quot;Section offsets must be ordered and non-overlapping.&quot;);return t=r,{generatedLine:n+1,generatedColumn:i+1,map:e.map,sourceMapConsumer:null}}));return{originalPositionFor:function({columnNumber:e,lineNumber:t}){const n=e-1;let i=null,s=0,a=r.length-1,o=-1;for(;s&lt;=a;){o=Math.floor((a+s)/2),i=r[o];const e=i.generatedLine;if(e===t){const e=i.generatedColumn;if(e===t)break;if(e&gt;n){if(!(a-o&gt;0)){o=a;break}a=o}else{if(!(o-s&gt;0)){o=s;break}s=o}}else if(e&gt;t){if(!(a-o&gt;0)){o=a;break}a=o}else{if(!(o-s&gt;0)){o=s;break}s=o}}if(null==i)throw Error(`Could not find matching section for line:${t} and column:${e}`);return null===i.sourceMapConsumer&amp;&amp;(i.sourceMapConsumer=new V(i.map)),i.sourceMapConsumer.originalPositionFor({columnNumber:e,lineNumber:t})}}}(e):function(e){const t=u(&quot;Decoding source map mappings with sourcemap-codec&quot;,(()=&gt;C(e.mappings)));return{originalPositionFor:function({columnNumber:r,lineNumber:n}){var i;const s=r-1,a=t[n-1];let o=null,l=0,p=a.length-1,c=-1;for(;l&lt;=p;){c=Math.floor((p+l)/2),o=a[c];const e=o[0];if(e===s)break;if(e&gt;s){if(!(p-c&gt;0)){c=p;break}p=c}else{if(!(c-l&gt;0)){c=l;break}l=c}}for(;c&gt;0&amp;&amp;a[c-1][0]===s;)c--;if(null==o)throw Error(`Could not find runtime location for line:${n} and column:${r}`);const u=o[1],d=null!=e.sourcesContent?e.sourcesContent[u]:null,h=null!==(i=e.sources[u])&amp;&amp;void 0!==i?i:null,f=o[2]+1,m=o[3];if(null===d||null===h)throw Error(`Could not find original source for line:${n} and column:${r}`);return{column:m,line:f,sourceContent:d,sourceURL:h}}}}(e)}const K=new(i())({max:50}),q=new(i())({max:50,dispose:(e,t)=&gt;{}}),Y=async function(t,r){return async function(n,i,a){c();s&amp;&amp;l(n);const o=await(async()=&gt;{const n=u(&quot;initializeHookParsedMetadata&quot;,(()=&gt;function(e){const t=new Map;return e.forEach(((e,r)=&gt;{const n={metadataConsumer:null,originalSourceAST:null,originalSourceCode:null,originalSourceURL:null,originalSourceLineNumber:null,originalSourceColumnNumber:null,sourceMapConsumer:null};t.set(r,n)})),t}(r)));return u(&quot;parseSourceMaps&quot;,(()=&gt;function(e,t){e.forEach(((e,r)=&gt;{const n=t.get(r);if(null==n)throw Error(`Expected to find HookParsedMetadata for &quot;${r}&quot;`);const{runtimeSourceURL:i,sourceMapJSON:s}=e,a=K.get(i);if(null!=a)n.metadataConsumer=a.metadataConsumer,n.sourceMapConsumer=a.sourceMapConsumer;else if(null!=s){const e=u(&quot;new SourceMapConsumer(sourceMapJSON)&quot;,(()=&gt;V(s))),t=u(&quot;new SourceMapMetadataConsumer(sourceMapJSON)&quot;,(()=&gt;new U(s)));n.metadataConsumer=t,n.sourceMapConsumer=e,K.set(i,{metadataConsumer:t,sourceMapConsumer:e})}}))}(r,n))),u(&quot;parseSourceAST()&quot;,(()=&gt;function(t,r){t.forEach(((t,n)=&gt;{const i=r.get(n);if(null==i)throw Error(`Expected to find HookParsedMetadata for &quot;${n}&quot;`);if(null!==i.originalSourceAST)return;if(null!=i.originalSourceURL&amp;&amp;null!=i.originalSourceCode&amp;&amp;null!=i.originalSourceColumnNumber&amp;&amp;null!=i.originalSourceLineNumber)return;const{lineNumber:s,columnNumber:a}=t.hookSource;if(null==s||null==a)throw Error(&quot;Hook source code location not found.&quot;);const{metadataConsumer:o,sourceMapConsumer:l}=i,p=t.runtimeSourceCode;let c,d,h,f,m=!1;if(function(){if(null===v)try{(0,P.ZP)(),v=!1}catch(e){E().parse(e)[0].lineNumber===P.U1&amp;&amp;(v=!0)}return!0===v}()||null===l)h=a,f=s,d=p,c=t.runtimeSourceURL;else{const{column:e,line:t,sourceContent:r,sourceURL:n}=l.originalPositionFor({columnNumber:a,lineNumber:s});h=e,f=t,d=r,c=n}if(i.originalSourceCode=d,i.originalSourceURL=c,i.originalSourceLineNumber=f,i.originalSourceColumnNumber=h,null!=o&amp;&amp;o.hasHookMap(c)&amp;&amp;(m=!0),m)return;const y=q.get(c);if(null!=y)i.originalSourceAST=y.originalSourceAST,i.originalSourceCode=y.originalSourceCode;else try{const t=d.indexOf(&quot;@flow&quot;)&gt;0?&quot;flow&quot;:&quot;typescript&quot;,r=u(&quot;[@babel/parser] parse(originalSourceCode)&quot;,(()=&gt;(0,e.parse)(d,{sourceType:&quot;unambiguous&quot;,plugins:[&quot;jsx&quot;,t]})));i.originalSourceAST=r,q.set(c,{originalSourceAST:r,originalSourceCode:d})}catch(e){throw new Error(`Failed to parse source file: ${c}\n\nOriginal error: ${e}`)}}))}(r,n))),u(&quot;findHookNames()&quot;,(()=&gt;function(e,t){const r=new Map;return e.map((e=&gt;{const n=e.hookSource;if(!n.fileName)return null;const i=A(n),s=t.get(i);if(!s)return null;const{lineNumber:a,columnNumber:o}=n;if(!a||!o)return null;const{originalSourceURL:l,originalSourceColumnNumber:p,originalSourceLineNumber:c}=s;if(null==c||null==p||null==l)return null;let d;const{metadataConsumer:h}=s;null!=h&amp;&amp;(d=u(&quot;metadataConsumer.hookNameFor()&quot;,(()=&gt;h.hookNameFor({line:c,column:p,source:l})))),null==d&amp;&amp;(d=u(&quot;getHookName()&quot;,(()=&gt;y(e,s.originalSourceAST,s.originalSourceCode,c,p))));const f=A(n);r.set(f,d)})),r}(t,n)))})();return s&amp;&amp;p(n),o}(&quot;parseSourceAndMetadata()&quot;)},W=function(){q.reset(),K.reset()};addEventListener(&quot;message&quot;,(function(e){var t,r=e.data,i=r.type,s=r.method,a=r.id,o=r.params;&quot;RPC&quot;===i&amp;&amp;s&amp;&amp;((t=n[s])?Promise.resolve().then((function(){return t.apply(n,o)})):Promise.reject(&quot;No such method&quot;)).then((function(e){postMessage({type:&quot;RPC&quot;,id:a,result:e})})).catch((function(e){var t={message:e};e.stack&amp;&amp;(t.message=e.message,t.stack=e.stack,t.name=e.name),postMessage({type:&quot;RPC&quot;,id:a,error:t})}))})),postMessage({type:&quot;RPC&quot;,method:&quot;ready&quot;})})()})();</span>
<span class="s6">//# sourceMappingURL=parseSourceAndMetadata.worker.worker.js.map</span></pre>
</body>
</html>
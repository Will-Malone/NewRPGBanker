<html>
<head>
<title>Device.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Device.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">fs = _interopRequireWildcard(require(</span><span class="s0">&quot;fs&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">path = _interopRequireWildcard(require(</span><span class="s0">&quot;path&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_nodeFetch = _interopRequireDefault(require(</span><span class="s0">&quot;node-fetch&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_ws = _interopRequireDefault(require(</span><span class="s0">&quot;ws&quot;</span><span class="s1">));</span>
<span class="s2">function </span><span class="s1">_interopRequireDefault(obj) {</span>
  <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">default</span><span class="s1">: obj };</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
  <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
  <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function </span><span class="s1">(nodeInterop) {</span>
    <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
  <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interopRequireWildcard(obj, nodeInterop) {</span>
  <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
    <span class="s2">return </span><span class="s1">obj;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">)) {</span>
    <span class="s2">return </span><span class="s1">{ </span><span class="s2">default</span><span class="s1">: obj };</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
  <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
    <span class="s2">return </span><span class="s1">cache.get(obj);</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">newObj = {};</span>
  <span class="s2">var </span><span class="s1">hasPropertyDescriptor =</span>
    <span class="s1">Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj) {</span>
    <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
      <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor</span>
        <span class="s1">? Object.getOwnPropertyDescriptor(obj, key)</span>
        <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
        <span class="s1">Object.defineProperty(newObj, key, desc);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">newObj[key] = obj[key];</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">newObj.</span><span class="s2">default </span><span class="s1">= obj;</span>
  <span class="s2">if </span><span class="s1">(cache) {</span>
    <span class="s1">cache.set(obj, newObj);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 * 
 * @format 
 * @oncall react_native 
 */</span>

<span class="s1">const debug = require(</span><span class="s0">&quot;debug&quot;</span><span class="s1">)(</span><span class="s0">&quot;Metro:InspectorProxy&quot;</span><span class="s1">);</span>
<span class="s1">const PAGES_POLLING_INTERVAL = </span><span class="s4">1000</span><span class="s1">;</span>

<span class="s3">// Android's stock emulator and other emulators such as genymotion use a standard localhost alias.</span>
<span class="s1">const EMULATOR_LOCALHOST_ADDRESSES = [</span><span class="s0">&quot;10.0.2.2&quot;</span><span class="s1">, </span><span class="s0">&quot;10.0.3.2&quot;</span><span class="s1">];</span>

<span class="s3">// Prefix for script URLs that are alphanumeric IDs. See comment in _processMessageFromDevice method for</span>
<span class="s3">// more details.</span>
<span class="s1">const FILE_PREFIX = </span><span class="s0">&quot;file://&quot;</span><span class="s1">;</span>
<span class="s1">const REACT_NATIVE_RELOADABLE_PAGE_ID = </span><span class="s0">&quot;-1&quot;</span><span class="s1">;</span>

<span class="s3">/** 
 * Device class represents single device connection to Inspector Proxy. Each device 
 * can have multiple inspectable pages. 
 */</span>
<span class="s1">class Device {</span>
  <span class="s3">// ID of the device.</span>

  <span class="s3">// Name of the device.</span>

  <span class="s3">// Package name of the app.</span>

  <span class="s3">// Stores socket connection between Inspector Proxy and device.</span>

  <span class="s3">// Stores last list of device's pages.</span>

  <span class="s3">// Stores information about currently connected debugger (if any).</span>
  <span class="s1">_debuggerConnection = </span><span class="s2">null</span><span class="s1">;</span>

  <span class="s3">// Last known Page ID of the React Native page.</span>
  <span class="s3">// This is used by debugger connections that don't have PageID specified</span>
  <span class="s3">// (and will interact with the latest React Native page).</span>
  <span class="s1">_lastConnectedReactNativePage = </span><span class="s2">null</span><span class="s1">;</span>

  <span class="s3">// Whether we are in the middle of a reload in the REACT_NATIVE_RELOADABLE_PAGE.</span>
  <span class="s1">_isReloading = </span><span class="s2">false</span><span class="s1">;</span>

  <span class="s3">// The previous &quot;GetPages&quot; message, for deduplication in debug logs.</span>
  <span class="s1">_lastGetPagesMessage = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>

  <span class="s3">// Mapping built from scriptParsed events and used to fetch file content in `Debugger.getScriptSource`.</span>
  <span class="s1">_scriptIdToSourcePathMapping = </span><span class="s2">new </span><span class="s1">Map();</span>

  <span class="s3">// Root of the project used for relative to absolute source path conversion.</span>

  <span class="s1">constructor(id, name, app, socket, projectRoot) {</span>
    <span class="s2">this</span><span class="s1">._id = id;</span>
    <span class="s2">this</span><span class="s1">._name = name;</span>
    <span class="s2">this</span><span class="s1">._app = app;</span>
    <span class="s2">this</span><span class="s1">._pages = [];</span>
    <span class="s2">this</span><span class="s1">._deviceSocket = socket;</span>
    <span class="s2">this</span><span class="s1">._projectRoot = projectRoot;</span>
    <span class="s2">this</span><span class="s1">._deviceSocket.on(</span><span class="s0">&quot;message&quot;</span><span class="s1">, (message) =&gt; {</span>
      <span class="s1">const parsedMessage = JSON.parse(message);</span>
      <span class="s2">if </span><span class="s1">(parsedMessage.event === </span><span class="s0">&quot;getPages&quot;</span><span class="s1">) {</span>
        <span class="s3">// There's a 'getPages' message every second, so only show them if they change</span>
        <span class="s2">if </span><span class="s1">(message !== </span><span class="s2">this</span><span class="s1">._lastGetPagesMessage) {</span>
          <span class="s1">debug(</span>
            <span class="s0">&quot;(Debugger)    (Proxy) &lt;- (Device), getPages ping has changed: &quot; </span><span class="s1">+</span>
              <span class="s1">message</span>
          <span class="s1">);</span>
          <span class="s2">this</span><span class="s1">._lastGetPagesMessage = message;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">debug(</span><span class="s0">&quot;(Debugger)    (Proxy) &lt;- (Device): &quot; </span><span class="s1">+ message);</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">._handleMessageFromDevice(parsedMessage);</span>
    <span class="s1">});</span>
    <span class="s2">this</span><span class="s1">._deviceSocket.on(</span><span class="s0">&quot;close&quot;</span><span class="s1">, () =&gt; {</span>
      <span class="s3">// Device disconnected - close debugger connection.</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._debuggerConnection) {</span>
        <span class="s2">this</span><span class="s1">._debuggerConnection.socket.close();</span>
        <span class="s2">this</span><span class="s1">._debuggerConnection = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">this</span><span class="s1">._setPagesPolling();</span>
  <span class="s1">}</span>
  <span class="s1">getName() {</span>
    <span class="s2">return this</span><span class="s1">._name;</span>
  <span class="s1">}</span>
  <span class="s1">getApp() {</span>
    <span class="s2">return this</span><span class="s1">._app;</span>
  <span class="s1">}</span>
  <span class="s1">getPagesList() {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._lastConnectedReactNativePage) {</span>
      <span class="s1">const reactNativeReloadablePage = {</span>
        <span class="s1">id: REACT_NATIVE_RELOADABLE_PAGE_ID,</span>
        <span class="s1">title: </span><span class="s0">&quot;React Native Experimental (Improved Chrome Reloads)&quot;</span><span class="s1">,</span>
        <span class="s1">vm: </span><span class="s0">&quot;don't use&quot;</span><span class="s1">,</span>
        <span class="s1">app: </span><span class="s2">this</span><span class="s1">._app,</span>
      <span class="s1">};</span>
      <span class="s2">return this</span><span class="s1">._pages.concat(reactNativeReloadablePage);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return this</span><span class="s1">._pages;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">// Handles new debugger connection to this device:</span>
  <span class="s3">// 1. Sends connect event to device</span>
  <span class="s3">// 2. Forwards all messages from the debugger to device as wrappedEvent</span>
  <span class="s3">// 3. Sends disconnect event to device when debugger connection socket closes.</span>
  <span class="s1">handleDebuggerConnection(socket, pageId) {</span>
    <span class="s3">// Disconnect current debugger if we already have debugger connected.</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._debuggerConnection) {</span>
      <span class="s2">this</span><span class="s1">._debuggerConnection.socket.close();</span>
      <span class="s2">this</span><span class="s1">._debuggerConnection = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const debuggerInfo = {</span>
      <span class="s1">socket,</span>
      <span class="s1">prependedFilePrefix: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">pageId,</span>
    <span class="s1">};</span>
    <span class="s2">this</span><span class="s1">._debuggerConnection = debuggerInfo;</span>
    <span class="s1">debug(`Got </span><span class="s2">new </span><span class="s1">debugger connection </span><span class="s2">for </span><span class="s1">page ${pageId} of ${</span><span class="s2">this</span><span class="s1">._name}`);</span>
    <span class="s2">this</span><span class="s1">._sendMessageToDevice({</span>
      <span class="s1">event: </span><span class="s0">&quot;connect&quot;</span><span class="s1">,</span>
      <span class="s1">payload: {</span>
        <span class="s1">pageId: </span><span class="s2">this</span><span class="s1">._mapToDevicePageId(pageId),</span>
      <span class="s1">},</span>
    <span class="s1">});</span>
    <span class="s1">socket.on(</span><span class="s0">&quot;message&quot;</span><span class="s1">, (message) =&gt; {</span>
      <span class="s1">debug(</span><span class="s0">&quot;(Debugger) -&gt; (Proxy)    (Device): &quot; </span><span class="s1">+ message);</span>
      <span class="s1">const debuggerRequest = JSON.parse(message);</span>
      <span class="s1">const handled = </span><span class="s2">this</span><span class="s1">._interceptMessageFromDebugger(</span>
        <span class="s1">debuggerRequest,</span>
        <span class="s1">debuggerInfo,</span>
        <span class="s1">socket</span>
      <span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(!handled) {</span>
        <span class="s2">this</span><span class="s1">._sendMessageToDevice({</span>
          <span class="s1">event: </span><span class="s0">&quot;wrappedEvent&quot;</span><span class="s1">,</span>
          <span class="s1">payload: {</span>
            <span class="s1">pageId: </span><span class="s2">this</span><span class="s1">._mapToDevicePageId(pageId),</span>
            <span class="s1">wrappedEvent: JSON.stringify(debuggerRequest),</span>
          <span class="s1">},</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">socket.on(</span><span class="s0">&quot;close&quot;</span><span class="s1">, () =&gt; {</span>
      <span class="s1">debug(`Debugger </span><span class="s2">for </span><span class="s1">page ${pageId} and ${</span><span class="s2">this</span><span class="s1">._name} disconnected.`);</span>
      <span class="s2">this</span><span class="s1">._sendMessageToDevice({</span>
        <span class="s1">event: </span><span class="s0">&quot;disconnect&quot;</span><span class="s1">,</span>
        <span class="s1">payload: {</span>
          <span class="s1">pageId: </span><span class="s2">this</span><span class="s1">._mapToDevicePageId(pageId),</span>
        <span class="s1">},</span>
      <span class="s1">});</span>
      <span class="s2">this</span><span class="s1">._debuggerConnection = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">});</span>
    <span class="s1">const sendFunc = socket.send;</span>
    <span class="s1">socket.send = </span><span class="s2">function </span><span class="s1">(message) {</span>
      <span class="s1">debug(</span><span class="s0">&quot;(Debugger) &lt;- (Proxy)    (Device): &quot; </span><span class="s1">+ message);</span>
      <span class="s2">return </span><span class="s1">sendFunc.call(socket, message);</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">/** 
   * Handles cleaning up a duplicate device connection, by client-side device ID. 
   * 1. Checks if the same device is attempting to reconnect for the same app. 
   * 2. If not, close both the device and debugger socket. 
   * 3. If the debugger connection can be reused, close the device socket only. 
   * 
   * This allows users to reload the app, either as result of a crash, or manually 
   * reloading, without having to restart the debugger. 
   */</span>
  <span class="s1">handleDuplicateDeviceConnection(newDevice) {</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s2">this</span><span class="s1">._app !== newDevice.getApp() ||</span>
      <span class="s2">this</span><span class="s1">._name !== newDevice.getName()</span>
    <span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">._deviceSocket.close();</span>
      <span class="s2">this</span><span class="s1">._debuggerConnection?.socket.close();</span>
    <span class="s1">}</span>
    <span class="s1">const oldDebugger = </span><span class="s2">this</span><span class="s1">._debuggerConnection;</span>
    <span class="s2">this</span><span class="s1">._debuggerConnection = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(oldDebugger) {</span>
      <span class="s1">oldDebugger.socket.removeAllListeners();</span>
      <span class="s2">this</span><span class="s1">._deviceSocket.close();</span>
      <span class="s1">newDevice.handleDebuggerConnection(</span>
        <span class="s1">oldDebugger.socket,</span>
        <span class="s1">oldDebugger.pageId</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">// Handles messages received from device:</span>
  <span class="s3">// 1. For getPages responses updates local _pages list.</span>
  <span class="s3">// 2. All other messages are forwarded to debugger as wrappedEvent.</span>
  <span class="s3">//</span>
  <span class="s3">// In the future more logic will be added to this method for modifying</span>
  <span class="s3">// some of the messages (like updating messages with source maps and file</span>
  <span class="s3">// locations).</span>
  <span class="s1">_handleMessageFromDevice(message) {</span>
    <span class="s2">if </span><span class="s1">(message.event === </span><span class="s0">&quot;getPages&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">._pages = message.payload;</span>

      <span class="s3">// Check if device have new React Native page.</span>
      <span class="s3">// There is usually no more than 2-3 pages per device so this operation</span>
      <span class="s3">// is not expensive.</span>
      <span class="s3">// TODO(hypuk): It is better for VM to send update event when new page is</span>
      <span class="s3">// created instead of manually checking this on every getPages result.</span>
      <span class="s2">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; </span><span class="s2">this</span><span class="s1">._pages.length; ++i) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._pages[i].title.indexOf(</span><span class="s0">&quot;React&quot;</span><span class="s1">) &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._pages[i].id != </span><span class="s2">this</span><span class="s1">._lastConnectedReactNativePage?.id) {</span>
            <span class="s2">this</span><span class="s1">._newReactNativePage(</span><span class="s2">this</span><span class="s1">._pages[i]);</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(message.event === </span><span class="s0">&quot;disconnect&quot;</span><span class="s1">) {</span>
      <span class="s3">// Device sends disconnect events only when page is reloaded or</span>
      <span class="s3">// if debugger socket was disconnected.</span>
      <span class="s1">const pageId = message.payload.pageId;</span>
      <span class="s1">const debuggerSocket = </span><span class="s2">this</span><span class="s1">._debuggerConnection</span>
        <span class="s1">? </span><span class="s2">this</span><span class="s1">._debuggerConnection.socket</span>
        <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(debuggerSocket &amp;&amp; debuggerSocket.readyState === _ws.</span><span class="s2">default</span><span class="s1">.OPEN) {</span>
        <span class="s2">if </span><span class="s1">(</span>
          <span class="s2">this</span><span class="s1">._debuggerConnection != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
          <span class="s2">this</span><span class="s1">._debuggerConnection.pageId !== REACT_NATIVE_RELOADABLE_PAGE_ID</span>
        <span class="s1">) {</span>
          <span class="s1">debug(`Page ${pageId} is reloading.`);</span>
          <span class="s1">debuggerSocket.send(</span>
            <span class="s1">JSON.stringify({</span>
              <span class="s1">method: </span><span class="s0">&quot;reload&quot;</span><span class="s1">,</span>
            <span class="s1">})</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(message.event === </span><span class="s0">&quot;wrappedEvent&quot;</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._debuggerConnection == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">// FIXME: Is it possible that we received message for pageID that does not</span>
      <span class="s3">// correspond to current debugger connection?</span>

      <span class="s1">const debuggerSocket = </span><span class="s2">this</span><span class="s1">._debuggerConnection.socket;</span>
      <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">debuggerSocket == </span><span class="s2">null </span><span class="s1">||</span>
        <span class="s1">debuggerSocket.readyState !== _ws.</span><span class="s2">default</span><span class="s1">.OPEN</span>
      <span class="s1">) {</span>
        <span class="s3">// TODO(hypuk): Send error back to device?</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const parsedPayload = JSON.parse(message.payload.wrappedEvent);</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._debuggerConnection) {</span>
        <span class="s3">// Wrapping just to make flow happy :)</span>
        <span class="s3">// $FlowFixMe[unused-promise]</span>
        <span class="s2">this</span><span class="s1">._processMessageFromDevice(</span>
          <span class="s1">parsedPayload,</span>
          <span class="s2">this</span><span class="s1">._debuggerConnection</span>
        <span class="s1">).then(() =&gt; {</span>
          <span class="s1">const messageToSend = JSON.stringify(parsedPayload);</span>
          <span class="s1">debuggerSocket.send(messageToSend);</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">// Sends single message to device.</span>
  <span class="s1">_sendMessageToDevice(message) {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(message.event !== </span><span class="s0">&quot;getPages&quot;</span><span class="s1">) {</span>
        <span class="s1">debug(</span><span class="s0">&quot;(Debugger)    (Proxy) -&gt; (Device): &quot; </span><span class="s1">+ JSON.stringify(message));</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">._deviceSocket.send(JSON.stringify(message));</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {}</span>
  <span class="s1">}</span>

  <span class="s3">// Sends 'getPages' request to device every PAGES_POLLING_INTERVAL milliseconds.</span>
  <span class="s1">_setPagesPolling() {</span>
    <span class="s1">setInterval(</span>
      <span class="s1">() =&gt;</span>
        <span class="s2">this</span><span class="s1">._sendMessageToDevice({</span>
          <span class="s1">event: </span><span class="s0">&quot;getPages&quot;</span><span class="s1">,</span>
        <span class="s1">}),</span>
      <span class="s1">PAGES_POLLING_INTERVAL</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">// We received new React Native Page ID.</span>
  <span class="s1">_newReactNativePage(page) {</span>
    <span class="s1">debug(`React Native page updated to ${page.id}`);</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s2">this</span><span class="s1">._debuggerConnection == </span><span class="s2">null </span><span class="s1">||</span>
      <span class="s2">this</span><span class="s1">._debuggerConnection.pageId !== REACT_NATIVE_RELOADABLE_PAGE_ID</span>
    <span class="s1">) {</span>
      <span class="s3">// We can just remember new page ID without any further actions if no</span>
      <span class="s3">// debugger is currently attached or attached debugger is not</span>
      <span class="s3">// &quot;Reloadable React Native&quot; connection.</span>
      <span class="s2">this</span><span class="s1">._lastConnectedReactNativePage = page;</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const oldPageId = </span><span class="s2">this</span><span class="s1">._lastConnectedReactNativePage?.id;</span>
    <span class="s2">this</span><span class="s1">._lastConnectedReactNativePage = page;</span>
    <span class="s2">this</span><span class="s1">._isReloading = </span><span class="s2">true</span><span class="s1">;</span>

    <span class="s3">// We already had a debugger connected to React Native page and a</span>
    <span class="s3">// new one appeared - in this case we need to emulate execution context</span>
    <span class="s3">// detroy and resend Debugger.enable and Runtime.enable commands to new</span>
    <span class="s3">// page.</span>

    <span class="s2">if </span><span class="s1">(oldPageId != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">._sendMessageToDevice({</span>
        <span class="s1">event: </span><span class="s0">&quot;disconnect&quot;</span><span class="s1">,</span>
        <span class="s1">payload: {</span>
          <span class="s1">pageId: oldPageId,</span>
        <span class="s1">},</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">._sendMessageToDevice({</span>
      <span class="s1">event: </span><span class="s0">&quot;connect&quot;</span><span class="s1">,</span>
      <span class="s1">payload: {</span>
        <span class="s1">pageId: page.id,</span>
      <span class="s1">},</span>
    <span class="s1">});</span>
    <span class="s1">const toSend = [</span>
      <span class="s1">{</span>
        <span class="s1">method: </span><span class="s0">&quot;Runtime.enable&quot;</span><span class="s1">,</span>
        <span class="s1">id: </span><span class="s4">1</span><span class="s1">e9,</span>
      <span class="s1">},</span>
      <span class="s1">{</span>
        <span class="s1">method: </span><span class="s0">&quot;Debugger.enable&quot;</span><span class="s1">,</span>
        <span class="s1">id: </span><span class="s4">1</span><span class="s1">e9,</span>
      <span class="s1">},</span>
    <span class="s1">];</span>
    <span class="s2">for </span><span class="s1">(const message of toSend) {</span>
      <span class="s2">this</span><span class="s1">._sendMessageToDevice({</span>
        <span class="s1">event: </span><span class="s0">&quot;wrappedEvent&quot;</span><span class="s1">,</span>
        <span class="s1">payload: {</span>
          <span class="s1">pageId: </span><span class="s2">this</span><span class="s1">._mapToDevicePageId(page.id),</span>
          <span class="s1">wrappedEvent: JSON.stringify(message),</span>
        <span class="s1">},</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">// Allows to make changes in incoming message from device.</span>
  <span class="s1">async _processMessageFromDevice(payload, debuggerInfo) {</span>
    <span class="s3">// Replace Android addresses for scriptParsed event.</span>
    <span class="s2">if </span><span class="s1">(payload.method === </span><span class="s0">&quot;Debugger.scriptParsed&quot;</span><span class="s1">) {</span>
      <span class="s1">const params = payload.params || {};</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s0">&quot;sourceMapURL&quot; </span><span class="s2">in </span><span class="s1">params) {</span>
        <span class="s2">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; EMULATOR_LOCALHOST_ADDRESSES.length; ++i) {</span>
          <span class="s1">const address = EMULATOR_LOCALHOST_ADDRESSES[i];</span>
          <span class="s2">if </span><span class="s1">(params.sourceMapURL.indexOf(address) &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">payload.params.sourceMapURL = params.sourceMapURL.replace(</span>
              <span class="s1">address,</span>
              <span class="s0">&quot;localhost&quot;</span>
            <span class="s1">);</span>
            <span class="s1">debuggerInfo.originalSourceURLAddress = address;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">const sourceMapURL = </span><span class="s2">this</span><span class="s1">._tryParseHTTPURL(params.sourceMapURL);</span>
        <span class="s2">if </span><span class="s1">(sourceMapURL) {</span>
          <span class="s3">// Some debug clients do not support fetching HTTP URLs. If the</span>
          <span class="s3">// message headed to the debug client identifies the source map with</span>
          <span class="s3">// an HTTP URL, fetch the content here and convert the content to a</span>
          <span class="s3">// Data URL (which is more widely supported) before passing the</span>
          <span class="s3">// message to the debug client.</span>
          <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">const sourceMap = await </span><span class="s2">this</span><span class="s1">._fetchText(sourceMapURL);</span>
            <span class="s1">payload.params.sourceMapURL =</span>
              <span class="s0">&quot;data:application/json;charset=utf-8;base64,&quot; </span><span class="s1">+</span>
              <span class="s2">new </span><span class="s1">Buffer(sourceMap).toString(</span><span class="s0">&quot;base64&quot;</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s2">catch </span><span class="s1">(exception) {</span>
            <span class="s2">this</span><span class="s1">._sendErrorToDebugger(</span>
              <span class="s1">`Failed to fetch source map ${params.sourceMapURL}: ${exception.message}`</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s0">&quot;url&quot; </span><span class="s2">in </span><span class="s1">params) {</span>
        <span class="s2">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; EMULATOR_LOCALHOST_ADDRESSES.length; ++i) {</span>
          <span class="s1">const address = EMULATOR_LOCALHOST_ADDRESSES[i];</span>
          <span class="s2">if </span><span class="s1">(params.url.indexOf(address) &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">payload.params.url = params.url.replace(address, </span><span class="s0">&quot;localhost&quot;</span><span class="s1">);</span>
            <span class="s1">debuggerInfo.originalSourceURLAddress = address;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">// Chrome doesn't download source maps if URL param is not a valid</span>
        <span class="s3">// URL. Some frameworks pass alphanumeric script ID instead of URL which causes</span>
        <span class="s3">// Chrome to not download source maps. In this case we want to prepend script ID</span>
        <span class="s3">// with 'file://' prefix.</span>
        <span class="s2">if </span><span class="s1">(payload.params.url.match(/^[</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">a-z]+$/)) {</span>
          <span class="s1">payload.params.url = FILE_PREFIX + payload.params.url;</span>
          <span class="s1">debuggerInfo.prependedFilePrefix = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">// $FlowFixMe[prop-missing]</span>
        <span class="s2">if </span><span class="s1">(params.scriptId != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">._scriptIdToSourcePathMapping.set(params.scriptId, params.url);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s1">payload.method === </span><span class="s0">&quot;Runtime.executionContextCreated&quot; </span><span class="s1">&amp;&amp;</span>
      <span class="s2">this</span><span class="s1">._isReloading</span>
    <span class="s1">) {</span>
      <span class="s3">// The new context is ready. First notify Chrome that we've reloaded so</span>
      <span class="s3">// it'll resend its breakpoints. If we do this earlier, we may not be</span>
      <span class="s3">// ready to receive them.</span>
      <span class="s1">debuggerInfo.socket.send(</span>
        <span class="s1">JSON.stringify({</span>
          <span class="s1">method: </span><span class="s0">&quot;Runtime.executionContextsCleared&quot;</span><span class="s1">,</span>
        <span class="s1">})</span>
      <span class="s1">);</span>

      <span class="s3">// The VM starts in a paused mode. Ask it to resume.</span>
      <span class="s3">// Note that if setting breakpoints in early initialization functions,</span>
      <span class="s3">// there's a currently race condition between these functions executing</span>
      <span class="s3">// and Chrome re-applying the breakpoints due to the message above.</span>
      <span class="s3">//</span>
      <span class="s3">// This is not an issue in VSCode/Nuclide where the IDE knows to resume</span>
      <span class="s3">// at its convenience.</span>
      <span class="s2">this</span><span class="s1">._sendMessageToDevice({</span>
        <span class="s1">event: </span><span class="s0">&quot;wrappedEvent&quot;</span><span class="s1">,</span>
        <span class="s1">payload: {</span>
          <span class="s1">pageId: </span><span class="s2">this</span><span class="s1">._mapToDevicePageId(debuggerInfo.pageId),</span>
          <span class="s1">wrappedEvent: JSON.stringify({</span>
            <span class="s1">method: </span><span class="s0">&quot;Debugger.resume&quot;</span><span class="s1">,</span>
            <span class="s1">id: </span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">}),</span>
        <span class="s1">},</span>
      <span class="s1">});</span>
      <span class="s2">this</span><span class="s1">._isReloading = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">// Allows to make changes in incoming messages from debugger. Returns a boolean</span>
  <span class="s3">// indicating whether the message has been handled locally (i.e. does not need</span>
  <span class="s3">// to be forwarded to the target).</span>
  <span class="s1">_interceptMessageFromDebugger(req, debuggerInfo, socket) {</span>
    <span class="s2">if </span><span class="s1">(req.method === </span><span class="s0">&quot;Debugger.setBreakpointByUrl&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">._processDebuggerSetBreakpointByUrl(req, debuggerInfo);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(req.method === </span><span class="s0">&quot;Debugger.getScriptSource&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">._processDebuggerGetScriptSource(req, socket);</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">_processDebuggerSetBreakpointByUrl(req, debuggerInfo) {</span>
    <span class="s3">// If we replaced Android emulator's address to localhost we need to change it back.</span>
    <span class="s2">if </span><span class="s1">(debuggerInfo.originalSourceURLAddress) {</span>
      <span class="s2">if </span><span class="s1">(req.params.url) {</span>
        <span class="s1">req.params.url = req.params.url.replace(</span>
          <span class="s0">&quot;localhost&quot;</span><span class="s1">,</span>
          <span class="s1">debuggerInfo.originalSourceURLAddress</span>
        <span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(</span>
          <span class="s1">req.params.url &amp;&amp;</span>
          <span class="s1">req.params.url.startsWith(FILE_PREFIX) &amp;&amp;</span>
          <span class="s1">debuggerInfo.prependedFilePrefix</span>
        <span class="s1">) {</span>
          <span class="s3">// Remove fake URL prefix if we modified URL in _processMessageFromDevice.</span>
          <span class="s3">// $FlowFixMe[incompatible-use]</span>
          <span class="s1">req.params.url = req.params.url.slice(FILE_PREFIX.length);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(req.params.urlRegex) {</span>
        <span class="s1">req.params.urlRegex = req.params.urlRegex.replace(</span>
          <span class="s1">/localhost/g,</span>
          <span class="s3">// $FlowFixMe[incompatible-call]</span>
          <span class="s1">debuggerInfo.originalSourceURLAddress</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_processDebuggerGetScriptSource(req, socket) {</span>
    <span class="s1">const sendSuccessResponse = (scriptSource) =&gt; {</span>
      <span class="s1">const result = {</span>
        <span class="s1">scriptSource,</span>
      <span class="s1">};</span>
      <span class="s1">socket.send(</span>
        <span class="s1">JSON.stringify({</span>
          <span class="s1">id: req.id,</span>
          <span class="s1">result,</span>
        <span class="s1">})</span>
      <span class="s1">);</span>
    <span class="s1">};</span>
    <span class="s1">const sendErrorResponse = (error) =&gt; {</span>
      <span class="s3">// Tell the client that the request failed</span>
      <span class="s1">const result = {</span>
        <span class="s1">error: {</span>
          <span class="s1">message: error,</span>
        <span class="s1">},</span>
      <span class="s1">};</span>
      <span class="s1">socket.send(</span>
        <span class="s1">JSON.stringify({</span>
          <span class="s1">id: req.id,</span>
          <span class="s1">result,</span>
        <span class="s1">})</span>
      <span class="s1">);</span>

      <span class="s3">// Send to the console as well, so the user can see it</span>
      <span class="s2">this</span><span class="s1">._sendErrorToDebugger(error);</span>
    <span class="s1">};</span>
    <span class="s1">const pathToSource = </span><span class="s2">this</span><span class="s1">._scriptIdToSourcePathMapping.get(</span>
      <span class="s1">req.params.scriptId</span>
    <span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(pathToSource) {</span>
      <span class="s1">const httpURL = </span><span class="s2">this</span><span class="s1">._tryParseHTTPURL(pathToSource);</span>
      <span class="s2">if </span><span class="s1">(httpURL) {</span>
        <span class="s2">this</span><span class="s1">._fetchText(httpURL).then(</span>
          <span class="s1">(text) =&gt; sendSuccessResponse(text),</span>
          <span class="s1">(err) =&gt;</span>
            <span class="s1">sendErrorResponse(</span>
              <span class="s1">`Failed to fetch source url ${pathToSource}: ${err.message}`</span>
            <span class="s1">)</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">let file;</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s1">file = fs.readFileSync(</span>
            <span class="s1">path.resolve(</span><span class="s2">this</span><span class="s1">._projectRoot, pathToSource),</span>
            <span class="s0">&quot;utf8&quot;</span>
          <span class="s1">);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
          <span class="s1">sendErrorResponse(</span>
            <span class="s1">`Failed to fetch source file ${pathToSource}: ${err.message}`</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(file) {</span>
          <span class="s1">sendSuccessResponse(file);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_mapToDevicePageId(pageId) {</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s1">pageId === REACT_NATIVE_RELOADABLE_PAGE_ID &amp;&amp;</span>
      <span class="s2">this</span><span class="s1">._lastConnectedReactNativePage != </span><span class="s2">null</span>
    <span class="s1">) {</span>
      <span class="s2">return this</span><span class="s1">._lastConnectedReactNativePage.id;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">pageId;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_tryParseHTTPURL(url) {</span>
    <span class="s1">let parsedURL;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">parsedURL = </span><span class="s2">new </span><span class="s1">URL(url);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">{}</span>
    <span class="s1">const protocol = parsedURL?.protocol;</span>
    <span class="s2">if </span><span class="s1">(protocol !== </span><span class="s0">&quot;http:&quot; </span><span class="s1">&amp;&amp; protocol !== </span><span class="s0">&quot;https:&quot;</span><span class="s1">) {</span>
      <span class="s1">parsedURL = undefined;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">parsedURL;</span>
  <span class="s1">}</span>

  <span class="s3">// Fetch text, raising an exception if the text could not be fetched,</span>
  <span class="s3">// or is too large.</span>
  <span class="s1">async _fetchText(url) {</span>
    <span class="s2">if </span><span class="s1">(url.hostname !== </span><span class="s0">&quot;localhost&quot;</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;remote fetches not permitted&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">const response = await (</span><span class="s4">0</span><span class="s1">, _nodeFetch.</span><span class="s2">default</span><span class="s1">)(url);</span>
    <span class="s1">const text = await response.text();</span>
    <span class="s3">// Restrict the length to well below the 500MB limit for nodejs (leaving</span>
    <span class="s3">// room some some later manipulation, e.g. base64 or wrapping in JSON)</span>
    <span class="s2">if </span><span class="s1">(text.length &gt; </span><span class="s4">350000000</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;file too large to fetch via HTTP&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">text;</span>
  <span class="s1">}</span>
  <span class="s1">_sendErrorToDebugger(message) {</span>
    <span class="s1">const debuggerSocket = </span><span class="s2">this</span><span class="s1">._debuggerConnection?.socket;</span>
    <span class="s2">if </span><span class="s1">(debuggerSocket &amp;&amp; debuggerSocket.readyState === _ws.</span><span class="s2">default</span><span class="s1">.OPEN) {</span>
      <span class="s1">debuggerSocket.send(</span>
        <span class="s1">JSON.stringify({</span>
          <span class="s1">method: </span><span class="s0">&quot;Runtime.consoleAPICalled&quot;</span><span class="s1">,</span>
          <span class="s1">params: {</span>
            <span class="s1">args: [</span>
              <span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">&quot;string&quot;</span><span class="s1">,</span>
                <span class="s1">value: message,</span>
              <span class="s1">},</span>
            <span class="s1">],</span>
            <span class="s1">executionContextId: </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s1">type: </span><span class="s0">&quot;error&quot;</span><span class="s1">,</span>
          <span class="s1">},</span>
        <span class="s1">})</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">module.exports = Device;</span>
</pre>
</body>
</html>
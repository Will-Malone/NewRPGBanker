<html>
<head>
<title>lval.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lval.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_types&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;_node&quot;</span><span class="s0">,</span><span class="s1">&quot;_scopeflags&quot;</span><span class="s0">,</span><span class="s1">&quot;_parseError&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwn&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;unwrapParenthesizedExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;ParseBindingListFlags&quot;</span><span class="s0">,</span><span class="s1">&quot;ALLOW_EMPTY&quot;</span><span class="s0">,</span><span class="s1">&quot;IS_FUNCTION_PARAMS&quot;</span><span class="s0">,</span><span class="s1">&quot;IS_CONSTRUCTOR_PARAMS&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;LValParser&quot;</span><span class="s0">,</span><span class="s1">&quot;NodeUtils&quot;</span><span class="s0">,</span><span class="s1">&quot;toAssignable&quot;</span><span class="s0">,</span><span class="s1">&quot;isLHS&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$extra&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$extra3&quot;</span><span class="s0">,</span><span class="s1">&quot;parenthesized&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;extra&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionScope&quot;</span><span class="s0">,</span><span class="s1">&quot;recordArrowParameterBindingError&quot;</span><span class="s0">,</span><span class="s1">&quot;Errors&quot;</span><span class="s0">,</span><span class="s1">&quot;InvalidParenthesizedAssignment&quot;</span><span class="s0">,</span><span class="s1">&quot;at&quot;</span><span class="s0">,</span><span class="s1">&quot;raise&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;properties&quot;</span><span class="s0">,</span><span class="s1">&quot;last&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$extra2&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;isLast&quot;</span><span class="s0">,</span><span class="s1">&quot;toAssignableObjectExpressionProp&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingCommaLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;RestTrailingComma&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;classScope&quot;</span><span class="s0">,</span><span class="s1">&quot;usePrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrivateNameSV&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;toAssignableList&quot;</span><span class="s0">,</span><span class="s1">&quot;elements&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;MissingEqInAssignment&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;PatternHasAccessor&quot;</span><span class="s0">,</span><span class="s1">&quot;PatternHasMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;argument&quot;</span><span class="s0">,</span><span class="s1">&quot;checkToRestConversion&quot;</span><span class="s0">,</span><span class="s1">&quot;exprList&quot;</span><span class="s0">,</span><span class="s1">&quot;elt&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignable&quot;</span><span class="s0">,</span><span class="s1">&quot;isBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;element&quot;</span><span class="s0">,</span><span class="s1">&quot;toReferencedList&quot;</span><span class="s0">,</span><span class="s1">&quot;isParenthesizedExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;toReferencedListDeep&quot;</span><span class="s0">,</span><span class="s1">&quot;expr&quot;</span><span class="s0">,</span><span class="s1">&quot;parseSpread&quot;</span><span class="s0">,</span><span class="s1">&quot;refExpressionErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;startNode&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;parseMaybeAssignAllowIn&quot;</span><span class="s0">,</span><span class="s1">&quot;finishNode&quot;</span><span class="s0">,</span><span class="s1">&quot;parseRestBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;parseBindingAtom&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;parseBindingList&quot;</span><span class="s0">,</span><span class="s1">&quot;parseObjectLike&quot;</span><span class="s0">,</span><span class="s1">&quot;parseIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;close&quot;</span><span class="s0">,</span><span class="s1">&quot;closeCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;flags&quot;</span><span class="s0">,</span><span class="s1">&quot;allowEmpty&quot;</span><span class="s0">,</span><span class="s1">&quot;elts&quot;</span><span class="s0">,</span><span class="s1">&quot;first&quot;</span><span class="s0">,</span><span class="s1">&quot;eat&quot;</span><span class="s0">,</span><span class="s1">&quot;expect&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;parseAssignableListItemTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;checkCommaAfterRest&quot;</span><span class="s0">,</span><span class="s1">&quot;decorators&quot;</span><span class="s0">,</span><span class="s1">&quot;hasPlugin&quot;</span><span class="s0">,</span><span class="s1">&quot;UnsupportedParameterDecorator&quot;</span><span class="s0">,</span><span class="s1">&quot;startLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;parseDecorator&quot;</span><span class="s0">,</span><span class="s1">&quot;parseAssignableListItem&quot;</span><span class="s0">,</span><span class="s1">&quot;parseBindingRestProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;parseBindingProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;expectPlugin&quot;</span><span class="s0">,</span><span class="s1">&quot;parsePrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;parsePropertyName&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;parseObjPropValue&quot;</span><span class="s0">,</span><span class="s1">&quot;parseMaybeDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;_startLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;_left&quot;</span><span class="s0">,</span><span class="s1">&quot;startNodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidLVal&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnparenthesizedInAssign&quot;</span><span class="s0">,</span><span class="s1">&quot;binding&quot;</span><span class="s0">,</span><span class="s1">&quot;AssignmentPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;RestElement&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;ParenthesizedExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ArrayPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;checkLVal&quot;</span><span class="s0">,</span><span class="s1">&quot;in&quot;</span><span class="s0">,</span><span class="s1">&quot;ancestor&quot;</span><span class="s0">,</span><span class="s1">&quot;BIND_NONE&quot;</span><span class="s0">,</span><span class="s1">&quot;checkClashes&quot;</span><span class="s0">,</span><span class="s1">&quot;strictModeChanged&quot;</span><span class="s0">,</span><span class="s1">&quot;hasParenthesizedAncestor&quot;</span><span class="s0">,</span><span class="s1">&quot;_expression$extra&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;InvalidPropertyBindingPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;checkIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;ParamDupe&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;validity&quot;</span><span class="s0">,</span><span class="s1">&quot;ParseErrorClass&quot;</span><span class="s0">,</span><span class="s1">&quot;InvalidLhs&quot;</span><span class="s0">,</span><span class="s1">&quot;InvalidLhsBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;isParenthesizedExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;nextAncestor&quot;</span><span class="s0">,</span><span class="s1">&quot;child&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingType&quot;</span><span class="s0">,</span><span class="s1">&quot;strict&quot;</span><span class="s0">,</span><span class="s1">&quot;isStrictBindReservedWord&quot;</span><span class="s0">,</span><span class="s1">&quot;inModule&quot;</span><span class="s0">,</span><span class="s1">&quot;isStrictBindOnlyReservedWord&quot;</span><span class="s0">,</span><span class="s1">&quot;StrictEvalArguments&quot;</span><span class="s0">,</span><span class="s1">&quot;referenceName&quot;</span><span class="s0">,</span><span class="s1">&quot;StrictEvalArgumentsBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingName&quot;</span><span class="s0">,</span><span class="s1">&quot;BIND_FLAGS_NO_LET_IN_LEXICAL&quot;</span><span class="s0">,</span><span class="s1">&quot;LetInLexicalBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;declareNameFromIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;declareName&quot;</span><span class="s0">,</span><span class="s1">&quot;allowPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;InvalidRestAssignmentPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;lookaheadCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;ElementAfterRest&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/parser/lval.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import * as charCodes from </span><span class="s3">\&quot;</span><span class="s1">charcodes</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { tt, type TokenType } from </span><span class="s3">\&quot;</span><span class="s1">../tokenizer/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">AssignmentPattern,</span><span class="s3">\n  </span><span class="s1">TSParameterProperty,</span><span class="s3">\n  </span><span class="s1">Decorator,</span><span class="s3">\n  </span><span class="s1">Expression,</span><span class="s3">\n  </span><span class="s1">Identifier,</span><span class="s3">\n  </span><span class="s1">Node,</span><span class="s3">\n  </span><span class="s1">Pattern,</span><span class="s3">\n  </span><span class="s1">RestElement,</span><span class="s3">\n  </span><span class="s1">SpreadElement,</span><span class="s3">\n  </span><span class="s1">ObjectOrClassMember,</span><span class="s3">\n  </span><span class="s1">ClassMember,</span><span class="s3">\n  </span><span class="s1">ObjectMember,</span><span class="s3">\n  </span><span class="s1">TsNamedTypeElementBase,</span><span class="s3">\n  </span><span class="s1">PrivateName,</span><span class="s3">\n  </span><span class="s1">ObjectExpression,</span><span class="s3">\n  </span><span class="s1">ObjectPattern,</span><span class="s3">\n  </span><span class="s1">ArrayExpression,</span><span class="s3">\n  </span><span class="s1">ArrayPattern,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">../types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Pos, Position } from </span><span class="s3">\&quot;</span><span class="s1">../util/location</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isStrictBindOnlyReservedWord,</span><span class="s3">\n  </span><span class="s1">isStrictBindReservedWord,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">../util/identifier</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { NodeUtils, type Undone } from </span><span class="s3">\&quot;</span><span class="s1">./node</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">type BindingTypes,</span><span class="s3">\n  </span><span class="s1">BIND_NONE,</span><span class="s3">\n  </span><span class="s1">BIND_FLAGS_NO_LET_IN_LEXICAL,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">../util/scopeflags</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { ExpressionErrors } from </span><span class="s3">\&quot;</span><span class="s1">./util</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Errors, type LValAncestor } from </span><span class="s3">\&quot;</span><span class="s1">../parse-error</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type Parser from </span><span class="s3">\&quot;</span><span class="s1">./index</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const getOwn = &lt;T extends {}&gt;(object: T, key: keyof T) =&gt;</span><span class="s3">\n  </span><span class="s1">Object.hasOwnProperty.call(object, key) &amp;&amp; object[key];</span><span class="s3">\n\n</span><span class="s1">const unwrapParenthesizedExpression = (node: Node): Node =&gt; {</span><span class="s3">\n  </span><span class="s1">return node.type === </span><span class="s3">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s3">\&quot;\n    </span><span class="s1">? unwrapParenthesizedExpression(node.expression)</span><span class="s3">\n    </span><span class="s1">: node;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export const enum ParseBindingListFlags {</span><span class="s3">\n  </span><span class="s1">ALLOW_EMPTY = 1 &lt;&lt; 0,</span><span class="s3">\n  </span><span class="s1">IS_FUNCTION_PARAMS = 1 &lt;&lt; 1,</span><span class="s3">\n  </span><span class="s1">IS_CONSTRUCTOR_PARAMS = 1 &lt;&lt; 2,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default abstract class LValParser extends NodeUtils {</span><span class="s3">\n  </span><span class="s1">// Forward-declaration: defined in expression.js</span><span class="s3">\n  </span><span class="s1">abstract parseIdentifier(liberal?: boolean): Identifier;</span><span class="s3">\n  </span><span class="s1">abstract parseMaybeAssign(</span><span class="s3">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s3">\n    </span><span class="s1">afterLeftParse?: Function,</span><span class="s3">\n    </span><span class="s1">refNeedsArrowPos?: Pos | null,</span><span class="s3">\n  </span><span class="s1">): Expression;</span><span class="s3">\n\n  </span><span class="s1">abstract parseMaybeAssignAllowIn(</span><span class="s3">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s3">\n    </span><span class="s1">afterLeftParse?: Function,</span><span class="s3">\n    </span><span class="s1">refNeedsArrowPos?: Pos | null,</span><span class="s3">\n  </span><span class="s1">): Expression;</span><span class="s3">\n\n  </span><span class="s1">abstract parseObjectLike&lt;T extends ObjectPattern | ObjectExpression&gt;(</span><span class="s3">\n    </span><span class="s1">close: TokenType,</span><span class="s3">\n    </span><span class="s1">isPattern: boolean,</span><span class="s3">\n    </span><span class="s1">isRecord?: boolean,</span><span class="s3">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors,</span><span class="s3">\n  </span><span class="s1">): T;</span><span class="s3">\n  </span><span class="s1">abstract parseObjPropValue(</span><span class="s3">\n    </span><span class="s1">prop: any,</span><span class="s3">\n    </span><span class="s1">startLoc: Position | null,</span><span class="s3">\n    </span><span class="s1">isGenerator: boolean,</span><span class="s3">\n    </span><span class="s1">isAsync: boolean,</span><span class="s3">\n    </span><span class="s1">isPattern: boolean,</span><span class="s3">\n    </span><span class="s1">isAccessor: boolean,</span><span class="s3">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s3">\n  </span><span class="s1">): void;</span><span class="s3">\n  </span><span class="s1">abstract parsePropertyName(</span><span class="s3">\n    </span><span class="s1">prop: ObjectOrClassMember | ClassMember | TsNamedTypeElementBase,</span><span class="s3">\n  </span><span class="s1">): Expression | Identifier;</span><span class="s3">\n  </span><span class="s1">abstract parsePrivateName(): PrivateName;</span><span class="s3">\n  </span><span class="s1">// Forward-declaration: defined in statement.js</span><span class="s3">\n  </span><span class="s1">abstract parseDecorator(): Decorator;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Convert existing expression atom to assignable pattern</span><span class="s3">\n   </span><span class="s1">* if possible. Also checks invalid destructuring targets:</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* - Parenthesized Destructuring patterns</span><span class="s3">\n   </span><span class="s1">* - RestElement is not the last element</span><span class="s3">\n   </span><span class="s1">* - Missing `=` in assignment pattern</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* NOTE: There is a corresponding </span><span class="s3">\&quot;</span><span class="s1">isAssignable</span><span class="s3">\&quot; </span><span class="s1">method.</span><span class="s3">\n   </span><span class="s1">* When this one is updated, please check if also that one needs to be updated.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param node The expression atom</span><span class="s3">\n   </span><span class="s1">* @param isLHS Whether we are parsing a LeftHandSideExpression.</span><span class="s3">\n   </span><span class="s1">*              If isLHS is `true`, the following cases are allowed: `[(a)] = [0]`, `[(a.b)] = [0]`</span><span class="s3">\n   </span><span class="s1">*              If isLHS is `false`, we are in an arrow function parameters list.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toAssignable(node: Node, isLHS: boolean = false): void {</span><span class="s3">\n    </span><span class="s1">let parenthesized = undefined;</span><span class="s3">\n    </span><span class="s1">if (node.type === </span><span class="s3">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s3">\&quot; </span><span class="s1">|| node.extra?.parenthesized) {</span><span class="s3">\n      </span><span class="s1">parenthesized = unwrapParenthesizedExpression(node);</span><span class="s3">\n      </span><span class="s1">if (isLHS) {</span><span class="s3">\n        </span><span class="s1">// an LHS can be reinterpreted to a binding pattern but not vice versa.</span><span class="s3">\n        </span><span class="s1">// therefore a parenthesized identifier is ambiguous until we are sure it is an assignment expression</span><span class="s3">\n        </span><span class="s1">// i.e. `([(a) = []] = []) =&gt; {}`</span><span class="s3">\n        </span><span class="s1">// see also `recordArrowParameterBindingError` signature in packages/babel-parser/src/util/expression-scope.js</span><span class="s3">\n        </span><span class="s1">if (parenthesized.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">this.expressionScope.recordArrowParameterBindingError(</span><span class="s3">\n            </span><span class="s1">Errors.InvalidParenthesizedAssignment,</span><span class="s3">\n            </span><span class="s1">{ at: node },</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else if (parenthesized.type !== </span><span class="s3">\&quot;</span><span class="s1">MemberExpression</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// A parenthesized member expression can be in LHS but not in pattern.</span><span class="s3">\n          </span><span class="s1">// If the LHS is later interpreted as a pattern, `checkLVal` will throw for member expression binding</span><span class="s3">\n          </span><span class="s1">// i.e. `([(a.b) = []] = []) =&gt; {}`</span><span class="s3">\n          </span><span class="s1">this.raise(Errors.InvalidParenthesizedAssignment, { at: node });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.raise(Errors.InvalidParenthesizedAssignment, { at: node });</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">switch (node.type) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ObjectPattern</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ArrayPattern</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">RestElement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ObjectExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">node.type = </span><span class="s3">\&quot;</span><span class="s1">ObjectPattern</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">for (</span><span class="s3">\n          </span><span class="s1">let i = 0, length = node.properties.length, last = length - 1;</span><span class="s3">\n          </span><span class="s1">i &lt; length;</span><span class="s3">\n          </span><span class="s1">i++</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">const prop = node.properties[i];</span><span class="s3">\n          </span><span class="s1">const isLast = i === last;</span><span class="s3">\n          </span><span class="s1">this.toAssignableObjectExpressionProp(prop, isLast, isLHS);</span><span class="s3">\n\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">isLast &amp;&amp;</span><span class="s3">\n            </span><span class="s1">prop.type === </span><span class="s3">\&quot;</span><span class="s1">RestElement</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n            </span><span class="s1">node.extra?.trailingCommaLoc</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">this.raise(Errors.RestTrailingComma, {</span><span class="s3">\n              </span><span class="s1">at: node.extra.trailingCommaLoc,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ObjectProperty</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">const { key, value } = node;</span><span class="s3">\n        </span><span class="s1">if (this.isPrivateName(key)) {</span><span class="s3">\n          </span><span class="s1">this.classScope.usePrivateName(</span><span class="s3">\n            </span><span class="s1">this.getPrivateNameSV(key),</span><span class="s3">\n            </span><span class="s1">key.loc.start,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.toAssignable(value, isLHS);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">SpreadElement</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          \&quot;</span><span class="s1">Internal @babel/parser error (this is a bug, please report it).</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n            \&quot; </span><span class="s1">SpreadElement should be converted by .toAssignable's caller.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ArrayExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">node.type = </span><span class="s3">\&quot;</span><span class="s1">ArrayPattern</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.toAssignableList(</span><span class="s3">\n          </span><span class="s1">node.elements,</span><span class="s3">\n          </span><span class="s1">node.extra?.trailingCommaLoc,</span><span class="s3">\n          </span><span class="s1">isLHS,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">if (node.operator !== </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">this.raise(Errors.MissingEqInAssignment, { at: node.left.loc.end });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">node.type = </span><span class="s3">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">delete node.operator;</span><span class="s3">\n        </span><span class="s1">this.toAssignable(node.left, isLHS);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">/*::invariant (parenthesized !== undefined) */</span><span class="s3">\n        </span><span class="s1">this.toAssignable(parenthesized, isLHS);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n\n      </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">// We don't know how to deal with this node. It will</span><span class="s3">\n      </span><span class="s1">// be reported by a later call to checkLVal</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toAssignableObjectExpressionProp(</span><span class="s3">\n    </span><span class="s1">prop: Node,</span><span class="s3">\n    </span><span class="s1">isLast: boolean,</span><span class="s3">\n    </span><span class="s1">isLHS: boolean,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (prop.type === </span><span class="s3">\&quot;</span><span class="s1">ObjectMethod</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.raise(</span><span class="s3">\n        </span><span class="s1">prop.kind === </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">|| prop.kind === </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;\n          </span><span class="s1">? Errors.PatternHasAccessor</span><span class="s3">\n          </span><span class="s1">: Errors.PatternHasMethod,</span><span class="s3">\n        </span><span class="s1">{ at: prop.key },</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else if (prop.type === </span><span class="s3">\&quot;</span><span class="s1">SpreadElement</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">prop.type = </span><span class="s3">\&quot;</span><span class="s1">RestElement</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">const arg = prop.argument;</span><span class="s3">\n      </span><span class="s1">this.checkToRestConversion(arg, /* allowPattern */ false);</span><span class="s3">\n      </span><span class="s1">this.toAssignable(arg, isLHS);</span><span class="s3">\n\n      </span><span class="s1">if (!isLast) {</span><span class="s3">\n        </span><span class="s1">this.raise(Errors.RestTrailingComma, { at: prop });</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.toAssignable(prop, isLHS);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Convert list of expression atoms to binding list.</span><span class="s3">\n\n  </span><span class="s1">toAssignableList(</span><span class="s3">\n    </span><span class="s1">exprList: Expression[],</span><span class="s3">\n    </span><span class="s1">trailingCommaLoc: Position | undefined | null,</span><span class="s3">\n    </span><span class="s1">isLHS: boolean,</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">const end = exprList.length - 1;</span><span class="s3">\n\n    </span><span class="s1">for (let i = 0; i &lt;= end; i++) {</span><span class="s3">\n      </span><span class="s1">const elt = exprList[i];</span><span class="s3">\n      </span><span class="s1">if (!elt) continue;</span><span class="s3">\n\n      </span><span class="s1">if (elt.type === </span><span class="s3">\&quot;</span><span class="s1">SpreadElement</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">elt.type = </span><span class="s3">\&quot;</span><span class="s1">RestElement</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">const arg = elt.argument;</span><span class="s3">\n        </span><span class="s1">this.checkToRestConversion(arg, /* allowPattern */ true);</span><span class="s3">\n        </span><span class="s1">this.toAssignable(arg, isLHS);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.toAssignable(elt, isLHS);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (elt.type === </span><span class="s3">\&quot;</span><span class="s1">RestElement</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (i &lt; end) {</span><span class="s3">\n          </span><span class="s1">this.raise(Errors.RestTrailingComma, { at: elt });</span><span class="s3">\n        </span><span class="s1">} else if (trailingCommaLoc) {</span><span class="s3">\n          </span><span class="s1">this.raise(Errors.RestTrailingComma, { at: trailingCommaLoc });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">isAssignable(node: Node, isBinding?: boolean): boolean {</span><span class="s3">\n    </span><span class="s1">switch (node.type) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ObjectPattern</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ArrayPattern</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">RestElement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ObjectExpression</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">const last = node.properties.length - 1;</span><span class="s3">\n        </span><span class="s1">return (node.properties as ObjectExpression[</span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">]).every(</span><span class="s3">\n          </span><span class="s1">(prop, i) =&gt; {</span><span class="s3">\n            </span><span class="s1">return (</span><span class="s3">\n              </span><span class="s1">prop.type !== </span><span class="s3">\&quot;</span><span class="s1">ObjectMethod</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n              </span><span class="s1">(i === last || prop.type !== </span><span class="s3">\&quot;</span><span class="s1">SpreadElement</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n              </span><span class="s1">this.isAssignable(prop)</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ObjectProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return this.isAssignable(node.value);</span><span class="s3">\n\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">SpreadElement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return this.isAssignable(node.argument);</span><span class="s3">\n\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ArrayExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return (node as ArrayExpression).elements.every(</span><span class="s3">\n          </span><span class="s1">element =&gt; element === null || this.isAssignable(element),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return node.operator === </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return this.isAssignable(node.expression);</span><span class="s3">\n\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">MemberExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">OptionalMemberExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return !isBinding;</span><span class="s3">\n\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Convert list of expression atoms to a list of</span><span class="s3">\n\n  </span><span class="s1">toReferencedList(</span><span class="s3">\n    </span><span class="s1">exprList: ReadonlyArray&lt;Expression | undefined | null&gt;,</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s3">\n    </span><span class="s1">isParenthesizedExpr?: boolean,</span><span class="s3">\n  </span><span class="s1">): ReadonlyArray&lt;Expression | undefined | null&gt; {</span><span class="s3">\n    </span><span class="s1">return exprList;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toReferencedListDeep(</span><span class="s3">\n    </span><span class="s1">exprList: ReadonlyArray&lt;Expression | undefined | null&gt;,</span><span class="s3">\n    </span><span class="s1">isParenthesizedExpr?: boolean,</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">this.toReferencedList(exprList, isParenthesizedExpr);</span><span class="s3">\n\n    </span><span class="s1">for (const expr of exprList) {</span><span class="s3">\n      </span><span class="s1">if (expr?.type === </span><span class="s3">\&quot;</span><span class="s1">ArrayExpression</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">this.toReferencedListDeep(expr.elements);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Parses spread element.</span><span class="s3">\n\n  </span><span class="s1">parseSpread(</span><span class="s3">\n    </span><span class="s1">this: Parser,</span><span class="s3">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s3">\n  </span><span class="s1">): SpreadElement {</span><span class="s3">\n    </span><span class="s1">const node = this.startNode&lt;SpreadElement&gt;();</span><span class="s3">\n    </span><span class="s1">this.next();</span><span class="s3">\n    </span><span class="s1">node.argument = this.parseMaybeAssignAllowIn(</span><span class="s3">\n      </span><span class="s1">refExpressionErrors,</span><span class="s3">\n      </span><span class="s1">undefined,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s3">\&quot;</span><span class="s1">SpreadElement</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-BindingRestProperty</span><span class="s3">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-BindingRestElement</span><span class="s3">\n  </span><span class="s1">parseRestBinding(this: Parser): RestElement {</span><span class="s3">\n    </span><span class="s1">const node = this.startNode&lt;RestElement&gt;();</span><span class="s3">\n    </span><span class="s1">this.next(); // eat `...`</span><span class="s3">\n    </span><span class="s1">node.argument = this.parseBindingAtom();</span><span class="s3">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s3">\&quot;</span><span class="s1">RestElement</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Parses lvalue (assignable) atom.</span><span class="s3">\n  </span><span class="s1">parseBindingAtom(this: Parser): Pattern {</span><span class="s3">\n    </span><span class="s1">// https://tc39.es/ecma262/#prod-BindingPattern</span><span class="s3">\n    </span><span class="s1">switch (this.state.type) {</span><span class="s3">\n      </span><span class="s1">case tt.bracketL: {</span><span class="s3">\n        </span><span class="s1">const node = this.startNode&lt;ArrayPattern&gt;();</span><span class="s3">\n        </span><span class="s1">this.next();</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error: Fixme: TSParameterProperty can not be assigned to node.elements</span><span class="s3">\n        </span><span class="s1">node.elements = this.parseBindingList(</span><span class="s3">\n          </span><span class="s1">tt.bracketR,</span><span class="s3">\n          </span><span class="s1">charCodes.rightSquareBracket,</span><span class="s3">\n          </span><span class="s1">ParseBindingListFlags.ALLOW_EMPTY,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s3">\&quot;</span><span class="s1">ArrayPattern</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">case tt.braceL:</span><span class="s3">\n        </span><span class="s1">return this.parseObjectLike(tt.braceR, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// https://tc39.es/ecma262/#prod-BindingIdentifier</span><span class="s3">\n    </span><span class="s1">return this.parseIdentifier();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-BindingElementList</span><span class="s3">\n  </span><span class="s1">parseBindingList(</span><span class="s3">\n    </span><span class="s1">this: Parser,</span><span class="s3">\n    </span><span class="s1">close: TokenType,</span><span class="s3">\n    </span><span class="s1">closeCharCode: (typeof charCodes)[keyof typeof charCodes],</span><span class="s3">\n    </span><span class="s1">flags: ParseBindingListFlags,</span><span class="s3">\n  </span><span class="s1">): Array&lt;Pattern | TSParameterProperty&gt; {</span><span class="s3">\n    </span><span class="s1">const allowEmpty = flags &amp; ParseBindingListFlags.ALLOW_EMPTY;</span><span class="s3">\n\n    </span><span class="s1">const elts: Array&lt;Pattern | TSParameterProperty&gt; = [];</span><span class="s3">\n    </span><span class="s1">let first = true;</span><span class="s3">\n    </span><span class="s1">while (!this.eat(close)) {</span><span class="s3">\n      </span><span class="s1">if (first) {</span><span class="s3">\n        </span><span class="s1">first = false;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.expect(tt.comma);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (allowEmpty &amp;&amp; this.match(tt.comma)) {</span><span class="s3">\n        </span><span class="s1">elts.push(null);</span><span class="s3">\n      </span><span class="s1">} else if (this.eat(close)) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">} else if (this.match(tt.ellipsis)) {</span><span class="s3">\n        </span><span class="s1">elts.push(</span><span class="s3">\n          </span><span class="s1">this.parseAssignableListItemTypes(this.parseRestBinding(), flags),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (!this.checkCommaAfterRest(closeCharCode)) {</span><span class="s3">\n          </span><span class="s1">this.expect(close);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">const decorators = [];</span><span class="s3">\n        </span><span class="s1">if (this.match(tt.at) &amp;&amp; this.hasPlugin(</span><span class="s3">\&quot;</span><span class="s1">decorators</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n          </span><span class="s1">this.raise(Errors.UnsupportedParameterDecorator, {</span><span class="s3">\n            </span><span class="s1">at: this.state.startLoc,</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// invariant: hasPlugin(</span><span class="s3">\&quot;</span><span class="s1">decorators-legacy</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">while (this.match(tt.at)) {</span><span class="s3">\n          </span><span class="s1">decorators.push(this.parseDecorator());</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">elts.push(this.parseAssignableListItem(flags, decorators));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return elts;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-BindingRestProperty</span><span class="s3">\n  </span><span class="s1">parseBindingRestProperty(</span><span class="s3">\n    </span><span class="s1">this: Parser,</span><span class="s3">\n    </span><span class="s1">prop: Undone&lt;RestElement&gt;,</span><span class="s3">\n  </span><span class="s1">): RestElement {</span><span class="s3">\n    </span><span class="s1">this.next(); // eat '...'</span><span class="s3">\n    </span><span class="s1">// Don't use parseRestBinding() as we only allow Identifier here.</span><span class="s3">\n    </span><span class="s1">prop.argument = this.parseIdentifier();</span><span class="s3">\n    </span><span class="s1">this.checkCommaAfterRest(charCodes.rightCurlyBrace);</span><span class="s3">\n    </span><span class="s1">return this.finishNode(prop, </span><span class="s3">\&quot;</span><span class="s1">RestElement</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-BindingProperty</span><span class="s3">\n  </span><span class="s1">parseBindingProperty(this: Parser): ObjectMember | RestElement {</span><span class="s3">\n    </span><span class="s1">const prop = this.startNode&lt;ObjectMember | RestElement&gt;();</span><span class="s3">\n    </span><span class="s1">const { type, startLoc } = this.state;</span><span class="s3">\n    </span><span class="s1">if (type === tt.ellipsis) {</span><span class="s3">\n      </span><span class="s1">return this.parseBindingRestProperty(prop as Undone&lt;RestElement&gt;);</span><span class="s3">\n    </span><span class="s1">} else if (type === tt.privateName) {</span><span class="s3">\n      </span><span class="s1">this.expectPlugin(</span><span class="s3">\&quot;</span><span class="s1">destructuringPrivate</span><span class="s3">\&quot;</span><span class="s1">, startLoc);</span><span class="s3">\n      </span><span class="s1">this.classScope.usePrivateName(this.state.value, startLoc);</span><span class="s3">\n      </span><span class="s1">(prop as Undone&lt;ObjectMember&gt;).key = this.parsePrivateName();</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.parsePropertyName(prop as Undone&lt;ObjectMember&gt;);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">(prop as Undone&lt;ObjectMember&gt;).method = false;</span><span class="s3">\n    </span><span class="s1">return this.parseObjPropValue(</span><span class="s3">\n      </span><span class="s1">prop as Undone&lt;ObjectMember&gt;,</span><span class="s3">\n      </span><span class="s1">startLoc,</span><span class="s3">\n      </span><span class="s1">false /* isGenerator */,</span><span class="s3">\n      </span><span class="s1">false /* isAsync */,</span><span class="s3">\n      </span><span class="s1">true /* isPattern */,</span><span class="s3">\n      </span><span class="s1">false /* isAccessor */,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">parseAssignableListItem(</span><span class="s3">\n    </span><span class="s1">this: Parser,</span><span class="s3">\n    </span><span class="s1">flags: ParseBindingListFlags,</span><span class="s3">\n    </span><span class="s1">decorators: Decorator[],</span><span class="s3">\n  </span><span class="s1">): Pattern | TSParameterProperty {</span><span class="s3">\n    </span><span class="s1">const left = this.parseMaybeDefault();</span><span class="s3">\n    </span><span class="s1">this.parseAssignableListItemTypes(left, flags);</span><span class="s3">\n    </span><span class="s1">const elt = this.parseMaybeDefault(left.loc.start, left);</span><span class="s3">\n    </span><span class="s1">if (decorators.length) {</span><span class="s3">\n      </span><span class="s1">left.decorators = decorators;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return elt;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Used by flow/typescript plugin to add type annotations to binding elements</span><span class="s3">\n  </span><span class="s1">parseAssignableListItemTypes(</span><span class="s3">\n    </span><span class="s1">param: Pattern,</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s3">\n    </span><span class="s1">flags: ParseBindingListFlags,</span><span class="s3">\n  </span><span class="s1">): Pattern {</span><span class="s3">\n    </span><span class="s1">return param;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Parses assignment pattern around given atom if possible.</span><span class="s3">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-BindingElement</span><span class="s3">\n  </span><span class="s1">parseMaybeDefault(</span><span class="s3">\n    </span><span class="s1">this: Parser,</span><span class="s3">\n    </span><span class="s1">startLoc?: Position | null,</span><span class="s3">\n    </span><span class="s1">left?: Pattern | null,</span><span class="s3">\n  </span><span class="s1">): Pattern {</span><span class="s3">\n    </span><span class="s1">startLoc ??= this.state.startLoc;</span><span class="s3">\n    </span><span class="s1">left = left ?? this.parseBindingAtom();</span><span class="s3">\n    </span><span class="s1">if (!this.eat(tt.eq)) return left;</span><span class="s3">\n\n    </span><span class="s1">const node = this.startNodeAt&lt;AssignmentPattern&gt;(startLoc);</span><span class="s3">\n    </span><span class="s1">node.left = left;</span><span class="s3">\n    </span><span class="s1">node.right = this.parseMaybeAssignAllowIn();</span><span class="s3">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s3">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Return information use in determining whether a Node of a given type is an LVal,</span><span class="s3">\n   </span><span class="s1">* possibly given certain additional context information.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Subclasser notes: This method has kind of a lot of mixed, but related,</span><span class="s3">\n   </span><span class="s1">* responsibilities. If we can definitively determine with the information</span><span class="s3">\n   </span><span class="s1">* provided that this either *is* or *isn't* a valid `LVal`, then the return</span><span class="s3">\n   </span><span class="s1">* value is easy: just return `true` or `false`. However, if it is a valid</span><span class="s3">\n   </span><span class="s1">* LVal *ancestor*, and thus its descendants must be subsequently visited to</span><span class="s3">\n   </span><span class="s1">* continue the </span><span class="s3">\&quot;</span><span class="s1">investigation</span><span class="s3">\&quot;</span><span class="s1">, then this method should return the relevant</span><span class="s3">\n   </span><span class="s1">* child key as a `string`. In some special cases, you additionally want to</span><span class="s3">\n   </span><span class="s1">* convey that this node should be treated as if it were parenthesized. In</span><span class="s3">\n   </span><span class="s1">* that case, a tuple of [key: string, parenthesized: boolean] is returned.</span><span class="s3">\n   </span><span class="s1">* The `string`-only return option is actually just a shorthand for:</span><span class="s3">\n   </span><span class="s1">* `[key: string, parenthesized: false]`.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param type A Node `type` string</span><span class="s3">\n   </span><span class="s1">* @param isUnparenthesizedInAssign</span><span class="s3">\n   </span><span class="s1">*        Whether the node in question is unparenthesized and its parent</span><span class="s3">\n   </span><span class="s1">*        is either an assignment pattern or an assignment expression.\n   * @param binding\n   *        The binding operation that is being considered for this potential\n   *        LVal.\n   * @returns `true` or `false` if we can immediately determine whether the node\n   *          type in question can be treated as an `LVal`.\n   *          A `string` key to traverse if we must check this child.\n   *          A `[string, boolean]` tuple if we need to check this child and\n   *          treat is as parenthesized.\n   */\n  isValidLVal(\n    type: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isUnparenthesizedInAssign: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    binding: BindingTypes,\n  ): string | boolean {\n    return getOwn(\n      {\n        AssignmentPattern: \&quot;left\&quot;,\n        RestElement: \&quot;argument\&quot;,\n        ObjectProperty: \&quot;value\&quot;,\n        ParenthesizedExpression: \&quot;expression\&quot;,\n        ArrayPattern: \&quot;elements\&quot;,\n        ObjectPattern: \&quot;properties\&quot;,\n      },\n      // @ts-expect-error refine string to enum\n      type,\n    );\n  }\n\n  /**\n   * Verify that a target expression is an lval (something that can be assigned to).\n   *\n   * @param expression The expression in question to check.\n   * @param options A set of options described below.\n   * @param options.in\n   *        The relevant ancestor to provide context information for the error\n   *        if the check fails.\n   * @param options.binding\n   *        The desired binding type. If the given expression is an identifier\n   *        and `binding` is not `BIND_NONE`, `checkLVal` will register binding\n   *        to the parser scope See also `src/util/scopeflags.js`\n   * @param options.checkClashes\n   *        An optional string set to check if an identifier name is included.\n   *        `checkLVal` will add checked identifier name to `checkClashes` It is\n   *        used in tracking duplicates in function parameter lists. If it is\n   *        false, `checkLVal` will skip duplicate checks\n   * @param options.strictModeChanged\n   *        Whether an identifier has been parsed in a sloppy context but should\n   *        be reinterpreted as strict-mode. e.g. `(arguments) =&gt; { \&quot;use strict \&quot;}`\n   * @param options.hasParenthesizedAncestor\n   *        This is only used internally during recursive calls, and you should\n   *        not have to set it yourself.\n   */\n\n  checkLVal(\n    expression: Expression | ObjectMember | RestElement,\n    {\n      in: ancestor,\n      binding = BIND_NONE,\n      checkClashes = false,\n      strictModeChanged = false,\n      hasParenthesizedAncestor = false,\n    }: {\n      in: LValAncestor;\n      binding?: BindingTypes;\n      checkClashes?: Set&lt;string&gt; | false;\n      strictModeChanged?: boolean;\n      hasParenthesizedAncestor?: boolean;\n    },\n  ): void {\n    const type = expression.type;\n\n    // If we find here an ObjectMethod, it's because this was originally\n    // an ObjectExpression which has then been converted.\n    // toAssignable already reported this error with a nicer message.\n    if (this.isObjectMethod(expression)) return;\n\n    if (type === \&quot;MemberExpression\&quot;) {\n      if (binding !== BIND_NONE) {\n        this.raise(Errors.InvalidPropertyBindingPattern, { at: expression });\n      }\n      return;\n    }\n\n    if (type === \&quot;Identifier\&quot;) {\n      this.checkIdentifier(\n        expression as Identifier,\n        binding,\n        strictModeChanged,\n      );\n\n      const { name } = expression as Identifier;\n\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, { at: expression });\n        } else {\n          checkClashes.add(name);\n        }\n      }\n\n      return;\n    }\n\n    const validity = this.isValidLVal(\n      type,\n      !(hasParenthesizedAncestor || expression.extra?.parenthesized) &amp;&amp;\n        ancestor.type === \&quot;AssignmentExpression\&quot;,\n      binding,\n    );\n\n    if (validity === true) return;\n    if (validity === false) {\n      const ParseErrorClass =\n        binding === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;\n\n      this.raise(ParseErrorClass, { at: expression, ancestor });\n      return;\n    }\n\n    const [key, isParenthesizedExpression] = Array.isArray(validity)\n      ? validity\n      : [validity, type === \&quot;ParenthesizedExpression\&quot;];\n    const nextAncestor =\n      type === \&quot;ArrayPattern\&quot; ||\n      type === \&quot;ObjectPattern\&quot; ||\n      type === \&quot;ParenthesizedExpression\&quot;\n        ? ({ type } as const)\n        : ancestor;\n\n    // @ts-expect-error key may not index expression.\n    for (const child of [].concat(expression[key])) {\n      if (child) {\n        this.checkLVal(child, {\n          in: nextAncestor,\n          binding,\n          checkClashes,\n          strictModeChanged,\n          hasParenthesizedAncestor: isParenthesizedExpression,\n        });\n      }\n    }\n  }\n\n  checkIdentifier(\n    at: Identifier,\n    bindingType: BindingTypes,\n    strictModeChanged: boolean = false,\n  ) {\n    if (\n      this.state.strict &amp;&amp;\n      (strictModeChanged\n        ? isStrictBindReservedWord(at.name, this.inModule)\n        : isStrictBindOnlyReservedWord(at.name))\n    ) {\n      if (bindingType === BIND_NONE) {\n        this.raise(Errors.StrictEvalArguments, { at, referenceName: at.name });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, {\n          at,\n          bindingName: at.name,\n        });\n      }\n    }\n\n    if (bindingType &amp; BIND_FLAGS_NO_LET_IN_LEXICAL &amp;&amp; at.name === \&quot;let\&quot;) {\n      this.raise(Errors.LetInLexicalBinding, { at });\n    }\n\n    if (!(bindingType &amp; BIND_NONE)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n\n  declareNameFromIdentifier(identifier: Identifier, binding: BindingTypes) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n\n  checkToRestConversion(node: Node, allowPattern: boolean): void {\n    switch (node.type) {\n      case \&quot;ParenthesizedExpression\&quot;:\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n      case \&quot;Identifier\&quot;:\n      case \&quot;MemberExpression\&quot;:\n        break;\n      case \&quot;ArrayExpression\&quot;:\n      case \&quot;ObjectExpression\&quot;:\n        if (allowPattern) break;\n      /* falls through */\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, { at: node });\n    }\n  }\n\n  checkCommaAfterRest(\n    close: (typeof charCodes)[keyof typeof charCodes],\n  ): boolean {\n    if (!this.match(tt.comma)) {\n      return false;\n    }\n\n    this.raise(\n      this.lookaheadCharCode() === close\n        ? Errors.RestTrailingComma\n        : Errors.ElementAfterRest,\n      { at: this.state.startLoc },\n    );\n\n    return true;\n  }\n}\n&quot;],&quot;mappings&quot;:&quot;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&quot;}</span></pre>
</body>
</html>
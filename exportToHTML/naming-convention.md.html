<html>
<head>
<title>naming-convention.md</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #a9b7c6;}
.s3 { color: #9876aa; font-style: italic;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
naming-convention.md</font>
</center></td></tr></table>
<pre><span class="s0">---</span>
<span class="s2">description</span><span class="s1">: '</span><span class="s2">Enforce naming conventions for everything across a codebase.'</span>
<span class="s0">---</span>

<span class="s0">&gt; </span><span class="s2">ðŸ›‘ This file is source code, not the primary documentation location</span><span class="s1">! </span><span class="s2">ðŸ›‘</span>
<span class="s1">&gt;</span>
<span class="s1">&gt; </span><span class="s2">See </span><span class="s1">**https://typescript-eslint.io/rules/naming-convention** </span><span class="s2">for documentation.</span>

<span class="s2">Enforcing naming conventions helps keep the codebase consistent, and reduces overhead when thinking about how to name a variable.</span>
<span class="s2">Additionally, a well-designed style guide can help communicate intent, such as by enforcing all private properties begin with an `</span><span class="s1">_</span><span class="s2">`, and all global-level constants are written in `UPPER_CASE`.</span>

<span class="s0">## </span><span class="s2">Examples</span>

<span class="s2">This rule allows you to enforce conventions for any identifier, using granular selectors to create a fine-grained style guide.</span>

<span class="s1">:::</span><span class="s2">note</span>

<span class="s2">This rule only needs type information in specific cases, detailed below.</span>

<span class="s1">:::</span>

<span class="s0">## </span><span class="s2">Options</span>

<span class="s2">This rule accepts an array of objects, with each object describing a different naming convention.</span>
<span class="s2">Each property will be described in detail below. Also see the examples section below for illustrated examples.</span>

<span class="s0">```</span><span class="s3">ts</span>
<span class="s4">type Options = {</span>
  <span class="s4">// format options</span>
  <span class="s4">format:</span>
    <span class="s4">| (</span>
        <span class="s4">| 'camelCase'</span>
        <span class="s4">| 'strictCamelCase'</span>
        <span class="s4">| 'PascalCase'</span>
        <span class="s4">| 'StrictPascalCase'</span>
        <span class="s4">| 'snake_case'</span>
        <span class="s4">| 'UPPER_CASE'</span>
      <span class="s4">)[]</span>
    <span class="s4">| null;</span>
  <span class="s4">custom?: {</span>
    <span class="s4">regex: string;</span>
    <span class="s4">match: boolean;</span>
  <span class="s4">};</span>
  <span class="s4">leadingUnderscore?:</span>
    <span class="s4">| 'forbid'</span>
    <span class="s4">| 'require'</span>
    <span class="s4">| 'requireDouble'</span>
    <span class="s4">| 'allow'</span>
    <span class="s4">| 'allowDouble'</span>
    <span class="s4">| 'allowSingleOrDouble';</span>
  <span class="s4">trailingUnderscore?:</span>
    <span class="s4">| 'forbid'</span>
    <span class="s4">| 'require'</span>
    <span class="s4">| 'requireDouble'</span>
    <span class="s4">| 'allow'</span>
    <span class="s4">| 'allowDouble'</span>
    <span class="s4">| 'allowSingleOrDouble';</span>
  <span class="s4">prefix?: string[];</span>
  <span class="s4">suffix?: string[];</span>

  <span class="s4">// selector options</span>
  <span class="s4">selector: Selector | Selector[];</span>
  <span class="s4">filter?:</span>
    <span class="s4">| string</span>
    <span class="s4">| {</span>
        <span class="s4">regex: string;</span>
        <span class="s4">match: boolean;</span>
      <span class="s4">};</span>
  <span class="s4">// the allowed values for these are dependent on the selector - see below</span>
  <span class="s4">modifiers?: Modifiers&lt;Selector&gt;[];</span>
  <span class="s4">types?: Types&lt;Selector&gt;[];</span>
<span class="s4">}[];</span>

<span class="s4">// the default config is similar to ESLint's camelcase rule but more strict</span>
<span class="s4">const defaultOptions: Options = [</span>
  <span class="s4">{</span>
    <span class="s4">selector: 'default',</span>
    <span class="s4">format: ['camelCase'],</span>
    <span class="s4">leadingUnderscore: 'allow',</span>
    <span class="s4">trailingUnderscore: 'allow',</span>
  <span class="s4">},</span>

  <span class="s4">{</span>
    <span class="s4">selector: 'variable',</span>
    <span class="s4">format: ['camelCase', 'UPPER_CASE'],</span>
    <span class="s4">leadingUnderscore: 'allow',</span>
    <span class="s4">trailingUnderscore: 'allow',</span>
  <span class="s4">},</span>

  <span class="s4">{</span>
    <span class="s4">selector: 'typeLike',</span>
    <span class="s4">format: ['PascalCase'],</span>
  <span class="s4">},</span>
<span class="s4">];</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">Format Options</span>

<span class="s2">Every single selector can have the same set of format options.</span>
<span class="s2">For information about how each selector is applied, see </span><span class="s1">[&quot;</span><span class="s2">How does the rule evaluate a name's format?</span><span class="s1">&quot;](</span><span class="s2">#how-does-the-rule-evaluate-a-names-format</span><span class="s1">)</span><span class="s2">.</span>

<span class="s0">#### </span><span class="s2">`format`</span>

<span class="s2">The `format` option defines the allowed formats for the identifier. This option accepts an array of the following values, and the identifier can match any of them</span><span class="s1">:</span>

<span class="s0">- </span><span class="s2">`camelCase` - standard camelCase format - no underscores are allowed between characters, and consecutive capitals are allowed </span><span class="s1">(</span><span class="s2">i.e. both `myID` and `myId` are valid</span><span class="s1">)</span><span class="s2">.</span>
<span class="s0">- </span><span class="s2">`PascalCase` - same as `camelCase`, except the first character must be upper-case.</span>
<span class="s0">- </span><span class="s2">`snake_case` - standard snake_case format - all characters must be lower-case, and underscores are allowed.</span>
<span class="s0">- </span><span class="s2">`strictCamelCase` - same as `camelCase`, but consecutive capitals are not allowed </span><span class="s1">(</span><span class="s2">i.e. `myId` is valid, but `myID` is not</span><span class="s1">)</span><span class="s2">.</span>
<span class="s0">- </span><span class="s2">`StrictPascalCase` - same as `strictCamelCase`, except the first character must be upper-case.</span>
<span class="s0">- </span><span class="s2">`UPPER_CASE` - same as `snake_case`, except all characters must be upper-case.</span>

<span class="s2">Instead of an array, you may also pass `null`. This signifies </span><span class="s1">&quot;</span><span class="s2">this selector shall not have its format checked</span><span class="s1">&quot;</span><span class="s2">.</span>
<span class="s2">This can be useful if you want to enforce no particular format for a specific selector, after applying a group selector.</span>

<span class="s0">#### </span><span class="s2">`custom`</span>

<span class="s2">The `custom` option defines a custom regex that the identifier must </span><span class="s1">(</span><span class="s2">or must not</span><span class="s1">) </span><span class="s2">match. This option allows you to have a bit more finer-grained control over identifiers, letting you ban </span><span class="s1">(</span><span class="s2">or force</span><span class="s1">) </span><span class="s2">certain patterns and substrings.</span>
<span class="s2">Accepts an object with the following properties</span><span class="s1">:</span>

<span class="s0">- </span><span class="s2">`match` - true if the identifier </span><span class="s1">_</span><span class="s2">must</span><span class="s1">_ </span><span class="s2">match the `regex`, false if the identifier </span><span class="s1">_</span><span class="s2">must not</span><span class="s1">_ </span><span class="s2">match the `regex`.</span>
<span class="s0">- </span><span class="s2">`regex` - a string that is then passed into RegExp to create a new regular expression</span><span class="s1">: </span><span class="s2">`new RegExp</span><span class="s1">(</span><span class="s2">regex</span><span class="s1">)</span><span class="s2">`</span>

<span class="s0">#### </span><span class="s2">`filter`</span>

<span class="s2">The `filter` option operates similar to `custom`, accepting the same shaped object, except that it controls if the rest of the configuration should or should not be applied to an identifier.</span>

<span class="s2">You can use this to include or exclude specific identifiers from specific configurations.</span>

<span class="s2">Accepts an object with the following properties</span><span class="s1">:</span>

<span class="s0">- </span><span class="s2">`match` - true if the identifier </span><span class="s1">_</span><span class="s2">must</span><span class="s1">_ </span><span class="s2">match the `regex`, false if the identifier </span><span class="s1">_</span><span class="s2">must not</span><span class="s1">_ </span><span class="s2">match the `regex`.</span>
<span class="s0">- </span><span class="s2">`regex` - a string that is then passed into RegExp to create a new regular expression</span><span class="s1">: </span><span class="s2">`new RegExp</span><span class="s1">(</span><span class="s2">regex</span><span class="s1">)</span><span class="s2">`</span>

<span class="s2">Alternatively, `filter` accepts a regular expression </span><span class="s1">(</span><span class="s2">anything accepted into `new RegExp</span><span class="s1">(</span><span class="s2">filter</span><span class="s1">)</span><span class="s2">`</span><span class="s1">)</span><span class="s2">. In this case, it's treated as if you had passed an object with the regex and `match</span><span class="s1">: </span><span class="s2">true`.</span>

<span class="s0">#### </span><span class="s2">`leadingUnderscore` / `trailingUnderscore`</span>

<span class="s2">The `leadingUnderscore` / `trailingUnderscore` options control whether leading/trailing underscores are considered valid. Accepts one of the following values</span><span class="s1">:</span>

<span class="s0">- </span><span class="s2">`allow` - existence of a single leading/trailing underscore is not explicitly enforced.</span>
<span class="s0">- </span><span class="s2">`allowDouble` - existence of a double leading/trailing underscore is not explicitly enforced.</span>
<span class="s0">- </span><span class="s2">`allowSingleOrDouble` - existence of a single or a double leading/trailing underscore is not explicitly enforced.</span>
<span class="s0">- </span><span class="s2">`forbid` - a leading/trailing underscore is not allowed at all.</span>
<span class="s0">- </span><span class="s2">`require` - a single leading/trailing underscore must be included.</span>
<span class="s0">- </span><span class="s2">`requireDouble` - two leading/trailing underscores must be included.</span>

<span class="s0">#### </span><span class="s2">`prefix` / `suffix`</span>

<span class="s2">The `prefix` / `suffix` options control which prefix/suffix strings must exist for the identifier. Accepts an array of strings.</span>

<span class="s2">If these are provided, the identifier must start with one of the provided values. For example, if you provide `{ prefix</span><span class="s1">: ['</span><span class="s2">Class', </span><span class="s1">'</span><span class="s2">IFace', </span><span class="s1">'</span><span class="s2">Type'</span><span class="s1">] </span><span class="s2">}`, then the following names are valid</span><span class="s1">: </span><span class="s2">`ClassBar`, `IFaceFoo`, `TypeBaz`, but the name `Bang` is not valid, as it contains none of the prefixes.</span>

<span class="s1">**</span><span class="s2">Note</span><span class="s1">:** </span><span class="s2">As </span><span class="s1">[</span><span class="s2">documented above</span><span class="s1">](</span><span class="s2">#format-options</span><span class="s1">)</span><span class="s2">, the prefix is trimmed before format is validated, therefore PascalCase must be used to allow variables such as `isEnabled` using the prefix `is`.</span>

<span class="s0">### </span><span class="s2">Selector Options</span>

<span class="s0">- </span><span class="s2">`selector` allows you to specify what types of identifiers to target.</span>
  <span class="s0">- </span><span class="s2">Accepts one or array of selectors to define an option block that applies to one or multiple selectors.</span>
  <span class="s0">- </span><span class="s2">For example, if you provide `{ selector</span><span class="s1">: ['</span><span class="s2">function', </span><span class="s1">'</span><span class="s2">variable'</span><span class="s1">] </span><span class="s2">}`, then it will apply the same option to variable and function nodes.</span>
  <span class="s0">- </span><span class="s2">See </span><span class="s1">[</span><span class="s2">Allowed Selectors, Modifiers and Types</span><span class="s1">](</span><span class="s2">#allowed-selectors-modifiers-and-types</span><span class="s1">) </span><span class="s2">below for the complete list of allowed selectors.</span>
<span class="s0">- </span><span class="s2">`modifiers` allows you to specify which modifiers to granularly apply to, such as the accessibility </span><span class="s1">(</span><span class="s2">`#private`/`private`/`protected`/`public`</span><span class="s1">)</span><span class="s2">, or if the thing is `static`, etc.</span>
  <span class="s0">- </span><span class="s2">The name must match </span><span class="s1">_</span><span class="s2">all</span><span class="s1">_ </span><span class="s2">of the modifiers.</span>
  <span class="s0">- </span><span class="s2">For example, if you provide `{ modifiers</span><span class="s1">: ['</span><span class="s2">private',</span><span class="s1">'</span><span class="s2">readonly',</span><span class="s1">'</span><span class="s2">static'</span><span class="s1">] </span><span class="s2">}`, then it will only match something that is `private static readonly`, and something that is just `private` will not match.</span>
  <span class="s0">- </span><span class="s2">The following `modifiers` are allowed</span><span class="s1">:</span>
    <span class="s0">- </span><span class="s2">`abstract`,`override`,`private`,`protected`,`readonly`,`static` - matches any member explicitly declared with the given modifier.</span>
    <span class="s0">- </span><span class="s2">`async` - matches any method, function, or function variable which is async via the `async` keyword </span><span class="s1">(</span><span class="s2">e.g. does not match functions that return promises without using `async` keyword</span><span class="s1">)</span>
    <span class="s0">- </span><span class="s2">`const` - matches a variable declared as being `const` </span><span class="s1">(</span><span class="s2">`const x = 1`</span><span class="s1">)</span><span class="s2">.</span>
    <span class="s0">- </span><span class="s2">`destructured` - matches a variable declared via an object destructuring pattern </span><span class="s1">(</span><span class="s2">`const {x, z = 2}`</span><span class="s1">)</span><span class="s2">.</span>
      <span class="s0">- </span><span class="s2">Note that this does not match renamed destructured properties </span><span class="s1">(</span><span class="s2">`const {x</span><span class="s1">: </span><span class="s2">y, a</span><span class="s1">: </span><span class="s2">b = 2}`</span><span class="s1">)</span><span class="s2">.</span>
    <span class="s0">- </span><span class="s2">`exported` - matches anything that is exported from the module.</span>
    <span class="s0">- </span><span class="s2">`global` - matches a variable/function declared in the top-level scope.</span>
    <span class="s0">- </span><span class="s2">`#private` - matches any member with a private identifier </span><span class="s1">(</span><span class="s2">an identifier that starts with `#`</span><span class="s1">)</span>
    <span class="s0">- </span><span class="s2">`public` - matches any member that is either explicitly declared as `public`, or has no visibility modifier </span><span class="s1">(</span><span class="s2">i.e. implicitly public</span><span class="s1">)</span><span class="s2">.</span>
    <span class="s0">- </span><span class="s2">`requiresQuotes` - matches any name that requires quotes as it is not a valid identifier </span><span class="s1">(</span><span class="s2">i.e. has a space, a dash, etc in it</span><span class="s1">)</span><span class="s2">.</span>
    <span class="s0">- </span><span class="s2">`unused` - matches anything that is not used.</span>
<span class="s0">- </span><span class="s2">`types` allows you to specify which types to match. This option supports simple, primitive types only </span><span class="s1">(</span><span class="s2">`array`,`boolean`,`function`,`number`,`string`</span><span class="s1">)</span><span class="s2">.</span>
  <span class="s0">- </span><span class="s2">The name must match </span><span class="s1">_</span><span class="s2">one</span><span class="s1">_ </span><span class="s2">of the types.</span>
  <span class="s0">- </span><span class="s1">**_</span><span class="s2">NOTE - Using this option will require that you lint with type information.</span><span class="s1">_**</span>
  <span class="s0">- </span><span class="s2">For example, this lets you do things like enforce that `boolean` variables are prefixed with a verb.</span>
  <span class="s0">- </span><span class="s2">The following `types` are allowed</span><span class="s1">:</span>
    <span class="s0">- </span><span class="s2">`array` matches any type assignable to `Array&lt;unknown&gt; | null | undefined`</span>
    <span class="s0">- </span><span class="s2">`boolean` matches any type assignable to `boolean | null | undefined`</span>
    <span class="s0">- </span><span class="s2">`function` matches any type assignable to `Function | null | undefined`</span>
    <span class="s0">- </span><span class="s2">`number` matches any type assignable to `number | null | undefined`</span>
    <span class="s0">- </span><span class="s2">`string` matches any type assignable to `string | null | undefined`</span>

<span class="s2">The ordering of selectors does not matter. The implementation will automatically sort the selectors to ensure they match from most-specific to least specific. It will keep checking selectors in that order until it finds one that matches the name. See </span><span class="s1">[&quot;</span><span class="s2">How does the rule automatically order selectors?</span><span class="s1">&quot;](</span><span class="s2">#how-does-the-rule-automatically-order-selectors</span><span class="s1">)</span>

<span class="s0">#### </span><span class="s2">Allowed Selectors, Modifiers and Types</span>

<span class="s2">There are two types of selectors, individual selectors, and grouped selectors.</span>

<span class="s0">##### </span><span class="s2">Individual Selectors</span>

<span class="s2">Individual Selectors match specific, well-defined sets. There is no overlap between each of the individual selectors.</span>

<span class="s0">- </span><span class="s2">`accessor` - matches any accessor.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`abstract`, `override`, `private`, `protected`, `public`, `requiresQuotes`, `static`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">`array`, `boolean`, `function`, `number`, `string`.</span>
<span class="s0">- </span><span class="s2">`class` - matches any class declaration.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`abstract`, `exported`, `unused`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">none.</span>
<span class="s0">- </span><span class="s2">`classMethod` - matches any class method. Also matches properties that have direct function expression or arrow function expression values. Does not match accessors.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`abstract`, `async`, `override`, `#private`, `private`, `protected`, `public`, `requiresQuotes`, `static`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">none.</span>
<span class="s0">- </span><span class="s2">`classProperty` - matches any class property. Does not match properties that have direct function expression or arrow function expression values.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`abstract`, `override`, `#private`, `private`, `protected`, `public`, `readonly`, `requiresQuotes`, `static`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">`array`, `boolean`, `function`, `number`, `string`.</span>
<span class="s0">- </span><span class="s2">`enum` - matches any enum declaration.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`exported`, `unused`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">none.</span>
<span class="s0">- </span><span class="s2">`enumMember` - matches any enum member.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`requiresQuotes`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">none.</span>
<span class="s0">- </span><span class="s2">`function` - matches any named function declaration or named function expression.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`async`, `exported`, `global`, `unused`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">none.</span>
<span class="s0">- </span><span class="s2">`interface` - matches any interface declaration.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`exported`, `unused`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">none.</span>
<span class="s0">- </span><span class="s2">`objectLiteralMethod` - matches any object literal method. Also matches properties that have direct function expression or arrow function expression values. Does not match accessors.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`async`, `public`, `requiresQuotes`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">none.</span>
<span class="s0">- </span><span class="s2">`objectLiteralProperty` - matches any object literal property. Does not match properties that have direct function expression or arrow function expression values.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`public`, `requiresQuotes`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">`array`, `boolean`, `function`, `number`, `string`.</span>
<span class="s0">- </span><span class="s2">`parameter` - matches any function parameter. Does not match parameter properties.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`destructured`, `unused`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">`array`, `boolean`, `function`, `number`, `string`.</span>
<span class="s0">- </span><span class="s2">`parameterProperty` - matches any parameter property.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`private`, `protected`, `public`, `readonly`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">`array`, `boolean`, `function`, `number`, `string`.</span>
<span class="s0">- </span><span class="s2">`typeAlias` - matches any type alias declaration.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`exported`, `unused`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">none.</span>
<span class="s0">- </span><span class="s2">`typeMethod` - matches any object type method. Also matches properties that have direct function expression or arrow function expression values. Does not match accessors.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`public`, `requiresQuotes`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">none.</span>
<span class="s0">- </span><span class="s2">`typeParameter` - matches any generic type parameter declaration.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`unused`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">none.</span>
<span class="s0">- </span><span class="s2">`typeProperty` - matches any object type property. Does not match properties that have direct function expression or arrow function expression values.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`public`, `readonly`, `requiresQuotes`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">`array`, `boolean`, `function`, `number`, `string`.</span>
<span class="s0">- </span><span class="s2">`variable` - matches any `const` / `let` / `var` variable name.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`async`, `const`, `destructured`, `exported`, `global`, `unused`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">`array`, `boolean`, `function`, `number`, `string`.</span>

<span class="s0">##### </span><span class="s2">Group Selectors</span>

<span class="s2">Group Selectors are provided for convenience, and essentially bundle up sets of individual selectors.</span>

<span class="s0">- </span><span class="s2">`default` - matches everything.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">all modifiers.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">none.</span>
<span class="s0">- </span><span class="s2">`memberLike` - matches the same as `accessor`, `enumMember`, `method`, `parameterProperty`, `property`.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`abstract`, `async`, `override`, `#private`, `private`, `protected`, `public`, `readonly`, `requiresQuotes`, `static`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">none.</span>
<span class="s0">- </span><span class="s2">`method` - matches the same as `classMethod`, `objectLiteralMethod`, `typeMethod`.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`abstract`, `async`, `override`, `#private`, `private`, `protected`, `public`, `readonly`, `requiresQuotes`, `static`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">none.</span>
<span class="s0">- </span><span class="s2">`property` - matches the same as `classProperty`, `objectLiteralProperty`, `typeProperty`.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`abstract`, `async`, `override`, `#private`, `private`, `protected`, `public`, `readonly`, `requiresQuotes`, `static`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">`array`, `boolean`, `function`, `number`, `string`.</span>
<span class="s0">- </span><span class="s2">`typeLike` - matches the same as `class`, `enum`, `interface`, `typeAlias`, `typeParameter`.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`abstract`, `unused`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">none.</span>
<span class="s0">- </span><span class="s2">`variableLike` - matches the same as `function`, `parameter` and `variable`.</span>
  <span class="s0">- </span><span class="s2">Allowed `modifiers`</span><span class="s1">: </span><span class="s2">`async`, `unused`.</span>
  <span class="s0">- </span><span class="s2">Allowed `types`</span><span class="s1">: </span><span class="s2">none.</span>

<span class="s0">## </span><span class="s2">FAQ</span>

<span class="s2">This is a big rule, and there's a lot of docs. Here are a few clarifications that people often ask about or figure out via trial-and-error.</span>

<span class="s0">### </span><span class="s2">How does the rule evaluate a selector?</span>

<span class="s2">Each selector is checked in the following way</span><span class="s1">:</span>

<span class="s0">1. </span><span class="s2">check the `filter`</span>
   <span class="s0">1. </span><span class="s2">if `filter` is omitted â†’ skip this step.</span>
   <span class="s0">2. </span><span class="s2">if the name matches the `filter` â†’ continue evaluating this selector.</span>
   <span class="s0">3. </span><span class="s2">if the name does not match the `filter` â†’ skip this selector and continue to the next selector.</span>
<span class="s0">2. </span><span class="s2">check the `selector`</span>
   <span class="s0">1. </span><span class="s2">if `selector` is one individual selector â†’ the name's type must be of that type.</span>
   <span class="s0">2. </span><span class="s2">if `selector` is a group selector â†’ the name's type must be one of the grouped types.</span>
   <span class="s0">3. </span><span class="s2">if `selector` is an array of selectors â†’ apply the above for each selector in the array.</span>
<span class="s0">3. </span><span class="s2">check the `types`</span>
   <span class="s0">1. </span><span class="s2">if `types` is omitted â†’ skip this step.</span>
   <span class="s0">2. </span><span class="s2">if the name has a type in `types` â†’ continue evaluating this selector.</span>
   <span class="s0">3. </span><span class="s2">if the name does not have a type in `types` â†’ skip this selector and continue to the next selector.</span>

<span class="s2">A name is considered to pass the config if it</span><span class="s1">:</span>

<span class="s0">1. </span><span class="s2">Matches one selector and passes all of that selector's format checks.</span>
<span class="s0">2. </span><span class="s2">Matches no selectors.</span>

<span class="s2">A name is considered to fail the config if it matches one selector and fails one that selector's format checks.</span>

<span class="s0">### </span><span class="s2">How does the rule automatically order selectors?</span>

<span class="s2">Each identifier should match exactly one selector. It may match multiple group selectors - but only ever one selector.</span>
<span class="s2">With that in mind - the base sort order works out to be</span><span class="s1">:</span>

<span class="s0">1. </span><span class="s2">Individual Selectors</span>
<span class="s0">2. </span><span class="s2">Grouped Selectors</span>
<span class="s0">3. </span><span class="s2">Default Selector</span>

<span class="s2">Within each of these categories, some further sorting occurs based on what selector options are supplied</span><span class="s1">:</span>

<span class="s0">1. </span><span class="s2">`filter` is given the highest priority above all else.</span>
<span class="s0">2. </span><span class="s2">`types`</span>
<span class="s0">3. </span><span class="s2">`modifiers`</span>
<span class="s0">4. </span><span class="s2">everything else</span>

<span class="s2">For example, if you provide the following config</span><span class="s1">:</span>

<span class="s0">```</span><span class="s3">ts</span>
<span class="s4">[</span>
  <span class="s4">/* 1 */ { selector: 'default', format: ['camelCase'] },</span>
  <span class="s4">/* 2 */ { selector: 'variable', format: ['snake_case'] },</span>
  <span class="s4">/* 3 */ { selector: 'variable', types: ['boolean'], format: ['UPPER_CASE'] },</span>
  <span class="s4">/* 4 */ { selector: 'variableLike', format: ['PascalCase'] },</span>
<span class="s4">];</span>
<span class="s0">```</span>

<span class="s2">Then for the code `const x = 1`, the rule will validate the selectors in the following order</span><span class="s1">: </span><span class="s2">`3`, `2`, `4`, `1`.</span>
<span class="s2">To clearly spell it out</span><span class="s1">:</span>

<span class="s0">- </span><span class="s1">(</span><span class="s2">3</span><span class="s1">) </span><span class="s2">is tested first because it has `types` and is an individual selector.</span>
<span class="s0">- </span><span class="s1">(</span><span class="s2">2</span><span class="s1">) </span><span class="s2">is tested next because it is an individual selector.</span>
<span class="s0">- </span><span class="s1">(</span><span class="s2">4</span><span class="s1">) </span><span class="s2">is tested next as it is a grouped selector.</span>
<span class="s0">- </span><span class="s1">(</span><span class="s2">1</span><span class="s1">) </span><span class="s2">is tested last as it is the base default selector.</span>

<span class="s2">Its worth noting that whilst this order is applied, all selectors may not run on a name.</span>
<span class="s2">This is explained in </span><span class="s1">[&quot;</span><span class="s2">How does the rule evaluate a name's format?</span><span class="s1">&quot;](</span><span class="s2">#how-does-the-rule-evaluate-a-names-format</span><span class="s1">)</span>

<span class="s0">### </span><span class="s2">How does the rule evaluate a name's format?</span>

<span class="s2">When the format of an identifier is checked, it is checked in the following order</span><span class="s1">:</span>

<span class="s0">1. </span><span class="s2">validate leading underscore</span>
<span class="s0">1. </span><span class="s2">validate trailing underscore</span>
<span class="s0">1. </span><span class="s2">validate prefix</span>
<span class="s0">1. </span><span class="s2">validate suffix</span>
<span class="s0">1. </span><span class="s2">validate custom</span>
<span class="s0">1. </span><span class="s2">validate format</span>

<span class="s2">For steps 1-4, if the identifier matches the option, the matching part will be removed.</span>
<span class="s2">This is done so that you can apply formats like PascalCase without worrying about prefixes or underscores causing it to not match.</span>

<span class="s2">One final note is that if the name were to become empty via this trimming process, it is considered to match all `format`s. An example of where this might be useful is for generic type parameters, where you want all names to be prefixed with `T`, but also want to allow for the single character `T` name.</span>

<span class="s2">Here are some examples to help illustrate</span>

<span class="s2">Name</span><span class="s1">: </span><span class="s2">`</span><span class="s1">_</span><span class="s2">IMyInterface`</span>
<span class="s2">Selector</span><span class="s1">:</span>

<span class="s0">```</span><span class="s3">json</span>
<span class="s4">{</span>
  <span class="s4">&quot;leadingUnderscore&quot;: &quot;require&quot;,</span>
  <span class="s4">&quot;prefix&quot;: [&quot;I&quot;],</span>
  <span class="s4">&quot;format&quot;: [&quot;UPPER_CASE&quot;, &quot;StrictPascalCase&quot;]</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">1. </span><span class="s2">`name = </span><span class="s1">_</span><span class="s2">IMyInterface`</span>
<span class="s0">1. </span><span class="s2">validate leading underscore</span>
   <span class="s0">1. </span><span class="s2">config is provided</span>
   <span class="s0">1. </span><span class="s2">check name â†’ pass</span>
   <span class="s0">1. </span><span class="s2">Trim underscore â†’ `name = IMyInterface`</span>
<span class="s0">1. </span><span class="s2">validate trailing underscore</span>
   <span class="s0">1. </span><span class="s2">config is not provided â†’ skip</span>
<span class="s0">1. </span><span class="s2">validate prefix</span>
   <span class="s0">1. </span><span class="s2">config is provided</span>
   <span class="s0">1. </span><span class="s2">check name â†’ pass</span>
   <span class="s0">1. </span><span class="s2">Trim prefix â†’ `name = MyInterface`</span>
<span class="s0">1. </span><span class="s2">validate suffix</span>
   <span class="s0">1. </span><span class="s2">config is not provided â†’ skip</span>
<span class="s0">1. </span><span class="s2">validate custom</span>
   <span class="s0">1. </span><span class="s2">config is not provided â†’ skip</span>
<span class="s0">1. </span><span class="s2">validate format</span>
   <span class="s0">1. </span><span class="s2">for each format...</span>
      <span class="s0">1. </span><span class="s2">`format = </span><span class="s1">'</span><span class="s2">UPPER_CASE'`</span>
         <span class="s0">1. </span><span class="s2">check format â†’ fail.</span>
            <span class="s0">- </span><span class="s2">Important to note that if you supply multiple formats - the name only needs to match </span><span class="s1">_</span><span class="s2">one</span><span class="s1">_ </span><span class="s2">of them</span><span class="s1">!</span>
      <span class="s0">1. </span><span class="s2">`format = </span><span class="s1">'</span><span class="s2">StrictPascalCase'`</span>
         <span class="s0">1. </span><span class="s2">check format â†’ success.</span>
<span class="s0">1. </span><span class="s1">**_</span><span class="s2">success</span><span class="s1">_**</span>

<span class="s2">Name</span><span class="s1">: </span><span class="s2">`IMyInterface`</span>
<span class="s2">Selector</span><span class="s1">:</span>

<span class="s0">```</span><span class="s3">json</span>
<span class="s4">{</span>
  <span class="s4">&quot;format&quot;: [&quot;StrictPascalCase&quot;],</span>
  <span class="s4">&quot;trailingUnderscore&quot;: &quot;allow&quot;,</span>
  <span class="s4">&quot;custom&quot;: {</span>
    <span class="s4">&quot;regex&quot;: &quot;^I[A-Z]&quot;,</span>
    <span class="s4">&quot;match&quot;: false</span>
  <span class="s4">}</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">1. </span><span class="s2">`name = IMyInterface`</span>
<span class="s0">1. </span><span class="s2">validate leading underscore</span>
   <span class="s0">1. </span><span class="s2">config is not provided â†’ skip</span>
<span class="s0">1. </span><span class="s2">validate trailing underscore</span>
   <span class="s0">1. </span><span class="s2">config is provided</span>
   <span class="s0">1. </span><span class="s2">check name â†’ pass</span>
   <span class="s0">1. </span><span class="s2">Trim underscore â†’ `name = IMyInterface`</span>
<span class="s0">1. </span><span class="s2">validate prefix</span>
   <span class="s0">1. </span><span class="s2">config is not provided â†’ skip</span>
<span class="s0">1. </span><span class="s2">validate suffix</span>
   <span class="s0">1. </span><span class="s2">config is not provided â†’ skip</span>
<span class="s0">1. </span><span class="s2">validate custom</span>
   <span class="s0">1. </span><span class="s2">config is provided</span>
   <span class="s0">1. </span><span class="s2">`regex = new RegExp</span><span class="s1">(&quot;</span><span class="s2">^I</span><span class="s1">[</span><span class="s2">A-Z</span><span class="s1">]&quot;)</span><span class="s2">`</span>
   <span class="s0">1. </span><span class="s2">`regex.test</span><span class="s1">(</span><span class="s2">name</span><span class="s1">) </span><span class="s2">=== custom.match`</span>
   <span class="s0">1. </span><span class="s1">**_</span><span class="s2">fail</span><span class="s1">_** </span><span class="s2">â†’ report and exit</span>

<span class="s0">### </span><span class="s2">What happens if I provide a `modifiers` to a Group Selector?</span>

<span class="s2">Some group selectors accept `modifiers`. For the most part these will work exactly the same as with individual selectors.</span>
<span class="s2">There is one exception to this in that a modifier might not apply to all individual selectors covered by a group selector.</span>

<span class="s2">For example - `memberLike` includes the `enumMember` selector, and it allows the `protected` modifier.</span>
<span class="s2">An `enumMember` can never ever be `protected`, which means that the following config will never match any `enumMember`</span><span class="s1">:</span>

<span class="s0">```</span><span class="s3">json</span>
<span class="s4">{</span>
  <span class="s4">&quot;selector&quot;: &quot;memberLike&quot;,</span>
  <span class="s4">&quot;modifiers&quot;: [&quot;protected&quot;]</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s2">To help with matching, members that cannot specify an accessibility will always have the `public` modifier. This means that the following config will always match any `enumMember`</span><span class="s1">:</span>

<span class="s0">```</span><span class="s3">json</span>
<span class="s4">{</span>
  <span class="s4">&quot;selector&quot;: &quot;memberLike&quot;,</span>
  <span class="s4">&quot;modifiers&quot;: [&quot;public&quot;]</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">## </span><span class="s2">Examples</span>

<span class="s0">### </span><span class="s2">Enforce that all variables, functions and properties follow are camelCase</span>

<span class="s0">```</span><span class="s3">json</span>
<span class="s4">{</span>
  <span class="s4">&quot;@typescript-eslint/naming-convention&quot;: [</span>
    <span class="s4">&quot;error&quot;,</span>
    <span class="s4">{ &quot;selector&quot;: &quot;variableLike&quot;, &quot;format&quot;: [&quot;camelCase&quot;] }</span>
  <span class="s4">]</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">Enforce that private members are prefixed with an underscore</span>

<span class="s0">```</span><span class="s3">json</span>
<span class="s4">{</span>
  <span class="s4">&quot;@typescript-eslint/naming-convention&quot;: [</span>
    <span class="s4">&quot;error&quot;,</span>
    <span class="s4">{</span>
      <span class="s4">&quot;selector&quot;: &quot;memberLike&quot;,</span>
      <span class="s4">&quot;modifiers&quot;: [&quot;private&quot;],</span>
      <span class="s4">&quot;format&quot;: [&quot;camelCase&quot;],</span>
      <span class="s4">&quot;leadingUnderscore&quot;: &quot;require&quot;</span>
    <span class="s4">}</span>
  <span class="s4">]</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">Enforce that boolean variables are prefixed with an allowed verb</span>

<span class="s1">**</span><span class="s2">Note</span><span class="s1">:** </span><span class="s2">As </span><span class="s1">[</span><span class="s2">documented above</span><span class="s1">](</span><span class="s2">#format-options</span><span class="s1">)</span><span class="s2">, the prefix is trimmed before format is validated, thus PascalCase must be used to allow variables such as `isEnabled`.</span>

<span class="s0">```</span><span class="s3">json</span>
<span class="s4">{</span>
  <span class="s4">&quot;@typescript-eslint/naming-convention&quot;: [</span>
    <span class="s4">&quot;error&quot;,</span>
    <span class="s4">{</span>
      <span class="s4">&quot;selector&quot;: &quot;variable&quot;,</span>
      <span class="s4">&quot;types&quot;: [&quot;boolean&quot;],</span>
      <span class="s4">&quot;format&quot;: [&quot;PascalCase&quot;],</span>
      <span class="s4">&quot;prefix&quot;: [&quot;is&quot;, &quot;should&quot;, &quot;has&quot;, &quot;can&quot;, &quot;did&quot;, &quot;will&quot;]</span>
    <span class="s4">}</span>
  <span class="s4">]</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">Enforce that all variables are either in camelCase or UPPER_CASE</span>

<span class="s0">```</span><span class="s3">json</span>
<span class="s4">{</span>
  <span class="s4">&quot;@typescript-eslint/naming-convention&quot;: [</span>
    <span class="s4">&quot;error&quot;,</span>
    <span class="s4">{</span>
      <span class="s4">&quot;selector&quot;: &quot;variable&quot;,</span>
      <span class="s4">&quot;format&quot;: [&quot;camelCase&quot;, &quot;UPPER_CASE&quot;]</span>
    <span class="s4">}</span>
  <span class="s4">]</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">Enforce that all const variables are in UPPER_CASE</span>

<span class="s0">```</span><span class="s3">json</span>
<span class="s4">{</span>
  <span class="s4">&quot;@typescript-eslint/naming-convention&quot;: [</span>
    <span class="s4">&quot;error&quot;,</span>
    <span class="s4">{</span>
      <span class="s4">&quot;selector&quot;: &quot;variable&quot;,</span>
      <span class="s4">&quot;modifiers&quot;: [&quot;const&quot;],</span>
      <span class="s4">&quot;format&quot;: [&quot;UPPER_CASE&quot;]</span>
    <span class="s4">}</span>
  <span class="s4">]</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">Enforce that type parameters </span><span class="s1">(</span><span class="s2">generics</span><span class="s1">) </span><span class="s2">are prefixed with `T`</span>

<span class="s2">This allows you to emulate the old `generic-type-naming` rule.</span>

<span class="s0">```</span><span class="s3">json</span>
<span class="s4">{</span>
  <span class="s4">&quot;@typescript-eslint/naming-convention&quot;: [</span>
    <span class="s4">&quot;error&quot;,</span>
    <span class="s4">{</span>
      <span class="s4">&quot;selector&quot;: &quot;typeParameter&quot;,</span>
      <span class="s4">&quot;format&quot;: [&quot;PascalCase&quot;],</span>
      <span class="s4">&quot;prefix&quot;: [&quot;T&quot;]</span>
    <span class="s4">}</span>
  <span class="s4">]</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">Enforce that interface names do not begin with an `I`</span>

<span class="s2">This allows you to emulate the old `interface-name-prefix` rule.</span>

<span class="s0">```</span><span class="s3">json</span>
<span class="s4">{</span>
  <span class="s4">&quot;@typescript-eslint/naming-convention&quot;: [</span>
    <span class="s4">&quot;error&quot;,</span>
    <span class="s4">{</span>
      <span class="s4">&quot;selector&quot;: &quot;interface&quot;,</span>
      <span class="s4">&quot;format&quot;: [&quot;PascalCase&quot;],</span>
      <span class="s4">&quot;custom&quot;: {</span>
        <span class="s4">&quot;regex&quot;: &quot;^I[A-Z]&quot;,</span>
        <span class="s4">&quot;match&quot;: false</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
  <span class="s4">]</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">Enforce that variable and function names are in camelCase</span>

<span class="s2">This allows you to lint multiple type with same pattern.</span>

<span class="s0">```</span><span class="s3">json</span>
<span class="s4">{</span>
  <span class="s4">&quot;@typescript-eslint/naming-convention&quot;: [</span>
    <span class="s4">&quot;error&quot;,</span>
    <span class="s4">{</span>
      <span class="s4">&quot;selector&quot;: [&quot;variable&quot;, &quot;function&quot;],</span>
      <span class="s4">&quot;format&quot;: [&quot;camelCase&quot;],</span>
      <span class="s4">&quot;leadingUnderscore&quot;: &quot;allow&quot;</span>
    <span class="s4">}</span>
  <span class="s4">]</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">Ignore properties that </span><span class="s1">**_</span><span class="s2">require</span><span class="s1">_** </span><span class="s2">quotes</span>

<span class="s2">Sometimes you have to use a quoted name that breaks the convention </span><span class="s1">(</span><span class="s2">for example, HTTP headers</span><span class="s1">)</span><span class="s2">.</span>
<span class="s2">If this is a common thing in your codebase, then you have a few options.</span>

<span class="s2">If you simply want to allow all property names that require quotes, you can use the `requiresQuotes` modifier to match any property name that </span><span class="s1">_</span><span class="s2">requires</span><span class="s1">_ </span><span class="s2">quoting, and use `format</span><span class="s1">: </span><span class="s2">null` to ignore the name.</span>

<span class="s0">```</span><span class="s3">jsonc</span>
<span class="s4">{</span>
  <span class="s4">&quot;@typescript-eslint/naming-convention&quot;: [</span>
    <span class="s4">&quot;error&quot;,</span>
    <span class="s4">{</span>
      <span class="s4">&quot;selector&quot;: [</span>
        <span class="s4">&quot;classProperty&quot;,</span>
        <span class="s4">&quot;objectLiteralProperty&quot;,</span>
        <span class="s4">&quot;typeProperty&quot;,</span>
        <span class="s4">&quot;classMethod&quot;,</span>
        <span class="s4">&quot;objectLiteralMethod&quot;,</span>
        <span class="s4">&quot;typeMethod&quot;,</span>
        <span class="s4">&quot;accessor&quot;,</span>
        <span class="s4">&quot;enumMember&quot;</span>
      <span class="s4">],</span>
      <span class="s4">&quot;format&quot;: null,</span>
      <span class="s4">&quot;modifiers&quot;: [&quot;requiresQuotes&quot;]</span>
    <span class="s4">}</span>
  <span class="s4">]</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s2">If you have a small and known list of exceptions, you can use the `filter` option to ignore these specific names only</span><span class="s1">:</span>

<span class="s0">```</span><span class="s3">jsonc</span>
<span class="s4">{</span>
  <span class="s4">&quot;@typescript-eslint/naming-convention&quot;: [</span>
    <span class="s4">&quot;error&quot;,</span>
    <span class="s4">{</span>
      <span class="s4">&quot;selector&quot;: &quot;property&quot;,</span>
      <span class="s4">&quot;format&quot;: [&quot;strictCamelCase&quot;],</span>
      <span class="s4">&quot;filter&quot;: {</span>
        <span class="s4">// you can expand this regex to add more allowed names</span>
        <span class="s4">&quot;regex&quot;: &quot;^(Property-Name-One|Property-Name-Two)$&quot;,</span>
        <span class="s4">&quot;match&quot;: false</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
  <span class="s4">]</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s2">You can use the `filter` option to ignore names with specific characters</span><span class="s1">:</span>

<span class="s0">```</span><span class="s3">jsonc</span>
<span class="s4">{</span>
  <span class="s4">&quot;@typescript-eslint/naming-convention&quot;: [</span>
    <span class="s4">&quot;error&quot;,</span>
    <span class="s4">{</span>
      <span class="s4">&quot;selector&quot;: &quot;property&quot;,</span>
      <span class="s4">&quot;format&quot;: [&quot;strictCamelCase&quot;],</span>
      <span class="s4">&quot;filter&quot;: {</span>
        <span class="s4">// you can expand this regex as you find more cases that require quoting that you want to allow</span>
        <span class="s4">&quot;regex&quot;: &quot;[- ]&quot;,</span>
        <span class="s4">&quot;match&quot;: false</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
  <span class="s4">]</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s2">Note that there is no way to ignore any name that is quoted - only names that are required to be quoted.</span>
<span class="s2">This is intentional - adding quotes around a name is not an escape hatch for proper naming.</span>
<span class="s2">If you want an escape hatch for a specific name - you should can use an </span><span class="s1">[</span><span class="s2">`eslint-disable` comment</span><span class="s1">](https://eslint.org/docs/user-guide/configuring#disabling-rules-with-inline-comments)</span><span class="s2">.</span>

<span class="s0">### </span><span class="s2">Ignore destructured names</span>

<span class="s2">Sometimes you might want to allow destructured properties to retain their original name, even if it breaks your naming convention.</span>

<span class="s2">You can use the `destructured` modifier to match these names, and explicitly set `format</span><span class="s1">: </span><span class="s2">null` to apply no formatting</span><span class="s1">:</span>

<span class="s0">```</span><span class="s3">jsonc</span>
<span class="s4">{</span>
  <span class="s4">&quot;@typescript-eslint/naming-convention&quot;: [</span>
    <span class="s4">&quot;error&quot;,</span>
    <span class="s4">{</span>
      <span class="s4">&quot;selector&quot;: &quot;variable&quot;,</span>
      <span class="s4">&quot;modifiers&quot;: [&quot;destructured&quot;],</span>
      <span class="s4">&quot;format&quot;: null</span>
    <span class="s4">}</span>
  <span class="s4">]</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">Enforce the codebase follows ESLint's `camelcase` conventions</span>

<span class="s0">```</span><span class="s3">json</span>
<span class="s4">{</span>
  <span class="s4">&quot;camelcase&quot;: &quot;off&quot;,</span>
  <span class="s4">&quot;@typescript-eslint/naming-convention&quot;: [</span>
    <span class="s4">&quot;error&quot;,</span>
    <span class="s4">{</span>
      <span class="s4">&quot;selector&quot;: &quot;default&quot;,</span>
      <span class="s4">&quot;format&quot;: [&quot;camelCase&quot;]</span>
    <span class="s4">},</span>

    <span class="s4">{</span>
      <span class="s4">&quot;selector&quot;: &quot;variable&quot;,</span>
      <span class="s4">&quot;format&quot;: [&quot;camelCase&quot;, &quot;UPPER_CASE&quot;]</span>
    <span class="s4">},</span>
    <span class="s4">{</span>
      <span class="s4">&quot;selector&quot;: &quot;parameter&quot;,</span>
      <span class="s4">&quot;format&quot;: [&quot;camelCase&quot;],</span>
      <span class="s4">&quot;leadingUnderscore&quot;: &quot;allow&quot;</span>
    <span class="s4">},</span>

    <span class="s4">{</span>
      <span class="s4">&quot;selector&quot;: &quot;memberLike&quot;,</span>
      <span class="s4">&quot;modifiers&quot;: [&quot;private&quot;],</span>
      <span class="s4">&quot;format&quot;: [&quot;camelCase&quot;],</span>
      <span class="s4">&quot;leadingUnderscore&quot;: &quot;require&quot;</span>
    <span class="s4">},</span>

    <span class="s4">{</span>
      <span class="s4">&quot;selector&quot;: &quot;typeLike&quot;,</span>
      <span class="s4">&quot;format&quot;: [&quot;PascalCase&quot;]</span>
    <span class="s4">}</span>
  <span class="s4">]</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">## </span><span class="s2">When Not To Use It</span>

<span class="s2">If you do not want to enforce naming conventions for anything.</span>
</pre>
</body>
</html>
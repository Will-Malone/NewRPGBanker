<html>
<head>
<title>runTest.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
runTest.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">'__esModule'</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= runTest;</span>
<span class="s2">function </span><span class="s1">_chalk() {</span>
  <span class="s1">const data = _interopRequireDefault(require(</span><span class="s0">'chalk'</span><span class="s1">));</span>
  <span class="s1">_chalk = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">fs() {</span>
  <span class="s1">const data = _interopRequireWildcard(require(</span><span class="s0">'graceful-fs'</span><span class="s1">));</span>
  <span class="s1">fs = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_sourceMapSupport() {</span>
  <span class="s1">const data = _interopRequireDefault(require(</span><span class="s0">'source-map-support'</span><span class="s1">));</span>
  <span class="s1">_sourceMapSupport = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_console() {</span>
  <span class="s1">const data = require(</span><span class="s0">'@jest/console'</span><span class="s1">);</span>
  <span class="s1">_console = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_transform() {</span>
  <span class="s1">const data = require(</span><span class="s0">'@jest/transform'</span><span class="s1">);</span>
  <span class="s1">_transform = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">docblock() {</span>
  <span class="s1">const data = _interopRequireWildcard(require(</span><span class="s0">'jest-docblock'</span><span class="s1">));</span>
  <span class="s1">docblock = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestLeakDetector() {</span>
  <span class="s1">const data = _interopRequireDefault(require(</span><span class="s0">'jest-leak-detector'</span><span class="s1">));</span>
  <span class="s1">_jestLeakDetector = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestMessageUtil() {</span>
  <span class="s1">const data = require(</span><span class="s0">'jest-message-util'</span><span class="s1">);</span>
  <span class="s1">_jestMessageUtil = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestResolve() {</span>
  <span class="s1">const data = require(</span><span class="s0">'jest-resolve'</span><span class="s1">);</span>
  <span class="s1">_jestResolve = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestUtil() {</span>
  <span class="s1">const data = require(</span><span class="s0">'jest-util'</span><span class="s1">);</span>
  <span class="s1">_jestUtil = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">'function'</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
  <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
  <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function </span><span class="s1">(nodeInterop) {</span>
    <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
  <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interopRequireWildcard(obj, nodeInterop) {</span>
  <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
    <span class="s2">return </span><span class="s1">obj;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">'function'</span><span class="s1">)) {</span>
    <span class="s2">return </span><span class="s1">{</span><span class="s2">default</span><span class="s1">: obj};</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
  <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
    <span class="s2">return </span><span class="s1">cache.get(obj);</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">newObj = {};</span>
  <span class="s2">var </span><span class="s1">hasPropertyDescriptor =</span>
    <span class="s1">Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj) {</span>
    <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">'default' </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
      <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor</span>
        <span class="s1">? Object.getOwnPropertyDescriptor(obj, key)</span>
        <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
        <span class="s1">Object.defineProperty(newObj, key, desc);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">newObj[key] = obj[key];</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">newObj.</span><span class="s2">default </span><span class="s1">= obj;</span>
  <span class="s2">if </span><span class="s1">(cache) {</span>
    <span class="s1">cache.set(obj, newObj);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interopRequireDefault(obj) {</span>
  <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span><span class="s2">default</span><span class="s1">: obj};</span>
<span class="s1">}</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 */</span>

<span class="s2">function </span><span class="s1">freezeConsole(testConsole, config) {</span>
  <span class="s3">// @ts-expect-error: `_log` is `private` - we should figure out some proper API here</span>
  <span class="s1">testConsole._log = </span><span class="s2">function </span><span class="s1">fakeConsolePush(_type, message) {</span>
    <span class="s1">const error = </span><span class="s2">new </span><span class="s1">(_jestUtil().ErrorWithStack)(</span>
      <span class="s1">`${_chalk().</span><span class="s2">default</span><span class="s1">.red(</span>
        <span class="s1">`${_chalk().</span><span class="s2">default</span><span class="s1">.bold(</span>
          <span class="s0">'Cannot log after tests are done.'</span>
        <span class="s1">)} Did you forget to wait </span><span class="s2">for </span><span class="s1">something async </span><span class="s2">in </span><span class="s1">your test?`</span>
      <span class="s1">)}\nAttempted to log </span><span class="s0">&quot;${message}&quot;</span><span class="s1">.`,</span>
      <span class="s1">fakeConsolePush</span>
    <span class="s1">);</span>
    <span class="s1">const formattedError = (</span><span class="s4">0</span><span class="s1">, _jestMessageUtil().formatExecError)(</span>
      <span class="s1">error,</span>
      <span class="s1">config,</span>
      <span class="s1">{</span>
        <span class="s1">noStackTrace: </span><span class="s2">false</span>
      <span class="s1">},</span>
      <span class="s1">undefined,</span>
      <span class="s2">true</span>
    <span class="s1">);</span>
    <span class="s1">process.stderr.write(`\n${formattedError}\n`);</span>
    <span class="s1">process.exitCode = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">// Keeping the core of &quot;runTest&quot; as a separate function (as &quot;runTestInternal&quot;)</span>
<span class="s3">// is key to be able to detect memory leaks. Since all variables are local to</span>
<span class="s3">// the function, when &quot;runTestInternal&quot; finishes its execution, they can all be</span>
<span class="s3">// freed, UNLESS something else is leaking them (and that's why we can detect</span>
<span class="s3">// the leak!).</span>
<span class="s3">//</span>
<span class="s3">// If we had all the code in a single function, we should manually nullify all</span>
<span class="s3">// references to verify if there is a leak, which is not maintainable and error</span>
<span class="s3">// prone. That's why &quot;runTestInternal&quot; CANNOT be inlined inside &quot;runTest&quot;.</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">runTestInternal(</span>
  <span class="s1">path,</span>
  <span class="s1">globalConfig,</span>
  <span class="s1">projectConfig,</span>
  <span class="s1">resolver,</span>
  <span class="s1">context,</span>
  <span class="s1">sendMessageToJest</span>
<span class="s1">) {</span>
  <span class="s1">const testSource = fs().readFileSync(path, </span><span class="s0">'utf8'</span><span class="s1">);</span>
  <span class="s1">const docblockPragmas = docblock().parse(docblock().extract(testSource));</span>
  <span class="s1">const customEnvironment = docblockPragmas[</span><span class="s0">'jest-environment'</span><span class="s1">];</span>
  <span class="s1">let testEnvironment = projectConfig.testEnvironment;</span>
  <span class="s2">if </span><span class="s1">(customEnvironment) {</span>
    <span class="s2">if </span><span class="s1">(Array.isArray(customEnvironment)) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span>
        <span class="s1">`You can only define a single test environment through docblocks, got </span><span class="s0">&quot;${customEnvironment.join(</span>
          <span class="s0">', '</span>
        <span class="s1">)}</span><span class="s0">&quot;`</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">testEnvironment = (</span><span class="s4">0</span><span class="s1">, _jestResolve().resolveTestEnvironment)({</span>
      <span class="s1">...projectConfig,</span>
      <span class="s1">requireResolveFunction: require.resolve,</span>
      <span class="s1">testEnvironment: customEnvironment</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
  <span class="s1">const cacheFS = </span><span class="s2">new </span><span class="s1">Map([[path, testSource]]);</span>
  <span class="s1">const transformer = await (</span><span class="s4">0</span><span class="s1">, _transform().createScriptTransformer)(</span>
    <span class="s1">projectConfig,</span>
    <span class="s1">cacheFS</span>
  <span class="s1">);</span>
  <span class="s1">const TestEnvironment = await transformer.requireAndTranspileModule(</span>
    <span class="s1">testEnvironment</span>
  <span class="s1">);</span>
  <span class="s1">const testFramework = await transformer.requireAndTranspileModule(</span>
    <span class="s1">process.env.JEST_JASMINE === </span><span class="s0">'1'</span>
      <span class="s1">? require.resolve(</span><span class="s0">'jest-jasmine2'</span><span class="s1">)</span>
      <span class="s1">: projectConfig.testRunner</span>
  <span class="s1">);</span>
  <span class="s1">const Runtime = (</span><span class="s4">0</span><span class="s1">, _jestUtil().interopRequireDefault)(</span>
    <span class="s1">projectConfig.runtime</span>
      <span class="s1">? require(projectConfig.runtime)</span>
      <span class="s1">: require(</span><span class="s0">'jest-runtime'</span><span class="s1">)</span>
  <span class="s1">).</span><span class="s2">default</span><span class="s1">;</span>
  <span class="s1">const consoleOut = globalConfig.useStderr ? process.stderr : process.stdout;</span>
  <span class="s1">const consoleFormatter = (type, message) =&gt;</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _console().getConsoleOutput)(</span>
      <span class="s3">// 4 = the console call is buried 4 stack frames deep</span>
      <span class="s1">_console().BufferedConsole.write([], type, message, </span><span class="s4">4</span><span class="s1">),</span>
      <span class="s1">projectConfig,</span>
      <span class="s1">globalConfig</span>
    <span class="s1">);</span>
  <span class="s1">let testConsole;</span>
  <span class="s2">if </span><span class="s1">(globalConfig.silent) {</span>
    <span class="s1">testConsole = </span><span class="s2">new </span><span class="s1">(_console().NullConsole)(</span>
      <span class="s1">consoleOut,</span>
      <span class="s1">consoleOut,</span>
      <span class="s1">consoleFormatter</span>
    <span class="s1">);</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(globalConfig.verbose) {</span>
    <span class="s1">testConsole = </span><span class="s2">new </span><span class="s1">(_console().CustomConsole)(</span>
      <span class="s1">consoleOut,</span>
      <span class="s1">consoleOut,</span>
      <span class="s1">consoleFormatter</span>
    <span class="s1">);</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">testConsole = </span><span class="s2">new </span><span class="s1">(_console().BufferedConsole)();</span>
  <span class="s1">}</span>
  <span class="s1">let extraTestEnvironmentOptions;</span>
  <span class="s1">const docblockEnvironmentOptions =</span>
    <span class="s1">docblockPragmas[</span><span class="s0">'jest-environment-options'</span><span class="s1">];</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">docblockEnvironmentOptions === </span><span class="s0">'string'</span><span class="s1">) {</span>
    <span class="s1">extraTestEnvironmentOptions = JSON.parse(docblockEnvironmentOptions);</span>
  <span class="s1">}</span>
  <span class="s1">const environment = </span><span class="s2">new </span><span class="s1">TestEnvironment(</span>
    <span class="s1">{</span>
      <span class="s1">globalConfig,</span>
      <span class="s1">projectConfig: extraTestEnvironmentOptions</span>
        <span class="s1">? {</span>
            <span class="s1">...projectConfig,</span>
            <span class="s1">testEnvironmentOptions: {</span>
              <span class="s1">...projectConfig.testEnvironmentOptions,</span>
              <span class="s1">...extraTestEnvironmentOptions</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">: projectConfig</span>
    <span class="s1">},</span>
    <span class="s1">{</span>
      <span class="s1">console: testConsole,</span>
      <span class="s1">docblockPragmas,</span>
      <span class="s1">testPath: path</span>
    <span class="s1">}</span>
  <span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">environment.getVmContext !== </span><span class="s0">'function'</span><span class="s1">) {</span>
    <span class="s1">console.error(</span>
      <span class="s1">`Test environment found at </span><span class="s0">&quot;${testEnvironment}&quot; </span><span class="s1">does not export a </span><span class="s0">&quot;getVmContext&quot; </span><span class="s1">method, which is mandatory from Jest </span><span class="s4">27</span><span class="s1">. This method is a replacement </span><span class="s2">for </span><span class="s0">&quot;runScript&quot;</span><span class="s1">.`</span>
    <span class="s1">);</span>
    <span class="s1">process.exit(</span><span class="s4">1</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">const leakDetector = projectConfig.detectLeaks</span>
    <span class="s1">? </span><span class="s2">new </span><span class="s1">(_jestLeakDetector().</span><span class="s2">default</span><span class="s1">)(environment)</span>
    <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">(</span><span class="s4">0</span><span class="s1">, _jestUtil().setGlobal)(environment.global, </span><span class="s0">'console'</span><span class="s1">, testConsole);</span>
  <span class="s1">const runtime = </span><span class="s2">new </span><span class="s1">Runtime(</span>
    <span class="s1">projectConfig,</span>
    <span class="s1">environment,</span>
    <span class="s1">resolver,</span>
    <span class="s1">transformer,</span>
    <span class="s1">cacheFS,</span>
    <span class="s1">{</span>
      <span class="s1">changedFiles: context.changedFiles,</span>
      <span class="s1">collectCoverage: globalConfig.collectCoverage,</span>
      <span class="s1">collectCoverageFrom: globalConfig.collectCoverageFrom,</span>
      <span class="s1">coverageProvider: globalConfig.coverageProvider,</span>
      <span class="s1">sourcesRelatedToTestsInChangedFiles:</span>
        <span class="s1">context.sourcesRelatedToTestsInChangedFiles</span>
    <span class="s1">},</span>
    <span class="s1">path,</span>
    <span class="s1">globalConfig</span>
  <span class="s1">);</span>
  <span class="s1">let isTornDown = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">const tearDownEnv = async () =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!isTornDown) {</span>
      <span class="s1">runtime.teardown();</span>
      <span class="s1">await environment.teardown();</span>
      <span class="s1">isTornDown = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s1">const start = Date.now();</span>
  <span class="s2">for </span><span class="s1">(const path of projectConfig.setupFiles) {</span>
    <span class="s1">const esm = runtime.unstable_shouldLoadAsEsm(path);</span>
    <span class="s2">if </span><span class="s1">(esm) {</span>
      <span class="s1">await runtime.unstable_importModule(path);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">const setupFile = runtime.requireModule(path);</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">setupFile === </span><span class="s0">'function'</span><span class="s1">) {</span>
        <span class="s1">await setupFile();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">const sourcemapOptions = {</span>
    <span class="s1">environment: </span><span class="s0">'node'</span><span class="s1">,</span>
    <span class="s1">handleUncaughtExceptions: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">retrieveSourceMap: source =&gt; {</span>
      <span class="s1">const sourceMapSource = runtime.getSourceMaps()?.get(source);</span>
      <span class="s2">if </span><span class="s1">(sourceMapSource) {</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">map: JSON.parse(fs().readFileSync(sourceMapSource, </span><span class="s0">'utf8'</span><span class="s1">)),</span>
            <span class="s1">url: source</span>
          <span class="s1">};</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">{}</span>
      <span class="s1">}</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">// For tests</span>
  <span class="s1">runtime</span>
    <span class="s1">.requireInternalModule(require.resolve(</span><span class="s0">'source-map-support'</span><span class="s1">))</span>
    <span class="s1">.install(sourcemapOptions);</span>

  <span class="s3">// For runtime errors</span>
  <span class="s1">_sourceMapSupport().</span><span class="s2">default</span><span class="s1">.install(sourcemapOptions);</span>
  <span class="s2">if </span><span class="s1">(</span>
    <span class="s1">environment.global &amp;&amp;</span>
    <span class="s1">environment.global.process &amp;&amp;</span>
    <span class="s1">environment.global.process.exit</span>
  <span class="s1">) {</span>
    <span class="s1">const realExit = environment.global.process.exit;</span>
    <span class="s1">environment.global.process.exit = </span><span class="s2">function </span><span class="s1">exit(...args) {</span>
      <span class="s1">const error = </span><span class="s2">new </span><span class="s1">(_jestUtil().ErrorWithStack)(</span>
        <span class="s1">`process.exit called </span><span class="s2">with </span><span class="s0">&quot;${args.join(', ')}&quot;</span><span class="s1">`,</span>
        <span class="s1">exit</span>
      <span class="s1">);</span>
      <span class="s1">const formattedError = (</span><span class="s4">0</span><span class="s1">, _jestMessageUtil().formatExecError)(</span>
        <span class="s1">error,</span>
        <span class="s1">projectConfig,</span>
        <span class="s1">{</span>
          <span class="s1">noStackTrace: </span><span class="s2">false</span>
        <span class="s1">},</span>
        <span class="s1">undefined,</span>
        <span class="s2">true</span>
      <span class="s1">);</span>
      <span class="s1">process.stderr.write(formattedError);</span>
      <span class="s2">return </span><span class="s1">realExit(...args);</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">// if we don't have `getVmContext` on the env skip coverage</span>
  <span class="s1">const collectV8Coverage =</span>
    <span class="s1">globalConfig.collectCoverage &amp;&amp;</span>
    <span class="s1">globalConfig.coverageProvider === </span><span class="s0">'v8' </span><span class="s1">&amp;&amp;</span>
    <span class="s2">typeof </span><span class="s1">environment.getVmContext === </span><span class="s0">'function'</span><span class="s1">;</span>

  <span class="s3">// Node's error-message stack size is limited at 10, but it's pretty useful</span>
  <span class="s3">// to see more than that when a test fails.</span>
  <span class="s1">Error.stackTraceLimit = </span><span class="s4">100</span><span class="s1">;</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s1">await environment.setup();</span>
    <span class="s1">let result;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(collectV8Coverage) {</span>
        <span class="s1">await runtime.collectV8Coverage();</span>
      <span class="s1">}</span>
      <span class="s1">result = await testFramework(</span>
        <span class="s1">globalConfig,</span>
        <span class="s1">projectConfig,</span>
        <span class="s1">environment,</span>
        <span class="s1">runtime,</span>
        <span class="s1">path,</span>
        <span class="s1">sendMessageToJest</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
      <span class="s3">// Access stack before uninstalling sourcemaps</span>
      <span class="s1">err.stack;</span>
      <span class="s2">throw </span><span class="s1">err;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(collectV8Coverage) {</span>
        <span class="s1">await runtime.stopCollectingV8Coverage();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">freezeConsole(testConsole, projectConfig);</span>
    <span class="s1">const testCount =</span>
      <span class="s1">result.numPassingTests +</span>
      <span class="s1">result.numFailingTests +</span>
      <span class="s1">result.numPendingTests +</span>
      <span class="s1">result.numTodoTests;</span>
    <span class="s1">const end = Date.now();</span>
    <span class="s1">const testRuntime = end - start;</span>
    <span class="s1">result.perfStats = {</span>
      <span class="s1">end,</span>
      <span class="s1">runtime: testRuntime,</span>
      <span class="s1">slow: testRuntime / </span><span class="s4">1000 </span><span class="s1">&gt; projectConfig.slowTestThreshold,</span>
      <span class="s1">start</span>
    <span class="s1">};</span>
    <span class="s1">result.testFilePath = path;</span>
    <span class="s1">result.console = testConsole.getBuffer();</span>
    <span class="s1">result.skipped = testCount === result.numPendingTests;</span>
    <span class="s1">result.displayName = projectConfig.displayName;</span>
    <span class="s1">const coverage = runtime.getAllCoverageInfoCopy();</span>
    <span class="s2">if </span><span class="s1">(coverage) {</span>
      <span class="s1">const coverageKeys = Object.keys(coverage);</span>
      <span class="s2">if </span><span class="s1">(coverageKeys.length) {</span>
        <span class="s1">result.coverage = coverage;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(collectV8Coverage) {</span>
      <span class="s1">const v8Coverage = runtime.getAllV8CoverageInfoCopy();</span>
      <span class="s2">if </span><span class="s1">(v8Coverage &amp;&amp; v8Coverage.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">result.v8Coverage = v8Coverage;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(globalConfig.logHeapUsage) {</span>
      <span class="s3">// @ts-expect-error - doesn't exist on globalThis</span>
      <span class="s1">globalThis.gc?.();</span>
      <span class="s1">result.memoryUsage = process.memoryUsage().heapUsed;</span>
    <span class="s1">}</span>
    <span class="s1">await tearDownEnv();</span>

    <span class="s3">// Delay the resolution to allow log messages to be output.</span>
    <span class="s2">return </span><span class="s1">await </span><span class="s2">new </span><span class="s1">Promise(resolve =&gt; {</span>
      <span class="s1">setImmediate(() =&gt;</span>
        <span class="s1">resolve({</span>
          <span class="s1">leakDetector,</span>
          <span class="s1">result</span>
        <span class="s1">})</span>
      <span class="s1">);</span>
    <span class="s1">});</span>
  <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
    <span class="s1">await tearDownEnv();</span>
    <span class="s1">_sourceMapSupport().</span><span class="s2">default</span><span class="s1">.resetRetrieveHandlers();</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">runTest(</span>
  <span class="s1">path,</span>
  <span class="s1">globalConfig,</span>
  <span class="s1">config,</span>
  <span class="s1">resolver,</span>
  <span class="s1">context,</span>
  <span class="s1">sendMessageToJest</span>
<span class="s1">) {</span>
  <span class="s1">const {leakDetector, result} = await runTestInternal(</span>
    <span class="s1">path,</span>
    <span class="s1">globalConfig,</span>
    <span class="s1">config,</span>
    <span class="s1">resolver,</span>
    <span class="s1">context,</span>
    <span class="s1">sendMessageToJest</span>
  <span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(leakDetector) {</span>
    <span class="s3">// We wanna allow a tiny but time to pass to allow last-minute cleanup</span>
    <span class="s1">await </span><span class="s2">new </span><span class="s1">Promise(resolve =&gt; setTimeout(resolve, </span><span class="s4">100</span><span class="s1">));</span>

    <span class="s3">// Resolve leak detector, outside the &quot;runTestInternal&quot; closure.</span>
    <span class="s1">result.leaks = await leakDetector.isLeaking();</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">result.leaks = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>
</pre>
</body>
</html>
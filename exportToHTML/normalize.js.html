<html>
<head>
<title>normalize.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
normalize.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">'__esModule'</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= normalize;</span>
<span class="s2">function </span><span class="s1">_crypto() {</span>
  <span class="s1">const data = require(</span><span class="s0">'crypto'</span><span class="s1">);</span>
  <span class="s1">_crypto = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_os() {</span>
  <span class="s1">const data = require(</span><span class="s0">'os'</span><span class="s1">);</span>
  <span class="s1">_os = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">path() {</span>
  <span class="s1">const data = _interopRequireWildcard(require(</span><span class="s0">'path'</span><span class="s1">));</span>
  <span class="s1">path = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_chalk() {</span>
  <span class="s1">const data = _interopRequireDefault(require(</span><span class="s0">'chalk'</span><span class="s1">));</span>
  <span class="s1">_chalk = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_deepmerge() {</span>
  <span class="s1">const data = _interopRequireDefault(require(</span><span class="s0">'deepmerge'</span><span class="s1">));</span>
  <span class="s1">_deepmerge = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_glob() {</span>
  <span class="s1">const data = require(</span><span class="s0">'glob'</span><span class="s1">);</span>
  <span class="s1">_glob = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_gracefulFs() {</span>
  <span class="s1">const data = require(</span><span class="s0">'graceful-fs'</span><span class="s1">);</span>
  <span class="s1">_gracefulFs = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_micromatch() {</span>
  <span class="s1">const data = _interopRequireDefault(require(</span><span class="s0">'micromatch'</span><span class="s1">));</span>
  <span class="s1">_micromatch = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestRegexUtil() {</span>
  <span class="s1">const data = require(</span><span class="s0">'jest-regex-util'</span><span class="s1">);</span>
  <span class="s1">_jestRegexUtil = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestResolve() {</span>
  <span class="s1">const data = _interopRequireWildcard(require(</span><span class="s0">'jest-resolve'</span><span class="s1">));</span>
  <span class="s1">_jestResolve = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestUtil() {</span>
  <span class="s1">const data = require(</span><span class="s0">'jest-util'</span><span class="s1">);</span>
  <span class="s1">_jestUtil = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestValidate() {</span>
  <span class="s1">const data = require(</span><span class="s0">'jest-validate'</span><span class="s1">);</span>
  <span class="s1">_jestValidate = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">_Defaults = _interopRequireDefault(require(</span><span class="s0">'./Defaults'</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_Deprecated = _interopRequireDefault(require(</span><span class="s0">'./Deprecated'</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_ReporterValidationErrors = require(</span><span class="s0">'./ReporterValidationErrors'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_ValidConfig = require(</span><span class="s0">'./ValidConfig'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_color = require(</span><span class="s0">'./color'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_constants = require(</span><span class="s0">'./constants'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_getMaxWorkers = _interopRequireDefault(require(</span><span class="s0">'./getMaxWorkers'</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_parseShardPair = require(</span><span class="s0">'./parseShardPair'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_setFromArgv = _interopRequireDefault(require(</span><span class="s0">'./setFromArgv'</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_stringToBytes = _interopRequireDefault(require(</span><span class="s0">'./stringToBytes'</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_utils = require(</span><span class="s0">'./utils'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_validatePattern = _interopRequireDefault(require(</span><span class="s0">'./validatePattern'</span><span class="s1">));</span>
<span class="s2">function </span><span class="s1">_interopRequireDefault(obj) {</span>
  <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span><span class="s2">default</span><span class="s1">: obj};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">'function'</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
  <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
  <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function </span><span class="s1">(nodeInterop) {</span>
    <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
  <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interopRequireWildcard(obj, nodeInterop) {</span>
  <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
    <span class="s2">return </span><span class="s1">obj;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">'function'</span><span class="s1">)) {</span>
    <span class="s2">return </span><span class="s1">{</span><span class="s2">default</span><span class="s1">: obj};</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
  <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
    <span class="s2">return </span><span class="s1">cache.get(obj);</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">newObj = {};</span>
  <span class="s2">var </span><span class="s1">hasPropertyDescriptor =</span>
    <span class="s1">Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj) {</span>
    <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">'default' </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
      <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor</span>
        <span class="s1">? Object.getOwnPropertyDescriptor(obj, key)</span>
        <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
        <span class="s1">Object.defineProperty(newObj, key, desc);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">newObj[key] = obj[key];</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">newObj.</span><span class="s2">default </span><span class="s1">= obj;</span>
  <span class="s2">if </span><span class="s1">(cache) {</span>
    <span class="s1">cache.set(obj, newObj);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s1">const ERROR = `${_utils.BULLET}Validation Error`;</span>
<span class="s1">const PRESET_EXTENSIONS = [</span><span class="s0">'.json'</span><span class="s1">, </span><span class="s0">'.js'</span><span class="s1">, </span><span class="s0">'.cjs'</span><span class="s1">, </span><span class="s0">'.mjs'</span><span class="s1">];</span>
<span class="s1">const PRESET_NAME = </span><span class="s0">'jest-preset'</span><span class="s1">;</span>
<span class="s1">const createConfigError = message =&gt;</span>
  <span class="s2">new </span><span class="s1">(_jestValidate().ValidationError)(</span>
    <span class="s1">ERROR,</span>
    <span class="s1">message,</span>
    <span class="s1">_utils.DOCUMENTATION_NOTE</span>
  <span class="s1">);</span>
<span class="s2">function </span><span class="s1">verifyDirectoryExists(path, key) {</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s1">const rootStat = (</span><span class="s4">0</span><span class="s1">, _gracefulFs().statSync)(path);</span>
    <span class="s2">if </span><span class="s1">(!rootStat.isDirectory()) {</span>
      <span class="s2">throw </span><span class="s1">createConfigError(</span>
        <span class="s1">`  ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(path)} </span><span class="s2">in </span><span class="s1">the ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(</span>
          <span class="s1">key</span>
        <span class="s1">)} option is not a directory.`</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
    <span class="s2">if </span><span class="s1">(err </span><span class="s2">instanceof </span><span class="s1">_jestValidate().ValidationError) {</span>
      <span class="s2">throw </span><span class="s1">err;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(err.code === </span><span class="s0">'ENOENT'</span><span class="s1">) {</span>
      <span class="s2">throw </span><span class="s1">createConfigError(</span>
        <span class="s1">`  Directory ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(</span>
          <span class="s1">path</span>
        <span class="s1">)} </span><span class="s2">in </span><span class="s1">the ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(key)} option was not found.`</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">// Not sure in which cases `statSync` can throw, so let's just show the underlying error to the user</span>
    <span class="s2">throw </span><span class="s1">createConfigError(</span>
      <span class="s1">`  Got an error trying to find ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(</span>
        <span class="s1">path</span>
      <span class="s1">)} </span><span class="s2">in </span><span class="s1">the ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(key)} option.\n\n  Error was: ${</span>
        <span class="s1">err.message</span>
      <span class="s1">}`</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">const mergeOptionWithPreset = (options, preset, optionName) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(options[optionName] &amp;&amp; preset[optionName]) {</span>
    <span class="s1">options[optionName] = {</span>
      <span class="s1">...options[optionName],</span>
      <span class="s1">...preset[optionName],</span>
      <span class="s1">...options[optionName]</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s1">const mergeGlobalsWithPreset = (options, preset) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(options.globals &amp;&amp; preset.globals) {</span>
    <span class="s1">options.globals = (</span><span class="s4">0</span><span class="s1">, _deepmerge().</span><span class="s2">default</span><span class="s1">)(</span>
      <span class="s1">preset.globals,</span>
      <span class="s1">options.globals</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s1">const setupPreset = async (options, optionsPreset) =&gt; {</span>
  <span class="s1">let preset;</span>
  <span class="s1">const presetPath = (</span><span class="s4">0</span><span class="s1">, _utils.replaceRootDirInPath)(</span>
    <span class="s1">options.rootDir,</span>
    <span class="s1">optionsPreset</span>
  <span class="s1">);</span>
  <span class="s1">const presetModule = _jestResolve().</span><span class="s2">default</span><span class="s1">.findNodeModule(</span>
    <span class="s1">presetPath.startsWith(</span><span class="s0">'.'</span><span class="s1">)</span>
      <span class="s1">? presetPath</span>
      <span class="s1">: path().join(presetPath, PRESET_NAME),</span>
    <span class="s1">{</span>
      <span class="s1">basedir: options.rootDir,</span>
      <span class="s1">extensions: PRESET_EXTENSIONS</span>
    <span class="s1">}</span>
  <span class="s1">);</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!presetModule) {</span>
      <span class="s2">throw new </span><span class="s1">Error(`Cannot find module </span><span class="s0">'${presetPath}'</span><span class="s1">`);</span>
    <span class="s1">}</span>

    <span class="s3">// Force re-evaluation to support multiple projects</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">delete </span><span class="s1">require.cache[require.resolve(presetModule)];</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">{}</span>
    <span class="s1">preset = await (</span><span class="s4">0</span><span class="s1">, _jestUtil().requireOrImportModule)(presetModule);</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
    <span class="s2">if </span><span class="s1">(error </span><span class="s2">instanceof </span><span class="s1">SyntaxError || error </span><span class="s2">instanceof </span><span class="s1">TypeError) {</span>
      <span class="s2">throw </span><span class="s1">createConfigError(</span>
        <span class="s1">`  Preset ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(presetPath)} is invalid:\n\n  ${</span>
          <span class="s1">error.message</span>
        <span class="s1">}\n  ${error.stack}`</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(error.message.includes(</span><span class="s0">'Cannot find module'</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(error.message.includes(presetPath)) {</span>
        <span class="s1">const preset = _jestResolve().</span><span class="s2">default</span><span class="s1">.findNodeModule(presetPath, {</span>
          <span class="s1">basedir: options.rootDir</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(preset) {</span>
          <span class="s2">throw </span><span class="s1">createConfigError(</span>
            <span class="s1">`  Module ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(</span>
              <span class="s1">presetPath</span>
            <span class="s1">)} should have </span><span class="s0">&quot;jest-preset.js&quot; </span><span class="s1">or </span><span class="s0">&quot;jest-preset.json&quot; </span><span class="s1">file at the root.`</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">throw </span><span class="s1">createConfigError(</span>
          <span class="s1">`  Preset ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(presetPath)} not found.`</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">throw </span><span class="s1">createConfigError(</span>
        <span class="s1">`  Missing dependency </span><span class="s2">in </span><span class="s1">${_chalk().</span><span class="s2">default</span><span class="s1">.bold(presetPath)}:\n\n  ${</span>
          <span class="s1">error.message</span>
        <span class="s1">}\n  ${error.stack}`</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">throw </span><span class="s1">createConfigError(</span>
      <span class="s1">`  An unknown error occurred </span><span class="s2">in </span><span class="s1">${_chalk().</span><span class="s2">default</span><span class="s1">.bold(</span>
        <span class="s1">presetPath</span>
      <span class="s1">)}:\n\n  ${error.message}\n  ${error.stack}`</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(options.setupFiles) {</span>
    <span class="s1">options.setupFiles = (preset.setupFiles || []).concat(options.setupFiles);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(options.setupFilesAfterEnv) {</span>
    <span class="s1">options.setupFilesAfterEnv = (preset.setupFilesAfterEnv || []).concat(</span>
      <span class="s1">options.setupFilesAfterEnv</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(options.modulePathIgnorePatterns &amp;&amp; preset.modulePathIgnorePatterns) {</span>
    <span class="s1">options.modulePathIgnorePatterns = preset.modulePathIgnorePatterns.concat(</span>
      <span class="s1">options.modulePathIgnorePatterns</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">mergeOptionWithPreset(options, preset, </span><span class="s0">'moduleNameMapper'</span><span class="s1">);</span>
  <span class="s1">mergeOptionWithPreset(options, preset, </span><span class="s0">'transform'</span><span class="s1">);</span>
  <span class="s1">mergeGlobalsWithPreset(options, preset);</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">...preset,</span>
    <span class="s1">...options</span>
  <span class="s1">};</span>
<span class="s1">};</span>
<span class="s1">const setupBabelJest = options =&gt; {</span>
  <span class="s1">const transform = options.transform;</span>
  <span class="s1">let babelJest;</span>
  <span class="s2">if </span><span class="s1">(transform) {</span>
    <span class="s1">const customJSPattern = Object.keys(transform).find(pattern =&gt; {</span>
      <span class="s1">const regex = </span><span class="s2">new </span><span class="s1">RegExp(pattern);</span>
      <span class="s2">return </span><span class="s1">regex.test(</span><span class="s0">'a.js'</span><span class="s1">) || regex.test(</span><span class="s0">'a.jsx'</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">const customTSPattern = Object.keys(transform).find(pattern =&gt; {</span>
      <span class="s1">const regex = </span><span class="s2">new </span><span class="s1">RegExp(pattern);</span>
      <span class="s2">return </span><span class="s1">regex.test(</span><span class="s0">'a.ts'</span><span class="s1">) || regex.test(</span><span class="s0">'a.tsx'</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">[customJSPattern, customTSPattern].forEach(pattern =&gt; {</span>
      <span class="s2">if </span><span class="s1">(pattern) {</span>
        <span class="s1">const customTransformer = transform[pattern];</span>
        <span class="s2">if </span><span class="s1">(Array.isArray(customTransformer)) {</span>
          <span class="s2">if </span><span class="s1">(customTransformer[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">'babel-jest'</span><span class="s1">) {</span>
            <span class="s1">babelJest = require.resolve(</span><span class="s0">'babel-jest'</span><span class="s1">);</span>
            <span class="s1">customTransformer[</span><span class="s4">0</span><span class="s1">] = babelJest;</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(customTransformer[</span><span class="s4">0</span><span class="s1">].includes(</span><span class="s0">'babel-jest'</span><span class="s1">)) {</span>
            <span class="s1">babelJest = customTransformer[</span><span class="s4">0</span><span class="s1">];</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(customTransformer === </span><span class="s0">'babel-jest'</span><span class="s1">) {</span>
            <span class="s1">babelJest = require.resolve(</span><span class="s0">'babel-jest'</span><span class="s1">);</span>
            <span class="s1">transform[pattern] = babelJest;</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(customTransformer.includes(</span><span class="s0">'babel-jest'</span><span class="s1">)) {</span>
            <span class="s1">babelJest = customTransformer;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">babelJest = require.resolve(</span><span class="s0">'babel-jest'</span><span class="s1">);</span>
    <span class="s1">options.transform = {</span>
      <span class="s1">[_constants.DEFAULT_JS_PATTERN]: babelJest</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s1">const normalizeCollectCoverageFrom = (options, key) =&gt; {</span>
  <span class="s1">const initialCollectCoverageFrom = options[key];</span>
  <span class="s1">let value;</span>
  <span class="s2">if </span><span class="s1">(!initialCollectCoverageFrom) {</span>
    <span class="s1">value = [];</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!Array.isArray(initialCollectCoverageFrom)) {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">value = JSON.parse(initialCollectCoverageFrom);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">{}</span>
    <span class="s2">if </span><span class="s1">(options[key] &amp;&amp; !Array.isArray(value)) {</span>
      <span class="s1">value = [initialCollectCoverageFrom];</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">value = initialCollectCoverageFrom;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(value) {</span>
    <span class="s1">value = value.map(filePath =&gt;</span>
      <span class="s1">filePath.replace(/^(!?)(&lt;rootDir&gt;\/)(.*)/, </span><span class="s0">'$1$3'</span><span class="s1">)</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">value;</span>
<span class="s1">};</span>
<span class="s1">const normalizeUnmockedModulePathPatterns = (options, key) =&gt;</span>
  <span class="s3">// _replaceRootDirTags is specifically well-suited for substituting</span>
  <span class="s3">// &lt;rootDir&gt; in paths (it deals with properly interpreting relative path</span>
  <span class="s3">// separators, etc).</span>
  <span class="s3">//</span>
  <span class="s3">// For patterns, direct global substitution is far more ideal, so we</span>
  <span class="s3">// special case substitutions for patterns here.</span>
  <span class="s1">options[key].map(pattern =&gt;</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _jestRegexUtil().replacePathSepForRegex)(</span>
      <span class="s1">pattern.replace(/&lt;rootDir&gt;/g, options.rootDir)</span>
    <span class="s1">)</span>
  <span class="s1">);</span>
<span class="s1">const normalizeMissingOptions = (options, configPath, projectIndex) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(!options.id) {</span>
    <span class="s1">options.id = (</span><span class="s4">0</span><span class="s1">, _crypto().createHash)(</span><span class="s0">'sha1'</span><span class="s1">)</span>
      <span class="s1">.update(options.rootDir)</span>
      <span class="s3">// In case we load config from some path that has the same root dir</span>
      <span class="s1">.update(configPath || </span><span class="s0">''</span><span class="s1">)</span>
      <span class="s1">.update(String(projectIndex))</span>
      <span class="s1">.digest(</span><span class="s0">'hex'</span><span class="s1">)</span>
      <span class="s1">.substring(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">32</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!options.setupFiles) {</span>
    <span class="s1">options.setupFiles = [];</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">options;</span>
<span class="s1">};</span>
<span class="s1">const normalizeRootDir = options =&gt; {</span>
  <span class="s3">// Assert that there *is* a rootDir</span>
  <span class="s2">if </span><span class="s1">(!options.rootDir) {</span>
    <span class="s2">throw </span><span class="s1">createConfigError(</span>
      <span class="s1">`  Configuration option ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(</span>
        <span class="s0">'rootDir'</span>
      <span class="s1">)} must be specified.`</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">options.rootDir = path().normalize(options.rootDir);</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s3">// try to resolve windows short paths, ignoring errors (permission errors, mostly)</span>
    <span class="s1">options.rootDir = (</span><span class="s4">0</span><span class="s1">, _jestUtil().tryRealpath)(options.rootDir);</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">{</span>
    <span class="s3">// ignored</span>
  <span class="s1">}</span>
  <span class="s1">verifyDirectoryExists(options.rootDir, </span><span class="s0">'rootDir'</span><span class="s1">);</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">...options,</span>
    <span class="s1">rootDir: options.rootDir</span>
  <span class="s1">};</span>
<span class="s1">};</span>
<span class="s1">const normalizeReporters = ({reporters, rootDir}) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(!reporters || !Array.isArray(reporters)) {</span>
    <span class="s2">return </span><span class="s1">undefined;</span>
  <span class="s1">}</span>
  <span class="s1">(</span><span class="s4">0</span><span class="s1">, _ReporterValidationErrors.validateReporters)(reporters);</span>
  <span class="s2">return </span><span class="s1">reporters.map(reporterConfig =&gt; {</span>
    <span class="s1">const normalizedReporterConfig =</span>
      <span class="s2">typeof </span><span class="s1">reporterConfig === </span><span class="s0">'string'</span>
        <span class="s1">? </span><span class="s3">// if reporter config is a string, we wrap it in an array</span>
          <span class="s3">// and pass an empty object for options argument, to normalize</span>
          <span class="s3">// the shape.</span>
          <span class="s1">[reporterConfig, {}]</span>
        <span class="s1">: reporterConfig;</span>
    <span class="s1">const reporterPath = (</span><span class="s4">0</span><span class="s1">, _utils.replaceRootDirInPath)(</span>
      <span class="s1">rootDir,</span>
      <span class="s1">normalizedReporterConfig[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(![</span><span class="s0">'default'</span><span class="s1">, </span><span class="s0">'github-actions'</span><span class="s1">, </span><span class="s0">'summary'</span><span class="s1">].includes(reporterPath)) {</span>
      <span class="s1">const reporter = _jestResolve().</span><span class="s2">default</span><span class="s1">.findNodeModule(reporterPath, {</span>
        <span class="s1">basedir: rootDir</span>
      <span class="s1">});</span>
      <span class="s2">if </span><span class="s1">(!reporter) {</span>
        <span class="s2">throw new </span><span class="s1">(_jestResolve().</span><span class="s2">default</span><span class="s1">.ModuleNotFoundError)(</span>
          <span class="s0">'Could not resolve a module for a custom reporter.</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+</span>
            <span class="s1">`  Module name: ${reporterPath}`</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s1">normalizedReporterConfig[</span><span class="s4">0</span><span class="s1">] = reporter;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">normalizedReporterConfig;</span>
  <span class="s1">});</span>
<span class="s1">};</span>
<span class="s1">const buildTestPathPattern = argv =&gt; {</span>
  <span class="s1">const patterns = [];</span>
  <span class="s2">if </span><span class="s1">(argv._) {</span>
    <span class="s1">patterns.push(...argv._);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(argv.testPathPattern) {</span>
    <span class="s1">patterns.push(...argv.testPathPattern);</span>
  <span class="s1">}</span>
  <span class="s1">const replacePosixSep = pattern =&gt; {</span>
    <span class="s3">// yargs coerces positional args into numbers</span>
    <span class="s1">const patternAsString = pattern.toString();</span>
    <span class="s2">if </span><span class="s1">(path().sep === </span><span class="s0">'/'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">patternAsString;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">patternAsString.replace(/\</span><span class="s3">//g, '\\\\');</span>
  <span class="s1">};</span>
  <span class="s1">const testPathPattern = patterns.map(replacePosixSep).join(</span><span class="s0">'|'</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _validatePattern.</span><span class="s2">default</span><span class="s1">)(testPathPattern)) {</span>
    <span class="s2">return </span><span class="s1">testPathPattern;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">showTestPathPatternError(testPathPattern);</span>
    <span class="s2">return </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s1">const showTestPathPatternError = testPathPattern =&gt; {</span>
  <span class="s1">(</span><span class="s4">0</span><span class="s1">, _jestUtil().clearLine)(process.stdout);</span>

  <span class="s3">// eslint-disable-next-line no-console</span>
  <span class="s1">console.log(</span>
    <span class="s1">_chalk().</span><span class="s2">default</span><span class="s1">.red(</span>
      <span class="s1">`  Invalid testPattern ${testPathPattern} supplied. ` +</span>
        <span class="s0">'Running all tests instead.'</span>
    <span class="s1">)</span>
  <span class="s1">);</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">validateExtensionsToTreatAsEsm(extensionsToTreatAsEsm) {</span>
  <span class="s2">if </span><span class="s1">(!extensionsToTreatAsEsm || extensionsToTreatAsEsm.length === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">return</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">printConfig(opts) {</span>
    <span class="s1">const string = opts.map(ext =&gt; `</span><span class="s0">'${ext}'</span><span class="s1">`).join(</span><span class="s0">', '</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">_chalk().</span><span class="s2">default</span><span class="s1">.bold(`extensionsToTreatAsEsm: [${string}]`);</span>
  <span class="s1">}</span>
  <span class="s1">const extensionWithoutDot = extensionsToTreatAsEsm.some(</span>
    <span class="s1">ext =&gt; !ext.startsWith(</span><span class="s0">'.'</span><span class="s1">)</span>
  <span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(extensionWithoutDot) {</span>
    <span class="s2">throw </span><span class="s1">createConfigError(`  Option: ${printConfig(</span>
      <span class="s1">extensionsToTreatAsEsm</span>
    <span class="s1">)} includes a string that does not start </span><span class="s2">with </span><span class="s1">a period (${_chalk().</span><span class="s2">default</span><span class="s1">.bold(</span>
      <span class="s0">'.'</span>
    <span class="s1">)}).</span>
  <span class="s1">Please change your configuration to ${printConfig(</span>
    <span class="s1">extensionsToTreatAsEsm.map(ext =&gt; (ext.startsWith(</span><span class="s0">'.'</span><span class="s1">) ? ext : `.${ext}`))</span>
  <span class="s1">)}.`);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(extensionsToTreatAsEsm.includes(</span><span class="s0">'.js'</span><span class="s1">)) {</span>
    <span class="s2">throw </span><span class="s1">createConfigError(</span>
      <span class="s1">`  Option: ${printConfig(</span>
        <span class="s1">extensionsToTreatAsEsm</span>
      <span class="s1">)} includes ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(</span>
        <span class="s0">&quot;'.js'&quot;</span>
      <span class="s1">)} which is always inferred based on ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(</span>
        <span class="s0">'type'</span>
      <span class="s1">)} </span><span class="s2">in </span><span class="s1">its nearest ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(</span><span class="s0">'package.json'</span><span class="s1">)}.`</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(extensionsToTreatAsEsm.includes(</span><span class="s0">'.cjs'</span><span class="s1">)) {</span>
    <span class="s2">throw </span><span class="s1">createConfigError(</span>
      <span class="s1">`  Option: ${printConfig(</span>
        <span class="s1">extensionsToTreatAsEsm</span>
      <span class="s1">)} includes ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(</span>
        <span class="s0">&quot;'.cjs'&quot;</span>
      <span class="s1">)} which is always treated as CommonJS.`</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(extensionsToTreatAsEsm.includes(</span><span class="s0">'.mjs'</span><span class="s1">)) {</span>
    <span class="s2">throw </span><span class="s1">createConfigError(</span>
      <span class="s1">`  Option: ${printConfig(</span>
        <span class="s1">extensionsToTreatAsEsm</span>
      <span class="s1">)} includes ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(</span>
        <span class="s0">&quot;'.mjs'&quot;</span>
      <span class="s1">)} which is always treated as an ECMAScript Module.`</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">normalize(</span>
  <span class="s1">initialOptions,</span>
  <span class="s1">argv,</span>
  <span class="s1">configPath,</span>
  <span class="s1">projectIndex = Infinity,</span>
  <span class="s1">isProjectOptions</span>
<span class="s1">) {</span>
  <span class="s1">const {hasDeprecationWarnings} = (</span><span class="s4">0</span><span class="s1">, _jestValidate().validate)(</span>
    <span class="s1">initialOptions,</span>
    <span class="s1">{</span>
      <span class="s1">comment: _utils.DOCUMENTATION_NOTE,</span>
      <span class="s1">deprecatedConfig: _Deprecated.</span><span class="s2">default</span><span class="s1">,</span>
      <span class="s1">exampleConfig: isProjectOptions</span>
        <span class="s1">? _ValidConfig.initialProjectOptions</span>
        <span class="s1">: _ValidConfig.initialOptions,</span>
      <span class="s1">recursiveDenylist: [</span>
        <span class="s3">// 'coverageThreshold' allows to use 'global' and glob strings on the same</span>
        <span class="s3">// level, there's currently no way we can deal with such config</span>
        <span class="s0">'coverageThreshold'</span><span class="s1">,</span>
        <span class="s0">'globals'</span><span class="s1">,</span>
        <span class="s0">'moduleNameMapper'</span><span class="s1">,</span>
        <span class="s0">'testEnvironmentOptions'</span><span class="s1">,</span>
        <span class="s0">'transform'</span>
      <span class="s1">]</span>
    <span class="s1">}</span>
  <span class="s1">);</span>
  <span class="s1">let options = normalizeMissingOptions(</span>
    <span class="s1">normalizeRootDir((</span><span class="s4">0</span><span class="s1">, _setFromArgv.</span><span class="s2">default</span><span class="s1">)(initialOptions, argv)),</span>
    <span class="s1">configPath,</span>
    <span class="s1">projectIndex</span>
  <span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(options.preset) {</span>
    <span class="s1">options = await setupPreset(options, options.preset);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!options.setupFilesAfterEnv) {</span>
    <span class="s1">options.setupFilesAfterEnv = [];</span>
  <span class="s1">}</span>
  <span class="s1">options.testEnvironment = (</span><span class="s4">0</span><span class="s1">, _jestResolve().resolveTestEnvironment)({</span>
    <span class="s1">requireResolveFunction: require.resolve,</span>
    <span class="s1">rootDir: options.rootDir,</span>
    <span class="s1">testEnvironment:</span>
      <span class="s1">options.testEnvironment ||</span>
      <span class="s1">require.resolve(_Defaults.</span><span class="s2">default</span><span class="s1">.testEnvironment)</span>
  <span class="s1">});</span>
  <span class="s2">if </span><span class="s1">(!options.roots) {</span>
    <span class="s1">options.roots = [options.rootDir];</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span>
    <span class="s1">!options.testRunner ||</span>
    <span class="s1">options.testRunner === </span><span class="s0">'circus' </span><span class="s1">||</span>
    <span class="s1">options.testRunner === </span><span class="s0">'jest-circus' </span><span class="s1">||</span>
    <span class="s1">options.testRunner === </span><span class="s0">'jest-circus/runner'</span>
  <span class="s1">) {</span>
    <span class="s1">options.testRunner = require.resolve(</span><span class="s0">'jest-circus/runner'</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(options.testRunner === </span><span class="s0">'jasmine2'</span><span class="s1">) {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">options.testRunner = require.resolve(</span><span class="s0">'jest-jasmine2'</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
      <span class="s2">if </span><span class="s1">(error.code === </span><span class="s0">'MODULE_NOT_FOUND'</span><span class="s1">) {</span>
        <span class="s2">throw </span><span class="s1">createConfigError(</span>
          <span class="s0">'jest-jasmine is no longer shipped by default with Jest, you need to install it explicitly or provide an absolute path to Jest'</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">throw </span><span class="s1">error;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!options.coverageDirectory) {</span>
    <span class="s1">options.coverageDirectory = path().resolve(options.rootDir, </span><span class="s0">'coverage'</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">setupBabelJest(options);</span>
  <span class="s3">// TODO: Type this properly</span>
  <span class="s1">const newOptions = {</span>
    <span class="s1">..._Defaults.</span><span class="s2">default</span>
  <span class="s1">};</span>
  <span class="s2">if </span><span class="s1">(options.resolver) {</span>
    <span class="s1">newOptions.resolver = (</span><span class="s4">0</span><span class="s1">, _utils.resolve)(</span><span class="s2">null</span><span class="s1">, {</span>
      <span class="s1">filePath: options.resolver,</span>
      <span class="s1">key: </span><span class="s0">'resolver'</span><span class="s1">,</span>
      <span class="s1">rootDir: options.rootDir</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
  <span class="s1">validateExtensionsToTreatAsEsm(options.extensionsToTreatAsEsm);</span>
  <span class="s2">if </span><span class="s1">(options.watchman == </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">options.watchman = _Defaults.</span><span class="s2">default</span><span class="s1">.watchman;</span>
  <span class="s1">}</span>
  <span class="s1">const optionKeys = Object.keys(options);</span>
  <span class="s1">optionKeys.reduce((newOptions, key) =&gt; {</span>
    <span class="s3">// The resolver has been resolved separately; skip it</span>
    <span class="s2">if </span><span class="s1">(key === </span><span class="s0">'resolver'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">newOptions;</span>
    <span class="s1">}</span>

    <span class="s3">// This is cheating, because it claims that all keys of InitialOptions are Required.</span>
    <span class="s3">// We only really know it's Required for oldOptions[key], not for oldOptions.someOtherKey,</span>
    <span class="s3">// so oldOptions[key] is the only way it should be used.</span>
    <span class="s1">const oldOptions = options;</span>
    <span class="s1">let value;</span>
    <span class="s2">switch </span><span class="s1">(key) {</span>
      <span class="s2">case </span><span class="s0">'setupFiles'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'setupFilesAfterEnv'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'snapshotSerializers'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">const option = oldOptions[key];</span>
          <span class="s1">value =</span>
            <span class="s1">option &amp;&amp;</span>
            <span class="s1">option.map(filePath =&gt;</span>
              <span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils.resolve)(newOptions.resolver, {</span>
                <span class="s1">filePath,</span>
                <span class="s1">key,</span>
                <span class="s1">rootDir: options.rootDir</span>
              <span class="s1">})</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'modulePaths'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'roots'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">const option = oldOptions[key];</span>
          <span class="s1">value =</span>
            <span class="s1">option &amp;&amp;</span>
            <span class="s1">option.map(filePath =&gt;</span>
              <span class="s1">path().resolve(</span>
                <span class="s1">options.rootDir,</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils.replaceRootDirInPath)(options.rootDir, filePath)</span>
              <span class="s1">)</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'collectCoverageFrom'</span><span class="s1">:</span>
        <span class="s1">value = normalizeCollectCoverageFrom(oldOptions, key);</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'cacheDirectory'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'coverageDirectory'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">const option = oldOptions[key];</span>
          <span class="s1">value =</span>
            <span class="s1">option &amp;&amp;</span>
            <span class="s1">path().resolve(</span>
              <span class="s1">options.rootDir,</span>
              <span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils.replaceRootDirInPath)(options.rootDir, option)</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'dependencyExtractor'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'globalSetup'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'globalTeardown'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'runtime'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'snapshotResolver'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'testResultsProcessor'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'testRunner'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'filter'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">const option = oldOptions[key];</span>
          <span class="s1">value =</span>
            <span class="s1">option &amp;&amp;</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils.resolve)(newOptions.resolver, {</span>
              <span class="s1">filePath: option,</span>
              <span class="s1">key,</span>
              <span class="s1">rootDir: options.rootDir</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'runner'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">const option = oldOptions[key];</span>
          <span class="s1">value =</span>
            <span class="s1">option &amp;&amp;</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _jestResolve().resolveRunner)(newOptions.resolver, {</span>
              <span class="s1">filePath: option,</span>
              <span class="s1">requireResolveFunction: require.resolve,</span>
              <span class="s1">rootDir: options.rootDir</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'prettierPath'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s3">// We only want this to throw if &quot;prettierPath&quot; is explicitly passed</span>
          <span class="s3">// from config or CLI, and the requested path isn't found. Otherwise we</span>
          <span class="s3">// set it to null and throw an error lazily when it is used.</span>

          <span class="s1">const option = oldOptions[key];</span>
          <span class="s1">value =</span>
            <span class="s1">option &amp;&amp;</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils.resolve)(newOptions.resolver, {</span>
              <span class="s1">filePath: option,</span>
              <span class="s1">key,</span>
              <span class="s1">optional: option === _Defaults.</span><span class="s2">default</span><span class="s1">[key],</span>
              <span class="s1">rootDir: options.rootDir</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'moduleNameMapper'</span><span class="s1">:</span>
        <span class="s1">const moduleNameMapper = oldOptions[key];</span>
        <span class="s1">value =</span>
          <span class="s1">moduleNameMapper &amp;&amp;</span>
          <span class="s1">Object.keys(moduleNameMapper).map(regex =&gt; {</span>
            <span class="s1">const item = moduleNameMapper &amp;&amp; moduleNameMapper[regex];</span>
            <span class="s2">return </span><span class="s1">(</span>
              <span class="s1">item &amp;&amp; [</span>
                <span class="s1">regex,</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils._replaceRootDirTags)(options.rootDir, item)</span>
              <span class="s1">]</span>
            <span class="s1">);</span>
          <span class="s1">});</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'transform'</span><span class="s1">:</span>
        <span class="s1">const transform = oldOptions[key];</span>
        <span class="s1">value =</span>
          <span class="s1">transform &amp;&amp;</span>
          <span class="s1">Object.keys(transform).map(regex =&gt; {</span>
            <span class="s1">const transformElement = transform[regex];</span>
            <span class="s2">return </span><span class="s1">[</span>
              <span class="s1">regex,</span>
              <span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils.resolve)(newOptions.resolver, {</span>
                <span class="s1">filePath: Array.isArray(transformElement)</span>
                  <span class="s1">? transformElement[</span><span class="s4">0</span><span class="s1">]</span>
                  <span class="s1">: transformElement,</span>
                <span class="s1">key,</span>
                <span class="s1">rootDir: options.rootDir</span>
              <span class="s1">}),</span>
              <span class="s1">Array.isArray(transformElement) ? transformElement[</span><span class="s4">1</span><span class="s1">] : {}</span>
            <span class="s1">];</span>
          <span class="s1">});</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'reporters'</span><span class="s1">:</span>
        <span class="s1">value = normalizeReporters(oldOptions);</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'coveragePathIgnorePatterns'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'modulePathIgnorePatterns'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'testPathIgnorePatterns'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'transformIgnorePatterns'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'watchPathIgnorePatterns'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'unmockedModulePathPatterns'</span><span class="s1">:</span>
        <span class="s1">value = normalizeUnmockedModulePathPatterns(oldOptions, key);</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'haste'</span><span class="s1">:</span>
        <span class="s1">value = {</span>
          <span class="s1">...oldOptions[key]</span>
        <span class="s1">};</span>
        <span class="s2">if </span><span class="s1">(value.hasteImplModulePath != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">const resolvedHasteImpl = (</span><span class="s4">0</span><span class="s1">, _utils.resolve)(newOptions.resolver, {</span>
            <span class="s1">filePath: (</span><span class="s4">0</span><span class="s1">, _utils.replaceRootDirInPath)(</span>
              <span class="s1">options.rootDir,</span>
              <span class="s1">value.hasteImplModulePath</span>
            <span class="s1">),</span>
            <span class="s1">key: </span><span class="s0">'haste.hasteImplModulePath'</span><span class="s1">,</span>
            <span class="s1">rootDir: options.rootDir</span>
          <span class="s1">});</span>
          <span class="s1">value.hasteImplModulePath = resolvedHasteImpl || undefined;</span>
        <span class="s1">}</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'projects'</span><span class="s1">:</span>
        <span class="s1">value = (oldOptions[key] || [])</span>
          <span class="s1">.map(project =&gt;</span>
            <span class="s2">typeof </span><span class="s1">project === </span><span class="s0">'string'</span>
              <span class="s1">? (</span><span class="s4">0</span><span class="s1">, _utils._replaceRootDirTags)(options.rootDir, project)</span>
              <span class="s1">: project</span>
          <span class="s1">)</span>
          <span class="s1">.reduce((projects, project) =&gt; {</span>
            <span class="s3">// Project can be specified as globs. If a glob matches any files,</span>
            <span class="s3">// We expand it to these paths. If not, we keep the original path</span>
            <span class="s3">// for the future resolution.</span>
            <span class="s1">const globMatches =</span>
              <span class="s2">typeof </span><span class="s1">project === </span><span class="s0">'string' </span><span class="s1">? (</span><span class="s4">0</span><span class="s1">, _glob().sync)(project) : [];</span>
            <span class="s2">return </span><span class="s1">projects.concat(globMatches.length ? globMatches : project);</span>
          <span class="s1">}, []);</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'moduleDirectories'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'testMatch'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">const replacedRootDirTags = (</span><span class="s4">0</span><span class="s1">, _utils._replaceRootDirTags)(</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils.escapeGlobCharacters)(options.rootDir),</span>
            <span class="s1">oldOptions[key]</span>
          <span class="s1">);</span>
          <span class="s2">if </span><span class="s1">(replacedRootDirTags) {</span>
            <span class="s1">value = Array.isArray(replacedRootDirTags)</span>
              <span class="s1">? replacedRootDirTags.map(_jestUtil().replacePathSepForGlob)</span>
              <span class="s1">: (</span><span class="s4">0</span><span class="s1">, _jestUtil().replacePathSepForGlob)(replacedRootDirTags);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">value = replacedRootDirTags;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'testRegex'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">const option = oldOptions[key];</span>
          <span class="s1">value = option</span>
            <span class="s1">? (Array.isArray(option) ? option : [option]).map(</span>
                <span class="s1">_jestRegexUtil().replacePathSepForRegex</span>
              <span class="s1">)</span>
            <span class="s1">: [];</span>
        <span class="s1">}</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'moduleFileExtensions'</span><span class="s1">: {</span>
        <span class="s1">value = oldOptions[key];</span>
        <span class="s2">if </span><span class="s1">(</span>
          <span class="s1">Array.isArray(value) &amp;&amp;</span>
          <span class="s3">// If it's the wrong type, it can throw at a later time</span>
          <span class="s1">(options.runner === undefined ||</span>
            <span class="s1">options.runner === _Defaults.</span><span class="s2">default</span><span class="s1">.runner) &amp;&amp;</span>
          <span class="s3">// Only require 'js' for the default jest-runner</span>
          <span class="s1">!value.includes(</span><span class="s0">'js'</span><span class="s1">)</span>
        <span class="s1">) {</span>
          <span class="s1">const errorMessage =</span>
            <span class="s0">&quot;  moduleFileExtensions must include 'js':</span><span class="s5">\n</span><span class="s0">&quot; </span><span class="s1">+</span>
            <span class="s0">'  but instead received:</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+</span>
            <span class="s1">`    ${_chalk().</span><span class="s2">default</span><span class="s1">.bold.red(JSON.stringify(value))}`;</span>

          <span class="s3">// If `js` is not included, any dependency Jest itself injects into</span>
          <span class="s3">// the environment, like jasmine or sourcemap-support, will need to</span>
          <span class="s3">// `require` its modules with a file extension. This is not plausible</span>
          <span class="s3">// in the long run, so it's way easier to just fail hard early.</span>
          <span class="s3">// We might consider throwing if `json` is missing as well, as it's a</span>
          <span class="s3">// fair assumption from modules that they can do</span>
          <span class="s3">// `require('some-package/package') without the trailing `.json` as it</span>
          <span class="s3">// works in Node normally.</span>
          <span class="s2">throw </span><span class="s1">createConfigError(</span>
            <span class="s1">`${errorMessage}\n  Please change your configuration to include </span><span class="s0">'js'</span><span class="s1">.`</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">case </span><span class="s0">'bail'</span><span class="s1">: {</span>
        <span class="s1">const bail = oldOptions[key];</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">bail === </span><span class="s0">'boolean'</span><span class="s1">) {</span>
          <span class="s1">value = bail ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">bail === </span><span class="s0">'string'</span><span class="s1">) {</span>
          <span class="s1">value = </span><span class="s4">1</span><span class="s1">;</span>
          <span class="s3">// If Jest is invoked as `jest --bail someTestPattern` then need to</span>
          <span class="s3">// move the pattern from the `bail` configuration and into `argv._`</span>
          <span class="s3">// to be processed as an extra parameter</span>
          <span class="s1">argv._.push(bail);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">value = oldOptions[key];</span>
        <span class="s1">}</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">case </span><span class="s0">'displayName'</span><span class="s1">: {</span>
        <span class="s1">const displayName = oldOptions[key];</span>
        <span class="s3">/** 
         * Ensuring that displayName shape is correct here so that the 
         * reporters can trust the shape of the data 
         */</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">displayName === </span><span class="s0">'object'</span><span class="s1">) {</span>
          <span class="s1">const {name, color} = displayName;</span>
          <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">!name ||</span>
            <span class="s1">!color ||</span>
            <span class="s2">typeof </span><span class="s1">name !== </span><span class="s0">'string' </span><span class="s1">||</span>
            <span class="s2">typeof </span><span class="s1">color !== </span><span class="s0">'string'</span>
          <span class="s1">) {</span>
            <span class="s1">const errorMessage =</span>
              <span class="s1">`  Option </span><span class="s0">&quot;${_chalk().default.bold(</span>
                <span class="s0">'displayName'</span>
              <span class="s1">)}</span><span class="s0">&quot; must be of type:</span><span class="s5">\n\n</span><span class="s0">` +</span>
              <span class="s0">'  {</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+</span>
              <span class="s0">'    name: string;</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+</span>
              <span class="s0">'    color: string;</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+</span>
              <span class="s0">'  }</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
            <span class="s2">throw </span><span class="s1">createConfigError(errorMessage);</span>
          <span class="s1">}</span>
          <span class="s1">value = oldOptions[key];</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">value = {</span>
            <span class="s1">color: (</span><span class="s4">0</span><span class="s1">, _color.getDisplayNameColor)(options.runner),</span>
            <span class="s1">name: displayName</span>
          <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">case </span><span class="s0">'testTimeout'</span><span class="s1">: {</span>
        <span class="s2">if </span><span class="s1">(oldOptions[key] &lt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s2">throw </span><span class="s1">createConfigError(</span>
            <span class="s1">`  Option </span><span class="s0">&quot;${_chalk().default.bold(</span>
              <span class="s0">'testTimeout'</span>
            <span class="s1">)}</span><span class="s0">&quot; must be a natural number.`</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">value = oldOptions[key];</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">case </span><span class="s0">'snapshotFormat'</span><span class="s1">: {</span>
        <span class="s1">value = {</span>
          <span class="s1">..._Defaults.</span><span class="s2">default</span><span class="s1">.snapshotFormat,</span>
          <span class="s1">...oldOptions[key]</span>
        <span class="s1">};</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">case </span><span class="s0">'automock'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'changedSince'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'changedFilesWithAncestor'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'clearMocks'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'collectCoverage'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'coverageProvider'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'coverageReporters'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'coverageThreshold'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'detectLeaks'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'detectOpenHandles'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'errorOnDeprecated'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'expand'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'extensionsToTreatAsEsm'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'globals'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'fakeTimers'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'findRelatedTests'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'forceCoverageMatch'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'forceExit'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'injectGlobals'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'lastCommit'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'listTests'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'logHeapUsage'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'maxConcurrency'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'id'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'noStackTrace'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'notify'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'notifyMode'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'onlyChanged'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'onlyFailures'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'openHandlesTimeout'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'outputFile'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'passWithNoTests'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'randomize'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'replname'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'resetMocks'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'resetModules'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'restoreMocks'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'rootDir'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'runTestsByPath'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'sandboxInjectedGlobals'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'silent'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'showSeed'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'skipFilter'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'skipNodeResolution'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'slowTestThreshold'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'testEnvironment'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'testEnvironmentOptions'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'testFailureExitCode'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'testLocationInResults'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'testNamePattern'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'useStderr'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'verbose'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'watch'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'watchAll'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'watchman'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'workerThreads'</span><span class="s1">:</span>
        <span class="s1">value = oldOptions[key];</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'workerIdleMemoryLimit'</span><span class="s1">:</span>
        <span class="s1">value = (</span><span class="s4">0</span><span class="s1">, _stringToBytes.</span><span class="s2">default</span><span class="s1">)(</span>
          <span class="s1">oldOptions[key],</span>
          <span class="s1">(</span><span class="s4">0</span><span class="s1">, _os().totalmem)()</span>
        <span class="s1">);</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'watchPlugins'</span><span class="s1">:</span>
        <span class="s1">value = (oldOptions[key] || []).map(watchPlugin =&gt; {</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">watchPlugin === </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">{</span>
              <span class="s1">config: {},</span>
              <span class="s1">path: (</span><span class="s4">0</span><span class="s1">, _jestResolve().resolveWatchPlugin)(</span>
                <span class="s1">newOptions.resolver,</span>
                <span class="s1">{</span>
                  <span class="s1">filePath: watchPlugin,</span>
                  <span class="s1">requireResolveFunction: require.resolve,</span>
                  <span class="s1">rootDir: options.rootDir</span>
                <span class="s1">}</span>
              <span class="s1">)</span>
            <span class="s1">};</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">return </span><span class="s1">{</span>
              <span class="s1">config: watchPlugin[</span><span class="s4">1</span><span class="s1">] || {},</span>
              <span class="s1">path: (</span><span class="s4">0</span><span class="s1">, _jestResolve().resolveWatchPlugin)(</span>
                <span class="s1">newOptions.resolver,</span>
                <span class="s1">{</span>
                  <span class="s1">filePath: watchPlugin[</span><span class="s4">0</span><span class="s1">],</span>
                  <span class="s1">requireResolveFunction: require.resolve,</span>
                  <span class="s1">rootDir: options.rootDir</span>
                <span class="s1">}</span>
              <span class="s1">)</span>
            <span class="s1">};</span>
          <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">// @ts-expect-error: automock is missing in GlobalConfig, so what</span>
    <span class="s1">newOptions[key] = value;</span>
    <span class="s2">return </span><span class="s1">newOptions;</span>
  <span class="s1">}, newOptions);</span>
  <span class="s2">if </span><span class="s1">(options.watchman &amp;&amp; options.haste?.enableSymlinks) {</span>
    <span class="s2">throw new </span><span class="s1">(_jestValidate().ValidationError)(</span>
      <span class="s0">'Validation Error'</span><span class="s1">,</span>
      <span class="s0">'haste.enableSymlinks is incompatible with watchman'</span><span class="s1">,</span>
      <span class="s0">'Either set haste.enableSymlinks to false or do not use watchman'</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">newOptions.roots.forEach((root, i) =&gt; {</span>
    <span class="s1">verifyDirectoryExists(root, `roots[${i}]`);</span>
  <span class="s1">});</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s3">// try to resolve windows short paths, ignoring errors (permission errors, mostly)</span>
    <span class="s1">newOptions.cwd = (</span><span class="s4">0</span><span class="s1">, _jestUtil().tryRealpath)(process.cwd());</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">{</span>
    <span class="s3">// ignored</span>
  <span class="s1">}</span>
  <span class="s1">newOptions.testSequencer = (</span><span class="s4">0</span><span class="s1">, _jestResolve().resolveSequencer)(</span>
    <span class="s1">newOptions.resolver,</span>
    <span class="s1">{</span>
      <span class="s1">filePath:</span>
        <span class="s1">options.testSequencer ||</span>
        <span class="s1">require.resolve(_Defaults.</span><span class="s2">default</span><span class="s1">.testSequencer),</span>
      <span class="s1">requireResolveFunction: require.resolve,</span>
      <span class="s1">rootDir: options.rootDir</span>
    <span class="s1">}</span>
  <span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(newOptions.runner === _Defaults.</span><span class="s2">default</span><span class="s1">.runner) {</span>
    <span class="s1">newOptions.runner = require.resolve(newOptions.runner);</span>
  <span class="s1">}</span>
  <span class="s1">newOptions.nonFlagArgs = argv._?.map(arg =&gt; `${arg}`);</span>
  <span class="s1">newOptions.testPathPattern = buildTestPathPattern(argv);</span>
  <span class="s1">newOptions.json = !!argv.json;</span>
  <span class="s1">newOptions.testFailureExitCode = parseInt(newOptions.testFailureExitCode, </span><span class="s4">10</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(</span>
    <span class="s1">newOptions.lastCommit ||</span>
    <span class="s1">newOptions.changedFilesWithAncestor ||</span>
    <span class="s1">newOptions.changedSince</span>
  <span class="s1">) {</span>
    <span class="s1">newOptions.onlyChanged = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(argv.all) {</span>
    <span class="s1">newOptions.onlyChanged = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">newOptions.onlyFailures = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(newOptions.testPathPattern) {</span>
    <span class="s3">// When passing a test path pattern we don't want to only monitor changed</span>
    <span class="s3">// files unless `--watch` is also passed.</span>
    <span class="s1">newOptions.onlyChanged = newOptions.watch;</span>
  <span class="s1">}</span>
  <span class="s1">newOptions.randomize = newOptions.randomize || argv.randomize;</span>
  <span class="s1">newOptions.showSeed =</span>
    <span class="s1">newOptions.randomize || newOptions.showSeed || argv.showSeed;</span>
  <span class="s1">const upperBoundSeedValue = </span><span class="s4">2 </span><span class="s1">** </span><span class="s4">31</span><span class="s1">;</span>

  <span class="s3">// bounds are determined by xoroshiro128plus which is used in v8 and is used here (at time of writing)</span>
  <span class="s1">newOptions.seed =</span>
    <span class="s1">argv.seed ??</span>
    <span class="s1">Math.floor((</span><span class="s4">2 </span><span class="s1">** </span><span class="s4">32 </span><span class="s1">- </span><span class="s4">1</span><span class="s1">) * Math.random() - upperBoundSeedValue);</span>
  <span class="s2">if </span><span class="s1">(</span>
    <span class="s1">newOptions.seed &lt; -upperBoundSeedValue ||</span>
    <span class="s1">newOptions.seed &gt; upperBoundSeedValue - </span><span class="s4">1</span>
  <span class="s1">) {</span>
    <span class="s2">throw new </span><span class="s1">(_jestValidate().ValidationError)(</span>
      <span class="s0">'Validation Error'</span><span class="s1">,</span>
      <span class="s1">`seed value must be between \`-</span><span class="s4">0</span><span class="s1">x80000000\` and \`</span><span class="s4">0</span><span class="s1">x7fffffff\` inclusive - instead it is ${newOptions.seed}`</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!newOptions.onlyChanged) {</span>
    <span class="s1">newOptions.onlyChanged = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!newOptions.lastCommit) {</span>
    <span class="s1">newOptions.lastCommit = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!newOptions.onlyFailures) {</span>
    <span class="s1">newOptions.onlyFailures = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!newOptions.watchAll) {</span>
    <span class="s1">newOptions.watchAll = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">// as unknown since it can happen. We really need to fix the types here</span>
  <span class="s2">if </span><span class="s1">(newOptions.moduleNameMapper === _Defaults.</span><span class="s2">default</span><span class="s1">.moduleNameMapper) {</span>
    <span class="s1">newOptions.moduleNameMapper = [];</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(argv.ci != </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">newOptions.ci = argv.ci;</span>
  <span class="s1">}</span>
  <span class="s1">newOptions.updateSnapshot =</span>
    <span class="s1">newOptions.ci &amp;&amp; !argv.updateSnapshot</span>
      <span class="s1">? </span><span class="s0">'none'</span>
      <span class="s1">: argv.updateSnapshot</span>
      <span class="s1">? </span><span class="s0">'all'</span>
      <span class="s1">: </span><span class="s0">'new'</span><span class="s1">;</span>
  <span class="s1">newOptions.maxConcurrency = parseInt(newOptions.maxConcurrency, </span><span class="s4">10</span><span class="s1">);</span>
  <span class="s1">newOptions.maxWorkers = (</span><span class="s4">0</span><span class="s1">, _getMaxWorkers.</span><span class="s2">default</span><span class="s1">)(argv, options);</span>
  <span class="s2">if </span><span class="s1">(newOptions.testRegex.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; options.testMatch) {</span>
    <span class="s2">throw </span><span class="s1">createConfigError(</span>
      <span class="s1">`  Configuration options ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(</span><span class="s0">'testMatch'</span><span class="s1">)} and` +</span>
        <span class="s1">` ${_chalk().</span><span class="s2">default</span><span class="s1">.bold(</span><span class="s0">'testRegex'</span><span class="s1">)} cannot be used together.`</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(newOptions.testRegex.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; !options.testMatch) {</span>
    <span class="s3">// Prevent the default testMatch conflicting with any explicitly</span>
    <span class="s3">// configured `testRegex` value</span>
    <span class="s1">newOptions.testMatch = [];</span>
  <span class="s1">}</span>

  <span class="s3">// If argv.json is set, coverageReporters shouldn't print a text report.</span>
  <span class="s2">if </span><span class="s1">(argv.json) {</span>
    <span class="s1">newOptions.coverageReporters = (newOptions.coverageReporters || []).filter(</span>
      <span class="s1">reporter =&gt; reporter !== </span><span class="s0">'text'</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">// If collectCoverage is enabled while using --findRelatedTests we need to</span>
  <span class="s3">// avoid having false negatives in the generated coverage report.</span>
  <span class="s3">// The following: `--findRelatedTests '/rootDir/file1.js' --coverage`</span>
  <span class="s3">// Is transformed to: `--findRelatedTests '/rootDir/file1.js' --coverage --collectCoverageFrom 'file1.js'`</span>
  <span class="s3">// where arguments to `--collectCoverageFrom` should be globs (or relative</span>
  <span class="s3">// paths to the rootDir)</span>
  <span class="s2">if </span><span class="s1">(newOptions.collectCoverage &amp;&amp; argv.findRelatedTests) {</span>
    <span class="s1">let collectCoverageFrom = newOptions.nonFlagArgs.map(filename =&gt; {</span>
      <span class="s1">filename = (</span><span class="s4">0</span><span class="s1">, _utils.replaceRootDirInPath)(options.rootDir, filename);</span>
      <span class="s2">return </span><span class="s1">path().isAbsolute(filename)</span>
        <span class="s1">? path().relative(options.rootDir, filename)</span>
        <span class="s1">: filename;</span>
    <span class="s1">});</span>

    <span class="s3">// Don't override existing collectCoverageFrom options</span>
    <span class="s2">if </span><span class="s1">(newOptions.collectCoverageFrom) {</span>
      <span class="s1">collectCoverageFrom = collectCoverageFrom.reduce((patterns, filename) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(</span>
          <span class="s1">(</span><span class="s4">0</span><span class="s1">, _micromatch().</span><span class="s2">default</span><span class="s1">)(</span>
            <span class="s1">[</span>
              <span class="s1">(</span><span class="s4">0</span><span class="s1">, _jestUtil().replacePathSepForGlob)(</span>
                <span class="s1">path().relative(options.rootDir, filename)</span>
              <span class="s1">)</span>
            <span class="s1">],</span>
            <span class="s1">newOptions.collectCoverageFrom</span>
          <span class="s1">).length === </span><span class="s4">0</span>
        <span class="s1">) {</span>
          <span class="s2">return </span><span class="s1">patterns;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">[...patterns, filename];</span>
      <span class="s1">}, newOptions.collectCoverageFrom);</span>
    <span class="s1">}</span>
    <span class="s1">newOptions.collectCoverageFrom = collectCoverageFrom;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!newOptions.collectCoverageFrom) {</span>
    <span class="s1">newOptions.collectCoverageFrom = [];</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!newOptions.findRelatedTests) {</span>
    <span class="s1">newOptions.findRelatedTests = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!newOptions.projects) {</span>
    <span class="s1">newOptions.projects = [];</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!newOptions.sandboxInjectedGlobals) {</span>
    <span class="s1">newOptions.sandboxInjectedGlobals = [];</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!newOptions.forceExit) {</span>
    <span class="s1">newOptions.forceExit = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!newOptions.logHeapUsage) {</span>
    <span class="s1">newOptions.logHeapUsage = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(argv.shard) {</span>
    <span class="s1">newOptions.shard = (</span><span class="s4">0</span><span class="s1">, _parseShardPair.parseShardPair)(argv.shard);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">hasDeprecationWarnings,</span>
    <span class="s1">options: newOptions</span>
  <span class="s1">};</span>
<span class="s1">}</span>
</pre>
</body>
</html>
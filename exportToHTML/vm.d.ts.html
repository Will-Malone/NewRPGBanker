<html>
<head>
<title>vm.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #cc7832;}
.s2 { color: #a9b7c6;}
.s3 { color: #a9b7c6;}
.s4 { color: #6a8759;}
.s5 { color: #ffc66d;}
.s6 { color: #9876aa; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
vm.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* The `node:vm` module enables compiling and running code within V8 Virtual 
 * Machine contexts. 
 * 
 * **The `node:vm` module is not a security** 
 * **mechanism. Do not use it to run untrusted code.** 
 * 
 * JavaScript code can be compiled and run immediately or 
 * compiled, saved, and run later. 
 * 
 * A common use case is to run the code in a different V8 Context. This means 
 * invoked code has a different global object than the invoking code. 
 * 
 * One can provide the context by `contextifying` an 
 * object. The invoked code treats any property in the context like a 
 * global variable. Any changes to global variables caused by the invoked 
 * code are reflected in the context object. 
 * 
 * ```js 
 * const vm = require('node:vm'); 
 * 
 * const x = 1; 
 * 
 * const context = { x: 2 }; 
 * vm.createContext(context); // Contextify the object. 
 * 
 * const code = 'x += 40; var y = 17;'; 
 * // `x` and `y` are global variables in the context. 
 * // Initially, x has the value 2 because that is the value of context.x. 
 * vm.runInContext(code, context); 
 * 
 * console.log(context.x); // 42 
 * console.log(context.y); // 17 
 * 
 * console.log(x); // 1; y is not defined. 
 * ``` 
 * </span><span class="s1">@see </span><span class="s2">[source](https:</span><span class="s0">//github.com/nodejs/node/blob/v20.2.0/lib/vm.js) 
 */</span>
<span class="s1">declare module </span><span class="s4">'vm' </span><span class="s3">{</span>
    <span class="s1">interface </span><span class="s2">Context </span><span class="s1">extends </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">Dict</span><span class="s3">&lt;</span><span class="s2">any</span><span class="s3">&gt; {}</span>
    <span class="s1">interface </span><span class="s2">BaseOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Specifies the filename used in stack traces produced by this script. 
         * Default: `''`. 
         */</span>
        <span class="s3">filename</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Specifies the line number offset that is displayed in stack traces produced by this script. 
         * Default: `0`. 
         */</span>
        <span class="s3">lineOffset</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Specifies the column number offset that is displayed in stack traces produced by this script. 
         * </span><span class="s1">@default </span><span class="s2">0</span>
         <span class="s0">*/</span>
        <span class="s3">columnOffset</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">ScriptOptions </span><span class="s1">extends </span><span class="s2">BaseOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* V8's code cache data for the supplied source. 
         */</span>
        <span class="s3">cachedData</span><span class="s1">?: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">ArrayBufferView </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/** </span><span class="s1">@deprecated </span><span class="s0">in favor of `script.createCachedData()` */</span>
        <span class="s3">produceCachedData</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Called during evaluation of this module when `import()` is called. 
         * If this option is not specified, calls to `import()` will reject with `ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING`. 
         */</span>
        <span class="s3">importModuleDynamically</span><span class="s1">?: </span><span class="s3">((</span><span class="s2">specifier</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">script</span><span class="s1">: </span><span class="s2">Script</span><span class="s3">, </span><span class="s2">importAssertions</span><span class="s1">: </span><span class="s2">Object</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">Module</span><span class="s3">) </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">RunningScriptOptions </span><span class="s1">extends </span><span class="s2">BaseOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* When `true`, if an `Error` occurs while compiling the `code`, the line of code causing the error is attached to the stack trace. 
         * Default: `true`. 
         */</span>
        <span class="s3">displayErrors</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Specifies the number of milliseconds to execute code before terminating execution. 
         * If execution is terminated, an `Error` will be thrown. This value must be a strictly positive integer. 
         */</span>
        <span class="s3">timeout</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If `true`, the execution will be terminated when `SIGINT` (Ctrl+C) is received. 
         * Existing handlers for the event that have been attached via `process.on('SIGINT')` will be disabled during script execution, but will continue to work after that. 
         * If execution is terminated, an `Error` will be thrown. 
         * Default: `false`. 
         */</span>
        <span class="s3">breakOnSigint</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">RunningScriptInNewContextOptions </span><span class="s1">extends </span><span class="s2">RunningScriptOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Human-readable name of the newly created context. 
         */</span>
        <span class="s3">contextName</span><span class="s1">?: </span><span class="s2">CreateContextOptions</span><span class="s3">[</span><span class="s4">'name'</span><span class="s3">];</span>
        <span class="s0">/**</span>
         <span class="s0">* Origin corresponding to the newly created context for display purposes. The origin should be formatted like a URL, 
         * but with only the scheme, host, and port (if necessary), like the value of the `url.origin` property of a `URL` object. 
         * Most notably, this string should omit the trailing slash, as that denotes a path. 
         */</span>
        <span class="s3">contextOrigin</span><span class="s1">?: </span><span class="s2">CreateContextOptions</span><span class="s3">[</span><span class="s4">'origin'</span><span class="s3">];</span>
        <span class="s3">contextCodeGeneration</span><span class="s1">?: </span><span class="s2">CreateContextOptions</span><span class="s3">[</span><span class="s4">'codeGeneration'</span><span class="s3">];</span>
        <span class="s0">/**</span>
         <span class="s0">* If set to `afterEvaluate`, microtasks will be run immediately after the script has run. 
         */</span>
        <span class="s3">microtaskMode</span><span class="s1">?: </span><span class="s2">CreateContextOptions</span><span class="s3">[</span><span class="s4">'microtaskMode'</span><span class="s3">];</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">RunningCodeOptions </span><span class="s1">extends </span><span class="s2">RunningScriptOptions </span><span class="s3">{</span>
        <span class="s3">cachedData</span><span class="s1">?: </span><span class="s2">ScriptOptions</span><span class="s3">[</span><span class="s4">'cachedData'</span><span class="s3">];</span>
        <span class="s3">importModuleDynamically</span><span class="s1">?: </span><span class="s2">ScriptOptions</span><span class="s3">[</span><span class="s4">'importModuleDynamically'</span><span class="s3">];</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">RunningCodeInNewContextOptions </span><span class="s1">extends </span><span class="s2">RunningScriptInNewContextOptions </span><span class="s3">{</span>
        <span class="s3">cachedData</span><span class="s1">?: </span><span class="s2">ScriptOptions</span><span class="s3">[</span><span class="s4">'cachedData'</span><span class="s3">];</span>
        <span class="s3">importModuleDynamically</span><span class="s1">?: </span><span class="s2">ScriptOptions</span><span class="s3">[</span><span class="s4">'importModuleDynamically'</span><span class="s3">];</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">CompileFunctionOptions </span><span class="s1">extends </span><span class="s2">BaseOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Provides an optional data with V8's code cache data for the supplied source. 
         */</span>
        <span class="s3">cachedData</span><span class="s1">?: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Specifies whether to produce new cache data. 
         * Default: `false`, 
         */</span>
        <span class="s3">produceCachedData</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The sandbox/context in which the said function should be compiled in. 
         */</span>
        <span class="s3">parsingContext</span><span class="s1">?: </span><span class="s2">Context </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An array containing a collection of context extensions (objects wrapping the current scope) to be applied while compiling 
         */</span>
        <span class="s3">contextExtensions</span><span class="s1">?: </span><span class="s2">Object</span><span class="s3">[] </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">CreateContextOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Human-readable name of the newly created context. 
         * </span><span class="s1">@default </span><span class="s2">'VM Context i' </span><span class="s0">Where i is an ascending numerical index of the created context. 
         */</span>
        <span class="s3">name</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Corresponds to the newly created context for display purposes. 
         * The origin should be formatted like a `URL`, but with only the scheme, host, and port (if necessary), 
         * like the value of the `url.origin` property of a URL object. 
         * Most notably, this string should omit the trailing slash, as that denotes a path. 
         * </span><span class="s1">@default </span><span class="s2">''</span>
         <span class="s0">*/</span>
        <span class="s3">origin</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">codeGeneration</span><span class="s1">?:</span>
            <span class="s1">| </span><span class="s3">{</span>
                  <span class="s0">/**</span>
                   <span class="s0">* If set to false any calls to eval or function constructors (Function, GeneratorFunction, etc) 
                   * will throw an EvalError. 
                   * </span><span class="s1">@default </span><span class="s2">true</span>
                   <span class="s0">*/</span>
                  <span class="s3">strings</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
                  <span class="s0">/**</span>
                   <span class="s0">* If set to false any attempt to compile a WebAssembly module will throw a WebAssembly.CompileError. 
                   * </span><span class="s1">@default </span><span class="s2">true</span>
                   <span class="s0">*/</span>
                  <span class="s3">wasm</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
              <span class="s3">}</span>
            <span class="s1">| </span><span class="s3">undefined;</span>
        <span class="s0">/**</span>
         <span class="s0">* If set to `afterEvaluate`, microtasks will be run immediately after the script has run. 
         */</span>
        <span class="s3">microtaskMode</span><span class="s1">?: </span><span class="s4">'afterEvaluate' </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">type </span><span class="s2">MeasureMemoryMode </span><span class="s1">= </span><span class="s4">'summary' </span><span class="s1">| </span><span class="s4">'detailed'</span><span class="s3">;</span>
    <span class="s1">interface </span><span class="s2">MeasureMemoryOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s2">'summary'</span>
         <span class="s0">*/</span>
        <span class="s3">mode</span><span class="s1">?: </span><span class="s2">MeasureMemoryMode </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s2">'default'</span>
         <span class="s0">*/</span>
        <span class="s3">execution</span><span class="s1">?: </span><span class="s4">'default' </span><span class="s1">| </span><span class="s4">'eager' </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">MemoryMeasurement </span><span class="s3">{</span>
        <span class="s3">total</span><span class="s1">: </span><span class="s3">{</span>
            <span class="s3">jsMemoryEstimate</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s3">jsMemoryRange</span><span class="s1">: </span><span class="s3">[</span><span class="s2">number</span><span class="s3">, </span><span class="s2">number</span><span class="s3">];</span>
        <span class="s3">};</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Instances of the `vm.Script` class contain precompiled scripts that can be 
     * executed in specific contexts. 
     * </span><span class="s1">@since </span><span class="s0">v0.3.1 
     */</span>
    <span class="s1">class </span><span class="s2">Script </span><span class="s3">{</span>
        <span class="s1">constructor</span><span class="s3">(</span><span class="s2">code</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">ScriptOptions </span><span class="s1">| </span><span class="s2">string</span><span class="s3">);</span>
        <span class="s0">/**</span>
         <span class="s0">* Runs the compiled code contained by the `vm.Script` object within the given`contextifiedObject` and returns the result. Running code does not have access 
         * to local scope. 
         * 
         * The following example compiles code that increments a global variable, sets 
         * the value of another global variable, then execute the code multiple times. 
         * The globals are contained in the `context` object. 
         * 
         * ```js 
         * const vm = require('node:vm'); 
         * 
         * const context = { 
         *   animal: 'cat', 
         *   count: 2, 
         * }; 
         * 
         * const script = new vm.Script('count += 1; name = &quot;kitty&quot;;'); 
         * 
         * vm.createContext(context); 
         * for (let i = 0; i &lt; 10; ++i) { 
         *   script.runInContext(context); 
         * } 
         * 
         * console.log(context); 
         * // Prints: { animal: 'cat', count: 12, name: 'kitty' } 
         * ``` 
         * 
         * Using the `timeout` or `breakOnSigint` options will result in new event loops 
         * and corresponding threads being started, which have a non-zero performance 
         * overhead. 
         * </span><span class="s1">@since </span><span class="s0">v0.3.1 
         * </span><span class="s1">@param </span><span class="s2">contextifiedObject </span><span class="s0">A `contextified` object as returned by the `vm.createContext()` method. 
         * </span><span class="s1">@return </span><span class="s0">the result of the very last statement executed in the script. 
         */</span>
        <span class="s3">runInContext(</span><span class="s2">contextifiedObject</span><span class="s1">: </span><span class="s2">Context</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">RunningScriptOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">any</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* First contextifies the given `contextObject`, runs the compiled code contained 
         * by the `vm.Script` object within the created context, and returns the result. 
         * Running code does not have access to local scope. 
         * 
         * The following example compiles code that sets a global variable, then executes 
         * the code multiple times in different contexts. The globals are set on and 
         * contained within each individual `context`. 
         * 
         * ```js 
         * const vm = require('node:vm'); 
         * 
         * const script = new vm.Script('globalVar = &quot;set&quot;'); 
         * 
         * const contexts = [{}, {}, {}]; 
         * contexts.forEach((context) =&gt; { 
         *   script.runInNewContext(context); 
         * }); 
         * 
         * console.log(contexts); 
         * // Prints: [{ globalVar: 'set' }, { globalVar: 'set' }, { globalVar: 'set' }] 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v0.3.1 
         * </span><span class="s1">@param </span><span class="s2">contextObject </span><span class="s0">An object that will be `contextified`. If `undefined`, a new object will be created. 
         * </span><span class="s1">@return </span><span class="s0">the result of the very last statement executed in the script. 
         */</span>
        <span class="s3">runInNewContext(</span><span class="s2">contextObject</span><span class="s1">?: </span><span class="s2">Context</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">RunningScriptInNewContextOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">any</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Runs the compiled code contained by the `vm.Script` within the context of the 
         * current `global` object. Running code does not have access to local scope, but _does_ have access to the current `global` object. 
         * 
         * The following example compiles code that increments a `global` variable then 
         * executes that code multiple times: 
         * 
         * ```js 
         * const vm = require('node:vm'); 
         * 
         * global.globalVar = 0; 
         * 
         * const script = new vm.Script('globalVar += 1', { filename: 'myfile.vm' }); 
         * 
         * for (let i = 0; i &lt; 1000; ++i) { 
         *   script.runInThisContext(); 
         * } 
         * 
         * console.log(globalVar); 
         * 
         * // 1000 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v0.3.1 
         * </span><span class="s1">@return </span><span class="s0">the result of the very last statement executed in the script. 
         */</span>
        <span class="s3">runInThisContext(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">RunningScriptOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">any</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Creates a code cache that can be used with the `Script` constructor's`cachedData` option. Returns a `Buffer`. This method may be called at any 
         * time and any number of times. 
         * 
         * The code cache of the `Script` doesn't contain any JavaScript observable 
         * states. The code cache is safe to be saved along side the script source and 
         * used to construct new `Script` instances multiple times. 
         * 
         * Functions in the `Script` source can be marked as lazily compiled and they are 
         * not compiled at construction of the `Script`. These functions are going to be 
         * compiled when they are invoked the first time. The code cache serializes the 
         * metadata that V8 currently knows about the `Script` that it can use to speed up 
         * future compilations. 
         * 
         * ```js 
         * const script = new vm.Script(` 
         * function add(a, b) { 
         *   return a + b; 
         * } 
         * 
         * const x = add(1, 2); 
         * `); 
         * 
         * const cacheWithoutAdd = script.createCachedData(); 
         * // In `cacheWithoutAdd` the function `add()` is marked for full compilation 
         * // upon invocation. 
         * 
         * script.runInThisContext(); 
         * 
         * const cacheWithAdd = script.createCachedData(); 
         * // `cacheWithAdd` contains fully compiled function `add()`. 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v10.6.0 
         */</span>
        <span class="s3">createCachedData()</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
        <span class="s0">/** </span><span class="s1">@deprecated </span><span class="s0">in favor of `script.createCachedData()` */</span>
        <span class="s3">cachedDataProduced</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* When `cachedData` is supplied to create the `vm.Script`, this value will be set 
         * to either `true` or `false` depending on acceptance of the data by V8\. 
         * Otherwise the value is `undefined`. 
         * </span><span class="s1">@since </span><span class="s0">v5.7.0 
         */</span>
        <span class="s3">cachedDataRejected</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">cachedData</span><span class="s1">?: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* When the script is compiled from a source that contains a source map magic 
         * comment, this property will be set to the URL of the source map. 
         * 
         * ```js 
         * import vm from 'node:vm'; 
         * 
         * const script = new vm.Script(` 
         * function myFunc() {} 
         * //# sourceMappingURL=sourcemap.json 
         * `); 
         * 
         * console.log(script.sourceMapURL); 
         * // Prints: sourcemap.json 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0 
         */</span>
        <span class="s3">sourceMapURL</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* If given a `contextObject`, the `vm.createContext()` method will `prepare 
     * that object` so that it can be used in calls to </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">runInContext} </span><span class="s0">or `script.runInContext()`. Inside such scripts, 
     * the `contextObject` will be the global object, retaining all of its existing 
     * properties but also having the built-in objects and functions any standard [global object](https://es5.github.io/#x15.1) has. Outside of scripts run by the vm module, global variables 
     * will remain unchanged. 
     * 
     * ```js 
     * const vm = require('node:vm'); 
     * 
     * global.globalVar = 3; 
     * 
     * const context = { globalVar: 1 }; 
     * vm.createContext(context); 
     * 
     * vm.runInContext('globalVar *= 2;', context); 
     * 
     * console.log(context); 
     * // Prints: { globalVar: 2 } 
     * 
     * console.log(global.globalVar); 
     * // Prints: 3 
     * ``` 
     * 
     * If `contextObject` is omitted (or passed explicitly as `undefined`), a new, 
     * empty `contextified` object will be returned. 
     * 
     * The `vm.createContext()` method is primarily useful for creating a single 
     * context that can be used to run multiple scripts. For instance, if emulating a 
     * web browser, the method can be used to create a single context representing a 
     * window's global object, then run all `&lt;script&gt;` tags together within that 
     * context. 
     * 
     * The provided `name` and `origin` of the context are made visible through the 
     * Inspector API. 
     * </span><span class="s1">@since </span><span class="s0">v0.3.1 
     * </span><span class="s1">@return </span><span class="s0">contextified object. 
     */</span>
    <span class="s1">function </span><span class="s3">createContext(</span><span class="s2">sandbox</span><span class="s1">?: </span><span class="s2">Context</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">CreateContextOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Context</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns `true` if the given `object` object has been `contextified` using </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">createContext}</span><span class="s0">. 
     * </span><span class="s1">@since </span><span class="s0">v0.11.7 
     */</span>
    <span class="s1">function </span><span class="s3">isContext(</span><span class="s2">sandbox</span><span class="s1">: </span><span class="s2">Context</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `vm.runInContext()` method compiles `code`, runs it within the context of 
     * the `contextifiedObject`, then returns the result. Running code does not have 
     * access to the local scope. The `contextifiedObject` object _must_ have been 
     * previously `contextified` using the </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">createContext} </span><span class="s0">method. 
     * 
     * If `options` is a string, then it specifies the filename. 
     * 
     * The following example compiles and executes different scripts using a single `contextified` object: 
     * 
     * ```js 
     * const vm = require('node:vm'); 
     * 
     * const contextObject = { globalVar: 1 }; 
     * vm.createContext(contextObject); 
     * 
     * for (let i = 0; i &lt; 10; ++i) { 
     *   vm.runInContext('globalVar *= 2;', contextObject); 
     * } 
     * console.log(contextObject); 
     * // Prints: { globalVar: 1024 } 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v0.3.1 
     * </span><span class="s1">@param </span><span class="s2">code </span><span class="s0">The JavaScript code to compile and run. 
     * </span><span class="s1">@param </span><span class="s2">contextifiedObject </span><span class="s0">The `contextified` object that will be used as the `global` when the `code` is compiled and run. 
     * </span><span class="s1">@return </span><span class="s0">the result of the very last statement executed in the script. 
     */</span>
    <span class="s1">function </span><span class="s3">runInContext(</span><span class="s2">code</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">contextifiedObject</span><span class="s1">: </span><span class="s2">Context</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">RunningCodeOptions </span><span class="s1">| </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">any</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `vm.runInNewContext()` first contextifies the given `contextObject` (or 
     * creates a new `contextObject` if passed as `undefined`), compiles the `code`, 
     * runs it within the created context, then returns the result. Running code 
     * does not have access to the local scope. 
     * 
     * If `options` is a string, then it specifies the filename. 
     * 
     * The following example compiles and executes code that increments a global 
     * variable and sets a new one. These globals are contained in the `contextObject`. 
     * 
     * ```js 
     * const vm = require('node:vm'); 
     * 
     * const contextObject = { 
     *   animal: 'cat', 
     *   count: 2, 
     * }; 
     * 
     * vm.runInNewContext('count += 1; name = &quot;kitty&quot;', contextObject); 
     * console.log(contextObject); 
     * // Prints: { animal: 'cat', count: 3, name: 'kitty' } 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v0.3.1 
     * </span><span class="s1">@param </span><span class="s2">code </span><span class="s0">The JavaScript code to compile and run. 
     * </span><span class="s1">@param </span><span class="s2">contextObject </span><span class="s0">An object that will be `contextified`. If `undefined`, a new object will be created. 
     * </span><span class="s1">@return </span><span class="s0">the result of the very last statement executed in the script. 
     */</span>
    <span class="s1">function </span><span class="s3">runInNewContext(</span><span class="s2">code</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">contextObject</span><span class="s1">?: </span><span class="s2">Context</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">RunningCodeInNewContextOptions </span><span class="s1">| </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">any</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* `vm.runInThisContext()` compiles `code`, runs it within the context of the 
     * current `global` and returns the result. Running code does not have access to 
     * local scope, but does have access to the current `global` object. 
     * 
     * If `options` is a string, then it specifies the filename. 
     * 
     * The following example illustrates using both `vm.runInThisContext()` and 
     * the JavaScript [`eval()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval) function to run the same code: 
     * 
     * ```js 
     * const vm = require('node:vm'); 
     * let localVar = 'initial value'; 
     * 
     * const vmResult = vm.runInThisContext('localVar = &quot;vm&quot;;'); 
     * console.log(`vmResult: '${vmResult}', localVar: '${localVar}'`); 
     * // Prints: vmResult: 'vm', localVar: 'initial value' 
     * 
     * const evalResult = eval('localVar = &quot;eval&quot;;'); 
     * console.log(`evalResult: '${evalResult}', localVar: '${localVar}'`); 
     * // Prints: evalResult: 'eval', localVar: 'eval' 
     * ``` 
     * 
     * Because `vm.runInThisContext()` does not have access to the local scope,`localVar` is unchanged. In contrast, 
     * [`eval()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval) _does_ have access to the 
     * local scope, so the value `localVar` is changed. In this way`vm.runInThisContext()` is much like an [indirect `eval()` call](https://es5.github.io/#x10.4.2), e.g.`(0,eval)('code')`. 
     * 
     * ## Example: Running an HTTP server within a VM 
     * 
     * When using either `script.runInThisContext()` or </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">runInThisContext}</span><span class="s0">, the code is executed within the current V8 global 
     * context. The code passed to this VM context will have its own isolated scope. 
     * 
     * In order to run a simple web server using the `node:http` module the code passed 
     * to the context must either call `require('node:http')` on its own, or have a 
     * reference to the `node:http` module passed to it. For instance: 
     * 
     * ```js 
     * 'use strict'; 
     * const vm = require('node:vm'); 
     * 
     * const code = ` 
     * ((require) =&gt; { 
     *   const http = require('node:http'); 
     * 
     *   http.createServer((request, response) =&gt; { 
     *     response.writeHead(200, { 'Content-Type': 'text/plain' }); 
     *     response.end('Hello World\\n'); 
     *   }).listen(8124); 
     * 
     *   console.log('Server running at http://127.0.0.1:8124/'); 
     * })`; 
     * 
     * vm.runInThisContext(code)(require); 
     * ``` 
     * 
     * The `require()` in the above case shares the state with the context it is 
     * passed from. This may introduce risks when untrusted code is executed, e.g. 
     * altering objects in the context in unwanted ways. 
     * </span><span class="s1">@since </span><span class="s0">v0.3.1 
     * </span><span class="s1">@param </span><span class="s2">code </span><span class="s0">The JavaScript code to compile and run. 
     * </span><span class="s1">@return </span><span class="s0">the result of the very last statement executed in the script. 
     */</span>
    <span class="s1">function </span><span class="s3">runInThisContext(</span><span class="s2">code</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">RunningCodeOptions </span><span class="s1">| </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">any</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Compiles the given code into the provided context (if no context is 
     * supplied, the current context is used), and returns it wrapped inside a 
     * function with the given `params`. 
     * </span><span class="s1">@since </span><span class="s0">v10.10.0 
     * </span><span class="s1">@param </span><span class="s2">code </span><span class="s0">The body of the function to compile. 
     * </span><span class="s1">@param </span><span class="s2">params </span><span class="s0">An array of strings containing all parameters for the function. 
     */</span>
    <span class="s1">function </span><span class="s3">compileFunction(</span>
        <span class="s2">code</span><span class="s1">: </span><span class="s2">string</span><span class="s3">,</span>
        <span class="s2">params</span><span class="s1">?: </span><span class="s2">ReadonlyArray</span><span class="s3">&lt;</span><span class="s2">string</span><span class="s3">&gt;,</span>
        <span class="s2">options</span><span class="s1">?: </span><span class="s2">CompileFunctionOptions</span>
    <span class="s3">)</span><span class="s1">: </span><span class="s2">Function </span><span class="s1">&amp; </span><span class="s3">{</span>
        <span class="s3">cachedData</span><span class="s1">?: </span><span class="s2">Script</span><span class="s3">[</span><span class="s4">'cachedData'</span><span class="s3">] </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">cachedDataProduced</span><span class="s1">?: </span><span class="s2">Script</span><span class="s3">[</span><span class="s4">'cachedDataProduced'</span><span class="s3">] </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">cachedDataRejected</span><span class="s1">?: </span><span class="s2">Script</span><span class="s3">[</span><span class="s4">'cachedDataRejected'</span><span class="s3">] </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}; 
    </span><span class="s0">/**</span>
     <span class="s0">* Measure the memory known to V8 and used by all contexts known to the 
     * current V8 isolate, or the main context. 
     * 
     * The format of the object that the returned Promise may resolve with is 
     * specific to the V8 engine and may change from one version of V8 to the next. 
     * 
     * The returned result is different from the statistics returned by`v8.getHeapSpaceStatistics()` in that `vm.measureMemory()` measure the 
     * memory reachable by each V8 specific contexts in the current instance of 
     * the V8 engine, while the result of `v8.getHeapSpaceStatistics()` measure 
     * the memory occupied by each heap space in the current V8 instance. 
     * 
     * ```js 
     * const vm = require('node:vm'); 
     * // Measure the memory used by the main context. 
     * vm.measureMemory({ mode: 'summary' }) 
     *   // This is the same as vm.measureMemory() 
     *   .then((result) =&gt; { 
     *     // The current format is: 
     *     // { 
     *     //   total: { 
     *     //      jsMemoryEstimate: 2418479, jsMemoryRange: [ 2418479, 2745799 ] 
     *     //    } 
     *     // } 
     *     console.log(result); 
     *   }); 
     * 
     * const context = vm.createContext({ a: 1 }); 
     * vm.measureMemory({ mode: 'detailed', execution: 'eager' }) 
     *   .then((result) =&gt; { 
     *     // Reference the context here so that it won't be GC'ed 
     *     // until the measurement is complete. 
     *     console.log(context.a); 
     *     // { 
     *     //   total: { 
     *     //     jsMemoryEstimate: 2574732, 
     *     //     jsMemoryRange: [ 2574732, 2904372 ] 
     *     //   }, 
     *     //   current: { 
     *     //     jsMemoryEstimate: 2438996, 
     *     //     jsMemoryRange: [ 2438996, 2768636 ] 
     *     //   }, 
     *     //   other: [ 
     *     //     { 
     *     //       jsMemoryEstimate: 135736, 
     *     //       jsMemoryRange: [ 135736, 465376 ] 
     *     //     } 
     *     //   ] 
     *     // } 
     *     console.log(result); 
     *   }); 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v13.10.0 
     * </span><span class="s1">@experimental</span>
     <span class="s0">*/</span>
    <span class="s3">function measureMemory(options?: MeasureMemoryOptions): Promise&lt;MemoryMeasurement&gt;; 
    </span><span class="s1">interface </span><span class="s2">ModuleEvaluateOptions </span><span class="s3">{</span>
        <span class="s3">timeout</span><span class="s1">?: </span><span class="s2">RunningScriptOptions</span><span class="s3">[</span><span class="s4">'timeout'</span><span class="s3">] </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">breakOnSigint</span><span class="s1">?: </span><span class="s2">RunningScriptOptions</span><span class="s3">[</span><span class="s4">'breakOnSigint'</span><span class="s3">] </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">type </span><span class="s2">ModuleLinker </span><span class="s1">= </span><span class="s3">(</span>
        <span class="s2">specifier</span><span class="s1">: </span><span class="s2">string</span><span class="s3">,</span>
        <span class="s2">referencingModule</span><span class="s1">: </span><span class="s2">Module</span><span class="s3">,</span>
        <span class="s2">extra</span><span class="s1">: </span><span class="s3">{</span>
            <span class="s3">assert</span><span class="s1">: </span><span class="s2">Object</span><span class="s3">;</span>
        <span class="s3">}</span>
    <span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">Module </span><span class="s1">| </span><span class="s2">Promise</span><span class="s3">&lt;</span><span class="s2">Module</span><span class="s3">&gt;;</span>
    <span class="s1">type </span><span class="s2">ModuleStatus </span><span class="s1">= </span><span class="s4">'unlinked' </span><span class="s1">| </span><span class="s4">'linking' </span><span class="s1">| </span><span class="s4">'linked' </span><span class="s1">| </span><span class="s4">'evaluating' </span><span class="s1">| </span><span class="s4">'evaluated' </span><span class="s1">| </span><span class="s4">'errored'</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This feature is only available with the `--experimental-vm-modules` command 
     * flag enabled. 
     * 
     * The `vm.Module` class provides a low-level interface for using 
     * ECMAScript modules in VM contexts. It is the counterpart of the `vm.Script`class that closely mirrors [Module Record](https://www.ecma-international.org/ecma-262/#sec-abstract-module-records) 
     * s as defined in the ECMAScript 
     * specification. 
     * 
     * Unlike `vm.Script` however, every `vm.Module` object is bound to a context from 
     * its creation. Operations on `vm.Module` objects are intrinsically asynchronous, 
     * in contrast with the synchronous nature of `vm.Script` objects. The use of 
     * 'async' functions can help with manipulating `vm.Module` objects. 
     * 
     * Using a `vm.Module` object requires three distinct steps: creation/parsing, 
     * linking, and evaluation. These three steps are illustrated in the following 
     * example. 
     * 
     * This implementation lies at a lower level than the `ECMAScript Module 
     * loader`. There is also no way to interact with the Loader yet, though 
     * support is planned. 
     * 
     * ```js 
     * import vm from 'node:vm'; 
     * 
     * const contextifiedObject = vm.createContext({ 
     *   secret: 42, 
     *   print: console.log, 
     * }); 
     * 
     * // Step 1 
     * // 
     * // Create a Module by constructing a new `vm.SourceTextModule` object. This 
     * // parses the provided source text, throwing a `SyntaxError` if anything goes 
     * // wrong. By default, a Module is created in the top context. But here, we 
     * // specify `contextifiedObject` as the context this Module belongs to. 
     * // 
     * // Here, we attempt to obtain the default export from the module &quot;foo&quot;, and 
     * // put it into local binding &quot;secret&quot;. 
     * 
     * const bar = new vm.SourceTextModule(` 
     *   import s from 'foo'; 
     *   s; 
     *   print(s); 
     * `, { context: contextifiedObject }); 
     * 
     * // Step 2 
     * // 
     * // &quot;Link&quot; the imported dependencies of this Module to it. 
     * // 
     * // The provided linking callback (the &quot;linker&quot;) accepts two arguments: the 
     * // parent module (`bar` in this case) and the string that is the specifier of 
     * // the imported module. The callback is expected to return a Module that 
     * // corresponds to the provided specifier, with certain requirements documented 
     * // in `module.link()`. 
     * // 
     * // If linking has not started for the returned Module, the same linker 
     * // callback will be called on the returned Module. 
     * // 
     * // Even top-level Modules without dependencies must be explicitly linked. The 
     * // callback provided would never be called, however. 
     * // 
     * // The link() method returns a Promise that will be resolved when all the 
     * // Promises returned by the linker resolve. 
     * // 
     * // Note: This is a contrived example in that the linker function creates a new 
     * // &quot;foo&quot; module every time it is called. In a full-fledged module system, a 
     * // cache would probably be used to avoid duplicated modules. 
     * 
     * async function linker(specifier, referencingModule) { 
     *   if (specifier === 'foo') { 
     *     return new vm.SourceTextModule(` 
     *       // The &quot;secret&quot; variable refers to the global variable we added to 
     *       // &quot;contextifiedObject&quot; when creating the context. 
     *       export default secret; 
     *     `, { context: referencingModule.context }); 
     * 
     *     // Using `contextifiedObject` instead of `referencingModule.context` 
     *     // here would work as well. 
     *   } 
     *   throw new Error(`Unable to resolve dependency: ${specifier}`); 
     * } 
     * await bar.link(linker); 
     * 
     * // Step 3 
     * // 
     * // Evaluate the Module. The evaluate() method returns a promise which will 
     * // resolve after the module has finished evaluating. 
     * 
     * // Prints 42. 
     * await bar.evaluate(); 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v13.0.0, v12.16.0 
     * </span><span class="s1">@experimental</span>
     <span class="s0">*/</span>
    <span class="s1">class </span><span class="s2">Module </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The specifiers of all dependencies of this module. The returned array is frozen 
         * to disallow any changes to it. 
         * 
         * Corresponds to the `[[RequestedModules]]` field of [Cyclic Module Record](https://tc39.es/ecma262/#sec-cyclic-module-records) s in 
         * the ECMAScript specification. 
         */</span>
        <span class="s3">dependencySpecifiers</span><span class="s1">: readonly </span><span class="s2">string</span><span class="s3">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* If the `module.status` is `'errored'`, this property contains the exception 
         * thrown by the module during evaluation. If the status is anything else, 
         * accessing this property will result in a thrown exception. 
         * 
         * The value `undefined` cannot be used for cases where there is not a thrown 
         * exception due to possible ambiguity with `throw undefined;`. 
         * 
         * Corresponds to the `[[EvaluationError]]` field of [Cyclic Module Record](https://tc39.es/ecma262/#sec-cyclic-module-records) s 
         * in the ECMAScript specification. 
         */</span>
        <span class="s3">error</span><span class="s1">: </span><span class="s2">any</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The identifier of the current module, as set in the constructor. 
         */</span>
        <span class="s3">identifier</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s3">context</span><span class="s1">: </span><span class="s2">Context</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The namespace object of the module. This is only available after linking 
         * (`module.link()`) has completed. 
         * 
         * Corresponds to the [GetModuleNamespace](https://tc39.es/ecma262/#sec-getmodulenamespace) abstract operation in the ECMAScript 
         * specification. 
         */</span>
        <span class="s3">namespace</span><span class="s1">: </span><span class="s2">Object</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The current status of the module. Will be one of: 
         * 
         * * `'unlinked'`: `module.link()` has not yet been called. 
         * * `'linking'`: `module.link()` has been called, but not all Promises returned 
         * by the linker function have been resolved yet. 
         * * `'linked'`: The module has been linked successfully, and all of its 
         * dependencies are linked, but `module.evaluate()` has not yet been called. 
         * * `'evaluating'`: The module is being evaluated through a `module.evaluate()` on 
         * itself or a parent module. 
         * * `'evaluated'`: The module has been successfully evaluated. 
         * * `'errored'`: The module has been evaluated, but an exception was thrown. 
         * 
         * Other than `'errored'`, this status string corresponds to the specification's [Cyclic Module Record](https://tc39.es/ecma262/#sec-cyclic-module-records)'s `[[Status]]` field. `'errored'` 
         * corresponds to`'evaluated'` in the specification, but with `[[EvaluationError]]` set to a 
         * value that is not `undefined`. 
         */</span>
        <span class="s3">status</span><span class="s1">: </span><span class="s2">ModuleStatus</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Evaluate the module. 
         * 
         * This must be called after the module has been linked; otherwise it will reject. 
         * It could be called also when the module has already been evaluated, in which 
         * case it will either do nothing if the initial evaluation ended in success 
         * (`module.status` is `'evaluated'`) or it will re-throw the exception that the 
         * initial evaluation resulted in (`module.status` is `'errored'`). 
         * 
         * This method cannot be called while the module is being evaluated 
         * (`module.status` is `'evaluating'`). 
         * 
         * Corresponds to the [Evaluate() concrete method](https://tc39.es/ecma262/#sec-moduleevaluation) field of [Cyclic Module Record](https://tc39.es/ecma262/#sec-cyclic-module-records) s in the 
         * ECMAScript specification. 
         * </span><span class="s1">@return </span><span class="s0">Fulfills with `undefined` upon success. 
         */</span>
        <span class="s3">evaluate(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">ModuleEvaluateOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Promise</span><span class="s3">&lt;</span><span class="s2">void</span><span class="s3">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Link module dependencies. This method must be called before evaluation, and 
         * can only be called once per module. 
         * 
         * The function is expected to return a `Module` object or a `Promise` that 
         * eventually resolves to a `Module` object. The returned `Module` must satisfy the 
         * following two invariants: 
         * 
         * * It must belong to the same context as the parent `Module`. 
         * * Its `status` must not be `'errored'`. 
         * 
         * If the returned `Module`'s `status` is `'unlinked'`, this method will be 
         * recursively called on the returned `Module` with the same provided `linker`function. 
         * 
         * `link()` returns a `Promise` that will either get resolved when all linking 
         * instances resolve to a valid `Module`, or rejected if the linker function either 
         * throws an exception or returns an invalid `Module`. 
         * 
         * The linker function roughly corresponds to the implementation-defined [HostResolveImportedModule](https://tc39.es/ecma262/#sec-hostresolveimportedmodule) abstract operation in the 
         * ECMAScript 
         * specification, with a few key differences: 
         * 
         * * The linker function is allowed to be asynchronous while [HostResolveImportedModule](https://tc39.es/ecma262/#sec-hostresolveimportedmodule) is synchronous. 
         * 
         * The actual [HostResolveImportedModule](https://tc39.es/ecma262/#sec-hostresolveimportedmodule) implementation used during module 
         * linking is one that returns the modules linked during linking. Since at 
         * that point all modules would have been fully linked already, the [HostResolveImportedModule](https://tc39.es/ecma262/#sec-hostresolveimportedmodule) implementation is fully synchronous per 
         * specification. 
         * 
         * Corresponds to the [Link() concrete method](https://tc39.es/ecma262/#sec-moduledeclarationlinking) field of [Cyclic Module Record](https://tc39.es/ecma262/#sec-cyclic-module-records) s in 
         * the ECMAScript specification. 
         */</span>
        <span class="s3">link(</span><span class="s2">linker</span><span class="s1">: </span><span class="s2">ModuleLinker</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Promise</span><span class="s3">&lt;</span><span class="s2">void</span><span class="s3">&gt;;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">SourceTextModuleOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* String used in stack traces. 
         * </span><span class="s1">@default </span><span class="s2">'vm:module(i)' </span><span class="s0">where i is a context-specific ascending index. 
         */</span>
        <span class="s3">identifier</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">cachedData</span><span class="s1">?: </span><span class="s2">ScriptOptions</span><span class="s3">[</span><span class="s4">'cachedData'</span><span class="s3">] </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">context</span><span class="s1">?: </span><span class="s2">Context </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">lineOffset</span><span class="s1">?: </span><span class="s2">BaseOptions</span><span class="s3">[</span><span class="s4">'lineOffset'</span><span class="s3">] </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">columnOffset</span><span class="s1">?: </span><span class="s2">BaseOptions</span><span class="s3">[</span><span class="s4">'columnOffset'</span><span class="s3">] </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Called during evaluation of this module to initialize the `import.meta`. 
         */</span>
        <span class="s3">initializeImportMeta</span><span class="s1">?: </span><span class="s3">((</span><span class="s2">meta</span><span class="s1">: </span><span class="s2">ImportMeta</span><span class="s3">, </span><span class="s2">module</span><span class="s1">: </span><span class="s2">SourceTextModule</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">importModuleDynamically</span><span class="s1">?: </span><span class="s2">ScriptOptions</span><span class="s3">[</span><span class="s4">'importModuleDynamically'</span><span class="s3">] </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* This feature is only available with the `--experimental-vm-modules` command 
     * flag enabled. 
     * 
     * 
     * 
     * The `vm.SourceTextModule` class provides the [Source Text Module Record](https://tc39.es/ecma262/#sec-source-text-module-records) as 
     * defined in the ECMAScript specification. 
     * </span><span class="s1">@since </span><span class="s0">v9.6.0 
     * </span><span class="s1">@experimental</span>
     <span class="s0">*/</span>
    <span class="s1">class </span><span class="s2">SourceTextModule </span><span class="s1">extends </span><span class="s2">Module </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Creates a new `SourceTextModule` instance. 
         * </span><span class="s1">@param </span><span class="s2">code </span><span class="s0">JavaScript Module code to parse 
         */</span>
        <span class="s1">constructor</span><span class="s3">(</span><span class="s2">code</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">SourceTextModuleOptions</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">SyntheticModuleOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* String used in stack traces. 
         * </span><span class="s1">@default </span><span class="s2">'vm:module(i)' </span><span class="s0">where i is a context-specific ascending index. 
         */</span>
        <span class="s3">identifier</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The contextified object as returned by the `vm.createContext()` method, to compile and evaluate this module in. 
         */</span>
        <span class="s3">context</span><span class="s1">?: </span><span class="s2">Context </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* This feature is only available with the `--experimental-vm-modules` command 
     * flag enabled. 
     * 
     * 
     * 
     * The `vm.SyntheticModule` class provides the [Synthetic Module Record](https://heycam.github.io/webidl/#synthetic-module-records) as 
     * defined in the WebIDL specification. The purpose of synthetic modules is to 
     * provide a generic interface for exposing non-JavaScript sources to ECMAScript 
     * module graphs. 
     * 
     * ```js 
     * const vm = require('node:vm'); 
     * 
     * const source = '{ &quot;a&quot;: 1 }'; 
     * const module = new vm.SyntheticModule(['default'], function() { 
     *   const obj = JSON.parse(source); 
     *   this.setExport('default', obj); 
     * }); 
     * 
     * // Use `module` in linking... 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v13.0.0, v12.16.0 
     * </span><span class="s1">@experimental</span>
     <span class="s0">*/</span>
    <span class="s1">class </span><span class="s2">SyntheticModule </span><span class="s1">extends </span><span class="s2">Module </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Creates a new `SyntheticModule` instance. 
         * </span><span class="s1">@param </span><span class="s2">exportNames </span><span class="s0">Array of names that will be exported from the module. 
         * </span><span class="s1">@param </span><span class="s2">evaluateCallback </span><span class="s0">Called when the module is evaluated. 
         */</span>
        <span class="s1">constructor</span><span class="s3">(</span><span class="s2">exportNames</span><span class="s1">: </span><span class="s2">string</span><span class="s3">[], </span><span class="s5">evaluateCallback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">this</span><span class="s1">: </span><span class="s2">SyntheticModule</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">SyntheticModuleOptions</span><span class="s3">);</span>
        <span class="s0">/**</span>
         <span class="s0">* This method is used after the module is linked to set the values of exports. If 
         * it is called before the module is linked, an `ERR_VM_MODULE_STATUS` error 
         * will be thrown. 
         * 
         * ```js 
         * import vm from 'node:vm'; 
         * 
         * const m = new vm.SyntheticModule(['x'], () =&gt; { 
         *   m.setExport('x', 1); 
         * }); 
         * 
         * await m.link(() =&gt; {}); 
         * await m.evaluate(); 
         * 
         * assert.strictEqual(m.namespace.x, 1); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v13.0.0, v12.16.0 
         * </span><span class="s1">@param </span><span class="s2">name </span><span class="s0">Name of the export to set. 
         * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">The value to set the export to. 
         */</span>
        <span class="s3">setExport(</span><span class="s2">name</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">value</span><span class="s1">: </span><span class="s2">any</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s3">}</span>
<span class="s3">}</span>
<span class="s1">declare module </span><span class="s4">'node:vm' </span><span class="s3">{</span>
    <span class="s1">export </span><span class="s6">* </span><span class="s1">from </span><span class="s4">'vm'</span><span class="s3">;</span>
<span class="s3">}</span>
</pre>
</body>
</html>
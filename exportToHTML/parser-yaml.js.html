<html>
<head>
<title>parser-yaml.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #cc7832;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #4646f1;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
parser-yaml.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">exports==</span><span class="s2">&quot;object&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">typeof </span><span class="s0">module==</span><span class="s2">&quot;object&quot;</span><span class="s0">)module.exports=e();</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">define==</span><span class="s2">&quot;function&quot;</span><span class="s0">&amp;&amp;define.amd)define(e);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">var </span><span class="s0">i=</span><span class="s1">typeof </span><span class="s0">globalThis&lt;</span><span class="s2">&quot;u&quot;</span><span class="s0">?globalThis:</span><span class="s1">typeof </span><span class="s0">global&lt;</span><span class="s2">&quot;u&quot;</span><span class="s0">?global:</span><span class="s1">typeof </span><span class="s0">self&lt;</span><span class="s2">&quot;u&quot;</span><span class="s0">?self:</span><span class="s1">this</span><span class="s0">||{};i.prettierPlugins=i.prettierPlugins||{},i.prettierPlugins.yaml=e()}})(</span><span class="s1">function</span><span class="s0">(){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">yt=(n,e)=&gt;()=&gt;(e||n((e={exports:{}}).exports,e),e.exports);</span><span class="s1">var </span><span class="s0">ln=yt((un,at)=&gt;{</span><span class="s1">var </span><span class="s0">Ye=Object.defineProperty,bt=Object.getOwnPropertyDescriptor,De=Object.getOwnPropertyNames,wt=Object.prototype.hasOwnProperty,Ke=(n,e)=&gt;</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n&amp;&amp;(e=(</span><span class="s3">0</span><span class="s0">,n[De(n)[</span><span class="s3">0</span><span class="s0">]])(n=</span><span class="s3">0</span><span class="s0">)),e},D=(n,e)=&gt;</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e||(</span><span class="s3">0</span><span class="s0">,n[De(n)[</span><span class="s3">0</span><span class="s0">]])((e={exports:{}}).exports,e),e.exports},St=(n,e)=&gt;{</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">r </span><span class="s1">in </span><span class="s0">e)Ye(n,r,{get:e[r],enumerable:!</span><span class="s3">0</span><span class="s0">})},Et=(n,e,r,c)=&gt;{</span><span class="s1">if</span><span class="s0">(e&amp;&amp;</span><span class="s1">typeof </span><span class="s0">e==</span><span class="s2">&quot;object&quot;</span><span class="s0">||</span><span class="s1">typeof </span><span class="s0">e==</span><span class="s2">&quot;function&quot;</span><span class="s0">)</span><span class="s1">for</span><span class="s0">(let h of De(e))!wt.call(n,h)&amp;&amp;h!==r&amp;&amp;Ye(n,h,{get:()=&gt;e[h],enumerable:!(c=bt(e,h))||c.enumerable});</span><span class="s1">return </span><span class="s0">n},se=n=&gt;Et(Ye({},</span><span class="s2">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s3">0</span><span class="s0">}),n),Te,Y=Ke({</span><span class="s2">&quot;&lt;define:process&gt;&quot;</span><span class="s0">(){Te={env:{},argv:[]}}}),Mt=D({</span><span class="s2">&quot;src/common/parser-create-error.js&quot;</span><span class="s0">(n,e){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y();</span><span class="s1">function </span><span class="s0">r(c,h){let d=</span><span class="s1">new </span><span class="s0">SyntaxError(c+</span><span class="s2">&quot; (&quot;</span><span class="s0">+h.start.line+</span><span class="s2">&quot;:&quot;</span><span class="s0">+h.start.column+</span><span class="s2">&quot;)&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">d.loc=h,d}e.exports=r}}),Ot=D({</span><span class="s2">&quot;src/language-yaml/pragma.js&quot;</span><span class="s0">(n,e){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y();</span><span class="s1">function </span><span class="s0">r(d){</span><span class="s1">return</span><span class="s0">/^\s*@(?:prettier|format)\s*$/.test(d)}</span><span class="s1">function </span><span class="s0">c(d){</span><span class="s1">return</span><span class="s0">/^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(d)}</span><span class="s1">function </span><span class="s0">h(d){</span><span class="s1">return</span><span class="s0">`# @format</span>

<span class="s0">${d}`}e.exports={isPragma:r,hasPragma:c,insertPragma:h}}}),Lt=D({</span><span class="s2">&quot;src/language-yaml/loc.js&quot;</span><span class="s0">(n,e){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y();</span><span class="s1">function </span><span class="s0">r(h){</span><span class="s1">return </span><span class="s0">h.position.start.offset}</span><span class="s1">function </span><span class="s0">c(h){</span><span class="s1">return </span><span class="s0">h.position.end.offset}e.exports={locStart:r,locEnd:c}}}),te={};St(te,{__assign:()=&gt;qe,__asyncDelegator:()=&gt;Yt,__asyncGenerator:()=&gt;jt,__asyncValues:()=&gt;Dt,__await:()=&gt;Ce,__awaiter:()=&gt;Pt,__classPrivateFieldGet:()=&gt;Qt,__classPrivateFieldSet:()=&gt;Ut,__createBinding:()=&gt;Rt,__decorate:()=&gt;Tt,__exportStar:()=&gt;qt,__extends:()=&gt;At,__generator:()=&gt;It,__importDefault:()=&gt;Vt,__importStar:()=&gt;Wt,__makeTemplateObject:()=&gt;Ft,__metadata:()=&gt;kt,__param:()=&gt;Ct,__read:()=&gt;Je,__rest:()=&gt;Nt,__spread:()=&gt;$t,__spreadArrays:()=&gt;Bt,__values:()=&gt;je});</span><span class="s1">function </span><span class="s0">At(n,e){Re(n,e);</span><span class="s1">function </span><span class="s0">r(){</span><span class="s1">this</span><span class="s0">.constructor=n}n.prototype=e===</span><span class="s1">null</span><span class="s0">?Object.create(e):(r.prototype=e.prototype,</span><span class="s1">new </span><span class="s0">r)}</span><span class="s1">function </span><span class="s0">Nt(n,e){</span><span class="s1">var </span><span class="s0">r={};</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">c </span><span class="s1">in </span><span class="s0">n)Object.prototype.hasOwnProperty.call(n,c)&amp;&amp;e.indexOf(c)&lt;</span><span class="s3">0</span><span class="s0">&amp;&amp;(r[c]=n[c]);</span><span class="s1">if</span><span class="s0">(n!=</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">typeof </span><span class="s0">Object.getOwnPropertySymbols==</span><span class="s2">&quot;function&quot;</span><span class="s0">)</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">h=</span><span class="s3">0</span><span class="s0">,c=Object.getOwnPropertySymbols(n);h&lt;c.length;h++)e.indexOf(c[h])&lt;</span><span class="s3">0</span><span class="s0">&amp;&amp;Object.prototype.propertyIsEnumerable.call(n,c[h])&amp;&amp;(r[c[h]]=n[c[h]]);</span><span class="s1">return </span><span class="s0">r}</span><span class="s1">function </span><span class="s0">Tt(n,e,r,c){</span><span class="s1">var </span><span class="s0">h=arguments.length,d=h&lt;</span><span class="s3">3</span><span class="s0">?e:c===</span><span class="s1">null</span><span class="s0">?c=Object.getOwnPropertyDescriptor(e,r):c,y;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Reflect==</span><span class="s2">&quot;object&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">typeof </span><span class="s0">Reflect.decorate==</span><span class="s2">&quot;function&quot;</span><span class="s0">)d=Reflect.decorate(n,e,r,c);</span><span class="s1">else for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">E=n.length-1;E&gt;=</span><span class="s3">0</span><span class="s0">;E--)(y=n[E])&amp;&amp;(d=(h&lt;</span><span class="s3">3</span><span class="s0">?y(d):h&gt;</span><span class="s3">3</span><span class="s0">?y(e,r,d):y(e,r))||d);</span><span class="s1">return </span><span class="s0">h&gt;</span><span class="s3">3</span><span class="s0">&amp;&amp;d&amp;&amp;Object.defineProperty(e,r,d),d}</span><span class="s1">function </span><span class="s0">Ct(n,e){</span><span class="s1">return function</span><span class="s0">(r,c){e(r,c,n)}}</span><span class="s1">function </span><span class="s0">kt(n,e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Reflect==</span><span class="s2">&quot;object&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">typeof </span><span class="s0">Reflect.metadata==</span><span class="s2">&quot;function&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">Reflect.metadata(n,e)}</span><span class="s1">function </span><span class="s0">Pt(n,e,r,c){</span><span class="s1">function </span><span class="s0">h(d){</span><span class="s1">return </span><span class="s0">d </span><span class="s1">instanceof </span><span class="s0">r?d:</span><span class="s1">new </span><span class="s0">r(</span><span class="s1">function</span><span class="s0">(y){y(d)})}</span><span class="s1">return new</span><span class="s0">(r||(r=Promise))(</span><span class="s1">function</span><span class="s0">(d,y){</span><span class="s1">function </span><span class="s0">E(M){</span><span class="s1">try</span><span class="s0">{S(c.next(M))}</span><span class="s1">catch</span><span class="s0">(T){y(T)}}</span><span class="s1">function </span><span class="s0">I(M){</span><span class="s1">try</span><span class="s0">{S(c.</span><span class="s1">throw</span><span class="s0">(M))}</span><span class="s1">catch</span><span class="s0">(T){y(T)}}</span><span class="s1">function </span><span class="s0">S(M){M.done?d(M.value):h(M.value).then(E,I)}S((c=c.apply(n,e||[])).next())})}</span><span class="s1">function </span><span class="s0">It(n,e){</span><span class="s1">var </span><span class="s0">r={label:</span><span class="s3">0</span><span class="s0">,sent:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(d[</span><span class="s3">0</span><span class="s0">]&amp;</span><span class="s3">1</span><span class="s0">)</span><span class="s1">throw </span><span class="s0">d[</span><span class="s3">1</span><span class="s0">];</span><span class="s1">return </span><span class="s0">d[</span><span class="s3">1</span><span class="s0">]},trys:[],ops:[]},c,h,d,y;</span><span class="s1">return </span><span class="s0">y={next:E(</span><span class="s3">0</span><span class="s0">),</span><span class="s1">throw</span><span class="s0">:E(</span><span class="s3">1</span><span class="s0">),</span><span class="s1">return</span><span class="s0">:E(</span><span class="s3">2</span><span class="s0">)},</span><span class="s1">typeof </span><span class="s0">Symbol==</span><span class="s2">&quot;function&quot;</span><span class="s0">&amp;&amp;(y[Symbol.iterator]=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">}),y;</span><span class="s1">function </span><span class="s0">E(S){</span><span class="s1">return function</span><span class="s0">(M){</span><span class="s1">return </span><span class="s0">I([S,M])}}</span><span class="s1">function </span><span class="s0">I(S){</span><span class="s1">if</span><span class="s0">(c)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Generator is already executing.&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(;r;)</span><span class="s1">try</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(c=</span><span class="s3">1</span><span class="s0">,h&amp;&amp;(d=S[</span><span class="s3">0</span><span class="s0">]&amp;</span><span class="s3">2</span><span class="s0">?h.</span><span class="s1">return</span><span class="s0">:S[</span><span class="s3">0</span><span class="s0">]?h.</span><span class="s1">throw</span><span class="s0">||((d=h.</span><span class="s1">return</span><span class="s0">)&amp;&amp;d.call(h),</span><span class="s3">0</span><span class="s0">):h.next)&amp;&amp;!(d=d.call(h,S[</span><span class="s3">1</span><span class="s0">])).done)</span><span class="s1">return </span><span class="s0">d;</span><span class="s1">switch</span><span class="s0">(h=</span><span class="s3">0</span><span class="s0">,d&amp;&amp;(S=[S[</span><span class="s3">0</span><span class="s0">]&amp;</span><span class="s3">2</span><span class="s0">,d.value]),S[</span><span class="s3">0</span><span class="s0">]){</span><span class="s1">case </span><span class="s3">0</span><span class="s0">:</span><span class="s1">case </span><span class="s3">1</span><span class="s0">:d=S;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s3">4</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r.label++,{value:S[</span><span class="s3">1</span><span class="s0">],done:!</span><span class="s3">1</span><span class="s0">};</span><span class="s1">case </span><span class="s3">5</span><span class="s0">:r.label++,h=S[</span><span class="s3">1</span><span class="s0">],S=[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">case </span><span class="s3">7</span><span class="s0">:S=r.ops.pop(),r.trys.pop();</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(d=r.trys,!(d=d.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;d[d.length-1])&amp;&amp;(S[</span><span class="s3">0</span><span class="s0">]===</span><span class="s3">6</span><span class="s0">||S[</span><span class="s3">0</span><span class="s0">]===</span><span class="s3">2</span><span class="s0">)){r=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(S[</span><span class="s3">0</span><span class="s0">]===</span><span class="s3">3</span><span class="s0">&amp;&amp;(!d||S[</span><span class="s3">1</span><span class="s0">]&gt;d[</span><span class="s3">0</span><span class="s0">]&amp;&amp;S[</span><span class="s3">1</span><span class="s0">]&lt;d[</span><span class="s3">3</span><span class="s0">])){r.label=S[</span><span class="s3">1</span><span class="s0">];</span><span class="s1">break</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(S[</span><span class="s3">0</span><span class="s0">]===</span><span class="s3">6</span><span class="s0">&amp;&amp;r.label&lt;d[</span><span class="s3">1</span><span class="s0">]){r.label=d[</span><span class="s3">1</span><span class="s0">],d=S;</span><span class="s1">break</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(d&amp;&amp;r.label&lt;d[</span><span class="s3">2</span><span class="s0">]){r.label=d[</span><span class="s3">2</span><span class="s0">],r.ops.push(S);</span><span class="s1">break</span><span class="s0">}d[</span><span class="s3">2</span><span class="s0">]&amp;&amp;r.ops.pop(),r.trys.pop();</span><span class="s1">continue</span><span class="s0">}S=e.call(n,r)}</span><span class="s1">catch</span><span class="s0">(M){S=[</span><span class="s3">6</span><span class="s0">,M],h=</span><span class="s3">0</span><span class="s0">}</span><span class="s1">finally</span><span class="s0">{c=d=</span><span class="s3">0</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(S[</span><span class="s3">0</span><span class="s0">]&amp;</span><span class="s3">5</span><span class="s0">)</span><span class="s1">throw </span><span class="s0">S[</span><span class="s3">1</span><span class="s0">];</span><span class="s1">return</span><span class="s0">{value:S[</span><span class="s3">0</span><span class="s0">]?S[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,done:!</span><span class="s3">0</span><span class="s0">}}}</span><span class="s1">function </span><span class="s0">Rt(n,e,r,c){c===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(c=r),n[c]=e[r]}</span><span class="s1">function </span><span class="s0">qt(n,e){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">r </span><span class="s1">in </span><span class="s0">n)r!==</span><span class="s2">&quot;default&quot;</span><span class="s0">&amp;&amp;!e.hasOwnProperty(r)&amp;&amp;(e[r]=n[r])}</span><span class="s1">function </span><span class="s0">je(n){</span><span class="s1">var </span><span class="s0">e=</span><span class="s1">typeof </span><span class="s0">Symbol==</span><span class="s2">&quot;function&quot;</span><span class="s0">&amp;&amp;Symbol.iterator,r=e&amp;&amp;n[e],c=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(r)</span><span class="s1">return </span><span class="s0">r.call(n);</span><span class="s1">if</span><span class="s0">(n&amp;&amp;</span><span class="s1">typeof </span><span class="s0">n.length==</span><span class="s2">&quot;number&quot;</span><span class="s0">)</span><span class="s1">return</span><span class="s0">{next:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">n&amp;&amp;c&gt;=n.length&amp;&amp;(n=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),{value:n&amp;&amp;n[c++],done:!n}}};</span><span class="s1">throw new </span><span class="s0">TypeError(e?</span><span class="s2">&quot;Object is not iterable.&quot;</span><span class="s0">:</span><span class="s2">&quot;Symbol.iterator is not defined.&quot;</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">Je(n,e){</span><span class="s1">var </span><span class="s0">r=</span><span class="s1">typeof </span><span class="s0">Symbol==</span><span class="s2">&quot;function&quot;</span><span class="s0">&amp;&amp;n[Symbol.iterator];</span><span class="s1">if</span><span class="s0">(!r)</span><span class="s1">return </span><span class="s0">n;</span><span class="s1">var </span><span class="s0">c=r.call(n),h,d=[],y;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">for</span><span class="s0">(;(e===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">||e-- &gt;</span><span class="s3">0</span><span class="s0">)&amp;&amp;!(h=c.next()).done;)d.push(h.value)}</span><span class="s1">catch</span><span class="s0">(E){y={error:E}}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">try</span><span class="s0">{h&amp;&amp;!h.done&amp;&amp;(r=c.</span><span class="s1">return</span><span class="s0">)&amp;&amp;r.call(c)}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(y)</span><span class="s1">throw </span><span class="s0">y.error}}</span><span class="s1">return </span><span class="s0">d}</span><span class="s1">function </span><span class="s0">$t(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">n=[],e=</span><span class="s3">0</span><span class="s0">;e&lt;arguments.length;e++)n=n.concat(Je(arguments[e]));</span><span class="s1">return </span><span class="s0">n}</span><span class="s1">function </span><span class="s0">Bt(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">n=</span><span class="s3">0</span><span class="s0">,e=</span><span class="s3">0</span><span class="s0">,r=arguments.length;e&lt;r;e++)n+=arguments[e].length;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">c=Array(n),h=</span><span class="s3">0</span><span class="s0">,e=</span><span class="s3">0</span><span class="s0">;e&lt;r;e++)</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">d=arguments[e],y=</span><span class="s3">0</span><span class="s0">,E=d.length;y&lt;E;y++,h++)c[h]=d[y];</span><span class="s1">return </span><span class="s0">c}</span><span class="s1">function </span><span class="s0">Ce(n){</span><span class="s1">return this instanceof </span><span class="s0">Ce?(</span><span class="s1">this</span><span class="s0">.v=n,</span><span class="s1">this</span><span class="s0">):</span><span class="s1">new </span><span class="s0">Ce(n)}</span><span class="s1">function </span><span class="s0">jt(n,e,r){</span><span class="s1">if</span><span class="s0">(!Symbol.asyncIterator)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Symbol.asyncIterator is not defined.&quot;</span><span class="s0">);</span><span class="s1">var </span><span class="s0">c=r.apply(n,e||[]),h,d=[];</span><span class="s1">return </span><span class="s0">h={},y(</span><span class="s2">&quot;next&quot;</span><span class="s0">),y(</span><span class="s2">&quot;throw&quot;</span><span class="s0">),y(</span><span class="s2">&quot;return&quot;</span><span class="s0">),h[Symbol.asyncIterator]=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">},h;</span><span class="s1">function </span><span class="s0">y(P){c[P]&amp;&amp;(h[P]=</span><span class="s1">function</span><span class="s0">(C){</span><span class="s1">return new </span><span class="s0">Promise(</span><span class="s1">function</span><span class="s0">(q,R){d.push([P,C,q,R])&gt;</span><span class="s3">1</span><span class="s0">||E(P,C)})})}</span><span class="s1">function </span><span class="s0">E(P,C){</span><span class="s1">try</span><span class="s0">{I(c[P](C))}</span><span class="s1">catch</span><span class="s0">(q){T(d[</span><span class="s3">0</span><span class="s0">][</span><span class="s3">3</span><span class="s0">],q)}}</span><span class="s1">function </span><span class="s0">I(P){P.value </span><span class="s1">instanceof </span><span class="s0">Ce?Promise.resolve(P.value.v).then(S,M):T(d[</span><span class="s3">0</span><span class="s0">][</span><span class="s3">2</span><span class="s0">],P)}</span><span class="s1">function </span><span class="s0">S(P){E(</span><span class="s2">&quot;next&quot;</span><span class="s0">,P)}</span><span class="s1">function </span><span class="s0">M(P){E(</span><span class="s2">&quot;throw&quot;</span><span class="s0">,P)}</span><span class="s1">function </span><span class="s0">T(P,C){P(C),d.shift(),d.length&amp;&amp;E(d[</span><span class="s3">0</span><span class="s0">][</span><span class="s3">0</span><span class="s0">],d[</span><span class="s3">0</span><span class="s0">][</span><span class="s3">1</span><span class="s0">])}}</span><span class="s1">function </span><span class="s0">Yt(n){</span><span class="s1">var </span><span class="s0">e,r;</span><span class="s1">return </span><span class="s0">e={},c(</span><span class="s2">&quot;next&quot;</span><span class="s0">),c(</span><span class="s2">&quot;throw&quot;</span><span class="s0">,</span><span class="s1">function</span><span class="s0">(h){</span><span class="s1">throw </span><span class="s0">h}),c(</span><span class="s2">&quot;return&quot;</span><span class="s0">),e[Symbol.iterator]=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">},e;</span><span class="s1">function </span><span class="s0">c(h,d){e[h]=n[h]?</span><span class="s1">function</span><span class="s0">(y){</span><span class="s1">return</span><span class="s0">(r=!r)?{value:Ce(n[h](y)),done:h===</span><span class="s2">&quot;return&quot;</span><span class="s0">}:d?d(y):y}:d}}</span><span class="s1">function </span><span class="s0">Dt(n){</span><span class="s1">if</span><span class="s0">(!Symbol.asyncIterator)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Symbol.asyncIterator is not defined.&quot;</span><span class="s0">);</span><span class="s1">var </span><span class="s0">e=n[Symbol.asyncIterator],r;</span><span class="s1">return </span><span class="s0">e?e.call(n):(n=</span><span class="s1">typeof </span><span class="s0">je==</span><span class="s2">&quot;function&quot;</span><span class="s0">?je(n):n[Symbol.iterator](),r={},c(</span><span class="s2">&quot;next&quot;</span><span class="s0">),c(</span><span class="s2">&quot;throw&quot;</span><span class="s0">),c(</span><span class="s2">&quot;return&quot;</span><span class="s0">),r[Symbol.asyncIterator]=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">},r);</span><span class="s1">function </span><span class="s0">c(d){r[d]=n[d]&amp;&amp;</span><span class="s1">function</span><span class="s0">(y){</span><span class="s1">return new </span><span class="s0">Promise(</span><span class="s1">function</span><span class="s0">(E,I){y=n[d](y),h(E,I,y.done,y.value)})}}</span><span class="s1">function </span><span class="s0">h(d,y,E,I){Promise.resolve(I).then(</span><span class="s1">function</span><span class="s0">(S){d({value:S,done:E})},y)}}</span><span class="s1">function </span><span class="s0">Ft(n,e){</span><span class="s1">return </span><span class="s0">Object.defineProperty?Object.defineProperty(n,</span><span class="s2">&quot;raw&quot;</span><span class="s0">,{value:e}):n.raw=e,n}</span><span class="s1">function </span><span class="s0">Wt(n){</span><span class="s1">if</span><span class="s0">(n&amp;&amp;n.__esModule)</span><span class="s1">return </span><span class="s0">n;</span><span class="s1">var </span><span class="s0">e={};</span><span class="s1">if</span><span class="s0">(n!=</span><span class="s1">null</span><span class="s0">)</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">r </span><span class="s1">in </span><span class="s0">n)Object.hasOwnProperty.call(n,r)&amp;&amp;(e[r]=n[r]);</span><span class="s1">return </span><span class="s0">e.</span><span class="s1">default</span><span class="s0">=n,e}</span><span class="s1">function </span><span class="s0">Vt(n){</span><span class="s1">return </span><span class="s0">n&amp;&amp;n.__esModule?n:{</span><span class="s1">default</span><span class="s0">:n}}</span><span class="s1">function </span><span class="s0">Qt(n,e){</span><span class="s1">if</span><span class="s0">(!e.has(n))</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;attempted to get private field on non-instance&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">e.get(n)}</span><span class="s1">function </span><span class="s0">Ut(n,e,r){</span><span class="s1">if</span><span class="s0">(!e.has(n))</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;attempted to set private field on non-instance&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">e.set(n,r),r}</span><span class="s1">var </span><span class="s0">Re,qe,ie=Ke({</span><span class="s2">&quot;node_modules/tslib/tslib.es6.js&quot;</span><span class="s0">(){Y(),Re=</span><span class="s1">function</span><span class="s0">(n,e){</span><span class="s1">return </span><span class="s0">Re=Object.setPrototypeOf||{__proto__:[]}</span><span class="s1">instanceof </span><span class="s0">Array&amp;&amp;</span><span class="s1">function</span><span class="s0">(r,c){r.__proto__=c}||</span><span class="s1">function</span><span class="s0">(r,c){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">h </span><span class="s1">in </span><span class="s0">c)c.hasOwnProperty(h)&amp;&amp;(r[h]=c[h])},Re(n,e)},qe=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">qe=Object.assign||</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">r,c=</span><span class="s3">1</span><span class="s0">,h=arguments.length;c&lt;h;c++){r=arguments[c];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">d </span><span class="s1">in </span><span class="s0">r)Object.prototype.hasOwnProperty.call(r,d)&amp;&amp;(e[d]=r[d])}</span><span class="s1">return </span><span class="s0">e},qe.apply(</span><span class="s1">this</span><span class="s0">,arguments)}}}),Kt=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/node_modules/lines-and-columns/build/index.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">,n.LinesAndColumns=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=`</span>
<span class="s0">`,r=</span><span class="s2">&quot;</span><span class="s4">\r</span><span class="s2">&quot;</span><span class="s0">,c=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">function </span><span class="s0">h(d){</span><span class="s1">this</span><span class="s0">.string=d;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">y=[</span><span class="s3">0</span><span class="s0">],E=</span><span class="s3">0</span><span class="s0">;E&lt;d.length;)</span><span class="s1">switch</span><span class="s0">(d[E]){</span><span class="s1">case </span><span class="s0">e:E+=e.length,y.push(E);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">r:E+=r.length,d[E]===e&amp;&amp;(E+=e.length),y.push(E);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:E++;</span><span class="s1">break</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.offsets=y}</span><span class="s1">return </span><span class="s0">h.prototype.locationForIndex=</span><span class="s1">function</span><span class="s0">(d){</span><span class="s1">if</span><span class="s0">(d&lt;</span><span class="s3">0</span><span class="s0">||d&gt;</span><span class="s1">this</span><span class="s0">.string.length)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">y=</span><span class="s3">0</span><span class="s0">,E=</span><span class="s1">this</span><span class="s0">.offsets;E[y+</span><span class="s3">1</span><span class="s0">]&lt;=d;)y++;</span><span class="s1">var </span><span class="s0">I=d-E[y];</span><span class="s1">return</span><span class="s0">{line:y,column:I}},h.prototype.indexForLocation=</span><span class="s1">function</span><span class="s0">(d){</span><span class="s1">var </span><span class="s0">y=d.line,E=d.column;</span><span class="s1">return </span><span class="s0">y&lt;</span><span class="s3">0</span><span class="s0">||y&gt;=</span><span class="s1">this</span><span class="s0">.offsets.length||E&lt;</span><span class="s3">0</span><span class="s0">||E&gt;</span><span class="s1">this</span><span class="s0">.lengthOfLine(y)?</span><span class="s1">null</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.offsets[y]+E},h.prototype.lengthOfLine=</span><span class="s1">function</span><span class="s0">(d){</span><span class="s1">var </span><span class="s0">y=</span><span class="s1">this</span><span class="s0">.offsets[d],E=d===</span><span class="s1">this</span><span class="s0">.offsets.length-1?</span><span class="s1">this</span><span class="s0">.string.length:</span><span class="s1">this</span><span class="s0">.offsets[d+</span><span class="s3">1</span><span class="s0">];</span><span class="s1">return </span><span class="s0">E-y},h}();n.LinesAndColumns=c,n.</span><span class="s1">default</span><span class="s0">=c}}),Jt=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/utils/define-parents.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r,c){c===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(c=</span><span class="s1">null</span><span class="s0">),</span><span class="s2">&quot;children&quot;</span><span class="s1">in </span><span class="s0">r&amp;&amp;r.children.forEach(</span><span class="s1">function</span><span class="s0">(h){</span><span class="s1">return </span><span class="s0">e(h,r)}),</span><span class="s2">&quot;anchor&quot;</span><span class="s1">in </span><span class="s0">r&amp;&amp;r.anchor&amp;&amp;e(r.anchor,r),</span><span class="s2">&quot;tag&quot;</span><span class="s1">in </span><span class="s0">r&amp;&amp;r.tag&amp;&amp;e(r.tag,r),</span><span class="s2">&quot;leadingComments&quot;</span><span class="s1">in </span><span class="s0">r&amp;&amp;r.leadingComments.forEach(</span><span class="s1">function</span><span class="s0">(h){</span><span class="s1">return </span><span class="s0">e(h,r)}),</span><span class="s2">&quot;middleComments&quot;</span><span class="s1">in </span><span class="s0">r&amp;&amp;r.middleComments.forEach(</span><span class="s1">function</span><span class="s0">(h){</span><span class="s1">return </span><span class="s0">e(h,r)}),</span><span class="s2">&quot;indicatorComment&quot;</span><span class="s1">in </span><span class="s0">r&amp;&amp;r.indicatorComment&amp;&amp;e(r.indicatorComment,r),</span><span class="s2">&quot;trailingComment&quot;</span><span class="s1">in </span><span class="s0">r&amp;&amp;r.trailingComment&amp;&amp;e(r.trailingComment,r),</span><span class="s2">&quot;endComments&quot;</span><span class="s1">in </span><span class="s0">r&amp;&amp;r.endComments.forEach(</span><span class="s1">function</span><span class="s0">(h){</span><span class="s1">return </span><span class="s0">e(h,r)}),Object.defineProperty(r,</span><span class="s2">&quot;_parent&quot;</span><span class="s0">,{value:c,enumerable:!</span><span class="s3">1</span><span class="s0">})}n.defineParents=e}}),Fe=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/utils/get-point-text.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r){</span><span class="s1">return </span><span class="s0">r.line+</span><span class="s2">&quot;:&quot;</span><span class="s0">+r.column}n.getPointText=e}}),xt=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/attach.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=Jt(),r=Fe();</span><span class="s1">function </span><span class="s0">c(S){e.defineParents(S);</span><span class="s1">var </span><span class="s0">M=h(S),T=S.children.slice();S.comments.sort(</span><span class="s1">function</span><span class="s0">(P,C){</span><span class="s1">return </span><span class="s0">P.position.start.offset-C.position.end.offset}).filter(</span><span class="s1">function</span><span class="s0">(P){</span><span class="s1">return</span><span class="s0">!P._parent}).forEach(</span><span class="s1">function</span><span class="s0">(P){</span><span class="s1">for</span><span class="s0">(;T.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;P.position.start.line&gt;T[</span><span class="s3">0</span><span class="s0">].position.end.line;)T.shift();y(P,M,T[</span><span class="s3">0</span><span class="s0">])})}n.attachComments=c;</span><span class="s1">function </span><span class="s0">h(S){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">M=Array.from(</span><span class="s1">new </span><span class="s0">Array(S.position.end.line),</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">{}}),T=</span><span class="s3">0</span><span class="s0">,P=S.comments;T&lt;P.length;T++){</span><span class="s1">var </span><span class="s0">C=P[T];M[C.position.start.line-1].comment=C}</span><span class="s1">return </span><span class="s0">d(M,S),M}</span><span class="s1">function </span><span class="s0">d(S,M){</span><span class="s1">if</span><span class="s0">(M.position.start.offset!==M.position.end.offset){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;leadingComments&quot;</span><span class="s1">in </span><span class="s0">M){</span><span class="s1">var </span><span class="s0">T=M.position.start,P=S[T.line-1].leadingAttachableNode;(!P||T.column&lt;P.position.start.column)&amp;&amp;(S[T.line-1].leadingAttachableNode=M)}</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;trailingComment&quot;</span><span class="s1">in </span><span class="s0">M&amp;&amp;M.position.end.column&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;M.type!==</span><span class="s2">&quot;document&quot;</span><span class="s0">&amp;&amp;M.type!==</span><span class="s2">&quot;documentHead&quot;</span><span class="s0">){</span><span class="s1">var </span><span class="s0">C=M.position.end,q=S[C.line-1].trailingAttachableNode;(!q||C.column&gt;=q.position.end.column)&amp;&amp;(S[C.line-1].trailingAttachableNode=M)}</span><span class="s1">if</span><span class="s0">(M.type!==</span><span class="s2">&quot;root&quot;</span><span class="s0">&amp;&amp;M.type!==</span><span class="s2">&quot;document&quot;</span><span class="s0">&amp;&amp;M.type!==</span><span class="s2">&quot;documentHead&quot;</span><span class="s0">&amp;&amp;M.type!==</span><span class="s2">&quot;documentBody&quot;</span><span class="s0">)</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">R=M.position,T=R.start,C=R.end,B=[C.line].concat(T.line===C.line?[]:T.line),U=</span><span class="s3">0</span><span class="s0">,f=B;U&lt;f.length;U++){</span><span class="s1">var </span><span class="s0">i=f[U],t=S[i-1].trailingNode;(!t||C.column&gt;=t.position.end.column)&amp;&amp;(S[i-1].trailingNode=M)}</span><span class="s2">&quot;children&quot;</span><span class="s1">in </span><span class="s0">M&amp;&amp;M.children.forEach(</span><span class="s1">function</span><span class="s0">(s){d(S,s)})}}</span><span class="s1">function </span><span class="s0">y(S,M,T){</span><span class="s1">var </span><span class="s0">P=S.position.start.line,C=M[P-1].trailingAttachableNode;</span><span class="s1">if</span><span class="s0">(C){</span><span class="s1">if</span><span class="s0">(C.trailingComment)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Unexpected multiple trailing comment at &quot;</span><span class="s0">+r.getPointText(S.position.start));e.defineParents(S,C),C.trailingComment=S;</span><span class="s1">return</span><span class="s0">}</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">q=P;q&gt;=T.position.start.line;q--){</span><span class="s1">var </span><span class="s0">R=M[q-1].trailingNode,B=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(R)B=R;</span><span class="s1">else if</span><span class="s0">(q!==P&amp;&amp;M[q-1].comment)B=M[q-1].comment._parent;</span><span class="s1">else continue</span><span class="s0">;</span><span class="s1">if</span><span class="s0">((B.type===</span><span class="s2">&quot;sequence&quot;</span><span class="s0">||B.type===</span><span class="s2">&quot;mapping&quot;</span><span class="s0">)&amp;&amp;(B=B.children[</span><span class="s3">0</span><span class="s0">]),B.type===</span><span class="s2">&quot;mappingItem&quot;</span><span class="s0">){</span><span class="s1">var </span><span class="s0">U=B.children,f=U[</span><span class="s3">0</span><span class="s0">],i=U[</span><span class="s3">1</span><span class="s0">];B=I(f)?f:i}</span><span class="s1">for</span><span class="s0">(;;){</span><span class="s1">if</span><span class="s0">(E(B,S)){e.defineParents(S,B),B.endComments.push(S);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(!B._parent)</span><span class="s1">break</span><span class="s0">;B=B._parent}</span><span class="s1">break</span><span class="s0">}</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">q=P+</span><span class="s3">1</span><span class="s0">;q&lt;=T.position.end.line;q++){</span><span class="s1">var </span><span class="s0">t=M[q-1].leadingAttachableNode;</span><span class="s1">if</span><span class="s0">(t){e.defineParents(S,t),t.leadingComments.push(S);</span><span class="s1">return</span><span class="s0">}}</span><span class="s1">var </span><span class="s0">s=T.children[</span><span class="s3">1</span><span class="s0">];e.defineParents(S,s),s.endComments.push(S)}</span><span class="s1">function </span><span class="s0">E(S,M){</span><span class="s1">if</span><span class="s0">(S.position.start.offset&lt;M.position.start.offset&amp;&amp;S.position.end.offset&gt;M.position.end.offset)</span><span class="s1">switch</span><span class="s0">(S.type){</span><span class="s1">case</span><span class="s2">&quot;flowMapping&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;flowSequence&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">S.children.length===</span><span class="s3">0</span><span class="s0">||M.position.start.line&gt;S.children[S.children.length-1].position.end.line}</span><span class="s1">if</span><span class="s0">(M.position.end.offset&lt;S.position.end.offset)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">switch</span><span class="s0">(S.type){</span><span class="s1">case</span><span class="s2">&quot;sequenceItem&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">M.position.start.column&gt;S.position.start.column;</span><span class="s1">case</span><span class="s2">&quot;mappingKey&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;mappingValue&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">M.position.start.column&gt;S._parent.position.start.column&amp;&amp;(S.children.length===</span><span class="s3">0</span><span class="s0">||S.children.length===</span><span class="s3">1</span><span class="s0">&amp;&amp;S.children[</span><span class="s3">0</span><span class="s0">].type!==</span><span class="s2">&quot;blockFolded&quot;</span><span class="s0">&amp;&amp;S.children[</span><span class="s3">0</span><span class="s0">].type!==</span><span class="s2">&quot;blockLiteral&quot;</span><span class="s0">)&amp;&amp;(S.type===</span><span class="s2">&quot;mappingValue&quot;</span><span class="s0">||I(S));</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}}</span><span class="s1">function </span><span class="s0">I(S){</span><span class="s1">return </span><span class="s0">S.position.start!==S.position.end&amp;&amp;(S.children.length===</span><span class="s3">0</span><span class="s0">||S.position.start.offset!==S.children[</span><span class="s3">0</span><span class="s0">].position.start.offset)}}}),me=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/node.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r,c){</span><span class="s1">return</span><span class="s0">{type:r,position:c}}n.createNode=e}}),Ht=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/root.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=me();</span><span class="s1">function </span><span class="s0">c(h,d,y){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign({},r.createNode(</span><span class="s2">&quot;root&quot;</span><span class="s0">,h)),{children:d,comments:y})}n.createRoot=c}}),Gt=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/preprocess.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r){</span><span class="s1">switch</span><span class="s0">(r.type){</span><span class="s1">case</span><span class="s2">&quot;DOCUMENT&quot;</span><span class="s0">:</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">c=r.contents.length-1;c&gt;=</span><span class="s3">0</span><span class="s0">;c--)r.contents[c].type===</span><span class="s2">&quot;BLANK_LINE&quot;</span><span class="s0">?r.contents.splice(c,</span><span class="s3">1</span><span class="s0">):e(r.contents[c]);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">c=r.directives.length-1;c&gt;=</span><span class="s3">0</span><span class="s0">;c--)r.directives[c].type===</span><span class="s2">&quot;BLANK_LINE&quot;</span><span class="s0">&amp;&amp;r.directives.splice(c,</span><span class="s3">1</span><span class="s0">);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;FLOW_MAP&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;FLOW_SEQ&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;MAP&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;SEQ&quot;</span><span class="s0">:</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">c=r.items.length-1;c&gt;=</span><span class="s3">0</span><span class="s0">;c--){</span><span class="s1">var </span><span class="s0">h=r.items[c];</span><span class="s2">&quot;char&quot;</span><span class="s1">in </span><span class="s0">h||(h.type===</span><span class="s2">&quot;BLANK_LINE&quot;</span><span class="s0">?r.items.splice(c,</span><span class="s3">1</span><span class="s0">):e(h))}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;MAP_KEY&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;MAP_VALUE&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;SEQ_ITEM&quot;</span><span class="s0">:r.node&amp;&amp;e(r.node);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;ALIAS&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;BLANK_LINE&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;BLOCK_FOLDED&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;BLOCK_LITERAL&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;COMMENT&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;DIRECTIVE&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;PLAIN&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;QUOTE_DOUBLE&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;QUOTE_SINGLE&quot;</span><span class="s0">:</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Unexpected node type &quot;</span><span class="s0">+JSON.stringify(r.type))}}n.removeCstBlankLine=e}}),Oe=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/leading-comment-attachable.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(){</span><span class="s1">return</span><span class="s0">{leadingComments:[]}}n.createLeadingCommentAttachable=e}}),$e=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/trailing-comment-attachable.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r){</span><span class="s1">return </span><span class="s0">r===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(r=</span><span class="s1">null</span><span class="s0">),{trailingComment:r}}n.createTrailingCommentAttachable=e}}),Se=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/comment-attachable.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Oe(),c=$e();</span><span class="s1">function </span><span class="s0">h(){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign({},r.createLeadingCommentAttachable()),c.createTrailingCommentAttachable())}n.createCommentAttachable=h}}),zt=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/alias.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Se(),c=me();</span><span class="s1">function </span><span class="s0">h(d,y,E){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign(e.__assign(e.__assign({},c.createNode(</span><span class="s2">&quot;alias&quot;</span><span class="s0">,d)),r.createCommentAttachable()),y),{value:E})}n.createAlias=h}}),Zt=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/alias.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=zt();</span><span class="s1">function </span><span class="s0">r(c,h){</span><span class="s1">var </span><span class="s0">d=c.cstNode;</span><span class="s1">return </span><span class="s0">e.createAlias(h.transformRange({origStart:d.valueRange.origStart-1,origEnd:d.valueRange.origEnd}),h.transformContent(c),d.rawValue)}n.transformAlias=r}}),Xt=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/block-folded.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te));</span><span class="s1">function </span><span class="s0">r(c){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign({},c),{type:</span><span class="s2">&quot;blockFolded&quot;</span><span class="s0">})}n.createBlockFolded=r}}),er=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/block-value.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Oe(),c=me();</span><span class="s1">function </span><span class="s0">h(d,y,E,I,S,M){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign(e.__assign(e.__assign({},c.createNode(</span><span class="s2">&quot;blockValue&quot;</span><span class="s0">,d)),r.createLeadingCommentAttachable()),y),{chomping:E,indent:I,value:S,indicatorComment:M})}n.createBlockValue=h}}),xe=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/constants.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e;(</span><span class="s1">function</span><span class="s0">(r){r.Tag=</span><span class="s2">&quot;!&quot;</span><span class="s0">,r.Anchor=</span><span class="s2">&quot;&amp;&quot;</span><span class="s0">,r.Comment=</span><span class="s2">&quot;#&quot;</span><span class="s0">})(e=n.PropLeadingCharacter||(n.PropLeadingCharacter={}))}}),tr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/anchor.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=me();</span><span class="s1">function </span><span class="s0">c(h,d){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign({},r.createNode(</span><span class="s2">&quot;anchor&quot;</span><span class="s0">,h)),{value:d})}n.createAnchor=c}}),We=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/comment.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=me();</span><span class="s1">function </span><span class="s0">c(h,d){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign({},r.createNode(</span><span class="s2">&quot;comment&quot;</span><span class="s0">,h)),{value:d})}n.createComment=c}}),rr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/content.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r,c,h){</span><span class="s1">return</span><span class="s0">{anchor:c,tag:r,middleComments:h}}n.createContent=e}}),nr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/tag.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=me();</span><span class="s1">function </span><span class="s0">c(h,d){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign({},r.createNode(</span><span class="s2">&quot;tag&quot;</span><span class="s0">,h)),{value:d})}n.createTag=c}}),He=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/content.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=xe(),r=tr(),c=We(),h=rr(),d=nr();</span><span class="s1">function </span><span class="s0">y(E,I,S){S===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(S=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">});</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">M=E.cstNode,T=[],P=</span><span class="s1">null</span><span class="s0">,C=</span><span class="s1">null</span><span class="s0">,q=</span><span class="s1">null</span><span class="s0">,R=</span><span class="s3">0</span><span class="s0">,B=M.props;R&lt;B.length;R++){</span><span class="s1">var </span><span class="s0">U=B[R],f=I.text[U.origStart];</span><span class="s1">switch</span><span class="s0">(f){</span><span class="s1">case </span><span class="s0">e.PropLeadingCharacter.Tag:P=P||U,C=d.createTag(I.transformRange(U),E.tag);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">e.PropLeadingCharacter.Anchor:P=P||U,q=r.createAnchor(I.transformRange(U),M.anchor);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">e.PropLeadingCharacter.Comment:{</span><span class="s1">var </span><span class="s0">i=c.createComment(I.transformRange(U),I.text.slice(U.origStart+</span><span class="s3">1</span><span class="s0">,U.origEnd));I.comments.push(i),!S(i)&amp;&amp;P&amp;&amp;P.origEnd&lt;=U.origStart&amp;&amp;U.origEnd&lt;=M.valueRange.origStart&amp;&amp;T.push(i);</span><span class="s1">break</span><span class="s0">}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Unexpected leading character &quot;</span><span class="s0">+JSON.stringify(f))}}</span><span class="s1">return </span><span class="s0">h.createContent(C,q,T)}n.transformContent=y}}),Ge=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/block-value.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=er(),r=Fe(),c=He(),h;(</span><span class="s1">function</span><span class="s0">(y){y.CLIP=</span><span class="s2">&quot;clip&quot;</span><span class="s0">,y.STRIP=</span><span class="s2">&quot;strip&quot;</span><span class="s0">,y.KEEP=</span><span class="s2">&quot;keep&quot;</span><span class="s0">})(h||(h={}));</span><span class="s1">function </span><span class="s0">d(y,E){</span><span class="s1">var </span><span class="s0">I=y.cstNode,S=</span><span class="s3">1</span><span class="s0">,M=I.chomping===</span><span class="s2">&quot;CLIP&quot;</span><span class="s0">?</span><span class="s3">0</span><span class="s0">:</span><span class="s3">1</span><span class="s0">,T=I.header.origEnd-I.header.origStart,P=T-S-M!==</span><span class="s3">0</span><span class="s0">,C=E.transformRange({origStart:I.header.origStart,origEnd:I.valueRange.origEnd}),q=</span><span class="s1">null</span><span class="s0">,R=c.transformContent(y,E,</span><span class="s1">function</span><span class="s0">(B){</span><span class="s1">var </span><span class="s0">U=C.start.offset&lt;B.position.start.offset&amp;&amp;B.position.end.offset&lt;C.end.offset;</span><span class="s1">if</span><span class="s0">(!U)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(q)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Unexpected multiple indicator comments at &quot;</span><span class="s0">+r.getPointText(B.position.start));</span><span class="s1">return </span><span class="s0">q=B,!</span><span class="s3">0</span><span class="s0">});</span><span class="s1">return </span><span class="s0">e.createBlockValue(C,R,h[I.chomping],P?I.blockIndent:</span><span class="s1">null</span><span class="s0">,I.strValue,q)}n.transformAstBlockValue=d}}),sr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/block-folded.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=Xt(),r=Ge();</span><span class="s1">function </span><span class="s0">c(h,d){</span><span class="s1">return </span><span class="s0">e.createBlockFolded(r.transformAstBlockValue(h,d))}n.transformBlockFolded=c}}),ir=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/block-literal.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te));</span><span class="s1">function </span><span class="s0">r(c){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign({},c),{type:</span><span class="s2">&quot;blockLiteral&quot;</span><span class="s0">})}n.createBlockLiteral=r}}),ar=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/block-literal.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=ir(),r=Ge();</span><span class="s1">function </span><span class="s0">c(h,d){</span><span class="s1">return </span><span class="s0">e.createBlockLiteral(r.transformAstBlockValue(h,d))}n.transformBlockLiteral=c}}),or=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/comment.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=We();</span><span class="s1">function </span><span class="s0">r(c,h){</span><span class="s1">return </span><span class="s0">e.createComment(h.transformRange(c.range),c.comment)}n.transformComment=r}}),lr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/directive.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Se(),c=me();</span><span class="s1">function </span><span class="s0">h(d,y,E){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign(e.__assign({},c.createNode(</span><span class="s2">&quot;directive&quot;</span><span class="s0">,d)),r.createCommentAttachable()),{name:y,parameters:E})}n.createDirective=h}}),Ve=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/utils/extract-prop-comments.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=xe(),r=We();</span><span class="s1">function </span><span class="s0">c(h,d){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">y=</span><span class="s3">0</span><span class="s0">,E=h.props;y&lt;E.length;y++){</span><span class="s1">var </span><span class="s0">I=E[y],S=d.text[I.origStart];</span><span class="s1">switch</span><span class="s0">(S){</span><span class="s1">case </span><span class="s0">e.PropLeadingCharacter.Comment:d.comments.push(r.createComment(d.transformRange(I),d.text.slice(I.origStart+</span><span class="s3">1</span><span class="s0">,I.origEnd)));</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Unexpected leading character &quot;</span><span class="s0">+JSON.stringify(S))}}}n.extractPropComments=c}}),cr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/directive.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=lr(),r=Ve();</span><span class="s1">function </span><span class="s0">c(h,d){</span><span class="s1">return </span><span class="s0">r.extractPropComments(h,d),e.createDirective(d.transformRange(h.range),h.name,h.parameters)}n.transformDirective=c}}),ur=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/document.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=me(),c=$e();</span><span class="s1">function </span><span class="s0">h(d,y,E,I){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign(e.__assign({},r.createNode(</span><span class="s2">&quot;document&quot;</span><span class="s0">,d)),c.createTrailingCommentAttachable(I)),{children:[y,E]})}n.createDocument=h}}),Le=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/position.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(c,h){</span><span class="s1">return</span><span class="s0">{start:c,end:h}}n.createPosition=e;</span><span class="s1">function </span><span class="s0">r(c){</span><span class="s1">return</span><span class="s0">{start:c,end:c}}n.createEmptyPosition=r}}),Ee=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/end-comment-attachable.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r){</span><span class="s1">return </span><span class="s0">r===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(r=[]),{endComments:r}}n.createEndCommentAttachable=e}}),fr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/document-body.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Ee(),c=me();</span><span class="s1">function </span><span class="s0">h(d,y,E){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign(e.__assign({},c.createNode(</span><span class="s2">&quot;documentBody&quot;</span><span class="s0">,d)),r.createEndCommentAttachable(E)),{children:y?[y]:[]})}n.createDocumentBody=h}}),Ae=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/utils/get-last.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r){</span><span class="s1">return </span><span class="s0">r[r.length-1]}n.getLast=e}}),ze=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/utils/get-match-index.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r,c){</span><span class="s1">var </span><span class="s0">h=r.match(c);</span><span class="s1">return </span><span class="s0">h?h.index:-</span><span class="s3">1</span><span class="s0">}n.getMatchIndex=e}}),mr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/document-body.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=fr(),c=Ae(),h=ze(),d=Fe();</span><span class="s1">function </span><span class="s0">y(S,M,T){</span><span class="s1">var </span><span class="s0">P,C=S.cstNode,q=E(C,M,T),R=q.comments,B=q.endComments,U=q.documentTrailingComment,f=q.documentHeadTrailingComment,i=M.transformNode(S.contents),t=I(C,i,M),s=t.position,a=t.documentEndPoint;</span><span class="s1">return</span><span class="s0">(P=M.comments).push.apply(P,e.__spreadArrays(R,B)),{documentBody:r.createDocumentBody(s,i,B),documentEndPoint:a,documentTrailingComment:U,documentHeadTrailingComment:f}}n.transformDocumentBody=y;</span><span class="s1">function </span><span class="s0">E(S,M,T){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">P=[],C=[],q=[],R=[],B=!</span><span class="s3">1</span><span class="s0">,U=S.contents.length-1;U&gt;=</span><span class="s3">0</span><span class="s0">;U--){</span><span class="s1">var </span><span class="s0">f=S.contents[U];</span><span class="s1">if</span><span class="s0">(f.type===</span><span class="s2">&quot;COMMENT&quot;</span><span class="s0">){</span><span class="s1">var </span><span class="s0">i=M.transformNode(f);T&amp;&amp;T.line===i.position.start.line?R.unshift(i):B?P.unshift(i):i.position.start.offset&gt;=S.valueRange.origEnd?q.unshift(i):P.unshift(i)}</span><span class="s1">else </span><span class="s0">B=!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(q.length&gt;</span><span class="s3">1</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Unexpected multiple document trailing comments at &quot;</span><span class="s0">+d.getPointText(q[</span><span class="s3">1</span><span class="s0">].position.start));</span><span class="s1">if</span><span class="s0">(R.length&gt;</span><span class="s3">1</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Unexpected multiple documentHead trailing comments at &quot;</span><span class="s0">+d.getPointText(R[</span><span class="s3">1</span><span class="s0">].position.start));</span><span class="s1">return</span><span class="s0">{comments:P,endComments:C,documentTrailingComment:c.getLast(q)||</span><span class="s1">null</span><span class="s0">,documentHeadTrailingComment:c.getLast(R)||</span><span class="s1">null</span><span class="s0">}}</span><span class="s1">function </span><span class="s0">I(S,M,T){</span><span class="s1">var </span><span class="s0">P=h.getMatchIndex(T.text.slice(S.valueRange.origEnd),/^\.\.\./),C=P===-</span><span class="s3">1</span><span class="s0">?S.valueRange.origEnd:Math.max(</span><span class="s3">0</span><span class="s0">,S.valueRange.origEnd-1);T.text[C-1]===</span><span class="s2">&quot;</span><span class="s4">\r</span><span class="s2">&quot;</span><span class="s0">&amp;&amp;C--;</span><span class="s1">var </span><span class="s0">q=T.transformRange({origStart:M!==</span><span class="s1">null</span><span class="s0">?M.position.start.offset:C,origEnd:C}),R=P===-</span><span class="s3">1</span><span class="s0">?q.end:T.transformOffset(S.valueRange.origEnd+</span><span class="s3">3</span><span class="s0">);</span><span class="s1">return</span><span class="s0">{position:q,documentEndPoint:R}}}}),dr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/document-head.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Ee(),c=me(),h=$e();</span><span class="s1">function </span><span class="s0">d(y,E,I,S){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign(e.__assign(e.__assign({},c.createNode(</span><span class="s2">&quot;documentHead&quot;</span><span class="s0">,y)),r.createEndCommentAttachable(I)),h.createTrailingCommentAttachable(S)),{children:E})}n.createDocumentHead=d}}),hr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/document-head.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=dr(),c=ze();</span><span class="s1">function </span><span class="s0">h(E,I){</span><span class="s1">var </span><span class="s0">S,M=E.cstNode,T=d(M,I),P=T.directives,C=T.comments,q=T.endComments,R=y(M,P,I),B=R.position,U=R.endMarkerPoint;(S=I.comments).push.apply(S,e.__spreadArrays(C,q));</span><span class="s1">var </span><span class="s0">f=</span><span class="s1">function</span><span class="s0">(i){</span><span class="s1">return </span><span class="s0">i&amp;&amp;I.comments.push(i),r.createDocumentHead(B,P,q,i)};</span><span class="s1">return</span><span class="s0">{createDocumentHeadWithTrailingComment:f,documentHeadEndMarkerPoint:U}}n.transformDocumentHead=h;</span><span class="s1">function </span><span class="s0">d(E,I){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">S=[],M=[],T=[],P=!</span><span class="s3">1</span><span class="s0">,C=E.directives.length-1;C&gt;=</span><span class="s3">0</span><span class="s0">;C--){</span><span class="s1">var </span><span class="s0">q=I.transformNode(E.directives[C]);q.type===</span><span class="s2">&quot;comment&quot;</span><span class="s0">?P?M.unshift(q):T.unshift(q):(P=!</span><span class="s3">0</span><span class="s0">,S.unshift(q))}</span><span class="s1">return</span><span class="s0">{directives:S,comments:M,endComments:T}}</span><span class="s1">function </span><span class="s0">y(E,I,S){</span><span class="s1">var </span><span class="s0">M=c.getMatchIndex(S.text.slice(</span><span class="s3">0</span><span class="s0">,E.valueRange.origStart),/---\s*$/);M&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;!/[\r\n]/.test(S.text[M-1])&amp;&amp;(M=-</span><span class="s3">1</span><span class="s0">);</span><span class="s1">var </span><span class="s0">T=M===-</span><span class="s3">1</span><span class="s0">?{origStart:E.valueRange.origStart,origEnd:E.valueRange.origStart}:{origStart:M,origEnd:M+</span><span class="s3">3</span><span class="s0">};</span><span class="s1">return </span><span class="s0">I.length!==</span><span class="s3">0</span><span class="s0">&amp;&amp;(T.origStart=I[</span><span class="s3">0</span><span class="s0">].position.start.offset),{position:S.transformRange(T),endMarkerPoint:M===-</span><span class="s3">1</span><span class="s0">?</span><span class="s1">null</span><span class="s0">:S.transformOffset(M)}}}}),gr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/document.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=ur(),r=Le(),c=mr(),h=hr();</span><span class="s1">function </span><span class="s0">d(y,E){</span><span class="s1">var </span><span class="s0">I=h.transformDocumentHead(y,E),S=I.createDocumentHeadWithTrailingComment,M=I.documentHeadEndMarkerPoint,T=c.transformDocumentBody(y,E,M),P=T.documentBody,C=T.documentEndPoint,q=T.documentTrailingComment,R=T.documentHeadTrailingComment,B=S(R);</span><span class="s1">return </span><span class="s0">q&amp;&amp;E.comments.push(q),e.createDocument(r.createPosition(B.position.start,C),B,P,q)}n.transformDocument=d}}),Ze=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/flow-collection.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Se(),c=Ee(),h=me();</span><span class="s1">function </span><span class="s0">d(y,E,I){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign(e.__assign(e.__assign(e.__assign({},h.createNode(</span><span class="s2">&quot;flowCollection&quot;</span><span class="s0">,y)),r.createCommentAttachable()),c.createEndCommentAttachable()),E),{children:I})}n.createFlowCollection=d}}),pr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/flow-mapping.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Ze();</span><span class="s1">function </span><span class="s0">c(h,d,y){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign({},r.createFlowCollection(h,d,y)),{type:</span><span class="s2">&quot;flowMapping&quot;</span><span class="s0">})}n.createFlowMapping=c}}),Xe=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/flow-mapping-item.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Oe(),c=me();</span><span class="s1">function </span><span class="s0">h(d,y,E){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign(e.__assign({},c.createNode(</span><span class="s2">&quot;flowMappingItem&quot;</span><span class="s0">,d)),r.createLeadingCommentAttachable()),{children:[y,E]})}n.createFlowMappingItem=h}}),Be=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/utils/extract-comments.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r,c){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">h=[],d=</span><span class="s3">0</span><span class="s0">,y=r;d&lt;y.length;d++){</span><span class="s1">var </span><span class="s0">E=y[d];E&amp;&amp;</span><span class="s2">&quot;type&quot;</span><span class="s1">in </span><span class="s0">E&amp;&amp;E.type===</span><span class="s2">&quot;COMMENT&quot;</span><span class="s0">?c.comments.push(c.transformNode(E)):h.push(E)}</span><span class="s1">return </span><span class="s0">h}n.extractComments=e}}),et=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/utils/get-flow-map-item-additional-ranges.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r){</span><span class="s1">var </span><span class="s0">c=[</span><span class="s2">&quot;?&quot;</span><span class="s0">,</span><span class="s2">&quot;:&quot;</span><span class="s0">].map(</span><span class="s1">function</span><span class="s0">(y){</span><span class="s1">var </span><span class="s0">E=r.find(</span><span class="s1">function</span><span class="s0">(I){</span><span class="s1">return</span><span class="s2">&quot;char&quot;</span><span class="s1">in </span><span class="s0">I&amp;&amp;I.char===y});</span><span class="s1">return </span><span class="s0">E?{origStart:E.origOffset,origEnd:E.origOffset+</span><span class="s3">1</span><span class="s0">}:</span><span class="s1">null</span><span class="s0">}),h=c[</span><span class="s3">0</span><span class="s0">],d=c[</span><span class="s3">1</span><span class="s0">];</span><span class="s1">return</span><span class="s0">{additionalKeyRange:h,additionalValueRange:d}}n.getFlowMapItemAdditionalRanges=e}}),tt=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/utils/create-slicer.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r,c){</span><span class="s1">var </span><span class="s0">h=c;</span><span class="s1">return function</span><span class="s0">(d){</span><span class="s1">return </span><span class="s0">r.slice(h,h=d)}}n.createSlicer=e}}),rt=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/utils/group-cst-flow-collection-items.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=tt();</span><span class="s1">function </span><span class="s0">r(c){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">h=[],d=e.createSlicer(c,</span><span class="s3">1</span><span class="s0">),y=!</span><span class="s3">1</span><span class="s0">,E=</span><span class="s3">1</span><span class="s0">;E&lt;c.length-1;E++){</span><span class="s1">var </span><span class="s0">I=c[E];</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;char&quot;</span><span class="s1">in </span><span class="s0">I&amp;&amp;I.char===</span><span class="s2">&quot;,&quot;</span><span class="s0">){h.push(d(E)),d(E+</span><span class="s3">1</span><span class="s0">),y=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">continue</span><span class="s0">}y=!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">return </span><span class="s0">y&amp;&amp;h.push(d(c.length-1)),h}n.groupCstFlowCollectionItems=r}}),_r=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/mapping-key.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Ee(),c=me(),h=$e();</span><span class="s1">function </span><span class="s0">d(y,E){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign(e.__assign(e.__assign({},c.createNode(</span><span class="s2">&quot;mappingKey&quot;</span><span class="s0">,y)),h.createTrailingCommentAttachable()),r.createEndCommentAttachable()),{children:E?[E]:[]})}n.createMappingKey=d}}),vr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/mapping-value.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Se(),c=Ee(),h=me();</span><span class="s1">function </span><span class="s0">d(y,E){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign(e.__assign(e.__assign({},h.createNode(</span><span class="s2">&quot;mappingValue&quot;</span><span class="s0">,y)),r.createCommentAttachable()),c.createEndCommentAttachable()),{children:E?[E]:[]})}n.createMappingValue=d}}),Qe=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/pair.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=_r(),r=vr(),c=Le();</span><span class="s1">function </span><span class="s0">h(d,y,E,I,S){</span><span class="s1">var </span><span class="s0">M=y.transformNode(d.key),T=y.transformNode(d.value),P=M||I?e.createMappingKey(y.transformRange({origStart:I?I.origStart:M.position.start.offset,origEnd:M?M.position.end.offset:I.origStart+</span><span class="s3">1</span><span class="s0">}),M):</span><span class="s1">null</span><span class="s0">,C=T||S?r.createMappingValue(y.transformRange({origStart:S?S.origStart:T.position.start.offset,origEnd:T?T.position.end.offset:S.origStart+</span><span class="s3">1</span><span class="s0">}),T):</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">E(c.createPosition(P?P.position.start:C.position.start,C?C.position.end:P.position.end),P||e.createMappingKey(c.createEmptyPosition(C.position.start),</span><span class="s1">null</span><span class="s0">),C||r.createMappingValue(c.createEmptyPosition(P.position.end),</span><span class="s1">null</span><span class="s0">))}n.transformAstPair=h}}),yr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/flow-map.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=pr(),r=Xe(),c=Be(),h=et(),d=Ae(),y=rt(),E=Qe();</span><span class="s1">function </span><span class="s0">I(S,M){</span><span class="s1">var </span><span class="s0">T=c.extractComments(S.cstNode.items,M),P=y.groupCstFlowCollectionItems(T),C=S.items.map(</span><span class="s1">function</span><span class="s0">(B,U){</span><span class="s1">var </span><span class="s0">f=P[U],i=h.getFlowMapItemAdditionalRanges(f),t=i.additionalKeyRange,s=i.additionalValueRange;</span><span class="s1">return </span><span class="s0">E.transformAstPair(B,M,r.createFlowMappingItem,t,s)}),q=T[</span><span class="s3">0</span><span class="s0">],R=d.getLast(T);</span><span class="s1">return </span><span class="s0">e.createFlowMapping(M.transformRange({origStart:q.origOffset,origEnd:R.origOffset+</span><span class="s3">1</span><span class="s0">}),M.transformContent(S),C)}n.transformFlowMap=I}}),br=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/flow-sequence.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Ze();</span><span class="s1">function </span><span class="s0">c(h,d,y){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign({},r.createFlowCollection(h,d,y)),{type:</span><span class="s2">&quot;flowSequence&quot;</span><span class="s0">})}n.createFlowSequence=c}}),wr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/flow-sequence-item.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=me();</span><span class="s1">function </span><span class="s0">c(h,d){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign({},r.createNode(</span><span class="s2">&quot;flowSequenceItem&quot;</span><span class="s0">,h)),{children:[d]})}n.createFlowSequenceItem=c}}),Sr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/flow-seq.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=Xe(),r=br(),c=wr(),h=Le(),d=Be(),y=et(),E=Ae(),I=rt(),S=Qe();</span><span class="s1">function </span><span class="s0">M(T,P){</span><span class="s1">var </span><span class="s0">C=d.extractComments(T.cstNode.items,P),q=I.groupCstFlowCollectionItems(C),R=T.items.map(</span><span class="s1">function</span><span class="s0">(f,i){</span><span class="s1">if</span><span class="s0">(f.type!==</span><span class="s2">&quot;PAIR&quot;</span><span class="s0">){</span><span class="s1">var </span><span class="s0">t=P.transformNode(f);</span><span class="s1">return </span><span class="s0">c.createFlowSequenceItem(h.createPosition(t.position.start,t.position.end),t)}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">var </span><span class="s0">s=q[i],a=y.getFlowMapItemAdditionalRanges(s),m=a.additionalKeyRange,g=a.additionalValueRange;</span><span class="s1">return </span><span class="s0">S.transformAstPair(f,P,e.createFlowMappingItem,m,g)}}),B=C[</span><span class="s3">0</span><span class="s0">],U=E.getLast(C);</span><span class="s1">return </span><span class="s0">r.createFlowSequence(P.transformRange({origStart:B.origOffset,origEnd:U.origOffset+</span><span class="s3">1</span><span class="s0">}),P.transformContent(T),R)}n.transformFlowSeq=M}}),Er=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/mapping.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Oe(),c=me();</span><span class="s1">function </span><span class="s0">h(d,y,E){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign(e.__assign(e.__assign({},c.createNode(</span><span class="s2">&quot;mapping&quot;</span><span class="s0">,d)),r.createLeadingCommentAttachable()),y),{children:E})}n.createMapping=h}}),Mr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/mapping-item.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Oe(),c=me();</span><span class="s1">function </span><span class="s0">h(d,y,E){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign(e.__assign({},c.createNode(</span><span class="s2">&quot;mappingItem&quot;</span><span class="s0">,d)),r.createLeadingCommentAttachable()),{children:[y,E]})}n.createMappingItem=h}}),Or=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/map.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=Er(),r=Mr(),c=Le(),h=tt(),d=Be(),y=Ve(),E=Ae(),I=Qe();</span><span class="s1">function </span><span class="s0">S(T,P){</span><span class="s1">var </span><span class="s0">C=T.cstNode;C.items.filter(</span><span class="s1">function</span><span class="s0">(U){</span><span class="s1">return </span><span class="s0">U.type===</span><span class="s2">&quot;MAP_KEY&quot;</span><span class="s0">||U.type===</span><span class="s2">&quot;MAP_VALUE&quot;</span><span class="s0">}).forEach(</span><span class="s1">function</span><span class="s0">(U){</span><span class="s1">return </span><span class="s0">y.extractPropComments(U,P)});</span><span class="s1">var </span><span class="s0">q=d.extractComments(C.items,P),R=M(q),B=T.items.map(</span><span class="s1">function</span><span class="s0">(U,f){</span><span class="s1">var </span><span class="s0">i=R[f],t=i[</span><span class="s3">0</span><span class="s0">].type===</span><span class="s2">&quot;MAP_VALUE&quot;</span><span class="s0">?[</span><span class="s1">null</span><span class="s0">,i[</span><span class="s3">0</span><span class="s0">].range]:[i[</span><span class="s3">0</span><span class="s0">].range,i.length===</span><span class="s3">1</span><span class="s0">?</span><span class="s1">null</span><span class="s0">:i[</span><span class="s3">1</span><span class="s0">].range],s=t[</span><span class="s3">0</span><span class="s0">],a=t[</span><span class="s3">1</span><span class="s0">];</span><span class="s1">return </span><span class="s0">I.transformAstPair(U,P,r.createMappingItem,s,a)});</span><span class="s1">return </span><span class="s0">e.createMapping(c.createPosition(B[</span><span class="s3">0</span><span class="s0">].position.start,E.getLast(B).position.end),P.transformContent(T),B)}n.transformMap=S;</span><span class="s1">function </span><span class="s0">M(T){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">P=[],C=h.createSlicer(T,</span><span class="s3">0</span><span class="s0">),q=!</span><span class="s3">1</span><span class="s0">,R=</span><span class="s3">0</span><span class="s0">;R&lt;T.length;R++){</span><span class="s1">var </span><span class="s0">B=T[R];</span><span class="s1">if</span><span class="s0">(B.type===</span><span class="s2">&quot;MAP_VALUE&quot;</span><span class="s0">){P.push(C(R+</span><span class="s3">1</span><span class="s0">)),q=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">continue</span><span class="s0">}q&amp;&amp;P.push(C(R)),q=!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">return </span><span class="s0">q&amp;&amp;P.push(C(</span><span class="s3">1</span><span class="s0">/</span><span class="s3">0</span><span class="s0">)),P}}}),Lr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/plain.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Se(),c=me();</span><span class="s1">function </span><span class="s0">h(d,y,E){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign(e.__assign(e.__assign({},c.createNode(</span><span class="s2">&quot;plain&quot;</span><span class="s0">,d)),r.createCommentAttachable()),y),{value:E})}n.createPlain=h}}),Ar=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/utils/find-last-char-index.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r,c,h){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">d=c;d&gt;=</span><span class="s3">0</span><span class="s0">;d--)</span><span class="s1">if</span><span class="s0">(h.test(r[d]))</span><span class="s1">return </span><span class="s0">d;</span><span class="s1">return</span><span class="s0">-</span><span class="s3">1</span><span class="s0">}n.findLastCharIndex=e}}),Nr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/plain.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=Lr(),r=Ar();</span><span class="s1">function </span><span class="s0">c(h,d){</span><span class="s1">var </span><span class="s0">y=h.cstNode;</span><span class="s1">return </span><span class="s0">e.createPlain(d.transformRange({origStart:y.valueRange.origStart,origEnd:r.findLastCharIndex(d.text,y.valueRange.origEnd-1,/\S/)+</span><span class="s3">1</span><span class="s0">}),d.transformContent(h),y.strValue)}n.transformPlain=c}}),Tr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/quote-double.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te));</span><span class="s1">function </span><span class="s0">r(c){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign({},c),{type:</span><span class="s2">&quot;quoteDouble&quot;</span><span class="s0">})}n.createQuoteDouble=r}}),Cr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/quote-value.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Se(),c=me();</span><span class="s1">function </span><span class="s0">h(d,y,E){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign(e.__assign(e.__assign({},c.createNode(</span><span class="s2">&quot;quoteValue&quot;</span><span class="s0">,d)),y),r.createCommentAttachable()),{value:E})}n.createQuoteValue=h}}),nt=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/quote-value.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=Cr();</span><span class="s1">function </span><span class="s0">r(c,h){</span><span class="s1">var </span><span class="s0">d=c.cstNode;</span><span class="s1">return </span><span class="s0">e.createQuoteValue(h.transformRange(d.valueRange),h.transformContent(c),d.strValue)}n.transformAstQuoteValue=r}}),kr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/quote-double.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=Tr(),r=nt();</span><span class="s1">function </span><span class="s0">c(h,d){</span><span class="s1">return </span><span class="s0">e.createQuoteDouble(r.transformAstQuoteValue(h,d))}n.transformQuoteDouble=c}}),Pr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/quote-single.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te));</span><span class="s1">function </span><span class="s0">r(c){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign({},c),{type:</span><span class="s2">&quot;quoteSingle&quot;</span><span class="s0">})}n.createQuoteSingle=r}}),Ir=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/quote-single.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=Pr(),r=nt();</span><span class="s1">function </span><span class="s0">c(h,d){</span><span class="s1">return </span><span class="s0">e.createQuoteSingle(r.transformAstQuoteValue(h,d))}n.transformQuoteSingle=c}}),Rr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/sequence.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Ee(),c=Oe(),h=me();</span><span class="s1">function </span><span class="s0">d(y,E,I){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign(e.__assign(e.__assign(e.__assign({},h.createNode(</span><span class="s2">&quot;sequence&quot;</span><span class="s0">,y)),c.createLeadingCommentAttachable()),r.createEndCommentAttachable()),E),{children:I})}n.createSequence=d}}),qr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/sequence-item.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te)),r=Se(),c=Ee(),h=me();</span><span class="s1">function </span><span class="s0">d(y,E){</span><span class="s1">return </span><span class="s0">e.__assign(e.__assign(e.__assign(e.__assign({},h.createNode(</span><span class="s2">&quot;sequenceItem&quot;</span><span class="s0">,y)),r.createCommentAttachable()),c.createEndCommentAttachable()),{children:E?[E]:[]})}n.createSequenceItem=d}}),$r=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/seq.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=Le(),r=Rr(),c=qr(),h=Be(),d=Ve(),y=Ae();</span><span class="s1">function </span><span class="s0">E(I,S){</span><span class="s1">var </span><span class="s0">M=h.extractComments(I.cstNode.items,S),T=M.map(</span><span class="s1">function</span><span class="s0">(P,C){d.extractPropComments(P,S);</span><span class="s1">var </span><span class="s0">q=S.transformNode(I.items[C]);</span><span class="s1">return </span><span class="s0">c.createSequenceItem(e.createPosition(S.transformOffset(P.valueRange.origStart),q===</span><span class="s1">null</span><span class="s0">?S.transformOffset(P.valueRange.origStart+</span><span class="s3">1</span><span class="s0">):q.position.end),q)});</span><span class="s1">return </span><span class="s0">r.createSequence(e.createPosition(T[</span><span class="s3">0</span><span class="s0">].position.start,y.getLast(T).position.end),S.transformContent(I),T)}n.transformSeq=E}}),Br=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transform.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=Zt(),r=sr(),c=ar(),h=or(),d=cr(),y=gr(),E=yr(),I=Sr(),S=Or(),M=Nr(),T=kr(),P=Ir(),C=$r();</span><span class="s1">function </span><span class="s0">q(R,B){</span><span class="s1">if</span><span class="s0">(R===</span><span class="s1">null</span><span class="s0">||R.type===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;R.value===</span><span class="s1">null</span><span class="s0">)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">switch</span><span class="s0">(R.type){</span><span class="s1">case</span><span class="s2">&quot;ALIAS&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.transformAlias(R,B);</span><span class="s1">case</span><span class="s2">&quot;BLOCK_FOLDED&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r.transformBlockFolded(R,B);</span><span class="s1">case</span><span class="s2">&quot;BLOCK_LITERAL&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">c.transformBlockLiteral(R,B);</span><span class="s1">case</span><span class="s2">&quot;COMMENT&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">h.transformComment(R,B);</span><span class="s1">case</span><span class="s2">&quot;DIRECTIVE&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">d.transformDirective(R,B);</span><span class="s1">case</span><span class="s2">&quot;DOCUMENT&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">y.transformDocument(R,B);</span><span class="s1">case</span><span class="s2">&quot;FLOW_MAP&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">E.transformFlowMap(R,B);</span><span class="s1">case</span><span class="s2">&quot;FLOW_SEQ&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">I.transformFlowSeq(R,B);</span><span class="s1">case</span><span class="s2">&quot;MAP&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">S.transformMap(R,B);</span><span class="s1">case</span><span class="s2">&quot;PLAIN&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">M.transformPlain(R,B);</span><span class="s1">case</span><span class="s2">&quot;QUOTE_DOUBLE&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">T.transformQuoteDouble(R,B);</span><span class="s1">case</span><span class="s2">&quot;QUOTE_SINGLE&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">P.transformQuoteSingle(R,B);</span><span class="s1">case</span><span class="s2">&quot;SEQ&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">C.transformSeq(R,B);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Unexpected node type &quot;</span><span class="s0">+R.type)}}n.transformNode=q}}),jr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/error.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r,c,h){</span><span class="s1">var </span><span class="s0">d=</span><span class="s1">new </span><span class="s0">SyntaxError(r);</span><span class="s1">return </span><span class="s0">d.name=</span><span class="s2">&quot;YAMLSyntaxError&quot;</span><span class="s0">,d.source=c,d.position=h,d}n.createError=e}}),Yr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/error.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=jr();</span><span class="s1">function </span><span class="s0">r(c,h){</span><span class="s1">var </span><span class="s0">d=c.source.range||c.source.valueRange;</span><span class="s1">return </span><span class="s0">e.createError(c.message,h.text,h.transformRange(d))}n.transformError=r}}),Dr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/factories/point.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r,c,h){</span><span class="s1">return</span><span class="s0">{offset:r,line:c,column:h}}n.createPoint=e}}),Fr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/offset.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=Dr();</span><span class="s1">function </span><span class="s0">r(c,h){c&lt;</span><span class="s3">0</span><span class="s0">?c=</span><span class="s3">0</span><span class="s0">:c&gt;h.text.length&amp;&amp;(c=h.text.length);</span><span class="s1">var </span><span class="s0">d=h.locator.locationForIndex(c);</span><span class="s1">return </span><span class="s0">e.createPoint(c,d.line+</span><span class="s3">1</span><span class="s0">,d.column+</span><span class="s3">1</span><span class="s0">)}n.transformOffset=r}}),Wr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/transforms/range.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=Le();</span><span class="s1">function </span><span class="s0">r(c,h){</span><span class="s1">return </span><span class="s0">e.createPosition(h.transformOffset(c.origStart),h.transformOffset(c.origEnd))}n.transformRange=r}}),Vr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/utils/add-orig-range.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">r(y){</span><span class="s1">if</span><span class="s0">(!y.setOrigRanges()){</span><span class="s1">var </span><span class="s0">E=</span><span class="s1">function</span><span class="s0">(I){</span><span class="s1">if</span><span class="s0">(h(I))</span><span class="s1">return </span><span class="s0">I.origStart=I.start,I.origEnd=I.end,e;</span><span class="s1">if</span><span class="s0">(d(I))</span><span class="s1">return </span><span class="s0">I.origOffset=I.offset,e};y.forEach(</span><span class="s1">function</span><span class="s0">(I){</span><span class="s1">return </span><span class="s0">c(I,E)})}}n.addOrigRange=r;</span><span class="s1">function </span><span class="s0">c(y,E){</span><span class="s1">if</span><span class="s0">(!(!y||</span><span class="s1">typeof </span><span class="s0">y!=</span><span class="s2">&quot;object&quot;</span><span class="s0">)&amp;&amp;E(y)!==e)</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">I=</span><span class="s3">0</span><span class="s0">,S=Object.keys(y);I&lt;S.length;I++){</span><span class="s1">var </span><span class="s0">M=S[I];</span><span class="s1">if</span><span class="s0">(!(M===</span><span class="s2">&quot;context&quot;</span><span class="s0">||M===</span><span class="s2">&quot;error&quot;</span><span class="s0">)){</span><span class="s1">var </span><span class="s0">T=y[M];Array.isArray(T)?T.forEach(</span><span class="s1">function</span><span class="s0">(P){</span><span class="s1">return </span><span class="s0">c(P,E)}):c(T,E)}}}</span><span class="s1">function </span><span class="s0">h(y){</span><span class="s1">return typeof </span><span class="s0">y.start==</span><span class="s2">&quot;number&quot;</span><span class="s0">}</span><span class="s1">function </span><span class="s0">d(y){</span><span class="s1">return typeof </span><span class="s0">y.offset==</span><span class="s2">&quot;number&quot;</span><span class="s0">}}}),Qr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/utils/remove-fake-nodes.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;children&quot;</span><span class="s1">in </span><span class="s0">r){</span><span class="s1">if</span><span class="s0">(r.children.length===</span><span class="s3">1</span><span class="s0">){</span><span class="s1">var </span><span class="s0">c=r.children[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(c.type===</span><span class="s2">&quot;plain&quot;</span><span class="s0">&amp;&amp;c.tag===</span><span class="s1">null</span><span class="s0">&amp;&amp;c.anchor===</span><span class="s1">null</span><span class="s0">&amp;&amp;c.value===</span><span class="s2">&quot;&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">r.children.splice(</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">),r}r.children.forEach(e)}</span><span class="s1">return </span><span class="s0">r}n.removeFakeNodes=e}}),Ur=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/utils/create-updater.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">e(r,c,h,d){</span><span class="s1">var </span><span class="s0">y=c(r);</span><span class="s1">return function</span><span class="s0">(E){d(y,E)&amp;&amp;h(r,y=E)}}n.createUpdater=e}}),Kr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/utils/update-positions.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=Ur(),r=Ae();</span><span class="s1">function </span><span class="s0">c(M){</span><span class="s1">if</span><span class="s0">(!(M===</span><span class="s1">null</span><span class="s0">||!(</span><span class="s2">&quot;children&quot;</span><span class="s1">in </span><span class="s0">M))){</span><span class="s1">var </span><span class="s0">T=M.children;</span><span class="s1">if</span><span class="s0">(T.forEach(c),M.type===</span><span class="s2">&quot;document&quot;</span><span class="s0">){</span><span class="s1">var </span><span class="s0">P=M.children,C=P[</span><span class="s3">0</span><span class="s0">],q=P[</span><span class="s3">1</span><span class="s0">];C.position.start.offset===C.position.end.offset?C.position.start=C.position.end=q.position.start:q.position.start.offset===q.position.end.offset&amp;&amp;(q.position.start=q.position.end=C.position.end)}</span><span class="s1">var </span><span class="s0">R=e.createUpdater(M.position,h,d,I),B=e.createUpdater(M.position,y,E,S);</span><span class="s2">&quot;endComments&quot;</span><span class="s1">in </span><span class="s0">M&amp;&amp;M.endComments.length!==</span><span class="s3">0</span><span class="s0">&amp;&amp;(R(M.endComments[</span><span class="s3">0</span><span class="s0">].position.start),B(r.getLast(M.endComments).position.end));</span><span class="s1">var </span><span class="s0">U=T.filter(</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">return </span><span class="s0">t!==</span><span class="s1">null</span><span class="s0">});</span><span class="s1">if</span><span class="s0">(U.length!==</span><span class="s3">0</span><span class="s0">){</span><span class="s1">var </span><span class="s0">f=U[</span><span class="s3">0</span><span class="s0">],i=r.getLast(U);R(f.position.start),B(i.position.end),</span><span class="s2">&quot;leadingComments&quot;</span><span class="s1">in </span><span class="s0">f&amp;&amp;f.leadingComments.length!==</span><span class="s3">0</span><span class="s0">&amp;&amp;R(f.leadingComments[</span><span class="s3">0</span><span class="s0">].position.start),</span><span class="s2">&quot;tag&quot;</span><span class="s1">in </span><span class="s0">f&amp;&amp;f.tag&amp;&amp;R(f.tag.position.start),</span><span class="s2">&quot;anchor&quot;</span><span class="s1">in </span><span class="s0">f&amp;&amp;f.anchor&amp;&amp;R(f.anchor.position.start),</span><span class="s2">&quot;trailingComment&quot;</span><span class="s1">in </span><span class="s0">i&amp;&amp;i.trailingComment&amp;&amp;B(i.trailingComment.position.end)}}}n.updatePositions=c;</span><span class="s1">function </span><span class="s0">h(M){</span><span class="s1">return </span><span class="s0">M.start}</span><span class="s1">function </span><span class="s0">d(M,T){M.start=T}</span><span class="s1">function </span><span class="s0">y(M){</span><span class="s1">return </span><span class="s0">M.end}</span><span class="s1">function </span><span class="s0">E(M,T){M.end=T}</span><span class="s1">function </span><span class="s0">I(M,T){</span><span class="s1">return </span><span class="s0">T.offset&lt;M.offset}</span><span class="s1">function </span><span class="s0">S(M,T){</span><span class="s1">return </span><span class="s0">T.offset&gt;M.offset}}}),Me=D({</span><span class="s2">&quot;node_modules/yaml/dist/PlainValue-ec8e588e.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y();</span><span class="s1">var </span><span class="s0">e={ANCHOR:</span><span class="s2">&quot;&amp;&quot;</span><span class="s0">,COMMENT:</span><span class="s2">&quot;#&quot;</span><span class="s0">,TAG:</span><span class="s2">&quot;!&quot;</span><span class="s0">,DIRECTIVES_END:</span><span class="s2">&quot;-&quot;</span><span class="s0">,DOCUMENT_END:</span><span class="s2">&quot;.&quot;</span><span class="s0">},r={ALIAS:</span><span class="s2">&quot;ALIAS&quot;</span><span class="s0">,BLANK_LINE:</span><span class="s2">&quot;BLANK_LINE&quot;</span><span class="s0">,BLOCK_FOLDED:</span><span class="s2">&quot;BLOCK_FOLDED&quot;</span><span class="s0">,BLOCK_LITERAL:</span><span class="s2">&quot;BLOCK_LITERAL&quot;</span><span class="s0">,COMMENT:</span><span class="s2">&quot;COMMENT&quot;</span><span class="s0">,DIRECTIVE:</span><span class="s2">&quot;DIRECTIVE&quot;</span><span class="s0">,DOCUMENT:</span><span class="s2">&quot;DOCUMENT&quot;</span><span class="s0">,FLOW_MAP:</span><span class="s2">&quot;FLOW_MAP&quot;</span><span class="s0">,FLOW_SEQ:</span><span class="s2">&quot;FLOW_SEQ&quot;</span><span class="s0">,MAP:</span><span class="s2">&quot;MAP&quot;</span><span class="s0">,MAP_KEY:</span><span class="s2">&quot;MAP_KEY&quot;</span><span class="s0">,MAP_VALUE:</span><span class="s2">&quot;MAP_VALUE&quot;</span><span class="s0">,PLAIN:</span><span class="s2">&quot;PLAIN&quot;</span><span class="s0">,QUOTE_DOUBLE:</span><span class="s2">&quot;QUOTE_DOUBLE&quot;</span><span class="s0">,QUOTE_SINGLE:</span><span class="s2">&quot;QUOTE_SINGLE&quot;</span><span class="s0">,SEQ:</span><span class="s2">&quot;SEQ&quot;</span><span class="s0">,SEQ_ITEM:</span><span class="s2">&quot;SEQ_ITEM&quot;</span><span class="s0">},c=</span><span class="s2">&quot;tag:yaml.org,2002:&quot;</span><span class="s0">,h={MAP:</span><span class="s2">&quot;tag:yaml.org,2002:map&quot;</span><span class="s0">,SEQ:</span><span class="s2">&quot;tag:yaml.org,2002:seq&quot;</span><span class="s0">,STR:</span><span class="s2">&quot;tag:yaml.org,2002:str&quot;</span><span class="s0">};</span><span class="s1">function </span><span class="s0">d(i){let t=[</span><span class="s3">0</span><span class="s0">],s=i.indexOf(`</span>
<span class="s0">`);</span><span class="s1">for</span><span class="s0">(;s!==-</span><span class="s3">1</span><span class="s0">;)s+=</span><span class="s3">1</span><span class="s0">,t.push(s),s=i.indexOf(`</span>
<span class="s0">`,s);</span><span class="s1">return </span><span class="s0">t}</span><span class="s1">function </span><span class="s0">y(i){let t,s;</span><span class="s1">return typeof </span><span class="s0">i==</span><span class="s2">&quot;string&quot;</span><span class="s0">?(t=d(i),s=i):(Array.isArray(i)&amp;&amp;(i=i[</span><span class="s3">0</span><span class="s0">]),i&amp;&amp;i.context&amp;&amp;(i.lineStarts||(i.lineStarts=d(i.context.src)),t=i.lineStarts,s=i.context.src)),{lineStarts:t,src:s}}</span><span class="s1">function </span><span class="s0">E(i,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">i!=</span><span class="s2">&quot;number&quot;</span><span class="s0">||i&lt;</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return null</span><span class="s0">;let{lineStarts:s,src:a}=y(t);</span><span class="s1">if</span><span class="s0">(!s||!a||i&gt;a.length)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let g=</span><span class="s3">0</span><span class="s0">;g&lt;s.length;++g){let u=s[g];</span><span class="s1">if</span><span class="s0">(i&lt;u)</span><span class="s1">return</span><span class="s0">{line:g,col:i-s[g-1]+</span><span class="s3">1</span><span class="s0">};</span><span class="s1">if</span><span class="s0">(i===u)</span><span class="s1">return</span><span class="s0">{line:g+</span><span class="s3">1</span><span class="s0">,col:</span><span class="s3">1</span><span class="s0">}}let m=s.length;</span><span class="s1">return</span><span class="s0">{line:m,col:i-s[m-1]+</span><span class="s3">1</span><span class="s0">}}</span><span class="s1">function </span><span class="s0">I(i,t){let{lineStarts:s,src:a}=y(t);</span><span class="s1">if</span><span class="s0">(!s||!(i&gt;=</span><span class="s3">1</span><span class="s0">)||i&gt;s.length)</span><span class="s1">return null</span><span class="s0">;let m=s[i-1],g=s[i];</span><span class="s1">for</span><span class="s0">(;g&amp;&amp;g&gt;m&amp;&amp;a[g-1]===`</span>
<span class="s0">`;)--g;</span><span class="s1">return </span><span class="s0">a.slice(m,g)}</span><span class="s1">function </span><span class="s0">S(i,t){let{start:s,end:a}=i,m=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">2</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">2</span><span class="s0">]:</span><span class="s3">80</span><span class="s0">,g=I(s.line,t);</span><span class="s1">if</span><span class="s0">(!g)</span><span class="s1">return null</span><span class="s0">;let{col:u}=s;</span><span class="s1">if</span><span class="s0">(g.length&gt;m)</span><span class="s1">if</span><span class="s0">(u&lt;=m-10)g=g.substr(</span><span class="s3">0</span><span class="s0">,m-1)+</span><span class="s2">&quot;</span><span class="s4">\u2026</span><span class="s2">&quot;</span><span class="s0">;</span><span class="s1">else</span><span class="s0">{let K=Math.round(m/</span><span class="s3">2</span><span class="s0">);g.length&gt;u+K&amp;&amp;(g=g.substr(</span><span class="s3">0</span><span class="s0">,u+K-1)+</span><span class="s2">&quot;</span><span class="s4">\u2026</span><span class="s2">&quot;</span><span class="s0">),u-=g.length-m,g=</span><span class="s2">&quot;</span><span class="s4">\u2026</span><span class="s2">&quot;</span><span class="s0">+g.substr(</span><span class="s3">1</span><span class="s0">-m)}let p=</span><span class="s3">1</span><span class="s0">,L=</span><span class="s2">&quot;&quot;</span><span class="s0">;a&amp;&amp;(a.line===s.line&amp;&amp;u+(a.col-s.col)&lt;=m+</span><span class="s3">1</span><span class="s0">?p=a.col-s.col:(p=Math.min(g.length+</span><span class="s3">1</span><span class="s0">,m)-u,L=</span><span class="s2">&quot;</span><span class="s4">\u2026</span><span class="s2">&quot;</span><span class="s0">));let k=u&gt;</span><span class="s3">1</span><span class="s0">?</span><span class="s2">&quot; &quot;</span><span class="s0">.repeat(u-1):</span><span class="s2">&quot;&quot;</span><span class="s0">,$=</span><span class="s2">&quot;^&quot;</span><span class="s0">.repeat(p);</span><span class="s1">return</span><span class="s0">`${g}</span>
<span class="s0">${k}${$}${L}`}</span><span class="s1">var </span><span class="s0">M=class{static copy(i){</span><span class="s1">return new </span><span class="s0">M(i.start,i.end)}constructor(i,t){</span><span class="s1">this</span><span class="s0">.start=i,</span><span class="s1">this</span><span class="s0">.end=t||i}isEmpty(){</span><span class="s1">return typeof this</span><span class="s0">.start!=</span><span class="s2">&quot;number&quot;</span><span class="s0">||!</span><span class="s1">this</span><span class="s0">.end||</span><span class="s1">this</span><span class="s0">.end&lt;=</span><span class="s1">this</span><span class="s0">.start}setOrigRange(i,t){let{start:s,end:a}=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(i.length===</span><span class="s3">0</span><span class="s0">||a&lt;=i[</span><span class="s3">0</span><span class="s0">])</span><span class="s1">return this</span><span class="s0">.origStart=s,</span><span class="s1">this</span><span class="s0">.origEnd=a,t;let m=t;</span><span class="s1">for</span><span class="s0">(;m&lt;i.length&amp;&amp;!(i[m]&gt;s);)++m;</span><span class="s1">this</span><span class="s0">.origStart=s+m;let g=m;</span><span class="s1">for</span><span class="s0">(;m&lt;i.length&amp;&amp;!(i[m]&gt;=a);)++m;</span><span class="s1">return this</span><span class="s0">.origEnd=a+m,g}},T=class{static addStringTerminator(i,t,s){</span><span class="s1">if</span><span class="s0">(s[s.length-1]===`</span>
<span class="s0">`)</span><span class="s1">return </span><span class="s0">s;let a=T.endOfWhiteSpace(i,t);</span><span class="s1">return </span><span class="s0">a&gt;=i.length||i[a]===`</span>
<span class="s0">`?s+`</span>
<span class="s0">`:s}static atDocumentBoundary(i,t,s){let a=i[t];</span><span class="s1">if</span><span class="s0">(!a)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;let m=i[t-1];</span><span class="s1">if</span><span class="s0">(m&amp;&amp;m!==`</span>
<span class="s0">`)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(s){</span><span class="s1">if</span><span class="s0">(a!==s)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(a!==e.DIRECTIVES_END&amp;&amp;a!==e.DOCUMENT_END)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let g=i[t+</span><span class="s3">1</span><span class="s0">],u=i[t+</span><span class="s3">2</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(g!==a||u!==a)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let p=i[t+</span><span class="s3">3</span><span class="s0">];</span><span class="s1">return</span><span class="s0">!p||p===`</span>
<span class="s0">`||p===</span><span class="s2">&quot;    &quot;</span><span class="s0">||p===</span><span class="s2">&quot; &quot;</span><span class="s0">}static endOfIdentifier(i,t){let s=i[t],a=s===</span><span class="s2">&quot;&lt;&quot;</span><span class="s0">,m=a?[`</span>
<span class="s0">`,</span><span class="s2">&quot; &quot;</span><span class="s0">,</span><span class="s2">&quot; &quot;</span><span class="s0">,</span><span class="s2">&quot;&gt;&quot;</span><span class="s0">]:[`</span>
<span class="s0">`,</span><span class="s2">&quot; &quot;</span><span class="s0">,</span><span class="s2">&quot; &quot;</span><span class="s0">,</span><span class="s2">&quot;[&quot;</span><span class="s0">,</span><span class="s2">&quot;]&quot;</span><span class="s0">,</span><span class="s2">&quot;{&quot;</span><span class="s0">,</span><span class="s2">&quot;}&quot;</span><span class="s0">,</span><span class="s2">&quot;,&quot;</span><span class="s0">];</span><span class="s1">for</span><span class="s0">(;s&amp;&amp;m.indexOf(s)===-</span><span class="s3">1</span><span class="s0">;)s=i[t+=</span><span class="s3">1</span><span class="s0">];</span><span class="s1">return </span><span class="s0">a&amp;&amp;s===</span><span class="s2">&quot;&gt;&quot;</span><span class="s0">&amp;&amp;(t+=</span><span class="s3">1</span><span class="s0">),t}static endOfIndent(i,t){let s=i[t];</span><span class="s1">for</span><span class="s0">(;s===</span><span class="s2">&quot; &quot;</span><span class="s0">;)s=i[t+=</span><span class="s3">1</span><span class="s0">];</span><span class="s1">return </span><span class="s0">t}static endOfLine(i,t){let s=i[t];</span><span class="s1">for</span><span class="s0">(;s&amp;&amp;s!==`</span>
<span class="s0">`;)s=i[t+=</span><span class="s3">1</span><span class="s0">];</span><span class="s1">return </span><span class="s0">t}static endOfWhiteSpace(i,t){let s=i[t];</span><span class="s1">for</span><span class="s0">(;s===</span><span class="s2">&quot;    &quot;</span><span class="s0">||s===</span><span class="s2">&quot; &quot;</span><span class="s0">;)s=i[t+=</span><span class="s3">1</span><span class="s0">];</span><span class="s1">return </span><span class="s0">t}static startOfLine(i,t){let s=i[t-1];</span><span class="s1">if</span><span class="s0">(s===`</span>
<span class="s0">`)</span><span class="s1">return </span><span class="s0">t;</span><span class="s1">for</span><span class="s0">(;s&amp;&amp;s!==`</span>
<span class="s0">`;)s=i[t-=</span><span class="s3">1</span><span class="s0">];</span><span class="s1">return </span><span class="s0">t+</span><span class="s3">1</span><span class="s0">}static endOfBlockIndent(i,t,s){let a=T.endOfIndent(i,s);</span><span class="s1">if</span><span class="s0">(a&gt;s+t)</span><span class="s1">return </span><span class="s0">a;{let m=T.endOfWhiteSpace(i,a),g=i[m];</span><span class="s1">if</span><span class="s0">(!g||g===`</span>
<span class="s0">`)</span><span class="s1">return </span><span class="s0">m}</span><span class="s1">return null</span><span class="s0">}static atBlank(i,t,s){let a=i[t];</span><span class="s1">return </span><span class="s0">a===`</span>
<span class="s0">`||a===</span><span class="s2">&quot;    &quot;</span><span class="s0">||a===</span><span class="s2">&quot; &quot;</span><span class="s0">||s&amp;&amp;!a}static nextNodeIsIndented(i,t,s){</span><span class="s1">return</span><span class="s0">!i||t&lt;</span><span class="s3">0</span><span class="s0">?!</span><span class="s3">1</span><span class="s0">:t&gt;</span><span class="s3">0</span><span class="s0">?!</span><span class="s3">0</span><span class="s0">:s&amp;&amp;i===</span><span class="s2">&quot;-&quot;</span><span class="s0">}static normalizeOffset(i,t){let s=i[t];</span><span class="s1">return </span><span class="s0">s?s!==`</span>
<span class="s0">`&amp;&amp;i[t-1]===`</span>
<span class="s0">`?t-1:T.endOfWhiteSpace(i,t):t}static foldNewline(i,t,s){let a=</span><span class="s3">0</span><span class="s0">,m=!</span><span class="s3">1</span><span class="s0">,g=</span><span class="s2">&quot;&quot;</span><span class="s0">,u=i[t+</span><span class="s3">1</span><span class="s0">];</span><span class="s1">for</span><span class="s0">(;u===</span><span class="s2">&quot; &quot;</span><span class="s0">||u===</span><span class="s2">&quot;   &quot;</span><span class="s0">||u===`</span>
<span class="s0">`;){</span><span class="s1">switch</span><span class="s0">(u){</span><span class="s1">case</span><span class="s0">`</span>
<span class="s0">`:a=</span><span class="s3">0</span><span class="s0">,t+=</span><span class="s3">1</span><span class="s0">,g+=`</span>
<span class="s0">`;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;   &quot;</span><span class="s0">:a&lt;=s&amp;&amp;(m=!</span><span class="s3">0</span><span class="s0">),t=T.endOfWhiteSpace(i,t+</span><span class="s3">2</span><span class="s0">)-</span><span class="s3">1</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot; &quot;</span><span class="s0">:a+=</span><span class="s3">1</span><span class="s0">,t+=</span><span class="s3">1</span><span class="s0">;</span><span class="s1">break</span><span class="s0">}u=i[t+</span><span class="s3">1</span><span class="s0">]}</span><span class="s1">return </span><span class="s0">g||(g=</span><span class="s2">&quot; &quot;</span><span class="s0">),u&amp;&amp;a&lt;=s&amp;&amp;(m=!</span><span class="s3">0</span><span class="s0">),{fold:g,offset:t,error:m}}constructor(i,t,s){Object.defineProperty(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;context&quot;</span><span class="s0">,{value:s||</span><span class="s1">null</span><span class="s0">,writable:!</span><span class="s3">0</span><span class="s0">}),</span><span class="s1">this</span><span class="s0">.error=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.range=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.valueRange=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.props=t||[],</span><span class="s1">this</span><span class="s0">.type=i,</span><span class="s1">this</span><span class="s0">.value=</span><span class="s1">null</span><span class="s0">}getPropValue(i,t,s){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.context)</span><span class="s1">return null</span><span class="s0">;let{src:a}=</span><span class="s1">this</span><span class="s0">.context,m=</span><span class="s1">this</span><span class="s0">.props[i];</span><span class="s1">return </span><span class="s0">m&amp;&amp;a[m.start]===t?a.slice(m.start+(s?</span><span class="s3">1</span><span class="s0">:</span><span class="s3">0</span><span class="s0">),m.end):</span><span class="s1">null</span><span class="s0">}get anchor(){</span><span class="s1">for</span><span class="s0">(let i=</span><span class="s3">0</span><span class="s0">;i&lt;</span><span class="s1">this</span><span class="s0">.props.length;++i){let t=</span><span class="s1">this</span><span class="s0">.getPropValue(i,e.ANCHOR,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(t!=</span><span class="s1">null</span><span class="s0">)</span><span class="s1">return </span><span class="s0">t}</span><span class="s1">return null</span><span class="s0">}get comment(){let i=[];</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s3">0</span><span class="s0">;t&lt;</span><span class="s1">this</span><span class="s0">.props.length;++t){let s=</span><span class="s1">this</span><span class="s0">.getPropValue(t,e.COMMENT,!</span><span class="s3">0</span><span class="s0">);s!=</span><span class="s1">null</span><span class="s0">&amp;&amp;i.push(s)}</span><span class="s1">return </span><span class="s0">i.length&gt;</span><span class="s3">0</span><span class="s0">?i.join(`</span>
<span class="s0">`):</span><span class="s1">null</span><span class="s0">}commentHasRequiredWhitespace(i){let{src:t}=</span><span class="s1">this</span><span class="s0">.context;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.header&amp;&amp;i===</span><span class="s1">this</span><span class="s0">.header.end||!</span><span class="s1">this</span><span class="s0">.valueRange)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let{end:s}=</span><span class="s1">this</span><span class="s0">.valueRange;</span><span class="s1">return </span><span class="s0">i!==s||T.atBlank(t,s-1)}get hasComment(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.context){let{src:i}=</span><span class="s1">this</span><span class="s0">.context;</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s3">0</span><span class="s0">;t&lt;</span><span class="s1">this</span><span class="s0">.props.length;++t)</span><span class="s1">if</span><span class="s0">(i[</span><span class="s1">this</span><span class="s0">.props[t].start]===e.COMMENT)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}get hasProps(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.context){let{src:i}=</span><span class="s1">this</span><span class="s0">.context;</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s3">0</span><span class="s0">;t&lt;</span><span class="s1">this</span><span class="s0">.props.length;++t)</span><span class="s1">if</span><span class="s0">(i[</span><span class="s1">this</span><span class="s0">.props[t].start]!==e.COMMENT)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}get includesTrailingLines(){</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}get jsonLike(){</span><span class="s1">return</span><span class="s0">[r.FLOW_MAP,r.FLOW_SEQ,r.QUOTE_DOUBLE,r.QUOTE_SINGLE].indexOf(</span><span class="s1">this</span><span class="s0">.type)!==-</span><span class="s3">1</span><span class="s0">}get rangeAsLinePos(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.range||!</span><span class="s1">this</span><span class="s0">.context)</span><span class="s1">return</span><span class="s0">;let i=E(</span><span class="s1">this</span><span class="s0">.range.start,</span><span class="s1">this</span><span class="s0">.context.root);</span><span class="s1">if</span><span class="s0">(!i)</span><span class="s1">return</span><span class="s0">;let t=E(</span><span class="s1">this</span><span class="s0">.range.end,</span><span class="s1">this</span><span class="s0">.context.root);</span><span class="s1">return</span><span class="s0">{start:i,end:t}}get rawValue(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.valueRange||!</span><span class="s1">this</span><span class="s0">.context)</span><span class="s1">return null</span><span class="s0">;let{start:i,end:t}=</span><span class="s1">this</span><span class="s0">.valueRange;</span><span class="s1">return this</span><span class="s0">.context.src.slice(i,t)}get tag(){</span><span class="s1">for</span><span class="s0">(let i=</span><span class="s3">0</span><span class="s0">;i&lt;</span><span class="s1">this</span><span class="s0">.props.length;++i){let t=</span><span class="s1">this</span><span class="s0">.getPropValue(i,e.TAG,!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(t!=</span><span class="s1">null</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(t[</span><span class="s3">1</span><span class="s0">]===</span><span class="s2">&quot;&lt;&quot;</span><span class="s0">)</span><span class="s1">return</span><span class="s0">{verbatim:t.slice(</span><span class="s3">2</span><span class="s0">,-</span><span class="s3">1</span><span class="s0">)};{let[s,a,m]=t.match(/^(.*!)([^!]*)$/);</span><span class="s1">return</span><span class="s0">{handle:a,suffix:m}}}}</span><span class="s1">return null</span><span class="s0">}get valueRangeContainsNewline(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.valueRange||!</span><span class="s1">this</span><span class="s0">.context)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let{start:i,end:t}=</span><span class="s1">this</span><span class="s0">.valueRange,{src:s}=</span><span class="s1">this</span><span class="s0">.context;</span><span class="s1">for</span><span class="s0">(let a=i;a&lt;t;++a)</span><span class="s1">if</span><span class="s0">(s[a]===`</span>
<span class="s0">`)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}parseComment(i){let{src:t}=</span><span class="s1">this</span><span class="s0">.context;</span><span class="s1">if</span><span class="s0">(t[i]===e.COMMENT){let s=T.endOfLine(t,i+</span><span class="s3">1</span><span class="s0">),a=</span><span class="s1">new </span><span class="s0">M(i,s);</span><span class="s1">return this</span><span class="s0">.props.push(a),s}</span><span class="s1">return </span><span class="s0">i}setOrigRanges(i,t){</span><span class="s1">return this</span><span class="s0">.range&amp;&amp;(t=</span><span class="s1">this</span><span class="s0">.range.setOrigRange(i,t)),</span><span class="s1">this</span><span class="s0">.valueRange&amp;&amp;</span><span class="s1">this</span><span class="s0">.valueRange.setOrigRange(i,t),</span><span class="s1">this</span><span class="s0">.props.forEach(s=&gt;s.setOrigRange(i,t)),t}toString(){let{context:{src:i},range:t,value:s}=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(s!=</span><span class="s1">null</span><span class="s0">)</span><span class="s1">return </span><span class="s0">s;let a=i.slice(t.start,t.end);</span><span class="s1">return </span><span class="s0">T.addStringTerminator(i,t.end,a)}},P=class extends Error{constructor(i,t,s){</span><span class="s1">if</span><span class="s0">(!s||!(t </span><span class="s1">instanceof </span><span class="s0">T))</span><span class="s1">throw new </span><span class="s0">Error(`Invalid arguments </span><span class="s1">for new </span><span class="s0">${i}`);super(),</span><span class="s1">this</span><span class="s0">.name=i,</span><span class="s1">this</span><span class="s0">.message=s,</span><span class="s1">this</span><span class="s0">.source=t}makePretty(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.source)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.nodeType=</span><span class="s1">this</span><span class="s0">.source.type;let i=</span><span class="s1">this</span><span class="s0">.source.context&amp;&amp;</span><span class="s1">this</span><span class="s0">.source.context.root;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof this</span><span class="s0">.offset==</span><span class="s2">&quot;number&quot;</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.range=</span><span class="s1">new </span><span class="s0">M(</span><span class="s1">this</span><span class="s0">.offset,</span><span class="s1">this</span><span class="s0">.offset+</span><span class="s3">1</span><span class="s0">);let t=i&amp;&amp;E(</span><span class="s1">this</span><span class="s0">.offset,i);</span><span class="s1">if</span><span class="s0">(t){let s={line:t.line,col:t.col+</span><span class="s3">1</span><span class="s0">};</span><span class="s1">this</span><span class="s0">.linePos={start:t,end:s}}</span><span class="s1">delete this</span><span class="s0">.offset}</span><span class="s1">else this</span><span class="s0">.range=</span><span class="s1">this</span><span class="s0">.source.range,</span><span class="s1">this</span><span class="s0">.linePos=</span><span class="s1">this</span><span class="s0">.source.rangeAsLinePos;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.linePos){let{line:t,col:s}=</span><span class="s1">this</span><span class="s0">.linePos.start;</span><span class="s1">this</span><span class="s0">.message+=` at line ${t}, column ${s}`;let a=i&amp;&amp;S(</span><span class="s1">this</span><span class="s0">.linePos,i);a&amp;&amp;(</span><span class="s1">this</span><span class="s0">.message+=`:</span>

<span class="s0">${a}</span>
<span class="s0">`)}</span><span class="s1">delete this</span><span class="s0">.source}},C=class extends P{constructor(i,t){super(</span><span class="s2">&quot;YAMLReferenceError&quot;</span><span class="s0">,i,t)}},q=class extends P{constructor(i,t){super(</span><span class="s2">&quot;YAMLSemanticError&quot;</span><span class="s0">,i,t)}},R=class extends P{constructor(i,t){super(</span><span class="s2">&quot;YAMLSyntaxError&quot;</span><span class="s0">,i,t)}},B=class extends P{constructor(i,t){super(</span><span class="s2">&quot;YAMLWarning&quot;</span><span class="s0">,i,t)}};</span><span class="s1">function </span><span class="s0">U(i,t,s){</span><span class="s1">return </span><span class="s0">t </span><span class="s1">in </span><span class="s0">i?Object.defineProperty(i,t,{value:s,enumerable:!</span><span class="s3">0</span><span class="s0">,configurable:!</span><span class="s3">0</span><span class="s0">,writable:!</span><span class="s3">0</span><span class="s0">}):i[t]=s,i}</span><span class="s1">var </span><span class="s0">f=class extends T{static endOfLine(i,t,s){let a=i[t],m=t;</span><span class="s1">for</span><span class="s0">(;a&amp;&amp;a!==`</span>
<span class="s0">`&amp;&amp;!(s&amp;&amp;(a===</span><span class="s2">&quot;[&quot;</span><span class="s0">||a===</span><span class="s2">&quot;]&quot;</span><span class="s0">||a===</span><span class="s2">&quot;{&quot;</span><span class="s0">||a===</span><span class="s2">&quot;}&quot;</span><span class="s0">||a===</span><span class="s2">&quot;,&quot;</span><span class="s0">));){let g=i[m+</span><span class="s3">1</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(a===</span><span class="s2">&quot;:&quot;</span><span class="s0">&amp;&amp;(!g||g===`</span>
<span class="s0">`||g===</span><span class="s2">&quot;    &quot;</span><span class="s0">||g===</span><span class="s2">&quot; &quot;</span><span class="s0">||s&amp;&amp;g===</span><span class="s2">&quot;,&quot;</span><span class="s0">)||(a===</span><span class="s2">&quot; &quot;</span><span class="s0">||a===</span><span class="s2">&quot;    &quot;</span><span class="s0">)&amp;&amp;g===</span><span class="s2">&quot;#&quot;</span><span class="s0">)</span><span class="s1">break</span><span class="s0">;m+=</span><span class="s3">1</span><span class="s0">,a=g}</span><span class="s1">return </span><span class="s0">m}get strValue(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.valueRange||!</span><span class="s1">this</span><span class="s0">.context)</span><span class="s1">return null</span><span class="s0">;let{start:i,end:t}=</span><span class="s1">this</span><span class="s0">.valueRange,{src:s}=</span><span class="s1">this</span><span class="s0">.context,a=s[t-1];</span><span class="s1">for</span><span class="s0">(;i&lt;t&amp;&amp;(a===`</span>
<span class="s0">`||a===</span><span class="s2">&quot;    &quot;</span><span class="s0">||a===</span><span class="s2">&quot; &quot;</span><span class="s0">);)a=s[--t-1];let m=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let u=i;u&lt;t;++u){let p=s[u];</span><span class="s1">if</span><span class="s0">(p===`</span>
<span class="s0">`){let{fold:L,offset:k}=T.foldNewline(s,u,-</span><span class="s3">1</span><span class="s0">);m+=L,u=k}</span><span class="s1">else if</span><span class="s0">(p===</span><span class="s2">&quot; &quot;</span><span class="s0">||p===</span><span class="s2">&quot;    &quot;</span><span class="s0">){let L=u,k=s[u+</span><span class="s3">1</span><span class="s0">];</span><span class="s1">for</span><span class="s0">(;u&lt;t&amp;&amp;(k===</span><span class="s2">&quot; &quot;</span><span class="s0">||k===</span><span class="s2">&quot;    &quot;</span><span class="s0">);)u+=</span><span class="s3">1</span><span class="s0">,k=s[u+</span><span class="s3">1</span><span class="s0">];k!==`</span>
<span class="s0">`&amp;&amp;(m+=u&gt;L?s.slice(L,u+</span><span class="s3">1</span><span class="s0">):p)}</span><span class="s1">else </span><span class="s0">m+=p}let g=s[i];</span><span class="s1">switch</span><span class="s0">(g){</span><span class="s1">case</span><span class="s2">&quot; &quot;</span><span class="s0">:{let u=</span><span class="s2">&quot;Plain value cannot start with a tab character&quot;</span><span class="s0">;</span><span class="s1">return</span><span class="s0">{errors:[</span><span class="s1">new </span><span class="s0">q(</span><span class="s1">this</span><span class="s0">,u)],str:m}}</span><span class="s1">case</span><span class="s2">&quot;@&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;`&quot;</span><span class="s0">:{let u=`Plain value cannot start </span><span class="s1">with </span><span class="s0">reserved character ${g}`;</span><span class="s1">return</span><span class="s0">{errors:[</span><span class="s1">new </span><span class="s0">q(</span><span class="s1">this</span><span class="s0">,u)],str:m}}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return </span><span class="s0">m}}parseBlockValue(i){let{indent:t,inFlow:s,src:a}=</span><span class="s1">this</span><span class="s0">.context,m=i,g=i;</span><span class="s1">for</span><span class="s0">(let u=a[m];u===`</span>
<span class="s0">`&amp;&amp;!T.atDocumentBoundary(a,m+</span><span class="s3">1</span><span class="s0">);u=a[m]){let p=T.endOfBlockIndent(a,t,m+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(p===</span><span class="s1">null</span><span class="s0">||a[p]===</span><span class="s2">&quot;#&quot;</span><span class="s0">)</span><span class="s1">break</span><span class="s0">;a[p]===`</span>
<span class="s0">`?m=p:(g=f.endOfLine(a,p,s),m=g)}</span><span class="s1">return this</span><span class="s0">.valueRange.isEmpty()&amp;&amp;(</span><span class="s1">this</span><span class="s0">.valueRange.start=i),</span><span class="s1">this</span><span class="s0">.valueRange.end=g,g}parse(i,t){</span><span class="s1">this</span><span class="s0">.context=i;let{inFlow:s,src:a}=i,m=t,g=a[m];</span><span class="s1">return </span><span class="s0">g&amp;&amp;g!==</span><span class="s2">&quot;#&quot;</span><span class="s0">&amp;&amp;g!==`</span>
<span class="s0">`&amp;&amp;(m=f.endOfLine(a,t,s)),</span><span class="s1">this</span><span class="s0">.valueRange=</span><span class="s1">new </span><span class="s0">M(t,m),m=T.endOfWhiteSpace(a,m),m=</span><span class="s1">this</span><span class="s0">.parseComment(m),(!</span><span class="s1">this</span><span class="s0">.hasComment||</span><span class="s1">this</span><span class="s0">.valueRange.isEmpty())&amp;&amp;(m=</span><span class="s1">this</span><span class="s0">.parseBlockValue(m)),m}};n.Char=e,n.Node=T,n.PlainValue=f,n.Range=M,n.Type=r,n.YAMLError=P,n.YAMLReferenceError=C,n.YAMLSemanticError=q,n.YAMLSyntaxError=R,n.YAMLWarning=B,n._defineProperty=U,n.defaultTagPrefix=c,n.defaultTags=h}}),Jr=D({</span><span class="s2">&quot;node_modules/yaml/dist/parse-cst.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y();</span><span class="s1">var </span><span class="s0">e=Me(),r=class extends e.Node{constructor(){super(e.Type.BLANK_LINE)}get includesTrailingLines(){</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}parse(f,i){</span><span class="s1">return this</span><span class="s0">.context=f,</span><span class="s1">this</span><span class="s0">.range=</span><span class="s1">new </span><span class="s0">e.Range(i,i+</span><span class="s3">1</span><span class="s0">),i+</span><span class="s3">1</span><span class="s0">}},c=class extends e.Node{constructor(f,i){super(f,i),</span><span class="s1">this</span><span class="s0">.node=</span><span class="s1">null</span><span class="s0">}get includesTrailingLines(){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.node&amp;&amp;</span><span class="s1">this</span><span class="s0">.node.includesTrailingLines}parse(f,i){</span><span class="s1">this</span><span class="s0">.context=f;let{parseNode:t,src:s}=f,{atLineStart:a,lineStart:m}=f;!a&amp;&amp;</span><span class="s1">this</span><span class="s0">.type===e.Type.SEQ_ITEM&amp;&amp;(</span><span class="s1">this</span><span class="s0">.error=</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;Sequence items must not have preceding content on the same line&quot;</span><span class="s0">));let g=a?i-m:f.indent,u=e.Node.endOfWhiteSpace(s,i+</span><span class="s3">1</span><span class="s0">),p=s[u],L=p===</span><span class="s2">&quot;#&quot;</span><span class="s0">,k=[],$=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;p===`</span>
<span class="s0">`||p===</span><span class="s2">&quot;#&quot;</span><span class="s0">;){</span><span class="s1">if</span><span class="s0">(p===</span><span class="s2">&quot;#&quot;</span><span class="s0">){let V=e.Node.endOfLine(s,u+</span><span class="s3">1</span><span class="s0">);k.push(</span><span class="s1">new </span><span class="s0">e.Range(u,V)),u=V}</span><span class="s1">else</span><span class="s0">{a=!</span><span class="s3">0</span><span class="s0">,m=u+</span><span class="s3">1</span><span class="s0">;let V=e.Node.endOfWhiteSpace(s,m);s[V]===`</span>
<span class="s0">`&amp;&amp;k.length===</span><span class="s3">0</span><span class="s0">&amp;&amp;($=</span><span class="s1">new </span><span class="s0">r,m=$.parse({src:s},m)),u=e.Node.endOfIndent(s,m)}p=s[u]}</span><span class="s1">if</span><span class="s0">(e.Node.nextNodeIsIndented(p,u-(m+g),</span><span class="s1">this</span><span class="s0">.type!==e.Type.SEQ_ITEM)?</span><span class="s1">this</span><span class="s0">.node=t({atLineStart:a,inCollection:!</span><span class="s3">1</span><span class="s0">,indent:g,lineStart:m,parent:</span><span class="s1">this</span><span class="s0">},u):p&amp;&amp;m&gt;i+</span><span class="s3">1</span><span class="s0">&amp;&amp;(u=m-1),</span><span class="s1">this</span><span class="s0">.node){</span><span class="s1">if</span><span class="s0">($){let V=f.parent.items||f.parent.contents;V&amp;&amp;V.push($)}k.length&amp;&amp;Array.prototype.push.apply(</span><span class="s1">this</span><span class="s0">.props,k),u=</span><span class="s1">this</span><span class="s0">.node.range.end}</span><span class="s1">else if</span><span class="s0">(L){let V=k[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">this</span><span class="s0">.props.push(V),u=V.end}</span><span class="s1">else </span><span class="s0">u=e.Node.endOfLine(s,i+</span><span class="s3">1</span><span class="s0">);let K=</span><span class="s1">this</span><span class="s0">.node?</span><span class="s1">this</span><span class="s0">.node.valueRange.end:u;</span><span class="s1">return this</span><span class="s0">.valueRange=</span><span class="s1">new </span><span class="s0">e.Range(i,K),u}setOrigRanges(f,i){</span><span class="s1">return </span><span class="s0">i=super.setOrigRanges(f,i),</span><span class="s1">this</span><span class="s0">.node?</span><span class="s1">this</span><span class="s0">.node.setOrigRanges(f,i):i}toString(){let{context:{src:f},node:i,range:t,value:s}=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(s!=</span><span class="s1">null</span><span class="s0">)</span><span class="s1">return </span><span class="s0">s;let a=i?f.slice(t.start,i.range.start)+String(i):f.slice(t.start,t.end);</span><span class="s1">return </span><span class="s0">e.Node.addStringTerminator(f,t.end,a)}},h=class extends e.Node{constructor(){super(e.Type.COMMENT)}parse(f,i){</span><span class="s1">this</span><span class="s0">.context=f;let t=</span><span class="s1">this</span><span class="s0">.parseComment(i);</span><span class="s1">return this</span><span class="s0">.range=</span><span class="s1">new </span><span class="s0">e.Range(i,t),t}};</span><span class="s1">function </span><span class="s0">d(f){let i=f;</span><span class="s1">for</span><span class="s0">(;i </span><span class="s1">instanceof </span><span class="s0">c;)i=i.node;</span><span class="s1">if</span><span class="s0">(!(i </span><span class="s1">instanceof </span><span class="s0">y))</span><span class="s1">return null</span><span class="s0">;let t=i.items.length,s=-</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let g=t-1;g&gt;=</span><span class="s3">0</span><span class="s0">;--g){let u=i.items[g];</span><span class="s1">if</span><span class="s0">(u.type===e.Type.COMMENT){let{indent:p,lineStart:L}=u.context;</span><span class="s1">if</span><span class="s0">(p&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;u.range.start&gt;=L+p)</span><span class="s1">break</span><span class="s0">;s=g}</span><span class="s1">else if</span><span class="s0">(u.type===e.Type.BLANK_LINE)s=g;</span><span class="s1">else break</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(s===-</span><span class="s3">1</span><span class="s0">)</span><span class="s1">return null</span><span class="s0">;let a=i.items.splice(s,t-s),m=a[</span><span class="s3">0</span><span class="s0">].range.start;</span><span class="s1">for</span><span class="s0">(;i.range.end=m,i.valueRange&amp;&amp;i.valueRange.end&gt;m&amp;&amp;(i.valueRange.end=m),i!==f;)i=i.context.parent;</span><span class="s1">return </span><span class="s0">a}</span><span class="s1">var </span><span class="s0">y=class extends e.Node{static nextContentHasIndent(f,i,t){let s=e.Node.endOfLine(f,i)+</span><span class="s3">1</span><span class="s0">;i=e.Node.endOfWhiteSpace(f,s);let a=f[i];</span><span class="s1">return </span><span class="s0">a?i&gt;=s+t?!</span><span class="s3">0</span><span class="s0">:a!==</span><span class="s2">&quot;#&quot;</span><span class="s0">&amp;&amp;a!==`</span>
<span class="s0">`?!</span><span class="s3">1</span><span class="s0">:y.nextContentHasIndent(f,i,t):!</span><span class="s3">1</span><span class="s0">}constructor(f){super(f.type===e.Type.SEQ_ITEM?e.Type.SEQ:e.Type.MAP);</span><span class="s1">for</span><span class="s0">(let t=f.props.length-1;t&gt;=</span><span class="s3">0</span><span class="s0">;--t)</span><span class="s1">if</span><span class="s0">(f.props[t].start&lt;f.context.lineStart){</span><span class="s1">this</span><span class="s0">.props=f.props.slice(</span><span class="s3">0</span><span class="s0">,t+</span><span class="s3">1</span><span class="s0">),f.props=f.props.slice(t+</span><span class="s3">1</span><span class="s0">);let s=f.props[</span><span class="s3">0</span><span class="s0">]||f.valueRange;f.range.start=s.start;</span><span class="s1">break</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.items=[f];let i=d(f);i&amp;&amp;Array.prototype.push.apply(</span><span class="s1">this</span><span class="s0">.items,i)}get includesTrailingLines(){</span><span class="s1">return this</span><span class="s0">.items.length&gt;</span><span class="s3">0</span><span class="s0">}parse(f,i){</span><span class="s1">this</span><span class="s0">.context=f;let{parseNode:t,src:s}=f,a=e.Node.startOfLine(s,i),m=</span><span class="s1">this</span><span class="s0">.items[</span><span class="s3">0</span><span class="s0">];m.context.parent=</span><span class="s1">this</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.valueRange=e.Range.copy(m.valueRange);let g=m.range.start-m.context.lineStart,u=i;u=e.Node.normalizeOffset(s,u);let p=s[u],L=e.Node.endOfWhiteSpace(s,a)===u,k=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;p;){</span><span class="s1">for</span><span class="s0">(;p===`</span>
<span class="s0">`||p===</span><span class="s2">&quot;#&quot;</span><span class="s0">;){</span><span class="s1">if</span><span class="s0">(L&amp;&amp;p===`</span>
<span class="s0">`&amp;&amp;!k){let V=</span><span class="s1">new </span><span class="s0">r;</span><span class="s1">if</span><span class="s0">(u=V.parse({src:s},u),</span><span class="s1">this</span><span class="s0">.valueRange.end=u,u&gt;=s.length){p=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">break</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.items.push(V),u-=</span><span class="s3">1</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(p===</span><span class="s2">&quot;#&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(u&lt;a+g&amp;&amp;!y.nextContentHasIndent(s,u,g))</span><span class="s1">return </span><span class="s0">u;let V=</span><span class="s1">new </span><span class="s0">h;</span><span class="s1">if</span><span class="s0">(u=V.parse({indent:g,lineStart:a,src:s},u),</span><span class="s1">this</span><span class="s0">.items.push(V),</span><span class="s1">this</span><span class="s0">.valueRange.end=u,u&gt;=s.length){p=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">break</span><span class="s0">}}</span><span class="s1">if</span><span class="s0">(a=u+</span><span class="s3">1</span><span class="s0">,u=e.Node.endOfIndent(s,a),e.Node.atBlank(s,u)){let V=e.Node.endOfWhiteSpace(s,u),z=s[V];(!z||z===`</span>
<span class="s0">`||z===</span><span class="s2">&quot;#&quot;</span><span class="s0">)&amp;&amp;(u=V)}p=s[u],L=!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(!p)</span><span class="s1">break</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(u!==a+g&amp;&amp;(L||p!==</span><span class="s2">&quot;:&quot;</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(u&lt;a+g){a&gt;i&amp;&amp;(u=a);</span><span class="s1">break</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.error){let V=</span><span class="s2">&quot;All collection items must start at the same column&quot;</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.error=</span><span class="s1">new </span><span class="s0">e.YAMLSyntaxError(</span><span class="s1">this</span><span class="s0">,V)}}</span><span class="s1">if</span><span class="s0">(m.type===e.Type.SEQ_ITEM){</span><span class="s1">if</span><span class="s0">(p!==</span><span class="s2">&quot;-&quot;</span><span class="s0">){a&gt;i&amp;&amp;(u=a);</span><span class="s1">break</span><span class="s0">}}</span><span class="s1">else if</span><span class="s0">(p===</span><span class="s2">&quot;-&quot;</span><span class="s0">&amp;&amp;!</span><span class="s1">this</span><span class="s0">.error){let V=s[u+</span><span class="s3">1</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(!V||V===`</span>
<span class="s0">`||V===</span><span class="s2">&quot;    &quot;</span><span class="s0">||V===</span><span class="s2">&quot; &quot;</span><span class="s0">){let z=</span><span class="s2">&quot;A collection cannot be both a mapping and a sequence&quot;</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.error=</span><span class="s1">new </span><span class="s0">e.YAMLSyntaxError(</span><span class="s1">this</span><span class="s0">,z)}}let $=t({atLineStart:L,inCollection:!</span><span class="s3">0</span><span class="s0">,indent:g,lineStart:a,parent:</span><span class="s1">this</span><span class="s0">},u);</span><span class="s1">if</span><span class="s0">(!$)</span><span class="s1">return </span><span class="s0">u;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.items.push($),</span><span class="s1">this</span><span class="s0">.valueRange.end=$.valueRange.end,u=e.Node.normalizeOffset(s,$.range.end),p=s[u],L=!</span><span class="s3">1</span><span class="s0">,k=$.includesTrailingLines,p){let V=u-1,z=s[V];</span><span class="s1">for</span><span class="s0">(;z===</span><span class="s2">&quot; &quot;</span><span class="s0">||z===</span><span class="s2">&quot;   &quot;</span><span class="s0">;)z=s[--V];z===`</span>
<span class="s0">`&amp;&amp;(a=V+</span><span class="s3">1</span><span class="s0">,L=!</span><span class="s3">0</span><span class="s0">)}let K=d($);K&amp;&amp;Array.prototype.push.apply(</span><span class="s1">this</span><span class="s0">.items,K)}</span><span class="s1">return </span><span class="s0">u}setOrigRanges(f,i){</span><span class="s1">return </span><span class="s0">i=super.setOrigRanges(f,i),</span><span class="s1">this</span><span class="s0">.items.forEach(t=&gt;{i=t.setOrigRanges(f,i)}),i}toString(){let{context:{src:f},items:i,range:t,value:s}=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(s!=</span><span class="s1">null</span><span class="s0">)</span><span class="s1">return </span><span class="s0">s;let a=f.slice(t.start,i[</span><span class="s3">0</span><span class="s0">].range.start)+String(i[</span><span class="s3">0</span><span class="s0">]);</span><span class="s1">for</span><span class="s0">(let m=</span><span class="s3">1</span><span class="s0">;m&lt;i.length;++m){let g=i[m],{atLineStart:u,indent:p}=g.context;</span><span class="s1">if</span><span class="s0">(u)</span><span class="s1">for</span><span class="s0">(let L=</span><span class="s3">0</span><span class="s0">;L&lt;p;++L)a+=</span><span class="s2">&quot; &quot;</span><span class="s0">;a+=String(g)}</span><span class="s1">return </span><span class="s0">e.Node.addStringTerminator(f,t.end,a)}},E=class extends e.Node{constructor(){super(e.Type.DIRECTIVE),</span><span class="s1">this</span><span class="s0">.name=</span><span class="s1">null</span><span class="s0">}get parameters(){let f=</span><span class="s1">this</span><span class="s0">.rawValue;</span><span class="s1">return </span><span class="s0">f?f.trim().split(/[ \t]+/):[]}parseName(f){let{src:i}=</span><span class="s1">this</span><span class="s0">.context,t=f,s=i[t];</span><span class="s1">for</span><span class="s0">(;s&amp;&amp;s!==`</span>
<span class="s0">`&amp;&amp;s!==</span><span class="s2">&quot;    &quot;</span><span class="s0">&amp;&amp;s!==</span><span class="s2">&quot; &quot;</span><span class="s0">;)s=i[t+=</span><span class="s3">1</span><span class="s0">];</span><span class="s1">return this</span><span class="s0">.name=i.slice(f,t),t}parseParameters(f){let{src:i}=</span><span class="s1">this</span><span class="s0">.context,t=f,s=i[t];</span><span class="s1">for</span><span class="s0">(;s&amp;&amp;s!==`</span>
<span class="s0">`&amp;&amp;s!==</span><span class="s2">&quot;#&quot;</span><span class="s0">;)s=i[t+=</span><span class="s3">1</span><span class="s0">];</span><span class="s1">return this</span><span class="s0">.valueRange=</span><span class="s1">new </span><span class="s0">e.Range(f,t),t}parse(f,i){</span><span class="s1">this</span><span class="s0">.context=f;let t=</span><span class="s1">this</span><span class="s0">.parseName(i+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.parseParameters(t),t=</span><span class="s1">this</span><span class="s0">.parseComment(t),</span><span class="s1">this</span><span class="s0">.range=</span><span class="s1">new </span><span class="s0">e.Range(i,t),t}},I=class extends e.Node{static startCommentOrEndBlankLine(f,i){let t=e.Node.endOfWhiteSpace(f,i),s=f[t];</span><span class="s1">return </span><span class="s0">s===</span><span class="s2">&quot;#&quot;</span><span class="s0">||s===`</span>
<span class="s0">`?t:i}constructor(){super(e.Type.DOCUMENT),</span><span class="s1">this</span><span class="s0">.directives=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.contents=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.directivesEndMarker=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.documentEndMarker=</span><span class="s1">null</span><span class="s0">}parseDirectives(f){let{src:i}=</span><span class="s1">this</span><span class="s0">.context;</span><span class="s1">this</span><span class="s0">.directives=[];let t=!</span><span class="s3">0</span><span class="s0">,s=!</span><span class="s3">1</span><span class="s0">,a=f;</span><span class="s1">for</span><span class="s0">(;!e.Node.atDocumentBoundary(i,a,e.Char.DIRECTIVES_END);)</span><span class="s1">switch</span><span class="s0">(a=I.startCommentOrEndBlankLine(i,a),i[a]){</span><span class="s1">case</span><span class="s0">`</span>
<span class="s0">`:</span><span class="s1">if</span><span class="s0">(t){let m=</span><span class="s1">new </span><span class="s0">r;a=m.parse({src:i},a),a&lt;i.length&amp;&amp;</span><span class="s1">this</span><span class="s0">.directives.push(m)}</span><span class="s1">else </span><span class="s0">a+=</span><span class="s3">1</span><span class="s0">,t=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;#&quot;</span><span class="s0">:{let m=</span><span class="s1">new </span><span class="s0">h;a=m.parse({src:i},a),</span><span class="s1">this</span><span class="s0">.directives.push(m),t=!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;%&quot;</span><span class="s0">:{let m=</span><span class="s1">new </span><span class="s0">E;a=m.parse({parent:</span><span class="s1">this</span><span class="s0">,src:i},a),</span><span class="s1">this</span><span class="s0">.directives.push(m),s=!</span><span class="s3">0</span><span class="s0">,t=!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return </span><span class="s0">s?</span><span class="s1">this</span><span class="s0">.error=</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;Missing directives-end indicator line&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.directives.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.contents=</span><span class="s1">this</span><span class="s0">.directives,</span><span class="s1">this</span><span class="s0">.directives=[]),a}</span><span class="s1">return </span><span class="s0">i[a]?(</span><span class="s1">this</span><span class="s0">.directivesEndMarker=</span><span class="s1">new </span><span class="s0">e.Range(a,a+</span><span class="s3">3</span><span class="s0">),a+</span><span class="s3">3</span><span class="s0">):(s?</span><span class="s1">this</span><span class="s0">.error=</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;Missing directives-end indicator line&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.directives.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.contents=</span><span class="s1">this</span><span class="s0">.directives,</span><span class="s1">this</span><span class="s0">.directives=[]),a)}parseContents(f){let{parseNode:i,src:t}=</span><span class="s1">this</span><span class="s0">.context;</span><span class="s1">this</span><span class="s0">.contents||(</span><span class="s1">this</span><span class="s0">.contents=[]);let s=f;</span><span class="s1">for</span><span class="s0">(;t[s-1]===</span><span class="s2">&quot;-&quot;</span><span class="s0">;)s-=</span><span class="s3">1</span><span class="s0">;let a=e.Node.endOfWhiteSpace(t,f),m=s===f;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.valueRange=</span><span class="s1">new </span><span class="s0">e.Range(a);!e.Node.atDocumentBoundary(t,a,e.Char.DOCUMENT_END);){</span><span class="s1">switch</span><span class="s0">(t[a]){</span><span class="s1">case</span><span class="s0">`</span>
<span class="s0">`:</span><span class="s1">if</span><span class="s0">(m){let g=</span><span class="s1">new </span><span class="s0">r;a=g.parse({src:t},a),a&lt;t.length&amp;&amp;</span><span class="s1">this</span><span class="s0">.contents.push(g)}</span><span class="s1">else </span><span class="s0">a+=</span><span class="s3">1</span><span class="s0">,m=!</span><span class="s3">0</span><span class="s0">;s=a;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;#&quot;</span><span class="s0">:{let g=</span><span class="s1">new </span><span class="s0">h;a=g.parse({src:t},a),</span><span class="s1">this</span><span class="s0">.contents.push(g),m=!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:{let g=e.Node.endOfIndent(t,a),p=i({atLineStart:m,indent:-</span><span class="s3">1</span><span class="s0">,inFlow:!</span><span class="s3">1</span><span class="s0">,inCollection:!</span><span class="s3">1</span><span class="s0">,lineStart:s,parent:</span><span class="s1">this</span><span class="s0">},g);</span><span class="s1">if</span><span class="s0">(!p)</span><span class="s1">return this</span><span class="s0">.valueRange.end=g;</span><span class="s1">this</span><span class="s0">.contents.push(p),a=p.range.end,m=!</span><span class="s3">1</span><span class="s0">;let L=d(p);L&amp;&amp;Array.prototype.push.apply(</span><span class="s1">this</span><span class="s0">.contents,L)}}a=I.startCommentOrEndBlankLine(t,a)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.valueRange.end=a,t[a]&amp;&amp;(</span><span class="s1">this</span><span class="s0">.documentEndMarker=</span><span class="s1">new </span><span class="s0">e.Range(a,a+</span><span class="s3">3</span><span class="s0">),a+=</span><span class="s3">3</span><span class="s0">,t[a])){</span><span class="s1">if</span><span class="s0">(a=e.Node.endOfWhiteSpace(t,a),t[a]===</span><span class="s2">&quot;#&quot;</span><span class="s0">){let g=</span><span class="s1">new </span><span class="s0">h;a=g.parse({src:t},a),</span><span class="s1">this</span><span class="s0">.contents.push(g)}</span><span class="s1">switch</span><span class="s0">(t[a]){</span><span class="s1">case</span><span class="s0">`</span>
<span class="s0">`:a+=</span><span class="s3">1</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case void </span><span class="s3">0</span><span class="s0">:</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.error=</span><span class="s1">new </span><span class="s0">e.YAMLSyntaxError(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;Document end marker line cannot have a non-comment suffix&quot;</span><span class="s0">)}}</span><span class="s1">return </span><span class="s0">a}parse(f,i){f.root=</span><span class="s1">this</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.context=f;let{src:t}=f,s=t.charCodeAt(i)===</span><span class="s3">65279</span><span class="s0">?i+</span><span class="s3">1</span><span class="s0">:i;</span><span class="s1">return </span><span class="s0">s=</span><span class="s1">this</span><span class="s0">.parseDirectives(s),s=</span><span class="s1">this</span><span class="s0">.parseContents(s),s}setOrigRanges(f,i){</span><span class="s1">return </span><span class="s0">i=super.setOrigRanges(f,i),</span><span class="s1">this</span><span class="s0">.directives.forEach(t=&gt;{i=t.setOrigRanges(f,i)}),</span><span class="s1">this</span><span class="s0">.directivesEndMarker&amp;&amp;(i=</span><span class="s1">this</span><span class="s0">.directivesEndMarker.setOrigRange(f,i)),</span><span class="s1">this</span><span class="s0">.contents.forEach(t=&gt;{i=t.setOrigRanges(f,i)}),</span><span class="s1">this</span><span class="s0">.documentEndMarker&amp;&amp;(i=</span><span class="s1">this</span><span class="s0">.documentEndMarker.setOrigRange(f,i)),i}toString(){let{contents:f,directives:i,value:t}=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(t!=</span><span class="s1">null</span><span class="s0">)</span><span class="s1">return </span><span class="s0">t;let s=i.join(</span><span class="s2">&quot;&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">f.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;((i.length&gt;</span><span class="s3">0</span><span class="s0">||f[</span><span class="s3">0</span><span class="s0">].type===e.Type.COMMENT)&amp;&amp;(s+=`---</span>
<span class="s0">`),s+=f.join(</span><span class="s2">&quot;&quot;</span><span class="s0">)),s[s.length-1]!==`</span>
<span class="s0">`&amp;&amp;(s+=`</span>
<span class="s0">`),s}},S=class extends e.Node{parse(f,i){</span><span class="s1">this</span><span class="s0">.context=f;let{src:t}=f,s=e.Node.endOfIdentifier(t,i+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.valueRange=</span><span class="s1">new </span><span class="s0">e.Range(i+</span><span class="s3">1</span><span class="s0">,s),s=e.Node.endOfWhiteSpace(t,s),s=</span><span class="s1">this</span><span class="s0">.parseComment(s),s}},M={CLIP:</span><span class="s2">&quot;CLIP&quot;</span><span class="s0">,KEEP:</span><span class="s2">&quot;KEEP&quot;</span><span class="s0">,STRIP:</span><span class="s2">&quot;STRIP&quot;</span><span class="s0">},T=class extends e.Node{constructor(f,i){super(f,i),</span><span class="s1">this</span><span class="s0">.blockIndent=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.chomping=M.CLIP,</span><span class="s1">this</span><span class="s0">.header=</span><span class="s1">null</span><span class="s0">}get includesTrailingLines(){</span><span class="s1">return this</span><span class="s0">.chomping===M.KEEP}get strValue(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.valueRange||!</span><span class="s1">this</span><span class="s0">.context)</span><span class="s1">return null</span><span class="s0">;let{start:f,end:i}=</span><span class="s1">this</span><span class="s0">.valueRange,{indent:t,src:s}=</span><span class="s1">this</span><span class="s0">.context;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.valueRange.isEmpty())</span><span class="s1">return</span><span class="s2">&quot;&quot;</span><span class="s0">;let a=</span><span class="s1">null</span><span class="s0">,m=s[i-1];</span><span class="s1">for</span><span class="s0">(;m===`</span>
<span class="s0">`||m===</span><span class="s2">&quot;    &quot;</span><span class="s0">||m===</span><span class="s2">&quot; &quot;</span><span class="s0">;){</span><span class="s1">if</span><span class="s0">(i-=</span><span class="s3">1</span><span class="s0">,i&lt;=f){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.chomping===M.KEEP)</span><span class="s1">break</span><span class="s0">;</span><span class="s1">return</span><span class="s2">&quot;&quot;</span><span class="s0">}m===`</span>
<span class="s0">`&amp;&amp;(a=i),m=s[i-1]}let g=i+</span><span class="s3">1</span><span class="s0">;a&amp;&amp;(</span><span class="s1">this</span><span class="s0">.chomping===M.KEEP?(g=a,i=</span><span class="s1">this</span><span class="s0">.valueRange.end):i=a);let u=t+</span><span class="s1">this</span><span class="s0">.blockIndent,p=</span><span class="s1">this</span><span class="s0">.type===e.Type.BLOCK_FOLDED,L=!</span><span class="s3">0</span><span class="s0">,k=</span><span class="s2">&quot;&quot;</span><span class="s0">,$=</span><span class="s2">&quot;&quot;</span><span class="s0">,K=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let V=f;V&lt;i;++V){</span><span class="s1">for</span><span class="s0">(let ae=</span><span class="s3">0</span><span class="s0">;ae&lt;u&amp;&amp;s[V]===</span><span class="s2">&quot; &quot;</span><span class="s0">;++ae)V+=</span><span class="s3">1</span><span class="s0">;let z=s[V];</span><span class="s1">if</span><span class="s0">(z===`</span>
<span class="s0">`)$===`</span>
<span class="s0">`?k+=`</span>
<span class="s0">`:$=`</span>
<span class="s0">`;</span><span class="s1">else</span><span class="s0">{let ae=e.Node.endOfLine(s,V),ue=s.slice(V,ae);V=ae,p&amp;&amp;(z===</span><span class="s2">&quot; &quot;</span><span class="s0">||z===</span><span class="s2">&quot; &quot;</span><span class="s0">)&amp;&amp;V&lt;g?($===</span><span class="s2">&quot; &quot;</span><span class="s0">?$=`</span>
<span class="s0">`:!K&amp;&amp;!L&amp;&amp;$===`</span>
<span class="s0">`&amp;&amp;($=`</span>

<span class="s0">`),k+=$+ue,$=ae&lt;i&amp;&amp;s[ae]||</span><span class="s2">&quot;&quot;</span><span class="s0">,K=!</span><span class="s3">0</span><span class="s0">):(k+=$+ue,$=p&amp;&amp;V&lt;g?</span><span class="s2">&quot; &quot;</span><span class="s0">:`</span>
<span class="s0">`,K=!</span><span class="s3">1</span><span class="s0">),L&amp;&amp;ue!==</span><span class="s2">&quot;&quot;</span><span class="s0">&amp;&amp;(L=!</span><span class="s3">1</span><span class="s0">)}}</span><span class="s1">return this</span><span class="s0">.chomping===M.STRIP?k:k+`</span>
<span class="s0">`}parseBlockHeader(f){let{src:i}=</span><span class="s1">this</span><span class="s0">.context,t=f+</span><span class="s3">1</span><span class="s0">,s=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;;){let a=i[t];</span><span class="s1">switch</span><span class="s0">(a){</span><span class="s1">case</span><span class="s2">&quot;-&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.chomping=M.STRIP;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;+&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.chomping=M.KEEP;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;0&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;1&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;2&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;3&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;4&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;5&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;6&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;7&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;8&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;9&quot;</span><span class="s0">:s+=a;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.blockIndent=Number(s)||</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.header=</span><span class="s1">new </span><span class="s0">e.Range(f,t),t}t+=</span><span class="s3">1</span><span class="s0">}}parseBlockValue(f){let{indent:i,src:t}=</span><span class="s1">this</span><span class="s0">.context,s=!!</span><span class="s1">this</span><span class="s0">.blockIndent,a=f,m=f,g=</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let u=t[a];u===`</span>
<span class="s0">`&amp;&amp;(a+=</span><span class="s3">1</span><span class="s0">,!e.Node.atDocumentBoundary(t,a));u=t[a]){let p=e.Node.endOfBlockIndent(t,i,a);</span><span class="s1">if</span><span class="s0">(p===</span><span class="s1">null</span><span class="s0">)</span><span class="s1">break</span><span class="s0">;let L=t[p],k=p-(a+i);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.blockIndent){</span><span class="s1">if</span><span class="s0">(L&amp;&amp;L!==`</span>
<span class="s0">`&amp;&amp;k&lt;</span><span class="s1">this</span><span class="s0">.blockIndent){</span><span class="s1">if</span><span class="s0">(t[p]===</span><span class="s2">&quot;#&quot;</span><span class="s0">)</span><span class="s1">break</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.error){let K=`Block scalars must not be less indented than their ${s?</span><span class="s2">&quot;explicit indentation indicator&quot;</span><span class="s0">:</span><span class="s2">&quot;first line&quot;</span><span class="s0">}`;</span><span class="s1">this</span><span class="s0">.error=</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(</span><span class="s1">this</span><span class="s0">,K)}}}</span><span class="s1">else if</span><span class="s0">(t[p]!==`</span>
<span class="s0">`){</span><span class="s1">if</span><span class="s0">(k&lt;g){let $=</span><span class="s2">&quot;Block scalars with more-indented leading empty lines must use an explicit indentation indicator&quot;</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.error=</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(</span><span class="s1">this</span><span class="s0">,$)}</span><span class="s1">this</span><span class="s0">.blockIndent=k}</span><span class="s1">else </span><span class="s0">k&gt;g&amp;&amp;(g=k);t[p]===`</span>
<span class="s0">`?a=p:a=m=e.Node.endOfLine(t,p)}</span><span class="s1">return this</span><span class="s0">.chomping!==M.KEEP&amp;&amp;(a=t[m]?m+</span><span class="s3">1</span><span class="s0">:m),</span><span class="s1">this</span><span class="s0">.valueRange=</span><span class="s1">new </span><span class="s0">e.Range(f+</span><span class="s3">1</span><span class="s0">,a),a}parse(f,i){</span><span class="s1">this</span><span class="s0">.context=f;let{src:t}=f,s=</span><span class="s1">this</span><span class="s0">.parseBlockHeader(i);</span><span class="s1">return </span><span class="s0">s=e.Node.endOfWhiteSpace(t,s),s=</span><span class="s1">this</span><span class="s0">.parseComment(s),s=</span><span class="s1">this</span><span class="s0">.parseBlockValue(s),s}setOrigRanges(f,i){</span><span class="s1">return </span><span class="s0">i=super.setOrigRanges(f,i),</span><span class="s1">this</span><span class="s0">.header?</span><span class="s1">this</span><span class="s0">.header.setOrigRange(f,i):i}},P=class extends e.Node{constructor(f,i){super(f,i),</span><span class="s1">this</span><span class="s0">.items=</span><span class="s1">null</span><span class="s0">}prevNodeIsJsonLike(){let f=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">0</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">0</span><span class="s0">]:</span><span class="s1">this</span><span class="s0">.items.length,i=</span><span class="s1">this</span><span class="s0">.items[f-1];</span><span class="s1">return</span><span class="s0">!!i&amp;&amp;(i.jsonLike||i.type===e.Type.COMMENT&amp;&amp;</span><span class="s1">this</span><span class="s0">.prevNodeIsJsonLike(f-1))}parse(f,i){</span><span class="s1">this</span><span class="s0">.context=f;let{parseNode:t,src:s}=f,{indent:a,lineStart:m}=f,g=s[i];</span><span class="s1">this</span><span class="s0">.items=[{char:g,offset:i}];let u=e.Node.endOfWhiteSpace(s,i+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(g=s[u];g&amp;&amp;g!==</span><span class="s2">&quot;]&quot;</span><span class="s0">&amp;&amp;g!==</span><span class="s2">&quot;}&quot;</span><span class="s0">;){</span><span class="s1">switch</span><span class="s0">(g){</span><span class="s1">case</span><span class="s0">`</span>
<span class="s0">`:{m=u+</span><span class="s3">1</span><span class="s0">;let p=e.Node.endOfWhiteSpace(s,m);</span><span class="s1">if</span><span class="s0">(s[p]===`</span>
<span class="s0">`){let L=</span><span class="s1">new </span><span class="s0">r;m=L.parse({src:s},m),</span><span class="s1">this</span><span class="s0">.items.push(L)}</span><span class="s1">if</span><span class="s0">(u=e.Node.endOfIndent(s,m),u&lt;=m+a&amp;&amp;(g=s[u],u&lt;m+a||g!==</span><span class="s2">&quot;]&quot;</span><span class="s0">&amp;&amp;g!==</span><span class="s2">&quot;}&quot;</span><span class="s0">)){let L=</span><span class="s2">&quot;Insufficient indentation in flow collection&quot;</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.error=</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(</span><span class="s1">this</span><span class="s0">,L)}}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;,&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.items.push({char:g,offset:u}),u+=</span><span class="s3">1</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;#&quot;</span><span class="s0">:{let p=</span><span class="s1">new </span><span class="s0">h;u=p.parse({src:s},u),</span><span class="s1">this</span><span class="s0">.items.push(p)}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;?&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;:&quot;</span><span class="s0">:{let p=s[u+</span><span class="s3">1</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(p===`</span>
<span class="s0">`||p===</span><span class="s2">&quot;    &quot;</span><span class="s0">||p===</span><span class="s2">&quot; &quot;</span><span class="s0">||p===</span><span class="s2">&quot;,&quot;</span><span class="s0">||g===</span><span class="s2">&quot;:&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.prevNodeIsJsonLike()){</span><span class="s1">this</span><span class="s0">.items.push({char:g,offset:u}),u+=</span><span class="s3">1</span><span class="s0">;</span><span class="s1">break</span><span class="s0">}}</span><span class="s1">default</span><span class="s0">:{let p=t({atLineStart:!</span><span class="s3">1</span><span class="s0">,inCollection:!</span><span class="s3">1</span><span class="s0">,inFlow:!</span><span class="s3">0</span><span class="s0">,indent:-</span><span class="s3">1</span><span class="s0">,lineStart:m,parent:</span><span class="s1">this</span><span class="s0">},u);</span><span class="s1">if</span><span class="s0">(!p)</span><span class="s1">return this</span><span class="s0">.valueRange=</span><span class="s1">new </span><span class="s0">e.Range(i,u),u;</span><span class="s1">this</span><span class="s0">.items.push(p),u=e.Node.normalizeOffset(s,p.range.end)}}u=e.Node.endOfWhiteSpace(s,u),g=s[u]}</span><span class="s1">return this</span><span class="s0">.valueRange=</span><span class="s1">new </span><span class="s0">e.Range(i,u+</span><span class="s3">1</span><span class="s0">),g&amp;&amp;(</span><span class="s1">this</span><span class="s0">.items.push({char:g,offset:u}),u=e.Node.endOfWhiteSpace(s,u+</span><span class="s3">1</span><span class="s0">),u=</span><span class="s1">this</span><span class="s0">.parseComment(u)),u}setOrigRanges(f,i){</span><span class="s1">return </span><span class="s0">i=super.setOrigRanges(f,i),</span><span class="s1">this</span><span class="s0">.items.forEach(t=&gt;{</span><span class="s1">if</span><span class="s0">(t </span><span class="s1">instanceof </span><span class="s0">e.Node)i=t.setOrigRanges(f,i);</span><span class="s1">else if</span><span class="s0">(f.length===</span><span class="s3">0</span><span class="s0">)t.origOffset=t.offset;</span><span class="s1">else</span><span class="s0">{let s=i;</span><span class="s1">for</span><span class="s0">(;s&lt;f.length&amp;&amp;!(f[s]&gt;t.offset);)++s;t.origOffset=t.offset+s,i=s}}),i}toString(){let{context:{src:f},items:i,range:t,value:s}=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(s!=</span><span class="s1">null</span><span class="s0">)</span><span class="s1">return </span><span class="s0">s;let a=i.filter(u=&gt;u </span><span class="s1">instanceof </span><span class="s0">e.Node),m=</span><span class="s2">&quot;&quot;</span><span class="s0">,g=t.start;</span><span class="s1">return </span><span class="s0">a.forEach(u=&gt;{let p=f.slice(g,u.range.start);g=u.range.end,m+=p+String(u),m[m.length-1]===`</span>
<span class="s0">`&amp;&amp;f[g-1]!==`</span>
<span class="s0">`&amp;&amp;f[g]===`</span>
<span class="s0">`&amp;&amp;(g+=</span><span class="s3">1</span><span class="s0">)}),m+=f.slice(g,t.end),e.Node.addStringTerminator(f,t.end,m)}},C=class extends e.Node{static endOfQuote(f,i){let t=f[i];</span><span class="s1">for</span><span class="s0">(;t&amp;&amp;t!==</span><span class="s2">'&quot;'</span><span class="s0">;)i+=t===</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">&quot;</span><span class="s0">?</span><span class="s3">2</span><span class="s0">:</span><span class="s3">1</span><span class="s0">,t=f[i];</span><span class="s1">return </span><span class="s0">i+</span><span class="s3">1</span><span class="s0">}get strValue(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.valueRange||!</span><span class="s1">this</span><span class="s0">.context)</span><span class="s1">return null</span><span class="s0">;let f=[],{start:i,end:t}=</span><span class="s1">this</span><span class="s0">.valueRange,{indent:s,src:a}=</span><span class="s1">this</span><span class="s0">.context;a[t-1]!==</span><span class="s2">'&quot;'</span><span class="s0">&amp;&amp;f.push(</span><span class="s1">new </span><span class="s0">e.YAMLSyntaxError(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">'Missing closing &quot;quote'</span><span class="s0">));let m=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let g=i+</span><span class="s3">1</span><span class="s0">;g&lt;t-1;++g){let u=a[g];</span><span class="s1">if</span><span class="s0">(u===`</span>
<span class="s0">`){e.Node.atDocumentBoundary(a,g+</span><span class="s3">1</span><span class="s0">)&amp;&amp;f.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;Document boundary indicators are not allowed within string values&quot;</span><span class="s0">));let{fold:p,offset:L,error:k}=e.Node.foldNewline(a,g,s);m+=p,g=L,k&amp;&amp;f.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;Multi-line double-quoted string needs to be sufficiently indented&quot;</span><span class="s0">))}</span><span class="s1">else if</span><span class="s0">(u===</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">&quot;</span><span class="s0">)</span><span class="s1">switch</span><span class="s0">(g+=</span><span class="s3">1</span><span class="s0">,a[g]){</span><span class="s1">case</span><span class="s2">&quot;0&quot;</span><span class="s0">:m+=</span><span class="s2">&quot;</span><span class="s4">\0</span><span class="s2">&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;a&quot;</span><span class="s0">:m+=</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">07&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;b&quot;</span><span class="s0">:m+=</span><span class="s2">&quot;</span><span class="s4">\b</span><span class="s2">&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;e&quot;</span><span class="s0">:m+=</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">1B&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;f&quot;</span><span class="s0">:m+=</span><span class="s2">&quot;</span><span class="s4">\f</span><span class="s2">&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;n&quot;</span><span class="s0">:m+=`</span>
<span class="s0">`;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;r&quot;</span><span class="s0">:m+=</span><span class="s2">&quot;</span><span class="s4">\r</span><span class="s2">&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;t&quot;</span><span class="s0">:m+=</span><span class="s2">&quot;  &quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;v&quot;</span><span class="s0">:m+=</span><span class="s2">&quot;</span><span class="s5">\v</span><span class="s2">&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;N&quot;</span><span class="s0">:m+=</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">85&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;_&quot;</span><span class="s0">:m+=</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">A0&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;L&quot;</span><span class="s0">:m+=</span><span class="s2">&quot;</span><span class="s4">\u2028</span><span class="s2">&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;P&quot;</span><span class="s0">:m+=</span><span class="s2">&quot;</span><span class="s4">\u2029</span><span class="s2">&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot; &quot;</span><span class="s0">:m+=</span><span class="s2">&quot; &quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">'&quot;'</span><span class="s0">:m+=</span><span class="s2">'&quot;'</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;/&quot;</span><span class="s0">:m+=</span><span class="s2">&quot;/&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">&quot;</span><span class="s0">:m+=</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;   &quot;</span><span class="s0">:m+=</span><span class="s2">&quot;  &quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;x&quot;</span><span class="s0">:m+=</span><span class="s1">this</span><span class="s0">.parseCharCode(g+</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,f),g+=</span><span class="s3">2</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;u&quot;</span><span class="s0">:m+=</span><span class="s1">this</span><span class="s0">.parseCharCode(g+</span><span class="s3">1</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,f),g+=</span><span class="s3">4</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;U&quot;</span><span class="s0">:m+=</span><span class="s1">this</span><span class="s0">.parseCharCode(g+</span><span class="s3">1</span><span class="s0">,</span><span class="s3">8</span><span class="s0">,f),g+=</span><span class="s3">8</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s0">`</span>
<span class="s0">`:</span><span class="s1">for</span><span class="s0">(;a[g+</span><span class="s3">1</span><span class="s0">]===</span><span class="s2">&quot; &quot;</span><span class="s0">||a[g+</span><span class="s3">1</span><span class="s0">]===</span><span class="s2">&quot; &quot;</span><span class="s0">;)g+=</span><span class="s3">1</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:f.push(</span><span class="s1">new </span><span class="s0">e.YAMLSyntaxError(</span><span class="s1">this</span><span class="s0">,`Invalid escape sequence ${a.substr(g-1,</span><span class="s3">2</span><span class="s0">)}`)),m+=</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">&quot;</span><span class="s0">+a[g]}</span><span class="s1">else if</span><span class="s0">(u===</span><span class="s2">&quot; &quot;</span><span class="s0">||u===</span><span class="s2">&quot;   &quot;</span><span class="s0">){let p=g,L=a[g+</span><span class="s3">1</span><span class="s0">];</span><span class="s1">for</span><span class="s0">(;L===</span><span class="s2">&quot; &quot;</span><span class="s0">||L===</span><span class="s2">&quot;  &quot;</span><span class="s0">;)g+=</span><span class="s3">1</span><span class="s0">,L=a[g+</span><span class="s3">1</span><span class="s0">];L!==`</span>
<span class="s0">`&amp;&amp;(m+=g&gt;p?a.slice(p,g+</span><span class="s3">1</span><span class="s0">):u)}</span><span class="s1">else </span><span class="s0">m+=u}</span><span class="s1">return </span><span class="s0">f.length&gt;</span><span class="s3">0</span><span class="s0">?{errors:f,str:m}:m}parseCharCode(f,i,t){let{src:s}=</span><span class="s1">this</span><span class="s0">.context,a=s.substr(f,i),g=a.length===i&amp;&amp;/^[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">a-fA-F]+$/.test(a)?parseInt(a,</span><span class="s3">16</span><span class="s0">):NaN;</span><span class="s1">return </span><span class="s0">isNaN(g)?(t.push(</span><span class="s1">new </span><span class="s0">e.YAMLSyntaxError(</span><span class="s1">this</span><span class="s0">,`Invalid escape sequence ${s.substr(f-2,i+</span><span class="s3">2</span><span class="s0">)}`)),s.substr(f-2,i+</span><span class="s3">2</span><span class="s0">)):String.fromCodePoint(g)}parse(f,i){</span><span class="s1">this</span><span class="s0">.context=f;let{src:t}=f,s=C.endOfQuote(t,i+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.valueRange=</span><span class="s1">new </span><span class="s0">e.Range(i,s),s=e.Node.endOfWhiteSpace(t,s),s=</span><span class="s1">this</span><span class="s0">.parseComment(s),s}},q=class extends e.Node{static endOfQuote(f,i){let t=f[i];</span><span class="s1">for</span><span class="s0">(;t;)</span><span class="s1">if</span><span class="s0">(t===</span><span class="s2">&quot;'&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(f[i+</span><span class="s3">1</span><span class="s0">]!==</span><span class="s2">&quot;'&quot;</span><span class="s0">)</span><span class="s1">break</span><span class="s0">;t=f[i+=</span><span class="s3">2</span><span class="s0">]}</span><span class="s1">else </span><span class="s0">t=f[i+=</span><span class="s3">1</span><span class="s0">];</span><span class="s1">return </span><span class="s0">i+</span><span class="s3">1</span><span class="s0">}get strValue(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.valueRange||!</span><span class="s1">this</span><span class="s0">.context)</span><span class="s1">return null</span><span class="s0">;let f=[],{start:i,end:t}=</span><span class="s1">this</span><span class="s0">.valueRange,{indent:s,src:a}=</span><span class="s1">this</span><span class="s0">.context;a[t-1]!==</span><span class="s2">&quot;'&quot;</span><span class="s0">&amp;&amp;f.push(</span><span class="s1">new </span><span class="s0">e.YAMLSyntaxError(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;Missing closing 'quote&quot;</span><span class="s0">));let m=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let g=i+</span><span class="s3">1</span><span class="s0">;g&lt;t-1;++g){let u=a[g];</span><span class="s1">if</span><span class="s0">(u===`</span>
<span class="s0">`){e.Node.atDocumentBoundary(a,g+</span><span class="s3">1</span><span class="s0">)&amp;&amp;f.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;Document boundary indicators are not allowed within string values&quot;</span><span class="s0">));let{fold:p,offset:L,error:k}=e.Node.foldNewline(a,g,s);m+=p,g=L,k&amp;&amp;f.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;Multi-line single-quoted string needs to be sufficiently indented&quot;</span><span class="s0">))}</span><span class="s1">else if</span><span class="s0">(u===</span><span class="s2">&quot;'&quot;</span><span class="s0">)m+=u,g+=</span><span class="s3">1</span><span class="s0">,a[g]!==</span><span class="s2">&quot;'&quot;</span><span class="s0">&amp;&amp;f.push(</span><span class="s1">new </span><span class="s0">e.YAMLSyntaxError(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;Unescaped single quote? This should not happen.&quot;</span><span class="s0">));</span><span class="s1">else if</span><span class="s0">(u===</span><span class="s2">&quot; &quot;</span><span class="s0">||u===</span><span class="s2">&quot;   &quot;</span><span class="s0">){let p=g,L=a[g+</span><span class="s3">1</span><span class="s0">];</span><span class="s1">for</span><span class="s0">(;L===</span><span class="s2">&quot; &quot;</span><span class="s0">||L===</span><span class="s2">&quot;  &quot;</span><span class="s0">;)g+=</span><span class="s3">1</span><span class="s0">,L=a[g+</span><span class="s3">1</span><span class="s0">];L!==`</span>
<span class="s0">`&amp;&amp;(m+=g&gt;p?a.slice(p,g+</span><span class="s3">1</span><span class="s0">):u)}</span><span class="s1">else </span><span class="s0">m+=u}</span><span class="s1">return </span><span class="s0">f.length&gt;</span><span class="s3">0</span><span class="s0">?{errors:f,str:m}:m}parse(f,i){</span><span class="s1">this</span><span class="s0">.context=f;let{src:t}=f,s=q.endOfQuote(t,i+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.valueRange=</span><span class="s1">new </span><span class="s0">e.Range(i,s),s=e.Node.endOfWhiteSpace(t,s),s=</span><span class="s1">this</span><span class="s0">.parseComment(s),s}};</span><span class="s1">function </span><span class="s0">R(f,i){</span><span class="s1">switch</span><span class="s0">(f){</span><span class="s1">case </span><span class="s0">e.Type.ALIAS:</span><span class="s1">return new </span><span class="s0">S(f,i);</span><span class="s1">case </span><span class="s0">e.Type.BLOCK_FOLDED:</span><span class="s1">case </span><span class="s0">e.Type.BLOCK_LITERAL:</span><span class="s1">return new </span><span class="s0">T(f,i);</span><span class="s1">case </span><span class="s0">e.Type.FLOW_MAP:</span><span class="s1">case </span><span class="s0">e.Type.FLOW_SEQ:</span><span class="s1">return new </span><span class="s0">P(f,i);</span><span class="s1">case </span><span class="s0">e.Type.MAP_KEY:</span><span class="s1">case </span><span class="s0">e.Type.MAP_VALUE:</span><span class="s1">case </span><span class="s0">e.Type.SEQ_ITEM:</span><span class="s1">return new </span><span class="s0">c(f,i);</span><span class="s1">case </span><span class="s0">e.Type.COMMENT:</span><span class="s1">case </span><span class="s0">e.Type.PLAIN:</span><span class="s1">return new </span><span class="s0">e.PlainValue(f,i);</span><span class="s1">case </span><span class="s0">e.Type.QUOTE_DOUBLE:</span><span class="s1">return new </span><span class="s0">C(f,i);</span><span class="s1">case </span><span class="s0">e.Type.QUOTE_SINGLE:</span><span class="s1">return new </span><span class="s0">q(f,i);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return null</span><span class="s0">}}</span><span class="s1">var </span><span class="s0">B=class{static parseType(f,i,t){</span><span class="s1">switch</span><span class="s0">(f[i]){</span><span class="s1">case</span><span class="s2">&quot;*&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.Type.ALIAS;</span><span class="s1">case</span><span class="s2">&quot;&gt;&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.Type.BLOCK_FOLDED;</span><span class="s1">case</span><span class="s2">&quot;|&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.Type.BLOCK_LITERAL;</span><span class="s1">case</span><span class="s2">&quot;{&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.Type.FLOW_MAP;</span><span class="s1">case</span><span class="s2">&quot;[&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.Type.FLOW_SEQ;</span><span class="s1">case</span><span class="s2">&quot;?&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!t&amp;&amp;e.Node.atBlank(f,i+</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">)?e.Type.MAP_KEY:e.Type.PLAIN;</span><span class="s1">case</span><span class="s2">&quot;:&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!t&amp;&amp;e.Node.atBlank(f,i+</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">)?e.Type.MAP_VALUE:e.Type.PLAIN;</span><span class="s1">case</span><span class="s2">&quot;-&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!t&amp;&amp;e.Node.atBlank(f,i+</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">)?e.Type.SEQ_ITEM:e.Type.PLAIN;</span><span class="s1">case</span><span class="s2">'&quot;'</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.Type.QUOTE_DOUBLE;</span><span class="s1">case</span><span class="s2">&quot;'&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.Type.QUOTE_SINGLE;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.Type.PLAIN}}constructor(){let f=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">0</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">0</span><span class="s0">]:{},{atLineStart:i,inCollection:t,inFlow:s,indent:a,lineStart:m,parent:g}=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:{};e._defineProperty(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;parseNode&quot;</span><span class="s0">,(u,p)=&gt;{</span><span class="s1">if</span><span class="s0">(e.Node.atDocumentBoundary(</span><span class="s1">this</span><span class="s0">.src,p))</span><span class="s1">return null</span><span class="s0">;let L=</span><span class="s1">new </span><span class="s0">B(</span><span class="s1">this</span><span class="s0">,u),{props:k,type:$,valueStart:K}=L.parseProps(p),V=R($,k),z=V.parse(L,K);</span><span class="s1">if</span><span class="s0">(V.range=</span><span class="s1">new </span><span class="s0">e.Range(p,z),z&lt;=p&amp;&amp;(V.error=</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">&quot;Node#parse consumed no characters&quot;</span><span class="s0">),V.error.parseEnd=z,V.error.source=V,V.range.end=p+</span><span class="s3">1</span><span class="s0">),L.nodeStartsCollection(V)){!V.error&amp;&amp;!L.atLineStart&amp;&amp;L.parent.type===e.Type.DOCUMENT&amp;&amp;(V.error=</span><span class="s1">new </span><span class="s0">e.YAMLSyntaxError(V,</span><span class="s2">&quot;Block collection must not have preceding content here (e.g. directives-end indicator)&quot;</span><span class="s0">));let ae=</span><span class="s1">new </span><span class="s0">y(V);</span><span class="s1">return </span><span class="s0">z=ae.parse(</span><span class="s1">new </span><span class="s0">B(L),z),ae.range=</span><span class="s1">new </span><span class="s0">e.Range(p,z),ae}</span><span class="s1">return </span><span class="s0">V}),</span><span class="s1">this</span><span class="s0">.atLineStart=i!=</span><span class="s1">null</span><span class="s0">?i:f.atLineStart||!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.inCollection=t!=</span><span class="s1">null</span><span class="s0">?t:f.inCollection||!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.inFlow=s!=</span><span class="s1">null</span><span class="s0">?s:f.inFlow||!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.indent=a!=</span><span class="s1">null</span><span class="s0">?a:f.indent,</span><span class="s1">this</span><span class="s0">.lineStart=m!=</span><span class="s1">null</span><span class="s0">?m:f.lineStart,</span><span class="s1">this</span><span class="s0">.parent=g!=</span><span class="s1">null</span><span class="s0">?g:f.parent||{},</span><span class="s1">this</span><span class="s0">.root=f.root,</span><span class="s1">this</span><span class="s0">.src=f.src}nodeStartsCollection(f){let{inCollection:i,inFlow:t,src:s}=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(i||t)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(f </span><span class="s1">instanceof </span><span class="s0">c)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;let a=f.range.end;</span><span class="s1">return </span><span class="s0">s[a]===`</span>
<span class="s0">`||s[a-1]===`</span>
<span class="s0">`?!</span><span class="s3">1</span><span class="s0">:(a=e.Node.endOfWhiteSpace(s,a),s[a]===</span><span class="s2">&quot;:&quot;</span><span class="s0">)}parseProps(f){let{inFlow:i,parent:t,src:s}=</span><span class="s1">this</span><span class="s0">,a=[],m=!</span><span class="s3">1</span><span class="s0">;f=</span><span class="s1">this</span><span class="s0">.atLineStart?e.Node.endOfIndent(s,f):e.Node.endOfWhiteSpace(s,f);let g=s[f];</span><span class="s1">for</span><span class="s0">(;g===e.Char.ANCHOR||g===e.Char.COMMENT||g===e.Char.TAG||g===`</span>
<span class="s0">`;){</span><span class="s1">if</span><span class="s0">(g===`</span>
<span class="s0">`){let p=f,L;</span><span class="s1">do </span><span class="s0">L=p+</span><span class="s3">1</span><span class="s0">,p=e.Node.endOfIndent(s,L);</span><span class="s1">while</span><span class="s0">(s[p]===`</span>
<span class="s0">`);let k=p-(L+</span><span class="s1">this</span><span class="s0">.indent),$=t.type===e.Type.SEQ_ITEM&amp;&amp;t.context.atLineStart;</span><span class="s1">if</span><span class="s0">(s[p]!==</span><span class="s2">&quot;#&quot;</span><span class="s0">&amp;&amp;!e.Node.nextNodeIsIndented(s[p],k,!$))</span><span class="s1">break</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.atLineStart=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lineStart=L,m=!</span><span class="s3">1</span><span class="s0">,f=p}</span><span class="s1">else if</span><span class="s0">(g===e.Char.COMMENT){let p=e.Node.endOfLine(s,f+</span><span class="s3">1</span><span class="s0">);a.push(</span><span class="s1">new </span><span class="s0">e.Range(f,p)),f=p}</span><span class="s1">else</span><span class="s0">{let p=e.Node.endOfIdentifier(s,f+</span><span class="s3">1</span><span class="s0">);g===e.Char.TAG&amp;&amp;s[p]===</span><span class="s2">&quot;,&quot;</span><span class="s0">&amp;&amp;/^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">}\/\S/.test(s.slice(f+</span><span class="s3">1</span><span class="s0">,p+</span><span class="s3">13</span><span class="s0">))&amp;&amp;(p=e.Node.endOfIdentifier(s,p+</span><span class="s3">5</span><span class="s0">)),a.push(</span><span class="s1">new </span><span class="s0">e.Range(f,p)),m=!</span><span class="s3">0</span><span class="s0">,f=e.Node.endOfWhiteSpace(s,p)}g=s[f]}m&amp;&amp;g===</span><span class="s2">&quot;:&quot;</span><span class="s0">&amp;&amp;e.Node.atBlank(s,f+</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">)&amp;&amp;(f-=</span><span class="s3">1</span><span class="s0">);let u=B.parseType(s,f,i);</span><span class="s1">return</span><span class="s0">{props:a,type:u,valueStart:f}}};</span><span class="s1">function </span><span class="s0">U(f){let i=[];f.indexOf(</span><span class="s2">&quot;</span><span class="s4">\r</span><span class="s2">&quot;</span><span class="s0">)!==-</span><span class="s3">1</span><span class="s0">&amp;&amp;(f=f.replace(/\r\n?/g,(a,m)=&gt;(a.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;i.push(m),`</span>
<span class="s0">`)));let t=[],s=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{let a=</span><span class="s1">new </span><span class="s0">I,m=</span><span class="s1">new </span><span class="s0">B({src:f});s=a.parse(m,s),t.push(a)}</span><span class="s1">while</span><span class="s0">(s&lt;f.length);</span><span class="s1">return </span><span class="s0">t.setOrigRanges=()=&gt;{</span><span class="s1">if</span><span class="s0">(i.length===</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let m=</span><span class="s3">1</span><span class="s0">;m&lt;i.length;++m)i[m]-=m;let a=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let m=</span><span class="s3">0</span><span class="s0">;m&lt;t.length;++m)a=t[m].setOrigRanges(i,a);</span><span class="s1">return </span><span class="s0">i.splice(</span><span class="s3">0</span><span class="s0">,i.length),!</span><span class="s3">0</span><span class="s0">},t.toString=()=&gt;t.join(`...</span>
<span class="s0">`),t}n.parse=U}}),ke=D({</span><span class="s2">&quot;node_modules/yaml/dist/resolveSeq-d03cb037.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y();</span><span class="s1">var </span><span class="s0">e=Me();</span><span class="s1">function </span><span class="s0">r(o,l,_){</span><span class="s1">return </span><span class="s0">_?`#${_.replace(/[\s\S]^/gm,`$&amp;${l}#`)}</span>
<span class="s0">${l}${o}`:o}</span><span class="s1">function </span><span class="s0">c(o,l,_){</span><span class="s1">return </span><span class="s0">_?_.indexOf(`</span>
<span class="s0">`)===-</span><span class="s3">1</span><span class="s0">?`${o} #${_}`:`${o}</span>
<span class="s0">`+_.replace(/^/gm,`${l||</span><span class="s2">&quot;&quot;</span><span class="s0">}#`):o}</span><span class="s1">var </span><span class="s0">h=class{};</span><span class="s1">function </span><span class="s0">d(o,l,_){</span><span class="s1">if</span><span class="s0">(Array.isArray(o))</span><span class="s1">return </span><span class="s0">o.map((v,b)=&gt;d(v,String(b),_));</span><span class="s1">if</span><span class="s0">(o&amp;&amp;</span><span class="s1">typeof </span><span class="s0">o.toJSON==</span><span class="s2">&quot;function&quot;</span><span class="s0">){let v=_&amp;&amp;_.anchors&amp;&amp;_.anchors.get(o);v&amp;&amp;(_.onCreate=w=&gt;{v.res=w,</span><span class="s1">delete </span><span class="s0">_.onCreate});let b=o.toJSON(l,_);</span><span class="s1">return </span><span class="s0">v&amp;&amp;_.onCreate&amp;&amp;_.onCreate(b),b}</span><span class="s1">return</span><span class="s0">(!_||!_.keep)&amp;&amp;</span><span class="s1">typeof </span><span class="s0">o==</span><span class="s2">&quot;bigint&quot;</span><span class="s0">?Number(o):o}</span><span class="s1">var </span><span class="s0">y=class extends h{constructor(o){super(),</span><span class="s1">this</span><span class="s0">.value=o}toJSON(o,l){</span><span class="s1">return </span><span class="s0">l&amp;&amp;l.keep?</span><span class="s1">this</span><span class="s0">.value:d(</span><span class="s1">this</span><span class="s0">.value,o,l)}toString(){</span><span class="s1">return </span><span class="s0">String(</span><span class="s1">this</span><span class="s0">.value)}};</span><span class="s1">function </span><span class="s0">E(o,l,_){let v=_;</span><span class="s1">for</span><span class="s0">(let b=l.length-1;b&gt;=</span><span class="s3">0</span><span class="s0">;--b){let w=l[b];</span><span class="s1">if</span><span class="s0">(Number.isInteger(w)&amp;&amp;w&gt;=</span><span class="s3">0</span><span class="s0">){let A=[];A[w]=v,v=A}</span><span class="s1">else</span><span class="s0">{let A={};Object.defineProperty(A,w,{value:v,writable:!</span><span class="s3">0</span><span class="s0">,enumerable:!</span><span class="s3">0</span><span class="s0">,configurable:!</span><span class="s3">0</span><span class="s0">}),v=A}}</span><span class="s1">return </span><span class="s0">o.createNode(v,!</span><span class="s3">1</span><span class="s0">)}</span><span class="s1">var </span><span class="s0">I=o=&gt;o==</span><span class="s1">null</span><span class="s0">||</span><span class="s1">typeof </span><span class="s0">o==</span><span class="s2">&quot;object&quot;</span><span class="s0">&amp;&amp;o[Symbol.iterator]().next().done,S=class extends h{constructor(o){super(),e._defineProperty(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;items&quot;</span><span class="s0">,[]),</span><span class="s1">this</span><span class="s0">.schema=o}addIn(o,l){</span><span class="s1">if</span><span class="s0">(I(o))</span><span class="s1">this</span><span class="s0">.add(l);</span><span class="s1">else</span><span class="s0">{let[_,...v]=o,b=</span><span class="s1">this</span><span class="s0">.get(_,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(b </span><span class="s1">instanceof </span><span class="s0">S)b.addIn(v,l);</span><span class="s1">else if</span><span class="s0">(b===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.schema)</span><span class="s1">this</span><span class="s0">.set(_,E(</span><span class="s1">this</span><span class="s0">.schema,v,l));</span><span class="s1">else throw new </span><span class="s0">Error(`Expected YAML collection at ${_}. Remaining path: ${v}`)}}deleteIn(o){let[l,..._]=o;</span><span class="s1">if</span><span class="s0">(_.length===</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return this</span><span class="s0">.</span><span class="s1">delete</span><span class="s0">(l);let v=</span><span class="s1">this</span><span class="s0">.get(l,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(v </span><span class="s1">instanceof </span><span class="s0">S)</span><span class="s1">return </span><span class="s0">v.deleteIn(_);</span><span class="s1">throw new </span><span class="s0">Error(`Expected YAML collection at ${l}. Remaining path: ${_}`)}getIn(o,l){let[_,...v]=o,b=</span><span class="s1">this</span><span class="s0">.get(_,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">return </span><span class="s0">v.length===</span><span class="s3">0</span><span class="s0">?!l&amp;&amp;b </span><span class="s1">instanceof </span><span class="s0">y?b.value:b:b </span><span class="s1">instanceof </span><span class="s0">S?b.getIn(v,l):</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}hasAllNullValues(){</span><span class="s1">return this</span><span class="s0">.items.every(o=&gt;{</span><span class="s1">if</span><span class="s0">(!o||o.type!==</span><span class="s2">&quot;PAIR&quot;</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let l=o.value;</span><span class="s1">return </span><span class="s0">l==</span><span class="s1">null</span><span class="s0">||l </span><span class="s1">instanceof </span><span class="s0">y&amp;&amp;l.value==</span><span class="s1">null</span><span class="s0">&amp;&amp;!l.commentBefore&amp;&amp;!l.comment&amp;&amp;!l.tag})}hasIn(o){let[l,..._]=o;</span><span class="s1">if</span><span class="s0">(_.length===</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return this</span><span class="s0">.has(l);let v=</span><span class="s1">this</span><span class="s0">.get(l,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">return </span><span class="s0">v </span><span class="s1">instanceof </span><span class="s0">S?v.hasIn(_):!</span><span class="s3">1</span><span class="s0">}setIn(o,l){let[_,...v]=o;</span><span class="s1">if</span><span class="s0">(v.length===</span><span class="s3">0</span><span class="s0">)</span><span class="s1">this</span><span class="s0">.set(_,l);</span><span class="s1">else</span><span class="s0">{let b=</span><span class="s1">this</span><span class="s0">.get(_,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(b </span><span class="s1">instanceof </span><span class="s0">S)b.setIn(v,l);</span><span class="s1">else if</span><span class="s0">(b===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.schema)</span><span class="s1">this</span><span class="s0">.set(_,E(</span><span class="s1">this</span><span class="s0">.schema,v,l));</span><span class="s1">else throw new </span><span class="s0">Error(`Expected YAML collection at ${_}. Remaining path: ${v}`)}}toJSON(){</span><span class="s1">return null</span><span class="s0">}toString(o,l,_,v){let{blockItem:b,flowChars:w,isMap:A,itemIndent:N}=l,{indent:j,indentStep:F,stringify:Q}=o,H=</span><span class="s1">this</span><span class="s0">.type===e.Type.FLOW_MAP||</span><span class="s1">this</span><span class="s0">.type===e.Type.FLOW_SEQ||o.inFlow;H&amp;&amp;(N+=F);let oe=A&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasAllNullValues();o=Object.assign({},o,{allNullValues:oe,indent:N,inFlow:H,type:</span><span class="s1">null</span><span class="s0">});let le=!</span><span class="s3">1</span><span class="s0">,Z=!</span><span class="s3">1</span><span class="s0">,ee=</span><span class="s1">this</span><span class="s0">.items.reduce((de,ne,he)=&gt;{let ce;ne&amp;&amp;(!le&amp;&amp;ne.spaceBefore&amp;&amp;de.push({type:</span><span class="s2">&quot;comment&quot;</span><span class="s0">,str:</span><span class="s2">&quot;&quot;</span><span class="s0">}),ne.commentBefore&amp;&amp;ne.commentBefore.match(/^.*$/gm).forEach(Ie=&gt;{de.push({type:</span><span class="s2">&quot;comment&quot;</span><span class="s0">,str:`#${Ie}`})}),ne.comment&amp;&amp;(ce=ne.comment),H&amp;&amp;(!le&amp;&amp;ne.spaceBefore||ne.commentBefore||ne.comment||ne.key&amp;&amp;(ne.key.commentBefore||ne.key.comment)||ne.value&amp;&amp;(ne.value.commentBefore||ne.value.comment))&amp;&amp;(Z=!</span><span class="s3">0</span><span class="s0">)),le=!</span><span class="s3">1</span><span class="s0">;let fe=Q(ne,o,()=&gt;ce=</span><span class="s1">null</span><span class="s0">,()=&gt;le=!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">return </span><span class="s0">H&amp;&amp;!Z&amp;&amp;fe.includes(`</span>
<span class="s0">`)&amp;&amp;(Z=!</span><span class="s3">0</span><span class="s0">),H&amp;&amp;he&lt;</span><span class="s1">this</span><span class="s0">.items.length-1&amp;&amp;(fe+=</span><span class="s2">&quot;,&quot;</span><span class="s0">),fe=c(fe,N,ce),le&amp;&amp;(ce||H)&amp;&amp;(le=!</span><span class="s3">1</span><span class="s0">),de.push({type:</span><span class="s2">&quot;item&quot;</span><span class="s0">,str:fe}),de},[]),X;</span><span class="s1">if</span><span class="s0">(ee.length===</span><span class="s3">0</span><span class="s0">)X=w.start+w.end;</span><span class="s1">else if</span><span class="s0">(H){let{start:de,end:ne}=w,he=ee.map(ce=&gt;ce.str);</span><span class="s1">if</span><span class="s0">(Z||he.reduce((ce,fe)=&gt;ce+fe.length+</span><span class="s3">2</span><span class="s0">,</span><span class="s3">2</span><span class="s0">)&gt;S.maxFlowStringSingleLineLength){X=de;</span><span class="s1">for</span><span class="s0">(let ce of he)X+=ce?`</span>
<span class="s0">${F}${j}${ce}`:`</span>
<span class="s0">`;X+=`</span>
<span class="s0">${j}${ne}`}</span><span class="s1">else </span><span class="s0">X=`${de} ${he.join(</span><span class="s2">&quot; &quot;</span><span class="s0">)} ${ne}`}</span><span class="s1">else</span><span class="s0">{let de=ee.map(b);X=de.shift();</span><span class="s1">for</span><span class="s0">(let ne of de)X+=ne?`</span>
<span class="s0">${j}${ne}`:`</span>
<span class="s0">`}</span><span class="s1">return this</span><span class="s0">.comment?(X+=`</span>
<span class="s0">`+</span><span class="s1">this</span><span class="s0">.comment.replace(/^/gm,`${j}#`),_&amp;&amp;_()):le&amp;&amp;v&amp;&amp;v(),X}};e._defineProperty(S,</span><span class="s2">&quot;maxFlowStringSingleLineLength&quot;</span><span class="s0">,</span><span class="s3">60</span><span class="s0">);</span><span class="s1">function </span><span class="s0">M(o){let l=o </span><span class="s1">instanceof </span><span class="s0">y?o.value:o;</span><span class="s1">return </span><span class="s0">l&amp;&amp;</span><span class="s1">typeof </span><span class="s0">l==</span><span class="s2">&quot;string&quot;</span><span class="s0">&amp;&amp;(l=Number(l)),Number.isInteger(l)&amp;&amp;l&gt;=</span><span class="s3">0</span><span class="s0">?l:</span><span class="s1">null</span><span class="s0">}</span><span class="s1">var </span><span class="s0">T=class extends S{add(o){</span><span class="s1">this</span><span class="s0">.items.push(o)}</span><span class="s1">delete</span><span class="s0">(o){let l=M(o);</span><span class="s1">return typeof </span><span class="s0">l!=</span><span class="s2">&quot;number&quot;</span><span class="s0">?!</span><span class="s3">1</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.items.splice(l,</span><span class="s3">1</span><span class="s0">).length&gt;</span><span class="s3">0</span><span class="s0">}get(o,l){let _=M(o);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">_!=</span><span class="s2">&quot;number&quot;</span><span class="s0">)</span><span class="s1">return</span><span class="s0">;let v=</span><span class="s1">this</span><span class="s0">.items[_];</span><span class="s1">return</span><span class="s0">!l&amp;&amp;v </span><span class="s1">instanceof </span><span class="s0">y?v.value:v}has(o){let l=M(o);</span><span class="s1">return typeof </span><span class="s0">l==</span><span class="s2">&quot;number&quot;</span><span class="s0">&amp;&amp;l&lt;</span><span class="s1">this</span><span class="s0">.items.length}set(o,l){let _=M(o);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">_!=</span><span class="s2">&quot;number&quot;</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(`Expected a valid index, not ${o}.`);</span><span class="s1">this</span><span class="s0">.items[_]=l}toJSON(o,l){let _=[];l&amp;&amp;l.onCreate&amp;&amp;l.onCreate(_);let v=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let b of </span><span class="s1">this</span><span class="s0">.items)_.push(d(b,String(v++),l));</span><span class="s1">return </span><span class="s0">_}toString(o,l,_){</span><span class="s1">return </span><span class="s0">o?super.toString(o,{blockItem:v=&gt;v.type===</span><span class="s2">&quot;comment&quot;</span><span class="s0">?v.str:`- ${v.str}`,flowChars:{start:</span><span class="s2">&quot;[&quot;</span><span class="s0">,end:</span><span class="s2">&quot;]&quot;</span><span class="s0">},isMap:!</span><span class="s3">1</span><span class="s0">,itemIndent:(o.indent||</span><span class="s2">&quot;&quot;</span><span class="s0">)+</span><span class="s2">&quot;  &quot;</span><span class="s0">},l,_):JSON.stringify(</span><span class="s1">this</span><span class="s0">)}},P=(o,l,_)=&gt;l===</span><span class="s1">null</span><span class="s0">?</span><span class="s2">&quot;&quot;</span><span class="s0">:</span><span class="s1">typeof </span><span class="s0">l!=</span><span class="s2">&quot;object&quot;</span><span class="s0">?String(l):o </span><span class="s1">instanceof </span><span class="s0">h&amp;&amp;_&amp;&amp;_.doc?o.toString({anchors:Object.create(</span><span class="s1">null</span><span class="s0">),doc:_.doc,indent:</span><span class="s2">&quot;&quot;</span><span class="s0">,indentStep:_.indentStep,inFlow:!</span><span class="s3">0</span><span class="s0">,inStringifyKey:!</span><span class="s3">0</span><span class="s0">,stringify:_.stringify}):JSON.stringify(l),C=class extends h{constructor(o){let l=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;super(),</span><span class="s1">this</span><span class="s0">.key=o,</span><span class="s1">this</span><span class="s0">.value=l,</span><span class="s1">this</span><span class="s0">.type=C.Type.PAIR}get commentBefore(){</span><span class="s1">return this</span><span class="s0">.key </span><span class="s1">instanceof </span><span class="s0">h?</span><span class="s1">this</span><span class="s0">.key.commentBefore:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}set commentBefore(o){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.key==</span><span class="s1">null</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.key=</span><span class="s1">new </span><span class="s0">y(</span><span class="s1">null</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.key </span><span class="s1">instanceof </span><span class="s0">h)</span><span class="s1">this</span><span class="s0">.key.commentBefore=o;</span><span class="s1">else</span><span class="s0">{let l=</span><span class="s2">&quot;Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.&quot;</span><span class="s0">;</span><span class="s1">throw new </span><span class="s0">Error(l)}}addToJSMap(o,l){let _=d(</span><span class="s1">this</span><span class="s0">.key,</span><span class="s2">&quot;&quot;</span><span class="s0">,o);</span><span class="s1">if</span><span class="s0">(l </span><span class="s1">instanceof </span><span class="s0">Map){let v=d(</span><span class="s1">this</span><span class="s0">.value,_,o);l.set(_,v)}</span><span class="s1">else if</span><span class="s0">(l </span><span class="s1">instanceof </span><span class="s0">Set)l.add(_);</span><span class="s1">else</span><span class="s0">{let v=P(</span><span class="s1">this</span><span class="s0">.key,_,o),b=d(</span><span class="s1">this</span><span class="s0">.value,v,o);v </span><span class="s1">in </span><span class="s0">l?Object.defineProperty(l,v,{value:b,writable:!</span><span class="s3">0</span><span class="s0">,enumerable:!</span><span class="s3">0</span><span class="s0">,configurable:!</span><span class="s3">0</span><span class="s0">}):l[v]=b}</span><span class="s1">return </span><span class="s0">l}toJSON(o,l){let _=l&amp;&amp;l.mapAsMap?</span><span class="s1">new </span><span class="s0">Map:{};</span><span class="s1">return this</span><span class="s0">.addToJSMap(l,_)}toString(o,l,_){</span><span class="s1">if</span><span class="s0">(!o||!o.doc)</span><span class="s1">return </span><span class="s0">JSON.stringify(</span><span class="s1">this</span><span class="s0">);let{indent:v,indentSeq:b,simpleKeys:w}=o.doc.options,{key:A,value:N}=</span><span class="s1">this</span><span class="s0">,j=A </span><span class="s1">instanceof </span><span class="s0">h&amp;&amp;A.comment;</span><span class="s1">if</span><span class="s0">(w){</span><span class="s1">if</span><span class="s0">(j)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;With simple keys, key nodes cannot have comments&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(A </span><span class="s1">instanceof </span><span class="s0">S){let ce=</span><span class="s2">&quot;With simple keys, collection cannot be used as a key value&quot;</span><span class="s0">;</span><span class="s1">throw new </span><span class="s0">Error(ce)}}let F=!w&amp;&amp;(!A||j||(A </span><span class="s1">instanceof </span><span class="s0">h?A </span><span class="s1">instanceof </span><span class="s0">S||A.type===e.Type.BLOCK_FOLDED||A.type===e.Type.BLOCK_LITERAL:</span><span class="s1">typeof </span><span class="s0">A==</span><span class="s2">&quot;object&quot;</span><span class="s0">)),{doc:Q,indent:H,indentStep:oe,stringify:le}=o;o=Object.assign({},o,{implicitKey:!F,indent:H+oe});let Z=!</span><span class="s3">1</span><span class="s0">,ee=le(A,o,()=&gt;j=</span><span class="s1">null</span><span class="s0">,()=&gt;Z=!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(ee=c(ee,o.indent,j),!F&amp;&amp;ee.length&gt;</span><span class="s3">1024</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(w)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;With simple keys, single line scalar must not span more than 1024 characters&quot;</span><span class="s0">);F=!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(o.allNullValues&amp;&amp;!w)</span><span class="s1">return this</span><span class="s0">.comment?(ee=c(ee,o.indent,</span><span class="s1">this</span><span class="s0">.comment),l&amp;&amp;l()):Z&amp;&amp;!j&amp;&amp;_&amp;&amp;_(),o.inFlow&amp;&amp;!F?ee:`? ${ee}`;ee=F?`? ${ee}</span>
<span class="s0">${H}:`:`${ee}:`,</span><span class="s1">this</span><span class="s0">.comment&amp;&amp;(ee=c(ee,o.indent,</span><span class="s1">this</span><span class="s0">.comment),l&amp;&amp;l());let X=</span><span class="s2">&quot;&quot;</span><span class="s0">,de=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(N </span><span class="s1">instanceof </span><span class="s0">h){</span><span class="s1">if</span><span class="s0">(N.spaceBefore&amp;&amp;(X=`</span>
<span class="s0">`),N.commentBefore){let ce=N.commentBefore.replace(/^/gm,`${o.indent}#`);X+=`</span>
<span class="s0">${ce}`}de=N.comment}</span><span class="s1">else </span><span class="s0">N&amp;&amp;</span><span class="s1">typeof </span><span class="s0">N==</span><span class="s2">&quot;object&quot;</span><span class="s0">&amp;&amp;(N=Q.schema.createNode(N,!</span><span class="s3">0</span><span class="s0">));o.implicitKey=!</span><span class="s3">1</span><span class="s0">,!F&amp;&amp;!</span><span class="s1">this</span><span class="s0">.comment&amp;&amp;N </span><span class="s1">instanceof </span><span class="s0">y&amp;&amp;(o.indentAtStart=ee.length+</span><span class="s3">1</span><span class="s0">),Z=!</span><span class="s3">1</span><span class="s0">,!b&amp;&amp;v&gt;=</span><span class="s3">2</span><span class="s0">&amp;&amp;!o.inFlow&amp;&amp;!F&amp;&amp;N </span><span class="s1">instanceof </span><span class="s0">T&amp;&amp;N.type!==e.Type.FLOW_SEQ&amp;&amp;!N.tag&amp;&amp;!Q.anchors.getName(N)&amp;&amp;(o.indent=o.indent.substr(</span><span class="s3">2</span><span class="s0">));let ne=le(N,o,()=&gt;de=</span><span class="s1">null</span><span class="s0">,()=&gt;Z=!</span><span class="s3">0</span><span class="s0">),he=</span><span class="s2">&quot; &quot;</span><span class="s0">;</span><span class="s1">return </span><span class="s0">X||</span><span class="s1">this</span><span class="s0">.comment?he=`${X}</span>
<span class="s0">${o.indent}`:!F&amp;&amp;N </span><span class="s1">instanceof </span><span class="s0">S?(!(ne[</span><span class="s3">0</span><span class="s0">]===</span><span class="s2">&quot;[&quot;</span><span class="s0">||ne[</span><span class="s3">0</span><span class="s0">]===</span><span class="s2">&quot;{&quot;</span><span class="s0">)||ne.includes(`</span>
<span class="s0">`))&amp;&amp;(he=`</span>
<span class="s0">${o.indent}`):ne[</span><span class="s3">0</span><span class="s0">]===`</span>
<span class="s0">`&amp;&amp;(he=</span><span class="s2">&quot;&quot;</span><span class="s0">),Z&amp;&amp;!de&amp;&amp;_&amp;&amp;_(),c(ee+he+ne,o.indent,de)}};e._defineProperty(C,</span><span class="s2">&quot;Type&quot;</span><span class="s0">,{PAIR:</span><span class="s2">&quot;PAIR&quot;</span><span class="s0">,MERGE_PAIR:</span><span class="s2">&quot;MERGE_PAIR&quot;</span><span class="s0">});</span><span class="s1">var </span><span class="s0">q=(o,l)=&gt;{</span><span class="s1">if</span><span class="s0">(o </span><span class="s1">instanceof </span><span class="s0">R){let _=l.get(o.source);</span><span class="s1">return </span><span class="s0">_.count*_.aliasCount}</span><span class="s1">else if</span><span class="s0">(o </span><span class="s1">instanceof </span><span class="s0">S){let _=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let v of o.items){let b=q(v,l);b&gt;_&amp;&amp;(_=b)}</span><span class="s1">return </span><span class="s0">_}</span><span class="s1">else if</span><span class="s0">(o </span><span class="s1">instanceof </span><span class="s0">C){let _=q(o.key,l),v=q(o.value,l);</span><span class="s1">return </span><span class="s0">Math.max(_,v)}</span><span class="s1">return </span><span class="s3">1</span><span class="s0">},R=class extends h{static stringify(o,l){let{range:_,source:v}=o,{anchors:b,doc:w,implicitKey:A,inStringifyKey:N}=l,j=Object.keys(b).find(Q=&gt;b[Q]===v);</span><span class="s1">if</span><span class="s0">(!j&amp;&amp;N&amp;&amp;(j=w.anchors.getName(v)||w.anchors.newName()),j)</span><span class="s1">return</span><span class="s0">`*${j}${A?</span><span class="s2">&quot; &quot;</span><span class="s0">:</span><span class="s2">&quot;&quot;</span><span class="s0">}`;let F=w.anchors.getName(v)?</span><span class="s2">&quot;Alias node must be after source node&quot;</span><span class="s0">:</span><span class="s2">&quot;Source node not found for alias node&quot;</span><span class="s0">;</span><span class="s1">throw new </span><span class="s0">Error(`${F} [${_}]`)}constructor(o){super(),</span><span class="s1">this</span><span class="s0">.source=o,</span><span class="s1">this</span><span class="s0">.type=e.Type.ALIAS}set tag(o){</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Alias nodes cannot have tags&quot;</span><span class="s0">)}toJSON(o,l){</span><span class="s1">if</span><span class="s0">(!l)</span><span class="s1">return </span><span class="s0">d(</span><span class="s1">this</span><span class="s0">.source,o,l);let{anchors:_,maxAliasCount:v}=l,b=_.get(</span><span class="s1">this</span><span class="s0">.source);</span><span class="s1">if</span><span class="s0">(!b||b.res===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">){let w=</span><span class="s2">&quot;This should not happen: Alias anchor was not resolved?&quot;</span><span class="s0">;</span><span class="s1">throw this</span><span class="s0">.cstNode?</span><span class="s1">new </span><span class="s0">e.YAMLReferenceError(</span><span class="s1">this</span><span class="s0">.cstNode,w):</span><span class="s1">new </span><span class="s0">ReferenceError(w)}</span><span class="s1">if</span><span class="s0">(v&gt;=</span><span class="s3">0</span><span class="s0">&amp;&amp;(b.count+=</span><span class="s3">1</span><span class="s0">,b.aliasCount===</span><span class="s3">0</span><span class="s0">&amp;&amp;(b.aliasCount=q(</span><span class="s1">this</span><span class="s0">.source,_)),b.count*b.aliasCount&gt;v)){let w=</span><span class="s2">&quot;Excessive alias count indicates a resource exhaustion attack&quot;</span><span class="s0">;</span><span class="s1">throw this</span><span class="s0">.cstNode?</span><span class="s1">new </span><span class="s0">e.YAMLReferenceError(</span><span class="s1">this</span><span class="s0">.cstNode,w):</span><span class="s1">new </span><span class="s0">ReferenceError(w)}</span><span class="s1">return </span><span class="s0">b.res}toString(o){</span><span class="s1">return </span><span class="s0">R.stringify(</span><span class="s1">this</span><span class="s0">,o)}};e._defineProperty(R,</span><span class="s2">&quot;default&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">function </span><span class="s0">B(o,l){let _=l </span><span class="s1">instanceof </span><span class="s0">y?l.value:l;</span><span class="s1">for</span><span class="s0">(let v of o)</span><span class="s1">if</span><span class="s0">(v </span><span class="s1">instanceof </span><span class="s0">C&amp;&amp;(v.key===l||v.key===_||v.key&amp;&amp;v.key.value===_))</span><span class="s1">return </span><span class="s0">v}</span><span class="s1">var </span><span class="s0">U=class extends S{add(o,l){o?o </span><span class="s1">instanceof </span><span class="s0">C||(o=</span><span class="s1">new </span><span class="s0">C(o.key||o,o.value)):o=</span><span class="s1">new </span><span class="s0">C(o);let _=B(</span><span class="s1">this</span><span class="s0">.items,o.key),v=</span><span class="s1">this</span><span class="s0">.schema&amp;&amp;</span><span class="s1">this</span><span class="s0">.schema.sortMapEntries;</span><span class="s1">if</span><span class="s0">(_)</span><span class="s1">if</span><span class="s0">(l)_.value=o.value;</span><span class="s1">else throw new </span><span class="s0">Error(`Key ${o.key} already set`);</span><span class="s1">else if</span><span class="s0">(v){let b=</span><span class="s1">this</span><span class="s0">.items.findIndex(w=&gt;v(o,w)&lt;</span><span class="s3">0</span><span class="s0">);b===-</span><span class="s3">1</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.items.push(o):</span><span class="s1">this</span><span class="s0">.items.splice(b,</span><span class="s3">0</span><span class="s0">,o)}</span><span class="s1">else this</span><span class="s0">.items.push(o)}</span><span class="s1">delete</span><span class="s0">(o){let l=B(</span><span class="s1">this</span><span class="s0">.items,o);</span><span class="s1">return </span><span class="s0">l?</span><span class="s1">this</span><span class="s0">.items.splice(</span><span class="s1">this</span><span class="s0">.items.indexOf(l),</span><span class="s3">1</span><span class="s0">).length&gt;</span><span class="s3">0</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">}get(o,l){let _=B(</span><span class="s1">this</span><span class="s0">.items,o),v=_&amp;&amp;_.value;</span><span class="s1">return</span><span class="s0">!l&amp;&amp;v </span><span class="s1">instanceof </span><span class="s0">y?v.value:v}has(o){</span><span class="s1">return</span><span class="s0">!!B(</span><span class="s1">this</span><span class="s0">.items,o)}set(o,l){</span><span class="s1">this</span><span class="s0">.add(</span><span class="s1">new </span><span class="s0">C(o,l),!</span><span class="s3">0</span><span class="s0">)}toJSON(o,l,_){let v=_?</span><span class="s1">new </span><span class="s0">_:l&amp;&amp;l.mapAsMap?</span><span class="s1">new </span><span class="s0">Map:{};l&amp;&amp;l.onCreate&amp;&amp;l.onCreate(v);</span><span class="s1">for</span><span class="s0">(let b of </span><span class="s1">this</span><span class="s0">.items)b.addToJSMap(l,v);</span><span class="s1">return </span><span class="s0">v}toString(o,l,_){</span><span class="s1">if</span><span class="s0">(!o)</span><span class="s1">return </span><span class="s0">JSON.stringify(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let v of </span><span class="s1">this</span><span class="s0">.items)</span><span class="s1">if</span><span class="s0">(!(v </span><span class="s1">instanceof </span><span class="s0">C))</span><span class="s1">throw new </span><span class="s0">Error(`Map items must all be pairs; found ${JSON.stringify(v)} instead`);</span><span class="s1">return </span><span class="s0">super.toString(o,{blockItem:v=&gt;v.str,flowChars:{start:</span><span class="s2">&quot;{&quot;</span><span class="s0">,end:</span><span class="s2">&quot;}&quot;</span><span class="s0">},isMap:!</span><span class="s3">0</span><span class="s0">,itemIndent:o.indent||</span><span class="s2">&quot;&quot;</span><span class="s0">},l,_)}},f=</span><span class="s2">&quot;&lt;&lt;&quot;</span><span class="s0">,i=class extends C{constructor(o){</span><span class="s1">if</span><span class="s0">(o </span><span class="s1">instanceof </span><span class="s0">C){let l=o.value;l </span><span class="s1">instanceof </span><span class="s0">T||(l=</span><span class="s1">new </span><span class="s0">T,l.items.push(o.value),l.range=o.value.range),super(o.key,l),</span><span class="s1">this</span><span class="s0">.range=o.range}</span><span class="s1">else </span><span class="s0">super(</span><span class="s1">new </span><span class="s0">y(f),</span><span class="s1">new </span><span class="s0">T);</span><span class="s1">this</span><span class="s0">.type=C.Type.MERGE_PAIR}addToJSMap(o,l){</span><span class="s1">for</span><span class="s0">(let{source:_}of </span><span class="s1">this</span><span class="s0">.value.items){</span><span class="s1">if</span><span class="s0">(!(_ </span><span class="s1">instanceof </span><span class="s0">U))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Merge sources must be maps&quot;</span><span class="s0">);let v=_.toJSON(</span><span class="s1">null</span><span class="s0">,o,Map);</span><span class="s1">for</span><span class="s0">(let[b,w]of v)l </span><span class="s1">instanceof </span><span class="s0">Map?l.has(b)||l.set(b,w):l </span><span class="s1">instanceof </span><span class="s0">Set?l.add(b):Object.prototype.hasOwnProperty.call(l,b)||Object.defineProperty(l,b,{value:w,writable:!</span><span class="s3">0</span><span class="s0">,enumerable:!</span><span class="s3">0</span><span class="s0">,configurable:!</span><span class="s3">0</span><span class="s0">})}</span><span class="s1">return </span><span class="s0">l}toString(o,l){let _=</span><span class="s1">this</span><span class="s0">.value;</span><span class="s1">if</span><span class="s0">(_.items.length&gt;</span><span class="s3">1</span><span class="s0">)</span><span class="s1">return </span><span class="s0">super.toString(o,l);</span><span class="s1">this</span><span class="s0">.value=_.items[</span><span class="s3">0</span><span class="s0">];let v=super.toString(o,l);</span><span class="s1">return this</span><span class="s0">.value=_,v}},t={defaultType:e.Type.BLOCK_LITERAL,lineWidth:</span><span class="s3">76</span><span class="s0">},s={trueStr:</span><span class="s2">&quot;true&quot;</span><span class="s0">,falseStr:</span><span class="s2">&quot;false&quot;</span><span class="s0">},a={asBigInt:!</span><span class="s3">1</span><span class="s0">},m={nullStr:</span><span class="s2">&quot;null&quot;</span><span class="s0">},g={defaultType:e.Type.PLAIN,doubleQuoted:{jsonEncoding:!</span><span class="s3">1</span><span class="s0">,minMultiLineLength:</span><span class="s3">40</span><span class="s0">},fold:{lineWidth:</span><span class="s3">80</span><span class="s0">,minContentWidth:</span><span class="s3">20</span><span class="s0">}};</span><span class="s1">function </span><span class="s0">u(o,l,_){</span><span class="s1">for</span><span class="s0">(let{format:v,test:b,resolve:w}of l)</span><span class="s1">if</span><span class="s0">(b){let A=o.match(b);</span><span class="s1">if</span><span class="s0">(A){let N=w.apply(</span><span class="s1">null</span><span class="s0">,A);</span><span class="s1">return </span><span class="s0">N </span><span class="s1">instanceof </span><span class="s0">y||(N=</span><span class="s1">new </span><span class="s0">y(N)),v&amp;&amp;(N.format=v),N}}</span><span class="s1">return </span><span class="s0">_&amp;&amp;(o=_(o)),</span><span class="s1">new </span><span class="s0">y(o)}</span><span class="s1">var </span><span class="s0">p=</span><span class="s2">&quot;flow&quot;</span><span class="s0">,L=</span><span class="s2">&quot;block&quot;</span><span class="s0">,k=</span><span class="s2">&quot;quoted&quot;</span><span class="s0">,$=(o,l)=&gt;{let _=o[l+</span><span class="s3">1</span><span class="s0">];</span><span class="s1">for</span><span class="s0">(;_===</span><span class="s2">&quot; &quot;</span><span class="s0">||_===</span><span class="s2">&quot;    &quot;</span><span class="s0">;){</span><span class="s1">do </span><span class="s0">_=o[l+=</span><span class="s3">1</span><span class="s0">];</span><span class="s1">while</span><span class="s0">(_&amp;&amp;_!==`</span>
<span class="s0">`);_=o[l+</span><span class="s3">1</span><span class="s0">]}</span><span class="s1">return </span><span class="s0">l};</span><span class="s1">function </span><span class="s0">K(o,l,_,v){let{indentAtStart:b,lineWidth:w=</span><span class="s3">80</span><span class="s0">,minContentWidth:A=</span><span class="s3">20</span><span class="s0">,onFold:N,onOverflow:j}=v;</span><span class="s1">if</span><span class="s0">(!w||w&lt;</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return </span><span class="s0">o;let F=Math.max(</span><span class="s3">1</span><span class="s0">+A,</span><span class="s3">1</span><span class="s0">+w-l.length);</span><span class="s1">if</span><span class="s0">(o.length&lt;=F)</span><span class="s1">return </span><span class="s0">o;let Q=[],H={},oe=w-l.length;</span><span class="s1">typeof </span><span class="s0">b==</span><span class="s2">&quot;number&quot;</span><span class="s0">&amp;&amp;(b&gt;w-Math.max(</span><span class="s3">2</span><span class="s0">,A)?Q.push(</span><span class="s3">0</span><span class="s0">):oe=w-b);let le,Z,ee=!</span><span class="s3">1</span><span class="s0">,X=-</span><span class="s3">1</span><span class="s0">,de=-</span><span class="s3">1</span><span class="s0">,ne=-</span><span class="s3">1</span><span class="s0">;_===L&amp;&amp;(X=$(o,X),X!==-</span><span class="s3">1</span><span class="s0">&amp;&amp;(oe=X+F));</span><span class="s1">for</span><span class="s0">(let ce;ce=o[X+=</span><span class="s3">1</span><span class="s0">];){</span><span class="s1">if</span><span class="s0">(_===k&amp;&amp;ce===</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">&quot;</span><span class="s0">){</span><span class="s1">switch</span><span class="s0">(de=X,o[X+</span><span class="s3">1</span><span class="s0">]){</span><span class="s1">case</span><span class="s2">&quot;x&quot;</span><span class="s0">:X+=</span><span class="s3">3</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;u&quot;</span><span class="s0">:X+=</span><span class="s3">5</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;U&quot;</span><span class="s0">:X+=</span><span class="s3">9</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:X+=</span><span class="s3">1</span><span class="s0">}ne=X}</span><span class="s1">if</span><span class="s0">(ce===`</span>
<span class="s0">`)_===L&amp;&amp;(X=$(o,X)),oe=X+F,le=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(ce===</span><span class="s2">&quot; &quot;</span><span class="s0">&amp;&amp;Z&amp;&amp;Z!==</span><span class="s2">&quot; &quot;</span><span class="s0">&amp;&amp;Z!==`</span>
<span class="s0">`&amp;&amp;Z!==</span><span class="s2">&quot;    &quot;</span><span class="s0">){let fe=o[X+</span><span class="s3">1</span><span class="s0">];fe&amp;&amp;fe!==</span><span class="s2">&quot; &quot;</span><span class="s0">&amp;&amp;fe!==`</span>
<span class="s0">`&amp;&amp;fe!==</span><span class="s2">&quot;   &quot;</span><span class="s0">&amp;&amp;(le=X)}</span><span class="s1">if</span><span class="s0">(X&gt;=oe)</span><span class="s1">if</span><span class="s0">(le)Q.push(le),oe=le+F,le=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(_===k){</span><span class="s1">for</span><span class="s0">(;Z===</span><span class="s2">&quot; &quot;</span><span class="s0">||Z===</span><span class="s2">&quot;  &quot;</span><span class="s0">;)Z=ce,ce=o[X+=</span><span class="s3">1</span><span class="s0">],ee=!</span><span class="s3">0</span><span class="s0">;let fe=X&gt;ne+</span><span class="s3">1</span><span class="s0">?X-2:de-1;</span><span class="s1">if</span><span class="s0">(H[fe])</span><span class="s1">return </span><span class="s0">o;Q.push(fe),H[fe]=!</span><span class="s3">0</span><span class="s0">,oe=fe+F,le=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}</span><span class="s1">else </span><span class="s0">ee=!</span><span class="s3">0</span><span class="s0">}Z=ce}</span><span class="s1">if</span><span class="s0">(ee&amp;&amp;j&amp;&amp;j(),Q.length===</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return </span><span class="s0">o;N&amp;&amp;N();let he=o.slice(</span><span class="s3">0</span><span class="s0">,Q[</span><span class="s3">0</span><span class="s0">]);</span><span class="s1">for</span><span class="s0">(let ce=</span><span class="s3">0</span><span class="s0">;ce&lt;Q.length;++ce){let fe=Q[ce],Ie=Q[ce+</span><span class="s3">1</span><span class="s0">]||o.length;fe===</span><span class="s3">0</span><span class="s0">?he=`</span>
<span class="s0">${l}${o.slice(</span><span class="s3">0</span><span class="s0">,Ie)}`:(_===k&amp;&amp;H[fe]&amp;&amp;(he+=`${o[fe]}\\`),he+=`</span>
<span class="s0">${l}${o.slice(fe+</span><span class="s3">1</span><span class="s0">,Ie)}`)}</span><span class="s1">return </span><span class="s0">he}</span><span class="s1">var </span><span class="s0">V=o=&gt;{let{indentAtStart:l}=o;</span><span class="s1">return </span><span class="s0">l?Object.assign({indentAtStart:l},g.fold):g.fold},z=o=&gt;/^(%|---|\.\.\.)/m.test(o);</span><span class="s1">function </span><span class="s0">ae(o,l,_){</span><span class="s1">if</span><span class="s0">(!l||l&lt;</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let v=l-_,b=o.length;</span><span class="s1">if</span><span class="s0">(b&lt;=v)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let w=</span><span class="s3">0</span><span class="s0">,A=</span><span class="s3">0</span><span class="s0">;w&lt;b;++w)</span><span class="s1">if</span><span class="s0">(o[w]===`</span>
<span class="s0">`){</span><span class="s1">if</span><span class="s0">(w-A&gt;v)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(A=w+</span><span class="s3">1</span><span class="s0">,b-A&lt;=v)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">function </span><span class="s0">ue(o,l){let{implicitKey:_}=l,{jsonEncoding:v,minMultiLineLength:b}=g.doubleQuoted,w=JSON.stringify(o);</span><span class="s1">if</span><span class="s0">(v)</span><span class="s1">return </span><span class="s0">w;let A=l.indent||(z(o)?</span><span class="s2">&quot;  &quot;</span><span class="s0">:</span><span class="s2">&quot;&quot;</span><span class="s0">),N=</span><span class="s2">&quot;&quot;</span><span class="s0">,j=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let F=</span><span class="s3">0</span><span class="s0">,Q=w[F];Q;Q=w[++F])</span><span class="s1">if</span><span class="s0">(Q===</span><span class="s2">&quot; &quot;</span><span class="s0">&amp;&amp;w[F+</span><span class="s3">1</span><span class="s0">]===</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">&quot;</span><span class="s0">&amp;&amp;w[F+</span><span class="s3">2</span><span class="s0">]===</span><span class="s2">&quot;n&quot;</span><span class="s0">&amp;&amp;(N+=w.slice(j,F)+</span><span class="s2">&quot;</span><span class="s4">\\ </span><span class="s2">&quot;</span><span class="s0">,F+=</span><span class="s3">1</span><span class="s0">,j=F,Q=</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">&quot;</span><span class="s0">),Q===</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">&quot;</span><span class="s0">)</span><span class="s1">switch</span><span class="s0">(w[F+</span><span class="s3">1</span><span class="s0">]){</span><span class="s1">case</span><span class="s2">&quot;u&quot;</span><span class="s0">:{N+=w.slice(j,F);let H=w.substr(F+</span><span class="s3">2</span><span class="s0">,</span><span class="s3">4</span><span class="s0">);</span><span class="s1">switch</span><span class="s0">(H){</span><span class="s1">case</span><span class="s2">&quot;0000&quot;</span><span class="s0">:N+=</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">0&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;0007&quot;</span><span class="s0">:N+=</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">a&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;000b&quot;</span><span class="s0">:N+=</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">v&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;001b&quot;</span><span class="s0">:N+=</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">e&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;0085&quot;</span><span class="s0">:N+=</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">N&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;00a0&quot;</span><span class="s0">:N+=</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">_&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;2028&quot;</span><span class="s0">:N+=</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">L&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;2029&quot;</span><span class="s0">:N+=</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">P&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:H.substr(</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">)===</span><span class="s2">&quot;00&quot;</span><span class="s0">?N+=</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">x&quot;</span><span class="s0">+H.substr(</span><span class="s3">2</span><span class="s0">):N+=w.substr(F,</span><span class="s3">6</span><span class="s0">)}F+=</span><span class="s3">5</span><span class="s0">,j=F+</span><span class="s3">1</span><span class="s0">}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;n&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(_||w[F+</span><span class="s3">2</span><span class="s0">]===</span><span class="s2">'&quot;'</span><span class="s0">||w.length&lt;b)F+=</span><span class="s3">1</span><span class="s0">;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">for</span><span class="s0">(N+=w.slice(j,F)+`</span>

<span class="s0">`;w[F+</span><span class="s3">2</span><span class="s0">]===</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">&quot;</span><span class="s0">&amp;&amp;w[F+</span><span class="s3">3</span><span class="s0">]===</span><span class="s2">&quot;n&quot;</span><span class="s0">&amp;&amp;w[F+</span><span class="s3">4</span><span class="s0">]!==</span><span class="s2">'&quot;'</span><span class="s0">;)N+=`</span>
<span class="s0">`,F+=</span><span class="s3">2</span><span class="s0">;N+=A,w[F+</span><span class="s3">2</span><span class="s0">]===</span><span class="s2">&quot; &quot;</span><span class="s0">&amp;&amp;(N+=</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">&quot;</span><span class="s0">),F+=</span><span class="s3">1</span><span class="s0">,j=F+</span><span class="s3">1</span><span class="s0">}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:F+=</span><span class="s3">1</span><span class="s0">}</span><span class="s1">return </span><span class="s0">N=j?N+w.slice(j):w,_?N:K(N,A,k,V(l))}</span><span class="s1">function </span><span class="s0">pe(o,l){</span><span class="s1">if</span><span class="s0">(l.implicitKey){</span><span class="s1">if</span><span class="s0">(/\n/.test(o))</span><span class="s1">return </span><span class="s0">ue(o,l)}</span><span class="s1">else if</span><span class="s0">(/[ \t]\n|\n[ \t]/.test(o))</span><span class="s1">return </span><span class="s0">ue(o,l);let _=l.indent||(z(o)?</span><span class="s2">&quot;  &quot;</span><span class="s0">:</span><span class="s2">&quot;&quot;</span><span class="s0">),v=</span><span class="s2">&quot;'&quot;</span><span class="s0">+o.replace(/</span><span class="s2">'/g,&quot;''&quot;).replace(/</span><span class="s4">\n</span><span class="s2">+/g,`$&amp;</span>
<span class="s0">${_}`)+</span><span class="s2">&quot;'&quot;</span><span class="s0">;</span><span class="s1">return </span><span class="s0">l.implicitKey?v:K(v,_,p,V(l))}</span><span class="s1">function </span><span class="s0">ge(o,l,_,v){let{comment:b,type:w,value:A}=o;</span><span class="s1">if</span><span class="s0">(/\n[\t ]+$/.test(A)||/^\s*$/.test(A))</span><span class="s1">return </span><span class="s0">ue(A,l);let N=l.indent||(l.forceBlockIndent||z(A)?</span><span class="s2">&quot;  &quot;</span><span class="s0">:</span><span class="s2">&quot;&quot;</span><span class="s0">),j=N?</span><span class="s2">&quot;2&quot;</span><span class="s0">:</span><span class="s2">&quot;1&quot;</span><span class="s0">,F=w===e.Type.BLOCK_FOLDED?!</span><span class="s3">1</span><span class="s0">:w===e.Type.BLOCK_LITERAL?!</span><span class="s3">0</span><span class="s0">:!ae(A,g.fold.lineWidth,N.length),Q=F?</span><span class="s2">&quot;|&quot;</span><span class="s0">:</span><span class="s2">&quot;&gt;&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!A)</span><span class="s1">return </span><span class="s0">Q+`</span>
<span class="s0">`;let H=</span><span class="s2">&quot;&quot;</span><span class="s0">,oe=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(A=A.replace(/[\n\t ]*$/,Z=&gt;{let ee=Z.indexOf(`</span>
<span class="s0">`);</span><span class="s1">return </span><span class="s0">ee===-</span><span class="s3">1</span><span class="s0">?Q+=</span><span class="s2">&quot;-&quot;</span><span class="s0">:(A===Z||ee!==Z.length-1)&amp;&amp;(Q+=</span><span class="s2">&quot;+&quot;</span><span class="s0">,v&amp;&amp;v()),oe=Z.replace(/\n$/,</span><span class="s2">&quot;&quot;</span><span class="s0">),</span><span class="s2">&quot;&quot;</span><span class="s0">}).replace(/^[\n ]*/,Z=&gt;{Z.indexOf(</span><span class="s2">&quot; &quot;</span><span class="s0">)!==-</span><span class="s3">1</span><span class="s0">&amp;&amp;(Q+=j);let ee=Z.match(/ +$/);</span><span class="s1">return </span><span class="s0">ee?(H=Z.slice(</span><span class="s3">0</span><span class="s0">,-ee[</span><span class="s3">0</span><span class="s0">].length),ee[</span><span class="s3">0</span><span class="s0">]):(H=Z,</span><span class="s2">&quot;&quot;</span><span class="s0">)}),oe&amp;&amp;(oe=oe.replace(/\n+(?!\n|$)/g,`$&amp;${N}`)),H&amp;&amp;(H=H.replace(/\n+/g,`$&amp;${N}`)),b&amp;&amp;(Q+=</span><span class="s2">&quot; #&quot;</span><span class="s0">+b.replace(/ ?[\r\n]+/g,</span><span class="s2">&quot; &quot;</span><span class="s0">),_&amp;&amp;_()),!A)</span><span class="s1">return</span><span class="s0">`${Q}${j}</span>
<span class="s0">${N}${oe}`;</span><span class="s1">if</span><span class="s0">(F)</span><span class="s1">return </span><span class="s0">A=A.replace(/\n+/g,`$&amp;${N}`),`${Q}</span>
<span class="s0">${N}${H}${A}${oe}`;A=A.replace(/\n+/g,`</span>
<span class="s0">$&amp;`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g,</span><span class="s2">&quot;$1$2&quot;</span><span class="s0">).replace(/\n+/g,`$&amp;${N}`);let le=K(`${H}${A}${oe}`,N,L,g.fold);</span><span class="s1">return</span><span class="s0">`${Q}</span>
<span class="s0">${N}${le}`}</span><span class="s1">function </span><span class="s0">O(o,l,_,v){let{comment:b,type:w,value:A}=o,{actualString:N,implicitKey:j,indent:F,inFlow:Q}=l;</span><span class="s1">if</span><span class="s0">(j&amp;&amp;/[\n[\]{},]/.test(A)||Q&amp;&amp;/[[\]{},]/.test(A))</span><span class="s1">return </span><span class="s0">ue(A,l);</span><span class="s1">if</span><span class="s0">(!A||/^[\n\t ,[\]{}#&amp;*!|&gt;</span><span class="s2">'&quot;%@`]|^[?-]$|^[?-][ </span><span class="s4">\t</span><span class="s2">]|[</span><span class="s4">\n</span><span class="s2">:][ </span><span class="s4">\t</span><span class="s2">]|[ </span><span class="s4">\t</span><span class="s2">]</span><span class="s4">\n</span><span class="s2">|[</span><span class="s4">\n\t </span><span class="s2">]#|[</span><span class="s4">\n\t </span><span class="s2">:]$/.test(A))return j||Q||A.indexOf(`</span>
<span class="s0">`)===-</span><span class="s3">1</span><span class="s0">?A.indexOf(</span><span class="s2">'&quot;'</span><span class="s0">)!==-</span><span class="s3">1</span><span class="s0">&amp;&amp;A.indexOf(</span><span class="s2">&quot;'&quot;</span><span class="s0">)===-</span><span class="s3">1</span><span class="s0">?pe(A,l):ue(A,l):ge(o,l,_,v);</span><span class="s1">if</span><span class="s0">(!j&amp;&amp;!Q&amp;&amp;w!==e.Type.PLAIN&amp;&amp;A.indexOf(`</span>
<span class="s0">`)!==-</span><span class="s3">1</span><span class="s0">)</span><span class="s1">return </span><span class="s0">ge(o,l,_,v);</span><span class="s1">if</span><span class="s0">(F===</span><span class="s2">&quot;&quot;</span><span class="s0">&amp;&amp;z(A))</span><span class="s1">return </span><span class="s0">l.forceBlockIndent=!</span><span class="s3">0</span><span class="s0">,ge(o,l,_,v);let H=A.replace(/\n+/g,`$&amp;</span>
<span class="s0">${F}`);</span><span class="s1">if</span><span class="s0">(N){let{tags:le}=l.doc.schema;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">u(H,le,le.scalarFallback).value!=</span><span class="s2">&quot;string&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">ue(A,l)}let oe=j?H:K(H,F,p,V(l));</span><span class="s1">return </span><span class="s0">b&amp;&amp;!Q&amp;&amp;(oe.indexOf(`</span>
<span class="s0">`)!==-</span><span class="s3">1</span><span class="s0">||b.indexOf(`</span>
<span class="s0">`)!==-</span><span class="s3">1</span><span class="s0">)?(_&amp;&amp;_(),r(oe,F,b)):oe}</span><span class="s1">function </span><span class="s0">W(o,l,_,v){let{defaultType:b}=g,{implicitKey:w,inFlow:A}=l,{type:N,value:j}=o;</span><span class="s1">typeof </span><span class="s0">j!=</span><span class="s2">&quot;string&quot;</span><span class="s0">&amp;&amp;(j=String(j),o=Object.assign({},o,{value:j}));let F=H=&gt;{</span><span class="s1">switch</span><span class="s0">(H){</span><span class="s1">case </span><span class="s0">e.Type.BLOCK_FOLDED:</span><span class="s1">case </span><span class="s0">e.Type.BLOCK_LITERAL:</span><span class="s1">return </span><span class="s0">ge(o,l,_,v);</span><span class="s1">case </span><span class="s0">e.Type.QUOTE_DOUBLE:</span><span class="s1">return </span><span class="s0">ue(j,l);</span><span class="s1">case </span><span class="s0">e.Type.QUOTE_SINGLE:</span><span class="s1">return </span><span class="s0">pe(j,l);</span><span class="s1">case </span><span class="s0">e.Type.PLAIN:</span><span class="s1">return </span><span class="s0">O(o,l,_,v);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return null</span><span class="s0">}};(N!==e.Type.QUOTE_DOUBLE&amp;&amp;/[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(j)||(w||A)&amp;&amp;(N===e.Type.BLOCK_FOLDED||N===e.Type.BLOCK_LITERAL))&amp;&amp;(N=e.Type.QUOTE_DOUBLE);let Q=F(N);</span><span class="s1">if</span><span class="s0">(Q===</span><span class="s1">null</span><span class="s0">&amp;&amp;(Q=F(b),Q===</span><span class="s1">null</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(`Unsupported </span><span class="s1">default </span><span class="s0">string type ${b}`);</span><span class="s1">return </span><span class="s0">Q}</span><span class="s1">function </span><span class="s0">J(o){let{format:l,minFractionDigits:_,tag:v,value:b}=o;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">b==</span><span class="s2">&quot;bigint&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">String(b);</span><span class="s1">if</span><span class="s0">(!isFinite(b))</span><span class="s1">return </span><span class="s0">isNaN(b)?</span><span class="s2">&quot;.nan&quot;</span><span class="s0">:b&lt;</span><span class="s3">0</span><span class="s0">?</span><span class="s2">&quot;-.inf&quot;</span><span class="s0">:</span><span class="s2">&quot;.inf&quot;</span><span class="s0">;let w=JSON.stringify(b);</span><span class="s1">if</span><span class="s0">(!l&amp;&amp;_&amp;&amp;(!v||v===</span><span class="s2">&quot;tag:yaml.org,2002:float&quot;</span><span class="s0">)&amp;&amp;/^\d/.test(w)){let A=w.indexOf(</span><span class="s2">&quot;.&quot;</span><span class="s0">);A&lt;</span><span class="s3">0</span><span class="s0">&amp;&amp;(A=w.length,w+=</span><span class="s2">&quot;.&quot;</span><span class="s0">);let N=_-(w.length-A-1);</span><span class="s1">for</span><span class="s0">(;N-- &gt;</span><span class="s3">0</span><span class="s0">;)w+=</span><span class="s2">&quot;0&quot;</span><span class="s0">}</span><span class="s1">return </span><span class="s0">w}</span><span class="s1">function </span><span class="s0">x(o,l){let _,v;</span><span class="s1">switch</span><span class="s0">(l.type){</span><span class="s1">case </span><span class="s0">e.Type.FLOW_MAP:_=</span><span class="s2">&quot;}&quot;</span><span class="s0">,v=</span><span class="s2">&quot;flow map&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">e.Type.FLOW_SEQ:_=</span><span class="s2">&quot;]&quot;</span><span class="s0">,v=</span><span class="s2">&quot;flow sequence&quot;</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:o.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(l,</span><span class="s2">&quot;Not a flow collection!?&quot;</span><span class="s0">));</span><span class="s1">return</span><span class="s0">}let b;</span><span class="s1">for</span><span class="s0">(let w=l.items.length-1;w&gt;=</span><span class="s3">0</span><span class="s0">;--w){let A=l.items[w];</span><span class="s1">if</span><span class="s0">(!A||A.type!==e.Type.COMMENT){b=A;</span><span class="s1">break</span><span class="s0">}}</span><span class="s1">if</span><span class="s0">(b&amp;&amp;b.char!==_){let w=`Expected ${v} to end </span><span class="s1">with </span><span class="s0">${_}`,A;</span><span class="s1">typeof </span><span class="s0">b.offset==</span><span class="s2">&quot;number&quot;</span><span class="s0">?(A=</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(l,w),A.offset=b.offset+</span><span class="s3">1</span><span class="s0">):(A=</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(b,w),b.range&amp;&amp;b.range.end&amp;&amp;(A.offset=b.range.end-b.range.start)),o.push(A)}}</span><span class="s1">function </span><span class="s0">G(o,l){let _=l.context.src[l.range.start-1];</span><span class="s1">if</span><span class="s0">(_!==`</span>
<span class="s0">`&amp;&amp;_!==</span><span class="s2">&quot;    &quot;</span><span class="s0">&amp;&amp;_!==</span><span class="s2">&quot; &quot;</span><span class="s0">){let v=</span><span class="s2">&quot;Comments must be separated from other tokens by white space characters&quot;</span><span class="s0">;o.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(l,v))}}</span><span class="s1">function </span><span class="s0">re(o,l){let _=String(l),v=_.substr(</span><span class="s3">0</span><span class="s0">,</span><span class="s3">8</span><span class="s0">)+</span><span class="s2">&quot;...&quot;</span><span class="s0">+_.substr(-</span><span class="s3">8</span><span class="s0">);</span><span class="s1">return new </span><span class="s0">e.YAMLSemanticError(o,`The </span><span class="s2">&quot;${v}&quot; </span><span class="s0">key is too long`)}</span><span class="s1">function </span><span class="s0">_e(o,l){</span><span class="s1">for</span><span class="s0">(let{afterKey:_,before:v,comment:b}of l){let w=o.items[v];w?(_&amp;&amp;w.value&amp;&amp;(w=w.value),b===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?(_||!w.commentBefore)&amp;&amp;(w.spaceBefore=!</span><span class="s3">0</span><span class="s0">):w.commentBefore?w.commentBefore+=`</span>
<span class="s0">`+b:w.commentBefore=b):b!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(o.comment?o.comment+=`</span>
<span class="s0">`+b:o.comment=b)}}</span><span class="s1">function </span><span class="s0">ye(o,l){let _=l.strValue;</span><span class="s1">return </span><span class="s0">_?</span><span class="s1">typeof </span><span class="s0">_==</span><span class="s2">&quot;string&quot;</span><span class="s0">?_:(_.errors.forEach(v=&gt;{v.source||(v.source=l),o.errors.push(v)}),_.str):</span><span class="s2">&quot;&quot;</span><span class="s0">}</span><span class="s1">function </span><span class="s0">be(o,l){let{handle:_,suffix:v}=l.tag,b=o.tagPrefixes.find(w=&gt;w.handle===_);</span><span class="s1">if</span><span class="s0">(!b){let w=o.getDefaults().tagPrefixes;</span><span class="s1">if</span><span class="s0">(w&amp;&amp;(b=w.find(A=&gt;A.handle===_)),!b)</span><span class="s1">throw new </span><span class="s0">e.YAMLSemanticError(l,`The ${_} tag handle is non-default and was not declared.`)}</span><span class="s1">if</span><span class="s0">(!v)</span><span class="s1">throw new </span><span class="s0">e.YAMLSemanticError(l,`The ${_} tag has no suffix.`);</span><span class="s1">if</span><span class="s0">(_===</span><span class="s2">&quot;!&quot;</span><span class="s0">&amp;&amp;(o.version||o.options.version)===</span><span class="s2">&quot;1.0&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(v[</span><span class="s3">0</span><span class="s0">]===</span><span class="s2">&quot;^&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">o.warnings.push(</span><span class="s1">new </span><span class="s0">e.YAMLWarning(l,</span><span class="s2">&quot;YAML 1.0 ^ tag expansion is not supported&quot;</span><span class="s0">)),v;</span><span class="s1">if</span><span class="s0">(/[:/]/.test(v)){let w=v.match(/^([a-z0-9-]+)\/(.*)/i);</span><span class="s1">return </span><span class="s0">w?`tag:${w[</span><span class="s3">1</span><span class="s0">]}.yaml.org,</span><span class="s3">2002</span><span class="s0">:${w[</span><span class="s3">2</span><span class="s0">]}`:`tag:${v}`}}</span><span class="s1">return </span><span class="s0">b.prefix+decodeURIComponent(v)}</span><span class="s1">function </span><span class="s0">ve(o,l){let{tag:_,type:v}=l,b=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(_){let{handle:w,suffix:A,verbatim:N}=_;</span><span class="s1">if</span><span class="s0">(N){</span><span class="s1">if</span><span class="s0">(N!==</span><span class="s2">&quot;!&quot;</span><span class="s0">&amp;&amp;N!==</span><span class="s2">&quot;!!&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">N;let j=`Verbatim tags aren</span><span class="s2">'t resolved, so ${N} is invalid.`;o.errors.push(new e.YAMLSemanticError(l,j))}else if(w===&quot;!&quot;&amp;&amp;!A)b=!0;else try{return be(o,l)}catch(j){o.errors.push(j)}}switch(v){case e.Type.BLOCK_FOLDED:case e.Type.BLOCK_LITERAL:case e.Type.QUOTE_DOUBLE:case e.Type.QUOTE_SINGLE:return e.defaultTags.STR;case e.Type.FLOW_MAP:case e.Type.MAP:return e.defaultTags.MAP;case e.Type.FLOW_SEQ:case e.Type.SEQ:return e.defaultTags.SEQ;case e.Type.PLAIN:return b?e.defaultTags.STR:null;default:return null}}function Ne(o,l,_){let{tags:v}=o.schema,b=[];for(let A of v)if(A.tag===_)if(A.test)b.push(A);else{let N=A.resolve(o,l);return N instanceof S?N:new y(N)}let w=ye(o,l);return typeof w==&quot;string&quot;&amp;&amp;b.length&gt;0?u(w,b,v.scalarFallback):null}function Pe(o){let{type:l}=o;switch(l){case e.Type.FLOW_MAP:case e.Type.MAP:return e.defaultTags.MAP;case e.Type.FLOW_SEQ:case e.Type.SEQ:return e.defaultTags.SEQ;default:return e.defaultTags.STR}}function ot(o,l,_){try{let v=Ne(o,l,_);if(v)return _&amp;&amp;l.tag&amp;&amp;(v.tag=_),v}catch(v){return v.source||(v.source=l),o.errors.push(v),null}try{let v=Pe(l);if(!v)throw new Error(`The tag ${_} is unavailable`);let b=`The tag ${_} is unavailable, falling back to ${v}`;o.warnings.push(new e.YAMLWarning(l,b));let w=Ne(o,l,v);return w.tag=_,w}catch(v){let b=new e.YAMLReferenceError(l,v.message);return b.stack=v.stack,o.errors.push(b),null}}var lt=o=&gt;{if(!o)return!1;let{type:l}=o;return l===e.Type.MAP_KEY||l===e.Type.MAP_VALUE||l===e.Type.SEQ_ITEM};function ct(o,l){let _={before:[],after:[]},v=!1,b=!1,w=lt(l.context.parent)?l.context.parent.props.concat(l.props):l.props;for(let{start:A,end:N}of w)switch(l.context.src[A]){case e.Char.COMMENT:{if(!l.commentHasRequiredWhitespace(A)){let H=&quot;Comments must be separated from other tokens by white space characters&quot;;o.push(new e.YAMLSemanticError(l,H))}let{header:j,valueRange:F}=l;(F&amp;&amp;(A&gt;F.start||j&amp;&amp;A&gt;j.start)?_.after:_.before).push(l.context.src.slice(A+1,N));break}case e.Char.ANCHOR:if(v){let j=&quot;A node can have at most one anchor&quot;;o.push(new e.YAMLSemanticError(l,j))}v=!0;break;case e.Char.TAG:if(b){let j=&quot;A node can have at most one tag&quot;;o.push(new e.YAMLSemanticError(l,j))}b=!0;break}return{comments:_,hasAnchor:v,hasTag:b}}function ut(o,l){let{anchors:_,errors:v,schema:b}=o;if(l.type===e.Type.ALIAS){let A=l.rawValue,N=_.getNode(A);if(!N){let F=`Aliased anchor not found: ${A}`;return v.push(new e.YAMLReferenceError(l,F)),null}let j=new R(N);return _._cstAliases.push(j),j}let w=ve(o,l);if(w)return ot(o,l,w);if(l.type!==e.Type.PLAIN){let A=`Failed to resolve ${l.type} node here`;return v.push(new e.YAMLSyntaxError(l,A)),null}try{let A=ye(o,l);return u(A,b.tags,b.tags.scalarFallback)}catch(A){return A.source||(A.source=l),v.push(A),null}}function we(o,l){if(!l)return null;l.error&amp;&amp;o.errors.push(l.error);let{comments:_,hasAnchor:v,hasTag:b}=ct(o.errors,l);if(v){let{anchors:A}=o,N=l.anchor,j=A.getNode(N);j&amp;&amp;(A.map[A.newName(N)]=j),A.map[N]=l}if(l.type===e.Type.ALIAS&amp;&amp;(v||b)){let A=&quot;An alias node must not specify any properties&quot;;o.errors.push(new e.YAMLSemanticError(l,A))}let w=ut(o,l);if(w){w.range=[l.range.start,l.range.end],o.options.keepCstNodes&amp;&amp;(w.cstNode=l),o.options.keepNodeTypes&amp;&amp;(w.type=l.type);let A=_.before.join(`</span>
<span class="s0">`);A&amp;&amp;(w.commentBefore=w.commentBefore?`${w.commentBefore}</span>
<span class="s0">${A}`:A);let N=_.after.join(`</span>
<span class="s0">`);N&amp;&amp;(w.comment=w.comment?`${w.comment}</span>
<span class="s0">${N}`:N)}</span><span class="s1">return </span><span class="s0">l.resolved=w}</span><span class="s1">function </span><span class="s0">ft(o,l){</span><span class="s1">if</span><span class="s0">(l.type!==e.Type.MAP&amp;&amp;l.type!==e.Type.FLOW_MAP){let A=`A ${l.type} node cannot be resolved as a mapping`;</span><span class="s1">return </span><span class="s0">o.errors.push(</span><span class="s1">new </span><span class="s0">e.YAMLSyntaxError(l,A)),</span><span class="s1">null</span><span class="s0">}let{comments:_,items:v}=l.type===e.Type.FLOW_MAP?gt(o,l):ht(o,l),b=</span><span class="s1">new </span><span class="s0">U;b.items=v,_e(b,_);let w=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let A=</span><span class="s3">0</span><span class="s0">;A&lt;v.length;++A){let{key:N}=v[A];</span><span class="s1">if</span><span class="s0">(N </span><span class="s1">instanceof </span><span class="s0">S&amp;&amp;(w=!</span><span class="s3">0</span><span class="s0">),o.schema.merge&amp;&amp;N&amp;&amp;N.value===f){v[A]=</span><span class="s1">new </span><span class="s0">i(v[A]);let j=v[A].value.items,F=</span><span class="s1">null</span><span class="s0">;j.some(Q=&gt;{</span><span class="s1">if</span><span class="s0">(Q </span><span class="s1">instanceof </span><span class="s0">R){let{type:H}=Q.source;</span><span class="s1">return </span><span class="s0">H===e.Type.MAP||H===e.Type.FLOW_MAP?!</span><span class="s3">1</span><span class="s0">:F=</span><span class="s2">&quot;Merge nodes aliases can only point to maps&quot;</span><span class="s0">}</span><span class="s1">return </span><span class="s0">F=</span><span class="s2">&quot;Merge nodes can only have Alias nodes as values&quot;</span><span class="s0">}),F&amp;&amp;o.errors.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(l,F))}</span><span class="s1">else for</span><span class="s0">(let j=A+</span><span class="s3">1</span><span class="s0">;j&lt;v.length;++j){let{key:F}=v[j];</span><span class="s1">if</span><span class="s0">(N===F||N&amp;&amp;F&amp;&amp;Object.prototype.hasOwnProperty.call(N,</span><span class="s2">&quot;value&quot;</span><span class="s0">)&amp;&amp;N.value===F.value){let Q=`Map keys must be unique; </span><span class="s2">&quot;${N}&quot; </span><span class="s0">is repeated`;o.errors.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(l,Q));</span><span class="s1">break</span><span class="s0">}}}</span><span class="s1">if</span><span class="s0">(w&amp;&amp;!o.options.mapAsMap){let A=</span><span class="s2">&quot;Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.&quot;</span><span class="s0">;o.warnings.push(</span><span class="s1">new </span><span class="s0">e.YAMLWarning(l,A))}</span><span class="s1">return </span><span class="s0">l.resolved=b,b}</span><span class="s1">var </span><span class="s0">mt=o=&gt;{let{context:{lineStart:l,node:_,src:v},props:b}=o;</span><span class="s1">if</span><span class="s0">(b.length===</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let{start:w}=b[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(_&amp;&amp;w&gt;_.valueRange.start||v[w]!==e.Char.COMMENT)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let A=l;A&lt;w;++A)</span><span class="s1">if</span><span class="s0">(v[A]===`</span>
<span class="s0">`)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">};</span><span class="s1">function </span><span class="s0">dt(o,l){</span><span class="s1">if</span><span class="s0">(!mt(o))</span><span class="s1">return</span><span class="s0">;let _=o.getPropValue(</span><span class="s3">0</span><span class="s0">,e.Char.COMMENT,!</span><span class="s3">0</span><span class="s0">),v=!</span><span class="s3">1</span><span class="s0">,b=l.value.commentBefore;</span><span class="s1">if</span><span class="s0">(b&amp;&amp;b.startsWith(_))l.value.commentBefore=b.substr(_.length+</span><span class="s3">1</span><span class="s0">),v=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">else</span><span class="s0">{let w=l.value.comment;!o.node&amp;&amp;w&amp;&amp;w.startsWith(_)&amp;&amp;(l.value.comment=w.substr(_.length+</span><span class="s3">1</span><span class="s0">),v=!</span><span class="s3">0</span><span class="s0">)}v&amp;&amp;(l.comment=_)}</span><span class="s1">function </span><span class="s0">ht(o,l){let _=[],v=[],b,w=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let A=</span><span class="s3">0</span><span class="s0">;A&lt;l.items.length;++A){let N=l.items[A];</span><span class="s1">switch</span><span class="s0">(N.type){</span><span class="s1">case </span><span class="s0">e.Type.BLANK_LINE:_.push({afterKey:!!b,before:v.length});</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">e.Type.COMMENT:_.push({afterKey:!!b,before:v.length,comment:N.comment});</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">e.Type.MAP_KEY:b!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;v.push(</span><span class="s1">new </span><span class="s0">C(b)),N.error&amp;&amp;o.errors.push(N.error),b=we(o,N.node),w=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">e.Type.MAP_VALUE:{</span><span class="s1">if</span><span class="s0">(b===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(b=</span><span class="s1">null</span><span class="s0">),N.error&amp;&amp;o.errors.push(N.error),!N.context.atLineStart&amp;&amp;N.node&amp;&amp;N.node.type===e.Type.MAP&amp;&amp;!N.node.context.atLineStart){let Q=</span><span class="s2">&quot;Nested mappings are not allowed in compact mappings&quot;</span><span class="s0">;o.errors.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(N.node,Q))}let j=N.node;</span><span class="s1">if</span><span class="s0">(!j&amp;&amp;N.props.length&gt;</span><span class="s3">0</span><span class="s0">){j=</span><span class="s1">new </span><span class="s0">e.PlainValue(e.Type.PLAIN,[]),j.context={parent:N,src:N.context.src};let Q=N.range.start+</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(j.range={start:Q,end:Q},j.valueRange={start:Q,end:Q},</span><span class="s1">typeof </span><span class="s0">N.range.origStart==</span><span class="s2">&quot;number&quot;</span><span class="s0">){let H=N.range.origStart+</span><span class="s3">1</span><span class="s0">;j.range.origStart=j.range.origEnd=H,j.valueRange.origStart=j.valueRange.origEnd=H}}let F=</span><span class="s1">new </span><span class="s0">C(b,we(o,j));dt(N,F),v.push(F),b&amp;&amp;</span><span class="s1">typeof </span><span class="s0">w==</span><span class="s2">&quot;number&quot;</span><span class="s0">&amp;&amp;N.range.start&gt;w+</span><span class="s3">1024</span><span class="s0">&amp;&amp;o.errors.push(re(l,b)),b=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,w=</span><span class="s1">null</span><span class="s0">}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:b!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;v.push(</span><span class="s1">new </span><span class="s0">C(b)),b=we(o,N),w=N.range.start,N.error&amp;&amp;o.errors.push(N.error);e:</span><span class="s1">for</span><span class="s0">(let j=A+</span><span class="s3">1</span><span class="s0">;;++j){let F=l.items[j];</span><span class="s1">switch</span><span class="s0">(F&amp;&amp;F.type){</span><span class="s1">case </span><span class="s0">e.Type.BLANK_LINE:</span><span class="s1">case </span><span class="s0">e.Type.COMMENT:</span><span class="s1">continue </span><span class="s0">e;</span><span class="s1">case </span><span class="s0">e.Type.MAP_VALUE:</span><span class="s1">break </span><span class="s0">e;</span><span class="s1">default</span><span class="s0">:{let Q=</span><span class="s2">&quot;Implicit map keys need to be followed by map values&quot;</span><span class="s0">;o.errors.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(N,Q));</span><span class="s1">break </span><span class="s0">e}}}</span><span class="s1">if</span><span class="s0">(N.valueRangeContainsNewline){let j=</span><span class="s2">&quot;Implicit map keys need to be on a single line&quot;</span><span class="s0">;o.errors.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(N,j))}}}</span><span class="s1">return </span><span class="s0">b!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;v.push(</span><span class="s1">new </span><span class="s0">C(b)),{comments:_,items:v}}</span><span class="s1">function </span><span class="s0">gt(o,l){let _=[],v=[],b,w=!</span><span class="s3">1</span><span class="s0">,A=</span><span class="s2">&quot;{&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let N=</span><span class="s3">0</span><span class="s0">;N&lt;l.items.length;++N){let j=l.items[N];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">j.char==</span><span class="s2">&quot;string&quot;</span><span class="s0">){let{char:F,offset:Q}=j;</span><span class="s1">if</span><span class="s0">(F===</span><span class="s2">&quot;?&quot;</span><span class="s0">&amp;&amp;b===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;!w){w=!</span><span class="s3">0</span><span class="s0">,A=</span><span class="s2">&quot;:&quot;</span><span class="s0">;</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(F===</span><span class="s2">&quot;:&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(b===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(b=</span><span class="s1">null</span><span class="s0">),A===</span><span class="s2">&quot;:&quot;</span><span class="s0">){A=</span><span class="s2">&quot;,&quot;</span><span class="s0">;</span><span class="s1">continue</span><span class="s0">}}</span><span class="s1">else if</span><span class="s0">(w&amp;&amp;(b===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;F!==</span><span class="s2">&quot;,&quot;</span><span class="s0">&amp;&amp;(b=</span><span class="s1">null</span><span class="s0">),w=!</span><span class="s3">1</span><span class="s0">),b!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(v.push(</span><span class="s1">new </span><span class="s0">C(b)),b=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,F===</span><span class="s2">&quot;,&quot;</span><span class="s0">)){A=</span><span class="s2">&quot;:&quot;</span><span class="s0">;</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(F===</span><span class="s2">&quot;}&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(N===l.items.length-1)</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(F===A){A=</span><span class="s2">&quot;:&quot;</span><span class="s0">;</span><span class="s1">continue</span><span class="s0">}let H=`Flow map contains an unexpected ${F}`,oe=</span><span class="s1">new </span><span class="s0">e.YAMLSyntaxError(l,H);oe.offset=Q,o.errors.push(oe)}</span><span class="s1">else </span><span class="s0">j.type===e.Type.BLANK_LINE?_.push({afterKey:!!b,before:v.length}):j.type===e.Type.COMMENT?(G(o.errors,j),_.push({afterKey:!!b,before:v.length,comment:j.comment})):b===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?(A===</span><span class="s2">&quot;,&quot;</span><span class="s0">&amp;&amp;o.errors.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(j,</span><span class="s2">&quot;Separator , missing in flow map&quot;</span><span class="s0">)),b=we(o,j)):(A!==</span><span class="s2">&quot;,&quot;</span><span class="s0">&amp;&amp;o.errors.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(j,</span><span class="s2">&quot;Indicator : missing in flow map entry&quot;</span><span class="s0">)),v.push(</span><span class="s1">new </span><span class="s0">C(b,we(o,j))),b=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,w=!</span><span class="s3">1</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">x(o.errors,l),b!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;v.push(</span><span class="s1">new </span><span class="s0">C(b)),{comments:_,items:v}}</span><span class="s1">function </span><span class="s0">pt(o,l){</span><span class="s1">if</span><span class="s0">(l.type!==e.Type.SEQ&amp;&amp;l.type!==e.Type.FLOW_SEQ){let w=`A ${l.type} node cannot be resolved as a sequence`;</span><span class="s1">return </span><span class="s0">o.errors.push(</span><span class="s1">new </span><span class="s0">e.YAMLSyntaxError(l,w)),</span><span class="s1">null</span><span class="s0">}let{comments:_,items:v}=l.type===e.Type.FLOW_SEQ?vt(o,l):_t(o,l),b=</span><span class="s1">new </span><span class="s0">T;</span><span class="s1">if</span><span class="s0">(b.items=v,_e(b,_),!o.options.mapAsMap&amp;&amp;v.some(w=&gt;w </span><span class="s1">instanceof </span><span class="s0">C&amp;&amp;w.key </span><span class="s1">instanceof </span><span class="s0">S)){let w=</span><span class="s2">&quot;Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.&quot;</span><span class="s0">;o.warnings.push(</span><span class="s1">new </span><span class="s0">e.YAMLWarning(l,w))}</span><span class="s1">return </span><span class="s0">l.resolved=b,b}</span><span class="s1">function </span><span class="s0">_t(o,l){let _=[],v=[];</span><span class="s1">for</span><span class="s0">(let b=</span><span class="s3">0</span><span class="s0">;b&lt;l.items.length;++b){let w=l.items[b];</span><span class="s1">switch</span><span class="s0">(w.type){</span><span class="s1">case </span><span class="s0">e.Type.BLANK_LINE:_.push({before:v.length});</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">e.Type.COMMENT:_.push({comment:w.comment,before:v.length});</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">e.Type.SEQ_ITEM:</span><span class="s1">if</span><span class="s0">(w.error&amp;&amp;o.errors.push(w.error),v.push(we(o,w.node)),w.hasProps){let A=</span><span class="s2">&quot;Sequence items cannot have tags or anchors before the - indicator&quot;</span><span class="s0">;o.errors.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(w,A))}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:w.error&amp;&amp;o.errors.push(w.error),o.errors.push(</span><span class="s1">new </span><span class="s0">e.YAMLSyntaxError(w,`Unexpected ${w.type} node </span><span class="s1">in </span><span class="s0">sequence`))}}</span><span class="s1">return</span><span class="s0">{comments:_,items:v}}</span><span class="s1">function </span><span class="s0">vt(o,l){let _=[],v=[],b=!</span><span class="s3">1</span><span class="s0">,w,A=</span><span class="s1">null</span><span class="s0">,N=</span><span class="s2">&quot;[&quot;</span><span class="s0">,j=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let F=</span><span class="s3">0</span><span class="s0">;F&lt;l.items.length;++F){let Q=l.items[F];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Q.char==</span><span class="s2">&quot;string&quot;</span><span class="s0">){let{char:H,offset:oe}=Q;</span><span class="s1">if</span><span class="s0">(H!==</span><span class="s2">&quot;:&quot;</span><span class="s0">&amp;&amp;(b||w!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)&amp;&amp;(b&amp;&amp;w===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(w=N?v.pop():</span><span class="s1">null</span><span class="s0">),v.push(</span><span class="s1">new </span><span class="s0">C(w)),b=!</span><span class="s3">1</span><span class="s0">,w=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,A=</span><span class="s1">null</span><span class="s0">),H===N)N=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(!N&amp;&amp;H===</span><span class="s2">&quot;?&quot;</span><span class="s0">)b=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(N!==</span><span class="s2">&quot;[&quot;</span><span class="s0">&amp;&amp;H===</span><span class="s2">&quot;:&quot;</span><span class="s0">&amp;&amp;w===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(N===</span><span class="s2">&quot;,&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(w=v.pop(),w </span><span class="s1">instanceof </span><span class="s0">C){let le=</span><span class="s2">&quot;Chaining flow sequence pairs is invalid&quot;</span><span class="s0">,Z=</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(l,le);Z.offset=oe,o.errors.push(Z)}</span><span class="s1">if</span><span class="s0">(!b&amp;&amp;</span><span class="s1">typeof </span><span class="s0">A==</span><span class="s2">&quot;number&quot;</span><span class="s0">){let le=Q.range?Q.range.start:Q.offset;le&gt;A+</span><span class="s3">1024</span><span class="s0">&amp;&amp;o.errors.push(re(l,w));let{src:Z}=j.context;</span><span class="s1">for</span><span class="s0">(let ee=A;ee&lt;le;++ee)</span><span class="s1">if</span><span class="s0">(Z[ee]===`</span>
<span class="s0">`){let X=</span><span class="s2">&quot;Implicit keys of flow sequence pairs need to be on a single line&quot;</span><span class="s0">;o.errors.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(j,X));</span><span class="s1">break</span><span class="s0">}}}</span><span class="s1">else </span><span class="s0">w=</span><span class="s1">null</span><span class="s0">;A=</span><span class="s1">null</span><span class="s0">,b=!</span><span class="s3">1</span><span class="s0">,N=</span><span class="s1">null</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(N===</span><span class="s2">&quot;[&quot;</span><span class="s0">||H!==</span><span class="s2">&quot;]&quot;</span><span class="s0">||F&lt;l.items.length-1){let le=`Flow sequence contains an unexpected ${H}`,Z=</span><span class="s1">new </span><span class="s0">e.YAMLSyntaxError(l,le);Z.offset=oe,o.errors.push(Z)}}</span><span class="s1">else if</span><span class="s0">(Q.type===e.Type.BLANK_LINE)_.push({before:v.length});</span><span class="s1">else if</span><span class="s0">(Q.type===e.Type.COMMENT)G(o.errors,Q),_.push({comment:Q.comment,before:v.length});</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(N){let oe=`Expected a ${N} </span><span class="s1">in </span><span class="s0">flow sequence`;o.errors.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(Q,oe))}let H=we(o,Q);w===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?(v.push(H),j=Q):(v.push(</span><span class="s1">new </span><span class="s0">C(w,H)),w=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),A=Q.range.start,N=</span><span class="s2">&quot;,&quot;</span><span class="s0">}}</span><span class="s1">return </span><span class="s0">x(o.errors,l),w!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;v.push(</span><span class="s1">new </span><span class="s0">C(w)),{comments:_,items:v}}n.Alias=R,n.Collection=S,n.Merge=i,n.Node=h,n.Pair=C,n.Scalar=y,n.YAMLMap=U,n.YAMLSeq=T,n.addComment=c,n.binaryOptions=t,n.boolOptions=s,n.findPair=B,n.intOptions=a,n.isEmptyPath=I,n.nullOptions=m,n.resolveMap=ft,n.resolveNode=we,n.resolveSeq=pt,n.resolveString=ye,n.strOptions=g,n.stringifyNumber=J,n.stringifyString=W,n.toJSON=d}}),st=D({</span><span class="s2">&quot;node_modules/yaml/dist/warnings-1000a372.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y();</span><span class="s1">var </span><span class="s0">e=Me(),r=ke(),c={identify:u=&gt;u </span><span class="s1">instanceof </span><span class="s0">Uint8Array,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:binary&quot;</span><span class="s0">,resolve:(u,p)=&gt;{let L=r.resolveString(u,p);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Buffer==</span><span class="s2">&quot;function&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">Buffer.from(L,</span><span class="s2">&quot;base64&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">atob==</span><span class="s2">&quot;function&quot;</span><span class="s0">){let k=atob(L.replace(/[\n\r]/g,</span><span class="s2">&quot;&quot;</span><span class="s0">)),$=</span><span class="s1">new </span><span class="s0">Uint8Array(k.length);</span><span class="s1">for</span><span class="s0">(let K=</span><span class="s3">0</span><span class="s0">;K&lt;k.length;++K)$[K]=k.charCodeAt(K);</span><span class="s1">return </span><span class="s0">$}</span><span class="s1">else</span><span class="s0">{let k=</span><span class="s2">&quot;This environment does not support reading binary tags; either Buffer or atob is required&quot;</span><span class="s0">;</span><span class="s1">return </span><span class="s0">u.errors.push(</span><span class="s1">new </span><span class="s0">e.YAMLReferenceError(p,k)),</span><span class="s1">null</span><span class="s0">}},options:r.binaryOptions,stringify:(u,p,L,k)=&gt;{let{comment:$,type:K,value:V}=u,z;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Buffer==</span><span class="s2">&quot;function&quot;</span><span class="s0">)z=V </span><span class="s1">instanceof </span><span class="s0">Buffer?V.toString(</span><span class="s2">&quot;base64&quot;</span><span class="s0">):Buffer.from(V.buffer).toString(</span><span class="s2">&quot;base64&quot;</span><span class="s0">);</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">btoa==</span><span class="s2">&quot;function&quot;</span><span class="s0">){let ae=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let ue=</span><span class="s3">0</span><span class="s0">;ue&lt;V.length;++ue)ae+=String.fromCharCode(V[ue]);z=btoa(ae)}</span><span class="s1">else throw new </span><span class="s0">Error(</span><span class="s2">&quot;This environment does not support writing binary tags; either Buffer or btoa is required&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(K||(K=r.binaryOptions.defaultType),K===e.Type.QUOTE_DOUBLE)V=z;</span><span class="s1">else</span><span class="s0">{let{lineWidth:ae}=r.binaryOptions,ue=Math.ceil(z.length/ae),pe=</span><span class="s1">new </span><span class="s0">Array(ue);</span><span class="s1">for</span><span class="s0">(let ge=</span><span class="s3">0</span><span class="s0">,O=</span><span class="s3">0</span><span class="s0">;ge&lt;ue;++ge,O+=ae)pe[ge]=z.substr(O,ae);V=pe.join(K===e.Type.BLOCK_LITERAL?`</span>
<span class="s0">`:</span><span class="s2">&quot; &quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">r.stringifyString({comment:$,type:K,value:V},p,L,k)}};</span><span class="s1">function </span><span class="s0">h(u,p){let L=r.resolveSeq(u,p);</span><span class="s1">for</span><span class="s0">(let k=</span><span class="s3">0</span><span class="s0">;k&lt;L.items.length;++k){let $=L.items[k];</span><span class="s1">if</span><span class="s0">(!($ </span><span class="s1">instanceof </span><span class="s0">r.Pair)){</span><span class="s1">if</span><span class="s0">($ </span><span class="s1">instanceof </span><span class="s0">r.YAMLMap){</span><span class="s1">if</span><span class="s0">($.items.length&gt;</span><span class="s3">1</span><span class="s0">){let V=</span><span class="s2">&quot;Each pair must have its own sequence indicator&quot;</span><span class="s0">;</span><span class="s1">throw new </span><span class="s0">e.YAMLSemanticError(p,V)}let K=$.items[</span><span class="s3">0</span><span class="s0">]||</span><span class="s1">new </span><span class="s0">r.Pair;$.commentBefore&amp;&amp;(K.commentBefore=K.commentBefore?`${$.commentBefore}</span>
<span class="s0">${K.commentBefore}`:$.commentBefore),$.comment&amp;&amp;(K.comment=K.comment?`${$.comment}</span>
<span class="s0">${K.comment}`:$.comment),$=K}L.items[k]=$ </span><span class="s1">instanceof </span><span class="s0">r.Pair?$:</span><span class="s1">new </span><span class="s0">r.Pair($)}}</span><span class="s1">return </span><span class="s0">L}</span><span class="s1">function </span><span class="s0">d(u,p,L){let k=</span><span class="s1">new </span><span class="s0">r.YAMLSeq(u);k.tag=</span><span class="s2">&quot;tag:yaml.org,2002:pairs&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let $ of p){let K,V;</span><span class="s1">if</span><span class="s0">(Array.isArray($))</span><span class="s1">if</span><span class="s0">($.length===</span><span class="s3">2</span><span class="s0">)K=$[</span><span class="s3">0</span><span class="s0">],V=$[</span><span class="s3">1</span><span class="s0">];</span><span class="s1">else throw new </span><span class="s0">TypeError(`Expected [key, value] tuple: ${$}`);</span><span class="s1">else if</span><span class="s0">($&amp;&amp;$ </span><span class="s1">instanceof </span><span class="s0">Object){let ae=Object.keys($);</span><span class="s1">if</span><span class="s0">(ae.length===</span><span class="s3">1</span><span class="s0">)K=ae[</span><span class="s3">0</span><span class="s0">],V=$[K];</span><span class="s1">else throw new </span><span class="s0">TypeError(`Expected { key: value } tuple: ${$}`)}</span><span class="s1">else </span><span class="s0">K=$;let z=u.createPair(K,V,L);k.items.push(z)}</span><span class="s1">return </span><span class="s0">k}</span><span class="s1">var </span><span class="s0">y={</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:pairs&quot;</span><span class="s0">,resolve:h,createNode:d},E=class extends r.YAMLSeq{constructor(){super(),e._defineProperty(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;add&quot;</span><span class="s0">,r.YAMLMap.prototype.add.bind(</span><span class="s1">this</span><span class="s0">)),e._defineProperty(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;delete&quot;</span><span class="s0">,r.YAMLMap.prototype.</span><span class="s1">delete</span><span class="s0">.bind(</span><span class="s1">this</span><span class="s0">)),e._defineProperty(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;get&quot;</span><span class="s0">,r.YAMLMap.prototype.get.bind(</span><span class="s1">this</span><span class="s0">)),e._defineProperty(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;has&quot;</span><span class="s0">,r.YAMLMap.prototype.has.bind(</span><span class="s1">this</span><span class="s0">)),e._defineProperty(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;set&quot;</span><span class="s0">,r.YAMLMap.prototype.set.bind(</span><span class="s1">this</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.tag=E.tag}toJSON(u,p){let L=</span><span class="s1">new </span><span class="s0">Map;p&amp;&amp;p.onCreate&amp;&amp;p.onCreate(L);</span><span class="s1">for</span><span class="s0">(let k of </span><span class="s1">this</span><span class="s0">.items){let $,K;</span><span class="s1">if</span><span class="s0">(k </span><span class="s1">instanceof </span><span class="s0">r.Pair?($=r.toJSON(k.key,</span><span class="s2">&quot;&quot;</span><span class="s0">,p),K=r.toJSON(k.value,$,p)):$=r.toJSON(k,</span><span class="s2">&quot;&quot;</span><span class="s0">,p),L.has($))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Ordered maps must not include duplicate keys&quot;</span><span class="s0">);L.set($,K)}</span><span class="s1">return </span><span class="s0">L}};e._defineProperty(E,</span><span class="s2">&quot;tag&quot;</span><span class="s0">,</span><span class="s2">&quot;tag:yaml.org,2002:omap&quot;</span><span class="s0">);</span><span class="s1">function </span><span class="s0">I(u,p){let L=h(u,p),k=[];</span><span class="s1">for</span><span class="s0">(let{key:$}of L.items)</span><span class="s1">if</span><span class="s0">($ </span><span class="s1">instanceof </span><span class="s0">r.Scalar)</span><span class="s1">if</span><span class="s0">(k.includes($.value)){let K=</span><span class="s2">&quot;Ordered maps must not include duplicate keys&quot;</span><span class="s0">;</span><span class="s1">throw new </span><span class="s0">e.YAMLSemanticError(p,K)}</span><span class="s1">else </span><span class="s0">k.push($.value);</span><span class="s1">return </span><span class="s0">Object.assign(</span><span class="s1">new </span><span class="s0">E,L)}</span><span class="s1">function </span><span class="s0">S(u,p,L){let k=d(u,p,L),$=</span><span class="s1">new </span><span class="s0">E;</span><span class="s1">return </span><span class="s0">$.items=k.items,$}</span><span class="s1">var </span><span class="s0">M={identify:u=&gt;u </span><span class="s1">instanceof </span><span class="s0">Map,nodeClass:E,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:omap&quot;</span><span class="s0">,resolve:I,createNode:S},T=class extends r.YAMLMap{constructor(){super(),</span><span class="s1">this</span><span class="s0">.tag=T.tag}add(u){let p=u </span><span class="s1">instanceof </span><span class="s0">r.Pair?u:</span><span class="s1">new </span><span class="s0">r.Pair(u);r.findPair(</span><span class="s1">this</span><span class="s0">.items,p.key)||</span><span class="s1">this</span><span class="s0">.items.push(p)}get(u,p){let L=r.findPair(</span><span class="s1">this</span><span class="s0">.items,u);</span><span class="s1">return</span><span class="s0">!p&amp;&amp;L </span><span class="s1">instanceof </span><span class="s0">r.Pair?L.key </span><span class="s1">instanceof </span><span class="s0">r.Scalar?L.key.value:L.key:L}set(u,p){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">p!=</span><span class="s2">&quot;boolean&quot;</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(`Expected boolean value </span><span class="s1">for </span><span class="s0">set(key, value) </span><span class="s1">in </span><span class="s0">a YAML set, not ${</span><span class="s1">typeof </span><span class="s0">p}`);let L=r.findPair(</span><span class="s1">this</span><span class="s0">.items,u);L&amp;&amp;!p?</span><span class="s1">this</span><span class="s0">.items.splice(</span><span class="s1">this</span><span class="s0">.items.indexOf(L),</span><span class="s3">1</span><span class="s0">):!L&amp;&amp;p&amp;&amp;</span><span class="s1">this</span><span class="s0">.items.push(</span><span class="s1">new </span><span class="s0">r.Pair(u))}toJSON(u,p){</span><span class="s1">return </span><span class="s0">super.toJSON(u,p,Set)}toString(u,p,L){</span><span class="s1">if</span><span class="s0">(!u)</span><span class="s1">return </span><span class="s0">JSON.stringify(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasAllNullValues())</span><span class="s1">return </span><span class="s0">super.toString(u,p,L);</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Set items must all have null values&quot;</span><span class="s0">)}};e._defineProperty(T,</span><span class="s2">&quot;tag&quot;</span><span class="s0">,</span><span class="s2">&quot;tag:yaml.org,2002:set&quot;</span><span class="s0">);</span><span class="s1">function </span><span class="s0">P(u,p){let L=r.resolveMap(u,p);</span><span class="s1">if</span><span class="s0">(!L.hasAllNullValues())</span><span class="s1">throw new </span><span class="s0">e.YAMLSemanticError(p,</span><span class="s2">&quot;Set items must all have null values&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">Object.assign(</span><span class="s1">new </span><span class="s0">T,L)}</span><span class="s1">function </span><span class="s0">C(u,p,L){let k=</span><span class="s1">new </span><span class="s0">T;</span><span class="s1">for</span><span class="s0">(let $ of p)k.items.push(u.createPair($,</span><span class="s1">null</span><span class="s0">,L));</span><span class="s1">return </span><span class="s0">k}</span><span class="s1">var </span><span class="s0">q={identify:u=&gt;u </span><span class="s1">instanceof </span><span class="s0">Set,nodeClass:T,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:set&quot;</span><span class="s0">,resolve:P,createNode:C},R=(u,p)=&gt;{let L=p.split(</span><span class="s2">&quot;:&quot;</span><span class="s0">).reduce((k,$)=&gt;k*</span><span class="s3">60</span><span class="s0">+Number($),</span><span class="s3">0</span><span class="s0">);</span><span class="s1">return </span><span class="s0">u===</span><span class="s2">&quot;-&quot;</span><span class="s0">?-L:L},B=u=&gt;{let{value:p}=u;</span><span class="s1">if</span><span class="s0">(isNaN(p)||!isFinite(p))</span><span class="s1">return </span><span class="s0">r.stringifyNumber(p);let L=</span><span class="s2">&quot;&quot;</span><span class="s0">;p&lt;</span><span class="s3">0</span><span class="s0">&amp;&amp;(L=</span><span class="s2">&quot;-&quot;</span><span class="s0">,p=Math.abs(p));let k=[p%</span><span class="s3">60</span><span class="s0">];</span><span class="s1">return </span><span class="s0">p&lt;</span><span class="s3">60</span><span class="s0">?k.unshift(</span><span class="s3">0</span><span class="s0">):(p=Math.round((p-k[</span><span class="s3">0</span><span class="s0">])/</span><span class="s3">60</span><span class="s0">),k.unshift(p%</span><span class="s3">60</span><span class="s0">),p&gt;=</span><span class="s3">60</span><span class="s0">&amp;&amp;(p=Math.round((p-k[</span><span class="s3">0</span><span class="s0">])/</span><span class="s3">60</span><span class="s0">),k.unshift(p))),L+k.map($=&gt;$&lt;</span><span class="s3">10</span><span class="s0">?</span><span class="s2">&quot;0&quot;</span><span class="s0">+String($):String($)).join(</span><span class="s2">&quot;:&quot;</span><span class="s0">).replace(/</span><span class="s3">000000</span><span class="s0">\d*$/,</span><span class="s2">&quot;&quot;</span><span class="s0">)},U={identify:u=&gt;</span><span class="s1">typeof </span><span class="s0">u==</span><span class="s2">&quot;number&quot;</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:int&quot;</span><span class="s0">,format:</span><span class="s2">&quot;TIME&quot;</span><span class="s0">,test:/^([-+]?)([</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">][</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">_]*(?::[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">5</span><span class="s0">]?[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">])+)$/,resolve:(u,p,L)=&gt;R(p,L.replace(/_/g,</span><span class="s2">&quot;&quot;</span><span class="s0">)),stringify:B},f={identify:u=&gt;</span><span class="s1">typeof </span><span class="s0">u==</span><span class="s2">&quot;number&quot;</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:float&quot;</span><span class="s0">,format:</span><span class="s2">&quot;TIME&quot;</span><span class="s0">,test:/^([-+]?)([</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">][</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">_]*(?::[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">5</span><span class="s0">]?[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">])+\.[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">_]*)$/,resolve:(u,p,L)=&gt;R(p,L.replace(/_/g,</span><span class="s2">&quot;&quot;</span><span class="s0">)),stringify:B},i={identify:u=&gt;u </span><span class="s1">instanceof </span><span class="s0">Date,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:timestamp&quot;</span><span class="s0">,test:RegExp(</span><span class="s2">&quot;^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ </span><span class="s4">\\</span><span class="s2">t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(</span><span class="s4">\\</span><span class="s2">.[0-9]+)?)(?:[ </span><span class="s4">\\</span><span class="s2">t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$&quot;</span><span class="s0">),resolve:(u,p,L,k,$,K,V,z,ae)=&gt;{z&amp;&amp;(z=(z+</span><span class="s2">&quot;00&quot;</span><span class="s0">).substr(</span><span class="s3">1</span><span class="s0">,</span><span class="s3">3</span><span class="s0">));let ue=Date.UTC(p,L-1,k,$||</span><span class="s3">0</span><span class="s0">,K||</span><span class="s3">0</span><span class="s0">,V||</span><span class="s3">0</span><span class="s0">,z||</span><span class="s3">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(ae&amp;&amp;ae!==</span><span class="s2">&quot;Z&quot;</span><span class="s0">){let pe=R(ae[</span><span class="s3">0</span><span class="s0">],ae.slice(</span><span class="s3">1</span><span class="s0">));Math.abs(pe)&lt;</span><span class="s3">30</span><span class="s0">&amp;&amp;(pe*=</span><span class="s3">60</span><span class="s0">),ue-=</span><span class="s3">6</span><span class="s0">e4*pe}</span><span class="s1">return new </span><span class="s0">Date(ue)},stringify:u=&gt;{let{value:p}=u;</span><span class="s1">return </span><span class="s0">p.toISOString().replace(/((T00:</span><span class="s3">00</span><span class="s0">)?:</span><span class="s3">00</span><span class="s0">)?\.</span><span class="s3">000</span><span class="s0">Z$/,</span><span class="s2">&quot;&quot;</span><span class="s0">)}};</span><span class="s1">function </span><span class="s0">t(u){let p=</span><span class="s1">typeof </span><span class="s0">Te&lt;</span><span class="s2">&quot;u&quot;</span><span class="s0">&amp;&amp;Te.env||{};</span><span class="s1">return </span><span class="s0">u?</span><span class="s1">typeof </span><span class="s0">YAML_SILENCE_DEPRECATION_WARNINGS&lt;</span><span class="s2">&quot;u&quot;</span><span class="s0">?!YAML_SILENCE_DEPRECATION_WARNINGS:!p.YAML_SILENCE_DEPRECATION_WARNINGS:</span><span class="s1">typeof </span><span class="s0">YAML_SILENCE_WARNINGS&lt;</span><span class="s2">&quot;u&quot;</span><span class="s0">?!YAML_SILENCE_WARNINGS:!p.YAML_SILENCE_WARNINGS}</span><span class="s1">function </span><span class="s0">s(u,p){</span><span class="s1">if</span><span class="s0">(t(!</span><span class="s3">1</span><span class="s0">)){let L=</span><span class="s1">typeof </span><span class="s0">Te&lt;</span><span class="s2">&quot;u&quot;</span><span class="s0">&amp;&amp;Te.emitWarning;L?L(u,p):console.warn(p?`${p}: ${u}`:u)}}</span><span class="s1">function </span><span class="s0">a(u){</span><span class="s1">if</span><span class="s0">(t(!</span><span class="s3">0</span><span class="s0">)){let p=u.replace(/.*yaml[/\\]/i,</span><span class="s2">&quot;&quot;</span><span class="s0">).replace(/\.js$/,</span><span class="s2">&quot;&quot;</span><span class="s0">).replace(/\\/g,</span><span class="s2">&quot;/&quot;</span><span class="s0">);s(`The endpoint </span><span class="s2">'yaml/${p}' </span><span class="s0">will be removed </span><span class="s1">in </span><span class="s0">a future release.`,</span><span class="s2">&quot;DeprecationWarning&quot;</span><span class="s0">)}}</span><span class="s1">var </span><span class="s0">m={};</span><span class="s1">function </span><span class="s0">g(u,p){</span><span class="s1">if</span><span class="s0">(!m[u]&amp;&amp;t(!</span><span class="s3">0</span><span class="s0">)){m[u]=!</span><span class="s3">0</span><span class="s0">;let L=`The option </span><span class="s2">'${u}' </span><span class="s0">will be removed </span><span class="s1">in </span><span class="s0">a future release`;L+=p?`, use </span><span class="s2">'${p}' </span><span class="s0">instead.`:</span><span class="s2">&quot;.&quot;</span><span class="s0">,s(L,</span><span class="s2">&quot;DeprecationWarning&quot;</span><span class="s0">)}}n.binary=c,n.floatTime=f,n.intTime=U,n.omap=M,n.pairs=y,n.set=q,n.timestamp=i,n.warn=s,n.warnFileDeprecation=a,n.warnOptionDeprecation=g}}),it=D({</span><span class="s2">&quot;node_modules/yaml/dist/Schema-88e323a7.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y();</span><span class="s1">var </span><span class="s0">e=Me(),r=ke(),c=st();</span><span class="s1">function </span><span class="s0">h(O,W,J){let x=</span><span class="s1">new </span><span class="s0">r.YAMLMap(O);</span><span class="s1">if</span><span class="s0">(W </span><span class="s1">instanceof </span><span class="s0">Map)</span><span class="s1">for</span><span class="s0">(let[G,re]of W)x.items.push(O.createPair(G,re,J));</span><span class="s1">else if</span><span class="s0">(W&amp;&amp;</span><span class="s1">typeof </span><span class="s0">W==</span><span class="s2">&quot;object&quot;</span><span class="s0">)</span><span class="s1">for</span><span class="s0">(let G of Object.keys(W))x.items.push(O.createPair(G,W[G],J));</span><span class="s1">return typeof </span><span class="s0">O.sortMapEntries==</span><span class="s2">&quot;function&quot;</span><span class="s0">&amp;&amp;x.items.sort(O.sortMapEntries),x}</span><span class="s1">var </span><span class="s0">d={createNode:h,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,nodeClass:r.YAMLMap,tag:</span><span class="s2">&quot;tag:yaml.org,2002:map&quot;</span><span class="s0">,resolve:r.resolveMap};</span><span class="s1">function </span><span class="s0">y(O,W,J){let x=</span><span class="s1">new </span><span class="s0">r.YAMLSeq(O);</span><span class="s1">if</span><span class="s0">(W&amp;&amp;W[Symbol.iterator])</span><span class="s1">for</span><span class="s0">(let G of W){let re=O.createNode(G,J.wrapScalars,</span><span class="s1">null</span><span class="s0">,J);x.items.push(re)}</span><span class="s1">return </span><span class="s0">x}</span><span class="s1">var </span><span class="s0">E={createNode:y,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,nodeClass:r.YAMLSeq,tag:</span><span class="s2">&quot;tag:yaml.org,2002:seq&quot;</span><span class="s0">,resolve:r.resolveSeq},I={identify:O=&gt;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;string&quot;</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:str&quot;</span><span class="s0">,resolve:r.resolveString,stringify(O,W,J,x){</span><span class="s1">return </span><span class="s0">W=Object.assign({actualString:!</span><span class="s3">0</span><span class="s0">},W),r.stringifyString(O,W,J,x)},options:r.strOptions},S=[d,E,I],M=O=&gt;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;bigint&quot;</span><span class="s0">||Number.isInteger(O),T=(O,W,J)=&gt;r.intOptions.asBigInt?BigInt(O):parseInt(W,J);</span><span class="s1">function </span><span class="s0">P(O,W,J){let{value:x}=O;</span><span class="s1">return </span><span class="s0">M(x)&amp;&amp;x&gt;=</span><span class="s3">0</span><span class="s0">?J+x.toString(W):r.stringifyNumber(O)}</span><span class="s1">var </span><span class="s0">C={identify:O=&gt;O==</span><span class="s1">null</span><span class="s0">,createNode:(O,W,J)=&gt;J.wrapScalars?</span><span class="s1">new </span><span class="s0">r.Scalar(</span><span class="s1">null</span><span class="s0">):</span><span class="s1">null</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:null&quot;</span><span class="s0">,test:/^(?:~|[Nn]ull|NULL)?$/,resolve:()=&gt;</span><span class="s1">null</span><span class="s0">,options:r.nullOptions,stringify:()=&gt;r.nullOptions.nullStr},q={identify:O=&gt;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;boolean&quot;</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:bool&quot;</span><span class="s0">,test:/^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,resolve:O=&gt;O[</span><span class="s3">0</span><span class="s0">]===</span><span class="s2">&quot;t&quot;</span><span class="s0">||O[</span><span class="s3">0</span><span class="s0">]===</span><span class="s2">&quot;T&quot;</span><span class="s0">,options:r.boolOptions,stringify:O=&gt;{let{value:W}=O;</span><span class="s1">return </span><span class="s0">W?r.boolOptions.trueStr:r.boolOptions.falseStr}},R={identify:O=&gt;M(O)&amp;&amp;O&gt;=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:int&quot;</span><span class="s0">,format:</span><span class="s2">&quot;OCT&quot;</span><span class="s0">,test:/^</span><span class="s3">0</span><span class="s0">o([</span><span class="s3">0</span><span class="s0">-</span><span class="s3">7</span><span class="s0">]+)$/,resolve:(O,W)=&gt;T(O,W,</span><span class="s3">8</span><span class="s0">),options:r.intOptions,stringify:O=&gt;P(O,</span><span class="s3">8</span><span class="s0">,</span><span class="s2">&quot;0o&quot;</span><span class="s0">)},B={identify:M,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:int&quot;</span><span class="s0">,test:/^[-+]?[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]+$/,resolve:O=&gt;T(O,O,</span><span class="s3">10</span><span class="s0">),options:r.intOptions,stringify:r.stringifyNumber},U={identify:O=&gt;M(O)&amp;&amp;O&gt;=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:int&quot;</span><span class="s0">,format:</span><span class="s2">&quot;HEX&quot;</span><span class="s0">,test:/^</span><span class="s3">0</span><span class="s0">x([</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">a-fA-F]+)$/,resolve:(O,W)=&gt;T(O,W,</span><span class="s3">16</span><span class="s0">),options:r.intOptions,stringify:O=&gt;P(O,</span><span class="s3">16</span><span class="s0">,</span><span class="s2">&quot;0x&quot;</span><span class="s0">)},f={identify:O=&gt;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;number&quot;</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:float&quot;</span><span class="s0">,test:/^(?:[-+]?\.inf|(\.nan))$/i,resolve:(O,W)=&gt;W?NaN:O[</span><span class="s3">0</span><span class="s0">]===</span><span class="s2">&quot;-&quot;</span><span class="s0">?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,stringify:r.stringifyNumber},i={identify:O=&gt;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;number&quot;</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:float&quot;</span><span class="s0">,format:</span><span class="s2">&quot;EXP&quot;</span><span class="s0">,test:/^[-+]?(?:\.[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]+|[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]+(?:\.[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]*)?)[eE][-+]?[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]+$/,resolve:O=&gt;parseFloat(O),stringify:O=&gt;{let{value:W}=O;</span><span class="s1">return </span><span class="s0">Number(W).toExponential()}},t={identify:O=&gt;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;number&quot;</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:float&quot;</span><span class="s0">,test:/^[-+]?(?:\.([</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]+)|[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]+\.([</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]*))$/,resolve(O,W,J){let x=W||J,G=</span><span class="s1">new </span><span class="s0">r.Scalar(parseFloat(O));</span><span class="s1">return </span><span class="s0">x&amp;&amp;x[x.length-1]===</span><span class="s2">&quot;0&quot;</span><span class="s0">&amp;&amp;(G.minFractionDigits=x.length),G},stringify:r.stringifyNumber},s=S.concat([C,q,R,B,U,f,i,t]),a=O=&gt;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;bigint&quot;</span><span class="s0">||Number.isInteger(O),m=O=&gt;{let{value:W}=O;</span><span class="s1">return </span><span class="s0">JSON.stringify(W)},g=[d,E,{identify:O=&gt;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;string&quot;</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:str&quot;</span><span class="s0">,resolve:r.resolveString,stringify:m},{identify:O=&gt;O==</span><span class="s1">null</span><span class="s0">,createNode:(O,W,J)=&gt;J.wrapScalars?</span><span class="s1">new </span><span class="s0">r.Scalar(</span><span class="s1">null</span><span class="s0">):</span><span class="s1">null</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:null&quot;</span><span class="s0">,test:/^null$/,resolve:()=&gt;</span><span class="s1">null</span><span class="s0">,stringify:m},{identify:O=&gt;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;boolean&quot;</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:bool&quot;</span><span class="s0">,test:/^</span><span class="s1">true</span><span class="s0">|false$/,resolve:O=&gt;O===</span><span class="s2">&quot;true&quot;</span><span class="s0">,stringify:m},{identify:a,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:int&quot;</span><span class="s0">,test:/^-?(?:</span><span class="s3">0</span><span class="s0">|[</span><span class="s3">1</span><span class="s0">-</span><span class="s3">9</span><span class="s0">][</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]*)$/,resolve:O=&gt;r.intOptions.asBigInt?BigInt(O):parseInt(O,</span><span class="s3">10</span><span class="s0">),stringify:O=&gt;{let{value:W}=O;</span><span class="s1">return </span><span class="s0">a(W)?W.toString():JSON.stringify(W)}},{identify:O=&gt;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;number&quot;</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:float&quot;</span><span class="s0">,test:/^-?(?:</span><span class="s3">0</span><span class="s0">|[</span><span class="s3">1</span><span class="s0">-</span><span class="s3">9</span><span class="s0">][</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]*)(?:\.[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]*)?(?:[eE][-+]?[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]+)?$/,resolve:O=&gt;parseFloat(O),stringify:m}];g.scalarFallback=O=&gt;{</span><span class="s1">throw new </span><span class="s0">SyntaxError(`Unresolved plain scalar ${JSON.stringify(O)}`)};</span><span class="s1">var </span><span class="s0">u=O=&gt;{let{value:W}=O;</span><span class="s1">return </span><span class="s0">W?r.boolOptions.trueStr:r.boolOptions.falseStr},p=O=&gt;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;bigint&quot;</span><span class="s0">||Number.isInteger(O);</span><span class="s1">function </span><span class="s0">L(O,W,J){let x=W.replace(/_/g,</span><span class="s2">&quot;&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(r.intOptions.asBigInt){</span><span class="s1">switch</span><span class="s0">(J){</span><span class="s1">case </span><span class="s3">2</span><span class="s0">:x=`</span><span class="s3">0</span><span class="s0">b${x}`;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s3">8</span><span class="s0">:x=`</span><span class="s3">0</span><span class="s0">o${x}`;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s3">16</span><span class="s0">:x=`</span><span class="s3">0</span><span class="s0">x${x}`;</span><span class="s1">break</span><span class="s0">}let re=BigInt(x);</span><span class="s1">return </span><span class="s0">O===</span><span class="s2">&quot;-&quot;</span><span class="s0">?BigInt(-</span><span class="s3">1</span><span class="s0">)*re:re}let G=parseInt(x,J);</span><span class="s1">return </span><span class="s0">O===</span><span class="s2">&quot;-&quot;</span><span class="s0">?-</span><span class="s3">1</span><span class="s0">*G:G}</span><span class="s1">function </span><span class="s0">k(O,W,J){let{value:x}=O;</span><span class="s1">if</span><span class="s0">(p(x)){let G=x.toString(W);</span><span class="s1">return </span><span class="s0">x&lt;</span><span class="s3">0</span><span class="s0">?</span><span class="s2">&quot;-&quot;</span><span class="s0">+J+G.substr(</span><span class="s3">1</span><span class="s0">):J+G}</span><span class="s1">return </span><span class="s0">r.stringifyNumber(O)}</span><span class="s1">var </span><span class="s0">$=S.concat([{identify:O=&gt;O==</span><span class="s1">null</span><span class="s0">,createNode:(O,W,J)=&gt;J.wrapScalars?</span><span class="s1">new </span><span class="s0">r.Scalar(</span><span class="s1">null</span><span class="s0">):</span><span class="s1">null</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:null&quot;</span><span class="s0">,test:/^(?:~|[Nn]ull|NULL)?$/,resolve:()=&gt;</span><span class="s1">null</span><span class="s0">,options:r.nullOptions,stringify:()=&gt;r.nullOptions.nullStr},{identify:O=&gt;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;boolean&quot;</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:bool&quot;</span><span class="s0">,test:/^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,resolve:()=&gt;!</span><span class="s3">0</span><span class="s0">,options:r.boolOptions,stringify:u},{identify:O=&gt;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;boolean&quot;</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:bool&quot;</span><span class="s0">,test:/^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,resolve:()=&gt;!</span><span class="s3">1</span><span class="s0">,options:r.boolOptions,stringify:u},{identify:p,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:int&quot;</span><span class="s0">,format:</span><span class="s2">&quot;BIN&quot;</span><span class="s0">,test:/^([-+]?)</span><span class="s3">0</span><span class="s0">b([</span><span class="s3">0</span><span class="s0">-</span><span class="s3">1</span><span class="s0">_]+)$/,resolve:(O,W,J)=&gt;L(W,J,</span><span class="s3">2</span><span class="s0">),stringify:O=&gt;k(O,</span><span class="s3">2</span><span class="s0">,</span><span class="s2">&quot;0b&quot;</span><span class="s0">)},{identify:p,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:int&quot;</span><span class="s0">,format:</span><span class="s2">&quot;OCT&quot;</span><span class="s0">,test:/^([-+]?)</span><span class="s3">0</span><span class="s0">([</span><span class="s3">0</span><span class="s0">-</span><span class="s3">7</span><span class="s0">_]+)$/,resolve:(O,W,J)=&gt;L(W,J,</span><span class="s3">8</span><span class="s0">),stringify:O=&gt;k(O,</span><span class="s3">8</span><span class="s0">,</span><span class="s2">&quot;0&quot;</span><span class="s0">)},{identify:p,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:int&quot;</span><span class="s0">,test:/^([-+]?)([</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">][</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">_]*)$/,resolve:(O,W,J)=&gt;L(W,J,</span><span class="s3">10</span><span class="s0">),stringify:r.stringifyNumber},{identify:p,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:int&quot;</span><span class="s0">,format:</span><span class="s2">&quot;HEX&quot;</span><span class="s0">,test:/^([-+]?)</span><span class="s3">0</span><span class="s0">x([</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">a-fA-F_]+)$/,resolve:(O,W,J)=&gt;L(W,J,</span><span class="s3">16</span><span class="s0">),stringify:O=&gt;k(O,</span><span class="s3">16</span><span class="s0">,</span><span class="s2">&quot;0x&quot;</span><span class="s0">)},{identify:O=&gt;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;number&quot;</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:float&quot;</span><span class="s0">,test:/^(?:[-+]?\.inf|(\.nan))$/i,resolve:(O,W)=&gt;W?NaN:O[</span><span class="s3">0</span><span class="s0">]===</span><span class="s2">&quot;-&quot;</span><span class="s0">?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,stringify:r.stringifyNumber},{identify:O=&gt;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;number&quot;</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:float&quot;</span><span class="s0">,format:</span><span class="s2">&quot;EXP&quot;</span><span class="s0">,test:/^[-+]?([</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">][</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">_]*)?(\.[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">_]*)?[eE][-+]?[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]+$/,resolve:O=&gt;parseFloat(O.replace(/_/g,</span><span class="s2">&quot;&quot;</span><span class="s0">)),stringify:O=&gt;{let{value:W}=O;</span><span class="s1">return </span><span class="s0">Number(W).toExponential()}},{identify:O=&gt;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;number&quot;</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,tag:</span><span class="s2">&quot;tag:yaml.org,2002:float&quot;</span><span class="s0">,test:/^[-+]?(?:[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">][</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">_]*)?\.([</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">_]*)$/,resolve(O,W){let J=</span><span class="s1">new </span><span class="s0">r.Scalar(parseFloat(O.replace(/_/g,</span><span class="s2">&quot;&quot;</span><span class="s0">)));</span><span class="s1">if</span><span class="s0">(W){let x=W.replace(/_/g,</span><span class="s2">&quot;&quot;</span><span class="s0">);x[x.length-1]===</span><span class="s2">&quot;0&quot;</span><span class="s0">&amp;&amp;(J.minFractionDigits=x.length)}</span><span class="s1">return </span><span class="s0">J},stringify:r.stringifyNumber}],c.binary,c.omap,c.pairs,c.set,c.intTime,c.floatTime,c.timestamp),K={core:s,failsafe:S,json:g,yaml11:$},V={binary:c.binary,bool:q,float:t,floatExp:i,floatNaN:f,floatTime:c.floatTime,int:B,intHex:U,intOct:R,intTime:c.intTime,map:d,</span><span class="s1">null</span><span class="s0">:C,omap:c.omap,pairs:c.pairs,seq:E,set:c.set,timestamp:c.timestamp};</span><span class="s1">function </span><span class="s0">z(O,W,J){</span><span class="s1">if</span><span class="s0">(W){let x=J.filter(re=&gt;re.tag===W),G=x.find(re=&gt;!re.format)||x[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(!G)</span><span class="s1">throw new </span><span class="s0">Error(`Tag ${W} not found`);</span><span class="s1">return </span><span class="s0">G}</span><span class="s1">return </span><span class="s0">J.find(x=&gt;(x.identify&amp;&amp;x.identify(O)||x.class&amp;&amp;O </span><span class="s1">instanceof </span><span class="s0">x.class)&amp;&amp;!x.format)}</span><span class="s1">function </span><span class="s0">ae(O,W,J){</span><span class="s1">if</span><span class="s0">(O </span><span class="s1">instanceof </span><span class="s0">r.Node)</span><span class="s1">return </span><span class="s0">O;let{defaultPrefix:x,onTagObj:G,prevObjects:re,schema:_e,wrapScalars:ye}=J;W&amp;&amp;W.startsWith(</span><span class="s2">&quot;!!&quot;</span><span class="s0">)&amp;&amp;(W=x+W.slice(</span><span class="s3">2</span><span class="s0">));let be=z(O,W,_e.tags);</span><span class="s1">if</span><span class="s0">(!be){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">O.toJSON==</span><span class="s2">&quot;function&quot;</span><span class="s0">&amp;&amp;(O=O.toJSON()),!O||</span><span class="s1">typeof </span><span class="s0">O!=</span><span class="s2">&quot;object&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">ye?</span><span class="s1">new </span><span class="s0">r.Scalar(O):O;be=O </span><span class="s1">instanceof </span><span class="s0">Map?d:O[Symbol.iterator]?E:d}G&amp;&amp;(G(be),</span><span class="s1">delete </span><span class="s0">J.onTagObj);let ve={value:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,node:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">};</span><span class="s1">if</span><span class="s0">(O&amp;&amp;</span><span class="s1">typeof </span><span class="s0">O==</span><span class="s2">&quot;object&quot;</span><span class="s0">&amp;&amp;re){let Ne=re.get(O);</span><span class="s1">if</span><span class="s0">(Ne){let Pe=</span><span class="s1">new </span><span class="s0">r.Alias(Ne);</span><span class="s1">return </span><span class="s0">J.aliasNodes.push(Pe),Pe}ve.value=O,re.set(O,ve)}</span><span class="s1">return </span><span class="s0">ve.node=be.createNode?be.createNode(J.schema,O,J):ye?</span><span class="s1">new </span><span class="s0">r.Scalar(O):O,W&amp;&amp;ve.node </span><span class="s1">instanceof </span><span class="s0">r.Node&amp;&amp;(ve.node.tag=W),ve.node}</span><span class="s1">function </span><span class="s0">ue(O,W,J,x){let G=O[x.replace(/\W/g,</span><span class="s2">&quot;&quot;</span><span class="s0">)];</span><span class="s1">if</span><span class="s0">(!G){let re=Object.keys(O).map(_e=&gt;JSON.stringify(_e)).join(</span><span class="s2">&quot;, &quot;</span><span class="s0">);</span><span class="s1">throw new </span><span class="s0">Error(`Unknown schema </span><span class="s2">&quot;${x}&quot;</span><span class="s0">; use one of ${re}`)}</span><span class="s1">if</span><span class="s0">(Array.isArray(J))</span><span class="s1">for</span><span class="s0">(let re of J)G=G.concat(re);</span><span class="s1">else typeof </span><span class="s0">J==</span><span class="s2">&quot;function&quot;</span><span class="s0">&amp;&amp;(G=J(G.slice()));</span><span class="s1">for</span><span class="s0">(let re=</span><span class="s3">0</span><span class="s0">;re&lt;G.length;++re){let _e=G[re];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">_e==</span><span class="s2">&quot;string&quot;</span><span class="s0">){let ye=W[_e];</span><span class="s1">if</span><span class="s0">(!ye){let be=Object.keys(W).map(ve=&gt;JSON.stringify(ve)).join(</span><span class="s2">&quot;, &quot;</span><span class="s0">);</span><span class="s1">throw new </span><span class="s0">Error(`Unknown custom tag </span><span class="s2">&quot;${_e}&quot;</span><span class="s0">; use one of ${be}`)}G[re]=ye}}</span><span class="s1">return </span><span class="s0">G}</span><span class="s1">var </span><span class="s0">pe=(O,W)=&gt;O.key&lt;W.key?-</span><span class="s3">1</span><span class="s0">:O.key&gt;W.key?</span><span class="s3">1</span><span class="s0">:</span><span class="s3">0</span><span class="s0">,ge=class{constructor(O){let{customTags:W,merge:J,schema:x,sortMapEntries:G,tags:re}=O;</span><span class="s1">this</span><span class="s0">.merge=!!J,</span><span class="s1">this</span><span class="s0">.name=x,</span><span class="s1">this</span><span class="s0">.sortMapEntries=G===!</span><span class="s3">0</span><span class="s0">?pe:G||</span><span class="s1">null</span><span class="s0">,!W&amp;&amp;re&amp;&amp;c.warnOptionDeprecation(</span><span class="s2">&quot;tags&quot;</span><span class="s0">,</span><span class="s2">&quot;customTags&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tags=ue(K,V,W||re,x)}createNode(O,W,J,x){let G={defaultPrefix:ge.defaultPrefix,schema:</span><span class="s1">this</span><span class="s0">,wrapScalars:W},re=x?Object.assign(x,G):G;</span><span class="s1">return </span><span class="s0">ae(O,J,re)}createPair(O,W,J){J||(J={wrapScalars:!</span><span class="s3">0</span><span class="s0">});let x=</span><span class="s1">this</span><span class="s0">.createNode(O,J.wrapScalars,</span><span class="s1">null</span><span class="s0">,J),G=</span><span class="s1">this</span><span class="s0">.createNode(W,J.wrapScalars,</span><span class="s1">null</span><span class="s0">,J);</span><span class="s1">return new </span><span class="s0">r.Pair(x,G)}};e._defineProperty(ge,</span><span class="s2">&quot;defaultPrefix&quot;</span><span class="s0">,e.defaultTagPrefix),e._defineProperty(ge,</span><span class="s2">&quot;defaultTags&quot;</span><span class="s0">,e.defaultTags),n.Schema=ge}}),xr=D({</span><span class="s2">&quot;node_modules/yaml/dist/Document-9b4560a1.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y();</span><span class="s1">var </span><span class="s0">e=Me(),r=ke(),c=it(),h={anchorPrefix:</span><span class="s2">&quot;a&quot;</span><span class="s0">,customTags:</span><span class="s1">null</span><span class="s0">,indent:</span><span class="s3">2</span><span class="s0">,indentSeq:!</span><span class="s3">0</span><span class="s0">,keepCstNodes:!</span><span class="s3">1</span><span class="s0">,keepNodeTypes:!</span><span class="s3">0</span><span class="s0">,keepBlobsInJSON:!</span><span class="s3">0</span><span class="s0">,mapAsMap:!</span><span class="s3">1</span><span class="s0">,maxAliasCount:</span><span class="s3">100</span><span class="s0">,prettyErrors:!</span><span class="s3">1</span><span class="s0">,simpleKeys:!</span><span class="s3">1</span><span class="s0">,version:</span><span class="s2">&quot;1.2&quot;</span><span class="s0">},d={get binary(){</span><span class="s1">return </span><span class="s0">r.binaryOptions},set binary(t){Object.assign(r.binaryOptions,t)},get bool(){</span><span class="s1">return </span><span class="s0">r.boolOptions},set bool(t){Object.assign(r.boolOptions,t)},get int(){</span><span class="s1">return </span><span class="s0">r.intOptions},set int(t){Object.assign(r.intOptions,t)},get </span><span class="s1">null</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">r.nullOptions},set </span><span class="s1">null</span><span class="s0">(t){Object.assign(r.nullOptions,t)},get str(){</span><span class="s1">return </span><span class="s0">r.strOptions},set str(t){Object.assign(r.strOptions,t)}},y={</span><span class="s2">&quot;1.0&quot;</span><span class="s0">:{schema:</span><span class="s2">&quot;yaml-1.1&quot;</span><span class="s0">,merge:!</span><span class="s3">0</span><span class="s0">,tagPrefixes:[{handle:</span><span class="s2">&quot;!&quot;</span><span class="s0">,prefix:e.defaultTagPrefix},{handle:</span><span class="s2">&quot;!!&quot;</span><span class="s0">,prefix:</span><span class="s2">&quot;tag:private.yaml.org,2002:&quot;</span><span class="s0">}]},</span><span class="s3">1.1</span><span class="s0">:{schema:</span><span class="s2">&quot;yaml-1.1&quot;</span><span class="s0">,merge:!</span><span class="s3">0</span><span class="s0">,tagPrefixes:[{handle:</span><span class="s2">&quot;!&quot;</span><span class="s0">,prefix:</span><span class="s2">&quot;!&quot;</span><span class="s0">},{handle:</span><span class="s2">&quot;!!&quot;</span><span class="s0">,prefix:e.defaultTagPrefix}]},</span><span class="s3">1.2</span><span class="s0">:{schema:</span><span class="s2">&quot;core&quot;</span><span class="s0">,merge:!</span><span class="s3">1</span><span class="s0">,tagPrefixes:[{handle:</span><span class="s2">&quot;!&quot;</span><span class="s0">,prefix:</span><span class="s2">&quot;!&quot;</span><span class="s0">},{handle:</span><span class="s2">&quot;!!&quot;</span><span class="s0">,prefix:e.defaultTagPrefix}]}};</span><span class="s1">function </span><span class="s0">E(t,s){</span><span class="s1">if</span><span class="s0">((t.version||t.options.version)===</span><span class="s2">&quot;1.0&quot;</span><span class="s0">){let g=s.match(/^tag:private\.yaml\.org,</span><span class="s3">2002</span><span class="s0">:([^:/]+)$/);</span><span class="s1">if</span><span class="s0">(g)</span><span class="s1">return</span><span class="s2">&quot;!&quot;</span><span class="s0">+g[</span><span class="s3">1</span><span class="s0">];let u=s.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,</span><span class="s3">2002</span><span class="s0">:(.*)/);</span><span class="s1">return </span><span class="s0">u?`!${u[</span><span class="s3">1</span><span class="s0">]}/${u[</span><span class="s3">2</span><span class="s0">]}`:`!${s.replace(/^tag:/,</span><span class="s2">&quot;&quot;</span><span class="s0">)}`}let a=t.tagPrefixes.find(g=&gt;s.indexOf(g.prefix)===</span><span class="s3">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!a){let g=t.getDefaults().tagPrefixes;a=g&amp;&amp;g.find(u=&gt;s.indexOf(u.prefix)===</span><span class="s3">0</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(!a)</span><span class="s1">return </span><span class="s0">s[</span><span class="s3">0</span><span class="s0">]===</span><span class="s2">&quot;!&quot;</span><span class="s0">?s:`!&lt;${s}&gt;`;let m=s.substr(a.prefix.length).replace(/[!,[\]{}]/g,g=&gt;({</span><span class="s2">&quot;!&quot;</span><span class="s0">:</span><span class="s2">&quot;%21&quot;</span><span class="s0">,</span><span class="s2">&quot;,&quot;</span><span class="s0">:</span><span class="s2">&quot;%2C&quot;</span><span class="s0">,</span><span class="s2">&quot;[&quot;</span><span class="s0">:</span><span class="s2">&quot;%5B&quot;</span><span class="s0">,</span><span class="s2">&quot;]&quot;</span><span class="s0">:</span><span class="s2">&quot;%5D&quot;</span><span class="s0">,</span><span class="s2">&quot;{&quot;</span><span class="s0">:</span><span class="s2">&quot;%7B&quot;</span><span class="s0">,</span><span class="s2">&quot;}&quot;</span><span class="s0">:</span><span class="s2">&quot;%7D&quot;</span><span class="s0">})[g]);</span><span class="s1">return </span><span class="s0">a.handle+m}</span><span class="s1">function </span><span class="s0">I(t,s){</span><span class="s1">if</span><span class="s0">(s </span><span class="s1">instanceof </span><span class="s0">r.Alias)</span><span class="s1">return </span><span class="s0">r.Alias;</span><span class="s1">if</span><span class="s0">(s.tag){let g=t.filter(u=&gt;u.tag===s.tag);</span><span class="s1">if</span><span class="s0">(g.length&gt;</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return </span><span class="s0">g.find(u=&gt;u.format===s.format)||g[</span><span class="s3">0</span><span class="s0">]}let a,m;</span><span class="s1">if</span><span class="s0">(s </span><span class="s1">instanceof </span><span class="s0">r.Scalar){m=s.value;let g=t.filter(u=&gt;u.identify&amp;&amp;u.identify(m)||u.class&amp;&amp;m </span><span class="s1">instanceof </span><span class="s0">u.class);a=g.find(u=&gt;u.format===s.format)||g.find(u=&gt;!u.format)}</span><span class="s1">else </span><span class="s0">m=s,a=t.find(g=&gt;g.nodeClass&amp;&amp;m </span><span class="s1">instanceof </span><span class="s0">g.nodeClass);</span><span class="s1">if</span><span class="s0">(!a){let g=m&amp;&amp;m.constructor?m.constructor.name:</span><span class="s1">typeof </span><span class="s0">m;</span><span class="s1">throw new </span><span class="s0">Error(`Tag not resolved </span><span class="s1">for </span><span class="s0">${g} value`)}</span><span class="s1">return </span><span class="s0">a}</span><span class="s1">function </span><span class="s0">S(t,s,a){let{anchors:m,doc:g}=a,u=[],p=g.anchors.getName(t);</span><span class="s1">return </span><span class="s0">p&amp;&amp;(m[p]=t,u.push(`&amp;${p}`)),t.tag?u.push(E(g,t.tag)):s.</span><span class="s1">default</span><span class="s0">||u.push(E(g,s.tag)),u.join(</span><span class="s2">&quot; &quot;</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">M(t,s,a,m){let{anchors:g,schema:u}=s.doc,p;</span><span class="s1">if</span><span class="s0">(!(t </span><span class="s1">instanceof </span><span class="s0">r.Node)){let $={aliasNodes:[],onTagObj:K=&gt;p=K,prevObjects:</span><span class="s1">new </span><span class="s0">Map};t=u.createNode(t,!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">null</span><span class="s0">,$);</span><span class="s1">for</span><span class="s0">(let K of $.aliasNodes){K.source=K.source.node;let V=g.getName(K.source);V||(V=g.newName(),g.map[V]=K.source)}}</span><span class="s1">if</span><span class="s0">(t </span><span class="s1">instanceof </span><span class="s0">r.Pair)</span><span class="s1">return </span><span class="s0">t.toString(s,a,m);p||(p=I(u.tags,t));let L=S(t,p,s);L.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;(s.indentAtStart=(s.indentAtStart||</span><span class="s3">0</span><span class="s0">)+L.length+</span><span class="s3">1</span><span class="s0">);let k=</span><span class="s1">typeof </span><span class="s0">p.stringify==</span><span class="s2">&quot;function&quot;</span><span class="s0">?p.stringify(t,s,a,m):t </span><span class="s1">instanceof </span><span class="s0">r.Scalar?r.stringifyString(t,s,a,m):t.toString(s,a,m);</span><span class="s1">return </span><span class="s0">L?t </span><span class="s1">instanceof </span><span class="s0">r.Scalar||k[</span><span class="s3">0</span><span class="s0">]===</span><span class="s2">&quot;{&quot;</span><span class="s0">||k[</span><span class="s3">0</span><span class="s0">]===</span><span class="s2">&quot;[&quot;</span><span class="s0">?`${L} ${k}`:`${L}</span>
<span class="s0">${s.indent}${k}`:k}</span><span class="s1">var </span><span class="s0">T=class{static validAnchorNode(t){</span><span class="s1">return </span><span class="s0">t </span><span class="s1">instanceof </span><span class="s0">r.Scalar||t </span><span class="s1">instanceof </span><span class="s0">r.YAMLSeq||t </span><span class="s1">instanceof </span><span class="s0">r.YAMLMap}constructor(t){e._defineProperty(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;map&quot;</span><span class="s0">,Object.create(</span><span class="s1">null</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.prefix=t}createAlias(t,s){</span><span class="s1">return this</span><span class="s0">.setAnchor(t,s),</span><span class="s1">new </span><span class="s0">r.Alias(t)}createMergePair(){let t=</span><span class="s1">new </span><span class="s0">r.Merge;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">s=arguments.length,a=</span><span class="s1">new </span><span class="s0">Array(s),m=</span><span class="s3">0</span><span class="s0">;m&lt;s;m++)a[m]=arguments[m];</span><span class="s1">return </span><span class="s0">t.value.items=a.map(g=&gt;{</span><span class="s1">if</span><span class="s0">(g </span><span class="s1">instanceof </span><span class="s0">r.Alias){</span><span class="s1">if</span><span class="s0">(g.source </span><span class="s1">instanceof </span><span class="s0">r.YAMLMap)</span><span class="s1">return </span><span class="s0">g}</span><span class="s1">else if</span><span class="s0">(g </span><span class="s1">instanceof </span><span class="s0">r.YAMLMap)</span><span class="s1">return this</span><span class="s0">.createAlias(g);</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Merge sources must be Map nodes or their Aliases&quot;</span><span class="s0">)}),t}getName(t){let{map:s}=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">return </span><span class="s0">Object.keys(s).find(a=&gt;s[a]===t)}getNames(){</span><span class="s1">return </span><span class="s0">Object.keys(</span><span class="s1">this</span><span class="s0">.map)}getNode(t){</span><span class="s1">return this</span><span class="s0">.map[t]}newName(t){t||(t=</span><span class="s1">this</span><span class="s0">.prefix);let s=Object.keys(</span><span class="s1">this</span><span class="s0">.map);</span><span class="s1">for</span><span class="s0">(let a=</span><span class="s3">1</span><span class="s0">;;++a){let m=`${t}${a}`;</span><span class="s1">if</span><span class="s0">(!s.includes(m))</span><span class="s1">return </span><span class="s0">m}}resolveNodes(){let{map:t,_cstAliases:s}=</span><span class="s1">this</span><span class="s0">;Object.keys(t).forEach(a=&gt;{t[a]=t[a].resolved}),s.forEach(a=&gt;{a.source=a.source.resolved}),</span><span class="s1">delete this</span><span class="s0">._cstAliases}setAnchor(t,s){</span><span class="s1">if</span><span class="s0">(t!=</span><span class="s1">null</span><span class="s0">&amp;&amp;!T.validAnchorNode(t))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Anchors may only be set for Scalar, Seq and Map nodes&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(s&amp;&amp;/[\x00-\x19\s,[\]{}]/.test(s))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Anchor names must not contain whitespace or control characters&quot;</span><span class="s0">);let{map:a}=</span><span class="s1">this</span><span class="s0">,m=t&amp;&amp;Object.keys(a).find(g=&gt;a[g]===t);</span><span class="s1">if</span><span class="s0">(m)</span><span class="s1">if</span><span class="s0">(s)m!==s&amp;&amp;(</span><span class="s1">delete </span><span class="s0">a[m],a[s]=t);</span><span class="s1">else return </span><span class="s0">m;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!s){</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return null</span><span class="s0">;s=</span><span class="s1">this</span><span class="s0">.newName()}a[s]=t}</span><span class="s1">return </span><span class="s0">s}},P=(t,s)=&gt;{</span><span class="s1">if</span><span class="s0">(t&amp;&amp;</span><span class="s1">typeof </span><span class="s0">t==</span><span class="s2">&quot;object&quot;</span><span class="s0">){let{tag:a}=t;t </span><span class="s1">instanceof </span><span class="s0">r.Collection?(a&amp;&amp;(s[a]=!</span><span class="s3">0</span><span class="s0">),t.items.forEach(m=&gt;P(m,s))):t </span><span class="s1">instanceof </span><span class="s0">r.Pair?(P(t.key,s),P(t.value,s)):t </span><span class="s1">instanceof </span><span class="s0">r.Scalar&amp;&amp;a&amp;&amp;(s[a]=!</span><span class="s3">0</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">s},C=t=&gt;Object.keys(P(t,{}));</span><span class="s1">function </span><span class="s0">q(t,s){let a={before:[],after:[]},m,g=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let u of s)</span><span class="s1">if</span><span class="s0">(u.valueRange){</span><span class="s1">if</span><span class="s0">(m!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">){let L=</span><span class="s2">&quot;Document contains trailing content not separated by a ... or --- line&quot;</span><span class="s0">;t.errors.push(</span><span class="s1">new </span><span class="s0">e.YAMLSyntaxError(u,L));</span><span class="s1">break</span><span class="s0">}let p=r.resolveNode(t,u);g&amp;&amp;(p.spaceBefore=!</span><span class="s3">0</span><span class="s0">,g=!</span><span class="s3">1</span><span class="s0">),m=p}</span><span class="s1">else </span><span class="s0">u.comment!==</span><span class="s1">null</span><span class="s0">?(m===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?a.before:a.after).push(u.comment):u.type===e.Type.BLANK_LINE&amp;&amp;(g=!</span><span class="s3">0</span><span class="s0">,m===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;a.before.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;!t.commentBefore&amp;&amp;(t.commentBefore=a.before.join(`</span>
<span class="s0">`),a.before=[]));</span><span class="s1">if</span><span class="s0">(t.contents=m||</span><span class="s1">null</span><span class="s0">,!m)t.comment=a.before.concat(a.after).join(`</span>
<span class="s0">`)||</span><span class="s1">null</span><span class="s0">;</span><span class="s1">else</span><span class="s0">{let u=a.before.join(`</span>
<span class="s0">`);</span><span class="s1">if</span><span class="s0">(u){let p=m </span><span class="s1">instanceof </span><span class="s0">r.Collection&amp;&amp;m.items[</span><span class="s3">0</span><span class="s0">]?m.items[</span><span class="s3">0</span><span class="s0">]:m;p.commentBefore=p.commentBefore?`${u}</span>
<span class="s0">${p.commentBefore}`:u}t.comment=a.after.join(`</span>
<span class="s0">`)||</span><span class="s1">null</span><span class="s0">}}</span><span class="s1">function </span><span class="s0">R(t,s){let{tagPrefixes:a}=t,[m,g]=s.parameters;</span><span class="s1">if</span><span class="s0">(!m||!g){let u=</span><span class="s2">&quot;Insufficient parameters given for %TAG directive&quot;</span><span class="s0">;</span><span class="s1">throw new </span><span class="s0">e.YAMLSemanticError(s,u)}</span><span class="s1">if</span><span class="s0">(a.some(u=&gt;u.handle===m)){let u=</span><span class="s2">&quot;The %TAG directive must only be given at most once per handle in the same document.&quot;</span><span class="s0">;</span><span class="s1">throw new </span><span class="s0">e.YAMLSemanticError(s,u)}</span><span class="s1">return</span><span class="s0">{handle:m,prefix:g}}</span><span class="s1">function </span><span class="s0">B(t,s){let[a]=s.parameters;</span><span class="s1">if</span><span class="s0">(s.name===</span><span class="s2">&quot;YAML:1.0&quot;</span><span class="s0">&amp;&amp;(a=</span><span class="s2">&quot;1.0&quot;</span><span class="s0">),!a){let m=</span><span class="s2">&quot;Insufficient parameters given for %YAML directive&quot;</span><span class="s0">;</span><span class="s1">throw new </span><span class="s0">e.YAMLSemanticError(s,m)}</span><span class="s1">if</span><span class="s0">(!y[a]){let g=`Document will be parsed as YAML ${t.version||t.options.version} rather than YAML ${a}`;t.warnings.push(</span><span class="s1">new </span><span class="s0">e.YAMLWarning(s,g))}</span><span class="s1">return </span><span class="s0">a}</span><span class="s1">function </span><span class="s0">U(t,s,a){let m=[],g=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let u of s){let{comment:p,name:L}=u;</span><span class="s1">switch</span><span class="s0">(L){</span><span class="s1">case</span><span class="s2">&quot;TAG&quot;</span><span class="s0">:</span><span class="s1">try</span><span class="s0">{t.tagPrefixes.push(R(t,u))}</span><span class="s1">catch</span><span class="s0">(k){t.errors.push(k)}g=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;YAML&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;YAML:1.0&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(t.version){let k=</span><span class="s2">&quot;The %YAML directive must only be given at most once per document.&quot;</span><span class="s0">;t.errors.push(</span><span class="s1">new </span><span class="s0">e.YAMLSemanticError(u,k))}</span><span class="s1">try</span><span class="s0">{t.version=B(t,u)}</span><span class="s1">catch</span><span class="s0">(k){t.errors.push(k)}g=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(L){let k=`YAML only supports %TAG and %YAML directives, and not %${L}`;t.warnings.push(</span><span class="s1">new </span><span class="s0">e.YAMLWarning(u,k))}}p&amp;&amp;m.push(p)}</span><span class="s1">if</span><span class="s0">(a&amp;&amp;!g&amp;&amp;(t.version||a.version||t.options.version)===</span><span class="s2">&quot;1.1&quot;</span><span class="s0">){let u=p=&gt;{let{handle:L,prefix:k}=p;</span><span class="s1">return</span><span class="s0">{handle:L,prefix:k}};t.tagPrefixes=a.tagPrefixes.map(u),t.version=a.version}t.commentBefore=m.join(`</span>
<span class="s0">`)||</span><span class="s1">null</span><span class="s0">}</span><span class="s1">function </span><span class="s0">f(t){</span><span class="s1">if</span><span class="s0">(t </span><span class="s1">instanceof </span><span class="s0">r.Collection)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Expected a YAML collection as document contents&quot;</span><span class="s0">)}</span><span class="s1">var </span><span class="s0">i=class{constructor(t){</span><span class="s1">this</span><span class="s0">.anchors=</span><span class="s1">new </span><span class="s0">T(t.anchorPrefix),</span><span class="s1">this</span><span class="s0">.commentBefore=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.comment=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.contents=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.directivesEndMarker=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.errors=[],</span><span class="s1">this</span><span class="s0">.options=t,</span><span class="s1">this</span><span class="s0">.schema=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tagPrefixes=[],</span><span class="s1">this</span><span class="s0">.version=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.warnings=[]}add(t){</span><span class="s1">return </span><span class="s0">f(</span><span class="s1">this</span><span class="s0">.contents),</span><span class="s1">this</span><span class="s0">.contents.add(t)}addIn(t,s){f(</span><span class="s1">this</span><span class="s0">.contents),</span><span class="s1">this</span><span class="s0">.contents.addIn(t,s)}</span><span class="s1">delete</span><span class="s0">(t){</span><span class="s1">return </span><span class="s0">f(</span><span class="s1">this</span><span class="s0">.contents),</span><span class="s1">this</span><span class="s0">.contents.</span><span class="s1">delete</span><span class="s0">(t)}deleteIn(t){</span><span class="s1">return </span><span class="s0">r.isEmptyPath(t)?</span><span class="s1">this</span><span class="s0">.contents==</span><span class="s1">null</span><span class="s0">?!</span><span class="s3">1</span><span class="s0">:(</span><span class="s1">this</span><span class="s0">.contents=</span><span class="s1">null</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">):(f(</span><span class="s1">this</span><span class="s0">.contents),</span><span class="s1">this</span><span class="s0">.contents.deleteIn(t))}getDefaults(){</span><span class="s1">return </span><span class="s0">i.defaults[</span><span class="s1">this</span><span class="s0">.version]||i.defaults[</span><span class="s1">this</span><span class="s0">.options.version]||{}}get(t,s){</span><span class="s1">return this</span><span class="s0">.contents </span><span class="s1">instanceof </span><span class="s0">r.Collection?</span><span class="s1">this</span><span class="s0">.contents.get(t,s):</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}getIn(t,s){</span><span class="s1">return </span><span class="s0">r.isEmptyPath(t)?!s&amp;&amp;</span><span class="s1">this</span><span class="s0">.contents </span><span class="s1">instanceof </span><span class="s0">r.Scalar?</span><span class="s1">this</span><span class="s0">.contents.value:</span><span class="s1">this</span><span class="s0">.contents:</span><span class="s1">this</span><span class="s0">.contents </span><span class="s1">instanceof </span><span class="s0">r.Collection?</span><span class="s1">this</span><span class="s0">.contents.getIn(t,s):</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}has(t){</span><span class="s1">return this</span><span class="s0">.contents </span><span class="s1">instanceof </span><span class="s0">r.Collection?</span><span class="s1">this</span><span class="s0">.contents.has(t):!</span><span class="s3">1</span><span class="s0">}hasIn(t){</span><span class="s1">return </span><span class="s0">r.isEmptyPath(t)?</span><span class="s1">this</span><span class="s0">.contents!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.contents </span><span class="s1">instanceof </span><span class="s0">r.Collection?</span><span class="s1">this</span><span class="s0">.contents.hasIn(t):!</span><span class="s3">1</span><span class="s0">}set(t,s){f(</span><span class="s1">this</span><span class="s0">.contents),</span><span class="s1">this</span><span class="s0">.contents.set(t,s)}setIn(t,s){r.isEmptyPath(t)?</span><span class="s1">this</span><span class="s0">.contents=s:(f(</span><span class="s1">this</span><span class="s0">.contents),</span><span class="s1">this</span><span class="s0">.contents.setIn(t,s))}setSchema(t,s){</span><span class="s1">if</span><span class="s0">(!t&amp;&amp;!s&amp;&amp;</span><span class="s1">this</span><span class="s0">.schema)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">typeof </span><span class="s0">t==</span><span class="s2">&quot;number&quot;</span><span class="s0">&amp;&amp;(t=t.toFixed(</span><span class="s3">1</span><span class="s0">)),t===</span><span class="s2">&quot;1.0&quot;</span><span class="s0">||t===</span><span class="s2">&quot;1.1&quot;</span><span class="s0">||t===</span><span class="s2">&quot;1.2&quot;</span><span class="s0">?(</span><span class="s1">this</span><span class="s0">.version?</span><span class="s1">this</span><span class="s0">.version=t:</span><span class="s1">this</span><span class="s0">.options.version=t,</span><span class="s1">delete this</span><span class="s0">.options.schema):t&amp;&amp;</span><span class="s1">typeof </span><span class="s0">t==</span><span class="s2">&quot;string&quot;</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.options.schema=t),Array.isArray(s)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.options.customTags=s);let a=Object.assign({},</span><span class="s1">this</span><span class="s0">.getDefaults(),</span><span class="s1">this</span><span class="s0">.options);</span><span class="s1">this</span><span class="s0">.schema=</span><span class="s1">new </span><span class="s0">c.Schema(a)}parse(t,s){</span><span class="s1">this</span><span class="s0">.options.keepCstNodes&amp;&amp;(</span><span class="s1">this</span><span class="s0">.cstNode=t),</span><span class="s1">this</span><span class="s0">.options.keepNodeTypes&amp;&amp;(</span><span class="s1">this</span><span class="s0">.type=</span><span class="s2">&quot;DOCUMENT&quot;</span><span class="s0">);let{directives:a=[],contents:m=[],directivesEndMarker:g,error:u,valueRange:p}=t;</span><span class="s1">if</span><span class="s0">(u&amp;&amp;(u.source||(u.source=</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.errors.push(u)),U(</span><span class="s1">this</span><span class="s0">,a,s),g&amp;&amp;(</span><span class="s1">this</span><span class="s0">.directivesEndMarker=!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.range=p?[p.start,p.end]:</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.setSchema(),</span><span class="s1">this</span><span class="s0">.anchors._cstAliases=[],q(</span><span class="s1">this</span><span class="s0">,m),</span><span class="s1">this</span><span class="s0">.anchors.resolveNodes(),</span><span class="s1">this</span><span class="s0">.options.prettyErrors){</span><span class="s1">for</span><span class="s0">(let L of </span><span class="s1">this</span><span class="s0">.errors)L </span><span class="s1">instanceof </span><span class="s0">e.YAMLError&amp;&amp;L.makePretty();</span><span class="s1">for</span><span class="s0">(let L of </span><span class="s1">this</span><span class="s0">.warnings)L </span><span class="s1">instanceof </span><span class="s0">e.YAMLError&amp;&amp;L.makePretty()}</span><span class="s1">return this</span><span class="s0">}listNonDefaultTags(){</span><span class="s1">return </span><span class="s0">C(</span><span class="s1">this</span><span class="s0">.contents).filter(t=&gt;t.indexOf(c.Schema.defaultPrefix)!==</span><span class="s3">0</span><span class="s0">)}setTagPrefix(t,s){</span><span class="s1">if</span><span class="s0">(t[</span><span class="s3">0</span><span class="s0">]!==</span><span class="s2">&quot;!&quot;</span><span class="s0">||t[t.length-1]!==</span><span class="s2">&quot;!&quot;</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Handle must start and end with !&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(s){let a=</span><span class="s1">this</span><span class="s0">.tagPrefixes.find(m=&gt;m.handle===t);a?a.prefix=s:</span><span class="s1">this</span><span class="s0">.tagPrefixes.push({handle:t,prefix:s})}</span><span class="s1">else this</span><span class="s0">.tagPrefixes=</span><span class="s1">this</span><span class="s0">.tagPrefixes.filter(a=&gt;a.handle!==t)}toJSON(t,s){let{keepBlobsInJSON:a,mapAsMap:m,maxAliasCount:g}=</span><span class="s1">this</span><span class="s0">.options,u=a&amp;&amp;(</span><span class="s1">typeof </span><span class="s0">t!=</span><span class="s2">&quot;string&quot;</span><span class="s0">||!(</span><span class="s1">this</span><span class="s0">.contents </span><span class="s1">instanceof </span><span class="s0">r.Scalar)),p={doc:</span><span class="s1">this</span><span class="s0">,indentStep:</span><span class="s2">&quot;  &quot;</span><span class="s0">,keep:u,mapAsMap:u&amp;&amp;!!m,maxAliasCount:g,stringify:M},L=Object.keys(</span><span class="s1">this</span><span class="s0">.anchors.map);L.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;(p.anchors=</span><span class="s1">new </span><span class="s0">Map(L.map($=&gt;[</span><span class="s1">this</span><span class="s0">.anchors.map[$],{alias:[],aliasCount:</span><span class="s3">0</span><span class="s0">,count:</span><span class="s3">1</span><span class="s0">}])));let k=r.toJSON(</span><span class="s1">this</span><span class="s0">.contents,t,p);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">s==</span><span class="s2">&quot;function&quot;</span><span class="s0">&amp;&amp;p.anchors)</span><span class="s1">for</span><span class="s0">(let{count:$,res:K}of p.anchors.values())s(K,$);</span><span class="s1">return </span><span class="s0">k}toString(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.errors.length&gt;</span><span class="s3">0</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Document with errors cannot be stringified&quot;</span><span class="s0">);let t=</span><span class="s1">this</span><span class="s0">.options.indent;</span><span class="s1">if</span><span class="s0">(!Number.isInteger(t)||t&lt;=</span><span class="s3">0</span><span class="s0">){let L=JSON.stringify(t);</span><span class="s1">throw new </span><span class="s0">Error(`</span><span class="s2">&quot;indent&quot; </span><span class="s0">option must be a positive integer, not ${L}`)}</span><span class="s1">this</span><span class="s0">.setSchema();let s=[],a=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.version){let L=</span><span class="s2">&quot;%YAML 1.2&quot;</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.schema.name===</span><span class="s2">&quot;yaml-1.1&quot;</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.version===</span><span class="s2">&quot;1.0&quot;</span><span class="s0">?L=</span><span class="s2">&quot;%YAML:1.0&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.version===</span><span class="s2">&quot;1.1&quot;</span><span class="s0">&amp;&amp;(L=</span><span class="s2">&quot;%YAML 1.1&quot;</span><span class="s0">)),s.push(L),a=!</span><span class="s3">0</span><span class="s0">}let m=</span><span class="s1">this</span><span class="s0">.listNonDefaultTags();</span><span class="s1">this</span><span class="s0">.tagPrefixes.forEach(L=&gt;{let{handle:k,prefix:$}=L;m.some(K=&gt;K.indexOf($)===</span><span class="s3">0</span><span class="s0">)&amp;&amp;(s.push(`%TAG ${k} ${$}`),a=!</span><span class="s3">0</span><span class="s0">)}),(a||</span><span class="s1">this</span><span class="s0">.directivesEndMarker)&amp;&amp;s.push(</span><span class="s2">&quot;---&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.commentBefore&amp;&amp;((a||!</span><span class="s1">this</span><span class="s0">.directivesEndMarker)&amp;&amp;s.unshift(</span><span class="s2">&quot;&quot;</span><span class="s0">),s.unshift(</span><span class="s1">this</span><span class="s0">.commentBefore.replace(/^/gm,</span><span class="s2">&quot;#&quot;</span><span class="s0">)));let g={anchors:Object.create(</span><span class="s1">null</span><span class="s0">),doc:</span><span class="s1">this</span><span class="s0">,indent:</span><span class="s2">&quot;&quot;</span><span class="s0">,indentStep:</span><span class="s2">&quot; &quot;</span><span class="s0">.repeat(t),stringify:M},u=!</span><span class="s3">1</span><span class="s0">,p=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.contents){</span><span class="s1">this</span><span class="s0">.contents </span><span class="s1">instanceof </span><span class="s0">r.Node&amp;&amp;(</span><span class="s1">this</span><span class="s0">.contents.spaceBefore&amp;&amp;(a||</span><span class="s1">this</span><span class="s0">.directivesEndMarker)&amp;&amp;s.push(</span><span class="s2">&quot;&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.contents.commentBefore&amp;&amp;s.push(</span><span class="s1">this</span><span class="s0">.contents.commentBefore.replace(/^/gm,</span><span class="s2">&quot;#&quot;</span><span class="s0">)),g.forceBlockIndent=!!</span><span class="s1">this</span><span class="s0">.comment,p=</span><span class="s1">this</span><span class="s0">.contents.comment);let L=p?</span><span class="s1">null</span><span class="s0">:()=&gt;u=!</span><span class="s3">0</span><span class="s0">,k=M(</span><span class="s1">this</span><span class="s0">.contents,g,()=&gt;p=</span><span class="s1">null</span><span class="s0">,L);s.push(r.addComment(k,</span><span class="s2">&quot;&quot;</span><span class="s0">,p))}</span><span class="s1">else this</span><span class="s0">.contents!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;s.push(M(</span><span class="s1">this</span><span class="s0">.contents,g));</span><span class="s1">return this</span><span class="s0">.comment&amp;&amp;((!u||p)&amp;&amp;s[s.length-1]!==</span><span class="s2">&quot;&quot;</span><span class="s0">&amp;&amp;s.push(</span><span class="s2">&quot;&quot;</span><span class="s0">),s.push(</span><span class="s1">this</span><span class="s0">.comment.replace(/^/gm,</span><span class="s2">&quot;#&quot;</span><span class="s0">))),s.join(`</span>
<span class="s0">`)+`</span>
<span class="s0">`}};e._defineProperty(i,</span><span class="s2">&quot;defaults&quot;</span><span class="s0">,y),n.Document=i,n.defaultOptions=h,n.scalarOptions=d}}),Hr=D({</span><span class="s2">&quot;node_modules/yaml/dist/index.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y();</span><span class="s1">var </span><span class="s0">e=Jr(),r=xr(),c=it(),h=Me(),d=st();ke();</span><span class="s1">function </span><span class="s0">y(C){let q=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:!</span><span class="s3">0</span><span class="s0">,R=arguments.length&gt;</span><span class="s3">2</span><span class="s0">?arguments[</span><span class="s3">2</span><span class="s0">]:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">;R===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">typeof </span><span class="s0">q==</span><span class="s2">&quot;string&quot;</span><span class="s0">&amp;&amp;(R=q,q=!</span><span class="s3">0</span><span class="s0">);let B=Object.assign({},r.Document.defaults[r.defaultOptions.version],r.defaultOptions);</span><span class="s1">return new </span><span class="s0">c.Schema(B).createNode(C,q,R)}</span><span class="s1">var </span><span class="s0">E=class extends r.Document{constructor(C){super(Object.assign({},r.defaultOptions,C))}};</span><span class="s1">function </span><span class="s0">I(C,q){let R=[],B;</span><span class="s1">for</span><span class="s0">(let U of e.parse(C)){let f=</span><span class="s1">new </span><span class="s0">E(q);f.parse(U,B),R.push(f),B=f}</span><span class="s1">return </span><span class="s0">R}</span><span class="s1">function </span><span class="s0">S(C,q){let R=e.parse(C),B=</span><span class="s1">new </span><span class="s0">E(q).parse(R[</span><span class="s3">0</span><span class="s0">]);</span><span class="s1">if</span><span class="s0">(R.length&gt;</span><span class="s3">1</span><span class="s0">){let U=</span><span class="s2">&quot;Source contains multiple documents; please use YAML.parseAllDocuments()&quot;</span><span class="s0">;B.errors.unshift(</span><span class="s1">new </span><span class="s0">h.YAMLSemanticError(R[</span><span class="s3">1</span><span class="s0">],U))}</span><span class="s1">return </span><span class="s0">B}</span><span class="s1">function </span><span class="s0">M(C,q){let R=S(C,q);</span><span class="s1">if</span><span class="s0">(R.warnings.forEach(B=&gt;d.warn(B)),R.errors.length&gt;</span><span class="s3">0</span><span class="s0">)</span><span class="s1">throw </span><span class="s0">R.errors[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">return </span><span class="s0">R.toJSON()}</span><span class="s1">function </span><span class="s0">T(C,q){let R=</span><span class="s1">new </span><span class="s0">E(q);</span><span class="s1">return </span><span class="s0">R.contents=C,String(R)}</span><span class="s1">var </span><span class="s0">P={createNode:y,defaultOptions:r.defaultOptions,Document:E,parse:M,parseAllDocuments:I,parseCST:e.parse,parseDocument:S,scalarOptions:r.scalarOptions,stringify:T};n.YAML=P}}),Ue=D({</span><span class="s2">&quot;node_modules/yaml/index.js&quot;</span><span class="s0">(n,e){Y(),e.exports=Hr().YAML}}),Gr=D({</span><span class="s2">&quot;node_modules/yaml/dist/util.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y();</span><span class="s1">var </span><span class="s0">e=ke(),r=Me();n.findPair=e.findPair,n.parseMap=e.resolveMap,n.parseSeq=e.resolveSeq,n.stringifyNumber=e.stringifyNumber,n.stringifyString=e.stringifyString,n.toJSON=e.toJSON,n.Type=r.Type,n.YAMLError=r.YAMLError,n.YAMLReferenceError=r.YAMLReferenceError,n.YAMLSemanticError=r.YAMLSemanticError,n.YAMLSyntaxError=r.YAMLSyntaxError,n.YAMLWarning=r.YAMLWarning}}),zr=D({</span><span class="s2">&quot;node_modules/yaml/util.js&quot;</span><span class="s0">(n){Y();</span><span class="s1">var </span><span class="s0">e=Gr();n.findPair=e.findPair,n.toJSON=e.toJSON,n.parseMap=e.parseMap,n.parseSeq=e.parseSeq,n.stringifyNumber=e.stringifyNumber,n.stringifyString=e.stringifyString,n.Type=e.Type,n.YAMLError=e.YAMLError,n.YAMLReferenceError=e.YAMLReferenceError,n.YAMLSemanticError=e.YAMLSemanticError,n.YAMLSyntaxError=e.YAMLSyntaxError,n.YAMLWarning=e.YAMLWarning}}),Zr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/yaml.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=Ue();n.Document=e.Document;</span><span class="s1">var </span><span class="s0">r=Ue();n.parseCST=r.parseCST;</span><span class="s1">var </span><span class="s0">c=zr();n.YAMLError=c.YAMLError,n.YAMLSyntaxError=c.YAMLSyntaxError,n.YAMLSemanticError=c.YAMLSemanticError}}),Xr=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/parse.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=Kt(),r=xt(),c=Ht(),h=Gt(),d=Br(),y=He(),E=Yr(),I=Fr(),S=Wr(),M=Vr(),T=Qr(),P=Kr(),C=Zr();</span><span class="s1">function </span><span class="s0">q(R){</span><span class="s1">var </span><span class="s0">B=C.parseCST(R);M.addOrigRange(B);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">U=B.map(</span><span class="s1">function</span><span class="s0">(k){</span><span class="s1">return new </span><span class="s0">C.Document({merge:!</span><span class="s3">1</span><span class="s0">,keepCstNodes:!</span><span class="s3">0</span><span class="s0">}).parse(k)}),f=</span><span class="s1">new </span><span class="s0">e.</span><span class="s1">default</span><span class="s0">(R),i=[],t={text:R,locator:f,comments:i,transformOffset:</span><span class="s1">function</span><span class="s0">(k){</span><span class="s1">return </span><span class="s0">I.transformOffset(k,t)},transformRange:</span><span class="s1">function</span><span class="s0">(k){</span><span class="s1">return </span><span class="s0">S.transformRange(k,t)},transformNode:</span><span class="s1">function</span><span class="s0">(k){</span><span class="s1">return </span><span class="s0">d.transformNode(k,t)},transformContent:</span><span class="s1">function</span><span class="s0">(k){</span><span class="s1">return </span><span class="s0">y.transformContent(k,t)}},s=</span><span class="s3">0</span><span class="s0">,a=U;s&lt;a.length;s++)</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">m=a[s],g=</span><span class="s3">0</span><span class="s0">,u=m.errors;g&lt;u.length;g++){</span><span class="s1">var </span><span class="s0">p=u[g];</span><span class="s1">if</span><span class="s0">(!(p </span><span class="s1">instanceof </span><span class="s0">C.YAMLSemanticError&amp;&amp;p.message===</span><span class="s2">'Map keys must be unique; &quot;&lt;&lt;&quot; is repeated'</span><span class="s0">))</span><span class="s1">throw </span><span class="s0">E.transformError(p,t)}U.forEach(</span><span class="s1">function</span><span class="s0">(k){</span><span class="s1">return </span><span class="s0">h.removeCstBlankLine(k.cstNode)});</span><span class="s1">var </span><span class="s0">L=c.createRoot(t.transformRange({origStart:</span><span class="s3">0</span><span class="s0">,origEnd:t.text.length}),U.map(t.transformNode),i);</span><span class="s1">return </span><span class="s0">r.attachComments(L),P.updatePositions(L),T.removeFakeNodes(L),L}n.parse=q}}),en=D({</span><span class="s2">&quot;node_modules/yaml-unist-parser/lib/index.js&quot;</span><span class="s0">(n){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;Y(),n.__esModule=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e=(ie(),se(te));e.__exportStar(Xr(),n)}});Y();</span><span class="s1">var </span><span class="s0">tn=Mt(),{hasPragma:rn}=Ot(),{locStart:nn,locEnd:sn}=Lt();</span><span class="s1">function </span><span class="s0">an(n){let{parse:e}=en();</span><span class="s1">try</span><span class="s0">{let r=e(n);</span><span class="s1">return delete </span><span class="s0">r.comments,r}</span><span class="s1">catch</span><span class="s0">(r){</span><span class="s1">throw </span><span class="s0">r!=</span><span class="s1">null</span><span class="s0">&amp;&amp;r.position?tn(r.message,r.position):r}}</span><span class="s1">var </span><span class="s0">on={astFormat:</span><span class="s2">&quot;yaml&quot;</span><span class="s0">,parse:an,hasPragma:rn,locStart:nn,locEnd:sn};at.exports={parsers:{yaml:on}}});</span><span class="s1">return </span><span class="s0">ln();});</span></pre>
</body>
</html>
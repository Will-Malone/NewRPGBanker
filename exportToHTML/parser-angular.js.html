<html>
<head>
<title>parser-angular.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #cc7832;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #4646f1;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
parser-angular.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">exports==</span><span class="s2">&quot;object&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">typeof </span><span class="s0">module==</span><span class="s2">&quot;object&quot;</span><span class="s0">)module.exports=e();</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">define==</span><span class="s2">&quot;function&quot;</span><span class="s0">&amp;&amp;define.amd)define(e);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">var </span><span class="s0">i=</span><span class="s1">typeof </span><span class="s0">globalThis&lt;</span><span class="s2">&quot;u&quot;</span><span class="s0">?globalThis:</span><span class="s1">typeof </span><span class="s0">global&lt;</span><span class="s2">&quot;u&quot;</span><span class="s0">?global:</span><span class="s1">typeof </span><span class="s0">self&lt;</span><span class="s2">&quot;u&quot;</span><span class="s0">?self:</span><span class="s1">this</span><span class="s0">||{};i.prettierPlugins=i.prettierPlugins||{},i.prettierPlugins.angular=e()}})(</span><span class="s1">function</span><span class="s0">(){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">cr=(e,t)=&gt;()=&gt;(t||e((t={exports:{}}).exports,t),t.exports);</span><span class="s1">var </span><span class="s0">Br=cr((Mr,ar)=&gt;{</span><span class="s1">var </span><span class="s0">ze=Object.defineProperty,ur=Object.getOwnPropertyDescriptor,He=Object.getOwnPropertyNames,lr=Object.prototype.hasOwnProperty,Y=(e,t)=&gt;</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e&amp;&amp;(t=(</span><span class="s3">0</span><span class="s0">,e[He(e)[</span><span class="s3">0</span><span class="s0">]])(e=</span><span class="s3">0</span><span class="s0">)),t},q=(e,t)=&gt;</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">t||(</span><span class="s3">0</span><span class="s0">,e[He(e)[</span><span class="s3">0</span><span class="s0">]])((t={exports:{}}).exports,t),t.exports},Xe=(e,t)=&gt;{</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">r </span><span class="s1">in </span><span class="s0">t)ze(e,r,{get:t[r],enumerable:!</span><span class="s3">0</span><span class="s0">})},hr=(e,t,r,n)=&gt;{</span><span class="s1">if</span><span class="s0">(t&amp;&amp;</span><span class="s1">typeof </span><span class="s0">t==</span><span class="s2">&quot;object&quot;</span><span class="s0">||</span><span class="s1">typeof </span><span class="s0">t==</span><span class="s2">&quot;function&quot;</span><span class="s0">)</span><span class="s1">for</span><span class="s0">(let s of He(t))!lr.call(e,s)&amp;&amp;s!==r&amp;&amp;ze(e,s,{get:()=&gt;t[s],enumerable:!(n=ur(t,s))||n.enumerable});</span><span class="s1">return </span><span class="s0">e},be=e=&gt;hr(ze({},</span><span class="s2">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s3">0</span><span class="s0">}),e),L=Y({</span><span class="s2">&quot;&lt;define:process&gt;&quot;</span><span class="s0">(){}}),pr=q({</span><span class="s2">&quot;src/utils/is-non-empty-array.js&quot;</span><span class="s0">(e,t){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;L();</span><span class="s1">function </span><span class="s0">r(n){</span><span class="s1">return </span><span class="s0">Array.isArray(n)&amp;&amp;n.length&gt;</span><span class="s3">0</span><span class="s0">}t.exports=r}}),dr=q({</span><span class="s2">&quot;src/language-js/loc.js&quot;</span><span class="s0">(e,t){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;L();</span><span class="s1">var </span><span class="s0">r=pr();</span><span class="s1">function </span><span class="s0">n(l){</span><span class="s1">var </span><span class="s0">P,p;let x=l.range?l.range[</span><span class="s3">0</span><span class="s0">]:l.start,C=(P=(p=l.declaration)===</span><span class="s1">null</span><span class="s0">||p===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:p.decorators)!==</span><span class="s1">null</span><span class="s0">&amp;&amp;P!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?P:l.decorators;</span><span class="s1">return </span><span class="s0">r(C)?Math.min(n(C[</span><span class="s3">0</span><span class="s0">]),x):x}</span><span class="s1">function </span><span class="s0">s(l){</span><span class="s1">return </span><span class="s0">l.range?l.range[</span><span class="s3">1</span><span class="s0">]:l.end}</span><span class="s1">function </span><span class="s0">a(l,P){let p=n(l);</span><span class="s1">return </span><span class="s0">Number.isInteger(p)&amp;&amp;p===n(P)}</span><span class="s1">function </span><span class="s0">i(l,P){let p=s(l);</span><span class="s1">return </span><span class="s0">Number.isInteger(p)&amp;&amp;p===s(P)}</span><span class="s1">function </span><span class="s0">h(l,P){</span><span class="s1">return </span><span class="s0">a(l,P)&amp;&amp;i(l,P)}t.exports={locStart:n,locEnd:s,hasSameLocStart:a,hasSameLoc:h}}}),fr=q({</span><span class="s2">&quot;node_modules/angular-estree-parser/node_modules/lines-and-columns/build/index.js&quot;</span><span class="s0">(e){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;L(),e.__esModule=!</span><span class="s3">0</span><span class="s0">,e.LinesAndColumns=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">t=`</span>
<span class="s0">`,r=</span><span class="s2">&quot;</span><span class="s4">\r</span><span class="s2">&quot;</span><span class="s0">,n=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">function </span><span class="s0">s(a){</span><span class="s1">this</span><span class="s0">.string=a;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i=[</span><span class="s3">0</span><span class="s0">],h=</span><span class="s3">0</span><span class="s0">;h&lt;a.length;)</span><span class="s1">switch</span><span class="s0">(a[h]){</span><span class="s1">case </span><span class="s0">t:h+=t.length,i.push(h);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s0">r:h+=r.length,a[h]===t&amp;&amp;(h+=t.length),i.push(h);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:h++;</span><span class="s1">break</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.offsets=i}</span><span class="s1">return </span><span class="s0">s.prototype.locationForIndex=</span><span class="s1">function</span><span class="s0">(a){</span><span class="s1">if</span><span class="s0">(a&lt;</span><span class="s3">0</span><span class="s0">||a&gt;</span><span class="s1">this</span><span class="s0">.string.length)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i=</span><span class="s3">0</span><span class="s0">,h=</span><span class="s1">this</span><span class="s0">.offsets;h[i+</span><span class="s3">1</span><span class="s0">]&lt;=a;)i++;</span><span class="s1">var </span><span class="s0">l=a-h[i];</span><span class="s1">return</span><span class="s0">{line:i,column:l}},s.prototype.indexForLocation=</span><span class="s1">function</span><span class="s0">(a){</span><span class="s1">var </span><span class="s0">i=a.line,h=a.column;</span><span class="s1">return </span><span class="s0">i&lt;</span><span class="s3">0</span><span class="s0">||i&gt;=</span><span class="s1">this</span><span class="s0">.offsets.length||h&lt;</span><span class="s3">0</span><span class="s0">||h&gt;</span><span class="s1">this</span><span class="s0">.lengthOfLine(i)?</span><span class="s1">null</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.offsets[i]+h},s.prototype.lengthOfLine=</span><span class="s1">function</span><span class="s0">(a){</span><span class="s1">var </span><span class="s0">i=</span><span class="s1">this</span><span class="s0">.offsets[a],h=a===</span><span class="s1">this</span><span class="s0">.offsets.length-1?</span><span class="s1">this</span><span class="s0">.string.length:</span><span class="s1">this</span><span class="s0">.offsets[a+</span><span class="s3">1</span><span class="s0">];</span><span class="s1">return </span><span class="s0">h-i},s}();e.LinesAndColumns=n,e.</span><span class="s1">default</span><span class="s0">=n}}),gr=q({</span><span class="s2">&quot;node_modules/angular-estree-parser/lib/context.js&quot;</span><span class="s0">(e){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;L(),Object.defineProperty(e,</span><span class="s2">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s3">0</span><span class="s0">}),e.Context=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span><span class="s1">var </span><span class="s0">t=fr(),r=class{constructor(s){</span><span class="s1">this</span><span class="s0">.text=s,</span><span class="s1">this</span><span class="s0">.locator=</span><span class="s1">new </span><span class="s0">n(</span><span class="s1">this</span><span class="s0">.text)}};e.Context=r;</span><span class="s1">var </span><span class="s0">n=class{constructor(s){</span><span class="s1">this</span><span class="s0">._lineAndColumn=</span><span class="s1">new </span><span class="s0">t.</span><span class="s1">default</span><span class="s0">(s)}locationForIndex(s){let{line:a,column:i}=</span><span class="s1">this</span><span class="s0">._lineAndColumn.locationForIndex(s);</span><span class="s1">return</span><span class="s0">{line:a+</span><span class="s3">1</span><span class="s0">,column:i}}}}}),Je={};Xe(Je,{AST:()=&gt;k,ASTWithName:()=&gt;W,ASTWithSource:()=&gt;G,AbsoluteSourceSpan:()=&gt;U,AstMemoryEfficientTransformer:()=&gt;Ct,AstTransformer:()=&gt;Pt,Binary:()=&gt;B,BindingPipe:()=&gt;fe,BoundElementProperty:()=&gt;It,Chain:()=&gt;oe,Conditional:()=&gt;ce,EmptyExpr:()=&gt;K,ExpressionBinding:()=&gt;Ze,FunctionCall:()=&gt;Pe,ImplicitReceiver:()=&gt;Oe,Interpolation:()=&gt;me,KeyedRead:()=&gt;he,KeyedWrite:()=&gt;de,LiteralArray:()=&gt;ge,LiteralMap:()=&gt;ve,LiteralPrimitive:()=&gt;$,MethodCall:()=&gt;ye,NonNullAssert:()=&gt;Se,ParseSpan:()=&gt;V,ParsedEvent:()=&gt;At,ParsedProperty:()=&gt;Et,ParsedPropertyType:()=&gt;se,ParsedVariable:()=&gt;_t,ParserError:()=&gt;ae,PrefixNot:()=&gt;xe,PropertyRead:()=&gt;ne,PropertyWrite:()=&gt;ue,Quote:()=&gt;Le,RecursiveAstVisitor:()=&gt;et,SafeKeyedRead:()=&gt;pe,SafeMethodCall:()=&gt;we,SafePropertyRead:()=&gt;le,ThisReceiver:()=&gt;Ye,Unary:()=&gt;F,VariableBinding:()=&gt;Re});</span><span class="s1">var </span><span class="s0">ae,V,k,W,Le,K,Oe,Ye,oe,ce,ne,ue,le,he,pe,de,fe,$,ge,ve,me,B,F,xe,Se,ye,we,Pe,U,G,Re,Ze,et,Pt,Ct,Et,se,At,_t,It,tt=Y({</span><span class="s2">&quot;node_modules/@angular/compiler/esm2015/src/expression_parser/ast.js&quot;</span><span class="s0">(){L(),ae=class{constructor(e,t,r,n){</span><span class="s1">this</span><span class="s0">.input=t,</span><span class="s1">this</span><span class="s0">.errLocation=r,</span><span class="s1">this</span><span class="s0">.ctxLocation=n,</span><span class="s1">this</span><span class="s0">.message=`Parser Error: ${e} ${r} [${t}] </span><span class="s1">in </span><span class="s0">${n}`}},V=class{constructor(e,t){</span><span class="s1">this</span><span class="s0">.start=e,</span><span class="s1">this</span><span class="s0">.end=t}toAbsolute(e){</span><span class="s1">return new </span><span class="s0">U(e+</span><span class="s1">this</span><span class="s0">.start,e+</span><span class="s1">this</span><span class="s0">.end)}},k=class{constructor(e,t){</span><span class="s1">this</span><span class="s0">.span=e,</span><span class="s1">this</span><span class="s0">.sourceSpan=t}toString(){</span><span class="s1">return</span><span class="s2">&quot;AST&quot;</span><span class="s0">}},W=class extends k{constructor(e,t,r){super(e,t),</span><span class="s1">this</span><span class="s0">.nameSpan=r}},Le=class extends k{constructor(e,t,r,n,s){super(e,t),</span><span class="s1">this</span><span class="s0">.prefix=r,</span><span class="s1">this</span><span class="s0">.uninterpretedExpression=n,</span><span class="s1">this</span><span class="s0">.location=s}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitQuote(</span><span class="s1">this</span><span class="s0">,t)}toString(){</span><span class="s1">return</span><span class="s2">&quot;Quote&quot;</span><span class="s0">}},K=class extends k{visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">}},Oe=class extends k{visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitImplicitReceiver(</span><span class="s1">this</span><span class="s0">,t)}},Ye=class extends Oe{visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">r;</span><span class="s1">return</span><span class="s0">(r=e.visitThisReceiver)===</span><span class="s1">null</span><span class="s0">||r===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:r.call(e,</span><span class="s1">this</span><span class="s0">,t)}},oe=class extends k{constructor(e,t,r){super(e,t),</span><span class="s1">this</span><span class="s0">.expressions=r}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitChain(</span><span class="s1">this</span><span class="s0">,t)}},ce=class extends k{constructor(e,t,r,n,s){super(e,t),</span><span class="s1">this</span><span class="s0">.condition=r,</span><span class="s1">this</span><span class="s0">.trueExp=n,</span><span class="s1">this</span><span class="s0">.falseExp=s}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitConditional(</span><span class="s1">this</span><span class="s0">,t)}},ne=class extends W{constructor(e,t,r,n,s){super(e,t,r),</span><span class="s1">this</span><span class="s0">.receiver=n,</span><span class="s1">this</span><span class="s0">.name=s}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitPropertyRead(</span><span class="s1">this</span><span class="s0">,t)}},ue=class extends W{constructor(e,t,r,n,s,a){super(e,t,r),</span><span class="s1">this</span><span class="s0">.receiver=n,</span><span class="s1">this</span><span class="s0">.name=s,</span><span class="s1">this</span><span class="s0">.value=a}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitPropertyWrite(</span><span class="s1">this</span><span class="s0">,t)}},le=class extends W{constructor(e,t,r,n,s){super(e,t,r),</span><span class="s1">this</span><span class="s0">.receiver=n,</span><span class="s1">this</span><span class="s0">.name=s}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitSafePropertyRead(</span><span class="s1">this</span><span class="s0">,t)}},he=class extends k{constructor(e,t,r,n){super(e,t),</span><span class="s1">this</span><span class="s0">.receiver=r,</span><span class="s1">this</span><span class="s0">.key=n}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitKeyedRead(</span><span class="s1">this</span><span class="s0">,t)}},pe=class extends k{constructor(e,t,r,n){super(e,t),</span><span class="s1">this</span><span class="s0">.receiver=r,</span><span class="s1">this</span><span class="s0">.key=n}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitSafeKeyedRead(</span><span class="s1">this</span><span class="s0">,t)}},de=class extends k{constructor(e,t,r,n,s){super(e,t),</span><span class="s1">this</span><span class="s0">.receiver=r,</span><span class="s1">this</span><span class="s0">.key=n,</span><span class="s1">this</span><span class="s0">.value=s}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitKeyedWrite(</span><span class="s1">this</span><span class="s0">,t)}},fe=class extends W{constructor(e,t,r,n,s,a){super(e,t,a),</span><span class="s1">this</span><span class="s0">.exp=r,</span><span class="s1">this</span><span class="s0">.name=n,</span><span class="s1">this</span><span class="s0">.args=s}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitPipe(</span><span class="s1">this</span><span class="s0">,t)}},$=class extends k{constructor(e,t,r){super(e,t),</span><span class="s1">this</span><span class="s0">.value=r}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitLiteralPrimitive(</span><span class="s1">this</span><span class="s0">,t)}},ge=class extends k{constructor(e,t,r){super(e,t),</span><span class="s1">this</span><span class="s0">.expressions=r}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitLiteralArray(</span><span class="s1">this</span><span class="s0">,t)}},ve=class extends k{constructor(e,t,r,n){super(e,t),</span><span class="s1">this</span><span class="s0">.keys=r,</span><span class="s1">this</span><span class="s0">.values=n}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitLiteralMap(</span><span class="s1">this</span><span class="s0">,t)}},me=class extends k{constructor(e,t,r,n){super(e,t),</span><span class="s1">this</span><span class="s0">.strings=r,</span><span class="s1">this</span><span class="s0">.expressions=n}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitInterpolation(</span><span class="s1">this</span><span class="s0">,t)}},B=class extends k{constructor(e,t,r,n,s){super(e,t),</span><span class="s1">this</span><span class="s0">.operation=r,</span><span class="s1">this</span><span class="s0">.left=n,</span><span class="s1">this</span><span class="s0">.right=s}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitBinary(</span><span class="s1">this</span><span class="s0">,t)}},F=class extends B{constructor(e,t,r,n,s,a,i){super(e,t,s,a,i),</span><span class="s1">this</span><span class="s0">.operator=r,</span><span class="s1">this</span><span class="s0">.expr=n}static createMinus(e,t,r){</span><span class="s1">return new </span><span class="s0">F(e,t,</span><span class="s2">&quot;-&quot;</span><span class="s0">,r,</span><span class="s2">&quot;-&quot;</span><span class="s0">,</span><span class="s1">new </span><span class="s0">$(e,t,</span><span class="s3">0</span><span class="s0">),r)}static createPlus(e,t,r){</span><span class="s1">return new </span><span class="s0">F(e,t,</span><span class="s2">&quot;+&quot;</span><span class="s0">,r,</span><span class="s2">&quot;-&quot;</span><span class="s0">,r,</span><span class="s1">new </span><span class="s0">$(e,t,</span><span class="s3">0</span><span class="s0">))}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitUnary!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?e.visitUnary(</span><span class="s1">this</span><span class="s0">,t):e.visitBinary(</span><span class="s1">this</span><span class="s0">,t)}},xe=class extends k{constructor(e,t,r){super(e,t),</span><span class="s1">this</span><span class="s0">.expression=r}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitPrefixNot(</span><span class="s1">this</span><span class="s0">,t)}},Se=class extends k{constructor(e,t,r){super(e,t),</span><span class="s1">this</span><span class="s0">.expression=r}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitNonNullAssert(</span><span class="s1">this</span><span class="s0">,t)}},ye=class extends W{constructor(e,t,r,n,s,a,i){super(e,t,r),</span><span class="s1">this</span><span class="s0">.receiver=n,</span><span class="s1">this</span><span class="s0">.name=s,</span><span class="s1">this</span><span class="s0">.args=a,</span><span class="s1">this</span><span class="s0">.argumentSpan=i}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitMethodCall(</span><span class="s1">this</span><span class="s0">,t)}},we=class extends W{constructor(e,t,r,n,s,a,i){super(e,t,r),</span><span class="s1">this</span><span class="s0">.receiver=n,</span><span class="s1">this</span><span class="s0">.name=s,</span><span class="s1">this</span><span class="s0">.args=a,</span><span class="s1">this</span><span class="s0">.argumentSpan=i}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitSafeMethodCall(</span><span class="s1">this</span><span class="s0">,t)}},Pe=class extends k{constructor(e,t,r,n){super(e,t),</span><span class="s1">this</span><span class="s0">.target=r,</span><span class="s1">this</span><span class="s0">.args=n}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitFunctionCall(</span><span class="s1">this</span><span class="s0">,t)}},U=class{constructor(e,t){</span><span class="s1">this</span><span class="s0">.start=e,</span><span class="s1">this</span><span class="s0">.end=t}},G=class extends k{constructor(e,t,r,n,s){super(</span><span class="s1">new </span><span class="s0">V(</span><span class="s3">0</span><span class="s0">,t===</span><span class="s1">null</span><span class="s0">?</span><span class="s3">0</span><span class="s0">:t.length),</span><span class="s1">new </span><span class="s0">U(n,t===</span><span class="s1">null</span><span class="s0">?n:n+t.length)),</span><span class="s1">this</span><span class="s0">.ast=e,</span><span class="s1">this</span><span class="s0">.source=t,</span><span class="s1">this</span><span class="s0">.location=r,</span><span class="s1">this</span><span class="s0">.errors=s}visit(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.visitASTWithSource?e.visitASTWithSource(</span><span class="s1">this</span><span class="s0">,t):</span><span class="s1">this</span><span class="s0">.ast.visit(e,t)}toString(){</span><span class="s1">return</span><span class="s0">`${</span><span class="s1">this</span><span class="s0">.source} </span><span class="s1">in </span><span class="s0">${</span><span class="s1">this</span><span class="s0">.location}`}},Re=class{constructor(e,t,r){</span><span class="s1">this</span><span class="s0">.sourceSpan=e,</span><span class="s1">this</span><span class="s0">.key=t,</span><span class="s1">this</span><span class="s0">.value=r}},Ze=class{constructor(e,t,r){</span><span class="s1">this</span><span class="s0">.sourceSpan=e,</span><span class="s1">this</span><span class="s0">.key=t,</span><span class="s1">this</span><span class="s0">.value=r}},et=class{visit(e,t){e.visit(</span><span class="s1">this</span><span class="s0">,t)}visitUnary(e,t){</span><span class="s1">this</span><span class="s0">.visit(e.expr,t)}visitBinary(e,t){</span><span class="s1">this</span><span class="s0">.visit(e.left,t),</span><span class="s1">this</span><span class="s0">.visit(e.right,t)}visitChain(e,t){</span><span class="s1">this</span><span class="s0">.visitAll(e.expressions,t)}visitConditional(e,t){</span><span class="s1">this</span><span class="s0">.visit(e.condition,t),</span><span class="s1">this</span><span class="s0">.visit(e.trueExp,t),</span><span class="s1">this</span><span class="s0">.visit(e.falseExp,t)}visitPipe(e,t){</span><span class="s1">this</span><span class="s0">.visit(e.exp,t),</span><span class="s1">this</span><span class="s0">.visitAll(e.args,t)}visitFunctionCall(e,t){e.target&amp;&amp;</span><span class="s1">this</span><span class="s0">.visit(e.target,t),</span><span class="s1">this</span><span class="s0">.visitAll(e.args,t)}visitImplicitReceiver(e,t){}visitThisReceiver(e,t){}visitInterpolation(e,t){</span><span class="s1">this</span><span class="s0">.visitAll(e.expressions,t)}visitKeyedRead(e,t){</span><span class="s1">this</span><span class="s0">.visit(e.receiver,t),</span><span class="s1">this</span><span class="s0">.visit(e.key,t)}visitKeyedWrite(e,t){</span><span class="s1">this</span><span class="s0">.visit(e.receiver,t),</span><span class="s1">this</span><span class="s0">.visit(e.key,t),</span><span class="s1">this</span><span class="s0">.visit(e.value,t)}visitLiteralArray(e,t){</span><span class="s1">this</span><span class="s0">.visitAll(e.expressions,t)}visitLiteralMap(e,t){</span><span class="s1">this</span><span class="s0">.visitAll(e.values,t)}visitLiteralPrimitive(e,t){}visitMethodCall(e,t){</span><span class="s1">this</span><span class="s0">.visit(e.receiver,t),</span><span class="s1">this</span><span class="s0">.visitAll(e.args,t)}visitPrefixNot(e,t){</span><span class="s1">this</span><span class="s0">.visit(e.expression,t)}visitNonNullAssert(e,t){</span><span class="s1">this</span><span class="s0">.visit(e.expression,t)}visitPropertyRead(e,t){</span><span class="s1">this</span><span class="s0">.visit(e.receiver,t)}visitPropertyWrite(e,t){</span><span class="s1">this</span><span class="s0">.visit(e.receiver,t),</span><span class="s1">this</span><span class="s0">.visit(e.value,t)}visitSafePropertyRead(e,t){</span><span class="s1">this</span><span class="s0">.visit(e.receiver,t)}visitSafeMethodCall(e,t){</span><span class="s1">this</span><span class="s0">.visit(e.receiver,t),</span><span class="s1">this</span><span class="s0">.visitAll(e.args,t)}visitSafeKeyedRead(e,t){</span><span class="s1">this</span><span class="s0">.visit(e.receiver,t),</span><span class="s1">this</span><span class="s0">.visit(e.key,t)}visitQuote(e,t){}visitAll(e,t){</span><span class="s1">for</span><span class="s0">(let r of e)</span><span class="s1">this</span><span class="s0">.visit(r,t)}},Pt=class{visitImplicitReceiver(e,t){</span><span class="s1">return </span><span class="s0">e}visitThisReceiver(e,t){</span><span class="s1">return </span><span class="s0">e}visitInterpolation(e,t){</span><span class="s1">return new </span><span class="s0">me(e.span,e.sourceSpan,e.strings,</span><span class="s1">this</span><span class="s0">.visitAll(e.expressions))}visitLiteralPrimitive(e,t){</span><span class="s1">return new </span><span class="s0">$(e.span,e.sourceSpan,e.value)}visitPropertyRead(e,t){</span><span class="s1">return new </span><span class="s0">ne(e.span,e.sourceSpan,e.nameSpan,e.receiver.visit(</span><span class="s1">this</span><span class="s0">),e.name)}visitPropertyWrite(e,t){</span><span class="s1">return new </span><span class="s0">ue(e.span,e.sourceSpan,e.nameSpan,e.receiver.visit(</span><span class="s1">this</span><span class="s0">),e.name,e.value.visit(</span><span class="s1">this</span><span class="s0">))}visitSafePropertyRead(e,t){</span><span class="s1">return new </span><span class="s0">le(e.span,e.sourceSpan,e.nameSpan,e.receiver.visit(</span><span class="s1">this</span><span class="s0">),e.name)}visitMethodCall(e,t){</span><span class="s1">return new </span><span class="s0">ye(e.span,e.sourceSpan,e.nameSpan,e.receiver.visit(</span><span class="s1">this</span><span class="s0">),e.name,</span><span class="s1">this</span><span class="s0">.visitAll(e.args),e.argumentSpan)}visitSafeMethodCall(e,t){</span><span class="s1">return new </span><span class="s0">we(e.span,e.sourceSpan,e.nameSpan,e.receiver.visit(</span><span class="s1">this</span><span class="s0">),e.name,</span><span class="s1">this</span><span class="s0">.visitAll(e.args),e.argumentSpan)}visitFunctionCall(e,t){</span><span class="s1">return new </span><span class="s0">Pe(e.span,e.sourceSpan,e.target.visit(</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.visitAll(e.args))}visitLiteralArray(e,t){</span><span class="s1">return new </span><span class="s0">ge(e.span,e.sourceSpan,</span><span class="s1">this</span><span class="s0">.visitAll(e.expressions))}visitLiteralMap(e,t){</span><span class="s1">return new </span><span class="s0">ve(e.span,e.sourceSpan,e.keys,</span><span class="s1">this</span><span class="s0">.visitAll(e.values))}visitUnary(e,t){</span><span class="s1">switch</span><span class="s0">(e.operator){</span><span class="s1">case</span><span class="s2">&quot;+&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">F.createPlus(e.span,e.sourceSpan,e.expr.visit(</span><span class="s1">this</span><span class="s0">));</span><span class="s1">case</span><span class="s2">&quot;-&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">F.createMinus(e.span,e.sourceSpan,e.expr.visit(</span><span class="s1">this</span><span class="s0">));</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw new </span><span class="s0">Error(`Unknown unary operator ${e.operator}`)}}visitBinary(e,t){</span><span class="s1">return new </span><span class="s0">B(e.span,e.sourceSpan,e.operation,e.left.visit(</span><span class="s1">this</span><span class="s0">),e.right.visit(</span><span class="s1">this</span><span class="s0">))}visitPrefixNot(e,t){</span><span class="s1">return new </span><span class="s0">xe(e.span,e.sourceSpan,e.expression.visit(</span><span class="s1">this</span><span class="s0">))}visitNonNullAssert(e,t){</span><span class="s1">return new </span><span class="s0">Se(e.span,e.sourceSpan,e.expression.visit(</span><span class="s1">this</span><span class="s0">))}visitConditional(e,t){</span><span class="s1">return new </span><span class="s0">ce(e.span,e.sourceSpan,e.condition.visit(</span><span class="s1">this</span><span class="s0">),e.trueExp.visit(</span><span class="s1">this</span><span class="s0">),e.falseExp.visit(</span><span class="s1">this</span><span class="s0">))}visitPipe(e,t){</span><span class="s1">return new </span><span class="s0">fe(e.span,e.sourceSpan,e.exp.visit(</span><span class="s1">this</span><span class="s0">),e.name,</span><span class="s1">this</span><span class="s0">.visitAll(e.args),e.nameSpan)}visitKeyedRead(e,t){</span><span class="s1">return new </span><span class="s0">he(e.span,e.sourceSpan,e.receiver.visit(</span><span class="s1">this</span><span class="s0">),e.key.visit(</span><span class="s1">this</span><span class="s0">))}visitKeyedWrite(e,t){</span><span class="s1">return new </span><span class="s0">de(e.span,e.sourceSpan,e.receiver.visit(</span><span class="s1">this</span><span class="s0">),e.key.visit(</span><span class="s1">this</span><span class="s0">),e.value.visit(</span><span class="s1">this</span><span class="s0">))}visitAll(e){let t=[];</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s3">0</span><span class="s0">;r&lt;e.length;++r)t[r]=e[r].visit(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">return </span><span class="s0">t}visitChain(e,t){</span><span class="s1">return new </span><span class="s0">oe(e.span,e.sourceSpan,</span><span class="s1">this</span><span class="s0">.visitAll(e.expressions))}visitQuote(e,t){</span><span class="s1">return new </span><span class="s0">Le(e.span,e.sourceSpan,e.prefix,e.uninterpretedExpression,e.location)}visitSafeKeyedRead(e,t){</span><span class="s1">return new </span><span class="s0">pe(e.span,e.sourceSpan,e.receiver.visit(</span><span class="s1">this</span><span class="s0">),e.key.visit(</span><span class="s1">this</span><span class="s0">))}},Ct=class{visitImplicitReceiver(e,t){</span><span class="s1">return </span><span class="s0">e}visitThisReceiver(e,t){</span><span class="s1">return </span><span class="s0">e}visitInterpolation(e,t){let r=</span><span class="s1">this</span><span class="s0">.visitAll(e.expressions);</span><span class="s1">return </span><span class="s0">r!==e.expressions?</span><span class="s1">new </span><span class="s0">me(e.span,e.sourceSpan,e.strings,r):e}visitLiteralPrimitive(e,t){</span><span class="s1">return </span><span class="s0">e}visitPropertyRead(e,t){let r=e.receiver.visit(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r!==e.receiver?</span><span class="s1">new </span><span class="s0">ne(e.span,e.sourceSpan,e.nameSpan,r,e.name):e}visitPropertyWrite(e,t){let r=e.receiver.visit(</span><span class="s1">this</span><span class="s0">),n=e.value.visit(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r!==e.receiver||n!==e.value?</span><span class="s1">new </span><span class="s0">ue(e.span,e.sourceSpan,e.nameSpan,r,e.name,n):e}visitSafePropertyRead(e,t){let r=e.receiver.visit(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r!==e.receiver?</span><span class="s1">new </span><span class="s0">le(e.span,e.sourceSpan,e.nameSpan,r,e.name):e}visitMethodCall(e,t){let r=e.receiver.visit(</span><span class="s1">this</span><span class="s0">),n=</span><span class="s1">this</span><span class="s0">.visitAll(e.args);</span><span class="s1">return </span><span class="s0">r!==e.receiver||n!==e.args?</span><span class="s1">new </span><span class="s0">ye(e.span,e.sourceSpan,e.nameSpan,r,e.name,n,e.argumentSpan):e}visitSafeMethodCall(e,t){let r=e.receiver.visit(</span><span class="s1">this</span><span class="s0">),n=</span><span class="s1">this</span><span class="s0">.visitAll(e.args);</span><span class="s1">return </span><span class="s0">r!==e.receiver||n!==e.args?</span><span class="s1">new </span><span class="s0">we(e.span,e.sourceSpan,e.nameSpan,r,e.name,n,e.argumentSpan):e}visitFunctionCall(e,t){let r=e.target&amp;&amp;e.target.visit(</span><span class="s1">this</span><span class="s0">),n=</span><span class="s1">this</span><span class="s0">.visitAll(e.args);</span><span class="s1">return </span><span class="s0">r!==e.target||n!==e.args?</span><span class="s1">new </span><span class="s0">Pe(e.span,e.sourceSpan,r,n):e}visitLiteralArray(e,t){let r=</span><span class="s1">this</span><span class="s0">.visitAll(e.expressions);</span><span class="s1">return </span><span class="s0">r!==e.expressions?</span><span class="s1">new </span><span class="s0">ge(e.span,e.sourceSpan,r):e}visitLiteralMap(e,t){let r=</span><span class="s1">this</span><span class="s0">.visitAll(e.values);</span><span class="s1">return </span><span class="s0">r!==e.values?</span><span class="s1">new </span><span class="s0">ve(e.span,e.sourceSpan,e.keys,r):e}visitUnary(e,t){let r=e.expr.visit(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(r!==e.expr)</span><span class="s1">switch</span><span class="s0">(e.operator){</span><span class="s1">case</span><span class="s2">&quot;+&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">F.createPlus(e.span,e.sourceSpan,r);</span><span class="s1">case</span><span class="s2">&quot;-&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">F.createMinus(e.span,e.sourceSpan,r);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw new </span><span class="s0">Error(`Unknown unary operator ${e.operator}`)}</span><span class="s1">return </span><span class="s0">e}visitBinary(e,t){let r=e.left.visit(</span><span class="s1">this</span><span class="s0">),n=e.right.visit(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r!==e.left||n!==e.right?</span><span class="s1">new </span><span class="s0">B(e.span,e.sourceSpan,e.operation,r,n):e}visitPrefixNot(e,t){let r=e.expression.visit(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r!==e.expression?</span><span class="s1">new </span><span class="s0">xe(e.span,e.sourceSpan,r):e}visitNonNullAssert(e,t){let r=e.expression.visit(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r!==e.expression?</span><span class="s1">new </span><span class="s0">Se(e.span,e.sourceSpan,r):e}visitConditional(e,t){let r=e.condition.visit(</span><span class="s1">this</span><span class="s0">),n=e.trueExp.visit(</span><span class="s1">this</span><span class="s0">),s=e.falseExp.visit(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r!==e.condition||n!==e.trueExp||s!==e.falseExp?</span><span class="s1">new </span><span class="s0">ce(e.span,e.sourceSpan,r,n,s):e}visitPipe(e,t){let r=e.exp.visit(</span><span class="s1">this</span><span class="s0">),n=</span><span class="s1">this</span><span class="s0">.visitAll(e.args);</span><span class="s1">return </span><span class="s0">r!==e.exp||n!==e.args?</span><span class="s1">new </span><span class="s0">fe(e.span,e.sourceSpan,r,e.name,n,e.nameSpan):e}visitKeyedRead(e,t){let r=e.receiver.visit(</span><span class="s1">this</span><span class="s0">),n=e.key.visit(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r!==e.receiver||n!==e.key?</span><span class="s1">new </span><span class="s0">he(e.span,e.sourceSpan,r,n):e}visitKeyedWrite(e,t){let r=e.receiver.visit(</span><span class="s1">this</span><span class="s0">),n=e.key.visit(</span><span class="s1">this</span><span class="s0">),s=e.value.visit(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r!==e.receiver||n!==e.key||s!==e.value?</span><span class="s1">new </span><span class="s0">de(e.span,e.sourceSpan,r,n,s):e}visitAll(e){let t=[],r=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let n=</span><span class="s3">0</span><span class="s0">;n&lt;e.length;++n){let s=e[n],a=s.visit(</span><span class="s1">this</span><span class="s0">);t[n]=a,r=r||a!==s}</span><span class="s1">return </span><span class="s0">r?t:e}visitChain(e,t){let r=</span><span class="s1">this</span><span class="s0">.visitAll(e.expressions);</span><span class="s1">return </span><span class="s0">r!==e.expressions?</span><span class="s1">new </span><span class="s0">oe(e.span,e.sourceSpan,r):e}visitQuote(e,t){</span><span class="s1">return </span><span class="s0">e}visitSafeKeyedRead(e,t){let r=e.receiver.visit(</span><span class="s1">this</span><span class="s0">),n=e.key.visit(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r!==e.receiver||n!==e.key?</span><span class="s1">new </span><span class="s0">pe(e.span,e.sourceSpan,r,n):e}},Et=class{constructor(e,t,r,n,s,a){</span><span class="s1">this</span><span class="s0">.name=e,</span><span class="s1">this</span><span class="s0">.expression=t,</span><span class="s1">this</span><span class="s0">.type=r,</span><span class="s1">this</span><span class="s0">.sourceSpan=n,</span><span class="s1">this</span><span class="s0">.keySpan=s,</span><span class="s1">this</span><span class="s0">.valueSpan=a,</span><span class="s1">this</span><span class="s0">.isLiteral=</span><span class="s1">this</span><span class="s0">.type===se.LITERAL_ATTR,</span><span class="s1">this</span><span class="s0">.isAnimation=</span><span class="s1">this</span><span class="s0">.type===se.ANIMATION}},</span><span class="s1">function</span><span class="s0">(e){e[e.DEFAULT=</span><span class="s3">0</span><span class="s0">]=</span><span class="s2">&quot;DEFAULT&quot;</span><span class="s0">,e[e.LITERAL_ATTR=</span><span class="s3">1</span><span class="s0">]=</span><span class="s2">&quot;LITERAL_ATTR&quot;</span><span class="s0">,e[e.ANIMATION=</span><span class="s3">2</span><span class="s0">]=</span><span class="s2">&quot;ANIMATION&quot;</span><span class="s0">}(se||(se={})),At=class{constructor(e,t,r,n,s,a,i){</span><span class="s1">this</span><span class="s0">.name=e,</span><span class="s1">this</span><span class="s0">.targetOrPhase=t,</span><span class="s1">this</span><span class="s0">.type=r,</span><span class="s1">this</span><span class="s0">.handler=n,</span><span class="s1">this</span><span class="s0">.sourceSpan=s,</span><span class="s1">this</span><span class="s0">.handlerSpan=a,</span><span class="s1">this</span><span class="s0">.keySpan=i}},_t=class{constructor(e,t,r,n,s){</span><span class="s1">this</span><span class="s0">.name=e,</span><span class="s1">this</span><span class="s0">.value=t,</span><span class="s1">this</span><span class="s0">.sourceSpan=r,</span><span class="s1">this</span><span class="s0">.keySpan=n,</span><span class="s1">this</span><span class="s0">.valueSpan=s}},It=class{constructor(e,t,r,n,s,a,i,h){</span><span class="s1">this</span><span class="s0">.name=e,</span><span class="s1">this</span><span class="s0">.type=t,</span><span class="s1">this</span><span class="s0">.securityContext=r,</span><span class="s1">this</span><span class="s0">.value=n,</span><span class="s1">this</span><span class="s0">.unit=s,</span><span class="s1">this</span><span class="s0">.sourceSpan=a,</span><span class="s1">this</span><span class="s0">.keySpan=i,</span><span class="s1">this</span><span class="s0">.valueSpan=h}}}});</span><span class="s1">function </span><span class="s0">vr(e){</span><span class="s1">return </span><span class="s0">e&gt;=rt&amp;&amp;e&lt;=nt||e==dt}</span><span class="s1">function </span><span class="s0">Q(e){</span><span class="s1">return </span><span class="s0">Mt&lt;=e&amp;&amp;e&lt;=jt}</span><span class="s1">function </span><span class="s0">mr(e){</span><span class="s1">return </span><span class="s0">e&gt;=ht&amp;&amp;e&lt;=pt||e&gt;=ut&amp;&amp;e&lt;=lt}</span><span class="s1">function </span><span class="s0">mt(e){</span><span class="s1">return </span><span class="s0">e===at||e===st||e===Xt}</span><span class="s1">var </span><span class="s0">Ce,rt,Ot,kt,Nt,bt,nt,Lt,st,Rt,it,Tt,je,at,Ee,z,$t,ot,ee,ct,H,Te,X,te,Bt,ie,Kt,Fe,Mt,jt,ut,Ft,lt,Ae,Ut,re,Wt,Be,ht,Gt,Vt,qt,Qt,Dt,zt,Ht,pt,$e,Ue,_e,dt,Xt,Jt=Y({</span><span class="s2">&quot;node_modules/@angular/compiler/esm2015/src/chars.js&quot;</span><span class="s0">(){L(),Ce=</span><span class="s3">0</span><span class="s0">,rt=</span><span class="s3">9</span><span class="s0">,Ot=</span><span class="s3">10</span><span class="s0">,kt=</span><span class="s3">11</span><span class="s0">,Nt=</span><span class="s3">12</span><span class="s0">,bt=</span><span class="s3">13</span><span class="s0">,nt=</span><span class="s3">32</span><span class="s0">,Lt=</span><span class="s3">33</span><span class="s0">,st=</span><span class="s3">34</span><span class="s0">,Rt=</span><span class="s3">35</span><span class="s0">,it=</span><span class="s3">36</span><span class="s0">,Tt=</span><span class="s3">37</span><span class="s0">,je=</span><span class="s3">38</span><span class="s0">,at=</span><span class="s3">39</span><span class="s0">,Ee=</span><span class="s3">40</span><span class="s0">,z=</span><span class="s3">41</span><span class="s0">,$t=</span><span class="s3">42</span><span class="s0">,ot=</span><span class="s3">43</span><span class="s0">,ee=</span><span class="s3">44</span><span class="s0">,ct=</span><span class="s3">45</span><span class="s0">,H=</span><span class="s3">46</span><span class="s0">,Te=</span><span class="s3">47</span><span class="s0">,X=</span><span class="s3">58</span><span class="s0">,te=</span><span class="s3">59</span><span class="s0">,Bt=</span><span class="s3">60</span><span class="s0">,ie=</span><span class="s3">61</span><span class="s0">,Kt=</span><span class="s3">62</span><span class="s0">,Fe=</span><span class="s3">63</span><span class="s0">,Mt=</span><span class="s3">48</span><span class="s0">,jt=</span><span class="s3">57</span><span class="s0">,ut=</span><span class="s3">65</span><span class="s0">,Ft=</span><span class="s3">69</span><span class="s0">,lt=</span><span class="s3">90</span><span class="s0">,Ae=</span><span class="s3">91</span><span class="s0">,Ut=</span><span class="s3">92</span><span class="s0">,re=</span><span class="s3">93</span><span class="s0">,Wt=</span><span class="s3">94</span><span class="s0">,Be=</span><span class="s3">95</span><span class="s0">,ht=</span><span class="s3">97</span><span class="s0">,Gt=</span><span class="s3">101</span><span class="s0">,Vt=</span><span class="s3">102</span><span class="s0">,qt=</span><span class="s3">110</span><span class="s0">,Qt=</span><span class="s3">114</span><span class="s0">,Dt=</span><span class="s3">116</span><span class="s0">,zt=</span><span class="s3">117</span><span class="s0">,Ht=</span><span class="s3">118</span><span class="s0">,pt=</span><span class="s3">122</span><span class="s0">,$e=</span><span class="s3">123</span><span class="s0">,Ue=</span><span class="s3">124</span><span class="s0">,_e=</span><span class="s3">125</span><span class="s0">,dt=</span><span class="s3">160</span><span class="s0">,Xt=</span><span class="s3">96</span><span class="s0">}}),Yt={};Xe(Yt,{EOF:()=&gt;Ie,Lexer:()=&gt;er,Token:()=&gt;M,TokenType:()=&gt;S,isIdentifier:()=&gt;Zt});</span><span class="s1">function </span><span class="s0">xt(e,t,r){</span><span class="s1">return new </span><span class="s0">M(e,t,S.Character,r,String.fromCharCode(r))}</span><span class="s1">function </span><span class="s0">xr(e,t,r){</span><span class="s1">return new </span><span class="s0">M(e,t,S.Identifier,</span><span class="s3">0</span><span class="s0">,r)}</span><span class="s1">function </span><span class="s0">Sr(e,t,r){</span><span class="s1">return new </span><span class="s0">M(e,t,S.PrivateIdentifier,</span><span class="s3">0</span><span class="s0">,r)}</span><span class="s1">function </span><span class="s0">yr(e,t,r){</span><span class="s1">return new </span><span class="s0">M(e,t,S.Keyword,</span><span class="s3">0</span><span class="s0">,r)}</span><span class="s1">function </span><span class="s0">Ke(e,t,r){</span><span class="s1">return new </span><span class="s0">M(e,t,S.Operator,</span><span class="s3">0</span><span class="s0">,r)}</span><span class="s1">function </span><span class="s0">wr(e,t,r){</span><span class="s1">return new </span><span class="s0">M(e,t,S.String,</span><span class="s3">0</span><span class="s0">,r)}</span><span class="s1">function </span><span class="s0">Pr(e,t,r){</span><span class="s1">return new </span><span class="s0">M(e,t,S.Number,r,</span><span class="s2">&quot;&quot;</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">Cr(e,t,r){</span><span class="s1">return new </span><span class="s0">M(e,t,S.Error,</span><span class="s3">0</span><span class="s0">,r)}</span><span class="s1">function </span><span class="s0">We(e){</span><span class="s1">return </span><span class="s0">ht&lt;=e&amp;&amp;e&lt;=pt||ut&lt;=e&amp;&amp;e&lt;=lt||e==Be||e==it}</span><span class="s1">function </span><span class="s0">Zt(e){</span><span class="s1">if</span><span class="s0">(e.length==</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let t=</span><span class="s1">new </span><span class="s0">Ve(e);</span><span class="s1">if</span><span class="s0">(!We(t.peek))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(t.advance();t.peek!==Ce;){</span><span class="s1">if</span><span class="s0">(!Ge(t.peek))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;t.advance()}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">function </span><span class="s0">Ge(e){</span><span class="s1">return </span><span class="s0">mr(e)||Q(e)||e==Be||e==it}</span><span class="s1">function </span><span class="s0">Er(e){</span><span class="s1">return </span><span class="s0">e==Gt||e==Ft}</span><span class="s1">function </span><span class="s0">Ar(e){</span><span class="s1">return </span><span class="s0">e==ct||e==ot}</span><span class="s1">function </span><span class="s0">_r(e){</span><span class="s1">switch</span><span class="s0">(e){</span><span class="s1">case </span><span class="s0">qt:</span><span class="s1">return </span><span class="s0">Ot;</span><span class="s1">case </span><span class="s0">Vt:</span><span class="s1">return </span><span class="s0">Nt;</span><span class="s1">case </span><span class="s0">Qt:</span><span class="s1">return </span><span class="s0">bt;</span><span class="s1">case </span><span class="s0">Dt:</span><span class="s1">return </span><span class="s0">rt;</span><span class="s1">case </span><span class="s0">Ht:</span><span class="s1">return </span><span class="s0">kt;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e}}</span><span class="s1">function </span><span class="s0">Ir(e){let t=parseInt(e);</span><span class="s1">if</span><span class="s0">(isNaN(t))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Invalid integer literal when parsing &quot;</span><span class="s0">+e);</span><span class="s1">return </span><span class="s0">t}</span><span class="s1">var </span><span class="s0">S,St,er,M,Ie,Ve,tr=Y({</span><span class="s2">&quot;node_modules/@angular/compiler/esm2015/src/expression_parser/lexer.js&quot;</span><span class="s0">(){L(),Jt(),</span><span class="s1">function</span><span class="s0">(e){e[e.Character=</span><span class="s3">0</span><span class="s0">]=</span><span class="s2">&quot;Character&quot;</span><span class="s0">,e[e.Identifier=</span><span class="s3">1</span><span class="s0">]=</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">,e[e.PrivateIdentifier=</span><span class="s3">2</span><span class="s0">]=</span><span class="s2">&quot;PrivateIdentifier&quot;</span><span class="s0">,e[e.Keyword=</span><span class="s3">3</span><span class="s0">]=</span><span class="s2">&quot;Keyword&quot;</span><span class="s0">,e[e.String=</span><span class="s3">4</span><span class="s0">]=</span><span class="s2">&quot;String&quot;</span><span class="s0">,e[e.Operator=</span><span class="s3">5</span><span class="s0">]=</span><span class="s2">&quot;Operator&quot;</span><span class="s0">,e[e.Number=</span><span class="s3">6</span><span class="s0">]=</span><span class="s2">&quot;Number&quot;</span><span class="s0">,e[e.Error=</span><span class="s3">7</span><span class="s0">]=</span><span class="s2">&quot;Error&quot;</span><span class="s0">}(S||(S={})),St=[</span><span class="s2">&quot;var&quot;</span><span class="s0">,</span><span class="s2">&quot;let&quot;</span><span class="s0">,</span><span class="s2">&quot;as&quot;</span><span class="s0">,</span><span class="s2">&quot;null&quot;</span><span class="s0">,</span><span class="s2">&quot;undefined&quot;</span><span class="s0">,</span><span class="s2">&quot;true&quot;</span><span class="s0">,</span><span class="s2">&quot;false&quot;</span><span class="s0">,</span><span class="s2">&quot;if&quot;</span><span class="s0">,</span><span class="s2">&quot;else&quot;</span><span class="s0">,</span><span class="s2">&quot;this&quot;</span><span class="s0">],er=class{tokenize(e){let t=</span><span class="s1">new </span><span class="s0">Ve(e),r=[],n=t.scanToken();</span><span class="s1">for</span><span class="s0">(;n!=</span><span class="s1">null</span><span class="s0">;)r.push(n),n=t.scanToken();</span><span class="s1">return </span><span class="s0">r}},M=class{constructor(e,t,r,n,s){</span><span class="s1">this</span><span class="s0">.index=e,</span><span class="s1">this</span><span class="s0">.end=t,</span><span class="s1">this</span><span class="s0">.type=r,</span><span class="s1">this</span><span class="s0">.numValue=n,</span><span class="s1">this</span><span class="s0">.strValue=s}isCharacter(e){</span><span class="s1">return this</span><span class="s0">.type==S.Character&amp;&amp;</span><span class="s1">this</span><span class="s0">.numValue==e}isNumber(){</span><span class="s1">return this</span><span class="s0">.type==S.Number}isString(){</span><span class="s1">return this</span><span class="s0">.type==S.String}isOperator(e){</span><span class="s1">return this</span><span class="s0">.type==S.Operator&amp;&amp;</span><span class="s1">this</span><span class="s0">.strValue==e}isIdentifier(){</span><span class="s1">return this</span><span class="s0">.type==S.Identifier}isPrivateIdentifier(){</span><span class="s1">return this</span><span class="s0">.type==S.PrivateIdentifier}isKeyword(){</span><span class="s1">return this</span><span class="s0">.type==S.Keyword}isKeywordLet(){</span><span class="s1">return this</span><span class="s0">.type==S.Keyword&amp;&amp;</span><span class="s1">this</span><span class="s0">.strValue==</span><span class="s2">&quot;let&quot;</span><span class="s0">}isKeywordAs(){</span><span class="s1">return this</span><span class="s0">.type==S.Keyword&amp;&amp;</span><span class="s1">this</span><span class="s0">.strValue==</span><span class="s2">&quot;as&quot;</span><span class="s0">}isKeywordNull(){</span><span class="s1">return this</span><span class="s0">.type==S.Keyword&amp;&amp;</span><span class="s1">this</span><span class="s0">.strValue==</span><span class="s2">&quot;null&quot;</span><span class="s0">}isKeywordUndefined(){</span><span class="s1">return this</span><span class="s0">.type==S.Keyword&amp;&amp;</span><span class="s1">this</span><span class="s0">.strValue==</span><span class="s2">&quot;undefined&quot;</span><span class="s0">}isKeywordTrue(){</span><span class="s1">return this</span><span class="s0">.type==S.Keyword&amp;&amp;</span><span class="s1">this</span><span class="s0">.strValue==</span><span class="s2">&quot;true&quot;</span><span class="s0">}isKeywordFalse(){</span><span class="s1">return this</span><span class="s0">.type==S.Keyword&amp;&amp;</span><span class="s1">this</span><span class="s0">.strValue==</span><span class="s2">&quot;false&quot;</span><span class="s0">}isKeywordThis(){</span><span class="s1">return this</span><span class="s0">.type==S.Keyword&amp;&amp;</span><span class="s1">this</span><span class="s0">.strValue==</span><span class="s2">&quot;this&quot;</span><span class="s0">}isError(){</span><span class="s1">return this</span><span class="s0">.type==S.Error}toNumber(){</span><span class="s1">return this</span><span class="s0">.type==S.Number?</span><span class="s1">this</span><span class="s0">.numValue:-</span><span class="s3">1</span><span class="s0">}toString(){</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.type){</span><span class="s1">case </span><span class="s0">S.Character:</span><span class="s1">case </span><span class="s0">S.Identifier:</span><span class="s1">case </span><span class="s0">S.Keyword:</span><span class="s1">case </span><span class="s0">S.Operator:</span><span class="s1">case </span><span class="s0">S.PrivateIdentifier:</span><span class="s1">case </span><span class="s0">S.String:</span><span class="s1">case </span><span class="s0">S.Error:</span><span class="s1">return this</span><span class="s0">.strValue;</span><span class="s1">case </span><span class="s0">S.Number:</span><span class="s1">return this</span><span class="s0">.numValue.toString();</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return null</span><span class="s0">}}},Ie=</span><span class="s1">new </span><span class="s0">M(-</span><span class="s3">1</span><span class="s0">,-</span><span class="s3">1</span><span class="s0">,S.Character,</span><span class="s3">0</span><span class="s0">,</span><span class="s2">&quot;&quot;</span><span class="s0">),Ve=class{constructor(e){</span><span class="s1">this</span><span class="s0">.input=e,</span><span class="s1">this</span><span class="s0">.peek=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.index=-</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.length=e.length,</span><span class="s1">this</span><span class="s0">.advance()}advance(){</span><span class="s1">this</span><span class="s0">.peek=++</span><span class="s1">this</span><span class="s0">.index&gt;=</span><span class="s1">this</span><span class="s0">.length?Ce:</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.index)}scanToken(){let e=</span><span class="s1">this</span><span class="s0">.input,t=</span><span class="s1">this</span><span class="s0">.length,r=</span><span class="s1">this</span><span class="s0">.peek,n=</span><span class="s1">this</span><span class="s0">.index;</span><span class="s1">for</span><span class="s0">(;r&lt;=nt;)</span><span class="s1">if</span><span class="s0">(++n&gt;=t){r=Ce;</span><span class="s1">break</span><span class="s0">}</span><span class="s1">else </span><span class="s0">r=e.charCodeAt(n);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.peek=r,</span><span class="s1">this</span><span class="s0">.index=n,n&gt;=t)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(We(r))</span><span class="s1">return this</span><span class="s0">.scanIdentifier();</span><span class="s1">if</span><span class="s0">(Q(r))</span><span class="s1">return this</span><span class="s0">.scanNumber(n);let s=n;</span><span class="s1">switch</span><span class="s0">(r){</span><span class="s1">case </span><span class="s0">H:</span><span class="s1">return this</span><span class="s0">.advance(),Q(</span><span class="s1">this</span><span class="s0">.peek)?</span><span class="s1">this</span><span class="s0">.scanNumber(s):xt(s,</span><span class="s1">this</span><span class="s0">.index,H);</span><span class="s1">case </span><span class="s0">Ee:</span><span class="s1">case </span><span class="s0">z:</span><span class="s1">case </span><span class="s0">$e:</span><span class="s1">case </span><span class="s0">_e:</span><span class="s1">case </span><span class="s0">Ae:</span><span class="s1">case </span><span class="s0">re:</span><span class="s1">case </span><span class="s0">ee:</span><span class="s1">case </span><span class="s0">X:</span><span class="s1">case </span><span class="s0">te:</span><span class="s1">return this</span><span class="s0">.scanCharacter(s,r);</span><span class="s1">case </span><span class="s0">at:</span><span class="s1">case </span><span class="s0">st:</span><span class="s1">return this</span><span class="s0">.scanString();</span><span class="s1">case </span><span class="s0">Rt:</span><span class="s1">return this</span><span class="s0">.scanPrivateIdentifier();</span><span class="s1">case </span><span class="s0">ot:</span><span class="s1">case </span><span class="s0">ct:</span><span class="s1">case </span><span class="s0">$t:</span><span class="s1">case </span><span class="s0">Te:</span><span class="s1">case </span><span class="s0">Tt:</span><span class="s1">case </span><span class="s0">Wt:</span><span class="s1">return this</span><span class="s0">.scanOperator(s,String.fromCharCode(r));</span><span class="s1">case </span><span class="s0">Fe:</span><span class="s1">return this</span><span class="s0">.scanQuestion(s);</span><span class="s1">case </span><span class="s0">Bt:</span><span class="s1">case </span><span class="s0">Kt:</span><span class="s1">return this</span><span class="s0">.scanComplexOperator(s,String.fromCharCode(r),ie,</span><span class="s2">&quot;=&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">Lt:</span><span class="s1">case </span><span class="s0">ie:</span><span class="s1">return this</span><span class="s0">.scanComplexOperator(s,String.fromCharCode(r),ie,</span><span class="s2">&quot;=&quot;</span><span class="s0">,ie,</span><span class="s2">&quot;=&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">je:</span><span class="s1">return this</span><span class="s0">.scanComplexOperator(s,</span><span class="s2">&quot;&amp;&quot;</span><span class="s0">,je,</span><span class="s2">&quot;&amp;&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">Ue:</span><span class="s1">return this</span><span class="s0">.scanComplexOperator(s,</span><span class="s2">&quot;|&quot;</span><span class="s0">,Ue,</span><span class="s2">&quot;|&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s0">dt:</span><span class="s1">for</span><span class="s0">(;vr(</span><span class="s1">this</span><span class="s0">.peek);)</span><span class="s1">this</span><span class="s0">.advance();</span><span class="s1">return this</span><span class="s0">.scanToken()}</span><span class="s1">return this</span><span class="s0">.advance(),</span><span class="s1">this</span><span class="s0">.error(`Unexpected character [${String.fromCharCode(r)}]`,</span><span class="s3">0</span><span class="s0">)}scanCharacter(e,t){</span><span class="s1">return this</span><span class="s0">.advance(),xt(e,</span><span class="s1">this</span><span class="s0">.index,t)}scanOperator(e,t){</span><span class="s1">return this</span><span class="s0">.advance(),Ke(e,</span><span class="s1">this</span><span class="s0">.index,t)}scanComplexOperator(e,t,r,n,s,a){</span><span class="s1">this</span><span class="s0">.advance();let i=t;</span><span class="s1">return this</span><span class="s0">.peek==r&amp;&amp;(</span><span class="s1">this</span><span class="s0">.advance(),i+=n),s!=</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.peek==s&amp;&amp;(</span><span class="s1">this</span><span class="s0">.advance(),i+=a),Ke(e,</span><span class="s1">this</span><span class="s0">.index,i)}scanIdentifier(){let e=</span><span class="s1">this</span><span class="s0">.index;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.advance();Ge(</span><span class="s1">this</span><span class="s0">.peek);)</span><span class="s1">this</span><span class="s0">.advance();let t=</span><span class="s1">this</span><span class="s0">.input.substring(e,</span><span class="s1">this</span><span class="s0">.index);</span><span class="s1">return </span><span class="s0">St.indexOf(t)&gt;-</span><span class="s3">1</span><span class="s0">?yr(e,</span><span class="s1">this</span><span class="s0">.index,t):xr(e,</span><span class="s1">this</span><span class="s0">.index,t)}scanPrivateIdentifier(){let e=</span><span class="s1">this</span><span class="s0">.index;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.advance(),!We(</span><span class="s1">this</span><span class="s0">.peek))</span><span class="s1">return this</span><span class="s0">.error(</span><span class="s2">&quot;Invalid character [#]&quot;</span><span class="s0">,-</span><span class="s3">1</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(;Ge(</span><span class="s1">this</span><span class="s0">.peek);)</span><span class="s1">this</span><span class="s0">.advance();let t=</span><span class="s1">this</span><span class="s0">.input.substring(e,</span><span class="s1">this</span><span class="s0">.index);</span><span class="s1">return </span><span class="s0">Sr(e,</span><span class="s1">this</span><span class="s0">.index,t)}scanNumber(e){let t=</span><span class="s1">this</span><span class="s0">.index===e,r=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.advance();;){</span><span class="s1">if</span><span class="s0">(!Q(</span><span class="s1">this</span><span class="s0">.peek))</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.peek===Be){</span><span class="s1">if</span><span class="s0">(!Q(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.index-1))||!Q(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.index+</span><span class="s3">1</span><span class="s0">)))</span><span class="s1">return this</span><span class="s0">.error(</span><span class="s2">&quot;Invalid numeric separator&quot;</span><span class="s0">,</span><span class="s3">0</span><span class="s0">);r=!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.peek===H)t=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(Er(</span><span class="s1">this</span><span class="s0">.peek)){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.advance(),Ar(</span><span class="s1">this</span><span class="s0">.peek)&amp;&amp;</span><span class="s1">this</span><span class="s0">.advance(),!Q(</span><span class="s1">this</span><span class="s0">.peek))</span><span class="s1">return this</span><span class="s0">.error(</span><span class="s2">&quot;Invalid exponent&quot;</span><span class="s0">,-</span><span class="s3">1</span><span class="s0">);t=!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">else break</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.advance()}let n=</span><span class="s1">this</span><span class="s0">.input.substring(e,</span><span class="s1">this</span><span class="s0">.index);r&amp;&amp;(n=n.replace(/_/g,</span><span class="s2">&quot;&quot;</span><span class="s0">));let s=t?Ir(n):parseFloat(n);</span><span class="s1">return </span><span class="s0">Pr(e,</span><span class="s1">this</span><span class="s0">.index,s)}scanString(){let e=</span><span class="s1">this</span><span class="s0">.index,t=</span><span class="s1">this</span><span class="s0">.peek;</span><span class="s1">this</span><span class="s0">.advance();let r=</span><span class="s2">&quot;&quot;</span><span class="s0">,n=</span><span class="s1">this</span><span class="s0">.index,s=</span><span class="s1">this</span><span class="s0">.input;</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.peek!=t;)</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.peek==Ut){r+=s.substring(n,</span><span class="s1">this</span><span class="s0">.index),</span><span class="s1">this</span><span class="s0">.advance();let i;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.peek=</span><span class="s1">this</span><span class="s0">.peek,</span><span class="s1">this</span><span class="s0">.peek==zt){let h=s.substring(</span><span class="s1">this</span><span class="s0">.index+</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.index+</span><span class="s3">5</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(/^[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">a-f]+$/i.test(h))i=parseInt(h,</span><span class="s3">16</span><span class="s0">);</span><span class="s1">else return this</span><span class="s0">.error(`Invalid unicode escape [\\u${h}]`,</span><span class="s3">0</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let l=</span><span class="s3">0</span><span class="s0">;l&lt;</span><span class="s3">5</span><span class="s0">;l++)</span><span class="s1">this</span><span class="s0">.advance()}</span><span class="s1">else </span><span class="s0">i=_r(</span><span class="s1">this</span><span class="s0">.peek),</span><span class="s1">this</span><span class="s0">.advance();r+=String.fromCharCode(i),n=</span><span class="s1">this</span><span class="s0">.index}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.peek==Ce)</span><span class="s1">return this</span><span class="s0">.error(</span><span class="s2">&quot;Unterminated quote&quot;</span><span class="s0">,</span><span class="s3">0</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.advance()}let a=s.substring(n,</span><span class="s1">this</span><span class="s0">.index);</span><span class="s1">return this</span><span class="s0">.advance(),wr(e,</span><span class="s1">this</span><span class="s0">.index,r+a)}scanQuestion(e){</span><span class="s1">this</span><span class="s0">.advance();let t=</span><span class="s2">&quot;?&quot;</span><span class="s0">;</span><span class="s1">return</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.peek===Fe||</span><span class="s1">this</span><span class="s0">.peek===H)&amp;&amp;(t+=</span><span class="s1">this</span><span class="s0">.peek===H?</span><span class="s2">&quot;.&quot;</span><span class="s0">:</span><span class="s2">&quot;?&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.advance()),Ke(e,</span><span class="s1">this</span><span class="s0">.index,t)}error(e,t){let r=</span><span class="s1">this</span><span class="s0">.index+t;</span><span class="s1">return </span><span class="s0">Cr(r,</span><span class="s1">this</span><span class="s0">.index,`Lexer Error: ${e} at column ${r} </span><span class="s1">in </span><span class="s0">expression [${</span><span class="s1">this</span><span class="s0">.input}]`)}}}});</span><span class="s1">function </span><span class="s0">Or(e,t){</span><span class="s1">if</span><span class="s0">(t!=</span><span class="s1">null</span><span class="s0">&amp;&amp;!(Array.isArray(t)&amp;&amp;t.length==</span><span class="s3">2</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(`Expected </span><span class="s2">'${e}' </span><span class="s0">to be an array, [start, end].`);</span><span class="s1">if</span><span class="s0">(t!=</span><span class="s1">null</span><span class="s0">){let r=t[</span><span class="s3">0</span><span class="s0">],n=t[</span><span class="s3">1</span><span class="s0">];rr.forEach(s=&gt;{</span><span class="s1">if</span><span class="s0">(s.test(r)||s.test(n))</span><span class="s1">throw new </span><span class="s0">Error(`[</span><span class="s2">'${r}'</span><span class="s0">, </span><span class="s2">'${n}'</span><span class="s0">] contains unusable interpolation symbol.`)})}}</span><span class="s1">var </span><span class="s0">rr,kr=Y({</span><span class="s2">&quot;node_modules/@angular/compiler/esm2015/src/assertions.js&quot;</span><span class="s0">(){L(),rr=[/^\s*$/,/[&lt;&gt;]/,/^[{}]$/,/&amp;(#|[a-z])/i,/^\/\</span><span class="s5">//]}}),Me,J,Nr=Y({&quot;node_modules/@angular/compiler/esm2015/src/ml_parser/interpolation_config.js&quot;(){L(),kr(),Me=class{constructor(e,t){this.start=e,this.end=t}static fromArray(e){return e?(Or(&quot;interpolation&quot;,e),new Me(e[0],e[1])):J}},J=new Me(&quot;{{&quot;,&quot;}}&quot;)}}),nr={};Xe(nr,{IvyParser:()=&gt;sr,Parser:()=&gt;De,SplitInterpolation:()=&gt;qe,TemplateBindingParseResult:()=&gt;Qe,_ParseAST:()=&gt;D});var qe,Qe,De,sr,Z,D,yt,wt,br=Y({&quot;node_modules/@angular/compiler/esm2015/src/expression_parser/parser.js&quot;(){L(),Jt(),Nr(),tt(),tr(),qe=class{constructor(e,t,r){this.strings=e,this.expressions=t,this.offsets=r}},Qe=class{constructor(e,t,r){this.templateBindings=e,this.warnings=t,this.errors=r}},De=class{constructor(e){this._lexer=e,this.errors=[],this.simpleExpressionChecker=yt}parseAction(e,t,r){let n=arguments.length&gt;3&amp;&amp;arguments[3]!==void 0?arguments[3]:J;this._checkNoInterpolation(e,t,n);let s=this._stripComments(e),a=this._lexer.tokenize(this._stripComments(e)),i=new D(e,t,r,a,s.length,!0,this.errors,e.length-s.length).parseChain();return new G(i,e,t,r,this.errors)}parseBinding(e,t,r){let n=arguments.length&gt;3&amp;&amp;arguments[3]!==void 0?arguments[3]:J,s=this._parseBindingAst(e,t,r,n);return new G(s,e,t,r,this.errors)}checkSimpleExpression(e){let t=new this.simpleExpressionChecker;return e.visit(t),t.errors}parseSimpleBinding(e,t,r){let n=arguments.length&gt;3&amp;&amp;arguments[3]!==void 0?arguments[3]:J,s=this._parseBindingAst(e,t,r,n),a=this.checkSimpleExpression(s);return a.length&gt;0&amp;&amp;this._reportError(`Host binding expression cannot contain ${a.join(&quot; &quot;)}`,e,t),new G(s,e,t,r,this.errors)}_reportError(e,t,r,n){this.errors.push(new ae(e,t,r,n))}_parseBindingAst(e,t,r,n){let s=this._parseQuote(e,t,r);if(s!=null)return s;this._checkNoInterpolation(e,t,n);let a=this._stripComments(e),i=this._lexer.tokenize(a);return new D(e,t,r,i,a.length,!1,this.errors,e.length-a.length).parseChain()}_parseQuote(e,t,r){if(e==null)return null;let n=e.indexOf(&quot;:&quot;);if(n==-1)return null;let s=e.substring(0,n).trim();if(!Zt(s))return null;let a=e.substring(n+1),i=new V(0,e.length);return new Le(i,i.toAbsolute(r),s,a,t)}parseTemplateBindings(e,t,r,n,s){let a=this._lexer.tokenize(t);return new D(t,r,s,a,t.length,!1,this.errors,0).parseTemplateBindings({source:e,span:new U(n,n+e.length)})}parseInterpolation(e,t,r){let n=arguments.length&gt;3&amp;&amp;arguments[3]!==void 0?arguments[3]:J,{strings:s,expressions:a,offsets:i}=this.splitInterpolation(e,t,n);if(a.length===0)return null;let h=[];for(let l=0;l&lt;a.length;++l){let P=a[l].text,p=this._stripComments(P),x=this._lexer.tokenize(p),C=new D(e,t,r,x,p.length,!1,this.errors,i[l]+(P.length-p.length)).parseChain();h.push(C)}return this.createInterpolationAst(s.map(l=&gt;l.text),h,e,t,r)}parseInterpolationExpression(e,t,r){let n=this._stripComments(e),s=this._lexer.tokenize(n),a=new D(e,t,r,s,n.length,!1,this.errors,0).parseChain(),i=[&quot;&quot;,&quot;&quot;];return this.createInterpolationAst(i,[a],e,t,r)}createInterpolationAst(e,t,r,n,s){let a=new V(0,r.length),i=new me(a,a.toAbsolute(s),e,t);return new G(i,r,n,s,this.errors)}splitInterpolation(e,t){let r=arguments.length&gt;2&amp;&amp;arguments[2]!==void 0?arguments[2]:J,n=[],s=[],a=[],i=0,h=!1,l=!1,{start:P,end:p}=r;for(;i&lt;e.length;)if(h){let x=i,C=x+P.length,b=this._getInterpolationEndIndex(e,p,C);if(b===-1){h=!1,l=!0;break}let _=b+p.length,R=e.substring(C,b);R.trim().length===0&amp;&amp;this._reportError(&quot;Blank expressions are not allowed in interpolated strings&quot;,e,`at column ${i} in`,t),s.push({text:R,start:x,end:_}),a.push(C),i=_,h=!1}else{let x=i;i=e.indexOf(P,i),i===-1&amp;&amp;(i=e.length);let C=e.substring(x,i);n.push({text:C,start:x,end:i}),h=!0}if(!h)if(l){let x=n[n.length-1];x.text+=e.substring(i),x.end=e.length}else n.push({text:e.substring(i),start:i,end:e.length});return new qe(n,s,a)}wrapLiteralPrimitive(e,t,r){let n=new V(0,e==null?0:e.length);return new G(new $(n,n.toAbsolute(r),e),e,t,r,this.errors)}_stripComments(e){let t=this._commentStart(e);return t!=null?e.substring(0,t).trim():e}_commentStart(e){let t=null;for(let r=0;r&lt;e.length-1;r++){let n=e.charCodeAt(r),s=e.charCodeAt(r+1);if(n===Te&amp;&amp;s==Te&amp;&amp;t==null)return r;t===n?t=null:t==null&amp;&amp;mt(n)&amp;&amp;(t=n)}return null}_checkNoInterpolation(e,t,r){let{start:n,end:s}=r,a=-1,i=-1;for(let h of this._forEachUnquotedChar(e,0))if(a===-1)e.startsWith(n)&amp;&amp;(a=h);else if(i=this._getInterpolationEndIndex(e,s,h),i&gt;-1)break;a&gt;-1&amp;&amp;i&gt;-1&amp;&amp;this._reportError(`Got interpolation (${n}${s}) where expression was expected`,e,`at column ${a} in`,t)}_getInterpolationEndIndex(e,t,r){for(let n of this._forEachUnquotedChar(e,r)){if(e.startsWith(t,n))return n;if(e.startsWith(&quot;//&quot;,n))return e.indexOf(t,n)}return-1}*_forEachUnquotedChar(e,t){let r=null,n=0;for(let s=t;s&lt;e.length;s++){let a=e[s];mt(e.charCodeAt(s))&amp;&amp;(r===null||r===a)&amp;&amp;n%2===0?r=r===null?a:null:r===null&amp;&amp;(yield s),n=a===&quot;\\&quot;?n+1:0}}},sr=class extends De{constructor(){super(...arguments),this.simpleExpressionChecker=wt}},function(e){e[e.None=0]=&quot;None&quot;,e[e.Writable=1]=&quot;Writable&quot;}(Z||(Z={})),D=class{constructor(e,t,r,n,s,a,i,h){this.input=e,this.location=t,this.absoluteOffset=r,this.tokens=n,this.inputLength=s,this.parseAction=a,this.errors=i,this.offset=h,this.rparensExpected=0,this.rbracketsExpected=0,this.rbracesExpected=0,this.context=Z.None,this.sourceSpanCache=new Map,this.index=0}peek(e){let t=this.index+e;return t&lt;this.tokens.length?this.tokens[t]:Ie}get next(){return this.peek(0)}get atEOF(){return this.index&gt;=this.tokens.length}get inputIndex(){return this.atEOF?this.currentEndIndex:this.next.index+this.offset}get currentEndIndex(){return this.index&gt;0?this.peek(-1).end+this.offset:this.tokens.length===0?this.inputLength+this.offset:this.next.index+this.offset}get currentAbsoluteOffset(){return this.absoluteOffset+this.inputIndex}span(e,t){let r=this.currentEndIndex;if(t!==void 0&amp;&amp;t&gt;this.currentEndIndex&amp;&amp;(r=t),e&gt;r){let n=r;r=e,e=n}return new V(e,r)}sourceSpan(e,t){let r=`${e}@${this.inputIndex}:${t}`;return this.sourceSpanCache.has(r)||this.sourceSpanCache.set(r,this.span(e,t).toAbsolute(this.absoluteOffset)),this.sourceSpanCache.get(r)}advance(){this.index++}withContext(e,t){this.context|=e;let r=t();return this.context^=e,r}consumeOptionalCharacter(e){return this.next.isCharacter(e)?(this.advance(),!0):!1}peekKeywordLet(){return this.next.isKeywordLet()}peekKeywordAs(){return this.next.isKeywordAs()}expectCharacter(e){this.consumeOptionalCharacter(e)||this.error(`Missing expected ${String.fromCharCode(e)}`)}consumeOptionalOperator(e){return this.next.isOperator(e)?(this.advance(),!0):!1}expectOperator(e){this.consumeOptionalOperator(e)||this.error(`Missing expected operator ${e}`)}prettyPrintToken(e){return e===Ie?&quot;end of input&quot;:`token ${e}`}expectIdentifierOrKeyword(){let e=this.next;return!e.isIdentifier()&amp;&amp;!e.isKeyword()?(e.isPrivateIdentifier()?this._reportErrorForPrivateIdentifier(e,&quot;expected identifier or keyword&quot;):this.error(`Unexpected ${this.prettyPrintToken(e)}, expected identifier or keyword`),null):(this.advance(),e.toString())}expectIdentifierOrKeywordOrString(){let e=this.next;return!e.isIdentifier()&amp;&amp;!e.isKeyword()&amp;&amp;!e.isString()?(e.isPrivateIdentifier()?this._reportErrorForPrivateIdentifier(e,&quot;expected identifier, keyword or string&quot;):this.error(`Unexpected ${this.prettyPrintToken(e)}, expected identifier, keyword, or string`),&quot;&quot;):(this.advance(),e.toString())}parseChain(){let e=[],t=this.inputIndex;for(;this.index&lt;this.tokens.length;){let r=this.parsePipe();if(e.push(r),this.consumeOptionalCharacter(te))for(this.parseAction||this.error(&quot;Binding expression cannot contain chained expression&quot;);this.consumeOptionalCharacter(te););else this.index&lt;this.tokens.length&amp;&amp;this.error(`Unexpected token '${this.next}'`)}if(e.length==0){let r=this.offset,n=this.offset+this.inputLength;return new K(this.span(r,n),this.sourceSpan(r,n))}return e.length==1?e[0]:new oe(this.span(t),this.sourceSpan(t),e)}parsePipe(){let e=this.inputIndex,t=this.parseExpression();if(this.consumeOptionalOperator(&quot;|&quot;)){this.parseAction&amp;&amp;this.error(&quot;Cannot have a pipe in an action expression&quot;);do{let r=this.inputIndex,n=this.expectIdentifierOrKeyword(),s,a;n!==null?s=this.sourceSpan(r):(n=&quot;&quot;,a=this.next.index!==-1?this.next.index:this.inputLength+this.offset,s=new V(a,a).toAbsolute(this.absoluteOffset));let i=[];for(;this.consumeOptionalCharacter(X);)i.push(this.parseExpression());t=new fe(this.span(e),this.sourceSpan(e,a),t,n,i,s)}while(this.consumeOptionalOperator(&quot;|&quot;))}return t}parseExpression(){return this.parseConditional()}parseConditional(){let e=this.inputIndex,t=this.parseLogicalOr();if(this.consumeOptionalOperator(&quot;?&quot;)){let r=this.parsePipe(),n;if(this.consumeOptionalCharacter(X))n=this.parsePipe();else{let s=this.inputIndex,a=this.input.substring(e,s);this.error(`Conditional expression ${a} requires all 3 expressions`),n=new K(this.span(e),this.sourceSpan(e))}return new ce(this.span(e),this.sourceSpan(e),t,r,n)}else return t}parseLogicalOr(){let e=this.inputIndex,t=this.parseLogicalAnd();for(;this.consumeOptionalOperator(&quot;||&quot;);){let r=this.parseLogicalAnd();t=new B(this.span(e),this.sourceSpan(e),&quot;||&quot;,t,r)}return t}parseLogicalAnd(){let e=this.inputIndex,t=this.parseNullishCoalescing();for(;this.consumeOptionalOperator(&quot;&amp;&amp;&quot;);){let r=this.parseNullishCoalescing();t=new B(this.span(e),this.sourceSpan(e),&quot;&amp;&amp;&quot;,t,r)}return t}parseNullishCoalescing(){let e=this.inputIndex,t=this.parseEquality();for(;this.consumeOptionalOperator(&quot;??&quot;);){let r=this.parseEquality();t=new B(this.span(e),this.sourceSpan(e),&quot;??&quot;,t,r)}return t}parseEquality(){let e=this.inputIndex,t=this.parseRelational();for(;this.next.type==S.Operator;){let r=this.next.strValue;switch(r){case&quot;==&quot;:case&quot;===&quot;:case&quot;!=&quot;:case&quot;!==&quot;:this.advance();let n=this.parseRelational();t=new B(this.span(e),this.sourceSpan(e),r,t,n);continue}break}return t}parseRelational(){let e=this.inputIndex,t=this.parseAdditive();for(;this.next.type==S.Operator;){let r=this.next.strValue;switch(r){case&quot;&lt;&quot;:case&quot;&gt;&quot;:case&quot;&lt;=&quot;:case&quot;&gt;=&quot;:this.advance();let n=this.parseAdditive();t=new B(this.span(e),this.sourceSpan(e),r,t,n);continue}break}return t}parseAdditive(){let e=this.inputIndex,t=this.parseMultiplicative();for(;this.next.type==S.Operator;){let r=this.next.strValue;switch(r){case&quot;+&quot;:case&quot;-&quot;:this.advance();let n=this.parseMultiplicative();t=new B(this.span(e),this.sourceSpan(e),r,t,n);continue}break}return t}parseMultiplicative(){let e=this.inputIndex,t=this.parsePrefix();for(;this.next.type==S.Operator;){let r=this.next.strValue;switch(r){case&quot;*&quot;:case&quot;%&quot;:case&quot;/&quot;:this.advance();let n=this.parsePrefix();t=new B(this.span(e),this.sourceSpan(e),r,t,n);continue}break}return t}parsePrefix(){if(this.next.type==S.Operator){let e=this.inputIndex,t=this.next.strValue,r;switch(t){case&quot;+&quot;:return this.advance(),r=this.parsePrefix(),F.createPlus(this.span(e),this.sourceSpan(e),r);case&quot;-&quot;:return this.advance(),r=this.parsePrefix(),F.createMinus(this.span(e),this.sourceSpan(e),r);case&quot;!&quot;:return this.advance(),r=this.parsePrefix(),new xe(this.span(e),this.sourceSpan(e),r)}}return this.parseCallChain()}parseCallChain(){let e=this.inputIndex,t=this.parsePrimary();for(;;)if(this.consumeOptionalCharacter(H))t=this.parseAccessMemberOrMethodCall(t,e,!1);else if(this.consumeOptionalOperator(&quot;?.&quot;))t=this.consumeOptionalCharacter(Ae)?this.parseKeyedReadOrWrite(t,e,!0):this.parseAccessMemberOrMethodCall(t,e,!0);else if(this.consumeOptionalCharacter(Ae))t=this.parseKeyedReadOrWrite(t,e,!1);else if(this.consumeOptionalCharacter(Ee)){this.rparensExpected++;let r=this.parseCallArguments();this.rparensExpected--,this.expectCharacter(z),t=new Pe(this.span(e),this.sourceSpan(e),t,r)}else if(this.consumeOptionalOperator(&quot;!&quot;))t=new Se(this.span(e),this.sourceSpan(e),t);else return t}parsePrimary(){let e=this.inputIndex;if(this.consumeOptionalCharacter(Ee)){this.rparensExpected++;let t=this.parsePipe();return this.rparensExpected--,this.expectCharacter(z),t}else{if(this.next.isKeywordNull())return this.advance(),new $(this.span(e),this.sourceSpan(e),null);if(this.next.isKeywordUndefined())return this.advance(),new $(this.span(e),this.sourceSpan(e),void 0);if(this.next.isKeywordTrue())return this.advance(),new $(this.span(e),this.sourceSpan(e),!0);if(this.next.isKeywordFalse())return this.advance(),new $(this.span(e),this.sourceSpan(e),!1);if(this.next.isKeywordThis())return this.advance(),new Ye(this.span(e),this.sourceSpan(e));if(this.consumeOptionalCharacter(Ae)){this.rbracketsExpected++;let t=this.parseExpressionList(re);return this.rbracketsExpected--,this.expectCharacter(re),new ge(this.span(e),this.sourceSpan(e),t)}else{if(this.next.isCharacter($e))return this.parseLiteralMap();if(this.next.isIdentifier())return this.parseAccessMemberOrMethodCall(new Oe(this.span(e),this.sourceSpan(e)),e,!1);if(this.next.isNumber()){let t=this.next.toNumber();return this.advance(),new $(this.span(e),this.sourceSpan(e),t)}else if(this.next.isString()){let t=this.next.toString();return this.advance(),new $(this.span(e),this.sourceSpan(e),t)}else return this.next.isPrivateIdentifier()?(this._reportErrorForPrivateIdentifier(this.next,null),new K(this.span(e),this.sourceSpan(e))):this.index&gt;=this.tokens.length?(this.error(`Unexpected end of expression: ${this.input}`),new K(this.span(e),this.sourceSpan(e))):(this.error(`Unexpected token ${this.next}`),new K(this.span(e),this.sourceSpan(e)))}}}parseExpressionList(e){let t=[];do if(!this.next.isCharacter(e))t.push(this.parsePipe());else break;while(this.consumeOptionalCharacter(ee));return t}parseLiteralMap(){let e=[],t=[],r=this.inputIndex;if(this.expectCharacter($e),!this.consumeOptionalCharacter(_e)){this.rbracesExpected++;do{let n=this.inputIndex,s=this.next.isString(),a=this.expectIdentifierOrKeywordOrString();if(e.push({key:a,quoted:s}),s)this.expectCharacter(X),t.push(this.parsePipe());else if(this.consumeOptionalCharacter(X))t.push(this.parsePipe());else{let i=this.span(n),h=this.sourceSpan(n);t.push(new ne(i,h,h,new Oe(i,h),a))}}while(this.consumeOptionalCharacter(ee));this.rbracesExpected--,this.expectCharacter(_e)}return new ve(this.span(r),this.sourceSpan(r),e,t)}parseAccessMemberOrMethodCall(e,t,r){let n=this.inputIndex,s=this.withContext(Z.Writable,()=&gt;{var i;let h=(i=this.expectIdentifierOrKeyword())!==null&amp;&amp;i!==void 0?i:&quot;&quot;;return h.length===0&amp;&amp;this.error(&quot;Expected identifier for property access&quot;,e.span.end),h}),a=this.sourceSpan(n);if(this.consumeOptionalCharacter(Ee)){let i=this.inputIndex;this.rparensExpected++;let h=this.parseCallArguments(),l=this.span(i,this.inputIndex).toAbsolute(this.absoluteOffset);this.expectCharacter(z),this.rparensExpected--;let P=this.span(t),p=this.sourceSpan(t);return r?new we(P,p,a,e,s,h,l):new ye(P,p,a,e,s,h,l)}else{if(r)return this.consumeOptionalOperator(&quot;=&quot;)?(this.error(&quot;The '?.' operator cannot be used in the assignment&quot;),new K(this.span(t),this.sourceSpan(t))):new le(this.span(t),this.sourceSpan(t),a,e,s);if(this.consumeOptionalOperator(&quot;=&quot;)){if(!this.parseAction)return this.error(&quot;Bindings cannot contain assignments&quot;),new K(this.span(t),this.sourceSpan(t));let i=this.parseConditional();return new ue(this.span(t),this.sourceSpan(t),a,e,s,i)}else return new ne(this.span(t),this.sourceSpan(t),a,e,s)}}parseCallArguments(){if(this.next.isCharacter(z))return[];let e=[];do e.push(this.parsePipe());while(this.consumeOptionalCharacter(ee));return e}expectTemplateBindingKey(){let e=&quot;&quot;,t=!1,r=this.currentAbsoluteOffset;do e+=this.expectIdentifierOrKeywordOrString(),t=this.consumeOptionalOperator(&quot;-&quot;),t&amp;&amp;(e+=&quot;-&quot;);while(t);return{source:e,span:new U(r,r+e.length)}}parseTemplateBindings(e){let t=[];for(t.push(...this.parseDirectiveKeywordBindings(e));this.index&lt;this.tokens.length;){let r=this.parseLetBinding();if(r)t.push(r);else{let n=this.expectTemplateBindingKey(),s=this.parseAsBinding(n);s?t.push(s):(n.source=e.source+n.source.charAt(0).toUpperCase()+n.source.substring(1),t.push(...this.parseDirectiveKeywordBindings(n)))}this.consumeStatementTerminator()}return new Qe(t,[],this.errors)}parseKeyedReadOrWrite(e,t,r){return this.withContext(Z.Writable,()=&gt;{this.rbracketsExpected++;let n=this.parsePipe();if(n instanceof K&amp;&amp;this.error(&quot;Key access cannot be empty&quot;),this.rbracketsExpected--,this.expectCharacter(re),this.consumeOptionalOperator(&quot;=&quot;))if(r)this.error(&quot;The '?.' operator cannot be used in the assignment&quot;);else{let s=this.parseConditional();return new de(this.span(t),this.sourceSpan(t),e,n,s)}else return r?new pe(this.span(t),this.sourceSpan(t),e,n):new he(this.span(t),this.sourceSpan(t),e,n);return new K(this.span(t),this.sourceSpan(t))})}parseDirectiveKeywordBindings(e){let t=[];this.consumeOptionalCharacter(X);let r=this.getDirectiveBoundTarget(),n=this.currentAbsoluteOffset,s=this.parseAsBinding(e);s||(this.consumeStatementTerminator(),n=this.currentAbsoluteOffset);let a=new U(e.span.start,n);return t.push(new Ze(a,e,r)),s&amp;&amp;t.push(s),t}getDirectiveBoundTarget(){if(this.next===Ie||this.peekKeywordAs()||this.peekKeywordLet())return null;let e=this.parsePipe(),{start:t,end:r}=e.span,n=this.input.substring(t,r);return new G(e,n,this.location,this.absoluteOffset+t,this.errors)}parseAsBinding(e){if(!this.peekKeywordAs())return null;this.advance();let t=this.expectTemplateBindingKey();this.consumeStatementTerminator();let r=new U(e.span.start,this.currentAbsoluteOffset);return new Re(r,t,e)}parseLetBinding(){if(!this.peekKeywordLet())return null;let e=this.currentAbsoluteOffset;this.advance();let t=this.expectTemplateBindingKey(),r=null;this.consumeOptionalOperator(&quot;=&quot;)&amp;&amp;(r=this.expectTemplateBindingKey()),this.consumeStatementTerminator();let n=new U(e,this.currentAbsoluteOffset);return new Re(n,t,r)}consumeStatementTerminator(){this.consumeOptionalCharacter(te)||this.consumeOptionalCharacter(ee)}error(e){let t=arguments.length&gt;1&amp;&amp;arguments[1]!==void 0?arguments[1]:null;this.errors.push(new ae(e,this.input,this.locationText(t),this.location)),this.skip()}locationText(){let e=arguments.length&gt;0&amp;&amp;arguments[0]!==void 0?arguments[0]:null;return e==null&amp;&amp;(e=this.index),e&lt;this.tokens.length?`at column ${this.tokens[e].index+1} in`:&quot;at the end of the expression&quot;}_reportErrorForPrivateIdentifier(e,t){let r=`Private identifiers are not supported. Unexpected private identifier: ${e}`;t!==null&amp;&amp;(r+=`, ${t}`),this.error(r)}skip(){let e=this.next;for(;this.index&lt;this.tokens.length&amp;&amp;!e.isCharacter(te)&amp;&amp;!e.isOperator(&quot;|&quot;)&amp;&amp;(this.rparensExpected&lt;=0||!e.isCharacter(z))&amp;&amp;(this.rbracesExpected&lt;=0||!e.isCharacter(_e))&amp;&amp;(this.rbracketsExpected&lt;=0||!e.isCharacter(re))&amp;&amp;(!(this.context&amp;Z.Writable)||!e.isOperator(&quot;=&quot;));)this.next.isError()&amp;&amp;this.errors.push(new ae(this.next.toString(),this.input,this.locationText(),this.location)),this.advance(),e=this.next}},yt=class{constructor(){this.errors=[]}visitImplicitReceiver(e,t){}visitThisReceiver(e,t){}visitInterpolation(e,t){}visitLiteralPrimitive(e,t){}visitPropertyRead(e,t){}visitPropertyWrite(e,t){}visitSafePropertyRead(e,t){}visitMethodCall(e,t){}visitSafeMethodCall(e,t){}visitFunctionCall(e,t){}visitLiteralArray(e,t){this.visitAll(e.expressions,t)}visitLiteralMap(e,t){this.visitAll(e.values,t)}visitUnary(e,t){}visitBinary(e,t){}visitPrefixNot(e,t){}visitNonNullAssert(e,t){}visitConditional(e,t){}visitPipe(e,t){this.errors.push(&quot;pipes&quot;)}visitKeyedRead(e,t){}visitKeyedWrite(e,t){}visitAll(e,t){return e.map(r=&gt;r.visit(this,t))}visitChain(e,t){}visitQuote(e,t){}visitSafeKeyedRead(e,t){}},wt=class extends et{constructor(){super(...arguments),this.errors=[]}visitPipe(){this.errors.push(&quot;pipes&quot;)}}}}),ft=q({&quot;node_modules/angular-estree-parser/lib/utils.js&quot;(e){&quot;use strict&quot;;L(),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0}),e.getLast=e.toLowerCamelCase=e.findBackChar=e.findFrontChar=e.fitSpans=e.getNgType=e.parseNgInterpolation=e.parseNgTemplateBindings=e.parseNgAction=e.parseNgSimpleBinding=e.parseNgBinding=e.NG_PARSE_TEMPLATE_BINDINGS_FAKE_PREFIX=void 0;var t=(tt(),be(Je)),r=(tr(),be(Yt)),n=(br(),be(nr)),s=&quot;angular-estree-parser&quot;;e.NG_PARSE_TEMPLATE_BINDINGS_FAKE_PREFIX=&quot;NgEstreeParser&quot;;var a=0,i=[s,a];function h(){return new n.Parser(new r.Lexer)}function l(o,d){let y=h(),{astInput:E,comments:A}=T(o,y),{ast:I,errors:j}=d(E,y);return R(j),{ast:I,comments:A}}function P(o){return l(o,(d,y)=&gt;y.parseBinding(d,...i))}e.parseNgBinding=P;function p(o){return l(o,(d,y)=&gt;y.parseSimpleBinding(d,...i))}e.parseNgSimpleBinding=p;function x(o){return l(o,(d,y)=&gt;y.parseAction(d,...i))}e.parseNgAction=x;function C(o){let d=h(),{templateBindings:y,errors:E}=d.parseTemplateBindings(e.NG_PARSE_TEMPLATE_BINDINGS_FAKE_PREFIX,o,s,a,a);return R(E),y}e.parseNgTemplateBindings=C;function b(o){let d=h(),{astInput:y,comments:E}=T(o,d),A=&quot;{{&quot;,I=&quot;}}&quot;,{ast:j,errors:or}=d.parseInterpolation(A+y+I,...i);R(or);let gt=j.expressions[0],vt=new Set;return _(gt,ke=&gt;{vt.has(ke)||(ke.start-=A.length,ke.end-=A.length,vt.add(ke))}),{ast:gt,comments:E}}e.parseNgInterpolation=b;function _(o,d){if(!(!o||typeof o!=&quot;object&quot;)){if(Array.isArray(o))return o.forEach(y=&gt;_(y,d));for(let y of Object.keys(o)){let E=o[y];y===&quot;span&quot;?d(E):_(E,d)}}}function R(o){if(o.length!==0){let[{message:d}]=o;throw new SyntaxError(d.replace(/^Parser Error: | at column \d+ in [^]*$/g,&quot;&quot;))}}function T(o,d){let y=d._commentStart(o);return y===null?{astInput:o,comments:[]}:{astInput:o.slice(0,y),comments:[{type:&quot;Comment&quot;,value:o.slice(y+2),span:{start:y,end:o.length}}]}}function O(o){return t.Unary&amp;&amp;o instanceof t.Unary?&quot;Unary&quot;:o instanceof t.Binary?&quot;Binary&quot;:o instanceof t.BindingPipe?&quot;BindingPipe&quot;:o instanceof t.Chain?&quot;Chain&quot;:o instanceof t.Conditional?&quot;Conditional&quot;:o instanceof t.EmptyExpr?&quot;EmptyExpr&quot;:o instanceof t.FunctionCall?&quot;FunctionCall&quot;:o instanceof t.ImplicitReceiver?&quot;ImplicitReceiver&quot;:o instanceof t.KeyedRead?&quot;KeyedRead&quot;:o instanceof t.KeyedWrite?&quot;KeyedWrite&quot;:o instanceof t.LiteralArray?&quot;LiteralArray&quot;:o instanceof t.LiteralMap?&quot;LiteralMap&quot;:o instanceof t.LiteralPrimitive?&quot;LiteralPrimitive&quot;:o instanceof t.MethodCall?&quot;MethodCall&quot;:o instanceof t.NonNullAssert?&quot;NonNullAssert&quot;:o instanceof t.PrefixNot?&quot;PrefixNot&quot;:o instanceof t.PropertyRead?&quot;PropertyRead&quot;:o instanceof t.PropertyWrite?&quot;PropertyWrite&quot;:o instanceof t.Quote?&quot;Quote&quot;:o instanceof t.SafeMethodCall?&quot;SafeMethodCall&quot;:o instanceof t.SafePropertyRead?&quot;SafePropertyRead&quot;:o.type}e.getNgType=O;function N(o,d){let{start:y,end:E}=o,A=y,I=E;for(;I!==A&amp;&amp;/\s/.test(d[I-1]);)I--;for(;A!==I&amp;&amp;/\s/.test(d[A]);)A++;return{start:A,end:I}}function c(o,d){let{start:y,end:E}=o,A=y,I=E;for(;I!==d.length&amp;&amp;/\s/.test(d[I]);)I++;for(;A!==0&amp;&amp;/\s/.test(d[A-1]);)A--;return{start:A,end:I}}function g(o,d){return d[o.start-1]===&quot;(&quot;&amp;&amp;d[o.end]===&quot;)&quot;?{start:o.start-1,end:o.end+1}:o}function u(o,d,y){let E=0,A={start:o.start,end:o.end};for(;;){let I=c(A,d),j=g(I,d);if(I.start===j.start&amp;&amp;I.end===j.end)break;A.start=j.start,A.end=j.end,E++}return{hasParens:(y?E-1:E)!==0,outerSpan:N(y?{start:A.start+1,end:A.end-1}:A,d),innerSpan:N(o,d)}}e.fitSpans=u;function v(o,d,y){let E=d;for(;!o.test(y[E]);)if(--E&lt;0)throw new Error(`Cannot find front char ${o} from index ${d} in ${JSON.stringify(y)}`);return E}e.findFrontChar=v;function m(o,d,y){let E=d;for(;!o.test(y[E]);)if(++E&gt;=y.length)throw new Error(`Cannot find back char ${o} from index ${d} in ${JSON.stringify(y)}`);return E}e.findBackChar=m;function f(o){return o.slice(0,1).toLowerCase()+o.slice(1)}e.toLowerCamelCase=f;function w(o){return o.length===0?void 0:o[o.length-1]}e.getLast=w}}),ir=q({&quot;node_modules/angular-estree-parser/lib/transform.js&quot;(e){&quot;use strict&quot;;L(),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0}),e.transformSpan=e.transform=void 0;var t=ft(),r=function(s,a){let i=arguments.length&gt;2&amp;&amp;arguments[2]!==void 0?arguments[2]:!1,h=t.getNgType(s);switch(h){case&quot;Unary&quot;:{let{operator:c,expr:g}=s,u=l(g);return p(&quot;UnaryExpression&quot;,{prefix:!0,argument:u,operator:c},s.span,{hasParentParens:i})}case&quot;Binary&quot;:{let{left:c,operation:g,right:u}=s,v=u.span.start===u.span.end,m=c.span.start===c.span.end;if(v||m){let o=c.span.start===c.span.end?l(u):l(c);return p(&quot;UnaryExpression&quot;,{prefix:!0,argument:o,operator:v?&quot;+&quot;:&quot;-&quot;},{start:s.span.start,end:N(o)},{hasParentParens:i})}let f=l(c),w=l(u);return p(g===&quot;&amp;&amp;&quot;||g===&quot;||&quot;?&quot;LogicalExpression&quot;:&quot;BinaryExpression&quot;,{left:f,right:w,operator:g},{start:O(f),end:N(w)},{hasParentParens:i})}case&quot;BindingPipe&quot;:{let{exp:c,name:g,args:u}=s,v=l(c),m=b(/\S/,b(/\|/,N(v))+1),f=p(&quot;Identifier&quot;,{name:g},{start:m,end:m+g.length}),w=u.map(l);return p(&quot;NGPipeExpression&quot;,{left:v,right:f,arguments:w},{start:O(v),end:N(w.length===0?f:t.getLast(w))},{hasParentParens:i})}case&quot;Chain&quot;:{let{expressions:c}=s;return p(&quot;NGChainedExpression&quot;,{expressions:c.map(l)},s.span,{hasParentParens:i})}case&quot;Comment&quot;:{let{value:c}=s;return p(&quot;CommentLine&quot;,{value:c},s.span,{processSpan:!1})}case&quot;Conditional&quot;:{let{condition:c,trueExp:g,falseExp:u}=s,v=l(c),m=l(g),f=l(u);return p(&quot;ConditionalExpression&quot;,{test:v,consequent:m,alternate:f},{start:O(v),end:N(f)},{hasParentParens:i})}case&quot;EmptyExpr&quot;:return p(&quot;NGEmptyExpression&quot;,{},s.span,{hasParentParens:i});case&quot;FunctionCall&quot;:{let{target:c,args:g}=s,u=g.length===1?[P(g[0])]:g.map(l),v=l(c);return p(&quot;CallExpression&quot;,{callee:v,arguments:u},{start:O(v),end:s.span.end},{hasParentParens:i})}case&quot;ImplicitReceiver&quot;:return p(&quot;ThisExpression&quot;,{},s.span,{hasParentParens:i});case&quot;KeyedRead&quot;:{let{key:c}=s,g=Object.prototype.hasOwnProperty.call(s,&quot;receiver&quot;)?s.receiver:s.obj,u=l(c);return x(g,u,{computed:!0,optional:!1},{end:s.span.end,hasParentParens:i})}case&quot;LiteralArray&quot;:{let{expressions:c}=s;return p(&quot;ArrayExpression&quot;,{elements:c.map(l)},s.span,{hasParentParens:i})}case&quot;LiteralMap&quot;:{let{keys:c,values:g}=s,u=g.map(m=&gt;l(m)),v=c.map((m,f)=&gt;{let{key:w,quoted:o}=m,d=u[f],y=b(/\S/,f===0?s.span.start+1:b(/,/,N(u[f-1]))+1),E=C(/\S/,C(/:/,O(d)-1)-1)+1,A={start:y,end:E},I=o?p(&quot;StringLiteral&quot;,{value:w},A):p(&quot;Identifier&quot;,{name:w},A),j=I.end&lt;I.start;return p(&quot;ObjectProperty&quot;,{key:I,value:d,method:!1,shorthand:j,computed:!1},{start:O(I),end:N(d)})});return p(&quot;ObjectExpression&quot;,{properties:v},s.span,{hasParentParens:i})}case&quot;LiteralPrimitive&quot;:{let{value:c}=s;switch(typeof c){case&quot;boolean&quot;:return p(&quot;BooleanLiteral&quot;,{value:c},s.span,{hasParentParens:i});case&quot;number&quot;:return p(&quot;NumericLiteral&quot;,{value:c},s.span,{hasParentParens:i});case&quot;object&quot;:return p(&quot;NullLiteral&quot;,{},s.span,{hasParentParens:i});case&quot;string&quot;:return p(&quot;StringLiteral&quot;,{value:c},s.span,{hasParentParens:i});case&quot;undefined&quot;:return p(&quot;Identifier&quot;,{name:&quot;undefined&quot;},s.span,{hasParentParens:i});default:throw new Error(`Unexpected LiteralPrimitive value type ${typeof c}`)}}case&quot;MethodCall&quot;:case&quot;SafeMethodCall&quot;:{let c=h===&quot;SafeMethodCall&quot;,{receiver:g,name:u,args:v}=s,m=v.length===1?[P(v[0])]:v.map(l),f=C(/\S/,C(/\(/,(m.length===0?C(/\)/,s.span.end-1):O(m[0]))-1)-1)+1,w=p(&quot;Identifier&quot;,{name:u},{start:f-u.length,end:f}),o=x(g,w,{computed:!1,optional:c}),d=R(o);return p(c||d?&quot;OptionalCallExpression&quot;:&quot;CallExpression&quot;,{callee:o,arguments:m},{start:O(o),end:s.span.end},{hasParentParens:i})}case&quot;NonNullAssert&quot;:{let{expression:c}=s,g=l(c);return p(&quot;TSNonNullExpression&quot;,{expression:g},{start:O(g),end:s.span.end},{hasParentParens:i})}case&quot;PrefixNot&quot;:{let{expression:c}=s,g=l(c);return p(&quot;UnaryExpression&quot;,{prefix:!0,operator:&quot;!&quot;,argument:g},{start:s.span.start,end:N(g)},{hasParentParens:i})}case&quot;PropertyRead&quot;:case&quot;SafePropertyRead&quot;:{let c=h===&quot;SafePropertyRead&quot;,{receiver:g,name:u}=s,v=C(/\S/,s.span.end-1)+1,m=p(&quot;Identifier&quot;,{name:u},{start:v-u.length,end:v},_(g)?{hasParentParens:i}:{});return x(g,m,{computed:!1,optional:c},{hasParentParens:i})}case&quot;KeyedWrite&quot;:{let{key:c,value:g}=s,u=Object.prototype.hasOwnProperty.call(s,&quot;receiver&quot;)?s.receiver:s.obj,v=l(c),m=l(g),f=x(u,v,{computed:!0,optional:!1},{end:b(/\]/,N(v))+1});return p(&quot;AssignmentExpression&quot;,{left:f,operator:&quot;=&quot;,right:m},{start:O(f),end:N(m)},{hasParentParens:i})}case&quot;PropertyWrite&quot;:{let{receiver:c,name:g,value:u}=s,v=l(u),m=C(/\S/,C(/=/,O(v)-1)-1)+1,f=p(&quot;Identifier&quot;,{name:g},{start:m-g.length,end:m}),w=x(c,f,{computed:!1,optional:!1});return p(&quot;AssignmentExpression&quot;,{left:w,operator:&quot;=&quot;,right:v},{start:O(w),end:N(v)},{hasParentParens:i})}case&quot;Quote&quot;:{let{prefix:c,uninterpretedExpression:g}=s;return p(&quot;NGQuotedExpression&quot;,{prefix:c,value:g},s.span,{hasParentParens:i})}default:throw new Error(`Unexpected node ${h}`)}function l(c){return e.transform(c,a)}function P(c){return e.transform(c,a,!0)}function p(c,g,u){let{processSpan:v=!0,hasParentParens:m=!1}=arguments.length&gt;3&amp;&amp;arguments[3]!==void 0?arguments[3]:{},f=Object.assign(Object.assign({type:c},n(u,a,v,m)),g);switch(c){case&quot;Identifier&quot;:{let w=f;w.loc.identifierName=w.name;break}case&quot;NumericLiteral&quot;:{let w=f;w.extra=Object.assign(Object.assign({},w.extra),{raw:a.text.slice(w.start,w.end),rawValue:w.value});break}case&quot;StringLiteral&quot;:{let w=f;w.extra=Object.assign(Object.assign({},w.extra),{raw:a.text.slice(w.start,w.end),rawValue:w.value});break}}return f}function x(c,g,u){let{end:v=N(g),hasParentParens:m=!1}=arguments.length&gt;3&amp;&amp;arguments[3]!==void 0?arguments[3]:{};if(_(c)||c.span.start===g.start)return g;let f=l(c),w=R(f);return p(u.optional||w?&quot;OptionalMemberExpression&quot;:&quot;MemberExpression&quot;,Object.assign({object:f,property:g,computed:u.computed},u.optional?{optional:!0}:w?{optional:!1}:null),{start:O(f),end:v},{hasParentParens:m})}function C(c,g){return t.findFrontChar(c,g,a.text)}function b(c,g){return t.findBackChar(c,g,a.text)}function _(c){return c.span.start&gt;=c.span.end||/^\s+$/.test(a.text.slice(c.span.start,c.span.end))}function R(c){return(c.type===&quot;OptionalCallExpression&quot;||c.type===&quot;OptionalMemberExpression&quot;)&amp;&amp;!T(c)}function T(c){return c.extra&amp;&amp;c.extra.parenthesized}function O(c){return T(c)?c.extra.parenStart:c.start}function N(c){return T(c)?c.extra.parenEnd:c.end}};e.transform=r;function n(s,a){let i=arguments.length&gt;2&amp;&amp;arguments[2]!==void 0?arguments[2]:!1,h=arguments.length&gt;3&amp;&amp;arguments[3]!==void 0?arguments[3]:!1;if(!i){let{start:x,end:C}=s;return{start:x,end:C,loc:{start:a.locator.locationForIndex(x),end:a.locator.locationForIndex(C)}}}let{outerSpan:l,innerSpan:P,hasParens:p}=t.fitSpans(s,a.text,h);return Object.assign({start:P.start,end:P.end,loc:{start:a.locator.locationForIndex(P.start),end:a.locator.locationForIndex(P.end)}},p&amp;&amp;{extra:{parenthesized:!0,parenStart:l.start,parenEnd:l.end}})}e.transformSpan=n}}),Lr=q({&quot;node_modules/angular-estree-parser/lib/transform-microsyntax.js&quot;(e){&quot;use strict&quot;;L(),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0}),e.transformTemplateBindings=void 0;var t=(tt(),be(Je)),r=ir(),n=ft();function s(a,i){a.forEach(N);let[h]=a,{key:l}=h,P=i.text.slice(h.sourceSpan.start,h.sourceSpan.end).trim().length===0?a.slice(1):a,p=[],x=null;for(let u=0;u&lt;P.length;u++){let v=P[u];if(x&amp;&amp;T(x)&amp;&amp;O(v)&amp;&amp;v.value&amp;&amp;v.value.source===x.key.source){let m=_(&quot;NGMicrosyntaxKey&quot;,{name:v.key.source},v.key.span),f=(d,y)=&gt;Object.assign(Object.assign({},d),r.transformSpan({start:d.start,end:y},i)),w=d=&gt;Object.assign(Object.assign({},f(d,m.end)),{alias:m}),o=p.pop();if(o.type===&quot;NGMicrosyntaxExpression&quot;)p.push(w(o));else if(o.type===&quot;NGMicrosyntaxKeyedExpression&quot;){let d=w(o.expression);p.push(f(Object.assign(Object.assign({},o),{expression:d}),d.end))}else throw new Error(`Unexpected type ${o.type}`)}else p.push(C(v,u));x=v}return _(&quot;NGMicrosyntax&quot;,{body:p},p.length===0?a[0].sourceSpan:{start:p[0].start,end:p[p.length-1].end});function C(u,v){if(T(u)){let{key:m,value:f}=u;return f?v===0?_(&quot;NGMicrosyntaxExpression&quot;,{expression:b(f.ast),alias:null},f.sourceSpan):_(&quot;NGMicrosyntaxKeyedExpression&quot;,{key:_(&quot;NGMicrosyntaxKey&quot;,{name:R(m.source)},m.span),expression:_(&quot;NGMicrosyntaxExpression&quot;,{expression:b(f.ast),alias:null},f.sourceSpan)},{start:m.span.start,end:f.sourceSpan.end}):_(&quot;NGMicrosyntaxKey&quot;,{name:R(m.source)},m.span)}else{let{key:m,sourceSpan:f}=u;if(/^let\s$/.test(i.text.slice(f.start,f.start+4))){let{value:o}=u;return _(&quot;NGMicrosyntaxLet&quot;,{key:_(&quot;NGMicrosyntaxKey&quot;,{name:m.source},m.span),value:o?_(&quot;NGMicrosyntaxKey&quot;,{name:o.source},o.span):null},{start:f.start,end:o?o.span.end:m.span.end})}else{let o=g(u);return _(&quot;NGMicrosyntaxAs&quot;,{key:_(&quot;NGMicrosyntaxKey&quot;,{name:o.source},o.span),alias:_(&quot;NGMicrosyntaxKey&quot;,{name:m.source},m.span)},{start:o.span.start,end:m.span.end})}}}function b(u){return r.transform(u,i)}function _(u,v,m){let f=arguments.length&gt;3&amp;&amp;arguments[3]!==void 0?arguments[3]:!0;return Object.assign(Object.assign({type:u},r.transformSpan(m,i,f)),v)}function R(u){return n.toLowerCamelCase(u.slice(l.source.length))}function T(u){return u instanceof t.ExpressionBinding}function O(u){return u instanceof t.VariableBinding}function N(u){c(u.key.span),O(u)&amp;&amp;u.value&amp;&amp;c(u.value.span)}function c(u){if(i.text[u.start]!=='&quot;'&amp;&amp;i.text[u.start]!==&quot;'&quot;)return;let v=i.text[u.start],m=!1;for(let f=u.start+1;f&lt;i.text.length;f++)switch(i.text[f]){case v:if(!m){u.end=f+1;return}default:m=!1;break;case&quot;\\&quot;:m=!m;break}}function g(u){if(!u.value||u.value.source!==n.NG_PARSE_TEMPLATE_BINDINGS_FAKE_PREFIX)return u.value;let v=n.findBackChar(/\S/,u.sourceSpan.start,i.text);return{source:&quot;$implicit&quot;,span:{start:v,end:v}}}}e.transformTemplateBindings=s}}),Rr=q({&quot;node_modules/angular-estree-parser/lib/index.js&quot;(e){&quot;use strict&quot;;L(),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0}),e.parseTemplateBindings=e.parseAction=e.parseInterpolation=e.parseSimpleBinding=e.parseBinding=void 0;var t=gr(),r=ir(),n=Lr(),s=ft();function a(x,C){let{ast:b,comments:_}=C(x),R=new t.Context(x),T=N=&gt;r.transform(N,R),O=T(b);return O.comments=_.map(T),O}function i(x){return a(x,s.parseNgBinding)}e.parseBinding=i;function h(x){return a(x,s.parseNgSimpleBinding)}e.parseSimpleBinding=h;function l(x){return a(x,s.parseNgInterpolation)}e.parseInterpolation=l;function P(x){return a(x,s.parseNgAction)}e.parseAction=P;function p(x){return n.transformTemplateBindings(s.parseNgTemplateBindings(x),new t.Context(x))}e.parseTemplateBindings=p}});L();var{locStart:Tr,locEnd:$r}=dr();function Ne(e){return{astFormat:&quot;estree&quot;,parse:(r,n,s)=&gt;{let a=Rr(),i=e(r,a);return{type:&quot;NGRoot&quot;,node:s.parser===&quot;__ng_action&quot;&amp;&amp;i.type!==&quot;NGChainedExpression&quot;?Object.assign(Object.assign({},i),{},{type:&quot;NGChainedExpression&quot;,expressions:[i]}):i}},locStart:Tr,locEnd:$r}}ar.exports={parsers:{__ng_action:Ne((e,t)=&gt;t.parseAction(e)),__ng_binding:Ne((e,t)=&gt;t.parseBinding(e)),__ng_interpolation:Ne((e,t)=&gt;t.parseInterpolation(e)),__ng_directive:Ne((e,t)=&gt;t.parseTemplateBindings(e))}}});return Br();});</span></pre>
</body>
</html>
<html>
<head>
<title>config-chain.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #4646f1;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
config-chain.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.buildPresetChain = buildPresetChain;</span>
<span class="s1">exports.buildPresetChainWalker = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s1">exports.buildRootChain = buildRootChain;</span>
<span class="s2">function </span><span class="s1">_path() {</span>
  <span class="s1">const data = require(</span><span class="s0">&quot;path&quot;</span><span class="s1">);</span>
  <span class="s1">_path = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_debug() {</span>
  <span class="s1">const data = require(</span><span class="s0">&quot;debug&quot;</span><span class="s1">);</span>
  <span class="s1">_debug = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">_options = require(</span><span class="s0">&quot;./validation/options&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_patternToRegex = require(</span><span class="s0">&quot;./pattern-to-regex&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_printer = require(</span><span class="s0">&quot;./printer&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_rewriteStackTrace = require(</span><span class="s0">&quot;../errors/rewrite-stack-trace&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_configError = require(</span><span class="s0">&quot;../errors/config-error&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_files = require(</span><span class="s0">&quot;./files&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_caching = require(</span><span class="s0">&quot;./caching&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_configDescriptors = require(</span><span class="s0">&quot;./config-descriptors&quot;</span><span class="s1">);</span>
<span class="s1">const debug = _debug()(</span><span class="s0">&quot;babel:config:config-chain&quot;</span><span class="s1">);</span>
<span class="s2">function</span><span class="s1">* buildPresetChain(arg, context) {</span>
  <span class="s1">const chain = yield* buildPresetChainWalker(arg, context);</span>
  <span class="s2">if </span><span class="s1">(!chain) </span><span class="s2">return null</span><span class="s1">;</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">plugins: dedupDescriptors(chain.plugins),</span>
    <span class="s1">presets: dedupDescriptors(chain.presets),</span>
    <span class="s1">options: chain.options.map(o =&gt; normalizeOptions(o)),</span>
    <span class="s1">files: </span><span class="s2">new </span><span class="s1">Set()</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">const buildPresetChainWalker = makeChainWalker({</span>
  <span class="s1">root: preset =&gt; loadPresetDescriptors(preset),</span>
  <span class="s1">env: (preset, envName) =&gt; loadPresetEnvDescriptors(preset)(envName),</span>
  <span class="s1">overrides: (preset, index) =&gt; loadPresetOverridesDescriptors(preset)(index),</span>
  <span class="s1">overridesEnv: (preset, index, envName) =&gt; loadPresetOverridesEnvDescriptors(preset)(index)(envName),</span>
  <span class="s1">createLogger: () =&gt; () =&gt; {}</span>
<span class="s1">});</span>
<span class="s1">exports.buildPresetChainWalker = buildPresetChainWalker;</span>
<span class="s1">const loadPresetDescriptors = (</span><span class="s3">0</span><span class="s1">, _caching.makeWeakCacheSync)(preset =&gt; buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors));</span>
<span class="s1">const loadPresetEnvDescriptors = (</span><span class="s3">0</span><span class="s1">, _caching.makeWeakCacheSync)(preset =&gt; (</span><span class="s3">0</span><span class="s1">, _caching.makeStrongCacheSync)(envName =&gt; buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName)));</span>
<span class="s1">const loadPresetOverridesDescriptors = (</span><span class="s3">0</span><span class="s1">, _caching.makeWeakCacheSync)(preset =&gt; (</span><span class="s3">0</span><span class="s1">, _caching.makeStrongCacheSync)(index =&gt; buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index)));</span>
<span class="s1">const loadPresetOverridesEnvDescriptors = (</span><span class="s3">0</span><span class="s1">, _caching.makeWeakCacheSync)(preset =&gt; (</span><span class="s3">0</span><span class="s1">, _caching.makeStrongCacheSync)(index =&gt; (</span><span class="s3">0</span><span class="s1">, _caching.makeStrongCacheSync)(envName =&gt; buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index, envName))));</span>
<span class="s2">function</span><span class="s1">* buildRootChain(opts, context) {</span>
  <span class="s1">let configReport, babelRcReport;</span>
  <span class="s1">const programmaticLogger = </span><span class="s2">new </span><span class="s1">_printer.ConfigPrinter();</span>
  <span class="s1">const programmaticChain = yield* loadProgrammaticChain({</span>
    <span class="s1">options: opts,</span>
    <span class="s1">dirname: context.cwd</span>
  <span class="s1">}, context, undefined, programmaticLogger);</span>
  <span class="s2">if </span><span class="s1">(!programmaticChain) </span><span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">const programmaticReport = yield* programmaticLogger.output();</span>
  <span class="s1">let configFile;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">opts.configFile === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
    <span class="s1">configFile = yield* (</span><span class="s3">0</span><span class="s1">, _files.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller);</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(opts.configFile !== </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s1">configFile = yield* (</span><span class="s3">0</span><span class="s1">, _files.findRootConfig)(context.root, context.envName, context.caller);</span>
  <span class="s1">}</span>
  <span class="s1">let {</span>
    <span class="s1">babelrc,</span>
    <span class="s1">babelrcRoots</span>
  <span class="s1">} = opts;</span>
  <span class="s1">let babelrcRootsDirectory = context.cwd;</span>
  <span class="s1">const configFileChain = emptyChain();</span>
  <span class="s1">const configFileLogger = </span><span class="s2">new </span><span class="s1">_printer.ConfigPrinter();</span>
  <span class="s2">if </span><span class="s1">(configFile) {</span>
    <span class="s1">const validatedFile = validateConfigFile(configFile);</span>
    <span class="s1">const result = yield* loadFileChain(validatedFile, context, undefined, configFileLogger);</span>
    <span class="s2">if </span><span class="s1">(!result) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">configReport = yield* configFileLogger.output();</span>
    <span class="s2">if </span><span class="s1">(babelrc === undefined) {</span>
      <span class="s1">babelrc = validatedFile.options.babelrc;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(babelrcRoots === undefined) {</span>
      <span class="s1">babelrcRootsDirectory = validatedFile.dirname;</span>
      <span class="s1">babelrcRoots = validatedFile.options.babelrcRoots;</span>
    <span class="s1">}</span>
    <span class="s1">mergeChain(configFileChain, result);</span>
  <span class="s1">}</span>
  <span class="s1">let ignoreFile, babelrcFile;</span>
  <span class="s1">let isIgnored = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">const fileChain = emptyChain();</span>
  <span class="s2">if </span><span class="s1">((babelrc === </span><span class="s2">true </span><span class="s1">|| babelrc === undefined) &amp;&amp; </span><span class="s2">typeof </span><span class="s1">context.filename === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
    <span class="s1">const pkgData = yield* (</span><span class="s3">0</span><span class="s1">, _files.findPackageData)(context.filename);</span>
    <span class="s2">if </span><span class="s1">(pkgData &amp;&amp; babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {</span>
      <span class="s1">({</span>
        <span class="s1">ignore: ignoreFile,</span>
        <span class="s1">config: babelrcFile</span>
      <span class="s1">} = yield* (</span><span class="s3">0</span><span class="s1">, _files.findRelativeConfig)(pkgData, context.envName, context.caller));</span>
      <span class="s2">if </span><span class="s1">(ignoreFile) {</span>
        <span class="s1">fileChain.files.add(ignoreFile.filepath);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(ignoreFile &amp;&amp; shouldIgnore(context, ignoreFile.ignore, </span><span class="s2">null</span><span class="s1">, ignoreFile.dirname)) {</span>
        <span class="s1">isIgnored = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(babelrcFile &amp;&amp; !isIgnored) {</span>
        <span class="s1">const validatedFile = validateBabelrcFile(babelrcFile);</span>
        <span class="s1">const babelrcLogger = </span><span class="s2">new </span><span class="s1">_printer.ConfigPrinter();</span>
        <span class="s1">const result = yield* loadFileChain(validatedFile, context, undefined, babelrcLogger);</span>
        <span class="s2">if </span><span class="s1">(!result) {</span>
          <span class="s1">isIgnored = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">babelRcReport = yield* babelrcLogger.output();</span>
          <span class="s1">mergeChain(fileChain, result);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(babelrcFile &amp;&amp; isIgnored) {</span>
        <span class="s1">fileChain.files.add(babelrcFile.filepath);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(context.showConfig) {</span>
    <span class="s1">console.log(`Babel configs on </span><span class="s0">&quot;${context.filename}&quot; </span><span class="s1">(ascending priority):\n` + [configReport, babelRcReport, programmaticReport].filter(x =&gt; !!x).join(</span><span class="s0">&quot;</span><span class="s4">\n\n</span><span class="s0">&quot;</span><span class="s1">) + </span><span class="s0">&quot;</span><span class="s4">\n</span><span class="s0">-----End Babel configs-----&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">const chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),</span>
    <span class="s1">presets: isIgnored ? [] : dedupDescriptors(chain.presets),</span>
    <span class="s1">options: isIgnored ? [] : chain.options.map(o =&gt; normalizeOptions(o)),</span>
    <span class="s1">fileHandling: isIgnored ? </span><span class="s0">&quot;ignored&quot; </span><span class="s1">: </span><span class="s0">&quot;transpile&quot;</span><span class="s1">,</span>
    <span class="s1">ignore: ignoreFile || undefined,</span>
    <span class="s1">babelrc: babelrcFile || undefined,</span>
    <span class="s1">config: configFile || undefined,</span>
    <span class="s1">files: chain.files</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">babelrcRoots === </span><span class="s0">&quot;boolean&quot;</span><span class="s1">) </span><span class="s2">return </span><span class="s1">babelrcRoots;</span>
  <span class="s1">const absoluteRoot = context.root;</span>
  <span class="s2">if </span><span class="s1">(babelrcRoots === undefined) {</span>
    <span class="s2">return </span><span class="s1">pkgData.directories.indexOf(absoluteRoot) !== -</span><span class="s3">1</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">let babelrcPatterns = babelrcRoots;</span>
  <span class="s2">if </span><span class="s1">(!Array.isArray(babelrcPatterns)) {</span>
    <span class="s1">babelrcPatterns = [babelrcPatterns];</span>
  <span class="s1">}</span>
  <span class="s1">babelrcPatterns = babelrcPatterns.map(pat =&gt; {</span>
    <span class="s2">return typeof </span><span class="s1">pat === </span><span class="s0">&quot;string&quot; </span><span class="s1">? _path().resolve(babelrcRootsDirectory, pat) : pat;</span>
  <span class="s1">});</span>
  <span class="s2">if </span><span class="s1">(babelrcPatterns.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp; babelrcPatterns[</span><span class="s3">0</span><span class="s1">] === absoluteRoot) {</span>
    <span class="s2">return </span><span class="s1">pkgData.directories.indexOf(absoluteRoot) !== -</span><span class="s3">1</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">babelrcPatterns.some(pat =&gt; {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">pat === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
      <span class="s1">pat = (</span><span class="s3">0</span><span class="s1">, _patternToRegex.</span><span class="s2">default</span><span class="s1">)(pat, babelrcRootsDirectory);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">pkgData.directories.some(directory =&gt; {</span>
      <span class="s2">return </span><span class="s1">matchPattern(pat, babelrcRootsDirectory, directory, context);</span>
    <span class="s1">});</span>
  <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">const validateConfigFile = (</span><span class="s3">0</span><span class="s1">, _caching.makeWeakCacheSync)(file =&gt; ({</span>
  <span class="s1">filepath: file.filepath,</span>
  <span class="s1">dirname: file.dirname,</span>
  <span class="s1">options: (</span><span class="s3">0</span><span class="s1">, _options.validate)(</span><span class="s0">&quot;configfile&quot;</span><span class="s1">, file.options, file.filepath)</span>
<span class="s1">}));</span>
<span class="s1">const validateBabelrcFile = (</span><span class="s3">0</span><span class="s1">, _caching.makeWeakCacheSync)(file =&gt; ({</span>
  <span class="s1">filepath: file.filepath,</span>
  <span class="s1">dirname: file.dirname,</span>
  <span class="s1">options: (</span><span class="s3">0</span><span class="s1">, _options.validate)(</span><span class="s0">&quot;babelrcfile&quot;</span><span class="s1">, file.options, file.filepath)</span>
<span class="s1">}));</span>
<span class="s1">const validateExtendFile = (</span><span class="s3">0</span><span class="s1">, _caching.makeWeakCacheSync)(file =&gt; ({</span>
  <span class="s1">filepath: file.filepath,</span>
  <span class="s1">dirname: file.dirname,</span>
  <span class="s1">options: (</span><span class="s3">0</span><span class="s1">, _options.validate)(</span><span class="s0">&quot;extendsfile&quot;</span><span class="s1">, file.options, file.filepath)</span>
<span class="s1">}));</span>
<span class="s1">const loadProgrammaticChain = makeChainWalker({</span>
  <span class="s1">root: input =&gt; buildRootDescriptors(input, </span><span class="s0">&quot;base&quot;</span><span class="s1">, _configDescriptors.createCachedDescriptors),</span>
  <span class="s1">env: (input, envName) =&gt; buildEnvDescriptors(input, </span><span class="s0">&quot;base&quot;</span><span class="s1">, _configDescriptors.createCachedDescriptors, envName),</span>
  <span class="s1">overrides: (input, index) =&gt; buildOverrideDescriptors(input, </span><span class="s0">&quot;base&quot;</span><span class="s1">, _configDescriptors.createCachedDescriptors, index),</span>
  <span class="s1">overridesEnv: (input, index, envName) =&gt; buildOverrideEnvDescriptors(input, </span><span class="s0">&quot;base&quot;</span><span class="s1">, _configDescriptors.createCachedDescriptors, index, envName),</span>
  <span class="s1">createLogger: (input, context, baseLogger) =&gt; buildProgrammaticLogger(input, context, baseLogger)</span>
<span class="s1">});</span>
<span class="s1">const loadFileChainWalker = makeChainWalker({</span>
  <span class="s1">root: file =&gt; loadFileDescriptors(file),</span>
  <span class="s1">env: (file, envName) =&gt; loadFileEnvDescriptors(file)(envName),</span>
  <span class="s1">overrides: (file, index) =&gt; loadFileOverridesDescriptors(file)(index),</span>
  <span class="s1">overridesEnv: (file, index, envName) =&gt; loadFileOverridesEnvDescriptors(file)(index)(envName),</span>
  <span class="s1">createLogger: (file, context, baseLogger) =&gt; buildFileLogger(file.filepath, context, baseLogger)</span>
<span class="s1">});</span>
<span class="s2">function</span><span class="s1">* loadFileChain(input, context, files, baseLogger) {</span>
  <span class="s1">const chain = yield* loadFileChainWalker(input, context, files, baseLogger);</span>
  <span class="s1">chain == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: chain.files.add(input.filepath);</span>
  <span class="s2">return </span><span class="s1">chain;</span>
<span class="s1">}</span>
<span class="s1">const loadFileDescriptors = (</span><span class="s3">0</span><span class="s1">, _caching.makeWeakCacheSync)(file =&gt; buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors));</span>
<span class="s1">const loadFileEnvDescriptors = (</span><span class="s3">0</span><span class="s1">, _caching.makeWeakCacheSync)(file =&gt; (</span><span class="s3">0</span><span class="s1">, _caching.makeStrongCacheSync)(envName =&gt; buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName)));</span>
<span class="s1">const loadFileOverridesDescriptors = (</span><span class="s3">0</span><span class="s1">, _caching.makeWeakCacheSync)(file =&gt; (</span><span class="s3">0</span><span class="s1">, _caching.makeStrongCacheSync)(index =&gt; buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index)));</span>
<span class="s1">const loadFileOverridesEnvDescriptors = (</span><span class="s3">0</span><span class="s1">, _caching.makeWeakCacheSync)(file =&gt; (</span><span class="s3">0</span><span class="s1">, _caching.makeStrongCacheSync)(index =&gt; (</span><span class="s3">0</span><span class="s1">, _caching.makeStrongCacheSync)(envName =&gt; buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index, envName))));</span>
<span class="s2">function </span><span class="s1">buildFileLogger(filepath, context, baseLogger) {</span>
  <span class="s2">if </span><span class="s1">(!baseLogger) {</span>
    <span class="s2">return </span><span class="s1">() =&gt; {};</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">baseLogger.configure(context.showConfig, _printer.ChainFormatter.Config, {</span>
    <span class="s1">filepath</span>
  <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildRootDescriptors({</span>
  <span class="s1">dirname,</span>
  <span class="s1">options</span>
<span class="s1">}, alias, descriptors) {</span>
  <span class="s2">return </span><span class="s1">descriptors(dirname, options, alias);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildProgrammaticLogger(_, context, baseLogger) {</span>
  <span class="s2">var </span><span class="s1">_context$caller;</span>
  <span class="s2">if </span><span class="s1">(!baseLogger) {</span>
    <span class="s2">return </span><span class="s1">() =&gt; {};</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">baseLogger.configure(context.showConfig, _printer.ChainFormatter.Programmatic, {</span>
    <span class="s1">callerName: (_context$caller = context.caller) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _context$caller.name</span>
  <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildEnvDescriptors({</span>
  <span class="s1">dirname,</span>
  <span class="s1">options</span>
<span class="s1">}, alias, descriptors, envName) {</span>
  <span class="s1">const opts = options.env &amp;&amp; options.env[envName];</span>
  <span class="s2">return </span><span class="s1">opts ? descriptors(dirname, opts, `${alias}.env[</span><span class="s0">&quot;${envName}&quot;</span><span class="s1">]`) : </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildOverrideDescriptors({</span>
  <span class="s1">dirname,</span>
  <span class="s1">options</span>
<span class="s1">}, alias, descriptors, index) {</span>
  <span class="s1">const opts = options.overrides &amp;&amp; options.overrides[index];</span>
  <span class="s2">if </span><span class="s1">(!opts) </span><span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;Assertion failure - missing override&quot;</span><span class="s1">);</span>
  <span class="s2">return </span><span class="s1">descriptors(dirname, opts, `${alias}.overrides[${index}]`);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildOverrideEnvDescriptors({</span>
  <span class="s1">dirname,</span>
  <span class="s1">options</span>
<span class="s1">}, alias, descriptors, index, envName) {</span>
  <span class="s1">const override = options.overrides &amp;&amp; options.overrides[index];</span>
  <span class="s2">if </span><span class="s1">(!override) </span><span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;Assertion failure - missing override&quot;</span><span class="s1">);</span>
  <span class="s1">const opts = override.env &amp;&amp; override.env[envName];</span>
  <span class="s2">return </span><span class="s1">opts ? descriptors(dirname, opts, `${alias}.overrides[${index}].env[</span><span class="s0">&quot;${envName}&quot;</span><span class="s1">]`) : </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeChainWalker({</span>
  <span class="s1">root,</span>
  <span class="s1">env,</span>
  <span class="s1">overrides,</span>
  <span class="s1">overridesEnv,</span>
  <span class="s1">createLogger</span>
<span class="s1">}) {</span>
  <span class="s2">return function</span><span class="s1">* chainWalker(input, context, files = </span><span class="s2">new </span><span class="s1">Set(), baseLogger) {</span>
    <span class="s1">const {</span>
      <span class="s1">dirname</span>
    <span class="s1">} = input;</span>
    <span class="s1">const flattenedConfigs = [];</span>
    <span class="s1">const rootOpts = root(input);</span>
    <span class="s2">if </span><span class="s1">(configIsApplicable(rootOpts, dirname, context, input.filepath)) {</span>
      <span class="s1">flattenedConfigs.push({</span>
        <span class="s1">config: rootOpts,</span>
        <span class="s1">envName: undefined,</span>
        <span class="s1">index: undefined</span>
      <span class="s1">});</span>
      <span class="s1">const envOpts = env(input, context.envName);</span>
      <span class="s2">if </span><span class="s1">(envOpts &amp;&amp; configIsApplicable(envOpts, dirname, context, input.filepath)) {</span>
        <span class="s1">flattenedConfigs.push({</span>
          <span class="s1">config: envOpts,</span>
          <span class="s1">envName: context.envName,</span>
          <span class="s1">index: undefined</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s1">(rootOpts.options.overrides || []).forEach((_, index) =&gt; {</span>
        <span class="s1">const overrideOps = overrides(input, index);</span>
        <span class="s2">if </span><span class="s1">(configIsApplicable(overrideOps, dirname, context, input.filepath)) {</span>
          <span class="s1">flattenedConfigs.push({</span>
            <span class="s1">config: overrideOps,</span>
            <span class="s1">index,</span>
            <span class="s1">envName: undefined</span>
          <span class="s1">});</span>
          <span class="s1">const overrideEnvOpts = overridesEnv(input, index, context.envName);</span>
          <span class="s2">if </span><span class="s1">(overrideEnvOpts &amp;&amp; configIsApplicable(overrideEnvOpts, dirname, context, input.filepath)) {</span>
            <span class="s1">flattenedConfigs.push({</span>
              <span class="s1">config: overrideEnvOpts,</span>
              <span class="s1">index,</span>
              <span class="s1">envName: context.envName</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(flattenedConfigs.some(({</span>
      <span class="s1">config: {</span>
        <span class="s1">options: {</span>
          <span class="s1">ignore,</span>
          <span class="s1">only</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}) =&gt; shouldIgnore(context, ignore, only, dirname))) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const chain = emptyChain();</span>
    <span class="s1">const logger = createLogger(input, context, baseLogger);</span>
    <span class="s2">for </span><span class="s1">(const {</span>
      <span class="s1">config,</span>
      <span class="s1">index,</span>
      <span class="s1">envName</span>
    <span class="s1">} of flattenedConfigs) {</span>
      <span class="s2">if </span><span class="s1">(!(yield* mergeExtendsChain(chain, config.options, dirname, context, files, baseLogger))) {</span>
        <span class="s2">return null</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">logger(config, index, envName);</span>
      <span class="s1">yield* mergeChainOpts(chain, config);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">chain;</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function</span><span class="s1">* mergeExtendsChain(chain, opts, dirname, context, files, baseLogger) {</span>
  <span class="s2">if </span><span class="s1">(opts.extends === undefined) </span><span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">const file = yield* (</span><span class="s3">0</span><span class="s1">, _files.loadConfig)(opts.extends, dirname, context.envName, context.caller);</span>
  <span class="s2">if </span><span class="s1">(files.has(file)) {</span>
    <span class="s2">throw new </span><span class="s1">Error(`Configuration cycle detected loading ${file.filepath}.\n` + `File already loaded following the config chain:\n` + Array.from(files, file =&gt; ` - ${file.filepath}`).join(</span><span class="s0">&quot;</span><span class="s4">\n</span><span class="s0">&quot;</span><span class="s1">));</span>
  <span class="s1">}</span>
  <span class="s1">files.add(file);</span>
  <span class="s1">const fileChain = yield* loadFileChain(validateExtendFile(file), context, files, baseLogger);</span>
  <span class="s1">files.</span><span class="s2">delete</span><span class="s1">(file);</span>
  <span class="s2">if </span><span class="s1">(!fileChain) </span><span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">mergeChain(chain, fileChain);</span>
  <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mergeChain(target, source) {</span>
  <span class="s1">target.options.push(...source.options);</span>
  <span class="s1">target.plugins.push(...source.plugins);</span>
  <span class="s1">target.presets.push(...source.presets);</span>
  <span class="s2">for </span><span class="s1">(const file of source.files) {</span>
    <span class="s1">target.files.add(file);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">target;</span>
<span class="s1">}</span>
<span class="s2">function</span><span class="s1">* mergeChainOpts(target, {</span>
  <span class="s1">options,</span>
  <span class="s1">plugins,</span>
  <span class="s1">presets</span>
<span class="s1">}) {</span>
  <span class="s1">target.options.push(options);</span>
  <span class="s1">target.plugins.push(...(yield* plugins()));</span>
  <span class="s1">target.presets.push(...(yield* presets()));</span>
  <span class="s2">return </span><span class="s1">target;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">emptyChain() {</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">options: [],</span>
    <span class="s1">presets: [],</span>
    <span class="s1">plugins: [],</span>
    <span class="s1">files: </span><span class="s2">new </span><span class="s1">Set()</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeOptions(opts) {</span>
  <span class="s1">const options = Object.assign({}, opts);</span>
  <span class="s2">delete </span><span class="s1">options.extends;</span>
  <span class="s2">delete </span><span class="s1">options.env;</span>
  <span class="s2">delete </span><span class="s1">options.overrides;</span>
  <span class="s2">delete </span><span class="s1">options.plugins;</span>
  <span class="s2">delete </span><span class="s1">options.presets;</span>
  <span class="s2">delete </span><span class="s1">options.passPerPreset;</span>
  <span class="s2">delete </span><span class="s1">options.ignore;</span>
  <span class="s2">delete </span><span class="s1">options.only;</span>
  <span class="s2">delete </span><span class="s1">options.test;</span>
  <span class="s2">delete </span><span class="s1">options.include;</span>
  <span class="s2">delete </span><span class="s1">options.exclude;</span>
  <span class="s2">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(options, </span><span class="s0">&quot;sourceMap&quot;</span><span class="s1">)) {</span>
    <span class="s1">options.sourceMaps = options.sourceMap;</span>
    <span class="s2">delete </span><span class="s1">options.sourceMap;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">options;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">dedupDescriptors(items) {</span>
  <span class="s1">const map = </span><span class="s2">new </span><span class="s1">Map();</span>
  <span class="s1">const descriptors = [];</span>
  <span class="s2">for </span><span class="s1">(const item of items) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">item.value === </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">const fnKey = item.value;</span>
      <span class="s1">let nameMap = map.get(fnKey);</span>
      <span class="s2">if </span><span class="s1">(!nameMap) {</span>
        <span class="s1">nameMap = </span><span class="s2">new </span><span class="s1">Map();</span>
        <span class="s1">map.set(fnKey, nameMap);</span>
      <span class="s1">}</span>
      <span class="s1">let desc = nameMap.get(item.name);</span>
      <span class="s2">if </span><span class="s1">(!desc) {</span>
        <span class="s1">desc = {</span>
          <span class="s1">value: item</span>
        <span class="s1">};</span>
        <span class="s1">descriptors.push(desc);</span>
        <span class="s2">if </span><span class="s1">(!item.ownPass) nameMap.set(item.name, desc);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">desc.value = item;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">descriptors.push({</span>
        <span class="s1">value: item</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">descriptors.reduce((acc, desc) =&gt; {</span>
    <span class="s1">acc.push(desc.value);</span>
    <span class="s2">return </span><span class="s1">acc;</span>
  <span class="s1">}, []);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">configIsApplicable({</span>
  <span class="s1">options</span>
<span class="s1">}, dirname, context, configName) {</span>
  <span class="s2">return </span><span class="s1">(options.test === undefined || configFieldIsApplicable(context, options.test, dirname, configName)) &amp;&amp; (options.include === undefined || configFieldIsApplicable(context, options.include, dirname, configName)) &amp;&amp; (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname, configName));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">configFieldIsApplicable(context, test, dirname, configName) {</span>
  <span class="s1">const patterns = Array.isArray(test) ? test : [test];</span>
  <span class="s2">return </span><span class="s1">matchesPatterns(context, patterns, dirname, configName);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">ignoreListReplacer(_key, value) {</span>
  <span class="s2">if </span><span class="s1">(value </span><span class="s2">instanceof </span><span class="s1">RegExp) {</span>
    <span class="s2">return </span><span class="s1">String(value);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">value;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">shouldIgnore(context, ignore, only, dirname) {</span>
  <span class="s2">if </span><span class="s1">(ignore &amp;&amp; matchesPatterns(context, ignore, dirname)) {</span>
    <span class="s2">var </span><span class="s1">_context$filename;</span>
    <span class="s1">const message = `No config is applied to </span><span class="s0">&quot;${(_context$filename = context.filename) != null ? _context$filename : &quot;</span><span class="s1">(unknown)</span><span class="s0">&quot;}&quot; </span><span class="s1">because it matches one of \`ignore: ${JSON.stringify(ignore, ignoreListReplacer)}\` from </span><span class="s0">&quot;${dirname}&quot;</span><span class="s1">`;</span>
    <span class="s1">debug(message);</span>
    <span class="s2">if </span><span class="s1">(context.showConfig) {</span>
      <span class="s1">console.log(message);</span>
    <span class="s1">}</span>
    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(only &amp;&amp; !matchesPatterns(context, only, dirname)) {</span>
    <span class="s2">var </span><span class="s1">_context$filename2;</span>
    <span class="s1">const message = `No config is applied to </span><span class="s0">&quot;${(_context$filename2 = context.filename) != null ? _context$filename2 : &quot;</span><span class="s1">(unknown)</span><span class="s0">&quot;}&quot; </span><span class="s1">because it fails to match one of \`only: ${JSON.stringify(only, ignoreListReplacer)}\` from </span><span class="s0">&quot;${dirname}&quot;</span><span class="s1">`;</span>
    <span class="s1">debug(message);</span>
    <span class="s2">if </span><span class="s1">(context.showConfig) {</span>
      <span class="s1">console.log(message);</span>
    <span class="s1">}</span>
    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">matchesPatterns(context, patterns, dirname, configName) {</span>
  <span class="s2">return </span><span class="s1">patterns.some(pattern =&gt; matchPattern(pattern, dirname, context.filename, context, configName));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">matchPattern(pattern, dirname, pathToTest, context, configName) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">pattern === </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">!!(</span><span class="s3">0</span><span class="s1">, _rewriteStackTrace.endHiddenCallStack)(pattern)(pathToTest, {</span>
      <span class="s1">dirname,</span>
      <span class="s1">envName: context.envName,</span>
      <span class="s1">caller: context.caller</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">pathToTest !== </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
    <span class="s2">throw new </span><span class="s1">_configError.</span><span class="s2">default</span><span class="s1">(`Configuration contains string/RegExp pattern, but no filename was passed to Babel`, configName);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">pattern === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
    <span class="s1">pattern = (</span><span class="s3">0</span><span class="s1">, _patternToRegex.</span><span class="s2">default</span><span class="s1">)(pattern, dirname);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">pattern.test(pathToTest);</span>
<span class="s1">}</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; </span><span class="s3">0</span><span class="s1">;</span>

<span class="s5">//# sourceMappingURL=config-chain.js.map</span>
</pre>
</body>
</html>
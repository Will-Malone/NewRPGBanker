<html>
<head>
<title>ReactViewBackgroundDrawable.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #629755; font-weight: bold; font-style: italic;}
.s5 { color: #77b767; font-style: italic;}
.s6 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ReactViewBackgroundDrawable.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.views.view</span><span class="s2">;</span>

<span class="s2">import static </span><span class="s1">android.os.Build.VERSION_CODES.LOLLIPOP</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.annotation.TargetApi</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.content.Context</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Canvas</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Color</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.ColorFilter</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.DashPathEffect</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Outline</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Paint</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Path</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.PathEffect</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.PointF</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Rect</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.RectF</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Region</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.drawable.Drawable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.View</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.annotations.VisibleForTesting</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.config.ReactFeatureFlags</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.modules.i18nmanager.I18nUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.FloatUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.Spacing</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaConstants</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Arrays</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Locale</span><span class="s2">;</span>

<span class="s3">/**</span>
 <span class="s3">* A subclass of {</span><span class="s4">@link </span><span class="s3">Drawable} used for background of {</span><span class="s4">@link </span><span class="s3">ReactViewGroup}. It supports drawing</span>
 <span class="s3">* background color and borders (including rounded borders) by providing a react friendly API</span>
 <span class="s3">* (setter for each of those properties).</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">The implementation tries to allocate as few objects as possible depending on which properties</span>
 <span class="s3">* are set. E.g. for views with rounded background/borders we allocate {</span><span class="s4">@code</span>
 <span class="s3">* mInnerClipPathForBorderRadius} and {</span><span class="s4">@code </span><span class="s3">mInnerClipTempRectForBorderRadius}. In case when view</span>
 <span class="s3">* have a rectangular borders we allocate {</span><span class="s4">@code </span><span class="s3">mBorderWidthResult} and similar. When only</span>
 <span class="s3">* background color is set we won't allocate any extra/unnecessary objects.</span>
 <span class="s3">*/</span>
<span class="s2">public class </span><span class="s1">ReactViewBackgroundDrawable </span><span class="s2">extends </span><span class="s1">Drawable {</span>

  <span class="s2">private static final int </span><span class="s1">DEFAULT_BORDER_COLOR = Color.BLACK</span><span class="s2">;</span>
  <span class="s2">private static final int </span><span class="s1">DEFAULT_BORDER_RGB = </span><span class="s6">0x00FFFFFF </span><span class="s1">&amp; DEFAULT_BORDER_COLOR</span><span class="s2">;</span>
  <span class="s2">private static final int </span><span class="s1">DEFAULT_BORDER_ALPHA = (</span><span class="s6">0xFF000000 </span><span class="s1">&amp; DEFAULT_BORDER_COLOR) &gt;&gt;&gt; </span><span class="s6">24</span><span class="s2">;</span>
  <span class="s0">// ~0 == 0xFFFFFFFF, all bits set to 1.</span>
  <span class="s2">private static final int </span><span class="s1">ALL_BITS_SET = ~</span><span class="s6">0</span><span class="s2">;</span>
  <span class="s0">// 0 == 0x00000000, all bits set to 0.</span>
  <span class="s2">private static final int </span><span class="s1">ALL_BITS_UNSET = </span><span class="s6">0</span><span class="s2">;</span>

  <span class="s2">private enum </span><span class="s1">BorderStyle {</span>
    <span class="s1">SOLID</span><span class="s2">,</span>
    <span class="s1">DASHED</span><span class="s2">,</span>
    <span class="s1">DOTTED</span><span class="s2">;</span>

    <span class="s2">public static </span><span class="s1">@Nullable PathEffect getPathEffect(BorderStyle style</span><span class="s2">, float </span><span class="s1">borderWidth) {</span>
      <span class="s2">switch </span><span class="s1">(style) {</span>
        <span class="s2">case </span><span class="s1">SOLID:</span>
          <span class="s2">return null;</span>

        <span class="s2">case </span><span class="s1">DASHED:</span>
          <span class="s2">return new </span><span class="s1">DashPathEffect(</span>
              <span class="s2">new float</span><span class="s1">[] {borderWidth * </span><span class="s6">3</span><span class="s2">, </span><span class="s1">borderWidth * </span><span class="s6">3</span><span class="s2">, </span><span class="s1">borderWidth * </span><span class="s6">3</span><span class="s2">, </span><span class="s1">borderWidth * </span><span class="s6">3</span><span class="s1">}</span><span class="s2">, </span><span class="s6">0</span><span class="s1">)</span><span class="s2">;</span>

        <span class="s2">case </span><span class="s1">DOTTED:</span>
          <span class="s2">return new </span><span class="s1">DashPathEffect(</span>
              <span class="s2">new float</span><span class="s1">[] {borderWidth</span><span class="s2">, </span><span class="s1">borderWidth</span><span class="s2">, </span><span class="s1">borderWidth</span><span class="s2">, </span><span class="s1">borderWidth}</span><span class="s2">, </span><span class="s6">0</span><span class="s1">)</span><span class="s2">;</span>

        <span class="s2">default</span><span class="s1">:</span>
          <span class="s2">return null;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s0">/* Value at Spacing.ALL index used for rounded borders, whole array used by rectangular borders */</span>
  <span class="s2">private </span><span class="s1">@Nullable Spacing mBorderWidth</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Spacing mBorderRGB</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Spacing mBorderAlpha</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable BorderStyle mBorderStyle</span><span class="s2">;</span>

  <span class="s2">private </span><span class="s1">@Nullable Path mInnerClipPathForBorderRadius</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Path mBackgroundColorRenderPath</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Path mOuterClipPathForBorderRadius</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Path mPathForBorderRadiusOutline</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Path mPathForBorder</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">Path mPathForSingleBorder = </span><span class="s2">new </span><span class="s1">Path()</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Path mCenterDrawPath</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable RectF mInnerClipTempRectForBorderRadius</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable RectF mOuterClipTempRectForBorderRadius</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable RectF mTempRectForBorderRadiusOutline</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable RectF mTempRectForCenterDrawPath</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable PointF mInnerTopLeftCorner</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable PointF mInnerTopRightCorner</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable PointF mInnerBottomRightCorner</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable PointF mInnerBottomLeftCorner</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mNeedUpdatePathForBorderRadius = </span><span class="s2">false;</span>
  <span class="s2">private float </span><span class="s1">mBorderRadius = YogaConstants.UNDEFINED</span><span class="s2">;</span>

  <span class="s0">/* Used by all types of background and for drawing borders */</span>
  <span class="s2">private final </span><span class="s1">Paint mPaint = </span><span class="s2">new </span><span class="s1">Paint(Paint.ANTI_ALIAS_FLAG)</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mColor = Color.TRANSPARENT</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mAlpha = </span><span class="s6">255</span><span class="s2">;</span>

  <span class="s0">// There is a small gap between the edges of adjacent paths</span>
  <span class="s0">// such as between the mBackgroundColorRenderPath and its border.</span>
  <span class="s0">// The smallest amount (found to be 0.8f) is used to extend</span>
  <span class="s0">// the paths, overlapping them and closing the visible gap.</span>
  <span class="s2">private final float </span><span class="s1">mGapBetweenPaths =</span>
      <span class="s1">ReactFeatureFlags.enableCloseVisibleGapBetweenPaths ? </span><span class="s6">0.8f </span><span class="s1">: </span><span class="s6">0.0f</span><span class="s2">;</span>

  <span class="s2">private </span><span class="s1">@Nullable </span><span class="s2">float</span><span class="s1">[] mBorderCornerRadii</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">Context mContext</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mLayoutDirection</span><span class="s2">;</span>

  <span class="s2">public enum </span><span class="s1">BorderRadiusLocation {</span>
    <span class="s1">TOP_LEFT</span><span class="s2">,</span>
    <span class="s1">TOP_RIGHT</span><span class="s2">,</span>
    <span class="s1">BOTTOM_RIGHT</span><span class="s2">,</span>
    <span class="s1">BOTTOM_LEFT</span><span class="s2">,</span>
    <span class="s1">TOP_START</span><span class="s2">,</span>
    <span class="s1">TOP_END</span><span class="s2">,</span>
    <span class="s1">BOTTOM_START</span><span class="s2">,</span>
    <span class="s1">BOTTOM_END</span><span class="s2">,</span>
    <span class="s1">END_END</span><span class="s2">,</span>
    <span class="s1">END_START</span><span class="s2">,</span>
    <span class="s1">START_END</span><span class="s2">,</span>
    <span class="s1">START_START</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">ReactViewBackgroundDrawable(Context context) {</span>
    <span class="s1">mContext = context</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">draw(Canvas canvas) {</span>
    <span class="s1">updatePathEffect()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!hasRoundedBorders()) {</span>
      <span class="s1">drawRectangularBackgroundWithBorders(canvas)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">drawRoundedBackgroundWithBorders(canvas)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public boolean </span><span class="s1">hasRoundedBorders() {</span>
    <span class="s2">if </span><span class="s1">(!YogaConstants.isUndefined(mBorderRadius) &amp;&amp; mBorderRadius &gt; </span><span class="s6">0</span><span class="s1">) {</span>
      <span class="s2">return true;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mBorderCornerRadii != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">final float </span><span class="s1">borderRadii : mBorderCornerRadii) {</span>
        <span class="s2">if </span><span class="s1">(!YogaConstants.isUndefined(borderRadii) &amp;&amp; borderRadii &gt; </span><span class="s6">0</span><span class="s1">) {</span>
          <span class="s2">return true;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return false;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onBoundsChange(Rect bounds) {</span>
    <span class="s2">super</span><span class="s1">.onBoundsChange(bounds)</span><span class="s2">;</span>
    <span class="s1">mNeedUpdatePathForBorderRadius = </span><span class="s2">true;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setAlpha(</span><span class="s2">int </span><span class="s1">alpha) {</span>
    <span class="s2">if </span><span class="s1">(alpha != mAlpha) {</span>
      <span class="s1">mAlpha = alpha</span><span class="s2">;</span>
      <span class="s1">invalidateSelf()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public int </span><span class="s1">getAlpha() {</span>
    <span class="s2">return </span><span class="s1">mAlpha</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setColorFilter(ColorFilter cf) {</span>
    <span class="s0">// do nothing</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public int </span><span class="s1">getOpacity() {</span>
    <span class="s2">return </span><span class="s1">ColorUtil.getOpacityFromColor(ColorUtil.multiplyColorAlpha(mColor</span><span class="s2">, </span><span class="s1">mAlpha))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/* Android's elevation implementation requires this to be implemented to know where to draw the shadow. */</span>
  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">getOutline(Outline outline) {</span>
    <span class="s2">if </span><span class="s1">((!YogaConstants.isUndefined(mBorderRadius) &amp;&amp; mBorderRadius &gt; </span><span class="s6">0</span><span class="s1">)</span>
        <span class="s1">|| mBorderCornerRadii != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">updatePath()</span><span class="s2">;</span>

      <span class="s1">outline.setConvexPath(mPathForBorderRadiusOutline)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">outline.setRect(getBounds())</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderWidth(</span><span class="s2">int </span><span class="s1">position</span><span class="s2">, float </span><span class="s1">width) {</span>
    <span class="s2">if </span><span class="s1">(mBorderWidth == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mBorderWidth = </span><span class="s2">new </span><span class="s1">Spacing()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!FloatUtil.floatsEqual(mBorderWidth.getRaw(position)</span><span class="s2">, </span><span class="s1">width)) {</span>
      <span class="s1">mBorderWidth.set(position</span><span class="s2">, </span><span class="s1">width)</span><span class="s2">;</span>
      <span class="s2">switch </span><span class="s1">(position) {</span>
        <span class="s2">case </span><span class="s1">Spacing.ALL:</span>
        <span class="s2">case </span><span class="s1">Spacing.LEFT:</span>
        <span class="s2">case </span><span class="s1">Spacing.BOTTOM:</span>
        <span class="s2">case </span><span class="s1">Spacing.RIGHT:</span>
        <span class="s2">case </span><span class="s1">Spacing.TOP:</span>
        <span class="s2">case </span><span class="s1">Spacing.START:</span>
        <span class="s2">case </span><span class="s1">Spacing.END:</span>
          <span class="s1">mNeedUpdatePathForBorderRadius = </span><span class="s2">true;</span>
      <span class="s1">}</span>
      <span class="s1">invalidateSelf()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderColor(</span><span class="s2">int </span><span class="s1">position</span><span class="s2">, float </span><span class="s1">rgb</span><span class="s2">, float </span><span class="s1">alpha) {</span>
    <span class="s2">this</span><span class="s1">.setBorderRGB(position</span><span class="s2">, </span><span class="s1">rgb)</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.setBorderAlpha(position</span><span class="s2">, </span><span class="s1">alpha)</span><span class="s2">;</span>
    <span class="s1">mNeedUpdatePathForBorderRadius = </span><span class="s2">true;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">setBorderRGB(</span><span class="s2">int </span><span class="s1">position</span><span class="s2">, float </span><span class="s1">rgb) {</span>
    <span class="s0">// set RGB component</span>
    <span class="s2">if </span><span class="s1">(mBorderRGB == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mBorderRGB = </span><span class="s2">new </span><span class="s1">Spacing(DEFAULT_BORDER_RGB)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!FloatUtil.floatsEqual(mBorderRGB.getRaw(position)</span><span class="s2">, </span><span class="s1">rgb)) {</span>
      <span class="s1">mBorderRGB.set(position</span><span class="s2">, </span><span class="s1">rgb)</span><span class="s2">;</span>
      <span class="s1">invalidateSelf()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">setBorderAlpha(</span><span class="s2">int </span><span class="s1">position</span><span class="s2">, float </span><span class="s1">alpha) {</span>
    <span class="s0">// set Alpha component</span>
    <span class="s2">if </span><span class="s1">(mBorderAlpha == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mBorderAlpha = </span><span class="s2">new </span><span class="s1">Spacing(DEFAULT_BORDER_ALPHA)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!FloatUtil.floatsEqual(mBorderAlpha.getRaw(position)</span><span class="s2">, </span><span class="s1">alpha)) {</span>
      <span class="s1">mBorderAlpha.set(position</span><span class="s2">, </span><span class="s1">alpha)</span><span class="s2">;</span>
      <span class="s1">invalidateSelf()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderStyle(@Nullable String style) {</span>
    <span class="s1">BorderStyle borderStyle =</span>
        <span class="s1">style == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: BorderStyle.valueOf(style.toUpperCase(Locale.US))</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mBorderStyle != borderStyle) {</span>
      <span class="s1">mBorderStyle = borderStyle</span><span class="s2">;</span>
      <span class="s1">mNeedUpdatePathForBorderRadius = </span><span class="s2">true;</span>
      <span class="s1">invalidateSelf()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setRadius(</span><span class="s2">float </span><span class="s1">radius) {</span>
    <span class="s2">if </span><span class="s1">(!FloatUtil.floatsEqual(mBorderRadius</span><span class="s2">, </span><span class="s1">radius)) {</span>
      <span class="s1">mBorderRadius = radius</span><span class="s2">;</span>
      <span class="s1">mNeedUpdatePathForBorderRadius = </span><span class="s2">true;</span>
      <span class="s1">invalidateSelf()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setRadius(</span><span class="s2">float </span><span class="s1">radius</span><span class="s2">, int </span><span class="s1">position) {</span>
    <span class="s2">if </span><span class="s1">(mBorderCornerRadii == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mBorderCornerRadii = </span><span class="s2">new float</span><span class="s1">[</span><span class="s6">12</span><span class="s1">]</span><span class="s2">;</span>
      <span class="s1">Arrays.fill(mBorderCornerRadii</span><span class="s2">, </span><span class="s1">YogaConstants.UNDEFINED)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!FloatUtil.floatsEqual(mBorderCornerRadii[position]</span><span class="s2">, </span><span class="s1">radius)) {</span>
      <span class="s1">mBorderCornerRadii[position] = radius</span><span class="s2">;</span>
      <span class="s1">mNeedUpdatePathForBorderRadius = </span><span class="s2">true;</span>
      <span class="s1">invalidateSelf()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public float </span><span class="s1">getFullBorderRadius() {</span>
    <span class="s2">return </span><span class="s1">YogaConstants.isUndefined(mBorderRadius) ? </span><span class="s6">0 </span><span class="s1">: mBorderRadius</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public float </span><span class="s1">getBorderRadius(</span><span class="s2">final </span><span class="s1">BorderRadiusLocation location) {</span>
    <span class="s2">return </span><span class="s1">getBorderRadiusOrDefaultTo(YogaConstants.UNDEFINED</span><span class="s2">, </span><span class="s1">location)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public float </span><span class="s1">getBorderRadiusOrDefaultTo(</span>
      <span class="s2">final float </span><span class="s1">defaultValue</span><span class="s2">, final </span><span class="s1">BorderRadiusLocation location) {</span>
    <span class="s2">if </span><span class="s1">(mBorderCornerRadii == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">defaultValue</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">final float </span><span class="s1">radius = mBorderCornerRadii[location.ordinal()]</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(YogaConstants.isUndefined(radius)) {</span>
      <span class="s2">return </span><span class="s1">defaultValue</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">radius</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setColor(</span><span class="s2">int </span><span class="s1">color) {</span>
    <span class="s1">mColor = color</span><span class="s2">;</span>
    <span class="s1">invalidateSelf()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Similar to Drawable.getLayoutDirection, but available in APIs &lt; 23. */</span>
  <span class="s2">public int </span><span class="s1">getResolvedLayoutDirection() {</span>
    <span class="s2">return </span><span class="s1">mLayoutDirection</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Similar to Drawable.setLayoutDirection, but available in APIs &lt; 23. */</span>
  <span class="s2">public boolean </span><span class="s1">setResolvedLayoutDirection(</span><span class="s2">int </span><span class="s1">layoutDirection) {</span>
    <span class="s2">if </span><span class="s1">(mLayoutDirection != layoutDirection) {</span>
      <span class="s1">mLayoutDirection = layoutDirection</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">onResolvedLayoutDirectionChanged(layoutDirection)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>

  <span class="s3">/** Similar to Drawable.onLayoutDirectionChanged, but available in APIs &lt; 23. */</span>
  <span class="s2">public boolean </span><span class="s1">onResolvedLayoutDirectionChanged(</span><span class="s2">int </span><span class="s1">layoutDirection) {</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>

  <span class="s1">@VisibleForTesting</span>
  <span class="s2">public int </span><span class="s1">getColor() {</span>
    <span class="s2">return </span><span class="s1">mColor</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">drawRoundedBackgroundWithBorders(Canvas canvas) {</span>
    <span class="s1">updatePath()</span><span class="s2">;</span>
    <span class="s1">canvas.save()</span><span class="s2">;</span>

    <span class="s0">// Clip outer border</span>
    <span class="s1">canvas.clipPath(mOuterClipPathForBorderRadius</span><span class="s2">, </span><span class="s1">Region.Op.INTERSECT)</span><span class="s2">;</span>

    <span class="s0">// Draws the View without its border first (with background color fill)</span>
    <span class="s2">int </span><span class="s1">useColor = ColorUtil.multiplyColorAlpha(mColor</span><span class="s2">, </span><span class="s1">mAlpha)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(Color.alpha(useColor) != </span><span class="s6">0</span><span class="s1">) { </span><span class="s0">// color is not transparent</span>
      <span class="s1">mPaint.setColor(useColor)</span><span class="s2">;</span>
      <span class="s1">mPaint.setStyle(Paint.Style.FILL)</span><span class="s2">;</span>
      <span class="s1">canvas.drawPath(mBackgroundColorRenderPath</span><span class="s2">, </span><span class="s1">mPaint)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">final </span><span class="s1">RectF borderWidth = getDirectionAwareBorderInsets()</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">colorLeft = getBorderColor(Spacing.LEFT)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">colorTop = getBorderColor(Spacing.TOP)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">colorRight = getBorderColor(Spacing.RIGHT)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">colorBottom = getBorderColor(Spacing.BOTTOM)</span><span class="s2">;</span>

    <span class="s2">int </span><span class="s1">colorBlock = getBorderColor(Spacing.BLOCK)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">colorBlockStart = getBorderColor(Spacing.BLOCK_START)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">colorBlockEnd = getBorderColor(Spacing.BLOCK_END)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(isBorderColorDefined(Spacing.BLOCK)) {</span>
      <span class="s1">colorBottom = colorBlock</span><span class="s2">;</span>
      <span class="s1">colorTop = colorBlock</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isBorderColorDefined(Spacing.BLOCK_END)) {</span>
      <span class="s1">colorBottom = colorBlockEnd</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isBorderColorDefined(Spacing.BLOCK_START)) {</span>
      <span class="s1">colorTop = colorBlockStart</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(borderWidth.top &gt; </span><span class="s6">0</span>
        <span class="s1">|| borderWidth.bottom &gt; </span><span class="s6">0</span>
        <span class="s1">|| borderWidth.left &gt; </span><span class="s6">0</span>
        <span class="s1">|| borderWidth.right &gt; </span><span class="s6">0</span><span class="s1">) {</span>

      <span class="s0">// If it's a full and even border draw inner rect path with stroke</span>
      <span class="s2">final float </span><span class="s1">fullBorderWidth = getFullBorderWidth()</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">borderColor = getBorderColor(Spacing.ALL)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(borderWidth.top == fullBorderWidth</span>
          <span class="s1">&amp;&amp; borderWidth.bottom == fullBorderWidth</span>
          <span class="s1">&amp;&amp; borderWidth.left == fullBorderWidth</span>
          <span class="s1">&amp;&amp; borderWidth.right == fullBorderWidth</span>
          <span class="s1">&amp;&amp; colorLeft == borderColor</span>
          <span class="s1">&amp;&amp; colorTop == borderColor</span>
          <span class="s1">&amp;&amp; colorRight == borderColor</span>
          <span class="s1">&amp;&amp; colorBottom == borderColor) {</span>
        <span class="s2">if </span><span class="s1">(fullBorderWidth &gt; </span><span class="s6">0</span><span class="s1">) {</span>
          <span class="s1">mPaint.setColor(ColorUtil.multiplyColorAlpha(borderColor</span><span class="s2">, </span><span class="s1">mAlpha))</span><span class="s2">;</span>
          <span class="s1">mPaint.setStyle(Paint.Style.STROKE)</span><span class="s2">;</span>
          <span class="s1">mPaint.setStrokeWidth(fullBorderWidth)</span><span class="s2">;</span>
          <span class="s1">canvas.drawPath(mCenterDrawPath</span><span class="s2">, </span><span class="s1">mPaint)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">// In the case of uneven border widths/colors draw quadrilateral in each direction</span>
      <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">mPaint.setStyle(Paint.Style.FILL)</span><span class="s2">;</span>

        <span class="s0">// Clip inner border</span>
        <span class="s1">canvas.clipPath(mInnerClipPathForBorderRadius</span><span class="s2">, </span><span class="s1">Region.Op.DIFFERENCE)</span><span class="s2">;</span>

        <span class="s2">final boolean </span><span class="s1">isRTL = getResolvedLayoutDirection() == View.LAYOUT_DIRECTION_RTL</span><span class="s2">;</span>
        <span class="s2">int </span><span class="s1">colorStart = getBorderColor(Spacing.START)</span><span class="s2">;</span>
        <span class="s2">int </span><span class="s1">colorEnd = getBorderColor(Spacing.END)</span><span class="s2">;</span>

        <span class="s2">if </span><span class="s1">(I18nUtil.getInstance().doLeftAndRightSwapInRTL(mContext)) {</span>
          <span class="s2">if </span><span class="s1">(!isBorderColorDefined(Spacing.START)) {</span>
            <span class="s1">colorStart = colorLeft</span><span class="s2">;</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(!isBorderColorDefined(Spacing.END)) {</span>
            <span class="s1">colorEnd = colorRight</span><span class="s2">;</span>
          <span class="s1">}</span>

          <span class="s2">final int </span><span class="s1">directionAwareColorLeft = isRTL ? colorEnd : colorStart</span><span class="s2">;</span>
          <span class="s2">final int </span><span class="s1">directionAwareColorRight = isRTL ? colorStart : colorEnd</span><span class="s2">;</span>

          <span class="s1">colorLeft = directionAwareColorLeft</span><span class="s2">;</span>
          <span class="s1">colorRight = directionAwareColorRight</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">final int </span><span class="s1">directionAwareColorLeft = isRTL ? colorEnd : colorStart</span><span class="s2">;</span>
          <span class="s2">final int </span><span class="s1">directionAwareColorRight = isRTL ? colorStart : colorEnd</span><span class="s2">;</span>

          <span class="s2">final boolean </span><span class="s1">isColorStartDefined = isBorderColorDefined(Spacing.START)</span><span class="s2">;</span>
          <span class="s2">final boolean </span><span class="s1">isColorEndDefined = isBorderColorDefined(Spacing.END)</span><span class="s2">;</span>
          <span class="s2">final boolean </span><span class="s1">isDirectionAwareColorLeftDefined =</span>
              <span class="s1">isRTL ? isColorEndDefined : isColorStartDefined</span><span class="s2">;</span>
          <span class="s2">final boolean </span><span class="s1">isDirectionAwareColorRightDefined =</span>
              <span class="s1">isRTL ? isColorStartDefined : isColorEndDefined</span><span class="s2">;</span>

          <span class="s2">if </span><span class="s1">(isDirectionAwareColorLeftDefined) {</span>
            <span class="s1">colorLeft = directionAwareColorLeft</span><span class="s2">;</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(isDirectionAwareColorRightDefined) {</span>
            <span class="s1">colorRight = directionAwareColorRight</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">final float </span><span class="s1">left = mOuterClipTempRectForBorderRadius.left</span><span class="s2">;</span>
        <span class="s2">final float </span><span class="s1">right = mOuterClipTempRectForBorderRadius.right</span><span class="s2">;</span>
        <span class="s2">final float </span><span class="s1">top = mOuterClipTempRectForBorderRadius.top</span><span class="s2">;</span>
        <span class="s2">final float </span><span class="s1">bottom = mOuterClipTempRectForBorderRadius.bottom</span><span class="s2">;</span>

        <span class="s0">// mGapBetweenPaths is used to close the gap between the diagonal</span>
        <span class="s0">// edges of the quadrilaterals on adjacent sides of the rectangle</span>
        <span class="s2">if </span><span class="s1">(borderWidth.left &gt; </span><span class="s6">0</span><span class="s1">) {</span>
          <span class="s2">final float </span><span class="s1">x1 = left</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y1 = top - mGapBetweenPaths</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x2 = mInnerTopLeftCorner.x</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y2 = mInnerTopLeftCorner.y - mGapBetweenPaths</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x3 = mInnerBottomLeftCorner.x</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y3 = mInnerBottomLeftCorner.y + mGapBetweenPaths</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x4 = left</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y4 = bottom + mGapBetweenPaths</span><span class="s2">;</span>

          <span class="s1">drawQuadrilateral(canvas</span><span class="s2">, </span><span class="s1">colorLeft</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">x3</span><span class="s2">, </span><span class="s1">y3</span><span class="s2">, </span><span class="s1">x4</span><span class="s2">, </span><span class="s1">y4)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(borderWidth.top &gt; </span><span class="s6">0</span><span class="s1">) {</span>
          <span class="s2">final float </span><span class="s1">x1 = left - mGapBetweenPaths</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y1 = top</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x2 = mInnerTopLeftCorner.x - mGapBetweenPaths</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y2 = mInnerTopLeftCorner.y</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x3 = mInnerTopRightCorner.x + mGapBetweenPaths</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y3 = mInnerTopRightCorner.y</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x4 = right + mGapBetweenPaths</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y4 = top</span><span class="s2">;</span>

          <span class="s1">drawQuadrilateral(canvas</span><span class="s2">, </span><span class="s1">colorTop</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">x3</span><span class="s2">, </span><span class="s1">y3</span><span class="s2">, </span><span class="s1">x4</span><span class="s2">, </span><span class="s1">y4)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(borderWidth.right &gt; </span><span class="s6">0</span><span class="s1">) {</span>
          <span class="s2">final float </span><span class="s1">x1 = right</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y1 = top - mGapBetweenPaths</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x2 = mInnerTopRightCorner.x</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y2 = mInnerTopRightCorner.y - mGapBetweenPaths</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x3 = mInnerBottomRightCorner.x</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y3 = mInnerBottomRightCorner.y + mGapBetweenPaths</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x4 = right</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y4 = bottom + mGapBetweenPaths</span><span class="s2">;</span>

          <span class="s1">drawQuadrilateral(canvas</span><span class="s2">, </span><span class="s1">colorRight</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">x3</span><span class="s2">, </span><span class="s1">y3</span><span class="s2">, </span><span class="s1">x4</span><span class="s2">, </span><span class="s1">y4)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(borderWidth.bottom &gt; </span><span class="s6">0</span><span class="s1">) {</span>
          <span class="s2">final float </span><span class="s1">x1 = left - mGapBetweenPaths</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y1 = bottom</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x2 = mInnerBottomLeftCorner.x - mGapBetweenPaths</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y2 = mInnerBottomLeftCorner.y</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x3 = mInnerBottomRightCorner.x + mGapBetweenPaths</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y3 = mInnerBottomRightCorner.y</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x4 = right + mGapBetweenPaths</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y4 = bottom</span><span class="s2">;</span>

          <span class="s1">drawQuadrilateral(canvas</span><span class="s2">, </span><span class="s1">colorBottom</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">x3</span><span class="s2">, </span><span class="s1">y3</span><span class="s2">, </span><span class="s1">x4</span><span class="s2">, </span><span class="s1">y4)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">canvas.restore()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">updatePath() {</span>
    <span class="s2">if </span><span class="s1">(!mNeedUpdatePathForBorderRadius) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">mNeedUpdatePathForBorderRadius = </span><span class="s2">false;</span>

    <span class="s2">if </span><span class="s1">(mInnerClipPathForBorderRadius == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mInnerClipPathForBorderRadius = </span><span class="s2">new </span><span class="s1">Path()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mBackgroundColorRenderPath == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mBackgroundColorRenderPath = </span><span class="s2">new </span><span class="s1">Path()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mOuterClipPathForBorderRadius == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mOuterClipPathForBorderRadius = </span><span class="s2">new </span><span class="s1">Path()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mPathForBorderRadiusOutline == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mPathForBorderRadiusOutline = </span><span class="s2">new </span><span class="s1">Path()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mCenterDrawPath == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mCenterDrawPath = </span><span class="s2">new </span><span class="s1">Path()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mInnerClipTempRectForBorderRadius == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mInnerClipTempRectForBorderRadius = </span><span class="s2">new </span><span class="s1">RectF()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mOuterClipTempRectForBorderRadius == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mOuterClipTempRectForBorderRadius = </span><span class="s2">new </span><span class="s1">RectF()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mTempRectForBorderRadiusOutline == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mTempRectForBorderRadiusOutline = </span><span class="s2">new </span><span class="s1">RectF()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mTempRectForCenterDrawPath == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mTempRectForCenterDrawPath = </span><span class="s2">new </span><span class="s1">RectF()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">mInnerClipPathForBorderRadius.reset()</span><span class="s2">;</span>
    <span class="s1">mBackgroundColorRenderPath.reset()</span><span class="s2">;</span>
    <span class="s1">mOuterClipPathForBorderRadius.reset()</span><span class="s2">;</span>
    <span class="s1">mPathForBorderRadiusOutline.reset()</span><span class="s2">;</span>
    <span class="s1">mCenterDrawPath.reset()</span><span class="s2">;</span>

    <span class="s1">mInnerClipTempRectForBorderRadius.set(getBounds())</span><span class="s2">;</span>
    <span class="s1">mOuterClipTempRectForBorderRadius.set(getBounds())</span><span class="s2">;</span>
    <span class="s1">mTempRectForBorderRadiusOutline.set(getBounds())</span><span class="s2">;</span>
    <span class="s1">mTempRectForCenterDrawPath.set(getBounds())</span><span class="s2">;</span>

    <span class="s2">final </span><span class="s1">RectF borderWidth = getDirectionAwareBorderInsets()</span><span class="s2">;</span>

    <span class="s2">int </span><span class="s1">colorLeft = getBorderColor(Spacing.LEFT)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">colorTop = getBorderColor(Spacing.TOP)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">colorRight = getBorderColor(Spacing.RIGHT)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">colorBottom = getBorderColor(Spacing.BOTTOM)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">borderColor = getBorderColor(Spacing.ALL)</span><span class="s2">;</span>

    <span class="s2">int </span><span class="s1">colorBlock = getBorderColor(Spacing.BLOCK)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">colorBlockStart = getBorderColor(Spacing.BLOCK_START)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">colorBlockEnd = getBorderColor(Spacing.BLOCK_END)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(isBorderColorDefined(Spacing.BLOCK)) {</span>
      <span class="s1">colorBottom = colorBlock</span><span class="s2">;</span>
      <span class="s1">colorTop = colorBlock</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isBorderColorDefined(Spacing.BLOCK_END)) {</span>
      <span class="s1">colorBottom = colorBlockEnd</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isBorderColorDefined(Spacing.BLOCK_START)) {</span>
      <span class="s1">colorTop = colorBlockStart</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Clip border ONLY if its color is non transparent</span>
    <span class="s2">if </span><span class="s1">(Color.alpha(colorLeft) != </span><span class="s6">0</span>
        <span class="s1">&amp;&amp; Color.alpha(colorTop) != </span><span class="s6">0</span>
        <span class="s1">&amp;&amp; Color.alpha(colorRight) != </span><span class="s6">0</span>
        <span class="s1">&amp;&amp; Color.alpha(colorBottom) != </span><span class="s6">0</span>
        <span class="s1">&amp;&amp; Color.alpha(borderColor) != </span><span class="s6">0</span><span class="s1">) {</span>

      <span class="s1">mInnerClipTempRectForBorderRadius.top += borderWidth.top</span><span class="s2">;</span>
      <span class="s1">mInnerClipTempRectForBorderRadius.bottom -= borderWidth.bottom</span><span class="s2">;</span>
      <span class="s1">mInnerClipTempRectForBorderRadius.left += borderWidth.left</span><span class="s2">;</span>
      <span class="s1">mInnerClipTempRectForBorderRadius.right -= borderWidth.right</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">mTempRectForCenterDrawPath.top += borderWidth.top * </span><span class="s6">0.5f</span><span class="s2">;</span>
    <span class="s1">mTempRectForCenterDrawPath.bottom -= borderWidth.bottom * </span><span class="s6">0.5f</span><span class="s2">;</span>
    <span class="s1">mTempRectForCenterDrawPath.left += borderWidth.left * </span><span class="s6">0.5f</span><span class="s2">;</span>
    <span class="s1">mTempRectForCenterDrawPath.right -= borderWidth.right * </span><span class="s6">0.5f</span><span class="s2">;</span>

    <span class="s2">final float </span><span class="s1">borderRadius = getFullBorderRadius()</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">topLeftRadius = getBorderRadiusOrDefaultTo(borderRadius</span><span class="s2">, </span><span class="s1">BorderRadiusLocation.TOP_LEFT)</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">topRightRadius = getBorderRadiusOrDefaultTo(borderRadius</span><span class="s2">, </span><span class="s1">BorderRadiusLocation.TOP_RIGHT)</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">bottomLeftRadius =</span>
        <span class="s1">getBorderRadiusOrDefaultTo(borderRadius</span><span class="s2">, </span><span class="s1">BorderRadiusLocation.BOTTOM_LEFT)</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">bottomRightRadius =</span>
        <span class="s1">getBorderRadiusOrDefaultTo(borderRadius</span><span class="s2">, </span><span class="s1">BorderRadiusLocation.BOTTOM_RIGHT)</span><span class="s2">;</span>

    <span class="s2">final boolean </span><span class="s1">isRTL = getResolvedLayoutDirection() == View.LAYOUT_DIRECTION_RTL</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">topStartRadius = getBorderRadius(BorderRadiusLocation.TOP_START)</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">topEndRadius = getBorderRadius(BorderRadiusLocation.TOP_END)</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">bottomStartRadius = getBorderRadius(BorderRadiusLocation.BOTTOM_START)</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">bottomEndRadius = getBorderRadius(BorderRadiusLocation.BOTTOM_END)</span><span class="s2">;</span>

    <span class="s2">float </span><span class="s1">endEndRadius = getBorderRadius(BorderRadiusLocation.END_END)</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">endStartRadius = getBorderRadius(BorderRadiusLocation.END_START)</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">startEndRadius = getBorderRadius(BorderRadiusLocation.START_END)</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">startStartRadius = getBorderRadius(BorderRadiusLocation.START_START)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(I18nUtil.getInstance().doLeftAndRightSwapInRTL(mContext)) {</span>
      <span class="s2">if </span><span class="s1">(YogaConstants.isUndefined(topStartRadius)) {</span>
        <span class="s1">topStartRadius = topLeftRadius</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(YogaConstants.isUndefined(topEndRadius)) {</span>
        <span class="s1">topEndRadius = topRightRadius</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(YogaConstants.isUndefined(bottomStartRadius)) {</span>
        <span class="s1">bottomStartRadius = bottomLeftRadius</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(YogaConstants.isUndefined(bottomEndRadius)) {</span>
        <span class="s1">bottomEndRadius = bottomRightRadius</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">final float </span><span class="s1">logicalTopStartRadius =</span>
          <span class="s1">YogaConstants.isUndefined(topStartRadius) ? startStartRadius : topStartRadius</span><span class="s2">;</span>
      <span class="s2">final float </span><span class="s1">logicalTopEndRadius =</span>
          <span class="s1">YogaConstants.isUndefined(topEndRadius) ? startEndRadius : topEndRadius</span><span class="s2">;</span>
      <span class="s2">final float </span><span class="s1">logicalBottomStartRadius =</span>
          <span class="s1">YogaConstants.isUndefined(bottomStartRadius) ? endStartRadius : bottomStartRadius</span><span class="s2">;</span>
      <span class="s2">final float </span><span class="s1">logicalBottomEndRadius =</span>
          <span class="s1">YogaConstants.isUndefined(bottomEndRadius) ? endEndRadius : bottomEndRadius</span><span class="s2">;</span>

      <span class="s2">final float </span><span class="s1">directionAwareTopLeftRadius = isRTL ? logicalTopEndRadius : logicalTopStartRadius</span><span class="s2">;</span>
      <span class="s2">final float </span><span class="s1">directionAwareTopRightRadius =</span>
          <span class="s1">isRTL ? logicalTopStartRadius : logicalTopEndRadius</span><span class="s2">;</span>
      <span class="s2">final float </span><span class="s1">directionAwareBottomLeftRadius =</span>
          <span class="s1">isRTL ? logicalBottomEndRadius : logicalBottomStartRadius</span><span class="s2">;</span>
      <span class="s2">final float </span><span class="s1">directionAwareBottomRightRadius =</span>
          <span class="s1">isRTL ? logicalBottomStartRadius : logicalBottomEndRadius</span><span class="s2">;</span>

      <span class="s1">topLeftRadius = directionAwareTopLeftRadius</span><span class="s2">;</span>
      <span class="s1">topRightRadius = directionAwareTopRightRadius</span><span class="s2">;</span>
      <span class="s1">bottomLeftRadius = directionAwareBottomLeftRadius</span><span class="s2">;</span>
      <span class="s1">bottomRightRadius = directionAwareBottomRightRadius</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">final float </span><span class="s1">logicalTopStartRadius =</span>
          <span class="s1">YogaConstants.isUndefined(topStartRadius) ? startStartRadius : topStartRadius</span><span class="s2">;</span>
      <span class="s2">final float </span><span class="s1">logicalTopEndRadius =</span>
          <span class="s1">YogaConstants.isUndefined(topEndRadius) ? startEndRadius : topEndRadius</span><span class="s2">;</span>
      <span class="s2">final float </span><span class="s1">logicalBottomStartRadius =</span>
          <span class="s1">YogaConstants.isUndefined(bottomStartRadius) ? endStartRadius : bottomStartRadius</span><span class="s2">;</span>
      <span class="s2">final float </span><span class="s1">logicalBottomEndRadius =</span>
          <span class="s1">YogaConstants.isUndefined(bottomEndRadius) ? endEndRadius : bottomEndRadius</span><span class="s2">;</span>

      <span class="s2">final float </span><span class="s1">directionAwareTopLeftRadius = isRTL ? logicalTopEndRadius : logicalTopStartRadius</span><span class="s2">;</span>
      <span class="s2">final float </span><span class="s1">directionAwareTopRightRadius =</span>
          <span class="s1">isRTL ? logicalTopStartRadius : logicalTopEndRadius</span><span class="s2">;</span>
      <span class="s2">final float </span><span class="s1">directionAwareBottomLeftRadius =</span>
          <span class="s1">isRTL ? logicalBottomEndRadius : logicalBottomStartRadius</span><span class="s2">;</span>
      <span class="s2">final float </span><span class="s1">directionAwareBottomRightRadius =</span>
          <span class="s1">isRTL ? logicalBottomStartRadius : logicalBottomEndRadius</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(!YogaConstants.isUndefined(directionAwareTopLeftRadius)) {</span>
        <span class="s1">topLeftRadius = directionAwareTopLeftRadius</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(!YogaConstants.isUndefined(directionAwareTopRightRadius)) {</span>
        <span class="s1">topRightRadius = directionAwareTopRightRadius</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(!YogaConstants.isUndefined(directionAwareBottomLeftRadius)) {</span>
        <span class="s1">bottomLeftRadius = directionAwareBottomLeftRadius</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(!YogaConstants.isUndefined(directionAwareBottomRightRadius)) {</span>
        <span class="s1">bottomRightRadius = directionAwareBottomRightRadius</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">final float </span><span class="s1">innerTopLeftRadiusX = Math.max(topLeftRadius - borderWidth.left</span><span class="s2">, </span><span class="s6">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">final float </span><span class="s1">innerTopLeftRadiusY = Math.max(topLeftRadius - borderWidth.top</span><span class="s2">, </span><span class="s6">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">final float </span><span class="s1">innerTopRightRadiusX = Math.max(topRightRadius - borderWidth.right</span><span class="s2">, </span><span class="s6">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">final float </span><span class="s1">innerTopRightRadiusY = Math.max(topRightRadius - borderWidth.top</span><span class="s2">, </span><span class="s6">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">final float </span><span class="s1">innerBottomRightRadiusX = Math.max(bottomRightRadius - borderWidth.right</span><span class="s2">, </span><span class="s6">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">final float </span><span class="s1">innerBottomRightRadiusY = Math.max(bottomRightRadius - borderWidth.bottom</span><span class="s2">, </span><span class="s6">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">final float </span><span class="s1">innerBottomLeftRadiusX = Math.max(bottomLeftRadius - borderWidth.left</span><span class="s2">, </span><span class="s6">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">final float </span><span class="s1">innerBottomLeftRadiusY = Math.max(bottomLeftRadius - borderWidth.bottom</span><span class="s2">, </span><span class="s6">0</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s1">mInnerClipPathForBorderRadius.addRoundRect(</span>
        <span class="s1">mInnerClipTempRectForBorderRadius</span><span class="s2">,</span>
        <span class="s2">new float</span><span class="s1">[] {</span>
          <span class="s1">innerTopLeftRadiusX</span><span class="s2">,</span>
          <span class="s1">innerTopLeftRadiusY</span><span class="s2">,</span>
          <span class="s1">innerTopRightRadiusX</span><span class="s2">,</span>
          <span class="s1">innerTopRightRadiusY</span><span class="s2">,</span>
          <span class="s1">innerBottomRightRadiusX</span><span class="s2">,</span>
          <span class="s1">innerBottomRightRadiusY</span><span class="s2">,</span>
          <span class="s1">innerBottomLeftRadiusX</span><span class="s2">,</span>
          <span class="s1">innerBottomLeftRadiusY</span><span class="s2">,</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">Path.Direction.CW)</span><span class="s2">;</span>

    <span class="s0">// There is a small gap between mBackgroundColorRenderPath and its</span>
    <span class="s0">// border. mGapBetweenPaths is used to slightly enlarge the rectangle</span>
    <span class="s0">// (mInnerClipTempRectForBorderRadius), ensuring the border can be</span>
    <span class="s0">// drawn on top without the gap.</span>
    <span class="s1">mBackgroundColorRenderPath.addRoundRect(</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.left - mGapBetweenPaths</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.top - mGapBetweenPaths</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.right + mGapBetweenPaths</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.bottom + mGapBetweenPaths</span><span class="s2">,</span>
        <span class="s2">new float</span><span class="s1">[] {</span>
          <span class="s1">innerTopLeftRadiusX</span><span class="s2">,</span>
          <span class="s1">innerTopLeftRadiusY</span><span class="s2">,</span>
          <span class="s1">innerTopRightRadiusX</span><span class="s2">,</span>
          <span class="s1">innerTopRightRadiusY</span><span class="s2">,</span>
          <span class="s1">innerBottomRightRadiusX</span><span class="s2">,</span>
          <span class="s1">innerBottomRightRadiusY</span><span class="s2">,</span>
          <span class="s1">innerBottomLeftRadiusX</span><span class="s2">,</span>
          <span class="s1">innerBottomLeftRadiusY</span><span class="s2">,</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">Path.Direction.CW)</span><span class="s2">;</span>

    <span class="s1">mOuterClipPathForBorderRadius.addRoundRect(</span>
        <span class="s1">mOuterClipTempRectForBorderRadius</span><span class="s2">,</span>
        <span class="s2">new float</span><span class="s1">[] {</span>
          <span class="s1">topLeftRadius</span><span class="s2">,</span>
          <span class="s1">topLeftRadius</span><span class="s2">,</span>
          <span class="s1">topRightRadius</span><span class="s2">,</span>
          <span class="s1">topRightRadius</span><span class="s2">,</span>
          <span class="s1">bottomRightRadius</span><span class="s2">,</span>
          <span class="s1">bottomRightRadius</span><span class="s2">,</span>
          <span class="s1">bottomLeftRadius</span><span class="s2">,</span>
          <span class="s1">bottomLeftRadius</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">Path.Direction.CW)</span><span class="s2">;</span>

    <span class="s2">float </span><span class="s1">extraRadiusForOutline = </span><span class="s6">0</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mBorderWidth != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">extraRadiusForOutline = mBorderWidth.get(Spacing.ALL) / </span><span class="s6">2f</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">mPathForBorderRadiusOutline.addRoundRect(</span>
        <span class="s1">mTempRectForBorderRadiusOutline</span><span class="s2">,</span>
        <span class="s2">new float</span><span class="s1">[] {</span>
          <span class="s1">topLeftRadius + extraRadiusForOutline</span><span class="s2">,</span>
          <span class="s1">topLeftRadius + extraRadiusForOutline</span><span class="s2">,</span>
          <span class="s1">topRightRadius + extraRadiusForOutline</span><span class="s2">,</span>
          <span class="s1">topRightRadius + extraRadiusForOutline</span><span class="s2">,</span>
          <span class="s1">bottomRightRadius + extraRadiusForOutline</span><span class="s2">,</span>
          <span class="s1">bottomRightRadius + extraRadiusForOutline</span><span class="s2">,</span>
          <span class="s1">bottomLeftRadius + extraRadiusForOutline</span><span class="s2">,</span>
          <span class="s1">bottomLeftRadius + extraRadiusForOutline</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">Path.Direction.CW)</span><span class="s2">;</span>

    <span class="s1">mCenterDrawPath.addRoundRect(</span>
        <span class="s1">mTempRectForCenterDrawPath</span><span class="s2">,</span>
        <span class="s2">new float</span><span class="s1">[] {</span>
          <span class="s1">Math.max(</span>
              <span class="s1">topLeftRadius - borderWidth.left * </span><span class="s6">0.5f</span><span class="s2">,</span>
              <span class="s1">(borderWidth.left &gt; </span><span class="s6">0.0f</span><span class="s1">) ? (topLeftRadius / borderWidth.left) : </span><span class="s6">0.0f</span><span class="s1">)</span><span class="s2">,</span>
          <span class="s1">Math.max(</span>
              <span class="s1">topLeftRadius - borderWidth.top * </span><span class="s6">0.5f</span><span class="s2">,</span>
              <span class="s1">(borderWidth.top &gt; </span><span class="s6">0.0f</span><span class="s1">) ? (topLeftRadius / borderWidth.top) : </span><span class="s6">0.0f</span><span class="s1">)</span><span class="s2">,</span>
          <span class="s1">Math.max(</span>
              <span class="s1">topRightRadius - borderWidth.right * </span><span class="s6">0.5f</span><span class="s2">,</span>
              <span class="s1">(borderWidth.right &gt; </span><span class="s6">0.0f</span><span class="s1">) ? (topRightRadius / borderWidth.right) : </span><span class="s6">0.0f</span><span class="s1">)</span><span class="s2">,</span>
          <span class="s1">Math.max(</span>
              <span class="s1">topRightRadius - borderWidth.top * </span><span class="s6">0.5f</span><span class="s2">,</span>
              <span class="s1">(borderWidth.top &gt; </span><span class="s6">0.0f</span><span class="s1">) ? (topRightRadius / borderWidth.top) : </span><span class="s6">0.0f</span><span class="s1">)</span><span class="s2">,</span>
          <span class="s1">Math.max(</span>
              <span class="s1">bottomRightRadius - borderWidth.right * </span><span class="s6">0.5f</span><span class="s2">,</span>
              <span class="s1">(borderWidth.right &gt; </span><span class="s6">0.0f</span><span class="s1">) ? (bottomRightRadius / borderWidth.right) : </span><span class="s6">0.0f</span><span class="s1">)</span><span class="s2">,</span>
          <span class="s1">Math.max(</span>
              <span class="s1">bottomRightRadius - borderWidth.bottom * </span><span class="s6">0.5f</span><span class="s2">,</span>
              <span class="s1">(borderWidth.bottom &gt; </span><span class="s6">0.0f</span><span class="s1">) ? (bottomRightRadius / borderWidth.bottom) : </span><span class="s6">0.0f</span><span class="s1">)</span><span class="s2">,</span>
          <span class="s1">Math.max(</span>
              <span class="s1">bottomLeftRadius - borderWidth.left * </span><span class="s6">0.5f</span><span class="s2">,</span>
              <span class="s1">(borderWidth.left &gt; </span><span class="s6">0.0f</span><span class="s1">) ? (bottomLeftRadius / borderWidth.left) : </span><span class="s6">0.0f</span><span class="s1">)</span><span class="s2">,</span>
          <span class="s1">Math.max(</span>
              <span class="s1">bottomLeftRadius - borderWidth.bottom * </span><span class="s6">0.5f</span><span class="s2">,</span>
              <span class="s1">(borderWidth.bottom &gt; </span><span class="s6">0.0f</span><span class="s1">) ? (bottomLeftRadius / borderWidth.bottom) : </span><span class="s6">0.0f</span><span class="s1">)</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">Path.Direction.CW)</span><span class="s2">;</span>

    <span class="s3">/**</span>
     <span class="s3">* Rounded Multi-Colored Border Algorithm:</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Let O (for outer) = (top, left, bottom, right) be the rectangle that represents the size</span>
     <span class="s3">* and position of a view V. Since the box-sizing of all React Native views is border-box, any</span>
     <span class="s3">* border of V will render inside O.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Let BorderWidth = (borderTop, borderLeft, borderBottom, borderRight).</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Let I (for inner) = O - BorderWidth.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Then, remembering that O and I are rectangles and that I is inside O, O - I gives us the</span>
     <span class="s3">* border of V. Therefore, we can use canvas.clipPath to draw V's border.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">canvas.clipPath(O, Region.OP.INTERSECT);</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">canvas.clipPath(I, Region.OP.DIFFERENCE);</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">canvas.drawRect(O, paint);</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">This lets us draw non-rounded single-color borders.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">To extend this algorithm to rounded single-color borders, we:</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">1. Curve the corners of O by the (border radii of V) using Path#addRoundRect.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">2. Curve the corners of I by (border radii of V - border widths of V) using</span>
     <span class="s3">* Path#addRoundRect.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Let O' = curve(O, border radii of V).</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Let I' = curve(I, border radii of V - border widths of V)</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">The rationale behind this decision is the (first sentence of the) following section in the</span>
     <span class="s3">* CSS Backgrounds and Borders Module Level 3:</span>
     <span class="s3">* https://www.w3.org/TR/css3-background/#the-border-radius.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">After both O and I have been curved, we can execute the following lines once again to</span>
     <span class="s3">* render curved single-color borders:</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">canvas.clipPath(O, Region.OP.INTERSECT);</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">canvas.clipPath(I, Region.OP.DIFFERENCE);</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">canvas.drawRect(O, paint);</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">To extend this algorithm to rendering multi-colored rounded borders, we render each side</span>
     <span class="s3">* of the border as its own quadrilateral. Suppose that we were handling the case where all the</span>
     <span class="s3">* border radii are 0. Then, the four quadrilaterals would be:</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Left: (O.left, O.top), (I.left, I.top), (I.left, I.bottom), (O.left, O.bottom)</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Top: (O.left, O.top), (I.left, I.top), (I.right, I.top), (O.right, O.top)</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Right: (O.right, O.top), (I.right, I.top), (I.right, I.bottom), (O.right, O.bottom)</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Bottom: (O.right, O.bottom), (I.right, I.bottom), (I.left, I.bottom), (O.left, O.bottom)</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Now, lets consider what happens when we render a rounded border (radii != 0). For the sake</span>
     <span class="s3">* of simplicity, let's focus on the top edge of the Left border:</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Let borderTopLeftRadius = 5. Let borderLeftWidth = 1. Let borderTopWidth = 2.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">We know that O is curved by the ellipse E_O (a = 5, b = 5). We know that I is curved by</span>
     <span class="s3">* the ellipse E_I (a = 5 - 1, b = 5 - 2).</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Since we have clipping, it should be safe to set the top-left point of the Left</span>
     <span class="s3">* quadrilateral's top edge to (O.left, O.top).</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">But, what should the top-right point be?</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">The fact that the border is curved shouldn't change the slope (nor the position) of the</span>
     <span class="s3">* line connecting the top-left and top-right points of the Left quadrilateral's top edge.</span>
     <span class="s3">* Therefore, The top-right point should lie somewhere on the line L = (1 - a) * (O.left, O.top)</span>
     <span class="s3">* + a * (I.left, I.top).</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">a != 0, because then the top-left and top-right points would be the same and</span>
     <span class="s3">* borderLeftWidth = 1. a != 1, because then the top-right point would not touch an edge of the</span>
     <span class="s3">* ellipse E_I. We want the top-right point to touch an edge of the inner ellipse because the</span>
     <span class="s3">* border curves with E_I on the top-left corner of V.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Therefore, it must be the case that a &gt; 1. Two natural locations of the top-right point</span>
     <span class="s3">* exist: 1. The first intersection of L with E_I. 2. The second intersection of L with E_I.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">We choose the top-right point of the top edge of the Left quadrilateral to be an arbitrary</span>
     <span class="s3">* intersection of L with E_I.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(mInnerTopLeftCorner == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mInnerTopLeftCorner = </span><span class="s2">new </span><span class="s1">PointF()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/** Compute mInnerTopLeftCorner */</span>
    <span class="s1">mInnerTopLeftCorner.x = mInnerClipTempRectForBorderRadius.left</span><span class="s2">;</span>
    <span class="s1">mInnerTopLeftCorner.y = mInnerClipTempRectForBorderRadius.top</span><span class="s2">;</span>

    <span class="s1">getEllipseIntersectionWithLine(</span>
        <span class="s0">// Ellipse Bounds</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.left</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.top</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.left + </span><span class="s6">2 </span><span class="s1">* innerTopLeftRadiusX</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.top + </span><span class="s6">2 </span><span class="s1">* innerTopLeftRadiusY</span><span class="s2">,</span>

        <span class="s0">// Line Start</span>
        <span class="s1">mOuterClipTempRectForBorderRadius.left</span><span class="s2">,</span>
        <span class="s1">mOuterClipTempRectForBorderRadius.top</span><span class="s2">,</span>

        <span class="s0">// Line End</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.left</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.top</span><span class="s2">,</span>

        <span class="s0">// Result</span>
        <span class="s1">mInnerTopLeftCorner)</span><span class="s2">;</span>

    <span class="s3">/** Compute mInnerBottomLeftCorner */</span>
    <span class="s2">if </span><span class="s1">(mInnerBottomLeftCorner == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mInnerBottomLeftCorner = </span><span class="s2">new </span><span class="s1">PointF()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">mInnerBottomLeftCorner.x = mInnerClipTempRectForBorderRadius.left</span><span class="s2">;</span>
    <span class="s1">mInnerBottomLeftCorner.y = mInnerClipTempRectForBorderRadius.bottom</span><span class="s2">;</span>

    <span class="s1">getEllipseIntersectionWithLine(</span>
        <span class="s0">// Ellipse Bounds</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.left</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.bottom - </span><span class="s6">2 </span><span class="s1">* innerBottomLeftRadiusY</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.left + </span><span class="s6">2 </span><span class="s1">* innerBottomLeftRadiusX</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.bottom</span><span class="s2">,</span>

        <span class="s0">// Line Start</span>
        <span class="s1">mOuterClipTempRectForBorderRadius.left</span><span class="s2">,</span>
        <span class="s1">mOuterClipTempRectForBorderRadius.bottom</span><span class="s2">,</span>

        <span class="s0">// Line End</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.left</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.bottom</span><span class="s2">,</span>

        <span class="s0">// Result</span>
        <span class="s1">mInnerBottomLeftCorner)</span><span class="s2">;</span>

    <span class="s3">/** Compute mInnerTopRightCorner */</span>
    <span class="s2">if </span><span class="s1">(mInnerTopRightCorner == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mInnerTopRightCorner = </span><span class="s2">new </span><span class="s1">PointF()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">mInnerTopRightCorner.x = mInnerClipTempRectForBorderRadius.right</span><span class="s2">;</span>
    <span class="s1">mInnerTopRightCorner.y = mInnerClipTempRectForBorderRadius.top</span><span class="s2">;</span>

    <span class="s1">getEllipseIntersectionWithLine(</span>
        <span class="s0">// Ellipse Bounds</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.right - </span><span class="s6">2 </span><span class="s1">* innerTopRightRadiusX</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.top</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.right</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.top + </span><span class="s6">2 </span><span class="s1">* innerTopRightRadiusY</span><span class="s2">,</span>

        <span class="s0">// Line Start</span>
        <span class="s1">mOuterClipTempRectForBorderRadius.right</span><span class="s2">,</span>
        <span class="s1">mOuterClipTempRectForBorderRadius.top</span><span class="s2">,</span>

        <span class="s0">// Line End</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.right</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.top</span><span class="s2">,</span>

        <span class="s0">// Result</span>
        <span class="s1">mInnerTopRightCorner)</span><span class="s2">;</span>

    <span class="s3">/** Compute mInnerBottomRightCorner */</span>
    <span class="s2">if </span><span class="s1">(mInnerBottomRightCorner == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mInnerBottomRightCorner = </span><span class="s2">new </span><span class="s1">PointF()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">mInnerBottomRightCorner.x = mInnerClipTempRectForBorderRadius.right</span><span class="s2">;</span>
    <span class="s1">mInnerBottomRightCorner.y = mInnerClipTempRectForBorderRadius.bottom</span><span class="s2">;</span>

    <span class="s1">getEllipseIntersectionWithLine(</span>
        <span class="s0">// Ellipse Bounds</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.right - </span><span class="s6">2 </span><span class="s1">* innerBottomRightRadiusX</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.bottom - </span><span class="s6">2 </span><span class="s1">* innerBottomRightRadiusY</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.right</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.bottom</span><span class="s2">,</span>

        <span class="s0">// Line Start</span>
        <span class="s1">mOuterClipTempRectForBorderRadius.right</span><span class="s2">,</span>
        <span class="s1">mOuterClipTempRectForBorderRadius.bottom</span><span class="s2">,</span>

        <span class="s0">// Line End</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.right</span><span class="s2">,</span>
        <span class="s1">mInnerClipTempRectForBorderRadius.bottom</span><span class="s2">,</span>

        <span class="s0">// Result</span>
        <span class="s1">mInnerBottomRightCorner)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private static void </span><span class="s1">getEllipseIntersectionWithLine(</span>
      <span class="s2">double </span><span class="s1">ellipseBoundsLeft</span><span class="s2">,</span>
      <span class="s2">double </span><span class="s1">ellipseBoundsTop</span><span class="s2">,</span>
      <span class="s2">double </span><span class="s1">ellipseBoundsRight</span><span class="s2">,</span>
      <span class="s2">double </span><span class="s1">ellipseBoundsBottom</span><span class="s2">,</span>
      <span class="s2">double </span><span class="s1">lineStartX</span><span class="s2">,</span>
      <span class="s2">double </span><span class="s1">lineStartY</span><span class="s2">,</span>
      <span class="s2">double </span><span class="s1">lineEndX</span><span class="s2">,</span>
      <span class="s2">double </span><span class="s1">lineEndY</span><span class="s2">,</span>
      <span class="s1">PointF result) {</span>
    <span class="s2">final double </span><span class="s1">ellipseCenterX = (ellipseBoundsLeft + ellipseBoundsRight) / </span><span class="s6">2</span><span class="s2">;</span>
    <span class="s2">final double </span><span class="s1">ellipseCenterY = (ellipseBoundsTop + ellipseBoundsBottom) / </span><span class="s6">2</span><span class="s2">;</span>

    <span class="s3">/**</span>
     <span class="s3">* Step 1:</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Translate the line so that the ellipse is at the origin.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Why? It makes the math easier by changing the ellipse equation from ((x -</span>
     <span class="s3">* ellipseCenterX)/a)^2 + ((y - ellipseCenterY)/b)^2 = 1 to (x/a)^2 + (y/b)^2 = 1.</span>
     <span class="s3">*/</span>
    <span class="s1">lineStartX -= ellipseCenterX</span><span class="s2">;</span>
    <span class="s1">lineStartY -= ellipseCenterY</span><span class="s2">;</span>
    <span class="s1">lineEndX -= ellipseCenterX</span><span class="s2">;</span>
    <span class="s1">lineEndY -= ellipseCenterY</span><span class="s2">;</span>

    <span class="s3">/**</span>
     <span class="s3">* Step 2:</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Ellipse equation: (x/a)^2 + (y/b)^2 = 1 Line equation: y = mx + c</span>
     <span class="s3">*/</span>
    <span class="s2">final double </span><span class="s1">a = Math.abs(ellipseBoundsRight - ellipseBoundsLeft) / </span><span class="s6">2</span><span class="s2">;</span>
    <span class="s2">final double </span><span class="s1">b = Math.abs(ellipseBoundsBottom - ellipseBoundsTop) / </span><span class="s6">2</span><span class="s2">;</span>
    <span class="s2">final double </span><span class="s1">m = (lineEndY - lineStartY) / (lineEndX - lineStartX)</span><span class="s2">;</span>
    <span class="s2">final double </span><span class="s1">c = lineStartY - m * lineStartX</span><span class="s2">; </span><span class="s0">// Just a point on the line</span>

    <span class="s3">/**</span>
     <span class="s3">* Step 3:</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Substitute the Line equation into the Ellipse equation. Solve for x. Eventually, you'll</span>
     <span class="s3">* have to use the quadratic formula.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Quadratic formula: Ax^2 + Bx + C = 0</span>
     <span class="s3">*/</span>
    <span class="s2">final double </span><span class="s1">A = (b * b + a * a * m * m)</span><span class="s2">;</span>
    <span class="s2">final double </span><span class="s1">B = </span><span class="s6">2 </span><span class="s1">* a * a * c * m</span><span class="s2">;</span>
    <span class="s2">final double </span><span class="s1">C = (a * a * (c * c - b * b))</span><span class="s2">;</span>

    <span class="s3">/**</span>
     <span class="s3">* Step 4:</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Apply Quadratic formula. D = determinant / 2A</span>
     <span class="s3">*/</span>
    <span class="s2">final double </span><span class="s1">D = Math.sqrt(-C / A + Math.pow(B / (</span><span class="s6">2 </span><span class="s1">* A)</span><span class="s2">, </span><span class="s6">2</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s2">final double </span><span class="s1">x2 = -B / (</span><span class="s6">2 </span><span class="s1">* A) - D</span><span class="s2">;</span>
    <span class="s2">final double </span><span class="s1">y2 = m * x2 + c</span><span class="s2">;</span>

    <span class="s3">/**</span>
     <span class="s3">* Step 5:</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Undo the space transformation in Step 5.</span>
     <span class="s3">*/</span>
    <span class="s2">final double </span><span class="s1">x = x2 + ellipseCenterX</span><span class="s2">;</span>
    <span class="s2">final double </span><span class="s1">y = y2 + ellipseCenterY</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(!Double.isNaN(x) &amp;&amp; !Double.isNaN(y)) {</span>
      <span class="s1">result.x = (</span><span class="s2">float</span><span class="s1">) x</span><span class="s2">;</span>
      <span class="s1">result.y = (</span><span class="s2">float</span><span class="s1">) y</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public float </span><span class="s1">getBorderWidthOrDefaultTo(</span><span class="s2">final float </span><span class="s1">defaultValue</span><span class="s2">, final int </span><span class="s1">spacingType) {</span>
    <span class="s2">if </span><span class="s1">(mBorderWidth == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">defaultValue</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">final float </span><span class="s1">width = mBorderWidth.getRaw(spacingType)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(YogaConstants.isUndefined(width)) {</span>
      <span class="s2">return </span><span class="s1">defaultValue</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">width</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Set type of border */</span>
  <span class="s2">private void </span><span class="s1">updatePathEffect() {</span>
    <span class="s0">// Used for rounded border and rounded background</span>
    <span class="s1">PathEffect mPathEffectForBorderStyle =</span>
        <span class="s1">mBorderStyle != </span><span class="s2">null </span><span class="s1">? BorderStyle.getPathEffect(mBorderStyle</span><span class="s2">, </span><span class="s1">getFullBorderWidth()) : </span><span class="s2">null;</span>

    <span class="s1">mPaint.setPathEffect(mPathEffectForBorderStyle)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">updatePathEffect(</span><span class="s2">int </span><span class="s1">borderWidth) {</span>
    <span class="s1">PathEffect pathEffectForBorderStyle = </span><span class="s2">null;</span>
    <span class="s2">if </span><span class="s1">(mBorderStyle != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">pathEffectForBorderStyle = BorderStyle.getPathEffect(mBorderStyle</span><span class="s2">, </span><span class="s1">borderWidth)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mPaint.setPathEffect(pathEffectForBorderStyle)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** For rounded borders we use default &quot;borderWidth&quot; property. */</span>
  <span class="s2">public float </span><span class="s1">getFullBorderWidth() {</span>
    <span class="s2">return </span><span class="s1">(mBorderWidth != </span><span class="s2">null </span><span class="s1">&amp;&amp; !YogaConstants.isUndefined(mBorderWidth.getRaw(Spacing.ALL)))</span>
        <span class="s1">? mBorderWidth.getRaw(Spacing.ALL)</span>
        <span class="s1">: </span><span class="s6">0f</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Quickly determine if all the set border colors are equal. Bitwise AND all the set colors</span>
   <span class="s3">* together, then OR them all together. If the AND and the OR are the same, then the colors are</span>
   <span class="s3">* compatible, so return this color.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Used to avoid expensive path creation and expensive calls to canvas.drawPath</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">A compatible border color, or zero if the border colors are not compatible.</span>
   <span class="s3">*/</span>
  <span class="s2">private static int </span><span class="s1">fastBorderCompatibleColorOrZero(</span>
      <span class="s2">int </span><span class="s1">borderLeft</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">borderTop</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">borderRight</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">borderBottom</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">colorLeft</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">colorTop</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">colorRight</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">colorBottom) {</span>
    <span class="s2">int </span><span class="s1">andSmear =</span>
        <span class="s1">(borderLeft &gt; </span><span class="s6">0 </span><span class="s1">? colorLeft : ALL_BITS_SET)</span>
            <span class="s1">&amp; (borderTop &gt; </span><span class="s6">0 </span><span class="s1">? colorTop : ALL_BITS_SET)</span>
            <span class="s1">&amp; (borderRight &gt; </span><span class="s6">0 </span><span class="s1">? colorRight : ALL_BITS_SET)</span>
            <span class="s1">&amp; (borderBottom &gt; </span><span class="s6">0 </span><span class="s1">? colorBottom : ALL_BITS_SET)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">orSmear =</span>
        <span class="s1">(borderLeft &gt; </span><span class="s6">0 </span><span class="s1">? colorLeft : ALL_BITS_UNSET)</span>
            <span class="s1">| (borderTop &gt; </span><span class="s6">0 </span><span class="s1">? colorTop : ALL_BITS_UNSET)</span>
            <span class="s1">| (borderRight &gt; </span><span class="s6">0 </span><span class="s1">? colorRight : ALL_BITS_UNSET)</span>
            <span class="s1">| (borderBottom &gt; </span><span class="s6">0 </span><span class="s1">? colorBottom : ALL_BITS_UNSET)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">andSmear == orSmear ? andSmear : </span><span class="s6">0</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">drawRectangularBackgroundWithBorders(Canvas canvas) {</span>
    <span class="s1">mPaint.setStyle(Paint.Style.FILL)</span><span class="s2">;</span>

    <span class="s2">int </span><span class="s1">useColor = ColorUtil.multiplyColorAlpha(mColor</span><span class="s2">, </span><span class="s1">mAlpha)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(Color.alpha(useColor) != </span><span class="s6">0</span><span class="s1">) { </span><span class="s0">// color is not transparent</span>
      <span class="s1">mPaint.setColor(useColor)</span><span class="s2">;</span>
      <span class="s1">canvas.drawRect(getBounds()</span><span class="s2">, </span><span class="s1">mPaint)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">final </span><span class="s1">RectF borderWidth = getDirectionAwareBorderInsets()</span><span class="s2">;</span>

    <span class="s2">final int </span><span class="s1">borderLeft = Math.round(borderWidth.left)</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">borderTop = Math.round(borderWidth.top)</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">borderRight = Math.round(borderWidth.right)</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">borderBottom = Math.round(borderWidth.bottom)</span><span class="s2">;</span>

    <span class="s0">// maybe draw borders?</span>
    <span class="s2">if </span><span class="s1">(borderLeft &gt; </span><span class="s6">0 </span><span class="s1">|| borderRight &gt; </span><span class="s6">0 </span><span class="s1">|| borderTop &gt; </span><span class="s6">0 </span><span class="s1">|| borderBottom &gt; </span><span class="s6">0</span><span class="s1">) {</span>
      <span class="s1">Rect bounds = getBounds()</span><span class="s2">;</span>

      <span class="s2">int </span><span class="s1">colorLeft = getBorderColor(Spacing.LEFT)</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">colorTop = getBorderColor(Spacing.TOP)</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">colorRight = getBorderColor(Spacing.RIGHT)</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">colorBottom = getBorderColor(Spacing.BOTTOM)</span><span class="s2">;</span>

      <span class="s2">int </span><span class="s1">colorBlock = getBorderColor(Spacing.BLOCK)</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">colorBlockStart = getBorderColor(Spacing.BLOCK_START)</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">colorBlockEnd = getBorderColor(Spacing.BLOCK_END)</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(isBorderColorDefined(Spacing.BLOCK)) {</span>
        <span class="s1">colorBottom = colorBlock</span><span class="s2">;</span>
        <span class="s1">colorTop = colorBlock</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isBorderColorDefined(Spacing.BLOCK_END)) {</span>
        <span class="s1">colorBottom = colorBlockEnd</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isBorderColorDefined(Spacing.BLOCK_START)) {</span>
        <span class="s1">colorTop = colorBlockStart</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">final boolean </span><span class="s1">isRTL = getResolvedLayoutDirection() == View.LAYOUT_DIRECTION_RTL</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">colorStart = getBorderColor(Spacing.START)</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">colorEnd = getBorderColor(Spacing.END)</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(I18nUtil.getInstance().doLeftAndRightSwapInRTL(mContext)) {</span>
        <span class="s2">if </span><span class="s1">(!isBorderColorDefined(Spacing.START)) {</span>
          <span class="s1">colorStart = colorLeft</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(!isBorderColorDefined(Spacing.END)) {</span>
          <span class="s1">colorEnd = colorRight</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">final int </span><span class="s1">directionAwareColorLeft = isRTL ? colorEnd : colorStart</span><span class="s2">;</span>
        <span class="s2">final int </span><span class="s1">directionAwareColorRight = isRTL ? colorStart : colorEnd</span><span class="s2">;</span>

        <span class="s1">colorLeft = directionAwareColorLeft</span><span class="s2">;</span>
        <span class="s1">colorRight = directionAwareColorRight</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">final int </span><span class="s1">directionAwareColorLeft = isRTL ? colorEnd : colorStart</span><span class="s2">;</span>
        <span class="s2">final int </span><span class="s1">directionAwareColorRight = isRTL ? colorStart : colorEnd</span><span class="s2">;</span>

        <span class="s2">final boolean </span><span class="s1">isColorStartDefined = isBorderColorDefined(Spacing.START)</span><span class="s2">;</span>
        <span class="s2">final boolean </span><span class="s1">isColorEndDefined = isBorderColorDefined(Spacing.END)</span><span class="s2">;</span>
        <span class="s2">final boolean </span><span class="s1">isDirectionAwareColorLeftDefined =</span>
            <span class="s1">isRTL ? isColorEndDefined : isColorStartDefined</span><span class="s2">;</span>
        <span class="s2">final boolean </span><span class="s1">isDirectionAwareColorRightDefined =</span>
            <span class="s1">isRTL ? isColorStartDefined : isColorEndDefined</span><span class="s2">;</span>

        <span class="s2">if </span><span class="s1">(isDirectionAwareColorLeftDefined) {</span>
          <span class="s1">colorLeft = directionAwareColorLeft</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(isDirectionAwareColorRightDefined) {</span>
          <span class="s1">colorRight = directionAwareColorRight</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">int </span><span class="s1">left = bounds.left</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">top = bounds.top</span><span class="s2">;</span>

      <span class="s0">// Check for fast path to border drawing.</span>
      <span class="s2">int </span><span class="s1">fastBorderColor =</span>
          <span class="s1">fastBorderCompatibleColorOrZero(</span>
              <span class="s1">borderLeft</span><span class="s2">,</span>
              <span class="s1">borderTop</span><span class="s2">,</span>
              <span class="s1">borderRight</span><span class="s2">,</span>
              <span class="s1">borderBottom</span><span class="s2">,</span>
              <span class="s1">colorLeft</span><span class="s2">,</span>
              <span class="s1">colorTop</span><span class="s2">,</span>
              <span class="s1">colorRight</span><span class="s2">,</span>
              <span class="s1">colorBottom)</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(fastBorderColor != </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(Color.alpha(fastBorderColor) != </span><span class="s6">0</span><span class="s1">) {</span>
          <span class="s0">// Border color is not transparent.</span>
          <span class="s2">int </span><span class="s1">right = bounds.right</span><span class="s2">;</span>
          <span class="s2">int </span><span class="s1">bottom = bounds.bottom</span><span class="s2">;</span>

          <span class="s1">mPaint.setColor(fastBorderColor)</span><span class="s2">;</span>
          <span class="s1">mPaint.setStyle(Paint.Style.STROKE)</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(borderLeft &gt; </span><span class="s6">0</span><span class="s1">) {</span>
            <span class="s1">mPathForSingleBorder.reset()</span><span class="s2">;</span>
            <span class="s2">int </span><span class="s1">width = Math.round(borderWidth.left)</span><span class="s2">;</span>
            <span class="s1">updatePathEffect(width)</span><span class="s2">;</span>
            <span class="s1">mPaint.setStrokeWidth(width)</span><span class="s2">;</span>
            <span class="s1">mPathForSingleBorder.moveTo(left + width / </span><span class="s6">2</span><span class="s2">, </span><span class="s1">top)</span><span class="s2">;</span>
            <span class="s1">mPathForSingleBorder.lineTo(left + width / </span><span class="s6">2</span><span class="s2">, </span><span class="s1">bottom)</span><span class="s2">;</span>
            <span class="s1">canvas.drawPath(mPathForSingleBorder</span><span class="s2">, </span><span class="s1">mPaint)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(borderTop &gt; </span><span class="s6">0</span><span class="s1">) {</span>
            <span class="s1">mPathForSingleBorder.reset()</span><span class="s2">;</span>
            <span class="s2">int </span><span class="s1">width = Math.round(borderWidth.top)</span><span class="s2">;</span>
            <span class="s1">updatePathEffect(width)</span><span class="s2">;</span>
            <span class="s1">mPaint.setStrokeWidth(width)</span><span class="s2">;</span>
            <span class="s1">mPathForSingleBorder.moveTo(left</span><span class="s2">, </span><span class="s1">top + width / </span><span class="s6">2</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">mPathForSingleBorder.lineTo(right</span><span class="s2">, </span><span class="s1">top + width / </span><span class="s6">2</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">canvas.drawPath(mPathForSingleBorder</span><span class="s2">, </span><span class="s1">mPaint)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(borderRight &gt; </span><span class="s6">0</span><span class="s1">) {</span>
            <span class="s1">mPathForSingleBorder.reset()</span><span class="s2">;</span>
            <span class="s2">int </span><span class="s1">width = Math.round(borderWidth.right)</span><span class="s2">;</span>
            <span class="s1">updatePathEffect(width)</span><span class="s2">;</span>
            <span class="s1">mPaint.setStrokeWidth(width)</span><span class="s2">;</span>
            <span class="s1">mPathForSingleBorder.moveTo(right - width / </span><span class="s6">2</span><span class="s2">, </span><span class="s1">top)</span><span class="s2">;</span>
            <span class="s1">mPathForSingleBorder.lineTo(right - width / </span><span class="s6">2</span><span class="s2">, </span><span class="s1">bottom)</span><span class="s2">;</span>
            <span class="s1">canvas.drawPath(mPathForSingleBorder</span><span class="s2">, </span><span class="s1">mPaint)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(borderBottom &gt; </span><span class="s6">0</span><span class="s1">) {</span>
            <span class="s1">mPathForSingleBorder.reset()</span><span class="s2">;</span>
            <span class="s2">int </span><span class="s1">width = Math.round(borderWidth.bottom)</span><span class="s2">;</span>
            <span class="s1">updatePathEffect(width)</span><span class="s2">;</span>
            <span class="s1">mPaint.setStrokeWidth(width)</span><span class="s2">;</span>
            <span class="s1">mPathForSingleBorder.moveTo(left</span><span class="s2">, </span><span class="s1">bottom - width / </span><span class="s6">2</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">mPathForSingleBorder.lineTo(right</span><span class="s2">, </span><span class="s1">bottom - width / </span><span class="s6">2</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">canvas.drawPath(mPathForSingleBorder</span><span class="s2">, </span><span class="s1">mPaint)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// If the path drawn previously is of the same color,</span>
        <span class="s0">// there would be a slight white space between borders</span>
        <span class="s0">// with anti-alias set to true.</span>
        <span class="s0">// Therefore we need to disable anti-alias, and</span>
        <span class="s0">// after drawing is done, we will re-enable it.</span>

        <span class="s1">mPaint.setAntiAlias(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>

        <span class="s2">int </span><span class="s1">width = bounds.width()</span><span class="s2">;</span>
        <span class="s2">int </span><span class="s1">height = bounds.height()</span><span class="s2">;</span>

        <span class="s2">if </span><span class="s1">(borderLeft &gt; </span><span class="s6">0</span><span class="s1">) {</span>
          <span class="s2">final float </span><span class="s1">x1 = left</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y1 = top</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x2 = left + borderLeft</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y2 = top + borderTop</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x3 = left + borderLeft</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y3 = top + height - borderBottom</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x4 = left</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y4 = top + height</span><span class="s2">;</span>

          <span class="s1">drawQuadrilateral(canvas</span><span class="s2">, </span><span class="s1">colorLeft</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">x3</span><span class="s2">, </span><span class="s1">y3</span><span class="s2">, </span><span class="s1">x4</span><span class="s2">, </span><span class="s1">y4)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(borderTop &gt; </span><span class="s6">0</span><span class="s1">) {</span>
          <span class="s2">final float </span><span class="s1">x1 = left</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y1 = top</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x2 = left + borderLeft</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y2 = top + borderTop</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x3 = left + width - borderRight</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y3 = top + borderTop</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x4 = left + width</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y4 = top</span><span class="s2">;</span>

          <span class="s1">drawQuadrilateral(canvas</span><span class="s2">, </span><span class="s1">colorTop</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">x3</span><span class="s2">, </span><span class="s1">y3</span><span class="s2">, </span><span class="s1">x4</span><span class="s2">, </span><span class="s1">y4)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(borderRight &gt; </span><span class="s6">0</span><span class="s1">) {</span>
          <span class="s2">final float </span><span class="s1">x1 = left + width</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y1 = top</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x2 = left + width</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y2 = top + height</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x3 = left + width - borderRight</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y3 = top + height - borderBottom</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x4 = left + width - borderRight</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y4 = top + borderTop</span><span class="s2">;</span>

          <span class="s1">drawQuadrilateral(canvas</span><span class="s2">, </span><span class="s1">colorRight</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">x3</span><span class="s2">, </span><span class="s1">y3</span><span class="s2">, </span><span class="s1">x4</span><span class="s2">, </span><span class="s1">y4)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(borderBottom &gt; </span><span class="s6">0</span><span class="s1">) {</span>
          <span class="s2">final float </span><span class="s1">x1 = left</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y1 = top + height</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x2 = left + width</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y2 = top + height</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x3 = left + width - borderRight</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y3 = top + height - borderBottom</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">x4 = left + borderLeft</span><span class="s2">;</span>
          <span class="s2">final float </span><span class="s1">y4 = top + height - borderBottom</span><span class="s2">;</span>

          <span class="s1">drawQuadrilateral(canvas</span><span class="s2">, </span><span class="s1">colorBottom</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">x3</span><span class="s2">, </span><span class="s1">y3</span><span class="s2">, </span><span class="s1">x4</span><span class="s2">, </span><span class="s1">y4)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s0">// re-enable anti alias</span>
        <span class="s1">mPaint.setAntiAlias(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">drawQuadrilateral(</span>
      <span class="s1">Canvas canvas</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">fillColor</span><span class="s2">,</span>
      <span class="s2">float </span><span class="s1">x1</span><span class="s2">,</span>
      <span class="s2">float </span><span class="s1">y1</span><span class="s2">,</span>
      <span class="s2">float </span><span class="s1">x2</span><span class="s2">,</span>
      <span class="s2">float </span><span class="s1">y2</span><span class="s2">,</span>
      <span class="s2">float </span><span class="s1">x3</span><span class="s2">,</span>
      <span class="s2">float </span><span class="s1">y3</span><span class="s2">,</span>
      <span class="s2">float </span><span class="s1">x4</span><span class="s2">,</span>
      <span class="s2">float </span><span class="s1">y4) {</span>
    <span class="s2">if </span><span class="s1">(fillColor == Color.TRANSPARENT) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mPathForBorder == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mPathForBorder = </span><span class="s2">new </span><span class="s1">Path()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">mPaint.setColor(fillColor)</span><span class="s2">;</span>
    <span class="s1">mPathForBorder.reset()</span><span class="s2">;</span>
    <span class="s1">mPathForBorder.moveTo(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">;</span>
    <span class="s1">mPathForBorder.lineTo(x2</span><span class="s2">, </span><span class="s1">y2)</span><span class="s2">;</span>
    <span class="s1">mPathForBorder.lineTo(x3</span><span class="s2">, </span><span class="s1">y3)</span><span class="s2">;</span>
    <span class="s1">mPathForBorder.lineTo(x4</span><span class="s2">, </span><span class="s1">y4)</span><span class="s2">;</span>
    <span class="s1">mPathForBorder.lineTo(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">;</span>
    <span class="s1">canvas.drawPath(mPathForBorder</span><span class="s2">, </span><span class="s1">mPaint)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private int </span><span class="s1">getBorderWidth(</span><span class="s2">int </span><span class="s1">position) {</span>
    <span class="s2">if </span><span class="s1">(mBorderWidth == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s6">0</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">final float </span><span class="s1">width = mBorderWidth.get(position)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">YogaConstants.isUndefined(width) ? -</span><span class="s6">1 </span><span class="s1">: Math.round(width)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private static int </span><span class="s1">colorFromAlphaAndRGBComponents(</span><span class="s2">float </span><span class="s1">alpha</span><span class="s2">, float </span><span class="s1">rgb) {</span>
    <span class="s2">int </span><span class="s1">rgbComponent = </span><span class="s6">0x00FFFFFF </span><span class="s1">&amp; (</span><span class="s2">int</span><span class="s1">) rgb</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">alphaComponent = </span><span class="s6">0xFF000000 </span><span class="s1">&amp; ((</span><span class="s2">int</span><span class="s1">) alpha) &lt;&lt; </span><span class="s6">24</span><span class="s2">;</span>

    <span class="s2">return </span><span class="s1">rgbComponent | alphaComponent</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private boolean </span><span class="s1">isBorderColorDefined(</span><span class="s2">int </span><span class="s1">position) {</span>
    <span class="s2">final float </span><span class="s1">rgb = mBorderRGB != </span><span class="s2">null </span><span class="s1">? mBorderRGB.get(position) : YogaConstants.UNDEFINED</span><span class="s2">;</span>
    <span class="s2">final float </span><span class="s1">alpha = mBorderAlpha != </span><span class="s2">null </span><span class="s1">? mBorderAlpha.get(position) : YogaConstants.UNDEFINED</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">!YogaConstants.isUndefined(rgb) &amp;&amp; !YogaConstants.isUndefined(alpha)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public int </span><span class="s1">getBorderColor(</span><span class="s2">int </span><span class="s1">position) {</span>
    <span class="s2">float </span><span class="s1">rgb = mBorderRGB != </span><span class="s2">null </span><span class="s1">? mBorderRGB.get(position) : DEFAULT_BORDER_RGB</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">alpha = mBorderAlpha != </span><span class="s2">null </span><span class="s1">? mBorderAlpha.get(position) : DEFAULT_BORDER_ALPHA</span><span class="s2">;</span>

    <span class="s2">return </span><span class="s1">ReactViewBackgroundDrawable.colorFromAlphaAndRGBComponents(alpha</span><span class="s2">, </span><span class="s1">rgb)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@TargetApi(LOLLIPOP)</span>
  <span class="s2">public </span><span class="s1">RectF getDirectionAwareBorderInsets() {</span>
    <span class="s2">final float </span><span class="s1">borderWidth = getBorderWidthOrDefaultTo(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">Spacing.ALL)</span><span class="s2">;</span>
    <span class="s2">final float </span><span class="s1">borderTopWidth = getBorderWidthOrDefaultTo(borderWidth</span><span class="s2">, </span><span class="s1">Spacing.TOP)</span><span class="s2">;</span>
    <span class="s2">final float </span><span class="s1">borderBottomWidth = getBorderWidthOrDefaultTo(borderWidth</span><span class="s2">, </span><span class="s1">Spacing.BOTTOM)</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">borderLeftWidth = getBorderWidthOrDefaultTo(borderWidth</span><span class="s2">, </span><span class="s1">Spacing.LEFT)</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">borderRightWidth = getBorderWidthOrDefaultTo(borderWidth</span><span class="s2">, </span><span class="s1">Spacing.RIGHT)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mBorderWidth != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">final boolean </span><span class="s1">isRTL = getResolvedLayoutDirection() == View.LAYOUT_DIRECTION_RTL</span><span class="s2">;</span>
      <span class="s2">float </span><span class="s1">borderStartWidth = mBorderWidth.getRaw(Spacing.START)</span><span class="s2">;</span>
      <span class="s2">float </span><span class="s1">borderEndWidth = mBorderWidth.getRaw(Spacing.END)</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(I18nUtil.getInstance().doLeftAndRightSwapInRTL(mContext)) {</span>
        <span class="s2">if </span><span class="s1">(YogaConstants.isUndefined(borderStartWidth)) {</span>
          <span class="s1">borderStartWidth = borderLeftWidth</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(YogaConstants.isUndefined(borderEndWidth)) {</span>
          <span class="s1">borderEndWidth = borderRightWidth</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">final float </span><span class="s1">directionAwareBorderLeftWidth = isRTL ? borderEndWidth : borderStartWidth</span><span class="s2">;</span>
        <span class="s2">final float </span><span class="s1">directionAwareBorderRightWidth = isRTL ? borderStartWidth : borderEndWidth</span><span class="s2">;</span>

        <span class="s1">borderLeftWidth = directionAwareBorderLeftWidth</span><span class="s2">;</span>
        <span class="s1">borderRightWidth = directionAwareBorderRightWidth</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">final float </span><span class="s1">directionAwareBorderLeftWidth = isRTL ? borderEndWidth : borderStartWidth</span><span class="s2">;</span>
        <span class="s2">final float </span><span class="s1">directionAwareBorderRightWidth = isRTL ? borderStartWidth : borderEndWidth</span><span class="s2">;</span>

        <span class="s2">if </span><span class="s1">(!YogaConstants.isUndefined(directionAwareBorderLeftWidth)) {</span>
          <span class="s1">borderLeftWidth = directionAwareBorderLeftWidth</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(!YogaConstants.isUndefined(directionAwareBorderRightWidth)) {</span>
          <span class="s1">borderRightWidth = directionAwareBorderRightWidth</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return new </span><span class="s1">RectF(borderLeftWidth</span><span class="s2">, </span><span class="s1">borderTopWidth</span><span class="s2">, </span><span class="s1">borderRightWidth</span><span class="s2">, </span><span class="s1">borderBottomWidth)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
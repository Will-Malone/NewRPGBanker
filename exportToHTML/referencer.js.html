<html>
<head>
<title>Referencer.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Referencer.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__classPrivateFieldSet = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__classPrivateFieldSet) || </span><span class="s2">function </span><span class="s1">(receiver, state, value, kind, f) {</span>
    <span class="s2">if </span><span class="s1">(kind === </span><span class="s0">&quot;m&quot;</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Private method is not writable&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(kind === </span><span class="s0">&quot;a&quot; </span><span class="s1">&amp;&amp; !f) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Private accessor was defined without a setter&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">state === </span><span class="s0">&quot;function&quot; </span><span class="s1">? receiver !== state || !f : !state.has(receiver)) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Cannot write private member to an object whose class did not declare it&quot;</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">(kind === </span><span class="s0">&quot;a&quot; </span><span class="s1">? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">__classPrivateFieldGet = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__classPrivateFieldGet) || </span><span class="s2">function </span><span class="s1">(receiver, state, kind, f) {</span>
    <span class="s2">if </span><span class="s1">(kind === </span><span class="s0">&quot;a&quot; </span><span class="s1">&amp;&amp; !f) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Private accessor was defined without a getter&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">state === </span><span class="s0">&quot;function&quot; </span><span class="s1">? receiver !== state || !f : !state.has(receiver)) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Cannot read private member from an object whose class did not declare it&quot;</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">kind === </span><span class="s0">&quot;m&quot; </span><span class="s1">? f : kind === </span><span class="s0">&quot;a&quot; </span><span class="s1">? f.call(receiver) : f ? f.value : state.get(receiver);</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">_Referencer_jsxPragma, _Referencer_jsxFragmentName, _Referencer_hasReferencedJsxFactory, _Referencer_hasReferencedJsxFragmentFactory, _Referencer_lib, _Referencer_emitDecoratorMetadata;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.Referencer = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s1">const types_1 = require(</span><span class="s0">&quot;@typescript-eslint/types&quot;</span><span class="s1">);</span>
<span class="s1">const assert_1 = require(</span><span class="s0">&quot;../assert&quot;</span><span class="s1">);</span>
<span class="s1">const definition_1 = require(</span><span class="s0">&quot;../definition&quot;</span><span class="s1">);</span>
<span class="s1">const lib_1 = require(</span><span class="s0">&quot;../lib&quot;</span><span class="s1">);</span>
<span class="s1">const ClassVisitor_1 = require(</span><span class="s0">&quot;./ClassVisitor&quot;</span><span class="s1">);</span>
<span class="s1">const ExportVisitor_1 = require(</span><span class="s0">&quot;./ExportVisitor&quot;</span><span class="s1">);</span>
<span class="s1">const ImportVisitor_1 = require(</span><span class="s0">&quot;./ImportVisitor&quot;</span><span class="s1">);</span>
<span class="s1">const PatternVisitor_1 = require(</span><span class="s0">&quot;./PatternVisitor&quot;</span><span class="s1">);</span>
<span class="s1">const Reference_1 = require(</span><span class="s0">&quot;./Reference&quot;</span><span class="s1">);</span>
<span class="s1">const TypeVisitor_1 = require(</span><span class="s0">&quot;./TypeVisitor&quot;</span><span class="s1">);</span>
<span class="s1">const Visitor_1 = require(</span><span class="s0">&quot;./Visitor&quot;</span><span class="s1">);</span>
<span class="s4">// Referencing variables and creating bindings.</span>
<span class="s1">class Referencer extends Visitor_1.Visitor {</span>
    <span class="s1">constructor(options, scopeManager) {</span>
        <span class="s1">super(options);</span>
        <span class="s1">_Referencer_jsxPragma.set(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">void </span><span class="s3">0</span><span class="s1">);</span>
        <span class="s1">_Referencer_jsxFragmentName.set(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">void </span><span class="s3">0</span><span class="s1">);</span>
        <span class="s1">_Referencer_hasReferencedJsxFactory.set(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s1">_Referencer_hasReferencedJsxFragmentFactory.set(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s1">_Referencer_lib.set(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">void </span><span class="s3">0</span><span class="s1">);</span>
        <span class="s1">_Referencer_emitDecoratorMetadata.set(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">void </span><span class="s3">0</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.scopeManager = scopeManager;</span>
        <span class="s1">__classPrivateFieldSet(</span><span class="s2">this</span><span class="s1">, _Referencer_jsxPragma, options.jsxPragma, </span><span class="s0">&quot;f&quot;</span><span class="s1">);</span>
        <span class="s1">__classPrivateFieldSet(</span><span class="s2">this</span><span class="s1">, _Referencer_jsxFragmentName, options.jsxFragmentName, </span><span class="s0">&quot;f&quot;</span><span class="s1">);</span>
        <span class="s1">__classPrivateFieldSet(</span><span class="s2">this</span><span class="s1">, _Referencer_lib, options.lib, </span><span class="s0">&quot;f&quot;</span><span class="s1">);</span>
        <span class="s1">__classPrivateFieldSet(</span><span class="s2">this</span><span class="s1">, _Referencer_emitDecoratorMetadata, options.emitDecoratorMetadata, </span><span class="s0">&quot;f&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">currentScope(dontThrowOnNull) {</span>
        <span class="s2">if </span><span class="s1">(!dontThrowOnNull) {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, assert_1.assert)(</span><span class="s2">this</span><span class="s1">.scopeManager.currentScope, </span><span class="s0">'aaa'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.scopeManager.currentScope;</span>
    <span class="s1">}</span>
    <span class="s1">close(node) {</span>
        <span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.currentScope(</span><span class="s2">true</span><span class="s1">) &amp;&amp; node === </span><span class="s2">this</span><span class="s1">.currentScope().block) {</span>
            <span class="s2">this</span><span class="s1">.scopeManager.currentScope = </span><span class="s2">this</span><span class="s1">.currentScope().close(</span><span class="s2">this</span><span class="s1">.scopeManager);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {</span>
        <span class="s1">assignments.forEach(assignment =&gt; {</span>
            <span class="s2">this</span><span class="s1">.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, assignment.right, maybeImplicitGlobal, init);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">populateGlobalsFromLib(globalScope) {</span>
        <span class="s2">for </span><span class="s1">(const lib of __classPrivateFieldGet(</span><span class="s2">this</span><span class="s1">, _Referencer_lib, </span><span class="s0">&quot;f&quot;</span><span class="s1">)) {</span>
            <span class="s1">const variables = lib_1.lib[lib];</span>
            <span class="s4">/* istanbul ignore if */ </span><span class="s2">if </span><span class="s1">(!variables) {</span>
                <span class="s2">throw new </span><span class="s1">Error(`Invalid value </span><span class="s2">for </span><span class="s1">lib provided: ${lib}`);</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(const [name, variable] of Object.entries(variables)) {</span>
                <span class="s1">globalScope.defineImplicitVariable(name, variable);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">// for const assertions (`{} as const` / `&lt;const&gt;{}`)</span>
        <span class="s1">globalScope.defineImplicitVariable(</span><span class="s0">'const'</span><span class="s1">, {</span>
            <span class="s1">eslintImplicitGlobalSetting: </span><span class="s0">'readonly'</span><span class="s1">,</span>
            <span class="s1">isTypeVariable: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">isValueVariable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Searches for a variable named &quot;name&quot; in the upper scopes and adds a pseudo-reference from itself to itself 
     */</span>
    <span class="s1">referenceInSomeUpperScope(name) {</span>
        <span class="s1">let scope = </span><span class="s2">this</span><span class="s1">.scopeManager.currentScope;</span>
        <span class="s2">while </span><span class="s1">(scope) {</span>
            <span class="s1">const variable = scope.set.get(name);</span>
            <span class="s2">if </span><span class="s1">(!variable) {</span>
                <span class="s1">scope = scope.upper;</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">scope.referenceValue(variable.identifiers[</span><span class="s3">0</span><span class="s1">]);</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">referenceJsxPragma() {</span>
        <span class="s2">if </span><span class="s1">(__classPrivateFieldGet(</span><span class="s2">this</span><span class="s1">, _Referencer_jsxPragma, </span><span class="s0">&quot;f&quot;</span><span class="s1">) == </span><span class="s2">null </span><span class="s1">|| __classPrivateFieldGet(</span><span class="s2">this</span><span class="s1">, _Referencer_hasReferencedJsxFactory, </span><span class="s0">&quot;f&quot;</span><span class="s1">)) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">__classPrivateFieldSet(</span><span class="s2">this</span><span class="s1">, _Referencer_hasReferencedJsxFactory, </span><span class="s2">this</span><span class="s1">.referenceInSomeUpperScope(__classPrivateFieldGet(</span><span class="s2">this</span><span class="s1">, _Referencer_jsxPragma, </span><span class="s0">&quot;f&quot;</span><span class="s1">)), </span><span class="s0">&quot;f&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">referenceJsxFragment() {</span>
        <span class="s2">if </span><span class="s1">(__classPrivateFieldGet(</span><span class="s2">this</span><span class="s1">, _Referencer_jsxFragmentName, </span><span class="s0">&quot;f&quot;</span><span class="s1">) == </span><span class="s2">null </span><span class="s1">||</span>
            <span class="s1">__classPrivateFieldGet(</span><span class="s2">this</span><span class="s1">, _Referencer_hasReferencedJsxFragmentFactory, </span><span class="s0">&quot;f&quot;</span><span class="s1">)) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">__classPrivateFieldSet(</span><span class="s2">this</span><span class="s1">, _Referencer_hasReferencedJsxFragmentFactory, </span><span class="s2">this</span><span class="s1">.referenceInSomeUpperScope(__classPrivateFieldGet(</span><span class="s2">this</span><span class="s1">, _Referencer_jsxFragmentName, </span><span class="s0">&quot;f&quot;</span><span class="s1">)), </span><span class="s0">&quot;f&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s4">///////////////////</span>
    <span class="s4">// Visit helpers //</span>
    <span class="s4">///////////////////</span>
    <span class="s1">visitClass(node) {</span>
        <span class="s1">ClassVisitor_1.ClassVisitor.visit(</span><span class="s2">this</span><span class="s1">, node, __classPrivateFieldGet(</span><span class="s2">this</span><span class="s1">, _Referencer_emitDecoratorMetadata, </span><span class="s0">&quot;f&quot;</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s1">visitForIn(node) {</span>
        <span class="s2">if </span><span class="s1">(node.left.type === types_1.AST_NODE_TYPES.VariableDeclaration &amp;&amp;</span>
            <span class="s1">node.left.kind !== </span><span class="s0">'var'</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.scopeManager.nestForScope(node);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(node.left.type === types_1.AST_NODE_TYPES.VariableDeclaration) {</span>
            <span class="s2">this</span><span class="s1">.visit(node.left);</span>
            <span class="s2">this</span><span class="s1">.visitPattern(node.left.declarations[</span><span class="s3">0</span><span class="s1">].id, pattern =&gt; {</span>
                <span class="s2">this</span><span class="s1">.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.visitPattern(node.left, (pattern, info) =&gt; {</span>
                <span class="s1">const maybeImplicitGlobal = !</span><span class="s2">this</span><span class="s1">.currentScope().isStrict</span>
                    <span class="s1">? {</span>
                        <span class="s1">pattern,</span>
                        <span class="s1">node,</span>
                    <span class="s1">}</span>
                    <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">this</span><span class="s1">.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, </span><span class="s2">false</span><span class="s1">);</span>
                <span class="s2">this</span><span class="s1">.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, maybeImplicitGlobal, </span><span class="s2">false</span><span class="s1">);</span>
            <span class="s1">}, { processRightHandNodes: </span><span class="s2">true </span><span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.visit(node.right);</span>
        <span class="s2">this</span><span class="s1">.visit(node.body);</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">visitFunctionParameterTypeAnnotation(node) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">'typeAnnotation' </span><span class="s2">in </span><span class="s1">node) {</span>
            <span class="s2">this</span><span class="s1">.visitType(node.typeAnnotation);</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(node.type === types_1.AST_NODE_TYPES.AssignmentPattern) {</span>
            <span class="s2">this</span><span class="s1">.visitType(node.left.typeAnnotation);</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(node.type === types_1.AST_NODE_TYPES.TSParameterProperty) {</span>
            <span class="s2">this</span><span class="s1">.visitFunctionParameterTypeAnnotation(node.parameter);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">visitFunction(node) {</span>
        <span class="s4">// FunctionDeclaration name is defined in upper scope</span>
        <span class="s4">// NOTE: Not referring variableScope. It is intended.</span>
        <span class="s4">// Since</span>
        <span class="s4">//  in ES5, FunctionDeclaration should be in FunctionBody.</span>
        <span class="s4">//  in ES6, FunctionDeclaration should be block scoped.</span>
        <span class="s2">var </span><span class="s1">_a;</span>
        <span class="s2">if </span><span class="s1">(node.type === types_1.AST_NODE_TYPES.FunctionExpression) {</span>
            <span class="s2">if </span><span class="s1">(node.id) {</span>
                <span class="s4">// FunctionExpression with name creates its special scope;</span>
                <span class="s4">// FunctionExpressionNameScope.</span>
                <span class="s2">this</span><span class="s1">.scopeManager.nestFunctionExpressionNameScope(node);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(node.id) {</span>
            <span class="s4">// id is defined in upper scope</span>
            <span class="s2">this</span><span class="s1">.currentScope().defineIdentifier(node.id, </span><span class="s2">new </span><span class="s1">definition_1.FunctionNameDefinition(node.id, node));</span>
        <span class="s1">}</span>
        <span class="s4">// Consider this function is in the MethodDefinition.</span>
        <span class="s2">this</span><span class="s1">.scopeManager.nestFunctionScope(node, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s4">// Process parameter declarations.</span>
        <span class="s2">for </span><span class="s1">(const param of node.params) {</span>
            <span class="s2">this</span><span class="s1">.visitPattern(param, (pattern, info) =&gt; {</span>
                <span class="s2">this</span><span class="s1">.currentScope().defineIdentifier(pattern, </span><span class="s2">new </span><span class="s1">definition_1.ParameterDefinition(pattern, node, info.rest));</span>
                <span class="s2">this</span><span class="s1">.referencingDefaultValue(pattern, info.assignments, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}, { processRightHandNodes: </span><span class="s2">true </span><span class="s1">});</span>
            <span class="s2">this</span><span class="s1">.visitFunctionParameterTypeAnnotation(param);</span>
            <span class="s1">(_a = param.decorators) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _a.forEach(d =&gt; </span><span class="s2">this</span><span class="s1">.visit(d));</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.visitType(node.returnType);</span>
        <span class="s2">this</span><span class="s1">.visitType(node.typeParameters);</span>
        <span class="s4">// In TypeScript there are a number of function-like constructs which have no body,</span>
        <span class="s4">// so check it exists before traversing</span>
        <span class="s2">if </span><span class="s1">(node.body) {</span>
            <span class="s4">// Skip BlockStatement to prevent creating BlockStatement scope.</span>
            <span class="s2">if </span><span class="s1">(node.body.type === types_1.AST_NODE_TYPES.BlockStatement) {</span>
                <span class="s2">this</span><span class="s1">.visitChildren(node.body);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">this</span><span class="s1">.visit(node.body);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">visitProperty(node) {</span>
        <span class="s2">if </span><span class="s1">(node.computed) {</span>
            <span class="s2">this</span><span class="s1">.visit(node.key);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.visit(node.value);</span>
    <span class="s1">}</span>
    <span class="s1">visitType(node) {</span>
        <span class="s2">if </span><span class="s1">(!node) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">TypeVisitor_1.TypeVisitor.visit(</span><span class="s2">this</span><span class="s1">, node);</span>
    <span class="s1">}</span>
    <span class="s1">visitTypeAssertion(node) {</span>
        <span class="s2">this</span><span class="s1">.visit(node.expression);</span>
        <span class="s2">this</span><span class="s1">.visitType(node.typeAnnotation);</span>
    <span class="s1">}</span>
    <span class="s4">/////////////////////</span>
    <span class="s4">// Visit selectors //</span>
    <span class="s4">/////////////////////</span>
    <span class="s1">ArrowFunctionExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitFunction(node);</span>
    <span class="s1">}</span>
    <span class="s1">AssignmentExpression(node) {</span>
        <span class="s1">let left = node.left;</span>
        <span class="s2">switch </span><span class="s1">(left.type) {</span>
            <span class="s2">case </span><span class="s1">types_1.AST_NODE_TYPES.TSAsExpression:</span>
            <span class="s2">case </span><span class="s1">types_1.AST_NODE_TYPES.TSTypeAssertion:</span>
                <span class="s4">// explicitly visit the type annotation</span>
                <span class="s2">this</span><span class="s1">.visitType(left.typeAnnotation);</span>
            <span class="s4">// intentional fallthrough</span>
            <span class="s2">case </span><span class="s1">types_1.AST_NODE_TYPES.TSNonNullExpression:</span>
                <span class="s4">// unwrap the expression</span>
                <span class="s1">left = left.expression;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(PatternVisitor_1.PatternVisitor.isPattern(left)) {</span>
            <span class="s2">if </span><span class="s1">(node.operator === </span><span class="s0">'='</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.visitPattern(left, (pattern, info) =&gt; {</span>
                    <span class="s1">const maybeImplicitGlobal = !</span><span class="s2">this</span><span class="s1">.currentScope().isStrict</span>
                        <span class="s1">? {</span>
                            <span class="s1">pattern,</span>
                            <span class="s1">node,</span>
                        <span class="s1">}</span>
                        <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
                    <span class="s2">this</span><span class="s1">.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, </span><span class="s2">false</span><span class="s1">);</span>
                    <span class="s2">this</span><span class="s1">.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, maybeImplicitGlobal, </span><span class="s2">false</span><span class="s1">);</span>
                <span class="s1">}, { processRightHandNodes: </span><span class="s2">true </span><span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(left.type === types_1.AST_NODE_TYPES.Identifier) {</span>
                <span class="s2">this</span><span class="s1">.currentScope().referenceValue(left, Reference_1.ReferenceFlag.ReadWrite, node.right);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.visit(left);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.visit(node.right);</span>
    <span class="s1">}</span>
    <span class="s1">BlockStatement(node) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.scopeManager.isES6()) {</span>
            <span class="s2">this</span><span class="s1">.scopeManager.nestBlockScope(node);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.visitChildren(node);</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">BreakStatement() {</span>
        <span class="s4">// don't reference the break statement's label</span>
    <span class="s1">}</span>
    <span class="s1">CallExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitChildren(node, [</span><span class="s0">'typeParameters'</span><span class="s1">]);</span>
        <span class="s2">this</span><span class="s1">.visitType(node.typeParameters);</span>
    <span class="s1">}</span>
    <span class="s1">CatchClause(node) {</span>
        <span class="s2">this</span><span class="s1">.scopeManager.nestCatchScope(node);</span>
        <span class="s2">if </span><span class="s1">(node.param) {</span>
            <span class="s1">const param = node.param;</span>
            <span class="s2">this</span><span class="s1">.visitPattern(param, (pattern, info) =&gt; {</span>
                <span class="s2">this</span><span class="s1">.currentScope().defineIdentifier(pattern, </span><span class="s2">new </span><span class="s1">definition_1.CatchClauseDefinition(param, node));</span>
                <span class="s2">this</span><span class="s1">.referencingDefaultValue(pattern, info.assignments, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}, { processRightHandNodes: </span><span class="s2">true </span><span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.visit(node.body);</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">ClassExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitClass(node);</span>
    <span class="s1">}</span>
    <span class="s1">ClassDeclaration(node) {</span>
        <span class="s2">this</span><span class="s1">.visitClass(node);</span>
    <span class="s1">}</span>
    <span class="s1">ContinueStatement() {</span>
        <span class="s4">// don't reference the continue statement's label</span>
    <span class="s1">}</span>
    <span class="s1">ExportAllDeclaration() {</span>
        <span class="s4">// this defines no local variables</span>
    <span class="s1">}</span>
    <span class="s1">ExportDefaultDeclaration(node) {</span>
        <span class="s2">if </span><span class="s1">(node.declaration.type === types_1.AST_NODE_TYPES.Identifier) {</span>
            <span class="s1">ExportVisitor_1.ExportVisitor.visit(</span><span class="s2">this</span><span class="s1">, node);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.visit(node.declaration);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">ExportNamedDeclaration(node) {</span>
        <span class="s2">if </span><span class="s1">(node.declaration) {</span>
            <span class="s2">this</span><span class="s1">.visit(node.declaration);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">ExportVisitor_1.ExportVisitor.visit(</span><span class="s2">this</span><span class="s1">, node);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">ForInStatement(node) {</span>
        <span class="s2">this</span><span class="s1">.visitForIn(node);</span>
    <span class="s1">}</span>
    <span class="s1">ForOfStatement(node) {</span>
        <span class="s2">this</span><span class="s1">.visitForIn(node);</span>
    <span class="s1">}</span>
    <span class="s1">ForStatement(node) {</span>
        <span class="s4">// Create ForStatement declaration.</span>
        <span class="s4">// NOTE: In ES6, ForStatement dynamically generates per iteration environment. However, this is</span>
        <span class="s4">// a static analyzer, we only generate one scope for ForStatement.</span>
        <span class="s2">if </span><span class="s1">(node.init &amp;&amp;</span>
            <span class="s1">node.init.type === types_1.AST_NODE_TYPES.VariableDeclaration &amp;&amp;</span>
            <span class="s1">node.init.kind !== </span><span class="s0">'var'</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.scopeManager.nestForScope(node);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.visitChildren(node);</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">FunctionDeclaration(node) {</span>
        <span class="s2">this</span><span class="s1">.visitFunction(node);</span>
    <span class="s1">}</span>
    <span class="s1">FunctionExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitFunction(node);</span>
    <span class="s1">}</span>
    <span class="s1">Identifier(node) {</span>
        <span class="s2">this</span><span class="s1">.currentScope().referenceValue(node);</span>
        <span class="s2">this</span><span class="s1">.visitType(node.typeAnnotation);</span>
    <span class="s1">}</span>
    <span class="s1">ImportDeclaration(node) {</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, assert_1.assert)(</span><span class="s2">this</span><span class="s1">.scopeManager.isES6() &amp;&amp; </span><span class="s2">this</span><span class="s1">.scopeManager.isModule(), </span><span class="s0">'ImportDeclaration should appear when the mode is ES6 and in the module context.'</span><span class="s1">);</span>
        <span class="s1">ImportVisitor_1.ImportVisitor.visit(</span><span class="s2">this</span><span class="s1">, node);</span>
    <span class="s1">}</span>
    <span class="s1">JSXAttribute(node) {</span>
        <span class="s2">this</span><span class="s1">.visit(node.value);</span>
    <span class="s1">}</span>
    <span class="s1">JSXClosingElement() {</span>
        <span class="s4">// should not be counted as a reference</span>
    <span class="s1">}</span>
    <span class="s1">JSXFragment(node) {</span>
        <span class="s2">this</span><span class="s1">.referenceJsxPragma();</span>
        <span class="s2">this</span><span class="s1">.referenceJsxFragment();</span>
        <span class="s2">this</span><span class="s1">.visitChildren(node);</span>
    <span class="s1">}</span>
    <span class="s1">JSXIdentifier(node) {</span>
        <span class="s2">this</span><span class="s1">.currentScope().referenceValue(node);</span>
    <span class="s1">}</span>
    <span class="s1">JSXMemberExpression(node) {</span>
        <span class="s2">if </span><span class="s1">(node.object.type !== types_1.AST_NODE_TYPES.JSXIdentifier) {</span>
            <span class="s2">this</span><span class="s1">.visit(node.object);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(node.object.name !== </span><span class="s0">'this'</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.visit(node.object);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">// we don't ever reference the property as it's always going to be a property on the thing</span>
    <span class="s1">}</span>
    <span class="s1">JSXOpeningElement(node) {</span>
        <span class="s2">this</span><span class="s1">.referenceJsxPragma();</span>
        <span class="s2">if </span><span class="s1">(node.name.type === types_1.AST_NODE_TYPES.JSXIdentifier) {</span>
            <span class="s2">if </span><span class="s1">(node.name.name[</span><span class="s3">0</span><span class="s1">].toUpperCase() === node.name.name[</span><span class="s3">0</span><span class="s1">] ||</span>
                <span class="s1">node.name.name === </span><span class="s0">'this'</span><span class="s1">) {</span>
                <span class="s4">// lower cased component names are always treated as &quot;intrinsic&quot; names, and are converted to a string,</span>
                <span class="s4">// not a variable by JSX transforms:</span>
                <span class="s4">// &lt;div /&gt; =&gt; React.createElement(&quot;div&quot;, null)</span>
                <span class="s4">// the only case we want to visit a lower-cased component has its name as &quot;this&quot;,</span>
                <span class="s2">this</span><span class="s1">.visit(node.name);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.visit(node.name);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.visitType(node.typeParameters);</span>
        <span class="s2">for </span><span class="s1">(const attr of node.attributes) {</span>
            <span class="s2">this</span><span class="s1">.visit(attr);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">LabeledStatement(node) {</span>
        <span class="s2">this</span><span class="s1">.visit(node.body);</span>
    <span class="s1">}</span>
    <span class="s1">MemberExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visit(node.object);</span>
        <span class="s2">if </span><span class="s1">(node.computed) {</span>
            <span class="s2">this</span><span class="s1">.visit(node.property);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">MetaProperty() {</span>
        <span class="s4">// meta properties all builtin globals</span>
    <span class="s1">}</span>
    <span class="s1">NewExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitChildren(node, [</span><span class="s0">'typeParameters'</span><span class="s1">]);</span>
        <span class="s2">this</span><span class="s1">.visitType(node.typeParameters);</span>
    <span class="s1">}</span>
    <span class="s1">PrivateIdentifier() {</span>
        <span class="s4">// private identifiers are members on classes and thus have no variables to to reference</span>
    <span class="s1">}</span>
    <span class="s1">Program(node) {</span>
        <span class="s1">const globalScope = </span><span class="s2">this</span><span class="s1">.scopeManager.nestGlobalScope(node);</span>
        <span class="s2">this</span><span class="s1">.populateGlobalsFromLib(globalScope);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.scopeManager.isGlobalReturn()) {</span>
            <span class="s4">// Force strictness of GlobalScope to false when using node.js scope.</span>
            <span class="s2">this</span><span class="s1">.currentScope().isStrict = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.scopeManager.nestFunctionScope(node, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.scopeManager.isES6() &amp;&amp; </span><span class="s2">this</span><span class="s1">.scopeManager.isModule()) {</span>
            <span class="s2">this</span><span class="s1">.scopeManager.nestModuleScope(node);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.scopeManager.isStrictModeSupported() &amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.scopeManager.isImpliedStrict()) {</span>
            <span class="s2">this</span><span class="s1">.currentScope().isStrict = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.visitChildren(node);</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">Property(node) {</span>
        <span class="s2">this</span><span class="s1">.visitProperty(node);</span>
    <span class="s1">}</span>
    <span class="s1">SwitchStatement(node) {</span>
        <span class="s2">this</span><span class="s1">.visit(node.discriminant);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.scopeManager.isES6()) {</span>
            <span class="s2">this</span><span class="s1">.scopeManager.nestSwitchScope(node);</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(const switchCase of node.cases) {</span>
            <span class="s2">this</span><span class="s1">.visit(switchCase);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">TaggedTemplateExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visit(node.tag);</span>
        <span class="s2">this</span><span class="s1">.visit(node.quasi);</span>
        <span class="s2">this</span><span class="s1">.visitType(node.typeParameters);</span>
    <span class="s1">}</span>
    <span class="s1">TSAsExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitTypeAssertion(node);</span>
    <span class="s1">}</span>
    <span class="s1">TSDeclareFunction(node) {</span>
        <span class="s2">this</span><span class="s1">.visitFunction(node);</span>
    <span class="s1">}</span>
    <span class="s1">TSImportEqualsDeclaration(node) {</span>
        <span class="s2">this</span><span class="s1">.currentScope().defineIdentifier(node.id, </span><span class="s2">new </span><span class="s1">definition_1.ImportBindingDefinition(node.id, node, node));</span>
        <span class="s2">if </span><span class="s1">(node.moduleReference.type === types_1.AST_NODE_TYPES.TSQualifiedName) {</span>
            <span class="s2">this</span><span class="s1">.visit(node.moduleReference.left);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.visit(node.moduleReference);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">TSEmptyBodyFunctionExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitFunction(node);</span>
    <span class="s1">}</span>
    <span class="s1">TSEnumDeclaration(node) {</span>
        <span class="s2">this</span><span class="s1">.currentScope().defineIdentifier(node.id, </span><span class="s2">new </span><span class="s1">definition_1.TSEnumNameDefinition(node.id, node));</span>
        <span class="s4">// enum members can be referenced within the enum body</span>
        <span class="s2">this</span><span class="s1">.scopeManager.nestTSEnumScope(node);</span>
        <span class="s4">// define the enum name again inside the new enum scope</span>
        <span class="s4">// references to the enum should not resolve directly to the enum</span>
        <span class="s2">this</span><span class="s1">.currentScope().defineIdentifier(node.id, </span><span class="s2">new </span><span class="s1">definition_1.TSEnumNameDefinition(node.id, node));</span>
        <span class="s2">for </span><span class="s1">(const member of node.members) {</span>
            <span class="s4">// TS resolves literal named members to be actual names</span>
            <span class="s4">// enum Foo {</span>
            <span class="s4">//   'a' = 1,</span>
            <span class="s4">//   b = a, // this references the 'a' member</span>
            <span class="s4">// }</span>
            <span class="s2">if </span><span class="s1">(member.id.type === types_1.AST_NODE_TYPES.Literal &amp;&amp;</span>
                <span class="s2">typeof </span><span class="s1">member.id.value === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s1">const name = member.id;</span>
                <span class="s2">this</span><span class="s1">.currentScope().defineLiteralIdentifier(name, </span><span class="s2">new </span><span class="s1">definition_1.TSEnumMemberDefinition(name, member));</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!member.computed &amp;&amp;</span>
                <span class="s1">member.id.type === types_1.AST_NODE_TYPES.Identifier) {</span>
                <span class="s2">this</span><span class="s1">.currentScope().defineIdentifier(member.id, </span><span class="s2">new </span><span class="s1">definition_1.TSEnumMemberDefinition(member.id, member));</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.visit(member.initializer);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">TSInstantiationExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitChildren(node, [</span><span class="s0">'typeParameters'</span><span class="s1">]);</span>
        <span class="s2">this</span><span class="s1">.visitType(node.typeParameters);</span>
    <span class="s1">}</span>
    <span class="s1">TSInterfaceDeclaration(node) {</span>
        <span class="s2">this</span><span class="s1">.visitType(node);</span>
    <span class="s1">}</span>
    <span class="s1">TSModuleDeclaration(node) {</span>
        <span class="s2">if </span><span class="s1">(node.id.type === types_1.AST_NODE_TYPES.Identifier &amp;&amp; !node.global) {</span>
            <span class="s2">this</span><span class="s1">.currentScope().defineIdentifier(node.id, </span><span class="s2">new </span><span class="s1">definition_1.TSModuleNameDefinition(node.id, node));</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.scopeManager.nestTSModuleScope(node);</span>
        <span class="s2">this</span><span class="s1">.visit(node.body);</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">TSSatisfiesExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitTypeAssertion(node);</span>
    <span class="s1">}</span>
    <span class="s1">TSTypeAliasDeclaration(node) {</span>
        <span class="s2">this</span><span class="s1">.visitType(node);</span>
    <span class="s1">}</span>
    <span class="s1">TSTypeAssertion(node) {</span>
        <span class="s2">this</span><span class="s1">.visitTypeAssertion(node);</span>
    <span class="s1">}</span>
    <span class="s1">UpdateExpression(node) {</span>
        <span class="s2">if </span><span class="s1">(PatternVisitor_1.PatternVisitor.isPattern(node.argument)) {</span>
            <span class="s2">this</span><span class="s1">.visitPattern(node.argument, pattern =&gt; {</span>
                <span class="s2">this</span><span class="s1">.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.ReadWrite, </span><span class="s2">null</span><span class="s1">);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.visitChildren(node);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">VariableDeclaration(node) {</span>
        <span class="s1">const variableTargetScope = node.kind === </span><span class="s0">'var'</span>
            <span class="s1">? </span><span class="s2">this</span><span class="s1">.currentScope().variableScope</span>
            <span class="s1">: </span><span class="s2">this</span><span class="s1">.currentScope();</span>
        <span class="s2">for </span><span class="s1">(const decl of node.declarations) {</span>
            <span class="s1">const init = decl.init;</span>
            <span class="s2">this</span><span class="s1">.visitPattern(decl.id, (pattern, info) =&gt; {</span>
                <span class="s1">variableTargetScope.defineIdentifier(pattern, </span><span class="s2">new </span><span class="s1">definition_1.VariableDefinition(pattern, decl, node));</span>
                <span class="s2">this</span><span class="s1">.referencingDefaultValue(pattern, info.assignments, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(init) {</span>
                    <span class="s2">this</span><span class="s1">.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, init, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}, { processRightHandNodes: </span><span class="s2">true </span><span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(decl.init) {</span>
                <span class="s2">this</span><span class="s1">.visit(decl.init);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s0">'typeAnnotation' </span><span class="s2">in </span><span class="s1">decl.id) {</span>
                <span class="s2">this</span><span class="s1">.visitType(decl.id.typeAnnotation);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">WithStatement(node) {</span>
        <span class="s2">this</span><span class="s1">.visit(node.object);</span>
        <span class="s4">// Then nest scope for WithStatement.</span>
        <span class="s2">this</span><span class="s1">.scopeManager.nestWithScope(node);</span>
        <span class="s2">this</span><span class="s1">.visit(node.body);</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">ImportAttribute() {</span>
        <span class="s4">// import assertions are module metadata and thus have no variables to reference</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.Referencer = Referencer;</span>
<span class="s1">_Referencer_jsxPragma = </span><span class="s2">new </span><span class="s1">WeakMap(), _Referencer_jsxFragmentName = </span><span class="s2">new </span><span class="s1">WeakMap(), _Referencer_hasReferencedJsxFactory = </span><span class="s2">new </span><span class="s1">WeakMap(), _Referencer_hasReferencedJsxFragmentFactory = </span><span class="s2">new </span><span class="s1">WeakMap(), _Referencer_lib = </span><span class="s2">new </span><span class="s1">WeakMap(), _Referencer_emitDecoratorMetadata = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
<span class="s4">//# sourceMappingURL=Referencer.js.map</span></pre>
</body>
</html>
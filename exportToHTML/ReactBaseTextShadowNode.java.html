<html>
<head>
<title>ReactBaseTextShadowNode.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #629755; font-weight: bold; font-style: italic;}
.s5 { color: #77b767; font-style: italic;}
.s6 { color: #6a8759;}
.s7 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ReactBaseTextShadowNode.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.views.text</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.annotation.TargetApi</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Color</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Typeface</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.os.Build</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.Layout</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.Spannable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.SpannableStringBuilder</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.TextUtils</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.Gravity</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.logging.FLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.infer.annotation.Assertions</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableArray</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.ReactConstants</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.IllegalViewOperationException</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.LayoutShadowNode</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.NativeViewHierarchyOptimizer</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.PixelUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactShadowNode</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ViewProps</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.annotations.ReactProp</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaDirection</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaUnit</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaValue</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.ArrayList</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.HashMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.List</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Map</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Objects</span><span class="s2">;</span>

<span class="s3">/**</span>
 <span class="s3">* {</span><span class="s4">@link </span><span class="s3">ReactShadowNode} abstract class for spannable text nodes.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">This class handles all text attributes associated with {</span><span class="s4">@code </span><span class="s5">&lt;Text&gt;</span><span class="s3">}-ish node. A concrete</span>
 <span class="s3">* node can be an anchor {</span><span class="s4">@code </span><span class="s5">&lt;Text&gt;</span><span class="s3">} node, an anchor {</span><span class="s4">@code </span><span class="s5">&lt;TextInput&gt;</span><span class="s3">} node or virtual {</span><span class="s4">@code</span>
 <span class="s3">* </span><span class="s5">&lt;Text&gt;</span><span class="s3">} node inside {</span><span class="s4">@code </span><span class="s5">&lt;Text&gt;</span><span class="s3">} or {</span><span class="s4">@code </span><span class="s5">&lt;TextInput&gt;</span><span class="s3">} node. Or even something else.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">This also node calculates {</span><span class="s4">@link </span><span class="s3">Spannable} object based on subnodes of the same type, which</span>
 <span class="s3">* can be used in concrete classes to feed native views and compute layout.</span>
 <span class="s3">*/</span>
<span class="s1">@TargetApi(Build.VERSION_CODES.M)</span>
<span class="s2">public abstract class </span><span class="s1">ReactBaseTextShadowNode </span><span class="s2">extends </span><span class="s1">LayoutShadowNode {</span>

  <span class="s0">// Use a direction weak character so the placeholder doesn't change the direction of the previous</span>
  <span class="s0">// character.</span>
  <span class="s0">// https://en.wikipedia.org/wiki/Bi-directional_text#weak_characters</span>
  <span class="s2">private static final </span><span class="s1">String INLINE_VIEW_PLACEHOLDER = </span><span class="s6">&quot;0&quot;</span><span class="s2">;</span>
  <span class="s2">public static final int </span><span class="s1">UNSET = -</span><span class="s7">1</span><span class="s2">;</span>

  <span class="s2">public static final </span><span class="s1">String PROP_SHADOW_OFFSET = </span><span class="s6">&quot;textShadowOffset&quot;</span><span class="s2">;</span>
  <span class="s2">public static final </span><span class="s1">String PROP_SHADOW_OFFSET_WIDTH = </span><span class="s6">&quot;width&quot;</span><span class="s2">;</span>
  <span class="s2">public static final </span><span class="s1">String PROP_SHADOW_OFFSET_HEIGHT = </span><span class="s6">&quot;height&quot;</span><span class="s2">;</span>
  <span class="s2">public static final </span><span class="s1">String PROP_SHADOW_RADIUS = </span><span class="s6">&quot;textShadowRadius&quot;</span><span class="s2">;</span>
  <span class="s2">public static final </span><span class="s1">String PROP_SHADOW_COLOR = </span><span class="s6">&quot;textShadowColor&quot;</span><span class="s2">;</span>

  <span class="s2">public static final </span><span class="s1">String PROP_TEXT_TRANSFORM = </span><span class="s6">&quot;textTransform&quot;</span><span class="s2">;</span>

  <span class="s2">public static final int </span><span class="s1">DEFAULT_TEXT_SHADOW_COLOR = </span><span class="s7">0x55000000</span><span class="s2">;</span>

  <span class="s2">protected </span><span class="s1">@Nullable ReactTextViewManagerCallback mReactTextViewManagerCallback</span><span class="s2">;</span>

  <span class="s2">private static void </span><span class="s1">buildSpannedFromShadowNode(</span>
      <span class="s1">ReactBaseTextShadowNode textShadowNode</span><span class="s2">,</span>
      <span class="s1">SpannableStringBuilder sb</span><span class="s2">,</span>
      <span class="s1">List&lt;SetSpanOperation&gt; ops</span><span class="s2">,</span>
      <span class="s1">TextAttributes parentTextAttributes</span><span class="s2">,</span>
      <span class="s2">boolean </span><span class="s1">supportsInlineViews</span><span class="s2">,</span>
      <span class="s1">Map&lt;Integer</span><span class="s2">, </span><span class="s1">ReactShadowNode&gt; inlineViews</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">start) {</span>

    <span class="s1">TextAttributes textAttributes</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(parentTextAttributes != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">textAttributes = parentTextAttributes.applyChild(textShadowNode.mTextAttributes)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">textAttributes = textShadowNode.mTextAttributes</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s7">0</span><span class="s2">, </span><span class="s1">length = textShadowNode.getChildCount()</span><span class="s2">; </span><span class="s1">i &lt; length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">ReactShadowNode child = textShadowNode.getChildAt(i)</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(child </span><span class="s2">instanceof </span><span class="s1">ReactRawTextShadowNode) {</span>
        <span class="s1">sb.append(</span>
            <span class="s1">TextTransform.apply(</span>
                <span class="s1">((ReactRawTextShadowNode) child).getText()</span><span class="s2">, </span><span class="s1">textAttributes.getTextTransform()))</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(child </span><span class="s2">instanceof </span><span class="s1">ReactBaseTextShadowNode) {</span>
        <span class="s1">buildSpannedFromShadowNode(</span>
            <span class="s1">(ReactBaseTextShadowNode) child</span><span class="s2">,</span>
            <span class="s1">sb</span><span class="s2">,</span>
            <span class="s1">ops</span><span class="s2">,</span>
            <span class="s1">textAttributes</span><span class="s2">,</span>
            <span class="s1">supportsInlineViews</span><span class="s2">,</span>
            <span class="s1">inlineViews</span><span class="s2">,</span>
            <span class="s1">sb.length())</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(child </span><span class="s2">instanceof </span><span class="s1">ReactTextInlineImageShadowNode) {</span>
        <span class="s0">// We make the image take up 1 character in the span and put a corresponding character into</span>
        <span class="s0">// the text so that the image doesn't run over any following text.</span>
        <span class="s1">sb.append(INLINE_VIEW_PLACEHOLDER)</span><span class="s2">;</span>
        <span class="s1">ops.add(</span>
            <span class="s2">new </span><span class="s1">SetSpanOperation(</span>
                <span class="s1">sb.length() - INLINE_VIEW_PLACEHOLDER.length()</span><span class="s2">,</span>
                <span class="s1">sb.length()</span><span class="s2">,</span>
                <span class="s1">((ReactTextInlineImageShadowNode) child).buildInlineImageSpan()))</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(supportsInlineViews) {</span>
        <span class="s2">int </span><span class="s1">reactTag = child.getReactTag()</span><span class="s2">;</span>
        <span class="s1">YogaValue widthValue = child.getStyleWidth()</span><span class="s2">;</span>
        <span class="s1">YogaValue heightValue = child.getStyleHeight()</span><span class="s2">;</span>

        <span class="s2">float </span><span class="s1">width</span><span class="s2">;</span>
        <span class="s2">float </span><span class="s1">height</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(widthValue.unit != YogaUnit.POINT || heightValue.unit != YogaUnit.POINT) {</span>
          <span class="s0">// If the measurement of the child isn't calculated, we calculate the layout for the</span>
          <span class="s0">// view using Yoga</span>
          <span class="s1">child.calculateLayout()</span><span class="s2">;</span>
          <span class="s1">width = child.getLayoutWidth()</span><span class="s2">;</span>
          <span class="s1">height = child.getLayoutHeight()</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">width = widthValue.value</span><span class="s2">;</span>
          <span class="s1">height = heightValue.value</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s0">// We make the inline view take up 1 character in the span and put a corresponding character</span>
        <span class="s0">// into</span>
        <span class="s0">// the text so that the inline view doesn't run over any following text.</span>
        <span class="s1">sb.append(INLINE_VIEW_PLACEHOLDER)</span><span class="s2">;</span>
        <span class="s1">ops.add(</span>
            <span class="s2">new </span><span class="s1">SetSpanOperation(</span>
                <span class="s1">sb.length() - INLINE_VIEW_PLACEHOLDER.length()</span><span class="s2">,</span>
                <span class="s1">sb.length()</span><span class="s2">,</span>
                <span class="s2">new </span><span class="s1">TextInlineViewPlaceholderSpan(reactTag</span><span class="s2">, </span><span class="s1">(</span><span class="s2">int</span><span class="s1">) width</span><span class="s2">, </span><span class="s1">(</span><span class="s2">int</span><span class="s1">) height)))</span><span class="s2">;</span>
        <span class="s1">inlineViews.put(reactTag</span><span class="s2">, </span><span class="s1">child)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
            <span class="s6">&quot;Unexpected view type nested under a &lt;Text&gt; or &lt;TextInput&gt; node: &quot; </span><span class="s1">+ child.getClass())</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">child.markUpdateSeen()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">int </span><span class="s1">end = sb.length()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(end &gt;= start) {</span>
      <span class="s2">if </span><span class="s1">(textShadowNode.mIsColorSet) {</span>
        <span class="s1">ops.add(</span>
            <span class="s2">new </span><span class="s1">SetSpanOperation(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, new </span><span class="s1">ReactForegroundColorSpan(textShadowNode.mColor)))</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(textShadowNode.mIsBackgroundColorSet) {</span>
        <span class="s1">ops.add(</span>
            <span class="s2">new </span><span class="s1">SetSpanOperation(</span>
                <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, new </span><span class="s1">ReactBackgroundColorSpan(textShadowNode.mBackgroundColor)))</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(textShadowNode.mIsAccessibilityLink) {</span>
        <span class="s1">ops.add(</span>
            <span class="s2">new </span><span class="s1">SetSpanOperation(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, new </span><span class="s1">ReactClickableSpan(textShadowNode.getReactTag())))</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">float </span><span class="s1">effectiveLetterSpacing = textAttributes.getEffectiveLetterSpacing()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!Float.isNaN(effectiveLetterSpacing)</span>
          <span class="s1">&amp;&amp; (parentTextAttributes == </span><span class="s2">null</span>
              <span class="s1">|| parentTextAttributes.getEffectiveLetterSpacing() != effectiveLetterSpacing)) {</span>
        <span class="s1">ops.add(</span>
            <span class="s2">new </span><span class="s1">SetSpanOperation(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, new </span><span class="s1">CustomLetterSpacingSpan(effectiveLetterSpacing)))</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">int </span><span class="s1">effectiveFontSize = textAttributes.getEffectiveFontSize()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">( </span><span class="s0">// `getEffectiveFontSize` always returns a value so don't need to check for anything like</span>
      <span class="s0">// `Float.NaN`.</span>
      <span class="s1">parentTextAttributes == </span><span class="s2">null</span>
          <span class="s1">|| parentTextAttributes.getEffectiveFontSize() != effectiveFontSize) {</span>
        <span class="s1">ops.add(</span><span class="s2">new </span><span class="s1">SetSpanOperation(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, new </span><span class="s1">ReactAbsoluteSizeSpan(effectiveFontSize)))</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(textShadowNode.mFontStyle != UNSET</span>
          <span class="s1">|| textShadowNode.mFontWeight != UNSET</span>
          <span class="s1">|| textShadowNode.mFontFamily != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">ops.add(</span>
            <span class="s2">new </span><span class="s1">SetSpanOperation(</span>
                <span class="s1">start</span><span class="s2">,</span>
                <span class="s1">end</span><span class="s2">,</span>
                <span class="s2">new </span><span class="s1">CustomStyleSpan(</span>
                    <span class="s1">textShadowNode.mFontStyle</span><span class="s2">,</span>
                    <span class="s1">textShadowNode.mFontWeight</span><span class="s2">,</span>
                    <span class="s1">textShadowNode.mFontFeatureSettings</span><span class="s2">,</span>
                    <span class="s1">textShadowNode.mFontFamily</span><span class="s2">,</span>
                    <span class="s1">textShadowNode.getThemedContext().getAssets())))</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(textShadowNode.mIsUnderlineTextDecorationSet) {</span>
        <span class="s1">ops.add(</span><span class="s2">new </span><span class="s1">SetSpanOperation(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, new </span><span class="s1">ReactUnderlineSpan()))</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(textShadowNode.mIsLineThroughTextDecorationSet) {</span>
        <span class="s1">ops.add(</span><span class="s2">new </span><span class="s1">SetSpanOperation(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, new </span><span class="s1">ReactStrikethroughSpan()))</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">((textShadowNode.mTextShadowOffsetDx != </span><span class="s7">0</span>
              <span class="s1">|| textShadowNode.mTextShadowOffsetDy != </span><span class="s7">0</span>
              <span class="s1">|| textShadowNode.mTextShadowRadius != </span><span class="s7">0</span><span class="s1">)</span>
          <span class="s1">&amp;&amp; Color.alpha(textShadowNode.mTextShadowColor) != </span><span class="s7">0</span><span class="s1">) {</span>
        <span class="s1">ops.add(</span>
            <span class="s2">new </span><span class="s1">SetSpanOperation(</span>
                <span class="s1">start</span><span class="s2">,</span>
                <span class="s1">end</span><span class="s2">,</span>
                <span class="s2">new </span><span class="s1">ShadowStyleSpan(</span>
                    <span class="s1">textShadowNode.mTextShadowOffsetDx</span><span class="s2">,</span>
                    <span class="s1">textShadowNode.mTextShadowOffsetDy</span><span class="s2">,</span>
                    <span class="s1">textShadowNode.mTextShadowRadius</span><span class="s2">,</span>
                    <span class="s1">textShadowNode.mTextShadowColor)))</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">float </span><span class="s1">effectiveLineHeight = textAttributes.getEffectiveLineHeight()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!Float.isNaN(effectiveLineHeight)</span>
          <span class="s1">&amp;&amp; (parentTextAttributes == </span><span class="s2">null</span>
              <span class="s1">|| parentTextAttributes.getEffectiveLineHeight() != effectiveLineHeight)) {</span>
        <span class="s1">ops.add(</span><span class="s2">new </span><span class="s1">SetSpanOperation(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, new </span><span class="s1">CustomLineHeightSpan(effectiveLineHeight)))</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">ops.add(</span><span class="s2">new </span><span class="s1">SetSpanOperation(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, new </span><span class="s1">ReactTagSpan(textShadowNode.getReactTag())))</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// `nativeViewHierarchyOptimizer` can be `null` as long as `supportsInlineViews` is `false`.</span>
  <span class="s2">protected </span><span class="s1">Spannable spannedFromShadowNode(</span>
      <span class="s1">ReactBaseTextShadowNode textShadowNode</span><span class="s2">,</span>
      <span class="s1">String text</span><span class="s2">,</span>
      <span class="s2">boolean </span><span class="s1">supportsInlineViews</span><span class="s2">,</span>
      <span class="s1">NativeViewHierarchyOptimizer nativeViewHierarchyOptimizer) {</span>
    <span class="s1">Assertions.assertCondition(</span>
        <span class="s1">!supportsInlineViews || nativeViewHierarchyOptimizer != </span><span class="s2">null,</span>
        <span class="s6">&quot;nativeViewHierarchyOptimizer is required when inline views are supported&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">SpannableStringBuilder sb = </span><span class="s2">new </span><span class="s1">SpannableStringBuilder()</span><span class="s2">;</span>

    <span class="s0">// TODO(5837930): Investigate whether it's worth optimizing this part and do it if so</span>

    <span class="s0">// The {@link SpannableStringBuilder} implementation require setSpan operation to be called</span>
    <span class="s0">// up-to-bottom, otherwise all the spannables that are within the region for which one may set</span>
    <span class="s0">// a new spannable will be wiped out</span>
    <span class="s1">List&lt;SetSpanOperation&gt; ops = </span><span class="s2">new </span><span class="s1">ArrayList&lt;&gt;()</span><span class="s2">;</span>
    <span class="s1">Map&lt;Integer</span><span class="s2">, </span><span class="s1">ReactShadowNode&gt; inlineViews =</span>
        <span class="s1">supportsInlineViews ? </span><span class="s2">new </span><span class="s1">HashMap&lt;Integer</span><span class="s2">, </span><span class="s1">ReactShadowNode&gt;() : </span><span class="s2">null;</span>

    <span class="s2">if </span><span class="s1">(text != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Handle text that is provided via a prop (e.g. the `value` and `defaultValue` props on</span>
      <span class="s0">// TextInput).</span>
      <span class="s1">sb.append(TextTransform.apply(text</span><span class="s2">, </span><span class="s1">textShadowNode.mTextAttributes.getTextTransform()))</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">buildSpannedFromShadowNode(textShadowNode</span><span class="s2">, </span><span class="s1">sb</span><span class="s2">, </span><span class="s1">ops</span><span class="s2">, null, </span><span class="s1">supportsInlineViews</span><span class="s2">, </span><span class="s1">inlineViews</span><span class="s2">, </span><span class="s7">0</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s1">textShadowNode.mContainsImages = </span><span class="s2">false;</span>
    <span class="s1">textShadowNode.mInlineViews = inlineViews</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">heightOfTallestInlineViewOrImage = Float.NaN</span><span class="s2">;</span>

    <span class="s0">// While setting the Spans on the final text, we also check whether any of them are inline views</span>
    <span class="s0">// or images.</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">priorityIndex = </span><span class="s7">0</span><span class="s2">; </span><span class="s1">priorityIndex &lt; ops.size()</span><span class="s2">; </span><span class="s1">priorityIndex++) {</span>
      <span class="s2">final </span><span class="s1">SetSpanOperation op = ops.get(ops.size() - priorityIndex - </span><span class="s7">1</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s2">boolean </span><span class="s1">isInlineImage = op.what </span><span class="s2">instanceof </span><span class="s1">TextInlineImageSpan</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(isInlineImage || op.what </span><span class="s2">instanceof </span><span class="s1">TextInlineViewPlaceholderSpan) {</span>
        <span class="s2">int </span><span class="s1">height</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isInlineImage) {</span>
          <span class="s1">height = ((TextInlineImageSpan) op.what).getHeight()</span><span class="s2">;</span>
          <span class="s1">textShadowNode.mContainsImages = </span><span class="s2">true;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">TextInlineViewPlaceholderSpan placeholder = (TextInlineViewPlaceholderSpan) op.what</span><span class="s2">;</span>
          <span class="s1">height = placeholder.getHeight()</span><span class="s2">;</span>

          <span class="s0">// Inline views cannot be layout-only because the ReactTextView needs to be able to grab</span>
          <span class="s0">// ahold of them on the UI thread to size and position them.</span>
          <span class="s1">ReactShadowNode childNode = inlineViews.get(placeholder.getReactTag())</span><span class="s2">;</span>
          <span class="s1">nativeViewHierarchyOptimizer.handleForceViewToBeNonLayoutOnly(childNode)</span><span class="s2">;</span>

          <span class="s0">// The ReactTextView is responsible for laying out the inline views.</span>
          <span class="s1">childNode.setLayoutParent(textShadowNode)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(Float.isNaN(heightOfTallestInlineViewOrImage)</span>
            <span class="s1">|| height &gt; heightOfTallestInlineViewOrImage) {</span>
          <span class="s1">heightOfTallestInlineViewOrImage = height</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">// Actual order of calling {@code execute} does NOT matter,</span>
      <span class="s0">// but the {@code priorityIndex} DOES matter.</span>
      <span class="s1">op.execute(sb</span><span class="s2">, </span><span class="s1">priorityIndex)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">textShadowNode.mTextAttributes.setHeightOfTallestInlineViewOrImage(</span>
        <span class="s1">heightOfTallestInlineViewOrImage)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mReactTextViewManagerCallback != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mReactTextViewManagerCallback.onPostProcessSpannable(sb)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">sb</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">protected </span><span class="s1">TextAttributes mTextAttributes</span><span class="s2">;</span>

  <span class="s2">protected boolean </span><span class="s1">mIsColorSet = </span><span class="s2">false;</span>
  <span class="s2">protected int </span><span class="s1">mColor</span><span class="s2">;</span>
  <span class="s2">protected boolean </span><span class="s1">mIsBackgroundColorSet = </span><span class="s2">false;</span>
  <span class="s2">protected int </span><span class="s1">mBackgroundColor</span><span class="s2">;</span>
  <span class="s2">protected boolean </span><span class="s1">mIsAccessibilityLink = </span><span class="s2">false;</span>

  <span class="s2">protected int </span><span class="s1">mNumberOfLines = UNSET</span><span class="s2">;</span>
  <span class="s2">protected int </span><span class="s1">mTextAlign = Gravity.NO_GRAVITY</span><span class="s2">;</span>
  <span class="s2">protected int </span><span class="s1">mTextBreakStrategy =</span>
      <span class="s1">(Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) ? </span><span class="s7">0 </span><span class="s1">: Layout.BREAK_STRATEGY_HIGH_QUALITY</span><span class="s2">;</span>
  <span class="s2">protected int </span><span class="s1">mHyphenationFrequency =</span>
      <span class="s1">(Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) ? </span><span class="s7">0 </span><span class="s1">: Layout.HYPHENATION_FREQUENCY_NONE</span><span class="s2">;</span>
  <span class="s2">protected int </span><span class="s1">mJustificationMode =</span>
      <span class="s1">(Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O) ? </span><span class="s7">0 </span><span class="s1">: Layout.JUSTIFICATION_MODE_NONE</span><span class="s2">;</span>

  <span class="s2">protected float </span><span class="s1">mTextShadowOffsetDx = </span><span class="s7">0</span><span class="s2">;</span>
  <span class="s2">protected float </span><span class="s1">mTextShadowOffsetDy = </span><span class="s7">0</span><span class="s2">;</span>
  <span class="s2">protected float </span><span class="s1">mTextShadowRadius = </span><span class="s7">0</span><span class="s2">;</span>
  <span class="s2">protected int </span><span class="s1">mTextShadowColor = DEFAULT_TEXT_SHADOW_COLOR</span><span class="s2">;</span>

  <span class="s2">protected boolean </span><span class="s1">mIsUnderlineTextDecorationSet = </span><span class="s2">false;</span>
  <span class="s2">protected boolean </span><span class="s1">mIsLineThroughTextDecorationSet = </span><span class="s2">false;</span>
  <span class="s2">protected boolean </span><span class="s1">mIncludeFontPadding = </span><span class="s2">true;</span>
  <span class="s2">protected boolean </span><span class="s1">mAdjustsFontSizeToFit = </span><span class="s2">false;</span>
  <span class="s2">protected float </span><span class="s1">mMinimumFontScale = </span><span class="s7">0</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* mFontStyle can be {</span><span class="s4">@link </span><span class="s3">Typeface#NORMAL} or {</span><span class="s4">@link </span><span class="s3">Typeface#ITALIC}. mFontWeight can be {</span><span class="s4">@link</span>
   <span class="s3">* Typeface#NORMAL} or {</span><span class="s4">@link </span><span class="s3">Typeface#BOLD}.</span>
   <span class="s3">*/</span>
  <span class="s2">protected int </span><span class="s1">mFontStyle = UNSET</span><span class="s2">;</span>

  <span class="s2">protected int </span><span class="s1">mFontWeight = UNSET</span><span class="s2">;</span>
  <span class="s3">/**</span>
   <span class="s3">* NB: If a font family is used that does not have a style in a certain Android version (ie.</span>
   <span class="s3">* monospace bold pre Android 5.0), that style (ie. bold) will not be inherited by nested Text</span>
   <span class="s3">* nodes. To retain that style, you have to add it to those nodes explicitly.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Example, Android 4.4:</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">&lt;pre&gt;</span>
   <span class="s3">* </span><span class="s5">&lt;Text style=</span><span class="s3">{{fontFamily=&quot;serif&quot; fontWeight=&quot;bold&quot;}}&gt;Bold Text</span><span class="s5">&lt;/Text&gt;</span>
   <span class="s3">*   </span><span class="s5">&lt;Text style=</span><span class="s3">{{fontFamily=&quot;sans-serif&quot;}}&gt;Bold Text</span><span class="s5">&lt;/Text&gt;</span>
   <span class="s3">*     </span><span class="s5">&lt;Text style=</span><span class="s3">{{fontFamily=&quot;serif}}&gt;Bold Text</span><span class="s5">&lt;/Text&gt;</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">&lt;Text style=</span><span class="s3">{{fontFamily=&quot;monospace&quot; fontWeight=&quot;bold&quot;}}&gt;Not Bold Text</span><span class="s5">&lt;/Text&gt;</span>
   <span class="s3">*   </span><span class="s5">&lt;Text style=</span><span class="s3">{{fontFamily=&quot;sans-serif&quot;}}&gt;Not Bold Text</span><span class="s5">&lt;/Text&gt;</span>
   <span class="s3">*     </span><span class="s5">&lt;Text style=</span><span class="s3">{{fontFamily=&quot;serif}}&gt;Not Bold Text</span><span class="s5">&lt;/Text&gt;</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">&lt;Text style=</span><span class="s3">{{fontFamily=&quot;monospace&quot; fontWeight=&quot;bold&quot;}}&gt;Not Bold Text</span><span class="s5">&lt;/Text&gt;</span>
   <span class="s3">*   </span><span class="s5">&lt;Text style=</span><span class="s3">{{fontFamily=&quot;sans-serif&quot; fontWeight=&quot;bold&quot;}}&gt;Bold Text</span><span class="s5">&lt;/Text&gt;</span>
   <span class="s3">*     </span><span class="s5">&lt;Text style=</span><span class="s3">{{fontFamily=&quot;serif}}&gt;Bold Text</span><span class="s5">&lt;/Text&gt;</span>
   <span class="s3">* </span><span class="s5">&lt;/pre&gt;</span>
   <span class="s3">*/</span>
  <span class="s2">protected </span><span class="s1">@Nullable String mFontFamily = </span><span class="s2">null;</span>

  <span class="s3">/** </span><span class="s4">@see </span><span class="s3">android.graphics.Paint#setFontFeatureSettings */</span>
  <span class="s2">protected </span><span class="s1">@Nullable String mFontFeatureSettings = </span><span class="s2">null;</span>

  <span class="s2">protected boolean </span><span class="s1">mContainsImages = </span><span class="s2">false;</span>
  <span class="s2">protected </span><span class="s1">Map&lt;Integer</span><span class="s2">, </span><span class="s1">ReactShadowNode&gt; mInlineViews</span><span class="s2">;</span>

  <span class="s2">public </span><span class="s1">ReactBaseTextShadowNode() {</span>
    <span class="s2">this</span><span class="s1">(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">ReactBaseTextShadowNode(</span>
      <span class="s1">@Nullable ReactTextViewManagerCallback reactTextViewManagerCallback) {</span>
    <span class="s1">mTextAttributes = </span><span class="s2">new </span><span class="s1">TextAttributes()</span><span class="s2">;</span>
    <span class="s1">mReactTextViewManagerCallback = reactTextViewManagerCallback</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// Return text alignment according to LTR or RTL style</span>
  <span class="s2">private int </span><span class="s1">getTextAlign() {</span>
    <span class="s2">int </span><span class="s1">textAlign = mTextAlign</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(getLayoutDirection() == YogaDirection.RTL) {</span>
      <span class="s2">if </span><span class="s1">(textAlign == Gravity.RIGHT) {</span>
        <span class="s1">textAlign = Gravity.LEFT</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(textAlign == Gravity.LEFT) {</span>
        <span class="s1">textAlign = Gravity.RIGHT</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">textAlign</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.NUMBER_OF_LINES</span><span class="s2">, </span><span class="s1">defaultInt = UNSET)</span>
  <span class="s2">public void </span><span class="s1">setNumberOfLines(</span><span class="s2">int </span><span class="s1">numberOfLines) {</span>
    <span class="s1">mNumberOfLines = numberOfLines == </span><span class="s7">0 </span><span class="s1">? UNSET : numberOfLines</span><span class="s2">;</span>
    <span class="s1">markUpdated()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.LINE_HEIGHT</span><span class="s2">, </span><span class="s1">defaultFloat = Float.NaN)</span>
  <span class="s2">public void </span><span class="s1">setLineHeight(</span><span class="s2">float </span><span class="s1">lineHeight) {</span>
    <span class="s1">mTextAttributes.setLineHeight(lineHeight)</span><span class="s2">;</span>
    <span class="s1">markUpdated()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.LETTER_SPACING</span><span class="s2">, </span><span class="s1">defaultFloat = Float.NaN)</span>
  <span class="s2">public void </span><span class="s1">setLetterSpacing(</span><span class="s2">float </span><span class="s1">letterSpacing) {</span>
    <span class="s1">mTextAttributes.setLetterSpacing(letterSpacing)</span><span class="s2">;</span>
    <span class="s1">markUpdated()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.ALLOW_FONT_SCALING</span><span class="s2">, </span><span class="s1">defaultBoolean = </span><span class="s2">true</span><span class="s1">)</span>
  <span class="s2">public void </span><span class="s1">setAllowFontScaling(</span><span class="s2">boolean </span><span class="s1">allowFontScaling) {</span>
    <span class="s2">if </span><span class="s1">(allowFontScaling != mTextAttributes.getAllowFontScaling()) {</span>
      <span class="s1">mTextAttributes.setAllowFontScaling(allowFontScaling)</span><span class="s2">;</span>
      <span class="s1">markUpdated()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.MAX_FONT_SIZE_MULTIPLIER</span><span class="s2">, </span><span class="s1">defaultFloat = Float.NaN)</span>
  <span class="s2">public void </span><span class="s1">setMaxFontSizeMultiplier(</span><span class="s2">float </span><span class="s1">maxFontSizeMultiplier) {</span>
    <span class="s2">if </span><span class="s1">(maxFontSizeMultiplier != mTextAttributes.getMaxFontSizeMultiplier()) {</span>
      <span class="s1">mTextAttributes.setMaxFontSizeMultiplier(maxFontSizeMultiplier)</span><span class="s2">;</span>
      <span class="s1">markUpdated()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.TEXT_ALIGN)</span>
  <span class="s2">public void </span><span class="s1">setTextAlign(@Nullable String textAlign) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s6">&quot;justify&quot;</span><span class="s1">.equals(textAlign)) {</span>
      <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {</span>
        <span class="s1">mJustificationMode = Layout.JUSTIFICATION_MODE_INTER_WORD</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">mTextAlign = Gravity.LEFT</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {</span>
        <span class="s1">mJustificationMode = Layout.JUSTIFICATION_MODE_NONE</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(textAlign == </span><span class="s2">null </span><span class="s1">|| </span><span class="s6">&quot;auto&quot;</span><span class="s1">.equals(textAlign)) {</span>
        <span class="s1">mTextAlign = Gravity.NO_GRAVITY</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s6">&quot;left&quot;</span><span class="s1">.equals(textAlign)) {</span>
        <span class="s1">mTextAlign = Gravity.LEFT</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s6">&quot;right&quot;</span><span class="s1">.equals(textAlign)) {</span>
        <span class="s1">mTextAlign = Gravity.RIGHT</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s6">&quot;center&quot;</span><span class="s1">.equals(textAlign)) {</span>
        <span class="s1">mTextAlign = Gravity.CENTER_HORIZONTAL</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">FLog.w(ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;Invalid textAlign: &quot; </span><span class="s1">+ textAlign)</span><span class="s2">;</span>
        <span class="s1">mTextAlign = Gravity.NO_GRAVITY</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">markUpdated()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.FONT_SIZE</span><span class="s2">, </span><span class="s1">defaultFloat = Float.NaN)</span>
  <span class="s2">public void </span><span class="s1">setFontSize(</span><span class="s2">float </span><span class="s1">fontSize) {</span>
    <span class="s1">mTextAttributes.setFontSize(fontSize)</span><span class="s2">;</span>
    <span class="s1">markUpdated()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.COLOR</span><span class="s2">, </span><span class="s1">customType = </span><span class="s6">&quot;Color&quot;</span><span class="s1">)</span>
  <span class="s2">public void </span><span class="s1">setColor(@Nullable Integer color) {</span>
    <span class="s1">mIsColorSet = (color != </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mIsColorSet) {</span>
      <span class="s1">mColor = color</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">markUpdated()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.BACKGROUND_COLOR</span><span class="s2">, </span><span class="s1">customType = </span><span class="s6">&quot;Color&quot;</span><span class="s1">)</span>
  <span class="s2">public void </span><span class="s1">setBackgroundColor(@Nullable Integer color) {</span>
    <span class="s0">// Background color needs to be handled here for virtual nodes so it can be incorporated into</span>
    <span class="s0">// the span. However, it doesn't need to be applied to non-virtual nodes because non-virtual</span>
    <span class="s0">// nodes get mapped to native views and native views get their background colors get set via</span>
    <span class="s0">// {@link BaseViewManager}.</span>
    <span class="s2">if </span><span class="s1">(isVirtual()) {</span>
      <span class="s1">mIsBackgroundColorSet = (color != </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(mIsBackgroundColorSet) {</span>
        <span class="s1">mBackgroundColor = color</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">markUpdated()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.ACCESSIBILITY_ROLE)</span>
  <span class="s2">public void </span><span class="s1">setIsAccessibilityLink(@Nullable String accessibilityRole) {</span>
    <span class="s2">if </span><span class="s1">(isVirtual()) {</span>
      <span class="s1">mIsAccessibilityLink = Objects.equals(accessibilityRole</span><span class="s2">, </span><span class="s6">&quot;link&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">markUpdated()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.FONT_FAMILY)</span>
  <span class="s2">public void </span><span class="s1">setFontFamily(@Nullable String fontFamily) {</span>
    <span class="s1">mFontFamily = fontFamily</span><span class="s2">;</span>
    <span class="s1">markUpdated()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.FONT_WEIGHT)</span>
  <span class="s2">public void </span><span class="s1">setFontWeight(@Nullable String fontWeightString) {</span>
    <span class="s2">int </span><span class="s1">fontWeight = ReactTypefaceUtils.parseFontWeight(fontWeightString)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(fontWeight != mFontWeight) {</span>
      <span class="s1">mFontWeight = fontWeight</span><span class="s2">;</span>
      <span class="s1">markUpdated()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.FONT_VARIANT)</span>
  <span class="s2">public void </span><span class="s1">setFontVariant(@Nullable ReadableArray fontVariantArray) {</span>
    <span class="s1">String fontFeatureSettings = ReactTypefaceUtils.parseFontVariant(fontVariantArray)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(!TextUtils.equals(fontFeatureSettings</span><span class="s2">, </span><span class="s1">mFontFeatureSettings)) {</span>
      <span class="s1">mFontFeatureSettings = fontFeatureSettings</span><span class="s2">;</span>
      <span class="s1">markUpdated()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.FONT_STYLE)</span>
  <span class="s2">public void </span><span class="s1">setFontStyle(@Nullable String fontStyleString) {</span>
    <span class="s2">int </span><span class="s1">fontStyle = ReactTypefaceUtils.parseFontStyle(fontStyleString)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(fontStyle != mFontStyle) {</span>
      <span class="s1">mFontStyle = fontStyle</span><span class="s2">;</span>
      <span class="s1">markUpdated()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.INCLUDE_FONT_PADDING</span><span class="s2">, </span><span class="s1">defaultBoolean = </span><span class="s2">true</span><span class="s1">)</span>
  <span class="s2">public void </span><span class="s1">setIncludeFontPadding(</span><span class="s2">boolean </span><span class="s1">includepad) {</span>
    <span class="s1">mIncludeFontPadding = includepad</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.TEXT_DECORATION_LINE)</span>
  <span class="s2">public void </span><span class="s1">setTextDecorationLine(@Nullable String textDecorationLineString) {</span>
    <span class="s1">mIsUnderlineTextDecorationSet = </span><span class="s2">false;</span>
    <span class="s1">mIsLineThroughTextDecorationSet = </span><span class="s2">false;</span>
    <span class="s2">if </span><span class="s1">(textDecorationLineString != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">for </span><span class="s1">(String textDecorationLineSubString : textDecorationLineString.split(</span><span class="s6">&quot; &quot;</span><span class="s1">)) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s6">&quot;underline&quot;</span><span class="s1">.equals(textDecorationLineSubString)) {</span>
          <span class="s1">mIsUnderlineTextDecorationSet = </span><span class="s2">true;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s6">&quot;line-through&quot;</span><span class="s1">.equals(textDecorationLineSubString)) {</span>
          <span class="s1">mIsLineThroughTextDecorationSet = </span><span class="s2">true;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">markUpdated()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.TEXT_BREAK_STRATEGY)</span>
  <span class="s2">public void </span><span class="s1">setTextBreakStrategy(@Nullable String textBreakStrategy) {</span>
    <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(textBreakStrategy == </span><span class="s2">null </span><span class="s1">|| </span><span class="s6">&quot;highQuality&quot;</span><span class="s1">.equals(textBreakStrategy)) {</span>
      <span class="s1">mTextBreakStrategy = Layout.BREAK_STRATEGY_HIGH_QUALITY</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s6">&quot;simple&quot;</span><span class="s1">.equals(textBreakStrategy)) {</span>
      <span class="s1">mTextBreakStrategy = Layout.BREAK_STRATEGY_SIMPLE</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s6">&quot;balanced&quot;</span><span class="s1">.equals(textBreakStrategy)) {</span>
      <span class="s1">mTextBreakStrategy = Layout.BREAK_STRATEGY_BALANCED</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">FLog.w(ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;Invalid textBreakStrategy: &quot; </span><span class="s1">+ textBreakStrategy)</span><span class="s2">;</span>
      <span class="s1">mTextBreakStrategy = Layout.BREAK_STRATEGY_HIGH_QUALITY</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">markUpdated()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = PROP_SHADOW_OFFSET)</span>
  <span class="s2">public void </span><span class="s1">setTextShadowOffset(ReadableMap offsetMap) {</span>
    <span class="s1">mTextShadowOffsetDx = </span><span class="s7">0</span><span class="s2">;</span>
    <span class="s1">mTextShadowOffsetDy = </span><span class="s7">0</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(offsetMap != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(offsetMap.hasKey(PROP_SHADOW_OFFSET_WIDTH)</span>
          <span class="s1">&amp;&amp; !offsetMap.isNull(PROP_SHADOW_OFFSET_WIDTH)) {</span>
        <span class="s1">mTextShadowOffsetDx =</span>
            <span class="s1">PixelUtil.toPixelFromDIP(offsetMap.getDouble(PROP_SHADOW_OFFSET_WIDTH))</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(offsetMap.hasKey(PROP_SHADOW_OFFSET_HEIGHT)</span>
          <span class="s1">&amp;&amp; !offsetMap.isNull(PROP_SHADOW_OFFSET_HEIGHT)) {</span>
        <span class="s1">mTextShadowOffsetDy =</span>
            <span class="s1">PixelUtil.toPixelFromDIP(offsetMap.getDouble(PROP_SHADOW_OFFSET_HEIGHT))</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">markUpdated()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = PROP_SHADOW_RADIUS</span><span class="s2">, </span><span class="s1">defaultInt = </span><span class="s7">1</span><span class="s1">)</span>
  <span class="s2">public void </span><span class="s1">setTextShadowRadius(</span><span class="s2">float </span><span class="s1">textShadowRadius) {</span>
    <span class="s2">if </span><span class="s1">(textShadowRadius != mTextShadowRadius) {</span>
      <span class="s1">mTextShadowRadius = textShadowRadius</span><span class="s2">;</span>
      <span class="s1">markUpdated()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = PROP_SHADOW_COLOR</span><span class="s2">, </span><span class="s1">defaultInt = DEFAULT_TEXT_SHADOW_COLOR</span><span class="s2">, </span><span class="s1">customType = </span><span class="s6">&quot;Color&quot;</span><span class="s1">)</span>
  <span class="s2">public void </span><span class="s1">setTextShadowColor(</span><span class="s2">int </span><span class="s1">textShadowColor) {</span>
    <span class="s2">if </span><span class="s1">(textShadowColor != mTextShadowColor) {</span>
      <span class="s1">mTextShadowColor = textShadowColor</span><span class="s2">;</span>
      <span class="s1">markUpdated()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = PROP_TEXT_TRANSFORM)</span>
  <span class="s2">public void </span><span class="s1">setTextTransform(@Nullable String textTransform) {</span>
    <span class="s2">if </span><span class="s1">(textTransform == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mTextAttributes.setTextTransform(TextTransform.UNSET)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s6">&quot;none&quot;</span><span class="s1">.equals(textTransform)) {</span>
      <span class="s1">mTextAttributes.setTextTransform(TextTransform.NONE)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s6">&quot;uppercase&quot;</span><span class="s1">.equals(textTransform)) {</span>
      <span class="s1">mTextAttributes.setTextTransform(TextTransform.UPPERCASE)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s6">&quot;lowercase&quot;</span><span class="s1">.equals(textTransform)) {</span>
      <span class="s1">mTextAttributes.setTextTransform(TextTransform.LOWERCASE)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s6">&quot;capitalize&quot;</span><span class="s1">.equals(textTransform)) {</span>
      <span class="s1">mTextAttributes.setTextTransform(TextTransform.CAPITALIZE)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">FLog.w(ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;Invalid textTransform: &quot; </span><span class="s1">+ textTransform)</span><span class="s2">;</span>
      <span class="s1">mTextAttributes.setTextTransform(TextTransform.UNSET)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">markUpdated()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.ADJUSTS_FONT_SIZE_TO_FIT)</span>
  <span class="s2">public void </span><span class="s1">setAdjustFontSizeToFit(</span><span class="s2">boolean </span><span class="s1">adjustsFontSizeToFit) {</span>
    <span class="s2">if </span><span class="s1">(adjustsFontSizeToFit != mAdjustsFontSizeToFit) {</span>
      <span class="s1">mAdjustsFontSizeToFit = adjustsFontSizeToFit</span><span class="s2">;</span>
      <span class="s1">markUpdated()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ReactProp(name = ViewProps.MINIMUM_FONT_SCALE)</span>
  <span class="s2">public void </span><span class="s1">setMinimumFontScale(</span><span class="s2">float </span><span class="s1">minimumFontScale) {</span>
    <span class="s2">if </span><span class="s1">(minimumFontScale != mMinimumFontScale) {</span>
      <span class="s1">mMinimumFontScale = minimumFontScale</span><span class="s2">;</span>
      <span class="s1">markUpdated()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
<html>
<head>
<title>UIManagerModule.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #77b767; font-style: italic;}
.s5 { color: #629755; font-weight: bold; font-style: italic;}
.s6 { color: #6a8759;}
.s7 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
UIManagerModule.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.uimanager</span><span class="s2">;</span>

<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.CREATE_UI_MANAGER_MODULE_CONSTANTS_END</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.CREATE_UI_MANAGER_MODULE_CONSTANTS_START</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.uimanager.common.UIManagerType.DEFAULT</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.uimanager.common.UIManagerType.FABRIC</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.content.ComponentCallbacks2</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.content.res.Configuration</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.View</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.NonNull</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.logging.FLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.debug.holder.PrinterHolder</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.debug.tags.ReactDebugOverlayTags</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.Arguments</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.Callback</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.Dynamic</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.GuardedRunnable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.LifecycleEventListener</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.OnBatchCompleteListener</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactApplicationContext</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactContextBaseJavaModule</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactMarker</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactMethod</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableArray</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableType</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.UIManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.UIManagerListener</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.UiThreadUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.WritableMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.MapBuilder</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.ReactConstants</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.module.annotations.ReactModule</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.common.ViewUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.debug.NotThreadSafeViewHierarchyUpdateDebugListener</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.events.EventDispatcher</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.events.EventDispatcherImpl</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.events.RCTEventEmitter</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.systrace.Systrace</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.systrace.SystraceMessage</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.ArrayList</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.List</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Map</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.concurrent.CopyOnWriteArrayList</span><span class="s2">;</span>

<span class="s3">/**</span>
 <span class="s3">* Native module to allow JS to create and update native Views.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">&lt;p&gt;</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">&lt;h2&gt;</span><span class="s3">== Transactional Requirement ==</span><span class="s4">&lt;/h2&gt;</span>
 <span class="s3">*</span>
 <span class="s3">* A requirement of this class is to make sure that transactional UI updates occur all at once,</span>
 <span class="s3">* meaning that no intermediate state is ever rendered to the screen. For example, if a JS</span>
 <span class="s3">* application update changes the background of View A to blue and the width of View B to 100, both</span>
 <span class="s3">* need to appear at once. Practically, this means that all UI update code related to a single</span>
 <span class="s3">* transaction must be executed as a single code block on the UI thread. Executing as multiple code</span>
 <span class="s3">* blocks could allow the platform UI system to interrupt and render a partial UI state.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">To facilitate this, this module enqueues operations that are then applied to native view</span>
 <span class="s3">* hierarchy through {</span><span class="s5">@link </span><span class="s3">NativeViewHierarchyManager} at the end of each transaction.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">&lt;p&gt;</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">&lt;h2&gt;</span><span class="s3">== CSSNodes ==</span><span class="s4">&lt;/h2&gt;</span>
 <span class="s3">*</span>
 <span class="s3">* In order to allow layout and measurement to occur on a non-UI thread, this module also operates</span>
 <span class="s3">* on intermediate CSSNodeDEPRECATED objects that correspond to a native view. These</span>
 <span class="s3">* CSSNodeDEPRECATED are able to calculate layout according to their styling rules, and then the</span>
 <span class="s3">* resulting x/y/width/height of that layout is scheduled as an operation that will be applied to</span>
 <span class="s3">* native view hierarchy at the end of current batch. TODO(5241856): Investigate memory usage of</span>
 <span class="s3">* creating many small objects in UIManageModule and consider implementing a pool TODO(5483063):</span>
 <span class="s3">* Don't dispatch the view hierarchy at the end of a batch if no UI changes occurred</span>
 <span class="s3">*/</span>
<span class="s1">@ReactModule(name = UIManagerModule.NAME)</span>
<span class="s2">public class </span><span class="s1">UIManagerModule </span><span class="s2">extends </span><span class="s1">ReactContextBaseJavaModule</span>
    <span class="s2">implements </span><span class="s1">OnBatchCompleteListener</span><span class="s2">, </span><span class="s1">LifecycleEventListener</span><span class="s2">, </span><span class="s1">UIManager {</span>
  <span class="s2">public static final </span><span class="s1">String TAG = UIManagerModule.</span><span class="s2">class</span><span class="s1">.getSimpleName()</span><span class="s2">;</span>

  <span class="s3">/** Resolves a name coming from native side to a name of the event that is exposed to JS. */</span>
  <span class="s2">public interface </span><span class="s1">CustomEventNamesResolver {</span>
    <span class="s3">/** Returns custom event name by the provided event name. */</span>
    <span class="s1">@Nullable</span>
    <span class="s1">String resolveCustomEventName(String eventName)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public static final </span><span class="s1">String NAME = </span><span class="s6">&quot;UIManager&quot;</span><span class="s2">;</span>

  <span class="s2">private static final boolean </span><span class="s1">DEBUG =</span>
      <span class="s1">PrinterHolder.getPrinter().shouldDisplayLogMessage(ReactDebugOverlayTags.UI_MANAGER)</span><span class="s2">;</span>

  <span class="s2">private final </span><span class="s1">EventDispatcher mEventDispatcher</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">Map&lt;String</span><span class="s2">, </span><span class="s1">Object&gt; mModuleConstants</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">Map&lt;String</span><span class="s2">, </span><span class="s1">Object&gt; mCustomDirectEvents</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">ViewManagerRegistry mViewManagerRegistry</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">UIImplementation mUIImplementation</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">MemoryTrimCallback mMemoryTrimCallback = </span><span class="s2">new </span><span class="s1">MemoryTrimCallback()</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">List&lt;UIManagerModuleListener&gt; mListeners = </span><span class="s2">new </span><span class="s1">ArrayList&lt;&gt;()</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">CopyOnWriteArrayList&lt;UIManagerListener&gt; mUIManagerListeners =</span>
      <span class="s2">new </span><span class="s1">CopyOnWriteArrayList&lt;&gt;()</span><span class="s2">;</span>

  <span class="s2">private int </span><span class="s1">mBatchId = </span><span class="s7">0</span><span class="s2">;</span>

  <span class="s2">public </span><span class="s1">UIManagerModule(</span>
      <span class="s1">ReactApplicationContext reactContext</span><span class="s2">,</span>
      <span class="s1">ViewManagerResolver viewManagerResolver</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">minTimeLeftInFrameForNonBatchedOperationMs) {</span>
    <span class="s2">super</span><span class="s1">(reactContext)</span><span class="s2">;</span>
    <span class="s1">DisplayMetricsHolder.initDisplayMetricsIfNotInitialized(reactContext)</span><span class="s2">;</span>
    <span class="s1">mEventDispatcher = </span><span class="s2">new </span><span class="s1">EventDispatcherImpl(reactContext)</span><span class="s2">;</span>
    <span class="s1">mModuleConstants = createConstants(viewManagerResolver)</span><span class="s2">;</span>
    <span class="s1">mCustomDirectEvents = UIManagerModuleConstants.getDirectEventTypeConstants()</span><span class="s2">;</span>
    <span class="s1">mViewManagerRegistry = </span><span class="s2">new </span><span class="s1">ViewManagerRegistry(viewManagerResolver)</span><span class="s2">;</span>
    <span class="s1">mUIImplementation =</span>
        <span class="s2">new </span><span class="s1">UIImplementation(</span>
            <span class="s1">reactContext</span><span class="s2">,</span>
            <span class="s1">mViewManagerRegistry</span><span class="s2">,</span>
            <span class="s1">mEventDispatcher</span><span class="s2">,</span>
            <span class="s1">minTimeLeftInFrameForNonBatchedOperationMs)</span><span class="s2">;</span>

    <span class="s1">reactContext.addLifecycleEventListener(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">UIManagerModule(</span>
      <span class="s1">ReactApplicationContext reactContext</span><span class="s2">,</span>
      <span class="s1">List&lt;ViewManager&gt; viewManagersList</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">minTimeLeftInFrameForNonBatchedOperationMs) {</span>
    <span class="s2">super</span><span class="s1">(reactContext)</span><span class="s2">;</span>
    <span class="s1">DisplayMetricsHolder.initDisplayMetricsIfNotInitialized(reactContext)</span><span class="s2">;</span>
    <span class="s1">mEventDispatcher = </span><span class="s2">new </span><span class="s1">EventDispatcherImpl(reactContext)</span><span class="s2">;</span>
    <span class="s1">mCustomDirectEvents = MapBuilder.newHashMap()</span><span class="s2">;</span>
    <span class="s1">mModuleConstants = createConstants(viewManagersList</span><span class="s2">, null, </span><span class="s1">mCustomDirectEvents)</span><span class="s2">;</span>
    <span class="s1">mViewManagerRegistry = </span><span class="s2">new </span><span class="s1">ViewManagerRegistry(viewManagersList)</span><span class="s2">;</span>
    <span class="s1">mUIImplementation =</span>
        <span class="s2">new </span><span class="s1">UIImplementation(</span>
            <span class="s1">reactContext</span><span class="s2">,</span>
            <span class="s1">mViewManagerRegistry</span><span class="s2">,</span>
            <span class="s1">mEventDispatcher</span><span class="s2">,</span>
            <span class="s1">minTimeLeftInFrameForNonBatchedOperationMs)</span><span class="s2">;</span>

    <span class="s1">reactContext.addLifecycleEventListener(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* This method gives an access to the {</span><span class="s5">@link </span><span class="s3">UIImplementation} object that can be used to execute</span>
   <span class="s3">* operations on the view hierarchy.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">This method will not be supported by the new architecture of react native.</span>
   <span class="s3">*/</span>
  <span class="s1">@Deprecated</span>
  <span class="s2">public </span><span class="s1">UIImplementation getUIImplementation() {</span>
    <span class="s2">return </span><span class="s1">mUIImplementation</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">@NonNull String getName() {</span>
    <span class="s2">return </span><span class="s1">NAME</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">Map&lt;String</span><span class="s2">, </span><span class="s1">Object&gt; getConstants() {</span>
    <span class="s2">return </span><span class="s1">mModuleConstants</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">initialize() {</span>
    <span class="s1">getReactApplicationContext().registerComponentCallbacks(mMemoryTrimCallback)</span><span class="s2">;</span>
    <span class="s1">getReactApplicationContext().registerComponentCallbacks(mViewManagerRegistry)</span><span class="s2">;</span>
    <span class="s1">mEventDispatcher.registerEventEmitter(</span>
        <span class="s1">DEFAULT</span><span class="s2">, </span><span class="s1">getReactApplicationContext().getJSModule(RCTEventEmitter.</span><span class="s2">class</span><span class="s1">))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onHostResume() {</span>
    <span class="s1">mUIImplementation.onHostResume()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onHostPause() {</span>
    <span class="s1">mUIImplementation.onHostPause()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onHostDestroy() {</span>
    <span class="s1">mUIImplementation.onHostDestroy()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onCatalystInstanceDestroy() {</span>
    <span class="s2">super</span><span class="s1">.onCatalystInstanceDestroy()</span><span class="s2">;</span>
    <span class="s1">mEventDispatcher.onCatalystInstanceDestroyed()</span><span class="s2">;</span>
    <span class="s1">mUIImplementation.onCatalystInstanceDestroyed()</span><span class="s2">;</span>

    <span class="s1">ReactApplicationContext reactApplicationContext = getReactApplicationContext()</span><span class="s2">;</span>
    <span class="s1">reactApplicationContext.unregisterComponentCallbacks(mMemoryTrimCallback)</span><span class="s2">;</span>
    <span class="s1">reactApplicationContext.unregisterComponentCallbacks(mViewManagerRegistry)</span><span class="s2">;</span>
    <span class="s1">YogaNodePool.get().clear()</span><span class="s2">;</span>
    <span class="s1">ViewManagerPropertyUpdater.clear()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* This method is intended to reuse the {</span><span class="s5">@link </span><span class="s3">ViewManagerRegistry} with FabricUIManager. Do not</span>
   <span class="s3">* use this method as this will be removed in the near future.</span>
   <span class="s3">*/</span>
  <span class="s1">@Deprecated</span>
  <span class="s2">public </span><span class="s1">ViewManagerRegistry getViewManagerRegistry_DO_NOT_USE() {</span>
    <span class="s2">return </span><span class="s1">mViewManagerRegistry</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private static </span><span class="s1">Map&lt;String</span><span class="s2">, </span><span class="s1">Object&gt; createConstants(ViewManagerResolver viewManagerResolver) {</span>
    <span class="s1">ReactMarker.logMarker(CREATE_UI_MANAGER_MODULE_CONSTANTS_START)</span><span class="s2">;</span>
    <span class="s1">SystraceMessage.beginSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;CreateUIManagerConstants&quot;</span><span class="s1">)</span>
        <span class="s1">.arg(</span><span class="s6">&quot;Lazy&quot;</span><span class="s2">, true</span><span class="s1">)</span>
        <span class="s1">.flush()</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">UIManagerModuleConstantsHelper.createConstants(viewManagerResolver)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">Systrace.endSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
      <span class="s1">ReactMarker.logMarker(CREATE_UI_MANAGER_MODULE_CONSTANTS_END)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private static </span><span class="s1">Map&lt;String</span><span class="s2">, </span><span class="s1">Object&gt; createConstants(</span>
      <span class="s1">List&lt;ViewManager&gt; viewManagers</span><span class="s2">,</span>
      <span class="s1">@Nullable Map&lt;String</span><span class="s2">, </span><span class="s1">Object&gt; customBubblingEvents</span><span class="s2">,</span>
      <span class="s1">@Nullable Map&lt;String</span><span class="s2">, </span><span class="s1">Object&gt; customDirectEvents) {</span>
    <span class="s1">ReactMarker.logMarker(CREATE_UI_MANAGER_MODULE_CONSTANTS_START)</span><span class="s2">;</span>
    <span class="s1">SystraceMessage.beginSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;CreateUIManagerConstants&quot;</span><span class="s1">)</span>
        <span class="s1">.arg(</span><span class="s6">&quot;Lazy&quot;</span><span class="s2">, false</span><span class="s1">)</span>
        <span class="s1">.flush()</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">UIManagerModuleConstantsHelper.createConstants(</span>
          <span class="s1">viewManagers</span><span class="s2">, </span><span class="s1">customBubblingEvents</span><span class="s2">, </span><span class="s1">customDirectEvents)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">Systrace.endSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
      <span class="s1">ReactMarker.logMarker(CREATE_UI_MANAGER_MODULE_CONSTANTS_END)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ReactMethod(isBlockingSynchronousMethod = </span><span class="s2">true</span><span class="s1">)</span>
  <span class="s2">public </span><span class="s1">@Nullable WritableMap getConstantsForViewManager(@Nullable String viewManagerName) {</span>
    <span class="s1">ViewManager targetView =</span>
        <span class="s1">viewManagerName != </span><span class="s2">null </span><span class="s1">? mUIImplementation.resolveViewManager(viewManagerName) : </span><span class="s2">null;</span>
    <span class="s2">if </span><span class="s1">(targetView == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return null;</span>
    <span class="s1">}</span>

    <span class="s1">SystraceMessage.beginSection(</span>
            <span class="s1">Systrace.TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;UIManagerModule.getConstantsForViewManager&quot;</span><span class="s1">)</span>
        <span class="s1">.arg(</span><span class="s6">&quot;ViewManager&quot;</span><span class="s2">, </span><span class="s1">targetView.getName())</span>
        <span class="s1">.arg(</span><span class="s6">&quot;Lazy&quot;</span><span class="s2">, true</span><span class="s1">)</span>
        <span class="s1">.flush()</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">Map&lt;String</span><span class="s2">, </span><span class="s1">Object&gt; viewManagerConstants =</span>
          <span class="s1">UIManagerModuleConstantsHelper.createConstantsForViewManager(</span>
              <span class="s1">targetView</span><span class="s2">, null, null, null, </span><span class="s1">mCustomDirectEvents)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(viewManagerConstants != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">Arguments.makeNativeMap(viewManagerConstants)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return null;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">SystraceMessage.endSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE).flush()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ReactMethod(isBlockingSynchronousMethod = </span><span class="s2">true</span><span class="s1">)</span>
  <span class="s2">public </span><span class="s1">WritableMap getDefaultEventTypes() {</span>
    <span class="s2">return </span><span class="s1">Arguments.makeNativeMap(UIManagerModuleConstantsHelper.getDefaultExportableEventTypes())</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Resolves Direct Event name exposed to JS from the one known to the Native side. */</span>
  <span class="s1">@Deprecated</span>
  <span class="s2">public </span><span class="s1">CustomEventNamesResolver getDirectEventNamesResolver() {</span>
    <span class="s2">return new </span><span class="s1">CustomEventNamesResolver() {</span>
      <span class="s1">@Override</span>
      <span class="s2">public </span><span class="s1">@Nullable String resolveCustomEventName(@Nullable String eventName) {</span>
        <span class="s2">return </span><span class="s1">resolveCustomDirectEventName(eventName)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s1">@Deprecated</span>
  <span class="s1">@Nullable</span>
  <span class="s2">public </span><span class="s1">String resolveCustomDirectEventName(@Nullable String eventName) {</span>
    <span class="s2">if </span><span class="s1">(eventName != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">Map&lt;String</span><span class="s2">, </span><span class="s1">String&gt; customEventType =</span>
          <span class="s1">(Map&lt;String</span><span class="s2">, </span><span class="s1">String&gt;) mCustomDirectEvents.get(eventName)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(customEventType != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">customEventType.get(</span><span class="s6">&quot;registrationName&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">eventName</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">profileNextBatch() {</span>
    <span class="s1">mUIImplementation.profileNextBatch()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">Map&lt;String</span><span class="s2">, </span><span class="s1">Long&gt; getPerformanceCounters() {</span>
    <span class="s2">return </span><span class="s1">mUIImplementation.getProfiledBatchPerfCounters()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">&lt;T </span><span class="s2">extends </span><span class="s1">View&gt; </span><span class="s2">int </span><span class="s1">addRootView(</span><span class="s2">final </span><span class="s1">T rootView) {</span>
    <span class="s2">return </span><span class="s1">addRootView(rootView</span><span class="s2">, null, null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Used by native animated module to bypass the process of updating the values through the shadow</span>
   <span class="s3">* view hierarchy. This method will directly update native views, which means that updates for</span>
   <span class="s3">* layout-related propertied won't be handled properly. Make sure you know what you're doing</span>
   <span class="s3">* before calling this method :)</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">synchronouslyUpdateViewOnUIThread(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">ReadableMap props) {</span>
    <span class="s1">mUIImplementation.synchronouslyUpdateViewOnUIThread(tag</span><span class="s2">, new </span><span class="s1">ReactStylesDiffMap(props))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Registers a new root view. JS can use the returned tag with manageChildren to add/remove</span>
   <span class="s3">* children to this view.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">Calling addRootView through UIManagerModule calls addRootView in the non-Fabric renderer,</span>
   <span class="s3">* always. This is deprecated in favor of calling startSurface in Fabric, which must be done</span>
   <span class="s3">* directly through the FabricUIManager.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">Note that this must be called after getWidth()/getHeight() actually return something. See</span>
   <span class="s3">* CatalystApplicationFragment as an example.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">TODO(6242243): Make addRootView thread safe NB: this method is horribly not-thread-safe.</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">&lt;T </span><span class="s2">extends </span><span class="s1">View&gt; </span><span class="s2">int </span><span class="s1">addRootView(</span>
      <span class="s2">final </span><span class="s1">T rootView</span><span class="s2">, </span><span class="s1">WritableMap initialProps</span><span class="s2">, </span><span class="s1">@Nullable String initialUITemplate) {</span>
    <span class="s1">Systrace.beginSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;UIManagerModule.addRootView&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">tag = ReactRootViewTagGenerator.getNextRootViewTag()</span><span class="s2">;</span>
    <span class="s2">final </span><span class="s1">ReactApplicationContext reactApplicationContext = getReactApplicationContext()</span><span class="s2">;</span>

    <span class="s0">// We pass in a surfaceId of -1 here - it is used only in Fabric.</span>
    <span class="s2">final </span><span class="s1">ThemedReactContext themedRootContext =</span>
        <span class="s2">new </span><span class="s1">ThemedReactContext(</span>
            <span class="s1">reactApplicationContext</span><span class="s2">,</span>
            <span class="s1">rootView.getContext()</span><span class="s2">,</span>
            <span class="s1">((ReactRoot) rootView).getSurfaceID()</span><span class="s2">,</span>
            <span class="s1">-</span><span class="s7">1</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s1">mUIImplementation.registerRootView(rootView</span><span class="s2">, </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">themedRootContext)</span><span class="s2">;</span>
    <span class="s1">Systrace.endSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">tag</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">&lt;T </span><span class="s2">extends </span><span class="s1">View&gt; </span><span class="s2">int </span><span class="s1">startSurface(</span>
      <span class="s2">final </span><span class="s1">T rootView</span><span class="s2">,</span>
      <span class="s2">final </span><span class="s1">String moduleName</span><span class="s2">,</span>
      <span class="s2">final </span><span class="s1">WritableMap initialProps</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">widthMeasureSpec</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">heightMeasureSpec) {</span>
    <span class="s2">throw new </span><span class="s1">UnsupportedOperationException()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">stopSurface(</span><span class="s2">final int </span><span class="s1">surfaceId) {</span>
    <span class="s2">throw new </span><span class="s1">UnsupportedOperationException()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Unregisters a new root view. */</span>
  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">removeRootView(</span><span class="s2">int </span><span class="s1">rootViewTag) {</span>
    <span class="s1">mUIImplementation.removeRootView(rootViewTag)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">updateNodeSize(</span><span class="s2">int </span><span class="s1">nodeViewTag</span><span class="s2">, int </span><span class="s1">newWidth</span><span class="s2">, int </span><span class="s1">newHeight) {</span>
    <span class="s1">getReactApplicationContext().assertOnNativeModulesQueueThread()</span><span class="s2">;</span>

    <span class="s1">mUIImplementation.updateNodeSize(nodeViewTag</span><span class="s2">, </span><span class="s1">newWidth</span><span class="s2">, </span><span class="s1">newHeight)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Sets local data for a shadow node corresponded with given tag. In some cases we need a way to</span>
   <span class="s3">* specify some environmental data to shadow node to improve layout (or do something similar), so</span>
   <span class="s3">* {</span><span class="s5">@code </span><span class="s3">localData} serves these needs. For example, any stateful embedded native views may</span>
   <span class="s3">* benefit from this. Have in mind that this data is not supposed to interfere with the state of</span>
   <span class="s3">* the shadow view. Please respect one-directional data flow of React.</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">setViewLocalData(</span><span class="s2">final int </span><span class="s1">tag</span><span class="s2">, final </span><span class="s1">Object data) {</span>
    <span class="s2">final </span><span class="s1">ReactApplicationContext reactApplicationContext = getReactApplicationContext()</span><span class="s2">;</span>

    <span class="s1">reactApplicationContext.assertOnUiQueueThread()</span><span class="s2">;</span>

    <span class="s1">reactApplicationContext.runOnNativeModulesQueueThread(</span>
        <span class="s2">new </span><span class="s1">GuardedRunnable(reactApplicationContext) {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">runGuarded() {</span>
            <span class="s1">mUIImplementation.setViewLocalData(tag</span><span class="s2">, </span><span class="s1">data)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">createView(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">String className</span><span class="s2">, int </span><span class="s1">rootViewTag</span><span class="s2">, </span><span class="s1">ReadableMap props) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG) {</span>
      <span class="s1">String message =</span>
          <span class="s6">&quot;(UIManager.createView) tag: &quot; </span><span class="s1">+ tag + </span><span class="s6">&quot;, class: &quot; </span><span class="s1">+ className + </span><span class="s6">&quot;, props: &quot; </span><span class="s1">+ props</span><span class="s2">;</span>
      <span class="s1">FLog.d(ReactConstants.TAG</span><span class="s2">, </span><span class="s1">message)</span><span class="s2">;</span>
      <span class="s1">PrinterHolder.getPrinter().logMessage(ReactDebugOverlayTags.UI_MANAGER</span><span class="s2">, </span><span class="s1">message)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mUIImplementation.createView(tag</span><span class="s2">, </span><span class="s1">className</span><span class="s2">, </span><span class="s1">rootViewTag</span><span class="s2">, </span><span class="s1">props)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">updateView(</span><span class="s2">final int </span><span class="s1">tag</span><span class="s2">, final </span><span class="s1">String className</span><span class="s2">, final </span><span class="s1">ReadableMap props) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG) {</span>
      <span class="s1">String message =</span>
          <span class="s6">&quot;(UIManager.updateView) tag: &quot; </span><span class="s1">+ tag + </span><span class="s6">&quot;, class: &quot; </span><span class="s1">+ className + </span><span class="s6">&quot;, props: &quot; </span><span class="s1">+ props</span><span class="s2">;</span>
      <span class="s1">FLog.d(ReactConstants.TAG</span><span class="s2">, </span><span class="s1">message)</span><span class="s2">;</span>
      <span class="s1">PrinterHolder.getPrinter().logMessage(ReactDebugOverlayTags.UI_MANAGER</span><span class="s2">, </span><span class="s1">message)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mUIImplementation.updateView(tag</span><span class="s2">, </span><span class="s1">className</span><span class="s2">, </span><span class="s1">props)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Interface for adding/removing/moving views within a parent view from JS.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">viewTag the view tag of the parent view</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">moveFrom a list of indices in the parent view to move views from</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">moveTo parallel to moveFrom, a list of indices in the parent view to move views to</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">addChildTags a list of tags of views to add to the parent</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">addAtIndices parallel to addChildTags, a list of indices to insert those children at</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">removeFrom a list of indices of views to permanently remove. The memory for the</span>
   <span class="s3">*     corresponding views and data structures should be reclaimed.</span>
   <span class="s3">*/</span>
  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">manageChildren(</span>
      <span class="s2">int </span><span class="s1">viewTag</span><span class="s2">,</span>
      <span class="s1">@Nullable ReadableArray moveFrom</span><span class="s2">,</span>
      <span class="s1">@Nullable ReadableArray moveTo</span><span class="s2">,</span>
      <span class="s1">@Nullable ReadableArray addChildTags</span><span class="s2">,</span>
      <span class="s1">@Nullable ReadableArray addAtIndices</span><span class="s2">,</span>
      <span class="s1">@Nullable ReadableArray removeFrom) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG) {</span>
      <span class="s1">String message =</span>
          <span class="s6">&quot;(UIManager.manageChildren) tag: &quot;</span>
              <span class="s1">+ viewTag</span>
              <span class="s1">+ </span><span class="s6">&quot;, moveFrom: &quot;</span>
              <span class="s1">+ moveFrom</span>
              <span class="s1">+ </span><span class="s6">&quot;, moveTo: &quot;</span>
              <span class="s1">+ moveTo</span>
              <span class="s1">+ </span><span class="s6">&quot;, addTags: &quot;</span>
              <span class="s1">+ addChildTags</span>
              <span class="s1">+ </span><span class="s6">&quot;, atIndices: &quot;</span>
              <span class="s1">+ addAtIndices</span>
              <span class="s1">+ </span><span class="s6">&quot;, removeFrom: &quot;</span>
              <span class="s1">+ removeFrom</span><span class="s2">;</span>
      <span class="s1">FLog.d(ReactConstants.TAG</span><span class="s2">, </span><span class="s1">message)</span><span class="s2">;</span>
      <span class="s1">PrinterHolder.getPrinter().logMessage(ReactDebugOverlayTags.UI_MANAGER</span><span class="s2">, </span><span class="s1">message)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mUIImplementation.manageChildren(</span>
        <span class="s1">viewTag</span><span class="s2">, </span><span class="s1">moveFrom</span><span class="s2">, </span><span class="s1">moveTo</span><span class="s2">, </span><span class="s1">addChildTags</span><span class="s2">, </span><span class="s1">addAtIndices</span><span class="s2">, </span><span class="s1">removeFrom)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Interface for fast tracking the initial adding of views. Children view tags are assumed to be</span>
   <span class="s3">* in order</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">viewTag the view tag of the parent view</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">childrenTags An array of tags to add to the parent in order</span>
   <span class="s3">*/</span>
  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">setChildren(</span><span class="s2">int </span><span class="s1">viewTag</span><span class="s2">, </span><span class="s1">ReadableArray childrenTags) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG) {</span>
      <span class="s1">String message = </span><span class="s6">&quot;(UIManager.setChildren) tag: &quot; </span><span class="s1">+ viewTag + </span><span class="s6">&quot;, children: &quot; </span><span class="s1">+ childrenTags</span><span class="s2">;</span>
      <span class="s1">FLog.d(ReactConstants.TAG</span><span class="s2">, </span><span class="s1">message)</span><span class="s2">;</span>
      <span class="s1">PrinterHolder.getPrinter().logMessage(ReactDebugOverlayTags.UI_MANAGER</span><span class="s2">, </span><span class="s1">message)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mUIImplementation.setChildren(viewTag</span><span class="s2">, </span><span class="s1">childrenTags)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Replaces the View specified by oldTag with the View specified by newTag within oldTag's parent.</span>
   <span class="s3">* This resolves to a simple {</span><span class="s5">@link </span><span class="s3">#manageChildren} call, but React doesn't have enough info in</span>
   <span class="s3">* JS to formulate it itself.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">This method will not be available in Fabric UIManager class.</span>
   <span class="s3">*/</span>
  <span class="s1">@ReactMethod</span>
  <span class="s1">@Deprecated</span>
  <span class="s2">public void </span><span class="s1">replaceExistingNonRootView(</span><span class="s2">int </span><span class="s1">oldTag</span><span class="s2">, int </span><span class="s1">newTag) {</span>
    <span class="s1">mUIImplementation.replaceExistingNonRootView(oldTag</span><span class="s2">, </span><span class="s1">newTag)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Method which takes a container tag and then releases all subviews for that container upon</span>
   <span class="s3">* receipt.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">containerTag the tag of the container for which the subviews must be removed</span>
   <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">This method will not be available in Fabric UIManager class.</span>
   <span class="s3">*/</span>
  <span class="s1">@ReactMethod</span>
  <span class="s1">@Deprecated</span>
  <span class="s2">public void </span><span class="s1">removeSubviewsFromContainerWithID(</span><span class="s2">int </span><span class="s1">containerTag) {</span>
    <span class="s1">mUIImplementation.removeSubviewsFromContainerWithID(containerTag)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Determines the location on screen, width, and height of the given view and returns the values</span>
   <span class="s3">* via an async callback.</span>
   <span class="s3">*/</span>
  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">measure(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">Callback callback) {</span>
    <span class="s1">mUIImplementation.measure(reactTag</span><span class="s2">, </span><span class="s1">callback)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Determines the location on screen, width, and height of the given view relative to the device</span>
   <span class="s3">* screen and returns the values via an async callback. This is the absolute position including</span>
   <span class="s3">* things like the status bar</span>
   <span class="s3">*/</span>
  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">measureInWindow(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">Callback callback) {</span>
    <span class="s1">mUIImplementation.measureInWindow(reactTag</span><span class="s2">, </span><span class="s1">callback)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Measures the view specified by tag relative to the given ancestorTag. This means that the</span>
   <span class="s3">* returned x, y are relative to the origin x, y of the ancestor view. Results are stored in the</span>
   <span class="s3">* given outputBuffer. We allow ancestor view and measured view to be the same, in which case the</span>
   <span class="s3">* position always will be (0, 0) and method will only measure the view dimensions.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">NB: Unlike {</span><span class="s5">@link </span><span class="s3">#measure}, this will measure relative to the view layout, not the visible</span>
   <span class="s3">* window which can cause unexpected results when measuring relative to things like ScrollViews</span>
   <span class="s3">* that can have offset content on the screen.</span>
   <span class="s3">*/</span>
  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">measureLayout(</span>
      <span class="s2">int </span><span class="s1">tag</span><span class="s2">, int </span><span class="s1">ancestorTag</span><span class="s2">, </span><span class="s1">Callback errorCallback</span><span class="s2">, </span><span class="s1">Callback successCallback) {</span>
    <span class="s1">mUIImplementation.measureLayout(tag</span><span class="s2">, </span><span class="s1">ancestorTag</span><span class="s2">, </span><span class="s1">errorCallback</span><span class="s2">, </span><span class="s1">successCallback)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Like {</span><span class="s5">@link </span><span class="s3">#measure} and {</span><span class="s5">@link </span><span class="s3">#measureLayout} but measures relative to the immediate parent.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">NB: Unlike {</span><span class="s5">@link </span><span class="s3">#measure}, this will measure relative to the view layout, not the visible</span>
   <span class="s3">* window which can cause unexpected results when measuring relative to things like ScrollViews</span>
   <span class="s3">* that can have offset content on the screen.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">this method will not be available in FabricUIManager class.</span>
   <span class="s3">*/</span>
  <span class="s1">@ReactMethod</span>
  <span class="s1">@Deprecated</span>
  <span class="s2">public void </span><span class="s1">measureLayoutRelativeToParent(</span>
      <span class="s2">int </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">Callback errorCallback</span><span class="s2">, </span><span class="s1">Callback successCallback) {</span>
    <span class="s1">mUIImplementation.measureLayoutRelativeToParent(tag</span><span class="s2">, </span><span class="s1">errorCallback</span><span class="s2">, </span><span class="s1">successCallback)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Find the touch target child native view in the supplied root view hierarchy, given a react</span>
   <span class="s3">* target location.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">This method is currently used only by Element Inspector DevTool.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">reactTag the tag of the root view to traverse</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">point an array containing both X and Y target location</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">callback will be called if with the identified child view react ID, and measurement</span>
   <span class="s3">*     info. If no view was found, callback will be invoked with no data.</span>
   <span class="s3">*/</span>
  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">findSubviewIn(</span>
      <span class="s2">final int </span><span class="s1">reactTag</span><span class="s2">, final </span><span class="s1">ReadableArray point</span><span class="s2">, final </span><span class="s1">Callback callback) {</span>
    <span class="s1">mUIImplementation.findSubviewIn(</span>
        <span class="s1">reactTag</span><span class="s2">,</span>
        <span class="s1">Math.round(PixelUtil.toPixelFromDIP(point.getDouble(</span><span class="s7">0</span><span class="s1">)))</span><span class="s2">,</span>
        <span class="s1">Math.round(PixelUtil.toPixelFromDIP(point.getDouble(</span><span class="s7">1</span><span class="s1">)))</span><span class="s2">,</span>
        <span class="s1">callback)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Check if the first shadow node is the descendant of the second shadow node</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">this method will not be available in FabricUIManager class.</span>
   <span class="s3">*/</span>
  <span class="s1">@ReactMethod</span>
  <span class="s1">@Deprecated</span>
  <span class="s2">public void </span><span class="s1">viewIsDescendantOf(</span>
      <span class="s2">final int </span><span class="s1">reactTag</span><span class="s2">, final int </span><span class="s1">ancestorReactTag</span><span class="s2">, final </span><span class="s1">Callback callback) {</span>
    <span class="s1">mUIImplementation.viewIsDescendantOf(reactTag</span><span class="s2">, </span><span class="s1">ancestorReactTag</span><span class="s2">, </span><span class="s1">callback)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">setJSResponder(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, boolean </span><span class="s1">blockNativeResponder) {</span>
    <span class="s1">mUIImplementation.setJSResponder(reactTag</span><span class="s2">, </span><span class="s1">blockNativeResponder)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">clearJSResponder() {</span>
    <span class="s1">mUIImplementation.clearJSResponder()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">dispatchViewManagerCommand(</span>
      <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">Dynamic commandId</span><span class="s2">, </span><span class="s1">@Nullable ReadableArray commandArgs) {</span>
    <span class="s0">// Fabric dispatchCommands should go through the JSI API - this will crash in Fabric.</span>
    <span class="s1">@Nullable</span>
    <span class="s1">UIManager uiManager =</span>
        <span class="s1">UIManagerHelper.getUIManager(</span>
            <span class="s1">getReactApplicationContext()</span><span class="s2">, </span><span class="s1">ViewUtil.getUIManagerType(reactTag))</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(uiManager == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(commandId.getType() == ReadableType.Number) {</span>
      <span class="s1">uiManager.dispatchCommand(reactTag</span><span class="s2">, </span><span class="s1">commandId.asInt()</span><span class="s2">, </span><span class="s1">commandArgs)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(commandId.getType() == ReadableType.String) {</span>
      <span class="s1">uiManager.dispatchCommand(reactTag</span><span class="s2">, </span><span class="s1">commandId.asString()</span><span class="s2">, </span><span class="s1">commandArgs)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** Deprecated, use {</span><span class="s5">@link </span><span class="s3">#dispatchCommand(int, String, ReadableArray)} instead. */</span>
  <span class="s1">@Deprecated</span>
  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">dispatchCommand(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, int </span><span class="s1">commandId</span><span class="s2">, </span><span class="s1">@Nullable ReadableArray commandArgs) {</span>
    <span class="s1">mUIImplementation.dispatchViewManagerCommand(reactTag</span><span class="s2">, </span><span class="s1">commandId</span><span class="s2">, </span><span class="s1">commandArgs)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">dispatchCommand(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">String commandId</span><span class="s2">, </span><span class="s1">@Nullable ReadableArray commandArgs) {</span>
    <span class="s1">mUIImplementation.dispatchViewManagerCommand(reactTag</span><span class="s2">, </span><span class="s1">commandId</span><span class="s2">, </span><span class="s1">commandArgs)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Show a PopupMenu.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">reactTag the tag of the anchor view (the PopupMenu is displayed next to this view); this</span>
   <span class="s3">*     needs to be the tag of a native view (shadow views can not be anchors)</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">items the menu items as an array of strings</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">error will be called if there is an error displaying the menu</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">success will be called with the position of the selected item as the first argument, or</span>
   <span class="s3">*     no arguments if the menu is dismissed</span>
   <span class="s3">*/</span>
  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">showPopupMenu(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">ReadableArray items</span><span class="s2">, </span><span class="s1">Callback error</span><span class="s2">, </span><span class="s1">Callback success) {</span>
    <span class="s1">mUIImplementation.showPopupMenu(reactTag</span><span class="s2">, </span><span class="s1">items</span><span class="s2">, </span><span class="s1">error</span><span class="s2">, </span><span class="s1">success)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">dismissPopupMenu() {</span>
    <span class="s1">mUIImplementation.dismissPopupMenu()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* LayoutAnimation API on Android is currently experimental. Therefore, it needs to be enabled</span>
   <span class="s3">* explicitly in order to avoid regression in existing application written for iOS using this API.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">Warning : This method will be removed in future version of React Native, and layout</span>
   <span class="s3">* animation will be enabled by default, so always check for its existence before invoking it.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">TODO(9139831) : remove this method once layout animation is fully stable.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">enabled whether layout animation is enabled or not</span>
   <span class="s3">*/</span>
  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">setLayoutAnimationEnabledExperimental(</span><span class="s2">boolean </span><span class="s1">enabled) {</span>
    <span class="s1">mUIImplementation.setLayoutAnimationEnabledExperimental(enabled)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Configure an animation to be used for the native layout changes, and native views creation. The</span>
   <span class="s3">* animation will only apply during the current batch operations.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">TODO(7728153) : animating view deletion is currently not supported.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">config the configuration of the animation for view addition/removal/update.</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">success will be called when the animation completes, or when the animation get</span>
   <span class="s3">*     interrupted. In this case, callback parameter will be false.</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">error will be called if there was an error processing the animation</span>
   <span class="s3">*/</span>
  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">configureNextLayoutAnimation(ReadableMap config</span><span class="s2">, </span><span class="s1">Callback success</span><span class="s2">, </span><span class="s1">Callback error) {</span>
    <span class="s1">mUIImplementation.configureNextLayoutAnimation(config</span><span class="s2">, </span><span class="s1">success)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* To implement the transactional requirement mentioned in the class javadoc, we only commit UI</span>
   <span class="s3">* changes to the actual view hierarchy once a batch of JS-&gt;Java calls have been completed. We</span>
   <span class="s3">* know this is safe because all JS-&gt;Java calls that are triggered by a Java-&gt;JS call (e.g. the</span>
   <span class="s3">* delivery of a touch event or execution of 'renderApplication') end up in a single JS-&gt;Java</span>
   <span class="s3">* transaction.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">A better way to do this would be to have JS explicitly signal to this module when a UI</span>
   <span class="s3">* transaction is done. Right now, though, this is how iOS does it, and we should probably update</span>
   <span class="s3">* the JS and native code and make this change at the same time.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">TODO(5279396): Make JS UI library explicitly notify the native UI module of the end of a UI</span>
   <span class="s3">* transaction using a standard native call</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onBatchComplete() {</span>
    <span class="s2">int </span><span class="s1">batchId = mBatchId</span><span class="s2">;</span>
    <span class="s1">mBatchId++</span><span class="s2">;</span>

    <span class="s1">SystraceMessage.beginSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;onBatchCompleteUI&quot;</span><span class="s1">)</span>
        <span class="s1">.arg(</span><span class="s6">&quot;BatchId&quot;</span><span class="s2">, </span><span class="s1">batchId)</span>
        <span class="s1">.flush()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(UIManagerModuleListener listener : mListeners) {</span>
      <span class="s1">listener.willDispatchViewUpdates(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(UIManagerListener listener : mUIManagerListeners) {</span>
      <span class="s1">listener.willDispatchViewUpdates(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">mUIImplementation.dispatchViewUpdates(batchId)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">Systrace.endSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setViewHierarchyUpdateDebugListener(</span>
      <span class="s1">@Nullable NotThreadSafeViewHierarchyUpdateDebugListener listener) {</span>
    <span class="s1">mUIImplementation.setViewHierarchyUpdateDebugListener(listener)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">EventDispatcher getEventDispatcher() {</span>
    <span class="s2">return </span><span class="s1">mEventDispatcher</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">sendAccessibilityEvent(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, int </span><span class="s1">eventType) {</span>
    <span class="s2">int </span><span class="s1">uiManagerType = ViewUtil.getUIManagerType(tag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(uiManagerType == FABRIC) {</span>
      <span class="s0">// TODO: T65793557 Refactor sendAccessibilityEvent to use ViewCommands</span>
      <span class="s1">UIManager fabricUIManager =</span>
          <span class="s1">UIManagerHelper.getUIManager(getReactApplicationContext()</span><span class="s2">, </span><span class="s1">uiManagerType)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(fabricUIManager != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">fabricUIManager.sendAccessibilityEvent(tag</span><span class="s2">, </span><span class="s1">eventType)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">mUIImplementation.sendAccessibilityEvent(tag</span><span class="s2">, </span><span class="s1">eventType)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Schedule a block to be executed on the UI thread. Useful if you need to execute view logic</span>
   <span class="s3">* after all currently queued view updates have completed.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">block that contains UI logic you want to execute.</span>
   <span class="s3">*     </span><span class="s4">&lt;p&gt;</span><span class="s3">Usage Example:</span>
   <span class="s3">*     </span><span class="s4">&lt;p&gt;</span><span class="s3">UIManagerModule uiManager = reactContext.getNativeModule(UIManagerModule.class);</span>
   <span class="s3">*     uiManager.addUIBlock(new UIBlock() { public void execute (NativeViewHierarchyManager nvhm)</span>
   <span class="s3">*     { View view = nvhm.resolveView(tag); // ...execute your code on View (e.g. snapshot the</span>
   <span class="s3">*     view) } });</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">addUIBlock(UIBlock block) {</span>
    <span class="s1">mUIImplementation.addUIBlock(block)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Schedule a block to be executed on the UI thread. Useful if you need to execute view logic</span>
   <span class="s3">* before all currently queued view updates have completed.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">block that contains UI logic you want to execute.</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">prependUIBlock(UIBlock block) {</span>
    <span class="s1">mUIImplementation.prependUIBlock(block)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Deprecated</span>
  <span class="s2">public void </span><span class="s1">addUIManagerListener(UIManagerModuleListener listener) {</span>
    <span class="s1">mListeners.add(listener)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Deprecated</span>
  <span class="s2">public void </span><span class="s1">removeUIManagerListener(UIManagerModuleListener listener) {</span>
    <span class="s1">mListeners.remove(listener)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">addUIManagerEventListener(UIManagerListener listener) {</span>
    <span class="s1">mUIManagerListeners.add(listener)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">removeUIManagerEventListener(UIManagerListener listener) {</span>
    <span class="s1">mUIManagerListeners.remove(listener)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Given a reactTag from a component, find its root node tag, if possible. Otherwise, this will</span>
   <span class="s3">* return 0. If the reactTag belongs to a root node, this will return the same reactTag.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">this method is not going to be supported in the near future, use {</span><span class="s5">@link</span>
   <span class="s3">*     ViewUtil#isRootTag(int)} to verify if a react Tag is a root or not</span>
   <span class="s3">*     </span><span class="s4">&lt;p&gt;</span><span class="s3">TODO: T63569137 Delete the method UIManagerModule.resolveRootTagFromReactTag</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">reactTag the component tag</span>
   <span class="s3">* </span><span class="s5">@return </span><span class="s3">the rootTag</span>
   <span class="s3">*/</span>
  <span class="s1">@Deprecated</span>
  <span class="s2">public int </span><span class="s1">resolveRootTagFromReactTag(</span><span class="s2">int </span><span class="s1">reactTag) {</span>
    <span class="s2">return </span><span class="s1">ViewUtil.isRootTag(reactTag)</span>
        <span class="s1">? reactTag</span>
        <span class="s1">: mUIImplementation.resolveRootTagFromReactTag(reactTag)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Dirties the node associated with the given react tag */</span>
  <span class="s2">public void </span><span class="s1">invalidateNodeLayout(</span><span class="s2">int </span><span class="s1">tag) {</span>
    <span class="s1">ReactShadowNode node = mUIImplementation.resolveShadowNode(tag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(node == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">FLog.w(</span>
          <span class="s1">ReactConstants.TAG</span><span class="s2">,</span>
          <span class="s6">&quot;Warning : attempted to dirty a non-existent react shadow node. reactTag=&quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">node.dirty()</span><span class="s2">;</span>
    <span class="s1">mUIImplementation.dispatchViewUpdates(-</span><span class="s7">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Updates the styles of the {</span><span class="s5">@link </span><span class="s3">ReactShadowNode} based on the Measure specs received by</span>
   <span class="s3">* parameters. offsetX and offsetY aren't used in non-Fabric, so they're ignored here.</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">updateRootLayoutSpecs(</span>
      <span class="s2">final int </span><span class="s1">rootViewTag</span><span class="s2">,</span>
      <span class="s2">final int </span><span class="s1">widthMeasureSpec</span><span class="s2">,</span>
      <span class="s2">final int </span><span class="s1">heightMeasureSpec</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">offsetX</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">offsetY) {</span>
    <span class="s1">ReactApplicationContext reactApplicationContext = getReactApplicationContext()</span><span class="s2">;</span>
    <span class="s1">reactApplicationContext.runOnNativeModulesQueueThread(</span>
        <span class="s2">new </span><span class="s1">GuardedRunnable(reactApplicationContext) {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">runGuarded() {</span>
            <span class="s1">mUIImplementation.updateRootView(rootViewTag</span><span class="s2">, </span><span class="s1">widthMeasureSpec</span><span class="s2">, </span><span class="s1">heightMeasureSpec)</span><span class="s2">;</span>
            <span class="s1">mUIImplementation.dispatchViewUpdates(-</span><span class="s7">1</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Listener that drops the CSSNode pool on low memory when the app is backgrounded. */</span>
  <span class="s2">private static class </span><span class="s1">MemoryTrimCallback </span><span class="s2">implements </span><span class="s1">ComponentCallbacks2 {</span>

    <span class="s1">@Override</span>
    <span class="s2">public void </span><span class="s1">onTrimMemory(</span><span class="s2">int </span><span class="s1">level) {</span>
      <span class="s2">if </span><span class="s1">(level &gt;= TRIM_MEMORY_MODERATE) {</span>
        <span class="s1">YogaNodePool.get().clear()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s2">public void </span><span class="s1">onConfigurationChanged(Configuration newConfig) {}</span>

    <span class="s1">@Override</span>
    <span class="s2">public void </span><span class="s1">onLowMemory() {}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">View resolveView(</span><span class="s2">int </span><span class="s1">tag) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">mUIImplementation</span>
        <span class="s1">.getUIViewOperationQueue()</span>
        <span class="s1">.getNativeViewHierarchyManager()</span>
        <span class="s1">.resolveView(tag)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">receiveEvent(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">String eventName</span><span class="s2">, </span><span class="s1">@Nullable WritableMap event) {</span>
    <span class="s1">receiveEvent(-</span><span class="s7">1</span><span class="s2">, </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">eventName</span><span class="s2">, </span><span class="s1">event)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">receiveEvent(</span>
      <span class="s2">int </span><span class="s1">surfaceId</span><span class="s2">, int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">String eventName</span><span class="s2">, </span><span class="s1">@Nullable WritableMap event) {</span>
    <span class="s2">assert </span><span class="s1">ViewUtil.getUIManagerType(reactTag) == DEFAULT</span><span class="s2">;</span>
    <span class="s1">getReactApplicationContext()</span>
        <span class="s1">.getJSModule(RCTEventEmitter.</span><span class="s2">class</span><span class="s1">)</span>
        <span class="s1">.receiveEvent(reactTag</span><span class="s2">, </span><span class="s1">eventName</span><span class="s2">, </span><span class="s1">event)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
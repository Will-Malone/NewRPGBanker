<html>
<head>
<title>GestureHandlerOrchestrator.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
GestureHandlerOrchestrator.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;GestureHandlerOrchestrator.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;GestureHandlerOrchestrator&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;scheduleFinishedHandlersCleanup&quot;</span><span class="s0">,</span><span class="s1">&quot;handlingChangeSemaphore&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanupFinishedHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;reset&quot;</span><span class="s0">,</span><span class="s1">&quot;setActive&quot;</span><span class="s0">,</span><span class="s1">&quot;setAwaiting&quot;</span><span class="s0">,</span><span class="s1">&quot;setActivationIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;MAX_VALUE&quot;</span><span class="s0">,</span><span class="s1">&quot;removeHandlerFromOrchestrator&quot;</span><span class="s0">,</span><span class="s1">&quot;gestureHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;awaitingHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;handlersToCancel&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;isFinished&quot;</span><span class="s0">,</span><span class="s1">&quot;getState&quot;</span><span class="s0">,</span><span class="s1">&quot;isAwaiting&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOtherHandlerToWaitFor&quot;</span><span class="s0">,</span><span class="s1">&quot;hasToWait&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;otherHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldHandlerWaitForOther&quot;</span><span class="s0">,</span><span class="s1">&quot;tryActivate&quot;</span><span class="s0">,</span><span class="s1">&quot;addAwaitingHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;State&quot;</span><span class="s0">,</span><span class="s1">&quot;CANCELLED&quot;</span><span class="s0">,</span><span class="s1">&quot;FAILED&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldActivate&quot;</span><span class="s0">,</span><span class="s1">&quot;makeActive&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTIVE&quot;</span><span class="s0">,</span><span class="s1">&quot;fail&quot;</span><span class="s0">,</span><span class="s1">&quot;BEGAN&quot;</span><span class="s0">,</span><span class="s1">&quot;cancel&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldHandlerBeCancelledBy&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanupAwaitingHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;onHandlerStateChange&quot;</span><span class="s0">,</span><span class="s1">&quot;newState&quot;</span><span class="s0">,</span><span class="s1">&quot;oldState&quot;</span><span class="s0">,</span><span class="s1">&quot;sendIfDisabled&quot;</span><span class="s0">,</span><span class="s1">&quot;isEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;END&quot;</span><span class="s0">,</span><span class="s1">&quot;sendEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;isActive&quot;</span><span class="s0">,</span><span class="s1">&quot;UNDETERMINED&quot;</span><span class="s0">,</span><span class="s1">&quot;currentState&quot;</span><span class="s0">,</span><span class="s1">&quot;setShouldResetProgress&quot;</span><span class="s0">,</span><span class="s1">&quot;activationIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;alreadyExists&quot;</span><span class="s0">,</span><span class="s1">&quot;recordHandlerIfNotPresent&quot;</span><span class="s0">,</span><span class="s1">&quot;MAX_SAFE_INTEGER&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldWaitForHandlerFailure&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldRequireToWaitForFailure&quot;</span><span class="s0">,</span><span class="s1">&quot;canRunSimultaneously&quot;</span><span class="s0">,</span><span class="s1">&quot;gh1&quot;</span><span class="s0">,</span><span class="s1">&quot;gh2&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldRecognizeSimultaneously&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldBeCancelledByOther&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerPointers&quot;</span><span class="s0">,</span><span class="s1">&quot;getTrackedPointersID&quot;</span><span class="s0">,</span><span class="s1">&quot;otherPointers&quot;</span><span class="s0">,</span><span class="s1">&quot;PointerTracker&quot;</span><span class="s0">,</span><span class="s1">&quot;shareCommonPointers&quot;</span><span class="s0">,</span><span class="s1">&quot;getView&quot;</span><span class="s0">,</span><span class="s1">&quot;checkOverlap&quot;</span><span class="s0">,</span><span class="s1">&quot;overlap&quot;</span><span class="s0">,</span><span class="s1">&quot;pointer&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerX&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracker&quot;</span><span class="s0">,</span><span class="s1">&quot;getLastX&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerY&quot;</span><span class="s0">,</span><span class="s1">&quot;getLastY&quot;</span><span class="s0">,</span><span class="s1">&quot;x&quot;</span><span class="s0">,</span><span class="s1">&quot;y&quot;</span><span class="s0">,</span><span class="s1">&quot;otherX&quot;</span><span class="s0">,</span><span class="s1">&quot;otherY&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;cancelMouseAndPenGestures&quot;</span><span class="s0">,</span><span class="s1">&quot;currentHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;getPointerType&quot;</span><span class="s0">,</span><span class="s1">&quot;PointerType&quot;</span><span class="s0">,</span><span class="s1">&quot;MOUSE&quot;</span><span class="s0">,</span><span class="s1">&quot;PEN&quot;</span><span class="s0">,</span><span class="s1">&quot;resetTracker&quot;</span><span class="s0">,</span><span class="s1">&quot;getInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;instance&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { State } from '../../State';</span><span class="s3">\n</span><span class="s1">import { PointerType } from '../interfaces';</span><span class="s3">\n\n</span><span class="s1">import GestureHandler from '../handlers/GestureHandler';</span><span class="s3">\n</span><span class="s1">import PointerTracker from './PointerTracker';</span><span class="s3">\n</span><span class="s1">import { isPointerInBounds } from '../utils';</span><span class="s3">\n\n</span><span class="s1">export default class GestureHandlerOrchestrator {</span><span class="s3">\n  </span><span class="s1">private static instance: GestureHandlerOrchestrator;</span><span class="s3">\n\n  </span><span class="s1">private gestureHandlers: GestureHandler[] = [];</span><span class="s3">\n  </span><span class="s1">private awaitingHandlers: GestureHandler[] = [];</span><span class="s3">\n  </span><span class="s1">private handlersToCancel: GestureHandler[] = [];</span><span class="s3">\n\n  </span><span class="s1">private handlingChangeSemaphore = 0;</span><span class="s3">\n  </span><span class="s1">private activationIndex = 0;</span><span class="s3">\n\n  </span><span class="s1">// Private beacuse of Singleton</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function</span><span class="s3">\n  </span><span class="s1">private constructor() {}</span><span class="s3">\n\n  </span><span class="s1">private scheduleFinishedHandlersCleanup(): void {</span><span class="s3">\n    </span><span class="s1">if (this.handlingChangeSemaphore === 0) {</span><span class="s3">\n      </span><span class="s1">this.cleanupFinishedHandlers();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private cleanHandler(handler: GestureHandler): void {</span><span class="s3">\n    </span><span class="s1">handler.reset();</span><span class="s3">\n    </span><span class="s1">handler.setActive(false);</span><span class="s3">\n    </span><span class="s1">handler.setAwaiting(false);</span><span class="s3">\n    </span><span class="s1">handler.setActivationIndex(Number.MAX_VALUE);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public removeHandlerFromOrchestrator(handler: GestureHandler): void {</span><span class="s3">\n    </span><span class="s1">this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler), 1);</span><span class="s3">\n    </span><span class="s1">this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler), 1);</span><span class="s3">\n    </span><span class="s1">this.handlersToCancel.splice(this.handlersToCancel.indexOf(handler), 1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private cleanupFinishedHandlers(): void {</span><span class="s3">\n    </span><span class="s1">for (let i = this.gestureHandlers.length - 1; i &gt;= 0; --i) {</span><span class="s3">\n      </span><span class="s1">const handler = this.gestureHandlers[i];</span><span class="s3">\n\n      </span><span class="s1">if (!handler) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (this.isFinished(handler.getState()) &amp;&amp; !handler.isAwaiting()) {</span><span class="s3">\n        </span><span class="s1">this.gestureHandlers.splice(i, 1);</span><span class="s3">\n\n        </span><span class="s1">this.cleanHandler(handler);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private hasOtherHandlerToWaitFor(handler: GestureHandler): boolean {</span><span class="s3">\n    </span><span class="s1">let hasToWait = false;</span><span class="s3">\n    </span><span class="s1">this.gestureHandlers.forEach((otherHandler) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">otherHandler &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!this.isFinished(otherHandler.getState()) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">this.shouldHandlerWaitForOther(handler, otherHandler)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">hasToWait = true;</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">return hasToWait;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private tryActivate(handler: GestureHandler): void {</span><span class="s3">\n    </span><span class="s1">if (this.hasOtherHandlerToWaitFor(handler)) {</span><span class="s3">\n      </span><span class="s1">this.addAwaitingHandler(handler);</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">handler.getState() !== State.CANCELLED &amp;&amp;</span><span class="s3">\n      </span><span class="s1">handler.getState() !== State.FAILED</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (this.shouldActivate(handler)) {</span><span class="s3">\n        </span><span class="s1">this.makeActive(handler);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">switch (handler.getState()) {</span><span class="s3">\n          </span><span class="s1">case State.ACTIVE:</span><span class="s3">\n            </span><span class="s1">handler.fail();</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case State.BEGAN:</span><span class="s3">\n            </span><span class="s1">handler.cancel();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private shouldActivate(handler: GestureHandler): boolean {</span><span class="s3">\n    </span><span class="s1">for (const otherHandler of this.gestureHandlers) {</span><span class="s3">\n      </span><span class="s1">if (this.shouldHandlerBeCancelledBy(handler, otherHandler)) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private cleanupAwaitingHandlers(handler: GestureHandler): void {</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; this.awaitingHandlers.length; ++i) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!this.awaitingHandlers[i].isAwaiting() &amp;&amp;</span><span class="s3">\n        </span><span class="s1">this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">this.cleanHandler(this.awaitingHandlers[i]);</span><span class="s3">\n        </span><span class="s1">this.awaitingHandlers.splice(i, 1);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public onHandlerStateChange(</span><span class="s3">\n    </span><span class="s1">handler: GestureHandler,</span><span class="s3">\n    </span><span class="s1">newState: State,</span><span class="s3">\n    </span><span class="s1">oldState: State,</span><span class="s3">\n    </span><span class="s1">sendIfDisabled?: boolean</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">if (!handler.isEnabled() &amp;&amp; !sendIfDisabled) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.handlingChangeSemaphore += 1;</span><span class="s3">\n\n    </span><span class="s1">if (this.isFinished(newState)) {</span><span class="s3">\n      </span><span class="s1">this.awaitingHandlers.forEach((otherHandler) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (this.shouldHandlerWaitForOther(otherHandler, handler)) {</span><span class="s3">\n          </span><span class="s1">if (newState === State.END) {</span><span class="s3">\n            </span><span class="s1">otherHandler?.cancel();</span><span class="s3">\n            </span><span class="s1">if (otherHandler.getState() === State.END) {</span><span class="s3">\n              </span><span class="s1">// Handle edge case, where discrete gestures end immediately after activation thus</span><span class="s3">\n              </span><span class="s1">// their state is set to END and when the gesture they are waiting for activates they</span><span class="s3">\n              </span><span class="s1">// should be cancelled, however `cancel` was never sent as gestures were already in the END state.</span><span class="s3">\n              </span><span class="s1">// Send synthetic BEGAN -&gt; CANCELLED to properly handle JS logic</span><span class="s3">\n              </span><span class="s1">otherHandler.sendEvent(State.CANCELLED, State.BEGAN);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">otherHandler?.setAwaiting(false);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">this.tryActivate(otherHandler);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (newState === State.ACTIVE) {</span><span class="s3">\n      </span><span class="s1">this.tryActivate(handler);</span><span class="s3">\n    </span><span class="s1">} else if (oldState === State.ACTIVE || oldState === State.END) {</span><span class="s3">\n      </span><span class="s1">if (handler.isActive()) {</span><span class="s3">\n        </span><span class="s1">handler.sendEvent(newState, oldState);</span><span class="s3">\n      </span><span class="s1">} else if (</span><span class="s3">\n        </span><span class="s1">oldState === State.ACTIVE &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(newState === State.CANCELLED || newState === State.FAILED)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">handler.sendEvent(newState, State.BEGAN);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">oldState !== State.UNDETERMINED ||</span><span class="s3">\n      </span><span class="s1">newState !== State.CANCELLED</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">handler.sendEvent(newState, oldState);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.handlingChangeSemaphore -= 1;</span><span class="s3">\n\n    </span><span class="s1">this.scheduleFinishedHandlersCleanup();</span><span class="s3">\n\n    </span><span class="s1">if (this.awaitingHandlers.indexOf(handler) &lt; 0) {</span><span class="s3">\n      </span><span class="s1">this.cleanupAwaitingHandlers(handler);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private makeActive(handler: GestureHandler): void {</span><span class="s3">\n    </span><span class="s1">const currentState = handler.getState();</span><span class="s3">\n\n    </span><span class="s1">handler.setActive(true);</span><span class="s3">\n    </span><span class="s1">handler.setShouldResetProgress(true);</span><span class="s3">\n    </span><span class="s1">handler.setActivationIndex(this.activationIndex++);</span><span class="s3">\n\n    </span><span class="s1">this.gestureHandlers.forEach((otherHandler) =&gt; {</span><span class="s3">\n      </span><span class="s1">// Order of arguments is correct - we check whether current handler should cancel existing handlers</span><span class="s3">\n\n      </span><span class="s1">if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {</span><span class="s3">\n        </span><span class="s1">this.handlersToCancel.push(otherHandler);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">for (let i = this.handlersToCancel.length - 1; i &gt;= 0; --i) {</span><span class="s3">\n      </span><span class="s1">this.handlersToCancel[i]?.cancel();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.awaitingHandlers.forEach((otherHandler) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {</span><span class="s3">\n        </span><span class="s1">otherHandler?.cancel();</span><span class="s3">\n        </span><span class="s1">otherHandler?.setAwaiting(true);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">handler.sendEvent(State.ACTIVE, State.BEGAN);</span><span class="s3">\n\n    </span><span class="s1">if (currentState !== State.ACTIVE) {</span><span class="s3">\n      </span><span class="s1">handler.sendEvent(State.END, State.ACTIVE);</span><span class="s3">\n      </span><span class="s1">if (currentState !== State.END) {</span><span class="s3">\n        </span><span class="s1">handler.sendEvent(State.UNDETERMINED, State.END);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (handler.isAwaiting()) {</span><span class="s3">\n      </span><span class="s1">handler.setAwaiting(false);</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; this.awaitingHandlers.length; ++i) {</span><span class="s3">\n        </span><span class="s1">if (this.awaitingHandlers[i] === handler) {</span><span class="s3">\n          </span><span class="s1">this.awaitingHandlers.splice(i, 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.handlersToCancel = [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private addAwaitingHandler(handler: GestureHandler): void {</span><span class="s3">\n    </span><span class="s1">let alreadyExists = false;</span><span class="s3">\n\n    </span><span class="s1">this.awaitingHandlers.forEach((otherHandler) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (otherHandler === handler) {</span><span class="s3">\n        </span><span class="s1">alreadyExists = true;</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">if (alreadyExists) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.awaitingHandlers.push(handler);</span><span class="s3">\n\n    </span><span class="s1">handler.setAwaiting(true);</span><span class="s3">\n    </span><span class="s1">handler.setActivationIndex(this.activationIndex++);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public recordHandlerIfNotPresent(handler: GestureHandler): void {</span><span class="s3">\n    </span><span class="s1">let alreadyExists = false;</span><span class="s3">\n\n    </span><span class="s1">this.gestureHandlers.forEach((otherHandler) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (otherHandler === handler) {</span><span class="s3">\n        </span><span class="s1">alreadyExists = true;</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">if (alreadyExists) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.gestureHandlers.push(handler);</span><span class="s3">\n\n    </span><span class="s1">handler.setActive(false);</span><span class="s3">\n    </span><span class="s1">handler.setAwaiting(false);</span><span class="s3">\n    </span><span class="s1">handler.setActivationIndex(Number.MAX_SAFE_INTEGER);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private shouldHandlerWaitForOther(</span><span class="s3">\n    </span><span class="s1">handler: GestureHandler,</span><span class="s3">\n    </span><span class="s1">otherHandler: GestureHandler</span><span class="s3">\n  </span><span class="s1">): boolean {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">handler !== otherHandler &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(handler.shouldWaitForHandlerFailure(otherHandler) ||</span><span class="s3">\n        </span><span class="s1">otherHandler.shouldRequireToWaitForFailure(handler))</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private canRunSimultaneously(</span><span class="s3">\n    </span><span class="s1">gh1: GestureHandler,</span><span class="s3">\n    </span><span class="s1">gh2: GestureHandler</span><span class="s3">\n  </span><span class="s1">): boolean {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">gh1 === gh2 ||</span><span class="s3">\n      </span><span class="s1">gh1.shouldRecognizeSimultaneously(gh2) ||</span><span class="s3">\n      </span><span class="s1">gh2.shouldRecognizeSimultaneously(gh1)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private shouldHandlerBeCancelledBy(</span><span class="s3">\n    </span><span class="s1">handler: GestureHandler,</span><span class="s3">\n    </span><span class="s1">otherHandler: GestureHandler</span><span class="s3">\n  </span><span class="s1">): boolean {</span><span class="s3">\n    </span><span class="s1">if (this.canRunSimultaneously(handler, otherHandler)) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">handler !== otherHandler &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(handler.isAwaiting() || handler.getState() === State.ACTIVE)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// For now it always returns false</span><span class="s3">\n      </span><span class="s1">return handler.shouldBeCancelledByOther(otherHandler);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const handlerPointers: number[] = handler.getTrackedPointersID();</span><span class="s3">\n    </span><span class="s1">const otherPointers: number[] = otherHandler.getTrackedPointersID();</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">handler.getView() !== otherHandler.getView()</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return this.checkOverlap(handler, otherHandler);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private checkOverlap(</span><span class="s3">\n    </span><span class="s1">handler: GestureHandler,</span><span class="s3">\n    </span><span class="s1">otherHandler: GestureHandler</span><span class="s3">\n  </span><span class="s1">): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    let overlap = false;\n\n    handlerPointers.forEach((pointer: number) =&gt; {\n      const handlerX: number = handler.getTracker().getLastX(pointer);\n      const handlerY: number = handler.getTracker().getLastY(pointer);\n\n      if (\n        isPointerInBounds(handler.getView(), { x: handlerX, y: handlerY }) &amp;&amp;\n        isPointerInBounds(otherHandler.getView(), { x: handlerX, y: handlerY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    otherPointers.forEach((pointer: number) =&gt; {\n      const otherX: number = otherHandler.getTracker().getLastX(pointer);\n      const otherY: number = otherHandler.getTracker().getLastY(pointer);\n\n      if (\n        isPointerInBounds(handler.getView(), { x: otherX, y: otherY }) &amp;&amp;\n        isPointerInBounds(otherHandler.getView(), { x: otherX, y: otherY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    return overlap;\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  // This function is called when handler receives touchdown event\n  // If handler is using mouse or pen as a pointer and any handler receives touch event,\n  // mouse/pen event dissappears - it doesn't send onPointerCancel nor onPointerUp (and others)\n  // This became a problem because handler was left at active state without any signal to end or fail\n  // To handle this, when new touch event is received, we loop through active handlers and check which type of\n  // pointer they're using. If there are any handler with mouse/pen as a pointer, we cancel them\n  public cancelMouseAndPenGestures(currentHandler: GestureHandler): void {\n    this.gestureHandlers.forEach((handler: GestureHandler) =&gt; {\n      if (\n        handler.getPointerType() !== PointerType.MOUSE &amp;&amp;\n        handler.getPointerType() !== PointerType.PEN\n      ) {\n        return;\n      }\n\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        // Handler that received touch event should have its pointer tracker reset\n        // This allows handler to smoothly change from mouse/pen to touch\n        // The drawback is, that when we try to use mouse/pen one more time, it doesn't send onPointerDown at the first time\n        // so it is required to click two times to get handler to work\n        //\n        // However, handler will receive manually created onPointerEnter that is triggered in EventManager in onPointerMove method.\n        // There may be possibility to use that fact to make handler respond properly to first mouse click\n        handler.getTracker().resetTracker();\n      }\n    });\n  }\n\n  public static getInstance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator.instance) {\n      GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n    }\n\n    return GestureHandlerOrchestrator.instance;\n  }\n}\n&quot;]}</span></pre>
</body>
</html>
<html>
<head>
<title>Server.js.flow</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Server.js.flow</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Copyright (c) Meta Platforms, Inc. and affiliates.</span>
 <span class="s0">*</span>
 <span class="s0">* This source code is licensed under the MIT license found in the</span>
 <span class="s0">* LICENSE file in the root directory of this source tree.</span>
 <span class="s0">*</span>
 <span class="s0">* @flow</span>
 <span class="s0">* @format</span>
 <span class="s0">* @oncall react_native</span>
 <span class="s0">*/</span>

<span class="s0">'use strict';</span>

<span class="s0">import type {StackFrameOutput} from './Server/symbolicate';</span>
<span class="s0">import type {AssetData} from './Assets';</span>
<span class="s0">import type {ExplodedSourceMap} from './DeltaBundler/Serializers/getExplodedSourceMap';</span>
<span class="s0">import type {RamBundleInfo} from './DeltaBundler/Serializers/getRamBundleInfo';</span>
<span class="s0">import type {</span>
  <span class="s0">MixedOutput,</span>
  <span class="s0">Module,</span>
  <span class="s0">ReadOnlyGraph,</span>
  <span class="s0">TransformInputOptions,</span>
  <span class="s0">TransformResult,</span>
<span class="s0">} from './DeltaBundler/types.flow';</span>
<span class="s0">import type {RevisionId} from './IncrementalBundler';</span>
<span class="s0">import type {GraphId} from './lib/getGraphId';</span>
<span class="s0">import type {Reporter} from './lib/reporting';</span>
<span class="s0">import type {</span>
  <span class="s0">BundleOptions,</span>
  <span class="s0">GraphOptions,</span>
  <span class="s0">ResolverInputOptions,</span>
  <span class="s0">SplitBundleOptions,</span>
<span class="s0">} from './shared/types.flow';</span>
<span class="s0">import type {IncomingMessage} from 'connect';</span>
<span class="s0">import type {ServerResponse} from 'http';</span>
<span class="s0">import type {CacheStore} from 'metro-cache';</span>
<span class="s0">import type {ConfigT, RootPerfLogger} from 'metro-config/src/configTypes.flow';</span>
<span class="s0">import type {</span>
  <span class="s0">ActionLogEntryData,</span>
  <span class="s0">ActionStartLogEntry,</span>
  <span class="s0">LogEntry,</span>
<span class="s0">} from 'metro-core/src/Logger';</span>
<span class="s0">import type {CustomResolverOptions} from 'metro-resolver/src/types';</span>
<span class="s0">import type {CustomTransformOptions} from 'metro-transform-worker';</span>

<span class="s0">const {getAsset} = require('./Assets');</span>
<span class="s0">const baseJSBundle = require('./DeltaBundler/Serializers/baseJSBundle');</span>
<span class="s0">const getAllFiles = require('./DeltaBundler/Serializers/getAllFiles');</span>
<span class="s0">const getAssets = require('./DeltaBundler/Serializers/getAssets');</span>
<span class="s0">const {</span>
  <span class="s0">getExplodedSourceMap,</span>
<span class="s0">} = require('./DeltaBundler/Serializers/getExplodedSourceMap');</span>
<span class="s0">const getRamBundleInfo = require('./DeltaBundler/Serializers/getRamBundleInfo');</span>
<span class="s0">const sourceMapString = require('./DeltaBundler/Serializers/sourceMapString');</span>
<span class="s0">const IncrementalBundler = require('./IncrementalBundler');</span>
<span class="s0">const ResourceNotFoundError = require('./IncrementalBundler/ResourceNotFoundError');</span>
<span class="s0">const bundleToString = require('./lib/bundleToString');</span>
<span class="s0">const formatBundlingError = require('./lib/formatBundlingError');</span>
<span class="s0">const getGraphId = require('./lib/getGraphId');</span>
<span class="s0">const parseOptionsFromUrl = require('./lib/parseOptionsFromUrl');</span>
<span class="s0">const splitBundleOptions = require('./lib/splitBundleOptions');</span>
<span class="s0">const transformHelpers = require('./lib/transformHelpers');</span>
<span class="s0">const parsePlatformFilePath = require('./node-haste/lib/parsePlatformFilePath');</span>
<span class="s0">const symbolicate = require('./Server/symbolicate');</span>
<span class="s0">const {codeFrameColumns} = require('@babel/code-frame');</span>
<span class="s0">const MultipartResponse = require('./Server/MultipartResponse');</span>
<span class="s0">const debug = require('debug')('Metro:Server');</span>
<span class="s0">const fs = require('graceful-fs');</span>
<span class="s0">const invariant = require('invariant');</span>
<span class="s0">const jscSafeUrl = require('jsc-safe-url');</span>
<span class="s0">const {</span>
  <span class="s0">Logger,</span>
  <span class="s0">Logger: {createActionStartEntry, createActionEndEntry, log},</span>
<span class="s0">} = require('metro-core');</span>

<span class="s0">const mime = require('mime-types');</span>
<span class="s0">const nullthrows = require('nullthrows');</span>
<span class="s0">const path = require('path');</span>
<span class="s0">const querystring = require('querystring');</span>
<span class="s0">const url = require('url');</span>

<span class="s0">const noopLogger: RootPerfLogger = {</span>
  <span class="s0">start: () =&gt; {},</span>
  <span class="s0">point: () =&gt; {},</span>
  <span class="s0">annotate: () =&gt; {},</span>
  <span class="s0">subSpan: () =&gt; noopLogger,</span>
  <span class="s0">end: () =&gt; {},</span>
<span class="s0">};</span>

<span class="s0">export type SegmentLoadData = {[number]: [Array&lt;number&gt;, ?number], ...};</span>
<span class="s0">export type BundleMetadata = {</span>
  <span class="s0">hash: string,</span>
  <span class="s0">otaBuildNumber: ?string,</span>
  <span class="s0">mobileConfigs: Array&lt;string&gt;,</span>
  <span class="s0">segmentHashes: Array&lt;string&gt;,</span>
  <span class="s0">segmentLoadData: SegmentLoadData,</span>
  <span class="s0">...</span>
<span class="s0">};</span>

<span class="s0">type ProcessStartContext = {</span>
  <span class="s0">+buildNumber: number,</span>
  <span class="s0">+bundleOptions: BundleOptions,</span>
  <span class="s0">+graphId: GraphId,</span>
  <span class="s0">+graphOptions: GraphOptions,</span>
  <span class="s0">+mres: MultipartResponse | ServerResponse,</span>
  <span class="s0">+req: IncomingMessage,</span>
  <span class="s0">+revisionId?: ?RevisionId,</span>
  <span class="s0">+bundlePerfLogger: RootPerfLogger,</span>
  <span class="s0">...SplitBundleOptions,</span>
<span class="s0">};</span>

<span class="s0">type ProcessDeleteContext = {</span>
  <span class="s0">+graphId: GraphId,</span>
  <span class="s0">+req: IncomingMessage,</span>
  <span class="s0">+res: ServerResponse,</span>
<span class="s0">};</span>

<span class="s0">type ProcessEndContext&lt;T&gt; = {</span>
  <span class="s0">...ProcessStartContext,</span>
  <span class="s0">+result: T,</span>
<span class="s0">};</span>

<span class="s0">export type ServerOptions = $ReadOnly&lt;{</span>
  <span class="s0">hasReducedPerformance?: boolean,</span>
  <span class="s0">onBundleBuilt?: (bundlePath: string) =&gt; void,</span>
  <span class="s0">watch?: boolean,</span>
<span class="s0">}&gt;;</span>

<span class="s0">const DELTA_ID_HEADER = 'X-Metro-Delta-ID';</span>
<span class="s0">const FILES_CHANGED_COUNT_HEADER = 'X-Metro-Files-Changed-Count';</span>

<span class="s0">class Server {</span>
  <span class="s0">_bundler: IncrementalBundler;</span>
  <span class="s0">_config: ConfigT;</span>
  <span class="s0">_createModuleId: (path: string) =&gt; number;</span>
  <span class="s0">_isEnded: boolean;</span>
  <span class="s0">_logger: typeof Logger;</span>
  <span class="s0">_nextBundleBuildNumber: number;</span>
  <span class="s0">_platforms: Set&lt;string&gt;;</span>
  <span class="s0">_reporter: Reporter;</span>
  <span class="s0">_serverOptions: ServerOptions | void;</span>

  <span class="s0">constructor(config: ConfigT, options?: ServerOptions) {</span>
    <span class="s0">this._config = config;</span>
    <span class="s0">this._serverOptions = options;</span>

    <span class="s0">if (this._config.resetCache) {</span>
      <span class="s0">this._config.cacheStores.forEach((store: CacheStore&lt;TransformResult&lt;&gt;&gt;) =&gt;</span>
        <span class="s0">store.clear(),</span>
      <span class="s0">);</span>
      <span class="s0">this._config.reporter.update({type: 'transform_cache_reset'});</span>
    <span class="s0">}</span>

    <span class="s0">this._reporter = config.reporter;</span>
    <span class="s0">this._logger = Logger;</span>
    <span class="s0">this._platforms = new Set(this._config.resolver.platforms);</span>
    <span class="s0">this._isEnded = false;</span>

    <span class="s0">// TODO(T34760917): These two properties should eventually be instantiated</span>
    <span class="s0">// elsewhere and passed as parameters, since they are also needed by</span>
    <span class="s0">// the HmrServer.</span>
    <span class="s0">// The whole bundling/serializing logic should follow as well.</span>
    <span class="s0">this._createModuleId = config.serializer.createModuleIdFactory();</span>
    <span class="s0">this._bundler = new IncrementalBundler(config, {</span>
      <span class="s0">hasReducedPerformance: options &amp;&amp; options.hasReducedPerformance,</span>
      <span class="s0">watch: options ? options.watch : undefined,</span>
    <span class="s0">});</span>
    <span class="s0">this._nextBundleBuildNumber = 1;</span>
  <span class="s0">}</span>

  <span class="s0">end() {</span>
    <span class="s0">if (!this._isEnded) {</span>
      <span class="s0">this._bundler.end();</span>
      <span class="s0">this._isEnded = true;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">getBundler(): IncrementalBundler {</span>
    <span class="s0">return this._bundler;</span>
  <span class="s0">}</span>

  <span class="s0">getCreateModuleId(): (path: string) =&gt; number {</span>
    <span class="s0">return this._createModuleId;</span>
  <span class="s0">}</span>

  <span class="s0">async build(options: BundleOptions): Promise&lt;{</span>
    <span class="s0">code: string,</span>
    <span class="s0">map: string,</span>
    <span class="s0">...</span>
  <span class="s0">}&gt; {</span>
    <span class="s0">const {</span>
      <span class="s0">entryFile,</span>
      <span class="s0">graphOptions,</span>
      <span class="s0">onProgress,</span>
      <span class="s0">resolverOptions,</span>
      <span class="s0">serializerOptions,</span>
      <span class="s0">transformOptions,</span>
    <span class="s0">} = splitBundleOptions(options);</span>

    <span class="s0">const {prepend, graph} = await this._bundler.buildGraph(</span>
      <span class="s0">entryFile,</span>
      <span class="s0">transformOptions,</span>
      <span class="s0">resolverOptions,</span>
      <span class="s0">{</span>
        <span class="s0">onProgress,</span>
        <span class="s0">shallow: graphOptions.shallow,</span>
        <span class="s0">lazy: graphOptions.lazy,</span>
      <span class="s0">},</span>
    <span class="s0">);</span>

    <span class="s0">const entryPoint = this._getEntryPointAbsolutePath(entryFile);</span>

    <span class="s0">const bundleOptions = {</span>
      <span class="s0">asyncRequireModulePath: await this._resolveRelativePath(</span>
        <span class="s0">this._config.transformer.asyncRequireModulePath,</span>
        <span class="s0">{</span>
          <span class="s0">relativeTo: 'project',</span>
          <span class="s0">resolverOptions,</span>
          <span class="s0">transformOptions,</span>
        <span class="s0">},</span>
      <span class="s0">),</span>
      <span class="s0">processModuleFilter: this._config.serializer.processModuleFilter,</span>
      <span class="s0">createModuleId: this._createModuleId,</span>
      <span class="s0">getRunModuleStatement: this._config.serializer.getRunModuleStatement,</span>
      <span class="s0">dev: transformOptions.dev,</span>
      <span class="s0">includeAsyncPaths: graphOptions.lazy,</span>
      <span class="s0">projectRoot: this._config.projectRoot,</span>
      <span class="s0">modulesOnly: serializerOptions.modulesOnly,</span>
      <span class="s0">runBeforeMainModule:</span>
        <span class="s0">this._config.serializer.getModulesRunBeforeMainModule(</span>
          <span class="s0">path.relative(this._config.projectRoot, entryPoint),</span>
        <span class="s0">),</span>
      <span class="s0">runModule: serializerOptions.runModule,</span>
      <span class="s0">sourceMapUrl: serializerOptions.sourceMapUrl,</span>
      <span class="s0">sourceUrl: serializerOptions.sourceUrl,</span>
      <span class="s0">inlineSourceMap: serializerOptions.inlineSourceMap,</span>
      <span class="s0">serverRoot:</span>
        <span class="s0">this._config.server.unstable_serverRoot ?? this._config.projectRoot,</span>
      <span class="s0">shouldAddToIgnoreList: (module: Module&lt;&gt;) =&gt;</span>
        <span class="s0">this._shouldAddModuleToIgnoreList(module),</span>
    <span class="s0">};</span>
    <span class="s0">let bundleCode = null;</span>
    <span class="s0">let bundleMap = null;</span>
    <span class="s0">if (this._config.serializer.customSerializer) {</span>
      <span class="s0">const bundle = await this._config.serializer.customSerializer(</span>
        <span class="s0">entryPoint,</span>
        <span class="s0">prepend,</span>
        <span class="s0">graph,</span>
        <span class="s0">bundleOptions,</span>
      <span class="s0">);</span>
      <span class="s0">if (typeof bundle === 'string') {</span>
        <span class="s0">bundleCode = bundle;</span>
      <span class="s0">} else {</span>
        <span class="s0">bundleCode = bundle.code;</span>
        <span class="s0">bundleMap = bundle.map;</span>
      <span class="s0">}</span>
    <span class="s0">} else {</span>
      <span class="s0">bundleCode = bundleToString(</span>
        <span class="s0">baseJSBundle(entryPoint, prepend, graph, bundleOptions),</span>
      <span class="s0">).code;</span>
    <span class="s0">}</span>
    <span class="s0">if (!bundleMap) {</span>
      <span class="s0">bundleMap = sourceMapString(</span>
        <span class="s0">[...prepend, ...this._getSortedModules(graph)],</span>
        <span class="s0">{</span>
          <span class="s0">excludeSource: serializerOptions.excludeSource,</span>
          <span class="s0">processModuleFilter: this._config.serializer.processModuleFilter,</span>
          <span class="s0">shouldAddToIgnoreList: bundleOptions.shouldAddToIgnoreList,</span>
        <span class="s0">},</span>
      <span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s0">return {</span>
      <span class="s0">code: bundleCode,</span>
      <span class="s0">map: bundleMap,</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s0">async getRamBundleInfo(options: BundleOptions): Promise&lt;RamBundleInfo&gt; {</span>
    <span class="s0">const {</span>
      <span class="s0">entryFile,</span>
      <span class="s0">graphOptions,</span>
      <span class="s0">onProgress,</span>
      <span class="s0">resolverOptions,</span>
      <span class="s0">serializerOptions,</span>
      <span class="s0">transformOptions,</span>
    <span class="s0">} = splitBundleOptions(options);</span>

    <span class="s0">const {prepend, graph} = await this._bundler.buildGraph(</span>
      <span class="s0">entryFile,</span>
      <span class="s0">transformOptions,</span>
      <span class="s0">resolverOptions,</span>
      <span class="s0">{</span>
        <span class="s0">onProgress,</span>
        <span class="s0">shallow: graphOptions.shallow,</span>
        <span class="s0">lazy: graphOptions.lazy,</span>
      <span class="s0">},</span>
    <span class="s0">);</span>

    <span class="s0">const entryPoint = this._getEntryPointAbsolutePath(entryFile);</span>

    <span class="s0">return await getRamBundleInfo(entryPoint, prepend, graph, {</span>
      <span class="s0">asyncRequireModulePath: await this._resolveRelativePath(</span>
        <span class="s0">this._config.transformer.asyncRequireModulePath,</span>
        <span class="s0">{</span>
          <span class="s0">relativeTo: 'project',</span>
          <span class="s0">resolverOptions,</span>
          <span class="s0">transformOptions,</span>
        <span class="s0">},</span>
      <span class="s0">),</span>
      <span class="s0">processModuleFilter: this._config.serializer.processModuleFilter,</span>
      <span class="s0">createModuleId: this._createModuleId,</span>
      <span class="s0">dev: transformOptions.dev,</span>
      <span class="s0">excludeSource: serializerOptions.excludeSource,</span>
      <span class="s0">getRunModuleStatement: this._config.serializer.getRunModuleStatement,</span>
      <span class="s0">getTransformOptions: this._config.transformer.getTransformOptions,</span>
      <span class="s0">includeAsyncPaths: graphOptions.lazy,</span>
      <span class="s0">platform: transformOptions.platform,</span>
      <span class="s0">projectRoot: this._config.projectRoot,</span>
      <span class="s0">modulesOnly: serializerOptions.modulesOnly,</span>
      <span class="s0">runBeforeMainModule:</span>
        <span class="s0">this._config.serializer.getModulesRunBeforeMainModule(</span>
          <span class="s0">path.relative(this._config.projectRoot, entryPoint),</span>
        <span class="s0">),</span>
      <span class="s0">runModule: serializerOptions.runModule,</span>
      <span class="s0">sourceMapUrl: serializerOptions.sourceMapUrl,</span>
      <span class="s0">sourceUrl: serializerOptions.sourceUrl,</span>
      <span class="s0">inlineSourceMap: serializerOptions.inlineSourceMap,</span>
      <span class="s0">serverRoot:</span>
        <span class="s0">this._config.server.unstable_serverRoot ?? this._config.projectRoot,</span>
      <span class="s0">shouldAddToIgnoreList: (module: Module&lt;&gt;) =&gt;</span>
        <span class="s0">this._shouldAddModuleToIgnoreList(module),</span>
    <span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s0">async getAssets(options: BundleOptions): Promise&lt;$ReadOnlyArray&lt;AssetData&gt;&gt; {</span>
    <span class="s0">const {entryFile, onProgress, resolverOptions, transformOptions} =</span>
      <span class="s0">splitBundleOptions(options);</span>

    <span class="s0">const dependencies = await this._bundler.getDependencies(</span>
      <span class="s0">[entryFile],</span>
      <span class="s0">transformOptions,</span>
      <span class="s0">resolverOptions,</span>
      <span class="s0">{onProgress, shallow: false, lazy: false},</span>
    <span class="s0">);</span>

    <span class="s0">return await getAssets(dependencies, {</span>
      <span class="s0">processModuleFilter: this._config.serializer.processModuleFilter,</span>
      <span class="s0">assetPlugins: this._config.transformer.assetPlugins,</span>
      <span class="s0">platform: transformOptions.platform,</span>
      <span class="s0">projectRoot: this._getServerRootDir(),</span>
      <span class="s0">publicPath: this._config.transformer.publicPath,</span>
    <span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s0">async getOrderedDependencyPaths(options: {</span>
    <span class="s0">+dev: boolean,</span>
    <span class="s0">+entryFile: string,</span>
    <span class="s0">+minify: boolean,</span>
    <span class="s0">+platform: ?string,</span>
    <span class="s0">...</span>
  <span class="s0">}): Promise&lt;Array&lt;string&gt;&gt; {</span>
    <span class="s0">const {</span>
      <span class="s0">entryFile,</span>
      <span class="s0">onProgress,</span>
      <span class="s0">resolverOptions,</span>
      <span class="s0">transformOptions,</span>
      <span class="s0">/* $FlowFixMe(&gt;=0.122.0 site=react_native_fb) This comment suppresses an</span>
       <span class="s0">* error found when Flow v0.122.0 was deployed. To see the error, delete</span>
       <span class="s0">* this comment and run Flow. */</span>
    <span class="s0">} = splitBundleOptions({</span>
      <span class="s0">...Server.DEFAULT_BUNDLE_OPTIONS,</span>
      <span class="s0">...options,</span>
      <span class="s0">bundleType: 'bundle',</span>
    <span class="s0">});</span>

    <span class="s0">const {prepend, graph} = await this._bundler.buildGraph(</span>
      <span class="s0">entryFile,</span>
      <span class="s0">transformOptions,</span>
      <span class="s0">resolverOptions,</span>
      <span class="s0">{onProgress, shallow: false, lazy: false},</span>
    <span class="s0">);</span>

    <span class="s0">const platform =</span>
      <span class="s0">transformOptions.platform ||</span>
      <span class="s0">parsePlatformFilePath(entryFile, this._platforms).platform;</span>

    <span class="s0">// $FlowFixMe[incompatible-return]</span>
    <span class="s0">return await getAllFiles(prepend, graph, {</span>
      <span class="s0">platform,</span>
      <span class="s0">processModuleFilter: this._config.serializer.processModuleFilter,</span>
    <span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s0">_rangeRequestMiddleware(</span>
    <span class="s0">req: IncomingMessage,</span>
    <span class="s0">res: ServerResponse,</span>
    <span class="s0">data: string | Buffer,</span>
    <span class="s0">assetPath: string,</span>
  <span class="s0">): Buffer | string {</span>
    <span class="s0">if (req.headers &amp;&amp; req.headers.range) {</span>
      <span class="s0">const [rangeStart, rangeEnd] = req.headers.range</span>
        <span class="s0">.replace(/bytes=/, '')</span>
        <span class="s0">.split('-');</span>
      <span class="s0">const dataStart = parseInt(rangeStart, 10);</span>
      <span class="s0">const dataEnd = rangeEnd ? parseInt(rangeEnd, 10) : data.length - 1;</span>
      <span class="s0">const chunksize = dataEnd - dataStart + 1;</span>

      <span class="s0">res.writeHead(206, {</span>
        <span class="s0">'Accept-Ranges': 'bytes',</span>
        <span class="s0">'Content-Length': chunksize.toString(),</span>
        <span class="s0">'Content-Range': `bytes ${dataStart}-${dataEnd}/${data.length}`,</span>
      <span class="s0">});</span>

      <span class="s0">return data.slice(dataStart, dataEnd + 1);</span>
    <span class="s0">}</span>

    <span class="s0">res.setHeader('Content-Length', String(Buffer.byteLength(data)));</span>

    <span class="s0">return data;</span>
  <span class="s0">}</span>

  <span class="s0">async _processSingleAssetRequest(</span>
    <span class="s0">req: IncomingMessage,</span>
    <span class="s0">res: ServerResponse,</span>
  <span class="s0">): Promise&lt;void&gt; {</span>
    <span class="s0">const urlObj = url.parse(decodeURI(req.url), true);</span>
    <span class="s0">let [, assetPath] =</span>
      <span class="s0">(urlObj &amp;&amp;</span>
        <span class="s0">urlObj.pathname &amp;&amp;</span>
        <span class="s0">urlObj.pathname.match(/^\/assets\/(.+)$/)) ||</span>
      <span class="s0">[];</span>

    <span class="s0">if (!assetPath &amp;&amp; urlObj &amp;&amp; urlObj.query &amp;&amp; urlObj.query.unstable_path) {</span>
      <span class="s0">const [, actualPath, secondaryQuery] = nullthrows(</span>
        <span class="s0">urlObj.query.unstable_path.match(/^([^?]*)\??(.*)$/),</span>
      <span class="s0">);</span>
      <span class="s0">if (secondaryQuery) {</span>
        <span class="s0">Object.assign(urlObj.query, querystring.parse(secondaryQuery));</span>
      <span class="s0">}</span>
      <span class="s0">assetPath = actualPath;</span>
    <span class="s0">}</span>

    <span class="s0">if (!assetPath) {</span>
      <span class="s0">throw new Error('Could not extract asset path from URL');</span>
    <span class="s0">}</span>

    <span class="s0">const processingAssetRequestLogEntry = log(</span>
      <span class="s0">createActionStartEntry({</span>
        <span class="s0">action_name: 'Processing asset request',</span>
        <span class="s0">asset: assetPath[1],</span>
      <span class="s0">}),</span>
    <span class="s0">);</span>

    <span class="s0">try {</span>
      <span class="s0">const data = await getAsset(</span>
        <span class="s0">assetPath,</span>
        <span class="s0">this._config.projectRoot,</span>
        <span class="s0">this._config.watchFolders,</span>
        <span class="s0">urlObj.query.platform,</span>
        <span class="s0">this._config.resolver.assetExts,</span>
      <span class="s0">);</span>
      <span class="s0">// Tell clients to cache this for 1 year.</span>
      <span class="s0">// This is safe as the asset url contains a hash of the asset.</span>
      <span class="s0">if (process.env.REACT_NATIVE_ENABLE_ASSET_CACHING === true) {</span>
        <span class="s0">res.setHeader('Cache-Control', 'max-age=31536000');</span>
      <span class="s0">}</span>
      <span class="s0">res.setHeader('Content-Type', mime.lookup(path.basename(assetPath)));</span>
      <span class="s0">res.end(this._rangeRequestMiddleware(req, res, data, assetPath));</span>
      <span class="s0">process.nextTick(() =&gt; {</span>
        <span class="s0">log(createActionEndEntry(processingAssetRequestLogEntry));</span>
      <span class="s0">});</span>
    <span class="s0">} catch (error) {</span>
      <span class="s0">console.error(error.stack);</span>
      <span class="s0">res.writeHead(404);</span>
      <span class="s0">res.end('Asset not found');</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">processRequest: (</span>
    <span class="s0">IncomingMessage,</span>
    <span class="s0">ServerResponse,</span>
    <span class="s0">((e: ?Error) =&gt; void),</span>
  <span class="s0">) =&gt; void = (</span>
    <span class="s0">req: IncomingMessage,</span>
    <span class="s0">res: ServerResponse,</span>
    <span class="s0">next: (?Error) =&gt; void,</span>
  <span class="s0">) =&gt; {</span>
    <span class="s0">this._processRequest(req, res, next).catch(next);</span>
  <span class="s0">};</span>

  <span class="s0">_parseOptions(url: string): BundleOptions {</span>
    <span class="s0">return parseOptionsFromUrl(url, new Set(this._config.resolver.platforms));</span>
  <span class="s0">}</span>

  <span class="s0">_rewriteAndNormalizeUrl(requestUrl: string): string {</span>
    <span class="s0">return jscSafeUrl.toNormalUrl(</span>
      <span class="s0">this._config.server.rewriteRequestUrl(jscSafeUrl.toNormalUrl(requestUrl)),</span>
    <span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s0">async _processRequest(</span>
    <span class="s0">req: IncomingMessage,</span>
    <span class="s0">res: ServerResponse,</span>
    <span class="s0">next: (?Error) =&gt; void,</span>
  <span class="s0">) {</span>
    <span class="s0">const originalUrl = req.url;</span>
    <span class="s0">req.url = this._rewriteAndNormalizeUrl(req.url);</span>
    <span class="s0">const urlObj = url.parse(req.url, true);</span>
    <span class="s0">const {host} = req.headers;</span>
    <span class="s0">debug(</span>
      <span class="s0">`Handling request: ${host ? 'http://' + host : ''}${req.url}` +</span>
        <span class="s0">(originalUrl !== req.url ? ` (rewritten from ${originalUrl})` : ''),</span>
    <span class="s0">);</span>
    <span class="s0">const formattedUrl = url.format({</span>
      <span class="s0">...urlObj,</span>
      <span class="s0">host,</span>
      <span class="s0">protocol: 'http',</span>
    <span class="s0">});</span>
    <span class="s0">const pathname = urlObj.pathname || '';</span>
    <span class="s0">const buildNumber = this.getNewBuildNumber();</span>
    <span class="s0">if (pathname.endsWith('.bundle')) {</span>
      <span class="s0">const options = this._parseOptions(formattedUrl);</span>
      <span class="s0">await this._processBundleRequest(req, res, options, {</span>
        <span class="s0">buildNumber,</span>
        <span class="s0">bundlePerfLogger:</span>
          <span class="s0">this._config.unstable_perfLoggerFactory?.('BUNDLING_REQUEST', {</span>
            <span class="s0">key: buildNumber,</span>
          <span class="s0">}) ?? noopLogger,</span>
      <span class="s0">});</span>

      <span class="s0">if (this._serverOptions &amp;&amp; this._serverOptions.onBundleBuilt) {</span>
        <span class="s0">this._serverOptions.onBundleBuilt(pathname);</span>
      <span class="s0">}</span>
    <span class="s0">} else if (pathname.endsWith('.map')) {</span>
      <span class="s0">// Chrome dev tools may need to access the source maps.</span>
      <span class="s0">res.setHeader('Access-Control-Allow-Origin', 'devtools://devtools');</span>
      <span class="s0">await this._processSourceMapRequest(</span>
        <span class="s0">req,</span>
        <span class="s0">res,</span>
        <span class="s0">this._parseOptions(formattedUrl),</span>
        <span class="s0">{</span>
          <span class="s0">buildNumber,</span>
          <span class="s0">bundlePerfLogger: noopLogger,</span>
        <span class="s0">},</span>
      <span class="s0">);</span>
    <span class="s0">} else if (pathname.endsWith('.assets')) {</span>
      <span class="s0">await this._processAssetsRequest(</span>
        <span class="s0">req,</span>
        <span class="s0">res,</span>
        <span class="s0">this._parseOptions(formattedUrl),</span>
        <span class="s0">{</span>
          <span class="s0">buildNumber,</span>
          <span class="s0">bundlePerfLogger: noopLogger,</span>
        <span class="s0">},</span>
      <span class="s0">);</span>
    <span class="s0">} else if (pathname.startsWith('/assets/') || pathname === '/assets') {</span>
      <span class="s0">await this._processSingleAssetRequest(req, res);</span>
    <span class="s0">} else if (pathname === '/symbolicate') {</span>
      <span class="s0">await this._symbolicate(req, res);</span>
    <span class="s0">} else {</span>
      <span class="s0">next();</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">_createRequestProcessor&lt;T&gt;({</span>
    <span class="s0">createStartEntry,</span>
    <span class="s0">createEndEntry,</span>
    <span class="s0">build,</span>
    <span class="s0">delete: deleteFn,</span>
    <span class="s0">finish,</span>
  <span class="s0">}: {</span>
    <span class="s0">+createStartEntry: (context: ProcessStartContext) =&gt; ActionLogEntryData,</span>
    <span class="s0">+createEndEntry: (</span>
      <span class="s0">context: ProcessEndContext&lt;T&gt;,</span>
    <span class="s0">) =&gt; $Rest&lt;ActionStartLogEntry, LogEntry&gt;,</span>
    <span class="s0">+build: (context: ProcessStartContext) =&gt; Promise&lt;T&gt;,</span>
    <span class="s0">+delete?: (context: ProcessDeleteContext) =&gt; Promise&lt;void&gt;,</span>
    <span class="s0">+finish: (context: ProcessEndContext&lt;T&gt;) =&gt; void,</span>
  <span class="s0">}): (</span>
    <span class="s0">req: IncomingMessage,</span>
    <span class="s0">res: ServerResponse,</span>
    <span class="s0">bundleOptions: BundleOptions,</span>
    <span class="s0">buildContext: $ReadOnly&lt;{</span>
      <span class="s0">buildNumber: number,</span>
      <span class="s0">bundlePerfLogger: RootPerfLogger,</span>
    <span class="s0">}&gt;,</span>
  <span class="s0">) =&gt; Promise&lt;void&gt; {</span>
    <span class="s0">return async function requestProcessor(</span>
      <span class="s0">this: Server,</span>
      <span class="s0">req: IncomingMessage,</span>
      <span class="s0">res: ServerResponse,</span>
      <span class="s0">bundleOptions: BundleOptions,</span>
      <span class="s0">buildContext: $ReadOnly&lt;{</span>
        <span class="s0">buildNumber: number,</span>
        <span class="s0">bundlePerfLogger: RootPerfLogger,</span>
      <span class="s0">}&gt;,</span>
    <span class="s0">): Promise&lt;void&gt; {</span>
      <span class="s0">const {buildNumber} = buildContext;</span>
      <span class="s0">const {</span>
        <span class="s0">entryFile,</span>
        <span class="s0">graphOptions,</span>
        <span class="s0">resolverOptions,</span>
        <span class="s0">serializerOptions,</span>
        <span class="s0">transformOptions,</span>
      <span class="s0">} = splitBundleOptions(bundleOptions);</span>

      <span class="s0">/**</span>
       <span class="s0">* `entryFile` is relative to projectRoot, we need to use resolution function</span>
       <span class="s0">* to find the appropriate file with supported extensions.</span>
       <span class="s0">*/</span>
      <span class="s0">const resolvedEntryFilePath = await this._resolveRelativePath(entryFile, {</span>
        <span class="s0">relativeTo: 'server',</span>
        <span class="s0">resolverOptions,</span>
        <span class="s0">transformOptions,</span>
      <span class="s0">});</span>
      <span class="s0">const graphId = getGraphId(resolvedEntryFilePath, transformOptions, {</span>
        <span class="s0">unstable_allowRequireContext:</span>
          <span class="s0">this._config.transformer.unstable_allowRequireContext,</span>
        <span class="s0">resolverOptions,</span>
        <span class="s0">shallow: graphOptions.shallow,</span>
        <span class="s0">lazy: graphOptions.lazy,</span>
      <span class="s0">});</span>

      <span class="s0">// For resources that support deletion, handle the DELETE method.</span>
      <span class="s0">if (deleteFn &amp;&amp; req.method === 'DELETE') {</span>
        <span class="s0">const deleteContext = {</span>
          <span class="s0">graphId,</span>
          <span class="s0">req,</span>
          <span class="s0">res,</span>
        <span class="s0">};</span>
        <span class="s0">try {</span>
          <span class="s0">await deleteFn(deleteContext);</span>
        <span class="s0">} catch (error) {</span>
          <span class="s0">const formattedError = formatBundlingError(error);</span>

          <span class="s0">const status = error instanceof ResourceNotFoundError ? 404 : 500;</span>
          <span class="s0">res.writeHead(status, {</span>
            <span class="s0">'Content-Type': 'application/json; charset=UTF-8',</span>
          <span class="s0">});</span>
          <span class="s0">res.end(JSON.stringify(formattedError));</span>
        <span class="s0">}</span>
        <span class="s0">return;</span>
      <span class="s0">}</span>

      <span class="s0">const mres = MultipartResponse.wrapIfSupported(req, res);</span>

      <span class="s0">let onProgress = null;</span>
      <span class="s0">let lastProgress = -1;</span>
      <span class="s0">if (this._config.reporter) {</span>
        <span class="s0">onProgress = (transformedFileCount: number, totalFileCount: number) =&gt; {</span>
          <span class="s0">const currentProgress = parseInt(</span>
            <span class="s0">(transformedFileCount / totalFileCount) * 100,</span>
            <span class="s0">10,</span>
          <span class="s0">);</span>

          <span class="s0">// We want to throttle the updates so that we only show meaningful</span>
          <span class="s0">// UI updates slow enough for the client to actually handle them. For</span>
          <span class="s0">// that, we check the percentage, and only send percentages that are</span>
          <span class="s0">// actually different and that have increased from the last one we sent.</span>
          <span class="s0">if (currentProgress &gt; lastProgress || totalFileCount &lt; 10) {</span>
            <span class="s0">if (mres instanceof MultipartResponse) {</span>
              <span class="s0">mres.writeChunk(</span>
                <span class="s0">{'Content-Type': 'application/json'},</span>
                <span class="s0">JSON.stringify({</span>
                  <span class="s0">done: transformedFileCount,</span>
                  <span class="s0">total: totalFileCount,</span>
                <span class="s0">}),</span>
              <span class="s0">);</span>
            <span class="s0">}</span>

            <span class="s0">// The `uncork` called internally in Node via `promise.nextTick()` may not fire</span>
            <span class="s0">// until all of the Promises are resolved because the microtask queue we're</span>
            <span class="s0">// in could be starving the event loop. This can cause a bug where the progress</span>
            <span class="s0">// is not actually sent in the response until after bundling is complete. This</span>
            <span class="s0">// would defeat the purpose of sending progress, so we `uncork` the stream now</span>
            <span class="s0">// which will force the response to flush to the client immediately.</span>
            <span class="s0">// $FlowFixMe[method-unbinding] added when improving typing for this parameters</span>
            <span class="s0">if (res.socket != null &amp;&amp; res.socket.uncork != null) {</span>
              <span class="s0">res.socket.uncork();</span>
            <span class="s0">}</span>

            <span class="s0">lastProgress = currentProgress;</span>
          <span class="s0">}</span>

          <span class="s0">this._reporter.update({</span>
            <span class="s0">buildID: getBuildID(buildNumber),</span>
            <span class="s0">type: 'bundle_transform_progressed',</span>
            <span class="s0">transformedFileCount,</span>
            <span class="s0">totalFileCount,</span>
          <span class="s0">});</span>
        <span class="s0">};</span>
      <span class="s0">}</span>

      <span class="s0">this._reporter.update({</span>
        <span class="s0">buildID: getBuildID(buildNumber),</span>
        <span class="s0">bundleDetails: {</span>
          <span class="s0">bundleType: bundleOptions.bundleType,</span>
          <span class="s0">dev: transformOptions.dev,</span>
          <span class="s0">entryFile: resolvedEntryFilePath,</span>
          <span class="s0">minify: transformOptions.minify,</span>
          <span class="s0">platform: transformOptions.platform,</span>
        <span class="s0">},</span>
        <span class="s0">isPrefetch: req.method === 'HEAD',</span>
        <span class="s0">type: 'bundle_build_started',</span>
      <span class="s0">});</span>

      <span class="s0">const startContext = {</span>
        <span class="s0">buildNumber,</span>
        <span class="s0">bundleOptions,</span>
        <span class="s0">entryFile: resolvedEntryFilePath,</span>
        <span class="s0">graphId,</span>
        <span class="s0">graphOptions,</span>
        <span class="s0">mres,</span>
        <span class="s0">onProgress,</span>
        <span class="s0">req,</span>
        <span class="s0">resolverOptions,</span>
        <span class="s0">serializerOptions,</span>
        <span class="s0">transformOptions,</span>
        <span class="s0">bundlePerfLogger: buildContext.bundlePerfLogger,</span>
      <span class="s0">};</span>
      <span class="s0">const logEntry = log(</span>
        <span class="s0">createActionStartEntry(createStartEntry(startContext)),</span>
      <span class="s0">);</span>

      <span class="s0">let result;</span>
      <span class="s0">try {</span>
        <span class="s0">result = await build(startContext);</span>
      <span class="s0">} catch (error) {</span>
        <span class="s0">const formattedError = formatBundlingError(error);</span>

        <span class="s0">const status = error instanceof ResourceNotFoundError ? 404 : 500;</span>
        <span class="s0">mres.writeHead(status, {</span>
          <span class="s0">'Content-Type': 'application/json; charset=UTF-8',</span>
        <span class="s0">});</span>
        <span class="s0">mres.end(JSON.stringify(formattedError));</span>

        <span class="s0">this._reporter.update({</span>
          <span class="s0">buildID: getBuildID(buildNumber),</span>
          <span class="s0">type: 'bundle_build_failed',</span>
          <span class="s0">bundleOptions,</span>
        <span class="s0">});</span>

        <span class="s0">this._reporter.update({error, type: 'bundling_error'});</span>

        <span class="s0">log({</span>
          <span class="s0">action_name: 'bundling_error',</span>
          <span class="s0">error_type: formattedError.type,</span>
          <span class="s0">log_entry_label: 'bundling_error',</span>
          <span class="s0">bundle_id: graphId,</span>
          <span class="s0">build_id: getBuildID(buildNumber),</span>
          <span class="s0">stack: formattedError.message,</span>
        <span class="s0">});</span>

        <span class="s0">debug('Bundling error', error);</span>

        <span class="s0">buildContext.bundlePerfLogger.end('FAIL');</span>

        <span class="s0">return;</span>
      <span class="s0">}</span>

      <span class="s0">const endContext = {</span>
        <span class="s0">...startContext,</span>
        <span class="s0">result,</span>
      <span class="s0">};</span>
      <span class="s0">finish(endContext);</span>

      <span class="s0">this._reporter.update({</span>
        <span class="s0">buildID: getBuildID(buildNumber),</span>
        <span class="s0">type: 'bundle_build_done',</span>
      <span class="s0">});</span>

      <span class="s0">log(</span>
        <span class="s0">/* $FlowFixMe(&gt;=0.122.0 site=react_native_fb) This comment suppresses</span>
         <span class="s0">* an error found when Flow v0.122.0 was deployed. To see the error,</span>
         <span class="s0">* delete this comment and run Flow. */</span>
        <span class="s0">createActionEndEntry({</span>
          <span class="s0">...logEntry,</span>
          <span class="s0">...createEndEntry(endContext),</span>
        <span class="s0">}),</span>
      <span class="s0">);</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s0">_processBundleRequest: (</span>
    <span class="s0">req: IncomingMessage,</span>
    <span class="s0">res: ServerResponse,</span>
    <span class="s0">bundleOptions: BundleOptions,</span>
    <span class="s0">buildContext: $ReadOnly&lt;{</span>
      <span class="s0">buildNumber: number,</span>
      <span class="s0">bundlePerfLogger: RootPerfLogger,</span>
    <span class="s0">}&gt;,</span>
  <span class="s0">) =&gt; Promise&lt;void&gt; = this._createRequestProcessor({</span>
    <span class="s0">createStartEntry(context: ProcessStartContext) {</span>
      <span class="s0">return {</span>
        <span class="s0">action_name: 'Requesting bundle',</span>
        <span class="s0">bundle_url: context.req.url,</span>
        <span class="s0">entry_point: context.entryFile,</span>
        <span class="s0">bundler: 'delta',</span>
        <span class="s0">build_id: getBuildID(context.buildNumber),</span>
        <span class="s0">bundle_options: context.bundleOptions,</span>
        <span class="s0">bundle_hash: context.graphId,</span>
        <span class="s0">user_agent: context.req.headers['user-agent'] ?? 'unknown',</span>
      <span class="s0">};</span>
    <span class="s0">},</span>
    <span class="s0">createEndEntry(</span>
      <span class="s0">context: ProcessEndContext&lt;{</span>
        <span class="s0">bundle: string,</span>
        <span class="s0">lastModifiedDate: Date,</span>
        <span class="s0">nextRevId: RevisionId,</span>
        <span class="s0">numModifiedFiles: number,</span>
      <span class="s0">}&gt;,</span>
    <span class="s0">) {</span>
      <span class="s0">return {</span>
        <span class="s0">outdated_modules: context.result.numModifiedFiles,</span>
      <span class="s0">};</span>
    <span class="s0">},</span>
    <span class="s0">build: async ({</span>
      <span class="s0">entryFile,</span>
      <span class="s0">graphId,</span>
      <span class="s0">graphOptions,</span>
      <span class="s0">onProgress,</span>
      <span class="s0">resolverOptions,</span>
      <span class="s0">serializerOptions,</span>
      <span class="s0">transformOptions,</span>
      <span class="s0">bundlePerfLogger,</span>
    <span class="s0">}) =&gt; {</span>
      <span class="s0">bundlePerfLogger.start();</span>
      <span class="s0">bundlePerfLogger.annotate({</span>
        <span class="s0">string: {</span>
          <span class="s0">bundle_url: entryFile,</span>
        <span class="s0">},</span>
      <span class="s0">});</span>
      <span class="s0">const revPromise = this._bundler.getRevisionByGraphId(graphId);</span>

      <span class="s0">bundlePerfLogger.point('resolvingAndTransformingDependencies_start');</span>
      <span class="s0">bundlePerfLogger.annotate({</span>
        <span class="s0">bool: {</span>
          <span class="s0">initial_build: revPromise == null,</span>
        <span class="s0">},</span>
      <span class="s0">});</span>
      <span class="s0">const {delta, revision} = await (revPromise != null</span>
        <span class="s0">? this._bundler.updateGraph(await revPromise, false)</span>
        <span class="s0">: this._bundler.initializeGraph(</span>
            <span class="s0">entryFile,</span>
            <span class="s0">transformOptions,</span>
            <span class="s0">resolverOptions,</span>
            <span class="s0">{</span>
              <span class="s0">onProgress,</span>
              <span class="s0">shallow: graphOptions.shallow,</span>
              <span class="s0">lazy: graphOptions.lazy,</span>
            <span class="s0">},</span>
          <span class="s0">));</span>
      <span class="s0">bundlePerfLogger.point('resolvingAndTransformingDependencies_end');</span>
      <span class="s0">bundlePerfLogger.point('serializingBundle_start');</span>
      <span class="s0">const serializer =</span>
        <span class="s0">this._config.serializer.customSerializer ||</span>
        <span class="s0">((entryPoint, preModules, graph, options) =&gt;</span>
          <span class="s0">bundleToString(baseJSBundle(entryPoint, preModules, graph, options))</span>
            <span class="s0">.code);</span>

      <span class="s0">const bundle = await serializer(</span>
        <span class="s0">entryFile,</span>
        <span class="s0">revision.prepend,</span>
        <span class="s0">revision.graph,</span>
        <span class="s0">{</span>
          <span class="s0">asyncRequireModulePath: await this._resolveRelativePath(</span>
            <span class="s0">this._config.transformer.asyncRequireModulePath,</span>
            <span class="s0">{</span>
              <span class="s0">relativeTo: 'project',</span>
              <span class="s0">resolverOptions,</span>
              <span class="s0">transformOptions,</span>
            <span class="s0">},</span>
          <span class="s0">),</span>
          <span class="s0">processModuleFilter: this._config.serializer.processModuleFilter,</span>
          <span class="s0">createModuleId: this._createModuleId,</span>
          <span class="s0">getRunModuleStatement: this._config.serializer.getRunModuleStatement,</span>
          <span class="s0">includeAsyncPaths: graphOptions.lazy,</span>
          <span class="s0">dev: transformOptions.dev,</span>
          <span class="s0">projectRoot: this._config.projectRoot,</span>
          <span class="s0">modulesOnly: serializerOptions.modulesOnly,</span>
          <span class="s0">runBeforeMainModule:</span>
            <span class="s0">this._config.serializer.getModulesRunBeforeMainModule(</span>
              <span class="s0">path.relative(this._config.projectRoot, entryFile),</span>
            <span class="s0">),</span>
          <span class="s0">runModule: serializerOptions.runModule,</span>
          <span class="s0">sourceMapUrl: serializerOptions.sourceMapUrl,</span>
          <span class="s0">sourceUrl: serializerOptions.sourceUrl,</span>
          <span class="s0">inlineSourceMap: serializerOptions.inlineSourceMap,</span>
          <span class="s0">serverRoot:</span>
            <span class="s0">this._config.server.unstable_serverRoot ?? this._config.projectRoot,</span>
          <span class="s0">shouldAddToIgnoreList: (module: Module&lt;&gt;) =&gt;</span>
            <span class="s0">this._shouldAddModuleToIgnoreList(module),</span>
        <span class="s0">},</span>
      <span class="s0">);</span>
      <span class="s0">bundlePerfLogger.point('serializingBundle_end');</span>

      <span class="s0">const bundleCode = typeof bundle === 'string' ? bundle : bundle.code;</span>

      <span class="s0">bundlePerfLogger.end('SUCCESS');</span>

      <span class="s0">return {</span>
        <span class="s0">numModifiedFiles: delta.reset</span>
          <span class="s0">? delta.added.size + revision.prepend.length</span>
          <span class="s0">: delta.added.size + delta.modified.size + delta.deleted.size,</span>
        <span class="s0">lastModifiedDate: revision.date,</span>
        <span class="s0">nextRevId: revision.id,</span>
        <span class="s0">bundle: bundleCode,</span>
      <span class="s0">};</span>
    <span class="s0">},</span>
    <span class="s0">finish({req, mres, serializerOptions, result}) {</span>
      <span class="s0">if (</span>
        <span class="s0">// We avoid parsing the dates since the client should never send a more</span>
        <span class="s0">// recent date than the one returned by the Delta Bundler (if that's the</span>
        <span class="s0">// case it's fine to return the whole bundle).</span>
        <span class="s0">req.headers['if-modified-since'] ===</span>
        <span class="s0">result.lastModifiedDate.toUTCString()</span>
      <span class="s0">) {</span>
        <span class="s0">debug('Responding with 304');</span>
        <span class="s0">mres.writeHead(304);</span>
        <span class="s0">mres.end();</span>
      <span class="s0">} else {</span>
        <span class="s0">mres.setHeader(</span>
          <span class="s0">FILES_CHANGED_COUNT_HEADER,</span>
          <span class="s0">String(result.numModifiedFiles),</span>
        <span class="s0">);</span>
        <span class="s0">mres.setHeader(DELTA_ID_HEADER, String(result.nextRevId));</span>
        <span class="s0">if (serializerOptions?.sourceUrl != null) {</span>
          <span class="s0">mres.setHeader('Content-Location', serializerOptions.sourceUrl);</span>
        <span class="s0">}</span>
        <span class="s0">mres.setHeader('Content-Type', 'application/javascript; charset=UTF-8');</span>
        <span class="s0">mres.setHeader('Last-Modified', result.lastModifiedDate.toUTCString());</span>
        <span class="s0">mres.setHeader(</span>
          <span class="s0">'Content-Length',</span>
          <span class="s0">String(Buffer.byteLength(result.bundle)),</span>
        <span class="s0">);</span>
        <span class="s0">mres.end(result.bundle);</span>
      <span class="s0">}</span>
    <span class="s0">},</span>
    <span class="s0">delete: async ({graphId, res}) =&gt; {</span>
      <span class="s0">await this._bundler.endGraph(graphId);</span>
      <span class="s0">res.statusCode = 204;</span>
      <span class="s0">res.end();</span>
    <span class="s0">},</span>
  <span class="s0">});</span>

  <span class="s0">// This function ensures that modules in source maps are sorted in the same</span>
  <span class="s0">// order as in a plain JS bundle.</span>
  <span class="s0">_getSortedModules(graph: ReadOnlyGraph&lt;&gt;): $ReadOnlyArray&lt;Module&lt;&gt;&gt; {</span>
    <span class="s0">const modules = [...graph.dependencies.values()];</span>
    <span class="s0">// Assign IDs to modules in a consistent order</span>
    <span class="s0">for (const module of modules) {</span>
      <span class="s0">this._createModuleId(module.path);</span>
    <span class="s0">}</span>
    <span class="s0">// Sort by IDs</span>
    <span class="s0">return modules.sort(</span>
      <span class="s0">(a: Module&lt;MixedOutput&gt;, b: Module&lt;MixedOutput&gt;) =&gt;</span>
        <span class="s0">this._createModuleId(a.path) - this._createModuleId(b.path),</span>
    <span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s0">_processSourceMapRequest: (</span>
    <span class="s0">req: IncomingMessage,</span>
    <span class="s0">res: ServerResponse,</span>
    <span class="s0">bundleOptions: BundleOptions,</span>
    <span class="s0">buildContext: $ReadOnly&lt;{</span>
      <span class="s0">buildNumber: number,</span>
      <span class="s0">bundlePerfLogger: RootPerfLogger,</span>
    <span class="s0">}&gt;,</span>
  <span class="s0">) =&gt; Promise&lt;void&gt; = this._createRequestProcessor({</span>
    <span class="s0">createStartEntry(context: ProcessStartContext) {</span>
      <span class="s0">return {</span>
        <span class="s0">action_name: 'Requesting sourcemap',</span>
        <span class="s0">bundle_url: context.req.url,</span>
        <span class="s0">entry_point: context.entryFile,</span>
        <span class="s0">bundler: 'delta',</span>
      <span class="s0">};</span>
    <span class="s0">},</span>
    <span class="s0">createEndEntry(context: ProcessEndContext&lt;string&gt;) {</span>
      <span class="s0">return {</span>
        <span class="s0">bundler: 'delta',</span>
      <span class="s0">};</span>
    <span class="s0">},</span>
    <span class="s0">build: async ({</span>
      <span class="s0">entryFile,</span>
      <span class="s0">graphId,</span>
      <span class="s0">graphOptions,</span>
      <span class="s0">onProgress,</span>
      <span class="s0">resolverOptions,</span>
      <span class="s0">serializerOptions,</span>
      <span class="s0">transformOptions,</span>
    <span class="s0">}) =&gt; {</span>
      <span class="s0">let revision;</span>
      <span class="s0">const revPromise = this._bundler.getRevisionByGraphId(graphId);</span>
      <span class="s0">if (revPromise == null) {</span>
        <span class="s0">({revision} = await this._bundler.initializeGraph(</span>
          <span class="s0">entryFile,</span>
          <span class="s0">transformOptions,</span>
          <span class="s0">resolverOptions,</span>
          <span class="s0">{</span>
            <span class="s0">onProgress,</span>
            <span class="s0">shallow: graphOptions.shallow,</span>
            <span class="s0">lazy: graphOptions.lazy,</span>
          <span class="s0">},</span>
        <span class="s0">));</span>
      <span class="s0">} else {</span>
        <span class="s0">({revision} = await this._bundler.updateGraph(await revPromise, false));</span>
      <span class="s0">}</span>

      <span class="s0">let {prepend, graph} = revision;</span>
      <span class="s0">if (serializerOptions.modulesOnly) {</span>
        <span class="s0">prepend = [];</span>
      <span class="s0">}</span>

      <span class="s0">return sourceMapString([...prepend, ...this._getSortedModules(graph)], {</span>
        <span class="s0">excludeSource: serializerOptions.excludeSource,</span>
        <span class="s0">processModuleFilter: this._config.serializer.processModuleFilter,</span>
        <span class="s0">shouldAddToIgnoreList: (module: Module&lt;&gt;) =&gt;</span>
          <span class="s0">this._shouldAddModuleToIgnoreList(module),</span>
      <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">finish({mres, result}) {</span>
      <span class="s0">mres.setHeader('Content-Type', 'application/json');</span>
      <span class="s0">mres.end(result.toString());</span>
    <span class="s0">},</span>
  <span class="s0">});</span>

  <span class="s0">_processAssetsRequest: (</span>
    <span class="s0">req: IncomingMessage,</span>
    <span class="s0">res: ServerResponse,</span>
    <span class="s0">bundleOptions: BundleOptions,</span>
    <span class="s0">buildContext: $ReadOnly&lt;{</span>
      <span class="s0">buildNumber: number,</span>
      <span class="s0">bundlePerfLogger: RootPerfLogger,</span>
    <span class="s0">}&gt;,</span>
  <span class="s0">) =&gt; Promise&lt;void&gt; = this._createRequestProcessor({</span>
    <span class="s0">createStartEntry(context: ProcessStartContext) {</span>
      <span class="s0">return {</span>
        <span class="s0">action_name: 'Requesting assets',</span>
        <span class="s0">bundle_url: context.req.url,</span>
        <span class="s0">entry_point: context.entryFile,</span>
        <span class="s0">bundler: 'delta',</span>
      <span class="s0">};</span>
    <span class="s0">},</span>
    <span class="s0">createEndEntry(context: ProcessEndContext&lt;$ReadOnlyArray&lt;AssetData&gt;&gt;) {</span>
      <span class="s0">return {</span>
        <span class="s0">bundler: 'delta',</span>
      <span class="s0">};</span>
    <span class="s0">},</span>
    <span class="s0">build: async ({</span>
      <span class="s0">entryFile,</span>
      <span class="s0">onProgress,</span>
      <span class="s0">resolverOptions,</span>
      <span class="s0">transformOptions,</span>
    <span class="s0">}) =&gt; {</span>
      <span class="s0">const dependencies = await this._bundler.getDependencies(</span>
        <span class="s0">[entryFile],</span>
        <span class="s0">transformOptions,</span>
        <span class="s0">resolverOptions,</span>
        <span class="s0">{onProgress, shallow: false, lazy: false},</span>
      <span class="s0">);</span>

      <span class="s0">return await getAssets(dependencies, {</span>
        <span class="s0">processModuleFilter: this._config.serializer.processModuleFilter,</span>
        <span class="s0">assetPlugins: this._config.transformer.assetPlugins,</span>
        <span class="s0">platform: transformOptions.platform,</span>
        <span class="s0">publicPath: this._config.transformer.publicPath,</span>
        <span class="s0">projectRoot: this._config.projectRoot,</span>
      <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">finish({mres, result}) {</span>
      <span class="s0">mres.setHeader('Content-Type', 'application/json');</span>
      <span class="s0">mres.end(JSON.stringify(result));</span>
    <span class="s0">},</span>
  <span class="s0">});</span>

  <span class="s0">async _symbolicate(req: IncomingMessage, res: ServerResponse) {</span>
    <span class="s0">const getCodeFrame = (</span>
      <span class="s0">urls: Set&lt;string&gt;,</span>
      <span class="s0">symbolicatedStack: $ReadOnlyArray&lt;StackFrameOutput&gt;,</span>
    <span class="s0">) =&gt; {</span>
      <span class="s0">for (let i = 0; i &lt; symbolicatedStack.length; i++) {</span>
        <span class="s0">const {collapse, column, file, lineNumber} = symbolicatedStack[i];</span>

        <span class="s0">if (</span>
          <span class="s0">collapse ||</span>
          <span class="s0">lineNumber == null ||</span>
          <span class="s0">(file != null &amp;&amp; urls.has(file))</span>
        <span class="s0">) {</span>
          <span class="s0">continue;</span>
        <span class="s0">}</span>

        <span class="s0">const fileAbsolute = path.resolve(this._config.projectRoot, file ?? '');</span>
        <span class="s0">try {</span>
          <span class="s0">return {</span>
            <span class="s0">content: codeFrameColumns(</span>
              <span class="s0">fs.readFileSync(fileAbsolute, 'utf8'),</span>
              <span class="s0">{</span>
                <span class="s0">// Metro returns 0 based columns but codeFrameColumns expects 1-based columns</span>
                <span class="s0">// $FlowFixMe[unsafe-addition]</span>
                <span class="s0">start: {column: column + 1, line: lineNumber},</span>
              <span class="s0">},</span>
              <span class="s0">{forceColor: true},</span>
            <span class="s0">),</span>
            <span class="s0">location: {</span>
              <span class="s0">row: lineNumber,</span>
              <span class="s0">column,</span>
            <span class="s0">},</span>
            <span class="s0">fileName: file,</span>
          <span class="s0">};</span>
        <span class="s0">} catch (error) {</span>
          <span class="s0">console.error(error);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s0">return null;</span>
    <span class="s0">};</span>

    <span class="s0">try {</span>
      <span class="s0">const symbolicatingLogEntry = log(</span>
        <span class="s0">createActionStartEntry('Symbolicating'),</span>
      <span class="s0">);</span>
      <span class="s0">debug('Start symbolication');</span>
      <span class="s0">/* $FlowFixMe: where is `rawBody` defined? Is it added by the `connect` framework? */</span>
      <span class="s0">const body = await req.rawBody;</span>
      <span class="s0">const parsedBody = JSON.parse(body);</span>

      <span class="s0">const rewriteAndNormalizeStackFrame = &lt;T&gt;(</span>
        <span class="s0">frame: T,</span>
        <span class="s0">lineNumber: number,</span>
      <span class="s0">): T =&gt; {</span>
        <span class="s0">invariant(</span>
          <span class="s0">frame != null &amp;&amp; typeof frame === 'object',</span>
          <span class="s0">'Bad stack frame at line %d, expected object, received: %s',</span>
          <span class="s0">lineNumber,</span>
          <span class="s0">typeof frame,</span>
        <span class="s0">);</span>
        <span class="s0">const frameFile = frame.file;</span>
        <span class="s0">if (typeof frameFile === 'string' &amp;&amp; frameFile.includes('://')) {</span>
          <span class="s0">return {</span>
            <span class="s0">...frame,</span>
            <span class="s0">file: this._rewriteAndNormalizeUrl(frameFile),</span>
          <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s0">return frame;</span>
      <span class="s0">};</span>

      <span class="s0">const stack = parsedBody.stack.map(rewriteAndNormalizeStackFrame);</span>
      <span class="s0">// In case of multiple bundles / HMR, some stack frames can have different URLs from others</span>
      <span class="s0">const urls = new Set&lt;string&gt;();</span>

      <span class="s0">stack.forEach(frame =&gt; {</span>
        <span class="s0">// These urls have been rewritten and normalized above.</span>
        <span class="s0">const sourceUrl = frame.file;</span>
        <span class="s0">// Skip `/debuggerWorker.js` which does not need symbolication.</span>
        <span class="s0">if (</span>
          <span class="s0">sourceUrl != null &amp;&amp;</span>
          <span class="s0">!urls.has(sourceUrl) &amp;&amp;</span>
          <span class="s0">!sourceUrl.endsWith('/debuggerWorker.js') &amp;&amp;</span>
          <span class="s0">sourceUrl.startsWith('http')</span>
        <span class="s0">) {</span>
          <span class="s0">urls.add(sourceUrl);</span>
        <span class="s0">}</span>
      <span class="s0">});</span>

      <span class="s0">debug('Getting source maps for symbolication');</span>
      <span class="s0">const sourceMaps = await Promise.all(</span>
        <span class="s0">Array.from(urls.values()).map(normalizedUrl =&gt;</span>
          <span class="s0">this._explodedSourceMapForBundleOptions(</span>
            <span class="s0">this._parseOptions(normalizedUrl),</span>
          <span class="s0">),</span>
        <span class="s0">),</span>
      <span class="s0">);</span>

      <span class="s0">debug('Performing fast symbolication');</span>
      <span class="s0">const symbolicatedStack = await symbolicate(</span>
        <span class="s0">stack,</span>
        <span class="s0">zip(urls.values(), sourceMaps),</span>
        <span class="s0">this._config,</span>
        <span class="s0">parsedBody.extraData ?? {},</span>
      <span class="s0">);</span>

      <span class="s0">debug('Symbolication done');</span>
      <span class="s0">res.end(</span>
        <span class="s0">JSON.stringify({</span>
          <span class="s0">codeFrame: getCodeFrame(urls, symbolicatedStack),</span>
          <span class="s0">stack: symbolicatedStack,</span>
        <span class="s0">}),</span>
      <span class="s0">);</span>
      <span class="s0">process.nextTick(() =&gt; {</span>
        <span class="s0">log(createActionEndEntry(symbolicatingLogEntry));</span>
      <span class="s0">});</span>
    <span class="s0">} catch (error) {</span>
      <span class="s0">console.error(error.stack || error);</span>
      <span class="s0">res.statusCode = 500;</span>
      <span class="s0">res.end(JSON.stringify({error: error.message}));</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">async _explodedSourceMapForBundleOptions(</span>
    <span class="s0">bundleOptions: BundleOptions,</span>
  <span class="s0">): Promise&lt;ExplodedSourceMap&gt; {</span>
    <span class="s0">const {</span>
      <span class="s0">entryFile,</span>
      <span class="s0">graphOptions,</span>
      <span class="s0">onProgress,</span>
      <span class="s0">resolverOptions,</span>
      <span class="s0">serializerOptions,</span>
      <span class="s0">transformOptions,</span>
    <span class="s0">} = splitBundleOptions(bundleOptions);</span>

    <span class="s0">/**</span>
     <span class="s0">* `entryFile` is relative to projectRoot, we need to use resolution function</span>
     <span class="s0">* to find the appropriate file with supported extensions.</span>
     <span class="s0">*/</span>
    <span class="s0">const resolvedEntryFilePath = await this._resolveRelativePath(entryFile, {</span>
      <span class="s0">relativeTo: 'server',</span>
      <span class="s0">resolverOptions,</span>
      <span class="s0">transformOptions,</span>
    <span class="s0">});</span>

    <span class="s0">const graphId = getGraphId(resolvedEntryFilePath, transformOptions, {</span>
      <span class="s0">unstable_allowRequireContext:</span>
        <span class="s0">this._config.transformer.unstable_allowRequireContext,</span>
      <span class="s0">resolverOptions,</span>
      <span class="s0">shallow: graphOptions.shallow,</span>
      <span class="s0">lazy: graphOptions.lazy,</span>
    <span class="s0">});</span>
    <span class="s0">let revision;</span>
    <span class="s0">const revPromise = this._bundler.getRevisionByGraphId(graphId);</span>
    <span class="s0">if (revPromise == null) {</span>
      <span class="s0">({revision} = await this._bundler.initializeGraph(</span>
        <span class="s0">resolvedEntryFilePath,</span>
        <span class="s0">transformOptions,</span>
        <span class="s0">resolverOptions,</span>
        <span class="s0">{</span>
          <span class="s0">onProgress,</span>
          <span class="s0">shallow: graphOptions.shallow,</span>
          <span class="s0">lazy: graphOptions.lazy,</span>
        <span class="s0">},</span>
      <span class="s0">));</span>
    <span class="s0">} else {</span>
      <span class="s0">({revision} = await this._bundler.updateGraph(await revPromise, false));</span>
    <span class="s0">}</span>

    <span class="s0">let {prepend, graph} = revision;</span>
    <span class="s0">if (serializerOptions.modulesOnly) {</span>
      <span class="s0">prepend = [];</span>
    <span class="s0">}</span>

    <span class="s0">return getExplodedSourceMap(</span>
      <span class="s0">[...prepend, ...this._getSortedModules(graph)],</span>
      <span class="s0">{</span>
        <span class="s0">processModuleFilter: this._config.serializer.processModuleFilter,</span>
      <span class="s0">},</span>
    <span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s0">async _resolveRelativePath(</span>
    <span class="s0">filePath: string,</span>
    <span class="s0">{</span>
      <span class="s0">relativeTo,</span>
      <span class="s0">resolverOptions,</span>
      <span class="s0">transformOptions,</span>
    <span class="s0">}: $ReadOnly&lt;{</span>
      <span class="s0">relativeTo: 'project' | 'server',</span>
      <span class="s0">resolverOptions: ResolverInputOptions,</span>
      <span class="s0">transformOptions: TransformInputOptions,</span>
    <span class="s0">}&gt;,</span>
  <span class="s0">): Promise&lt;string&gt; {</span>
    <span class="s0">const resolutionFn = await transformHelpers.getResolveDependencyFn(</span>
      <span class="s0">this._bundler.getBundler(),</span>
      <span class="s0">transformOptions.platform,</span>
      <span class="s0">resolverOptions,</span>
    <span class="s0">);</span>
    <span class="s0">const rootDir =</span>
      <span class="s0">relativeTo === 'server'</span>
        <span class="s0">? this._getServerRootDir()</span>
        <span class="s0">: this._config.projectRoot;</span>
    <span class="s0">return resolutionFn(`${rootDir}/.`, filePath).filePath;</span>
  <span class="s0">}</span>

  <span class="s0">getNewBuildNumber(): number {</span>
    <span class="s0">return this._nextBundleBuildNumber++;</span>
  <span class="s0">}</span>

  <span class="s0">getPlatforms(): $ReadOnlyArray&lt;string&gt; {</span>
    <span class="s0">return this._config.resolver.platforms;</span>
  <span class="s0">}</span>

  <span class="s0">getWatchFolders(): $ReadOnlyArray&lt;string&gt; {</span>
    <span class="s0">return this._config.watchFolders;</span>
  <span class="s0">}</span>

  <span class="s0">static DEFAULT_GRAPH_OPTIONS: $ReadOnly&lt;{</span>
    <span class="s0">customResolverOptions: CustomResolverOptions,</span>
    <span class="s0">customTransformOptions: CustomTransformOptions,</span>
    <span class="s0">dev: boolean,</span>
    <span class="s0">hot: boolean,</span>
    <span class="s0">minify: boolean,</span>
    <span class="s0">unstable_transformProfile: 'default',</span>
  <span class="s0">}&gt; = {</span>
    <span class="s0">customResolverOptions: Object.create(null),</span>
    <span class="s0">customTransformOptions: Object.create(null),</span>
    <span class="s0">dev: true,</span>
    <span class="s0">hot: false,</span>
    <span class="s0">minify: false,</span>
    <span class="s0">unstable_transformProfile: 'default',</span>
  <span class="s0">};</span>

  <span class="s0">static DEFAULT_BUNDLE_OPTIONS: {</span>
    <span class="s0">...typeof Server.DEFAULT_GRAPH_OPTIONS,</span>
    <span class="s0">excludeSource: false,</span>
    <span class="s0">inlineSourceMap: false,</span>
    <span class="s0">lazy: false,</span>
    <span class="s0">modulesOnly: false,</span>
    <span class="s0">onProgress: null,</span>
    <span class="s0">runModule: true,</span>
    <span class="s0">shallow: false,</span>
    <span class="s0">sourceMapUrl: null,</span>
    <span class="s0">sourceUrl: null,</span>
  <span class="s0">} = {</span>
    <span class="s0">...Server.DEFAULT_GRAPH_OPTIONS,</span>
    <span class="s0">excludeSource: false,</span>
    <span class="s0">inlineSourceMap: false,</span>
    <span class="s0">lazy: false,</span>
    <span class="s0">modulesOnly: false,</span>
    <span class="s0">onProgress: null,</span>
    <span class="s0">runModule: true,</span>
    <span class="s0">shallow: false,</span>
    <span class="s0">sourceMapUrl: null,</span>
    <span class="s0">sourceUrl: null,</span>
  <span class="s0">};</span>

  <span class="s0">_getServerRootDir(): string {</span>
    <span class="s0">return this._config.server.unstable_serverRoot ?? this._config.projectRoot;</span>
  <span class="s0">}</span>

  <span class="s0">_getEntryPointAbsolutePath(entryFile: string): string {</span>
    <span class="s0">return path.resolve(this._getServerRootDir(), entryFile);</span>
  <span class="s0">}</span>

  <span class="s0">// Wait for the server to finish initializing.</span>
  <span class="s0">async ready(): Promise&lt;void&gt; {</span>
    <span class="s0">await this._bundler.ready();</span>
  <span class="s0">}</span>

  <span class="s0">_shouldAddModuleToIgnoreList(module: Module&lt;&gt;): boolean {</span>
    <span class="s0">// TODO: Add flag to Module signifying whether it represents generated code</span>
    <span class="s0">// and clean up these heuristics.</span>
    <span class="s0">return (</span>
      <span class="s0">// Prelude code, see getPrependedScripts.js</span>
      <span class="s0">module.path === '__prelude__' ||</span>
      <span class="s0">// Generated require.context() module, see contextModule.js</span>
      <span class="s0">module.path.includes('?ctx=') ||</span>
      <span class="s0">this._config.serializer.isThirdPartyModule(module)</span>
    <span class="s0">);</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">function* zip&lt;X, Y&gt;(xs: Iterable&lt;X&gt;, ys: Iterable&lt;Y&gt;): Iterable&lt;[X, Y]&gt; {</span>
  <span class="s0">//$FlowIssue #9324959</span>
  <span class="s0">const ysIter: Iterator&lt;Y&gt; = ys[Symbol.iterator]();</span>
  <span class="s0">for (const x of xs) {</span>
    <span class="s0">const y = ysIter.next();</span>
    <span class="s0">if (y.done) {</span>
      <span class="s0">return;</span>
    <span class="s0">}</span>
    <span class="s0">yield [x, y.value];</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">function getBuildID(buildNumber: number): string {</span>
  <span class="s0">return buildNumber.toString(36);</span>
<span class="s0">}</span>

<span class="s0">module.exports = Server;</span>
</pre>
</body>
</html>
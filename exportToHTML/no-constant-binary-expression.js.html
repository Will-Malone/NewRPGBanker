<html>
<head>
<title>no-constant-binary-expression.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
no-constant-binary-expression.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @fileoverview Rule to flag constant comparisons and logical expressions that always/never short circuit 
 * @author Jordan Eldredge &lt;https://jordaneldredge.com&gt; 
 */</span>

<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">const globals = require(</span><span class="s2">&quot;globals&quot;</span><span class="s1">);</span>
<span class="s1">const { isNullLiteral, isConstant, isReferenceToGlobalVariable, isLogicalAssignmentOperator } = require(</span><span class="s2">&quot;./utils/ast-utils&quot;</span><span class="s1">);</span>

<span class="s1">const NUMERIC_OR_STRING_BINARY_OPERATORS = </span><span class="s3">new </span><span class="s1">Set([</span><span class="s2">&quot;+&quot;</span><span class="s1">, </span><span class="s2">&quot;-&quot;</span><span class="s1">, </span><span class="s2">&quot;*&quot;</span><span class="s1">, </span><span class="s2">&quot;/&quot;</span><span class="s1">, </span><span class="s2">&quot;%&quot;</span><span class="s1">, </span><span class="s2">&quot;|&quot;</span><span class="s1">, </span><span class="s2">&quot;^&quot;</span><span class="s1">, </span><span class="s2">&quot;&amp;&quot;</span><span class="s1">, </span><span class="s2">&quot;**&quot;</span><span class="s1">, </span><span class="s2">&quot;&lt;&lt;&quot;</span><span class="s1">, </span><span class="s2">&quot;&gt;&gt;&quot;</span><span class="s1">, </span><span class="s2">&quot;&gt;&gt;&gt;&quot;</span><span class="s1">]);</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Helpers</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/** 
 * Checks whether or not a node is `null` or `undefined`. Similar to the one 
 * found in ast-utils.js, but this one correctly handles the edge case that 
 * `undefined` has been redefined. 
 * @param {Scope} scope Scope in which the expression was found. 
 * @param {ASTNode} node A node to check. 
 * @returns {boolean} Whether or not the node is a `null` or `undefined`. 
 * @public 
 */</span>
<span class="s3">function </span><span class="s1">isNullOrUndefined(scope, node) {</span>
    <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">isNullLiteral(node) ||</span>
        <span class="s1">(node.type === </span><span class="s2">&quot;Identifier&quot; </span><span class="s1">&amp;&amp; node.name === </span><span class="s2">&quot;undefined&quot; </span><span class="s1">&amp;&amp; isReferenceToGlobalVariable(scope, node)) ||</span>
        <span class="s1">(node.type === </span><span class="s2">&quot;UnaryExpression&quot; </span><span class="s1">&amp;&amp; node.operator === </span><span class="s2">&quot;void&quot;</span><span class="s1">)</span>
    <span class="s1">);</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Test if an AST node has a statically knowable constant nullishness. Meaning, 
 * it will always resolve to a constant value of either: `null`, `undefined` 
 * or not `null` _or_ `undefined`. An expression that can vary between those 
 * three states at runtime would return `false`. 
 * @param {Scope} scope The scope in which the node was found. 
 * @param {ASTNode} node The AST node being tested. 
 * @param {boolean} nonNullish if `true` then nullish values are not considered constant. 
 * @returns {boolean} Does `node` have constant nullishness? 
 */</span>
<span class="s3">function </span><span class="s1">hasConstantNullishness(scope, node, nonNullish) {</span>
    <span class="s3">if </span><span class="s1">(nonNullish &amp;&amp; isNullOrUndefined(scope, node)) {</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">switch </span><span class="s1">(node.type) {</span>
        <span class="s3">case </span><span class="s2">&quot;ObjectExpression&quot;</span><span class="s1">: </span><span class="s0">// Objects are never nullish</span>
        <span class="s3">case </span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s1">: </span><span class="s0">// Arrays are never nullish</span>
        <span class="s3">case </span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s1">: </span><span class="s0">// Functions never nullish</span>
        <span class="s3">case </span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s1">: </span><span class="s0">// Functions are never nullish</span>
        <span class="s3">case </span><span class="s2">&quot;ClassExpression&quot;</span><span class="s1">: </span><span class="s0">// Classes are never nullish</span>
        <span class="s3">case </span><span class="s2">&quot;NewExpression&quot;</span><span class="s1">: </span><span class="s0">// Objects are never nullish</span>
        <span class="s3">case </span><span class="s2">&quot;Literal&quot;</span><span class="s1">: </span><span class="s0">// Nullish, or non-nullish, literals never change</span>
        <span class="s3">case </span><span class="s2">&quot;TemplateLiteral&quot;</span><span class="s1">: </span><span class="s0">// A string is never nullish</span>
        <span class="s3">case </span><span class="s2">&quot;UpdateExpression&quot;</span><span class="s1">: </span><span class="s0">// Numbers are never nullish</span>
        <span class="s3">case </span><span class="s2">&quot;BinaryExpression&quot;</span><span class="s1">: </span><span class="s0">// Numbers, strings, or booleans are never nullish</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;CallExpression&quot;</span><span class="s1">: {</span>
            <span class="s3">if </span><span class="s1">(node.callee.type !== </span><span class="s2">&quot;Identifier&quot;</span><span class="s1">) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">const functionName = node.callee.name;</span>

            <span class="s3">return </span><span class="s1">(functionName === </span><span class="s2">&quot;Boolean&quot; </span><span class="s1">|| functionName === </span><span class="s2">&quot;String&quot; </span><span class="s1">|| functionName === </span><span class="s2">&quot;Number&quot;</span><span class="s1">) &amp;&amp;</span>
                <span class="s1">isReferenceToGlobalVariable(scope, node.callee);</span>
        <span class="s1">}</span>
        <span class="s3">case </span><span class="s2">&quot;LogicalExpression&quot;</span><span class="s1">: {</span>
            <span class="s3">return </span><span class="s1">node.operator === </span><span class="s2">&quot;??&quot; </span><span class="s1">&amp;&amp; hasConstantNullishness(scope, node.right, </span><span class="s3">true</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">case </span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">(node.operator === </span><span class="s2">&quot;=&quot;</span><span class="s1">) {</span>
                <span class="s3">return </span><span class="s1">hasConstantNullishness(scope, node.right, nonNullish);</span>
            <span class="s1">}</span>

            <span class="s0">/* 
             * Handling short-circuiting assignment operators would require 
             * walking the scope. We won't attempt that (for now...) / 
             */</span>
            <span class="s3">if </span><span class="s1">(isLogicalAssignmentOperator(node.operator)) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s0">/* 
             * The remaining assignment expressions all result in a numeric or 
             * string (non-nullish) value: 
             *   &quot;+=&quot;, &quot;-=&quot;, &quot;*=&quot;, &quot;/=&quot;, &quot;%=&quot;, &quot;&lt;&lt;=&quot;, &quot;&gt;&gt;=&quot;, &quot;&gt;&gt;&gt;=&quot;, &quot;|=&quot;, &quot;^=&quot;, &quot;&amp;=&quot; 
             */</span>

            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;UnaryExpression&quot;</span><span class="s1">:</span>

            <span class="s0">/* 
             * &quot;void&quot; Always returns `undefined` 
             * &quot;typeof&quot; All types are strings, and thus non-nullish 
             * &quot;!&quot; Boolean is never nullish 
             * &quot;delete&quot; Returns a boolean, which is never nullish 
             * Math operators always return numbers or strings, neither of which 
             * are non-nullish &quot;+&quot;, &quot;-&quot;, &quot;~&quot; 
             */</span>

            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;SequenceExpression&quot;</span><span class="s1">: {</span>
            <span class="s1">const last = node.expressions[node.expressions.length - </span><span class="s4">1</span><span class="s1">];</span>

            <span class="s3">return </span><span class="s1">hasConstantNullishness(scope, last, nonNullish);</span>
        <span class="s1">}</span>
        <span class="s3">case </span><span class="s2">&quot;Identifier&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">node.name === </span><span class="s2">&quot;undefined&quot; </span><span class="s1">&amp;&amp; isReferenceToGlobalVariable(scope, node);</span>
        <span class="s3">case </span><span class="s2">&quot;JSXElement&quot;</span><span class="s1">: </span><span class="s0">// ESLint has a policy of not assuming any specific JSX behavior.</span>
        <span class="s3">case </span><span class="s2">&quot;JSXFragment&quot;</span><span class="s1">:</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">default</span><span class="s1">:</span>
            <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Test if an AST node is a boolean value that never changes. Specifically we 
 * test for: 
 * 1. Literal booleans (`true` or `false`) 
 * 2. Unary `!` expressions with a constant value 
 * 3. Constant booleans created via the `Boolean` global function 
 * @param {Scope} scope The scope in which the node was found. 
 * @param {ASTNode} node The node to test 
 * @returns {boolean} Is `node` guaranteed to be a boolean? 
 */</span>
<span class="s3">function </span><span class="s1">isStaticBoolean(scope, node) {</span>
    <span class="s3">switch </span><span class="s1">(node.type) {</span>
        <span class="s3">case </span><span class="s2">&quot;Literal&quot;</span><span class="s1">:</span>
            <span class="s3">return typeof </span><span class="s1">node.value === </span><span class="s2">&quot;boolean&quot;</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;CallExpression&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">node.callee.type === </span><span class="s2">&quot;Identifier&quot; </span><span class="s1">&amp;&amp; node.callee.name === </span><span class="s2">&quot;Boolean&quot; </span><span class="s1">&amp;&amp;</span>
              <span class="s1">isReferenceToGlobalVariable(scope, node.callee) &amp;&amp;</span>
              <span class="s1">(node.arguments.length === </span><span class="s4">0 </span><span class="s1">|| isConstant(scope, node.arguments[</span><span class="s4">0</span><span class="s1">], </span><span class="s3">true</span><span class="s1">));</span>
        <span class="s3">case </span><span class="s2">&quot;UnaryExpression&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">node.operator === </span><span class="s2">&quot;!&quot; </span><span class="s1">&amp;&amp; isConstant(scope, node.argument, </span><span class="s3">true</span><span class="s1">);</span>
        <span class="s3">default</span><span class="s1">:</span>
            <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>


<span class="s0">/** 
 * Test if an AST node will always give the same result when compared to a 
 * boolean value. Note that comparison to boolean values is different than 
 * truthiness. 
 * https://262.ecma-international.org/5.1/#sec-11.9.3 
 * 
 * Javascript `==` operator works by converting the boolean to `1` (true) or 
 * `+0` (false) and then checks the values `==` equality to that number. 
 * @param {Scope} scope The scope in which node was found. 
 * @param {ASTNode} node The node to test. 
 * @returns {boolean} Will `node` always coerce to the same boolean value? 
 */</span>
<span class="s3">function </span><span class="s1">hasConstantLooseBooleanComparison(scope, node) {</span>
    <span class="s3">switch </span><span class="s1">(node.type) {</span>
        <span class="s3">case </span><span class="s2">&quot;ObjectExpression&quot;</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">&quot;ClassExpression&quot;</span><span class="s1">:</span>

            <span class="s0">/** 
             * In theory objects like: 
             * 
             * `{toString: () =&gt; a}` 
             * `{valueOf: () =&gt; a}` 
             * 
             * Or a classes like: 
             * 
             * `class { static toString() { return a } }` 
             * `class { static valueOf() { return a } }` 
             * 
             * Are not constant verifiably when `inBooleanPosition` is 
             * false, but it's an edge case we've opted not to handle. 
             */</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s1">: {</span>
            <span class="s1">const nonSpreadElements = node.elements.filter(e =&gt;</span>

                <span class="s0">// Elements can be `null` in sparse arrays: `[,,]`;</span>
                <span class="s1">e !== </span><span class="s3">null </span><span class="s1">&amp;&amp; e.type !== </span><span class="s2">&quot;SpreadElement&quot;</span><span class="s1">);</span>


            <span class="s0">/* 
             * Possible future direction if needed: We could check if the 
             * single value would result in variable boolean comparison. 
             * For now we will err on the side of caution since `[x]` could 
             * evaluate to `[0]` or `[1]`. 
             */</span>
            <span class="s3">return </span><span class="s1">node.elements.length === </span><span class="s4">0 </span><span class="s1">|| nonSpreadElements.length &gt; </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">case </span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s1">:</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;UnaryExpression&quot;</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">(node.operator === </span><span class="s2">&quot;void&quot; </span><span class="s1">|| </span><span class="s0">// Always returns `undefined`</span>
                <span class="s1">node.operator === </span><span class="s2">&quot;typeof&quot; </span><span class="s0">// All `typeof` strings, when coerced to number, are not 0 or 1.</span>
            <span class="s1">) {</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(node.operator === </span><span class="s2">&quot;!&quot;</span><span class="s1">) {</span>
                <span class="s3">return </span><span class="s1">isConstant(scope, node.argument, </span><span class="s3">true</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s0">/* 
             * We won't try to reason about +, -, ~, or delete 
             * In theory, for the mathematical operators, we could look at the 
             * argument and try to determine if it coerces to a constant numeric 
             * value. 
             */</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;NewExpression&quot;</span><span class="s1">: </span><span class="s0">// Objects might have custom `.valueOf` or `.toString`.</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;CallExpression&quot;</span><span class="s1">: {</span>
            <span class="s3">if </span><span class="s1">(node.callee.type === </span><span class="s2">&quot;Identifier&quot; </span><span class="s1">&amp;&amp;</span>
                <span class="s1">node.callee.name === </span><span class="s2">&quot;Boolean&quot; </span><span class="s1">&amp;&amp;</span>
                <span class="s1">isReferenceToGlobalVariable(scope, node.callee)</span>
            <span class="s1">) {</span>
                <span class="s3">return </span><span class="s1">node.arguments.length === </span><span class="s4">0 </span><span class="s1">|| isConstant(scope, node.arguments[</span><span class="s4">0</span><span class="s1">], </span><span class="s3">true</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">case </span><span class="s2">&quot;Literal&quot;</span><span class="s1">: </span><span class="s0">// True or false, literals never change</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;Identifier&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">node.name === </span><span class="s2">&quot;undefined&quot; </span><span class="s1">&amp;&amp; isReferenceToGlobalVariable(scope, node);</span>
        <span class="s3">case </span><span class="s2">&quot;TemplateLiteral&quot;</span><span class="s1">:</span>

            <span class="s0">/* 
             * In theory we could try to check if the quasi are sufficient to 
             * prove that the expression will always be true, but it would be 
             * tricky to get right. For example: `000.${foo}000` 
             */</span>
            <span class="s3">return </span><span class="s1">node.expressions.length === </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">(node.operator === </span><span class="s2">&quot;=&quot;</span><span class="s1">) {</span>
                <span class="s3">return </span><span class="s1">hasConstantLooseBooleanComparison(scope, node.right);</span>
            <span class="s1">}</span>

            <span class="s0">/* 
             * Handling short-circuiting assignment operators would require 
             * walking the scope. We won't attempt that (for now...) 
             * 
             * The remaining assignment expressions all result in a numeric or 
             * string (non-nullish) values which could be truthy or falsy: 
             *   &quot;+=&quot;, &quot;-=&quot;, &quot;*=&quot;, &quot;/=&quot;, &quot;%=&quot;, &quot;&lt;&lt;=&quot;, &quot;&gt;&gt;=&quot;, &quot;&gt;&gt;&gt;=&quot;, &quot;|=&quot;, &quot;^=&quot;, &quot;&amp;=&quot; 
             */</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;SequenceExpression&quot;</span><span class="s1">: {</span>
            <span class="s1">const last = node.expressions[node.expressions.length - </span><span class="s4">1</span><span class="s1">];</span>

            <span class="s3">return </span><span class="s1">hasConstantLooseBooleanComparison(scope, last);</span>
        <span class="s1">}</span>
        <span class="s3">case </span><span class="s2">&quot;JSXElement&quot;</span><span class="s1">: </span><span class="s0">// ESLint has a policy of not assuming any specific JSX behavior.</span>
        <span class="s3">case </span><span class="s2">&quot;JSXFragment&quot;</span><span class="s1">:</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">default</span><span class="s1">:</span>
            <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>


<span class="s0">/** 
 * Test if an AST node will always give the same result when _strictly_ compared 
 * to a boolean value. This can happen if the expression can never be boolean, or 
 * if it is always the same boolean value. 
 * @param {Scope} scope The scope in which the node was found. 
 * @param {ASTNode} node The node to test 
 * @returns {boolean} Will `node` always give the same result when compared to a 
 * static boolean value? 
 */</span>
<span class="s3">function </span><span class="s1">hasConstantStrictBooleanComparison(scope, node) {</span>
    <span class="s3">switch </span><span class="s1">(node.type) {</span>
        <span class="s3">case </span><span class="s2">&quot;ObjectExpression&quot;</span><span class="s1">: </span><span class="s0">// Objects are not booleans</span>
        <span class="s3">case </span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s1">: </span><span class="s0">// Arrays are not booleans</span>
        <span class="s3">case </span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s1">: </span><span class="s0">// Functions are not booleans</span>
        <span class="s3">case </span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">&quot;ClassExpression&quot;</span><span class="s1">: </span><span class="s0">// Classes are not booleans</span>
        <span class="s3">case </span><span class="s2">&quot;NewExpression&quot;</span><span class="s1">: </span><span class="s0">// Objects are not booleans</span>
        <span class="s3">case </span><span class="s2">&quot;TemplateLiteral&quot;</span><span class="s1">: </span><span class="s0">// Strings are not booleans</span>
        <span class="s3">case </span><span class="s2">&quot;Literal&quot;</span><span class="s1">: </span><span class="s0">// True, false, or not boolean, literals never change.</span>
        <span class="s3">case </span><span class="s2">&quot;UpdateExpression&quot;</span><span class="s1">: </span><span class="s0">// Numbers are not booleans</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;BinaryExpression&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">NUMERIC_OR_STRING_BINARY_OPERATORS.has(node.operator);</span>
        <span class="s3">case </span><span class="s2">&quot;UnaryExpression&quot;</span><span class="s1">: {</span>
            <span class="s3">if </span><span class="s1">(node.operator === </span><span class="s2">&quot;delete&quot;</span><span class="s1">) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(node.operator === </span><span class="s2">&quot;!&quot;</span><span class="s1">) {</span>
                <span class="s3">return </span><span class="s1">isConstant(scope, node.argument, </span><span class="s3">true</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s0">/* 
             * The remaining operators return either strings or numbers, neither 
             * of which are boolean. 
             */</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">case </span><span class="s2">&quot;SequenceExpression&quot;</span><span class="s1">: {</span>
            <span class="s1">const last = node.expressions[node.expressions.length - </span><span class="s4">1</span><span class="s1">];</span>

            <span class="s3">return </span><span class="s1">hasConstantStrictBooleanComparison(scope, last);</span>
        <span class="s1">}</span>
        <span class="s3">case </span><span class="s2">&quot;Identifier&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">node.name === </span><span class="s2">&quot;undefined&quot; </span><span class="s1">&amp;&amp; isReferenceToGlobalVariable(scope, node);</span>
        <span class="s3">case </span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">(node.operator === </span><span class="s2">&quot;=&quot;</span><span class="s1">) {</span>
                <span class="s3">return </span><span class="s1">hasConstantStrictBooleanComparison(scope, node.right);</span>
            <span class="s1">}</span>

            <span class="s0">/* 
             * Handling short-circuiting assignment operators would require 
             * walking the scope. We won't attempt that (for now...) 
             */</span>
            <span class="s3">if </span><span class="s1">(isLogicalAssignmentOperator(node.operator)) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s0">/* 
             * The remaining assignment expressions all result in either a number 
             * or a string, neither of which can ever be boolean. 
             */</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;CallExpression&quot;</span><span class="s1">: {</span>
            <span class="s3">if </span><span class="s1">(node.callee.type !== </span><span class="s2">&quot;Identifier&quot;</span><span class="s1">) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">const functionName = node.callee.name;</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">(functionName === </span><span class="s2">&quot;String&quot; </span><span class="s1">|| functionName === </span><span class="s2">&quot;Number&quot;</span><span class="s1">) &amp;&amp;</span>
                <span class="s1">isReferenceToGlobalVariable(scope, node.callee)</span>
            <span class="s1">) {</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(functionName === </span><span class="s2">&quot;Boolean&quot; </span><span class="s1">&amp;&amp; isReferenceToGlobalVariable(scope, node.callee)) {</span>
                <span class="s3">return </span><span class="s1">(</span>
                    <span class="s1">node.arguments.length === </span><span class="s4">0 </span><span class="s1">|| isConstant(scope, node.arguments[</span><span class="s4">0</span><span class="s1">], </span><span class="s3">true</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">case </span><span class="s2">&quot;JSXElement&quot;</span><span class="s1">: </span><span class="s0">// ESLint has a policy of not assuming any specific JSX behavior.</span>
        <span class="s3">case </span><span class="s2">&quot;JSXFragment&quot;</span><span class="s1">:</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">default</span><span class="s1">:</span>
            <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Test if an AST node will always result in a newly constructed object 
 * @param {Scope} scope The scope in which the node was found. 
 * @param {ASTNode} node The node to test 
 * @returns {boolean} Will `node` always be new? 
 */</span>
<span class="s3">function </span><span class="s1">isAlwaysNew(scope, node) {</span>
    <span class="s3">switch </span><span class="s1">(node.type) {</span>
        <span class="s3">case </span><span class="s2">&quot;ObjectExpression&quot;</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">&quot;ClassExpression&quot;</span><span class="s1">:</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;NewExpression&quot;</span><span class="s1">: {</span>
            <span class="s3">if </span><span class="s1">(node.callee.type !== </span><span class="s2">&quot;Identifier&quot;</span><span class="s1">) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s0">/* 
             * All the built-in constructors are always new, but 
             * user-defined constructors could return a sentinel 
             * object. 
             * 
             * Catching these is especially useful for primitive constructors 
             * which return boxed values, a surprising gotcha' in JavaScript. 
             */</span>
            <span class="s3">return </span><span class="s1">Object.hasOwnProperty.call(globals.builtin, node.callee.name) &amp;&amp;</span>
              <span class="s1">isReferenceToGlobalVariable(scope, node.callee);</span>
        <span class="s1">}</span>
        <span class="s3">case </span><span class="s2">&quot;Literal&quot;</span><span class="s1">:</span>

            <span class="s0">// Regular expressions are objects, and thus always new</span>
            <span class="s3">return typeof </span><span class="s1">node.regex === </span><span class="s2">&quot;object&quot;</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;SequenceExpression&quot;</span><span class="s1">: {</span>
            <span class="s1">const last = node.expressions[node.expressions.length - </span><span class="s4">1</span><span class="s1">];</span>

            <span class="s3">return </span><span class="s1">isAlwaysNew(scope, last);</span>
        <span class="s1">}</span>
        <span class="s3">case </span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">(node.operator === </span><span class="s2">&quot;=&quot;</span><span class="s1">) {</span>
                <span class="s3">return </span><span class="s1">isAlwaysNew(scope, node.right);</span>
            <span class="s1">}</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">&quot;ConditionalExpression&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">isAlwaysNew(scope, node.consequent) &amp;&amp; isAlwaysNew(scope, node.alternate);</span>
        <span class="s3">case </span><span class="s2">&quot;JSXElement&quot;</span><span class="s1">: </span><span class="s0">// ESLint has a policy of not assuming any specific JSX behavior.</span>
        <span class="s3">case </span><span class="s2">&quot;JSXFragment&quot;</span><span class="s1">:</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">default</span><span class="s1">:</span>
            <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Checks if one operand will cause the result to be constant. 
 * @param {Scope} scope Scope in which the expression was found. 
 * @param {ASTNode} a One side of the expression 
 * @param {ASTNode} b The other side of the expression 
 * @param {string} operator The binary expression operator 
 * @returns {ASTNode | null} The node which will cause the expression to have a constant result. 
 */</span>
<span class="s3">function </span><span class="s1">findBinaryExpressionConstantOperand(scope, a, b, operator) {</span>
    <span class="s3">if </span><span class="s1">(operator === </span><span class="s2">&quot;==&quot; </span><span class="s1">|| operator === </span><span class="s2">&quot;!=&quot;</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">(isNullOrUndefined(scope, a) &amp;&amp; hasConstantNullishness(scope, b, </span><span class="s3">false</span><span class="s1">)) ||</span>
            <span class="s1">(isStaticBoolean(scope, a) &amp;&amp; hasConstantLooseBooleanComparison(scope, b))</span>
        <span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">b;</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(operator === </span><span class="s2">&quot;===&quot; </span><span class="s1">|| operator === </span><span class="s2">&quot;!==&quot;</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">(isNullOrUndefined(scope, a) &amp;&amp; hasConstantNullishness(scope, b, </span><span class="s3">false</span><span class="s1">)) ||</span>
            <span class="s1">(isStaticBoolean(scope, a) &amp;&amp; hasConstantStrictBooleanComparison(scope, b))</span>
        <span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">b;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Rule Definition</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/** @type {import('../shared/types').Rule} */</span>
<span class="s1">module.exports = {</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s2">&quot;problem&quot;</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s2">&quot;Disallow expressions where the operation doesn't affect the value&quot;</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">url: </span><span class="s2">&quot;https://eslint.org/docs/latest/rules/no-constant-binary-expression&quot;</span>
        <span class="s1">},</span>
        <span class="s1">schema: [],</span>
        <span class="s1">messages: {</span>
            <span class="s1">constantBinaryOperand: </span><span class="s2">&quot;Unexpected constant binary expression. Compares constantly with the {{otherSide}}-hand side of the `{{operator}}`.&quot;</span><span class="s1">,</span>
            <span class="s1">constantShortCircuit: </span><span class="s2">&quot;Unexpected constant {{property}} on the left-hand side of a `{{operator}}` expression.&quot;</span><span class="s1">,</span>
            <span class="s1">alwaysNew: </span><span class="s2">&quot;Unexpected comparison to newly constructed object. These two values can never be equal.&quot;</span><span class="s1">,</span>
            <span class="s1">bothAlwaysNew: </span><span class="s2">&quot;Unexpected comparison of two newly constructed objects. These two values can never be equal.&quot;</span>
        <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s1">create(context) {</span>
        <span class="s1">const sourceCode = context.sourceCode;</span>

        <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">LogicalExpression(node) {</span>
                <span class="s1">const { operator, left } = node;</span>
                <span class="s1">const scope = sourceCode.getScope(node);</span>

                <span class="s3">if </span><span class="s1">((operator === </span><span class="s2">&quot;&amp;&amp;&quot; </span><span class="s1">|| operator === </span><span class="s2">&quot;||&quot;</span><span class="s1">) &amp;&amp; isConstant(scope, left, </span><span class="s3">true</span><span class="s1">)) {</span>
                    <span class="s1">context.report({ node: left, messageId: </span><span class="s2">&quot;constantShortCircuit&quot;</span><span class="s1">, data: { property: </span><span class="s2">&quot;truthiness&quot;</span><span class="s1">, operator } });</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(operator === </span><span class="s2">&quot;??&quot; </span><span class="s1">&amp;&amp; hasConstantNullishness(scope, left, </span><span class="s3">false</span><span class="s1">)) {</span>
                    <span class="s1">context.report({ node: left, messageId: </span><span class="s2">&quot;constantShortCircuit&quot;</span><span class="s1">, data: { property: </span><span class="s2">&quot;nullishness&quot;</span><span class="s1">, operator } });</span>
                <span class="s1">}</span>
            <span class="s1">},</span>
            <span class="s1">BinaryExpression(node) {</span>
                <span class="s1">const scope = sourceCode.getScope(node);</span>
                <span class="s1">const { right, left, operator } = node;</span>
                <span class="s1">const rightConstantOperand = findBinaryExpressionConstantOperand(scope, left, right, operator);</span>
                <span class="s1">const leftConstantOperand = findBinaryExpressionConstantOperand(scope, right, left, operator);</span>

                <span class="s3">if </span><span class="s1">(rightConstantOperand) {</span>
                    <span class="s1">context.report({ node: rightConstantOperand, messageId: </span><span class="s2">&quot;constantBinaryOperand&quot;</span><span class="s1">, data: { operator, otherSide: </span><span class="s2">&quot;left&quot; </span><span class="s1">} });</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(leftConstantOperand) {</span>
                    <span class="s1">context.report({ node: leftConstantOperand, messageId: </span><span class="s2">&quot;constantBinaryOperand&quot;</span><span class="s1">, data: { operator, otherSide: </span><span class="s2">&quot;right&quot; </span><span class="s1">} });</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(operator === </span><span class="s2">&quot;===&quot; </span><span class="s1">|| operator === </span><span class="s2">&quot;!==&quot;</span><span class="s1">) {</span>
                    <span class="s3">if </span><span class="s1">(isAlwaysNew(scope, left)) {</span>
                        <span class="s1">context.report({ node: left, messageId: </span><span class="s2">&quot;alwaysNew&quot; </span><span class="s1">});</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isAlwaysNew(scope, right)) {</span>
                        <span class="s1">context.report({ node: right, messageId: </span><span class="s2">&quot;alwaysNew&quot; </span><span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(operator === </span><span class="s2">&quot;==&quot; </span><span class="s1">|| operator === </span><span class="s2">&quot;!=&quot;</span><span class="s1">) {</span>

                    <span class="s0">/* 
                     * If both sides are &quot;new&quot;, then both sides are objects and 
                     * therefore they will be compared by reference even with `==` 
                     * equality. 
                     */</span>
                    <span class="s3">if </span><span class="s1">(isAlwaysNew(scope, left) &amp;&amp; isAlwaysNew(scope, right)) {</span>
                        <span class="s1">context.report({ node: left, messageId: </span><span class="s2">&quot;bothAlwaysNew&quot; </span><span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>

            <span class="s1">}</span>

            <span class="s0">/* 
             * In theory we could handle short-circuiting assignment operators, 
             * for some constant values, but that would require walking the 
             * scope to find the value of the variable being assigned. This is 
             * dependant on https://github.com/eslint/eslint/issues/13776 
             * 
             * AssignmentExpression() {}, 
             */</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
<span class="s1">};</span>
</pre>
</body>
</html>
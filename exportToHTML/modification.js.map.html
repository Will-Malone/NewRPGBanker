<html>
<head>
<title>modification.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
modification.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_cache&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_hoister&quot;</span><span class="s0">,</span><span class="s1">&quot;_index&quot;</span><span class="s0">,</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;assertExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportNamedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isSequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;insertBefore&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes_&quot;</span><span class="s0">,</span><span class="s1">&quot;_assertUnremoved&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes&quot;</span><span class="s0">,</span><span class="s1">&quot;_verifyNodeList&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isLabeledStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDefaultDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isNodeType&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXElement&quot;</span><span class="s0">,</span><span class="s1">&quot;isForStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceExpressionWithStatements&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;container&quot;</span><span class="s0">,</span><span class="s1">&quot;_containerInsertBefore&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatementOrBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldInsertCurrentNode&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;unshiftContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;_containerInsert&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;updateSiblingKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;to&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;getSibling&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;queue&quot;</span><span class="s0">,</span><span class="s1">&quot;pushContext&quot;</span><span class="s0">,</span><span class="s1">&quot;contexts&quot;</span><span class="s0">,</span><span class="s1">&quot;_getQueueContexts&quot;</span><span class="s0">,</span><span class="s1">&quot;setScope&quot;</span><span class="s0">,</span><span class="s1">&quot;debug&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;_containerInsertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;last&quot;</span><span class="s0">,</span><span class="s1">&quot;arr&quot;</span><span class="s0">,</span><span class="s1">&quot;isHiddenInSequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;expressions&quot;</span><span class="s0">,</span><span class="s1">&quot;isAlmostConstantAssignment&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;blockScope&quot;</span><span class="s0">,</span><span class="s1">&quot;getBlockParent&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;constantViolations&quot;</span><span class="s0">,</span><span class="s1">&quot;insertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;isPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;isPure&quot;</span><span class="s0">,</span><span class="s1">&quot;isMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;temp&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDeclaredUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;pushContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;fromIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;incrementBy&quot;</span><span class="s0">,</span><span class="s1">&quot;pathCache&quot;</span><span class="s0">,</span><span class="s1">&quot;msg&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;NodePath&quot;</span><span class="s0">,</span><span class="s1">&quot;listKey&quot;</span><span class="s0">,</span><span class="s1">&quot;setContext&quot;</span><span class="s0">,</span><span class="s1">&quot;verifiedNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWithMultiple&quot;</span><span class="s0">,</span><span class="s1">&quot;hoist&quot;</span><span class="s0">,</span><span class="s1">&quot;hoister&quot;</span><span class="s0">,</span><span class="s1">&quot;PathHoister&quot;</span><span class="s0">,</span><span class="s1">&quot;run&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/path/modification.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// This file contains methods that modify the path/node in some ways.</span><span class="s3">\n\n</span><span class="s1">import { path as pathCache } from </span><span class="s3">\&quot;</span><span class="s1">../cache</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import PathHoister from </span><span class="s3">\&quot;</span><span class="s1">./lib/hoister</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import NodePath from </span><span class="s3">\&quot;</span><span class="s1">./index</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">arrowFunctionExpression,</span><span class="s3">\n  </span><span class="s1">assertExpression,</span><span class="s3">\n  </span><span class="s1">assignmentExpression,</span><span class="s3">\n  </span><span class="s1">blockStatement,</span><span class="s3">\n  </span><span class="s1">callExpression,</span><span class="s3">\n  </span><span class="s1">cloneNode,</span><span class="s3">\n  </span><span class="s1">expressionStatement,</span><span class="s3">\n  </span><span class="s1">isAssignmentExpression,</span><span class="s3">\n  </span><span class="s1">isCallExpression,</span><span class="s3">\n  </span><span class="s1">isExportNamedDeclaration,</span><span class="s3">\n  </span><span class="s1">isExpression,</span><span class="s3">\n  </span><span class="s1">isIdentifier,</span><span class="s3">\n  </span><span class="s1">isSequenceExpression,</span><span class="s3">\n  </span><span class="s1">isSuper,</span><span class="s3">\n  </span><span class="s1">thisExpression,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type Scope from </span><span class="s3">\&quot;</span><span class="s1">../scope</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Insert the provided nodes before the current one.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function insertBefore(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">nodes_: t.Node | t.Node[],</span><span class="s3">\n</span><span class="s1">): NodePath[] {</span><span class="s3">\n  </span><span class="s1">this._assertUnremoved();</span><span class="s3">\n\n  </span><span class="s1">const nodes = this._verifyNodeList(nodes_);</span><span class="s3">\n\n  </span><span class="s1">const { parentPath, parent } = this;</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">parentPath.isExpressionStatement() ||</span><span class="s3">\n    </span><span class="s1">parentPath.isLabeledStatement() ||</span><span class="s3">\n    </span><span class="s1">// https://github.com/babel/babel/issues/15293</span><span class="s3">\n    </span><span class="s1">// When Babel transforms `export class String { field }`, the class properties plugin will inject the defineProperty</span><span class="s3">\n    </span><span class="s1">// helper, which depends on the builtins e.g. String, Number, Symbol, etc. To prevent them from being shadowed by local</span><span class="s3">\n    </span><span class="s1">// exports, the helper injector replaces the named export into `class _String { field }; export { _String as String }`,</span><span class="s3">\n    </span><span class="s1">// with `parentPath` here changed to the moved ClassDeclaration, causing rare inconsistency between `parent` and `parentPath`.</span><span class="s3">\n    </span><span class="s1">// Here we retrieve the parent type from the `parent` property. This is a temporary fix and we should revisit when</span><span class="s3">\n    </span><span class="s1">// helpers should get injected.</span><span class="s3">\n    </span><span class="s1">isExportNamedDeclaration(parent) ||</span><span class="s3">\n    </span><span class="s1">(parentPath.isExportDefaultDeclaration() &amp;&amp; this.isDeclaration())</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return parentPath.insertBefore(nodes);</span><span class="s3">\n  </span><span class="s1">} else if (</span><span class="s3">\n    </span><span class="s1">(this.isNodeType(</span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; !this.isJSXElement()) ||</span><span class="s3">\n    </span><span class="s1">(parentPath.isForStatement() &amp;&amp; this.key === </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (this.node) nodes.push(this.node);</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): check that nodes is an array of statements</span><span class="s3">\n    </span><span class="s1">return this.replaceExpressionWithStatements(nodes);</span><span class="s3">\n  </span><span class="s1">} else if (Array.isArray(this.container)) {</span><span class="s3">\n    </span><span class="s1">return this._containerInsertBefore(nodes);</span><span class="s3">\n  </span><span class="s1">} else if (this.isStatementOrBlock()) {</span><span class="s3">\n    </span><span class="s1">const node = this.node as t.Statement;</span><span class="s3">\n    </span><span class="s1">const shouldInsertCurrentNode =</span><span class="s3">\n      </span><span class="s1">node &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(!this.isExpressionStatement() ||</span><span class="s3">\n        </span><span class="s1">(node as t.ExpressionStatement).expression != null);</span><span class="s3">\n\n    </span><span class="s1">this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));</span><span class="s3">\n    </span><span class="s1">return (this as NodePath&lt;t.BlockStatement&gt;).unshiftContainer(</span><span class="s3">\n      \&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error Fixme: refine nodes to t.BlockStatement[</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">] when this is a BlockStatement path</span><span class="s3">\n      </span><span class="s1">nodes,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">We don't know what to do with this node type. </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        \&quot;</span><span class="s1">We were previously a Statement but we can't fit in here?</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _containerInsert&lt;N extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">from: number,</span><span class="s3">\n  </span><span class="s1">nodes: N[],</span><span class="s3">\n</span><span class="s1">): NodePath&lt;N&gt;[] {</span><span class="s3">\n  </span><span class="s1">this.updateSiblingKeys(from, nodes.length);</span><span class="s3">\n\n  </span><span class="s1">const paths: NodePath&lt;N&gt;[] = [];</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): this.container could be a NodePath</span><span class="s3">\n  </span><span class="s1">this.container.splice(from, 0, ...nodes);</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">const to = from + i;</span><span class="s3">\n    </span><span class="s1">const path = this.getSibling(to) as NodePath&lt;N&gt;;</span><span class="s3">\n    </span><span class="s1">paths.push(path);</span><span class="s3">\n\n    </span><span class="s1">if (this.context &amp;&amp; this.context.queue) {</span><span class="s3">\n      </span><span class="s1">path.pushContext(this.context);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const contexts = this._getQueueContexts();</span><span class="s3">\n\n  </span><span class="s1">for (const path of paths) {</span><span class="s3">\n    </span><span class="s1">path.setScope();</span><span class="s3">\n    </span><span class="s1">path.debug(</span><span class="s3">\&quot;</span><span class="s1">Inserted.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">for (const context of contexts) {</span><span class="s3">\n      </span><span class="s1">context.maybeQueue(path, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return paths;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _containerInsertBefore&lt;N extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">nodes: N[],</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return this._containerInsert(this.key as number, nodes);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _containerInsertAfter&lt;N extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">nodes: N[],</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return this._containerInsert((this.key as number) + 1, nodes);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const last = &lt;T&gt;(arr: T[]) =&gt; arr[arr.length - 1];</span><span class="s3">\n\n</span><span class="s1">function isHiddenInSequenceExpression(path: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">isSequenceExpression(path.parent) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(last(path.parent.expressions) !== path.node ||</span><span class="s3">\n      </span><span class="s1">isHiddenInSequenceExpression(path.parentPath))</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isAlmostConstantAssignment(</span><span class="s3">\n  </span><span class="s1">node: t.Node,</span><span class="s3">\n  </span><span class="s1">scope: Scope,</span><span class="s3">\n</span><span class="s1">): node is t.AssignmentExpression &amp; { left: t.Identifier } {</span><span class="s3">\n  </span><span class="s1">if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Not every scope can contain variables. For example, we might be in</span><span class="s3">\n  </span><span class="s1">// a ClassScope either in the ClassHeritage or in a computed key.</span><span class="s3">\n  </span><span class="s1">const blockScope = scope.getBlockParent();</span><span class="s3">\n\n  </span><span class="s1">// If the variable is defined in the current scope and only assigned here,</span><span class="s3">\n  </span><span class="s1">// we can be sure that its value won't change.</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">blockScope.hasOwnBinding(node.left.name) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">blockScope.getOwnBinding(node.left.name).constantViolations.length &lt;= 1</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Insert the provided nodes after the current one. When inserting nodes after an</span><span class="s3">\n </span><span class="s1">* expression, ensure that the completion record is correct by pushing the current node.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function insertAfter(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">nodes_: t.Node | t.Node[],</span><span class="s3">\n</span><span class="s1">): NodePath[] {</span><span class="s3">\n  </span><span class="s1">this._assertUnremoved();</span><span class="s3">\n\n  </span><span class="s1">if (this.isSequenceExpression()) {</span><span class="s3">\n    </span><span class="s1">return last(this.get(</span><span class="s3">\&quot;</span><span class="s1">expressions</span><span class="s3">\&quot;</span><span class="s1">)).insertAfter(nodes_);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const nodes = this._verifyNodeList(nodes_);</span><span class="s3">\n\n  </span><span class="s1">const { parentPath, parent } = this;</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">parentPath.isExpressionStatement() ||</span><span class="s3">\n    </span><span class="s1">parentPath.isLabeledStatement() ||</span><span class="s3">\n    </span><span class="s1">// see insertBefore</span><span class="s3">\n    </span><span class="s1">isExportNamedDeclaration(parent) ||</span><span class="s3">\n    </span><span class="s1">(parentPath.isExportDefaultDeclaration() &amp;&amp; this.isDeclaration())</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return parentPath.insertAfter(</span><span class="s3">\n      </span><span class="s1">nodes.map(node =&gt; {</span><span class="s3">\n        </span><span class="s1">// Usually after an expression we can safely insert another expression:</span><span class="s3">\n        </span><span class="s1">//   A.insertAfter(B)</span><span class="s3">\n        </span><span class="s1">//     foo = A;  -&gt; foo = (A, B);</span><span class="s3">\n        </span><span class="s1">// If A is an expression statement, it isn't safe anymore so we need to</span><span class="s3">\n        </span><span class="s1">// convert B to an expression statement</span><span class="s3">\n        </span><span class="s1">//     A;        -&gt; A; B // No semicolon! It could break if followed by [!</span><span class="s3">\n        </span><span class="s1">return isExpression(node) ? expressionStatement(node) : node;</span><span class="s3">\n      </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else if (</span><span class="s3">\n    </span><span class="s1">(this.isNodeType(</span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!this.isJSXElement() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!parentPath.isJSXElement()) ||</span><span class="s3">\n    </span><span class="s1">(parentPath.isForStatement() &amp;&amp; this.key === </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (this.node) {</span><span class="s3">\n      </span><span class="s1">const node = this.node as t.Expression | t.VariableDeclaration;</span><span class="s3">\n      </span><span class="s1">let { scope } = this;</span><span class="s3">\n\n      </span><span class="s1">if (scope.path.isPattern()) {</span><span class="s3">\n        </span><span class="s1">assertExpression(node);</span><span class="s3">\n\n        </span><span class="s1">this.replaceWith(callExpression(arrowFunctionExpression([], node), []));</span><span class="s3">\n        </span><span class="s1">(this.get(</span><span class="s3">\&quot;</span><span class="s1">callee.body</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.Expression&gt;).insertAfter(nodes);</span><span class="s3">\n        </span><span class="s1">return [this];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isHiddenInSequenceExpression(this)) {</span><span class="s3">\n        </span><span class="s1">nodes.unshift(node);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// We need to preserve the value of this expression.</span><span class="s3">\n      </span><span class="s1">else if (isCallExpression(node) &amp;&amp; isSuper(node.callee)) {</span><span class="s3">\n        </span><span class="s1">nodes.unshift(node);</span><span class="s3">\n        </span><span class="s1">// `super(...)` always evaluates to `this`.</span><span class="s3">\n        </span><span class="s1">nodes.push(thisExpression());</span><span class="s3">\n      </span><span class="s1">} else if (isAlmostConstantAssignment(node, scope)) {</span><span class="s3">\n        </span><span class="s1">nodes.unshift(node);</span><span class="s3">\n        </span><span class="s1">nodes.push(cloneNode(node.left));</span><span class="s3">\n      </span><span class="s1">} else if (scope.isPure(node, true)) {</span><span class="s3">\n        </span><span class="s1">// Insert the nodes before rather than after; it's not observable.</span><span class="s3">\n        </span><span class="s1">nodes.push(node);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Inserting after the computed key of a method should insert the</span><span class="s3">\n        </span><span class="s1">// temporary binding in the method's parent's scope.</span><span class="s3">\n        </span><span class="s1">if (parentPath.isMethod({ computed: true, key: node })) {</span><span class="s3">\n          </span><span class="s1">scope = scope.parent;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const temp = scope.generateDeclaredUidIdentifier();</span><span class="s3">\n        </span><span class="s1">nodes.unshift(</span><span class="s3">\n          </span><span class="s1">expressionStatement(</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): This can be a variable</span><span class="s3">\n            </span><span class="s1">// declaration in the </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot; </span><span class="s1">of a for statement, but that's</span><span class="s3">\n            </span><span class="s1">// invalid here.</span><span class="s3">\n            </span><span class="s1">assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, cloneNode(temp), node),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">nodes.push(expressionStatement(cloneNode(temp)));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): check that nodes is an array of statements</span><span class="s3">\n    </span><span class="s1">return this.replaceExpressionWithStatements(nodes);</span><span class="s3">\n  </span><span class="s1">} else if (Array.isArray(this.container)) {</span><span class="s3">\n    </span><span class="s1">return this._containerInsertAfter(nodes);</span><span class="s3">\n  </span><span class="s1">} else if (this.isStatementOrBlock()) {</span><span class="s3">\n    </span><span class="s1">const node = this.node as t.Statement;</span><span class="s3">\n    </span><span class="s1">const shouldInsertCurrentNode =</span><span class="s3">\n      </span><span class="s1">node &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(!this.isExpressionStatement() ||</span><span class="s3">\n        </span><span class="s1">(node as t.ExpressionStatement).expression != null);</span><span class="s3">\n\n    </span><span class="s1">this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error Fixme: refine nodes to t.BlockStatement[</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">] when this is a BlockStatement path</span><span class="s3">\n    </span><span class="s1">return this.pushContainer(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, nodes);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">We don't know what to do with this node type. </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        \&quot;</span><span class="s1">We were previously a Statement but we can't fit in here?</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Update all sibling node paths after `fromIndex` by `incrementBy`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function updateSiblingKeys(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">fromIndex: number,</span><span class="s3">\n  </span><span class="s1">incrementBy: number,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!this.parent) return;</span><span class="s3">\n\n  </span><span class="s1">const paths = pathCache.get(this.parent);</span><span class="s3">\n\n  </span><span class="s1">for (const [, path] of paths) {</span><span class="s3">\n    </span><span class="s1">if (typeof path.key === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; path.key &gt;= fromIndex) {</span><span class="s3">\n      </span><span class="s1">path.key += incrementBy;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _verifyNodeList&lt;N extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">nodes: N | N[],</span><span class="s3">\n</span><span class="s1">): N[] {</span><span class="s3">\n  </span><span class="s1">if (!nodes) {</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!Array.isArray(nodes)) {</span><span class="s3">\n    </span><span class="s1">nodes = [nodes];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">const node = nodes[i];</span><span class="s3">\n    </span><span class="s1">let msg;</span><span class="s3">\n\n    </span><span class="s1">if (!node) {</span><span class="s3">\n      </span><span class="s1">msg = </span><span class="s3">\&quot;</span><span class="s1">has falsy node</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else if (typeof node !== </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">msg = </span><span class="s3">\&quot;</span><span class="s1">contains a non-object node</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else if (!node.type) {</span><span class="s3">\n      </span><span class="s1">msg = </span><span class="s3">\&quot;</span><span class="s1">without a type</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else if (node instanceof NodePath) {</span><span class="s3">\n      </span><span class="s1">msg = </span><span class="s3">\&quot;</span><span class="s1">has a NodePath when it expected a raw object</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (msg) {</span><span class="s3">\n      </span><span class="s1">const type = Array.isArray(node) ? </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot; </span><span class="s1">: typeof node;</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`Node list ${msg} with the index of ${i} and type of ${type}`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return nodes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function unshiftContainer&lt;N extends t.Node, K extends keyof N &amp; string&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;N&gt;,</span><span class="s3">\n  </span><span class="s1">listKey: K,</span><span class="s3">\n  </span><span class="s1">nodes: N[K] extends (infer E)[]</span><span class="s3">\n    </span><span class="s1">? E | E[]</span><span class="s3">\n    </span><span class="s1">: // todo: refine to t.Node[]</span><span class="s3">\n      </span><span class="s1">//  ? E extends t.Node</span><span class="s3">\n      </span><span class="s1">//    ? E | E[]</span><span class="s3">\n      </span><span class="s1">//    : never</span><span class="s3">\n      </span><span class="s1">never,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// todo: NodePaths&lt;Nodes&gt;</span><span class="s3">\n  </span><span class="s1">this._assertUnremoved();</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error fixme</span><span class="s3">\n  </span><span class="s1">nodes = this._verifyNodeList(nodes);</span><span class="s3">\n\n  </span><span class="s1">// get the first path and insert our nodes before it, if it doesn't exist then it</span><span class="s3">\n  </span><span class="s1">// doesn't matter, our nodes will be inserted anyway</span><span class="s3">\n  </span><span class="s1">const path = NodePath.get({</span><span class="s3">\n    </span><span class="s1">parentPath: this,</span><span class="s3">\n    </span><span class="s1">parent: this.node,</span><span class="s3">\n    </span><span class="s1">container: this.node[listKey] as unknown as t.Node | t.Node[],</span><span class="s3">\n    </span><span class="s1">listKey,</span><span class="s3">\n    </span><span class="s1">key: 0,</span><span class="s3">\n  </span><span class="s1">}).setContext(this.context);</span><span class="s3">\n\n  </span><span class="s1">return path._containerInsertBefore(</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error typings needed to narrow down nodes as t.Node[]</span><span class="s3">\n    </span><span class="s1">nodes,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function pushContainer&lt;N extends t.Node, K extends keyof N &amp; string&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;N&gt;,</span><span class="s3">\n  </span><span class="s1">listKey: K,</span><span class="s3">\n  </span><span class="s1">nodes: N[K] extends (infer E)[]</span><span class="s3">\n    </span><span class="s1">? E | E[]</span><span class="s3">\n    </span><span class="s1">: // todo: refine to t.Node[]</span><span class="s3">\n      </span><span class="s1">//  ? E extends t.Node</span><span class="s3">\n      </span><span class="s1">//    ? E | E[]</span><span class="s3">\n      </span><span class="s1">//    : never</span><span class="s3">\n      </span><span class="s1">never,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this._assertUnremoved();</span><span class="s3">\n\n  </span><span class="s1">const verifiedNodes = this._verifyNodeList(</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error refine typings</span><span class="s3">\n    </span><span class="s1">nodes,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">// get an invisible path that represents the last node + 1 and replace it with our</span><span class="s3">\n  </span><span class="s1">// nodes, effectively inlining it</span><span class="s3">\n\n  </span><span class="s1">const container = this.node[listKey];</span><span class="s3">\n  </span><span class="s1">const path = NodePath.get({</span><span class="s3">\n    </span><span class="s1">parentPath: this,</span><span class="s3">\n    </span><span class="s1">parent: this.node,</span><span class="s3">\n    </span><span class="s1">container: container as unknown as t.Node | t.Node[],</span><span class="s3">\n    </span><span class="s1">listKey,</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error TS cannot infer that container is t.Node[]</span><span class="s3">\n    </span><span class="s1">key: container.length,</span><span class="s3">\n  </span><span class="s1">}).setContext(this.context);</span><span class="s3">\n\n  </span><span class="s1">return path.replaceWithMultiple(verifiedNodes);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Hoist the current node to the highest scope possible and return a UID</span><span class="s3">\n </span><span class="s1">* referencing it.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function hoist&lt;T extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">scope: Scope = this.scope,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const hoister = new PathHoister&lt;T&gt;(this, scope);</span><span class="s3">\n  </span><span class="s1">return hoister.run();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;}</span></pre>
</body>
</html>
<html>
<head>
<title>events.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #cc7832;}
.s2 { color: #a9b7c6;}
.s3 { color: #a9b7c6;}
.s4 { color: #6a8759;}
.s5 { color: #ffc66d;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
events.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Much of the Node.js core API is built around an idiomatic asynchronous 
 * event-driven architecture in which certain kinds of objects (called &quot;emitters&quot;) 
 * emit named events that cause `Function` objects (&quot;listeners&quot;) to be called. 
 * 
 * For instance: a `net.Server` object emits an event each time a peer 
 * connects to it; a `fs.ReadStream` emits an event when the file is opened; 
 * a `stream` emits an event whenever data is available to be read. 
 * 
 * All objects that emit events are instances of the `EventEmitter` class. These 
 * objects expose an `eventEmitter.on()` function that allows one or more 
 * functions to be attached to named events emitted by the object. Typically, 
 * event names are camel-cased strings but any valid JavaScript property key 
 * can be used. 
 * 
 * When the `EventEmitter` object emits an event, all of the functions attached 
 * to that specific event are called _synchronously_. Any values returned by the 
 * called listeners are _ignored_ and discarded. 
 * 
 * The following example shows a simple `EventEmitter` instance with a single 
 * listener. The `eventEmitter.on()` method is used to register listeners, while 
 * the `eventEmitter.emit()` method is used to trigger the event. 
 * 
 * ```js 
 * import { EventEmitter } from 'node:events'; 
 * 
 * class MyEmitter extends EventEmitter {} 
 * 
 * const myEmitter = new MyEmitter(); 
 * myEmitter.on('event', () =&gt; { 
 *   console.log('an event occurred!'); 
 * }); 
 * myEmitter.emit('event'); 
 * ``` 
 * </span><span class="s1">@see </span><span class="s2">[source](https:</span><span class="s0">//github.com/nodejs/node/blob/v20.2.0/lib/events.js) 
 */</span>
<span class="s1">declare module </span><span class="s4">'events' </span><span class="s3">{</span>
    <span class="s0">// NOTE: This class is in the docs but is **not actually exported** by Node.</span>
    <span class="s0">// If https://github.com/nodejs/node/issues/39903 gets resolved and Node</span>
    <span class="s0">// actually starts exporting the class, uncomment below.</span>
    <span class="s0">// import { EventListener, EventListenerObject } from '__dom-events';</span>
    <span class="s0">// /** The NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API. */</span>
    <span class="s0">// interface NodeEventTarget extends EventTarget {</span>
    <span class="s0">//     /**</span>
    <span class="s0">//      * Node.js-specific extension to the `EventTarget` class that emulates the equivalent `EventEmitter` API.</span>
    <span class="s0">//      * The only difference between `addListener()` and `addEventListener()` is that addListener() will return a reference to the EventTarget.</span>
    <span class="s0">//      */</span>
    <span class="s0">//     addListener(type: string, listener: EventListener | EventListenerObject, options?: { once: boolean }): this;</span>
    <span class="s0">//     /** Node.js-specific extension to the `EventTarget` class that returns an array of event `type` names for which event listeners are registered. */</span>
    <span class="s0">//     eventNames(): string[];</span>
    <span class="s0">//     /** Node.js-specific extension to the `EventTarget` class that returns the number of event listeners registered for the `type`. */</span>
    <span class="s0">//     listenerCount(type: string): number;</span>
    <span class="s0">//     /** Node.js-specific alias for `eventTarget.removeListener()`. */</span>
    <span class="s0">//     off(type: string, listener: EventListener | EventListenerObject): this;</span>
    <span class="s0">//     /** Node.js-specific alias for `eventTarget.addListener()`. */</span>
    <span class="s0">//     on(type: string, listener: EventListener | EventListenerObject, options?: { once: boolean }): this;</span>
    <span class="s0">//     /** Node.js-specific extension to the `EventTarget` class that adds a `once` listener for the given event `type`. This is equivalent to calling `on` with the `once` option set to `true`. */</span>
    <span class="s0">//     once(type: string, listener: EventListener | EventListenerObject): this;</span>
    <span class="s0">//     /**</span>
    <span class="s0">//      * Node.js-specific extension to the `EventTarget` class.</span>
    <span class="s0">//      * If `type` is specified, removes all registered listeners for `type`,</span>
    <span class="s0">//      * otherwise removes all registered listeners.</span>
    <span class="s0">//      */</span>
    <span class="s0">//     removeAllListeners(type: string): this;</span>
    <span class="s0">//     /**</span>
    <span class="s0">//      * Node.js-specific extension to the `EventTarget` class that removes the listener for the given `type`.</span>
    <span class="s0">//      * The only difference between `removeListener()` and `removeEventListener()` is that `removeListener()` will return a reference to the `EventTarget`.</span>
    <span class="s0">//      */</span>
    <span class="s0">//     removeListener(type: string, listener: EventListener | EventListenerObject): this;</span>
    <span class="s0">// }</span>
    <span class="s1">interface </span><span class="s2">EventEmitterOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables automatic capturing of promise rejection. 
         */</span>
        <span class="s3">captureRejections</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">// Any EventTarget with a Node-style `once` function</span>
    <span class="s1">interface </span><span class="s2">_NodeEventTarget </span><span class="s3">{</span>
        <span class="s3">once(</span><span class="s2">eventName</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">// Any EventTarget with a DOM-style `addEventListener`</span>
    <span class="s1">interface </span><span class="s2">_DOMEventTarget </span><span class="s3">{</span>
        <span class="s3">addEventListener(</span>
            <span class="s2">eventName</span><span class="s1">: </span><span class="s2">string</span><span class="s3">,</span>
            <span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">,</span>
            <span class="s2">opts</span><span class="s1">?: </span><span class="s3">{</span>
                <span class="s3">once</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
            <span class="s3">}</span>
        <span class="s3">)</span><span class="s1">: </span><span class="s2">any</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">StaticEventEmitterOptions </span><span class="s3">{</span>
        <span class="s3">signal</span><span class="s1">?: </span><span class="s2">AbortSignal </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">EventEmitter </span><span class="s1">extends </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">EventEmitter </span><span class="s3">{}</span>
    <span class="s0">/**</span>
     <span class="s0">* The `EventEmitter` class is defined and exposed by the `node:events` module: 
     * 
     * ```js 
     * import { EventEmitter } from 'node:events'; 
     * ``` 
     * 
     * All `EventEmitter`s emit the event `'newListener'` when new listeners are 
     * added and `'removeListener'` when existing listeners are removed. 
     * 
     * It supports the following option: 
     * </span><span class="s1">@since </span><span class="s0">v0.1.26 
     */</span>
    <span class="s1">class </span><span class="s2">EventEmitter </span><span class="s3">{</span>
        <span class="s1">constructor</span><span class="s3">(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">EventEmitterOptions</span><span class="s3">);</span>
        <span class="s0">/**</span>
         <span class="s0">* Creates a `Promise` that is fulfilled when the `EventEmitter` emits the given 
         * event or that is rejected if the `EventEmitter` emits `'error'` while waiting. 
         * The `Promise` will resolve with an array of all the arguments emitted to the 
         * given event. 
         * 
         * This method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event 
         * semantics and does not listen to the `'error'` event. 
         * 
         * ```js 
         * import { once, EventEmitter } from 'node:events'; 
         * import process from 'node:process'; 
         * 
         * const ee = new EventEmitter(); 
         * 
         * process.nextTick(() =&gt; { 
         *   ee.emit('myevent', 42); 
         * }); 
         * 
         * const [value] = await once(ee, 'myevent'); 
         * console.log(value); 
         * 
         * const err = new Error('kaboom'); 
         * process.nextTick(() =&gt; { 
         *   ee.emit('error', err); 
         * }); 
         * 
         * try { 
         *   await once(ee, 'myevent'); 
         * } catch (err) { 
         *   console.error('error happened', err); 
         * } 
         * ``` 
         * 
         * The special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the 
         * '`error'` event itself, then it is treated as any other kind of event without 
         * special handling: 
         * 
         * ```js 
         * import { EventEmitter, once } from 'node:events'; 
         * 
         * const ee = new EventEmitter(); 
         * 
         * once(ee, 'error') 
         *   .then(([err]) =&gt; console.log('ok', err.message)) 
         *   .catch((err) =&gt; console.error('error', err.message)); 
         * 
         * ee.emit('error', new Error('boom')); 
         * 
         * // Prints: ok boom 
         * ``` 
         * 
         * An `AbortSignal` can be used to cancel waiting for the event: 
         * 
         * ```js 
         * import { EventEmitter, once } from 'node:events'; 
         * 
         * const ee = new EventEmitter(); 
         * const ac = new AbortController(); 
         * 
         * async function foo(emitter, event, signal) { 
         *   try { 
         *     await once(emitter, event, { signal }); 
         *     console.log('event emitted!'); 
         *   } catch (error) { 
         *     if (error.name === 'AbortError') { 
         *       console.error('Waiting for the event was canceled!'); 
         *     } else { 
         *       console.error('There was an error', error.message); 
         *     } 
         *   } 
         * } 
         * 
         * foo(ee, 'foo', ac.signal); 
         * ac.abort(); // Abort waiting for the event 
         * ee.emit('foo'); // Prints: Waiting for the event was canceled! 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v11.13.0, v10.16.0 
         */</span>
        <span class="s1">static </span><span class="s3">once(</span><span class="s2">emitter</span><span class="s1">: </span><span class="s2">_NodeEventTarget</span><span class="s3">, </span><span class="s2">eventName</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">StaticEventEmitterOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Promise</span><span class="s3">&lt;</span><span class="s2">any</span><span class="s3">[]&gt;;</span>
        <span class="s1">static </span><span class="s3">once(</span><span class="s2">emitter</span><span class="s1">: </span><span class="s2">_DOMEventTarget</span><span class="s3">, </span><span class="s2">eventName</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">StaticEventEmitterOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Promise</span><span class="s3">&lt;</span><span class="s2">any</span><span class="s3">[]&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* ```js 
         * import { on, EventEmitter } from 'node:events'; 
         * import process from 'node:process'; 
         * 
         * const ee = new EventEmitter(); 
         * 
         * // Emit later on 
         * process.nextTick(() =&gt; { 
         *   ee.emit('foo', 'bar'); 
         *   ee.emit('foo', 42); 
         * }); 
         * 
         * for await (const event of on(ee, 'foo')) { 
         *   // The execution of this inner block is synchronous and it 
         *   // processes one event at a time (even with await). Do not use 
         *   // if concurrent execution is required. 
         *   console.log(event); // prints ['bar'] [42] 
         * } 
         * // Unreachable here 
         * ``` 
         * 
         * Returns an `AsyncIterator` that iterates `eventName` events. It will throw 
         * if the `EventEmitter` emits `'error'`. It removes all listeners when 
         * exiting the loop. The `value` returned by each iteration is an array 
         * composed of the emitted event arguments. 
         * 
         * An `AbortSignal` can be used to cancel waiting on events: 
         * 
         * ```js 
         * import { on, EventEmitter } from 'node:events'; 
         * import process from 'node:process'; 
         * 
         * const ac = new AbortController(); 
         * 
         * (async () =&gt; { 
         *   const ee = new EventEmitter(); 
         * 
         *   // Emit later on 
         *   process.nextTick(() =&gt; { 
         *     ee.emit('foo', 'bar'); 
         *     ee.emit('foo', 42); 
         *   }); 
         * 
         *   for await (const event of on(ee, 'foo', { signal: ac.signal })) { 
         *     // The execution of this inner block is synchronous and it 
         *     // processes one event at a time (even with await). Do not use 
         *     // if concurrent execution is required. 
         *     console.log(event); // prints ['bar'] [42] 
         *   } 
         *   // Unreachable here 
         * })(); 
         * 
         * process.nextTick(() =&gt; ac.abort()); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v13.6.0, v12.16.0 
         * </span><span class="s1">@param </span><span class="s2">eventName </span><span class="s0">The name of the event being listened for 
         * </span><span class="s1">@return </span><span class="s0">that iterates `eventName` events emitted by the `emitter` 
         */</span>
        <span class="s1">static </span><span class="s3">on(</span><span class="s2">emitter</span><span class="s1">: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">EventEmitter</span><span class="s3">, </span><span class="s2">eventName</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">StaticEventEmitterOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">AsyncIterableIterator</span><span class="s3">&lt;</span><span class="s2">any</span><span class="s3">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* A class method that returns the number of listeners for the given `eventName`registered on the given `emitter`. 
         * 
         * ```js 
         * import { EventEmitter, listenerCount } from 'node:events'; 
         * 
         * const myEmitter = new EventEmitter(); 
         * myEmitter.on('event', () =&gt; {}); 
         * myEmitter.on('event', () =&gt; {}); 
         * console.log(listenerCount(myEmitter, 'event')); 
         * // Prints: 2 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v0.9.12 
         * </span><span class="s1">@deprecated </span><span class="s0">Since v3.2.0 - Use `listenerCount` instead. 
         * </span><span class="s1">@param </span><span class="s2">emitter </span><span class="s0">The emitter to query 
         * </span><span class="s1">@param </span><span class="s2">eventName </span><span class="s0">The event name 
         */</span>
        <span class="s1">static </span><span class="s3">listenerCount(</span><span class="s2">emitter</span><span class="s1">: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">EventEmitter</span><span class="s3">, </span><span class="s2">eventName</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a copy of the array of listeners for the event named `eventName`. 
         * 
         * For `EventEmitter`s this behaves exactly the same as calling `.listeners` on 
         * the emitter. 
         * 
         * For `EventTarget`s this is the only way to get the event listeners for the 
         * event target. This is useful for debugging and diagnostic purposes. 
         * 
         * ```js 
         * import { getEventListeners, EventEmitter } from 'node:events'; 
         * 
         * { 
         *   const ee = new EventEmitter(); 
         *   const listener = () =&gt; console.log('Events are fun'); 
         *   ee.on('foo', listener); 
         *   console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ] 
         * } 
         * { 
         *   const et = new EventTarget(); 
         *   const listener = () =&gt; console.log('Events are fun'); 
         *   et.addEventListener('foo', listener); 
         *   console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ] 
         * } 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v15.2.0, v14.17.0 
         */</span>
        <span class="s1">static </span><span class="s3">getEventListeners(</span><span class="s2">emitter</span><span class="s1">: </span><span class="s2">_DOMEventTarget </span><span class="s1">| </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">EventEmitter</span><span class="s3">, </span><span class="s2">name</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Function</span><span class="s3">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns the currently set max amount of listeners. 
         * 
         * For `EventEmitter`s this behaves exactly the same as calling `.getMaxListeners` on 
         * the emitter. 
         * 
         * For `EventTarget`s this is the only way to get the max event listeners for the 
         * event target. If the number of event handlers on a single EventTarget exceeds 
         * the max set, the EventTarget will print a warning. 
         * 
         * ```js 
         * import { getMaxListeners, setMaxListeners, EventEmitter } from 'node:events'; 
         * 
         * { 
         *   const ee = new EventEmitter(); 
         *   console.log(getMaxListeners(ee)); // 10 
         *   setMaxListeners(11, ee); 
         *   console.log(getMaxListeners(ee)); // 11 
         * } 
         * { 
         *   const et = new EventTarget(); 
         *   console.log(getMaxListeners(et)); // 10 
         *   setMaxListeners(11, et); 
         *   console.log(getMaxListeners(et)); // 11 
         * } 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v19.9.0 
         */</span>
        <span class="s1">static </span><span class="s3">getMaxListeners(</span><span class="s2">emitter</span><span class="s1">: </span><span class="s2">_DOMEventTarget </span><span class="s1">| </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">EventEmitter</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* ```js 
         * import { setMaxListeners, EventEmitter } from 'node:events'; 
         * 
         * const target = new EventTarget(); 
         * const emitter = new EventEmitter(); 
         * 
         * setMaxListeners(5, target, emitter); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v15.4.0 
         * </span><span class="s1">@param </span><span class="s2">n </span><span class="s0">A non-negative number. The maximum number of listeners per `EventTarget` event. 
         * </span><span class="s1">@param </span><span class="s2">eventsTargets </span><span class="s0">Zero or more {EventTarget} or {EventEmitter} instances. If none are specified, `n` is set as the default max for all newly created {EventTarget} and {EventEmitter} 
         * objects. 
         */</span>
        <span class="s1">static </span><span class="s3">setMaxListeners(</span><span class="s2">n</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">, </span><span class="s1">...</span><span class="s2">eventTargets</span><span class="s1">: </span><span class="s2">Array</span><span class="s3">&lt;</span><span class="s2">_DOMEventTarget </span><span class="s1">| </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">EventEmitter</span><span class="s3">&gt;)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This symbol shall be used to install a listener for only monitoring `'error'`events. Listeners installed using this symbol are called before the regular`'error'` listeners are called. 
         * 
         * Installing a listener using this symbol does not change the behavior once an`'error'` event is emitted. Therefore, the process will still crash if no 
         * regular `'error'` listener is installed. 
         * </span><span class="s1">@since </span><span class="s0">v13.6.0, v12.17.0 
         */</span>
        <span class="s1">static readonly </span><span class="s3">errorMonitor</span><span class="s1">: </span><span class="s2">unique symbol</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Value: `Symbol.for('nodejs.rejection')` 
         * 
         * See how to write a custom `rejection handler`. 
         * </span><span class="s1">@since </span><span class="s0">v13.4.0, v12.16.0 
         */</span>
        <span class="s1">static readonly </span><span class="s3">captureRejectionSymbol</span><span class="s1">: </span><span class="s2">unique symbol</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Value: [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 
         * 
         * Change the default `captureRejections` option on all new `EventEmitter` objects. 
         * </span><span class="s1">@since </span><span class="s0">v13.4.0, v12.16.0 
         */</span>
        <span class="s1">static </span><span class="s3">captureRejections</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* By default, a maximum of `10` listeners can be registered for any single 
         * event. This limit can be changed for individual `EventEmitter` instances 
         * using the `emitter.setMaxListeners(n)` method. To change the default 
         * for _all_`EventEmitter` instances, the `events.defaultMaxListeners`property can be used. If this value is not a positive number, a `RangeError`is thrown. 
         * 
         * Take caution when setting the `events.defaultMaxListeners` because the 
         * change affects _all_`EventEmitter` instances, including those created before 
         * the change is made. However, calling `emitter.setMaxListeners(n)` still has 
         * precedence over `events.defaultMaxListeners`. 
         * 
         * This is not a hard limit. The `EventEmitter` instance will allow 
         * more listeners to be added but will output a trace warning to stderr indicating 
         * that a &quot;possible EventEmitter memory leak&quot; has been detected. For any single`EventEmitter`, the `emitter.getMaxListeners()` and `emitter.setMaxListeners()`methods can be used to 
         * temporarily avoid this warning: 
         * 
         * ```js 
         * import { EventEmitter } from 'node:events'; 
         * const emitter = new EventEmitter(); 
         * emitter.setMaxListeners(emitter.getMaxListeners() + 1); 
         * emitter.once('event', () =&gt; { 
         *   // do stuff 
         *   emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0)); 
         * }); 
         * ``` 
         * 
         * The `--trace-warnings` command-line flag can be used to display the 
         * stack trace for such warnings. 
         * 
         * The emitted warning can be inspected with `process.on('warning')` and will 
         * have the additional `emitter`, `type`, and `count` properties, referring to 
         * the event emitter instance, the event's name and the number of attached 
         * listeners, respectively. 
         * Its `name` property is set to `'MaxListenersExceededWarning'`. 
         * </span><span class="s1">@since </span><span class="s0">v0.11.2 
         */</span>
        <span class="s1">static </span><span class="s3">defaultMaxListeners</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">import </span><span class="s2">internal </span><span class="s1">= require</span><span class="s3">(</span><span class="s4">'node:events'</span><span class="s3">);</span>
    <span class="s1">namespace </span><span class="s2">EventEmitter </span><span class="s3">{</span>
        <span class="s0">// Should just be `export { EventEmitter }`, but that doesn't work in TypeScript 3.4</span>
        <span class="s1">export </span><span class="s3">{ </span><span class="s2">internal </span><span class="s1">as </span><span class="s2">EventEmitter </span><span class="s3">};</span>
        <span class="s1">export interface </span><span class="s2">Abortable </span><span class="s3">{</span>
            <span class="s0">/**</span>
             <span class="s0">* When provided the corresponding `AbortController` can be used to cancel an asynchronous action. 
             */</span>
            <span class="s3">signal</span><span class="s1">?: </span><span class="s2">AbortSignal </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">}</span>
    <span class="s3">}</span>
    <span class="s2">global </span><span class="s3">{</span>
        <span class="s1">namespace </span><span class="s2">NodeJS </span><span class="s3">{</span>
            <span class="s1">interface </span><span class="s2">EventEmitter </span><span class="s3">{</span>
                <span class="s0">/**</span>
                 <span class="s0">* Alias for `emitter.on(eventName, listener)`. 
                 * </span><span class="s1">@since </span><span class="s0">v0.1.26 
                 */</span>
                <span class="s3">addListener(</span><span class="s2">eventName</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Adds the `listener` function to the end of the listeners array for the 
                 * event named `eventName`. No checks are made to see if the `listener` has 
                 * already been added. Multiple calls passing the same combination of `eventName`and `listener` will result in the `listener` being added, and called, multiple 
                 * times. 
                 * 
                 * ```js 
                 * server.on('connection', (stream) =&gt; { 
                 *   console.log('someone connected!'); 
                 * }); 
                 * ``` 
                 * 
                 * Returns a reference to the `EventEmitter`, so that calls can be chained. 
                 * 
                 * By default, event listeners are invoked in the order they are added. The`emitter.prependListener()` method can be used as an alternative to add the 
                 * event listener to the beginning of the listeners array. 
                 * 
                 * ```js 
                 * import { EventEmitter } from 'node:events'; 
                 * const myEE = new EventEmitter(); 
                 * myEE.on('foo', () =&gt; console.log('a')); 
                 * myEE.prependListener('foo', () =&gt; console.log('b')); 
                 * myEE.emit('foo'); 
                 * // Prints: 
                 * //   b 
                 * //   a 
                 * ``` 
                 * </span><span class="s1">@since </span><span class="s0">v0.1.101 
                 * </span><span class="s1">@param </span><span class="s2">eventName </span><span class="s0">The name of the event. 
                 * </span><span class="s1">@param </span><span class="s2">listener </span><span class="s0">The callback function 
                 */</span>
                <span class="s3">on(</span><span class="s2">eventName</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Adds a **one-time**`listener` function for the event named `eventName`. The 
                 * next time `eventName` is triggered, this listener is removed and then invoked. 
                 * 
                 * ```js 
                 * server.once('connection', (stream) =&gt; { 
                 *   console.log('Ah, we have our first user!'); 
                 * }); 
                 * ``` 
                 * 
                 * Returns a reference to the `EventEmitter`, so that calls can be chained. 
                 * 
                 * By default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the 
                 * event listener to the beginning of the listeners array. 
                 * 
                 * ```js 
                 * import { EventEmitter } from 'node:events'; 
                 * const myEE = new EventEmitter(); 
                 * myEE.once('foo', () =&gt; console.log('a')); 
                 * myEE.prependOnceListener('foo', () =&gt; console.log('b')); 
                 * myEE.emit('foo'); 
                 * // Prints: 
                 * //   b 
                 * //   a 
                 * ``` 
                 * </span><span class="s1">@since </span><span class="s0">v0.3.0 
                 * </span><span class="s1">@param </span><span class="s2">eventName </span><span class="s0">The name of the event. 
                 * </span><span class="s1">@param </span><span class="s2">listener </span><span class="s0">The callback function 
                 */</span>
                <span class="s3">once(</span><span class="s2">eventName</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Removes the specified `listener` from the listener array for the event named`eventName`. 
                 * 
                 * ```js 
                 * const callback = (stream) =&gt; { 
                 *   console.log('someone connected!'); 
                 * }; 
                 * server.on('connection', callback); 
                 * // ... 
                 * server.removeListener('connection', callback); 
                 * ``` 
                 * 
                 * `removeListener()` will remove, at most, one instance of a listener from the 
                 * listener array. If any single listener has been added multiple times to the 
                 * listener array for the specified `eventName`, then `removeListener()` must be 
                 * called multiple times to remove each instance. 
                 * 
                 * Once an event is emitted, all listeners attached to it at the 
                 * time of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution 
                 * will not remove them from`emit()` in progress. Subsequent events behave as expected. 
                 * 
                 * ```js 
                 * import { EventEmitter } from 'node:events'; 
                 * class MyEmitter extends EventEmitter {} 
                 * const myEmitter = new MyEmitter(); 
                 * 
                 * const callbackA = () =&gt; { 
                 *   console.log('A'); 
                 *   myEmitter.removeListener('event', callbackB); 
                 * }; 
                 * 
                 * const callbackB = () =&gt; { 
                 *   console.log('B'); 
                 * }; 
                 * 
                 * myEmitter.on('event', callbackA); 
                 * 
                 * myEmitter.on('event', callbackB); 
                 * 
                 * // callbackA removes listener callbackB but it will still be called. 
                 * // Internal listener array at time of emit [callbackA, callbackB] 
                 * myEmitter.emit('event'); 
                 * // Prints: 
                 * //   A 
                 * //   B 
                 * 
                 * // callbackB is now removed. 
                 * // Internal listener array [callbackA] 
                 * myEmitter.emit('event'); 
                 * // Prints: 
                 * //   A 
                 * ``` 
                 * 
                 * Because listeners are managed using an internal array, calling this will 
                 * change the position indices of any listener registered _after_ the listener 
                 * being removed. This will not impact the order in which listeners are called, 
                 * but it means that any copies of the listener array as returned by 
                 * the `emitter.listeners()` method will need to be recreated. 
                 * 
                 * When a single function has been added as a handler multiple times for a single 
                 * event (as in the example below), `removeListener()` will remove the most 
                 * recently added instance. In the example the `once('ping')`listener is removed: 
                 * 
                 * ```js 
                 * import { EventEmitter } from 'node:events'; 
                 * const ee = new EventEmitter(); 
                 * 
                 * function pong() { 
                 *   console.log('pong'); 
                 * } 
                 * 
                 * ee.on('ping', pong); 
                 * ee.once('ping', pong); 
                 * ee.removeListener('ping', pong); 
                 * 
                 * ee.emit('ping'); 
                 * ee.emit('ping'); 
                 * ``` 
                 * 
                 * Returns a reference to the `EventEmitter`, so that calls can be chained. 
                 * </span><span class="s1">@since </span><span class="s0">v0.1.26 
                 */</span>
                <span class="s3">removeListener(</span><span class="s2">eventName</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Alias for `emitter.removeListener()`. 
                 * </span><span class="s1">@since </span><span class="s0">v10.0.0 
                 */</span>
                <span class="s3">off(</span><span class="s2">eventName</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Removes all listeners, or those of the specified `eventName`. 
                 * 
                 * It is bad practice to remove listeners added elsewhere in the code, 
                 * particularly when the `EventEmitter` instance was created by some other 
                 * component or module (e.g. sockets or file streams). 
                 * 
                 * Returns a reference to the `EventEmitter`, so that calls can be chained. 
                 * </span><span class="s1">@since </span><span class="s0">v0.1.26 
                 */</span>
                <span class="s3">removeAllListeners(</span><span class="s2">event</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* By default `EventEmitter`s will print a warning if more than `10` listeners are 
                 * added for a particular event. This is a useful default that helps finding 
                 * memory leaks. The `emitter.setMaxListeners()` method allows the limit to be 
                 * modified for this specific `EventEmitter` instance. The value can be set to`Infinity` (or `0`) to indicate an unlimited number of listeners. 
                 * 
                 * Returns a reference to the `EventEmitter`, so that calls can be chained. 
                 * </span><span class="s1">@since </span><span class="s0">v0.3.5 
                 */</span>
                <span class="s3">setMaxListeners(</span><span class="s2">n</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Returns the current max listener value for the `EventEmitter` which is either 
                 * set by `emitter.setMaxListeners(n)` or defaults to </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">defaultMaxListeners}</span><span class="s0">. 
                 * </span><span class="s1">@since </span><span class="s0">v1.0.0 
                 */</span>
                <span class="s3">getMaxListeners()</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Returns a copy of the array of listeners for the event named `eventName`. 
                 * 
                 * ```js 
                 * server.on('connection', (stream) =&gt; { 
                 *   console.log('someone connected!'); 
                 * }); 
                 * console.log(util.inspect(server.listeners('connection'))); 
                 * // Prints: [ [Function] ] 
                 * ``` 
                 * </span><span class="s1">@since </span><span class="s0">v0.1.26 
                 */</span>
                <span class="s3">listeners(</span><span class="s2">eventName</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Function</span><span class="s3">[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* Returns a copy of the array of listeners for the event named `eventName`, 
                 * including any wrappers (such as those created by `.once()`). 
                 * 
                 * ```js 
                 * import { EventEmitter } from 'node:events'; 
                 * const emitter = new EventEmitter(); 
                 * emitter.once('log', () =&gt; console.log('log once')); 
                 * 
                 * // Returns a new Array with a function `onceWrapper` which has a property 
                 * // `listener` which contains the original listener bound above 
                 * const listeners = emitter.rawListeners('log'); 
                 * const logFnWrapper = listeners[0]; 
                 * 
                 * // Logs &quot;log once&quot; to the console and does not unbind the `once` event 
                 * logFnWrapper.listener(); 
                 * 
                 * // Logs &quot;log once&quot; to the console and removes the listener 
                 * logFnWrapper(); 
                 * 
                 * emitter.on('log', () =&gt; console.log('log persistently')); 
                 * // Will return a new Array with a single function bound by `.on()` above 
                 * const newListeners = emitter.rawListeners('log'); 
                 * 
                 * // Logs &quot;log persistently&quot; twice 
                 * newListeners[0](); 
                 * emitter.emit('log'); 
                 * ``` 
                 * </span><span class="s1">@since </span><span class="s0">v9.4.0 
                 */</span>
                <span class="s3">rawListeners(</span><span class="s2">eventName</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Function</span><span class="s3">[];</span>
                <span class="s0">/**</span>
                 <span class="s0">* Synchronously calls each of the listeners registered for the event named`eventName`, in the order they were registered, passing the supplied arguments 
                 * to each. 
                 * 
                 * Returns `true` if the event had listeners, `false` otherwise. 
                 * 
                 * ```js 
                 * import { EventEmitter } from 'node:events'; 
                 * const myEmitter = new EventEmitter(); 
                 * 
                 * // First listener 
                 * myEmitter.on('event', function firstListener() { 
                 *   console.log('Helloooo! first listener'); 
                 * }); 
                 * // Second listener 
                 * myEmitter.on('event', function secondListener(arg1, arg2) { 
                 *   console.log(`event with parameters ${arg1}, ${arg2} in second listener`); 
                 * }); 
                 * // Third listener 
                 * myEmitter.on('event', function thirdListener(...args) { 
                 *   const parameters = args.join(', '); 
                 *   console.log(`event with parameters ${parameters} in third listener`); 
                 * }); 
                 * 
                 * console.log(myEmitter.listeners('event')); 
                 * 
                 * myEmitter.emit('event', 1, 2, 3, 4, 5); 
                 * 
                 * // Prints: 
                 * // [ 
                 * //   [Function: firstListener], 
                 * //   [Function: secondListener], 
                 * //   [Function: thirdListener] 
                 * // ] 
                 * // Helloooo! first listener 
                 * // event with parameters 1, 2 in second listener 
                 * // event with parameters 1, 2, 3, 4, 5 in third listener 
                 * ``` 
                 * </span><span class="s1">@since </span><span class="s0">v0.1.26 
                 */</span>
                <span class="s3">emit(</span><span class="s2">eventName</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[])</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Returns the number of listeners listening for the event named `eventName`. 
                 * If `listener` is provided, it will return how many times the listener is found 
                 * in the list of the listeners of the event. 
                 * </span><span class="s1">@since </span><span class="s0">v3.2.0 
                 * </span><span class="s1">@param </span><span class="s2">eventName </span><span class="s0">The name of the event being listened for 
                 * </span><span class="s1">@param </span><span class="s2">listener </span><span class="s0">The event handler function 
                 */</span>
                <span class="s3">listenerCount(</span><span class="s2">eventName</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">?: </span><span class="s2">Function</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Adds the `listener` function to the _beginning_ of the listeners array for the 
                 * event named `eventName`. No checks are made to see if the `listener` has 
                 * already been added. Multiple calls passing the same combination of `eventName`and `listener` will result in the `listener` being added, and called, multiple 
                 * times. 
                 * 
                 * ```js 
                 * server.prependListener('connection', (stream) =&gt; { 
                 *   console.log('someone connected!'); 
                 * }); 
                 * ``` 
                 * 
                 * Returns a reference to the `EventEmitter`, so that calls can be chained. 
                 * </span><span class="s1">@since </span><span class="s0">v6.0.0 
                 * </span><span class="s1">@param </span><span class="s2">eventName </span><span class="s0">The name of the event. 
                 * </span><span class="s1">@param </span><span class="s2">listener </span><span class="s0">The callback function 
                 */</span>
                <span class="s3">prependListener(</span><span class="s2">eventName</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this 
                 * listener is removed, and then invoked. 
                 * 
                 * ```js 
                 * server.prependOnceListener('connection', (stream) =&gt; { 
                 *   console.log('Ah, we have our first user!'); 
                 * }); 
                 * ``` 
                 * 
                 * Returns a reference to the `EventEmitter`, so that calls can be chained. 
                 * </span><span class="s1">@since </span><span class="s0">v6.0.0 
                 * </span><span class="s1">@param </span><span class="s2">eventName </span><span class="s0">The name of the event. 
                 * </span><span class="s1">@param </span><span class="s2">listener </span><span class="s0">The callback function 
                 */</span>
                <span class="s3">prependOnceListener(</span><span class="s2">eventName</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Returns an array listing the events for which the emitter has registered 
                 * listeners. The values in the array are strings or `Symbol`s. 
                 * 
                 * ```js 
                 * import { EventEmitter } from 'node:events'; 
                 * 
                 * const myEE = new EventEmitter(); 
                 * myEE.on('foo', () =&gt; {}); 
                 * myEE.on('bar', () =&gt; {}); 
                 * 
                 * const sym = Symbol('symbol'); 
                 * myEE.on(sym, () =&gt; {}); 
                 * 
                 * console.log(myEE.eventNames()); 
                 * // Prints: [ 'foo', 'bar', Symbol(symbol) ] 
                 * ``` 
                 * </span><span class="s1">@since </span><span class="s0">v6.0.0 
                 */</span>
                <span class="s3">eventNames()</span><span class="s1">: </span><span class="s2">Array</span><span class="s3">&lt;</span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">&gt;;</span>
            <span class="s3">}</span>
        <span class="s3">}</span>
    <span class="s3">}</span>
    <span class="s1">export = </span><span class="s2">EventEmitter</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s1">declare module </span><span class="s4">'node:events' </span><span class="s3">{</span>
    <span class="s1">import </span><span class="s2">events </span><span class="s1">= require</span><span class="s3">(</span><span class="s4">'events'</span><span class="s3">);</span>
    <span class="s1">export = </span><span class="s2">events</span><span class="s3">;</span>
<span class="s3">}</span>
</pre>
</body>
</html>
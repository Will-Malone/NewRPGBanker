<html>
<head>
<title>ViewManager.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-weight: bold; font-style: italic;}
.s6 { color: #77b767; font-style: italic;}
.s7 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ViewManager.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.uimanager</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.content.Context</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.View</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.NonNull</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.logging.FLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.BaseJavaModule</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactApplicationContext</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableArray</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.mapbuffer.MapBuffer</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.config.ReactFeatureFlags</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.touch.JSResponderHandler</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.touch.ReactInterceptingViewGroup</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.annotations.ReactProp</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.annotations.ReactPropGroup</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.annotations.ReactPropertyHolder</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaMeasureMode</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.HashMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Map</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Stack</span><span class="s2">;</span>

<span class="s3">/**</span>
 <span class="s3">* Class responsible for knowing how to create and update catalyst Views of a given type. It is also</span>
 <span class="s3">* responsible for creating and updating CSSNodeDEPRECATED subclasses used for calculating position</span>
 <span class="s3">* and size for the corresponding native view.</span>
 <span class="s3">*/</span>
<span class="s1">@ReactPropertyHolder</span>
<span class="s2">public abstract class </span><span class="s1">ViewManager&lt;T </span><span class="s2">extends </span><span class="s1">View</span><span class="s2">, </span><span class="s1">C </span><span class="s2">extends </span><span class="s1">ReactShadowNode&gt;</span>
    <span class="s2">extends </span><span class="s1">BaseJavaModule {</span>

  <span class="s2">private static </span><span class="s1">String NAME = ViewManager.</span><span class="s2">class</span><span class="s1">.getSimpleName()</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* For View recycling: we store a Stack of unused, dead Views. This is null by default, and when</span>
   <span class="s3">* null signals that View Recycling is disabled. `enableViewRecycling` must be explicitly called</span>
   <span class="s3">* in a concrete constructor to enable View Recycling per ViewManager.</span>
   <span class="s3">*/</span>
  <span class="s1">@Nullable </span><span class="s2">private </span><span class="s1">HashMap&lt;Integer</span><span class="s2">, </span><span class="s1">Stack&lt;T&gt;&gt; mRecyclableViews = </span><span class="s2">null;</span>

  <span class="s2">private int </span><span class="s1">mRecyclableViewsBufferSize = </span><span class="s4">1024</span><span class="s2">;</span>

  <span class="s3">/** Call in constructor of concrete ViewManager class to enable. */</span>
  <span class="s2">protected void </span><span class="s1">setupViewRecycling() {</span>
    <span class="s2">if </span><span class="s1">(ReactFeatureFlags.enableViewRecycling) {</span>
      <span class="s1">mRecyclableViews = </span><span class="s2">new </span><span class="s1">HashMap&lt;&gt;()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** Call in constructor of concrete ViewManager class to enable. */</span>
  <span class="s2">protected void </span><span class="s1">setupViewRecycling(</span><span class="s2">int </span><span class="s1">bufferSize) {</span>
    <span class="s1">mRecyclableViewsBufferSize = bufferSize</span><span class="s2">;</span>
    <span class="s1">setupViewRecycling()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private </span><span class="s1">@Nullable Stack&lt;T&gt; getRecyclableViewStack(</span><span class="s2">int </span><span class="s1">surfaceId) {</span>
    <span class="s2">if </span><span class="s1">(mRecyclableViews == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return null;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!mRecyclableViews.containsKey(surfaceId)) {</span>
      <span class="s1">mRecyclableViews.put(surfaceId</span><span class="s2">, new </span><span class="s1">Stack&lt;T&gt;())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">mRecyclableViews.get(surfaceId)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* For the vast majority of ViewManagers, you will not need to override this. Only override this</span>
   <span class="s3">* if you really know what you're doing and have a very unique use-case.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">viewToUpdate</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">props</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">updateProperties(@NonNull T viewToUpdate</span><span class="s2">, </span><span class="s1">ReactStylesDiffMap props) {</span>
    <span class="s2">final </span><span class="s1">ViewManagerDelegate&lt;T&gt; delegate = getDelegate()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(delegate != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">ViewManagerPropertyUpdater.updateProps(delegate</span><span class="s2">, </span><span class="s1">viewToUpdate</span><span class="s2">, </span><span class="s1">props)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">ViewManagerPropertyUpdater.updateProps(</span><span class="s2">this, </span><span class="s1">viewToUpdate</span><span class="s2">, </span><span class="s1">props)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">onAfterUpdateTransaction(viewToUpdate)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Override this method and return an instance of {</span><span class="s5">@link </span><span class="s3">ViewManagerDelegate} if the props of the</span>
   <span class="s3">* view managed by this view manager should be set via this delegate. The provided instance will</span>
   <span class="s3">* then get calls to {</span><span class="s5">@link </span><span class="s3">ViewManagerDelegate#setProperty(View, String, Object)} for every prop</span>
   <span class="s3">* that must be updated and it's the delegate's responsibility to apply these values to the view.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">&lt;p&gt;</span><span class="s3">By default this method returns {</span><span class="s5">@code </span><span class="s3">null}, which means that the view manager doesn't have</span>
   <span class="s3">* a delegate and the view props should be set internally by the view manager itself.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@return </span><span class="s3">an instance of {</span><span class="s5">@link </span><span class="s3">ViewManagerDelegate} if the props of the view managed by this</span>
   <span class="s3">*     view manager should be set via this delegate</span>
   <span class="s3">*/</span>
  <span class="s1">@Nullable</span>
  <span class="s2">protected </span><span class="s1">ViewManagerDelegate&lt;T&gt; getDelegate() {</span>
    <span class="s2">return null;</span>
  <span class="s1">}</span>

  <span class="s3">/** Creates a view with knowledge of props and state. */</span>
  <span class="s2">public </span><span class="s1">@NonNull T createView(</span>
      <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">,</span>
      <span class="s1">@NonNull ThemedReactContext reactContext</span><span class="s2">,</span>
      <span class="s1">@Nullable ReactStylesDiffMap props</span><span class="s2">,</span>
      <span class="s1">@Nullable StateWrapper stateWrapper</span><span class="s2">,</span>
      <span class="s1">JSResponderHandler jsResponderHandler) {</span>
    <span class="s1">T view = createViewInstance(reactTag</span><span class="s2">, </span><span class="s1">reactContext</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">stateWrapper)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(view </span><span class="s2">instanceof </span><span class="s1">ReactInterceptingViewGroup) {</span>
      <span class="s1">((ReactInterceptingViewGroup) view).setOnInterceptTouchEventListener(jsResponderHandler)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">view</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* </span><span class="s5">@return </span><span class="s3">the name of this view manager. This will be the name used to reference this view</span>
   <span class="s3">*     manager from JavaScript in createReactNativeComponentClass.</span>
   <span class="s3">*/</span>
  <span class="s2">public abstract </span><span class="s1">@NonNull String getName()</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* This method should return a subclass of {</span><span class="s5">@link </span><span class="s3">ReactShadowNode} which will be then used for</span>
   <span class="s3">* measuring position and size of the view. In most of the cases this should just return an</span>
   <span class="s3">* instance of {</span><span class="s5">@link </span><span class="s3">ReactShadowNode}</span>
   <span class="s3">*/</span>
  <span class="s2">public </span><span class="s1">C createShadowNodeInstance() {</span>
    <span class="s2">throw new </span><span class="s1">RuntimeException(</span><span class="s7">&quot;ViewManager subclasses must implement createShadowNodeInstance()&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">@NonNull C createShadowNodeInstance(@NonNull ReactApplicationContext context) {</span>
    <span class="s2">return </span><span class="s1">createShadowNodeInstance()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* This method should return {</span><span class="s5">@link </span><span class="s3">Class} instance that represent type of shadow node that this</span>
   <span class="s3">* manager will return from {</span><span class="s5">@link </span><span class="s3">#createShadowNodeInstance}.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">&lt;p&gt;</span><span class="s3">This method will be used in the bridge initialization phase to collect properties exposed</span>
   <span class="s3">* using {</span><span class="s5">@link </span><span class="s3">ReactProp} (or {</span><span class="s5">@link </span><span class="s3">ReactPropGroup}) annotation from the {</span><span class="s5">@link </span><span class="s3">ReactShadowNode}</span>
   <span class="s3">* subclass specific for native view this manager provides.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@return </span><span class="s3">{</span><span class="s5">@link </span><span class="s3">Class} object that represents type of shadow node used by this view manager.</span>
   <span class="s3">*/</span>
  <span class="s2">public abstract </span><span class="s1">Class&lt;? </span><span class="s2">extends </span><span class="s1">C&gt; getShadowNodeClass()</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Subclasses should return a new View instance of the proper type.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">reactContext</span>
   <span class="s3">*/</span>
  <span class="s2">protected abstract </span><span class="s1">@NonNull T createViewInstance(@NonNull ThemedReactContext reactContext)</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Subclasses should return a new View instance of the proper type. This is an optional method</span>
   <span class="s3">* that will call createViewInstance for you. Override it if you need props upon creation of the</span>
   <span class="s3">* view, or state.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">&lt;p&gt;</span><span class="s3">If you override this method, you *must* guarantee that you you're handling updateProperties,</span>
   <span class="s3">* view.setId, addEventEmitters, and updateState/updateExtraData properly!</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">reactTag reactTag that should be set as ID of the view instance</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">reactContext ReactContext used to initialize view instance</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">initialProps initial props for the view instance</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">stateWrapper initial state for the view instance</span>
   <span class="s3">*/</span>
  <span class="s2">protected </span><span class="s1">@NonNull T createViewInstance(</span>
      <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">,</span>
      <span class="s1">@NonNull ThemedReactContext reactContext</span><span class="s2">,</span>
      <span class="s1">@Nullable ReactStylesDiffMap initialProps</span><span class="s2">,</span>
      <span class="s1">@Nullable StateWrapper stateWrapper) {</span>
    <span class="s1">T view = </span><span class="s2">null;</span>
    <span class="s1">@Nullable Stack&lt;T&gt; recyclableViews = getRecyclableViewStack(reactContext.getSurfaceId())</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(recyclableViews != </span><span class="s2">null </span><span class="s1">&amp;&amp; !recyclableViews.empty()) {</span>
      <span class="s1">view = recycleView(reactContext</span><span class="s2">, </span><span class="s1">recyclableViews.pop())</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">view = createViewInstance(reactContext)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">view.setId(reactTag)</span><span class="s2">;</span>
    <span class="s1">addEventEmitters(reactContext</span><span class="s2">, </span><span class="s1">view)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(initialProps != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">updateProperties(view</span><span class="s2">, </span><span class="s1">initialProps)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// Only present in Fabric; but always present in Fabric.</span>
    <span class="s2">if </span><span class="s1">(stateWrapper != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">Object extraData = updateState(view</span><span class="s2">, </span><span class="s1">initialProps</span><span class="s2">, </span><span class="s1">stateWrapper)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(extraData != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">updateExtraData(view</span><span class="s2">, </span><span class="s1">extraData)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">view</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Called when view is detached from view hierarchy and allows for some additional cleanup by the</span>
   <span class="s3">* {</span><span class="s5">@link </span><span class="s3">ViewManager} subclass.</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">onDropViewInstance(@NonNull T view) {</span>
    <span class="s0">// Some legacy components will return an Activity here instead of a ThemedReactContext</span>
    <span class="s1">Context viewContext = view.getContext()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(viewContext == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Who knows! Anything is possible. Checking instanceof on null is an NPE,</span>
      <span class="s0">// So this is not redundant.</span>
      <span class="s1">FLog.e(NAME</span><span class="s2">, </span><span class="s7">&quot;onDropViewInstance: view [&quot; </span><span class="s1">+ view.getId() + </span><span class="s7">&quot;] has a null context&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!(viewContext </span><span class="s2">instanceof </span><span class="s1">ThemedReactContext)) {</span>
      <span class="s1">FLog.e(</span>
          <span class="s1">NAME</span><span class="s2">,</span>
          <span class="s7">&quot;onDropViewInstance: view [&quot;</span>
              <span class="s1">+ view.getId()</span>
              <span class="s1">+ </span><span class="s7">&quot;] has a context that is not a ThemedReactContext: &quot;</span>
              <span class="s1">+ viewContext)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s0">// View recycling</span>
    <span class="s1">ThemedReactContext themedReactContext = (ThemedReactContext) viewContext</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">surfaceId = themedReactContext.getSurfaceId()</span><span class="s2">;</span>
    <span class="s1">@Nullable Stack&lt;T&gt; recyclableViews = getRecyclableViewStack(surfaceId)</span><span class="s2">;</span>

    <span class="s0">// Any max buffer size &lt;0 results in an infinite buffer size</span>
    <span class="s2">if </span><span class="s1">(recyclableViews != </span><span class="s2">null</span>
        <span class="s1">&amp;&amp; (mRecyclableViewsBufferSize &lt; </span><span class="s4">0</span>
            <span class="s1">|| recyclableViews.size() &lt; mRecyclableViewsBufferSize)) {</span>
      <span class="s1">recyclableViews.push(prepareToRecycleView(themedReactContext</span><span class="s2">, </span><span class="s1">view))</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Called when a View is removed from the hierarchy. This should be used to reset any properties.</span>
   <span class="s3">*/</span>
  <span class="s2">protected </span><span class="s1">T prepareToRecycleView(@NonNull ThemedReactContext reactContext</span><span class="s2">, </span><span class="s1">@NonNull T view) {</span>
    <span class="s2">return </span><span class="s1">view</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Called when a View is going to be reused. */</span>
  <span class="s2">protected </span><span class="s1">T recycleView(@NonNull ThemedReactContext reactContext</span><span class="s2">, </span><span class="s1">@NonNull T view) {</span>
    <span class="s2">return </span><span class="s1">view</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Subclasses can override this method to install custom event emitters on the given View. You</span>
   <span class="s3">* might want to override this method if your view needs to emit events besides basic touch events</span>
   <span class="s3">* to JS (e.g. scroll events).</span>
   <span class="s3">*/</span>
  <span class="s2">protected void </span><span class="s1">addEventEmitters(@NonNull ThemedReactContext reactContext</span><span class="s2">, </span><span class="s1">@NonNull T view) {}</span>

  <span class="s3">/**</span>
   <span class="s3">* Callback that will be triggered after all properties are updated in current update transaction</span>
   <span class="s3">* (all @ReactProp handlers for properties updated in current transaction have been called). If</span>
   <span class="s3">* you want to override this method you should call super.onAfterUpdateTransaction from it as the</span>
   <span class="s3">* parent class of the ViewManager may rely on callback being executed.</span>
   <span class="s3">*/</span>
  <span class="s2">protected void </span><span class="s1">onAfterUpdateTransaction(@NonNull T view) {}</span>

  <span class="s3">/**</span>
   <span class="s3">* Subclasses can implement this method to receive an optional extra data enqueued from the</span>
   <span class="s3">* corresponding instance of {</span><span class="s5">@link </span><span class="s3">ReactShadowNode} in {</span><span class="s5">@link</span>
   <span class="s3">* ReactShadowNode#onCollectExtraUpdates}.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">&lt;p&gt;</span><span class="s3">Since css layout step and ui updates can be executed in separate thread apart of setting</span>
   <span class="s3">* x/y/width/height this is the recommended and thread-safe way of passing extra data from css</span>
   <span class="s3">* node to the native view counterpart.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">&lt;p&gt;</span><span class="s3">TODO T7247021: Replace updateExtraData with generic update props mechanism after D2086999</span>
   <span class="s3">*/</span>
  <span class="s2">public abstract void </span><span class="s1">updateExtraData(@NonNull T root</span><span class="s2">, </span><span class="s1">Object extraData)</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Subclasses may use this method to receive events/commands directly from JS through the {</span><span class="s5">@link</span>
   <span class="s3">* UIManager}. Good example of such a command would be {</span><span class="s5">@code </span><span class="s3">scrollTo} request with coordinates</span>
   <span class="s3">* for a {</span><span class="s5">@link </span><span class="s3">ScrollView} instance.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">&lt;p&gt;</span><span class="s3">This method is deprecated use {</span><span class="s5">@link </span><span class="s3">#receiveCommand(View, String, ReadableArray)} instead.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">root View instance that should receive the command</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">commandId code of the command</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">args optional arguments for the command</span>
   <span class="s3">*/</span>
  <span class="s1">@Deprecated</span>
  <span class="s2">public void </span><span class="s1">receiveCommand(@NonNull T root</span><span class="s2">, int </span><span class="s1">commandId</span><span class="s2">, </span><span class="s1">@Nullable ReadableArray args) {}</span>

  <span class="s3">/**</span>
   <span class="s3">* Subclasses may use this method to receive events/commands directly from JS through the {</span><span class="s5">@link</span>
   <span class="s3">* UIManager}. Good example of such a command would be {</span><span class="s5">@code </span><span class="s3">scrollTo} request with coordinates</span>
   <span class="s3">* for a {</span><span class="s5">@link </span><span class="s3">ReactScrollView} instance.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">root View instance that should receive the command</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">commandId code of the command</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">args optional arguments for the command</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">receiveCommand(@NonNull T root</span><span class="s2">, </span><span class="s1">String commandId</span><span class="s2">, </span><span class="s1">@Nullable ReadableArray args) {}</span>

  <span class="s3">/**</span>
   <span class="s3">* Subclasses of {</span><span class="s5">@link </span><span class="s3">ViewManager} that expect to receive commands through {</span><span class="s5">@link</span>
   <span class="s3">* UIManagerModule#dispatchViewManagerCommand} should override this method returning the map</span>
   <span class="s3">* between names of the commands and IDs that are then used in {</span><span class="s5">@link </span><span class="s3">#receiveCommand} method</span>
   <span class="s3">* whenever the command is dispatched for this particular {</span><span class="s5">@link </span><span class="s3">ViewManager}.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@return </span><span class="s3">map of string to int mapping of the expected commands</span>
   <span class="s3">*/</span>
  <span class="s2">public </span><span class="s1">@Nullable Map&lt;String</span><span class="s2">, </span><span class="s1">Integer&gt; getCommandsMap() {</span>
    <span class="s2">return null;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Returns a map of config data passed to JS that defines eligible events that can be placed on</span>
   <span class="s3">* native views. This should return bubbling directly-dispatched event types and specify what</span>
   <span class="s3">* names should be used to subscribe to either form (bubbling/capturing).</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">&lt;p&gt;</span><span class="s3">Returned map should be of the form:</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">&lt;pre&gt;</span>
   <span class="s3">* {</span>
   <span class="s3">*   &quot;onTwirl&quot;: {</span>
   <span class="s3">*     &quot;phasedRegistrationNames&quot;: {</span>
   <span class="s3">*       &quot;bubbled&quot;: &quot;onTwirl&quot;,</span>
   <span class="s3">*       &quot;captured&quot;: &quot;onTwirlCaptured&quot;</span>
   <span class="s3">*     }</span>
   <span class="s3">*   }</span>
   <span class="s3">* }</span>
   <span class="s3">* </span><span class="s6">&lt;/pre&gt;</span>
   <span class="s3">*/</span>
  <span class="s2">public </span><span class="s1">@Nullable Map&lt;String</span><span class="s2">, </span><span class="s1">Object&gt; getExportedCustomBubblingEventTypeConstants() {</span>
    <span class="s2">return null;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Returns a map of config data passed to JS that defines eligible events that can be placed on</span>
   <span class="s3">* native views. This should return non-bubbling directly-dispatched event types.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">&lt;p&gt;</span><span class="s3">Returned map should be of the form:</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">&lt;pre&gt;</span>
   <span class="s3">* {</span>
   <span class="s3">*   &quot;onTwirl&quot;: {</span>
   <span class="s3">*     &quot;registrationName&quot;: &quot;onTwirl&quot;</span>
   <span class="s3">*   }</span>
   <span class="s3">* }</span>
   <span class="s3">* </span><span class="s6">&lt;/pre&gt;</span>
   <span class="s3">*/</span>
  <span class="s2">public </span><span class="s1">@Nullable Map&lt;String</span><span class="s2">, </span><span class="s1">Object&gt; getExportedCustomDirectEventTypeConstants() {</span>
    <span class="s2">return null;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Returns a map of view-specific constants that are injected to JavaScript. These constants are</span>
   <span class="s3">* made accessible via UIManager.</span><span class="s6">&lt;ViewName&gt;</span><span class="s3">.Constants.</span>
   <span class="s3">*/</span>
  <span class="s2">public </span><span class="s1">@Nullable Map&lt;String</span><span class="s2">, </span><span class="s1">Object&gt; getExportedViewConstants() {</span>
    <span class="s2">return null;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Returns a {</span><span class="s5">@link </span><span class="s3">Map</span><span class="s1">&lt;</span><span class="s3">String</span><span class="s1">, </span><span class="s3">String</span><span class="s1">&gt;</span><span class="s3">} representing the native props of the view manager. The</span>
   <span class="s3">* Map contains the names (key) and types (value) of the ViewManager's props.</span>
   <span class="s3">*/</span>
  <span class="s2">public </span><span class="s1">Map&lt;String</span><span class="s2">, </span><span class="s1">String&gt; getNativeProps() {</span>
    <span class="s2">return </span><span class="s1">ViewManagerPropertyUpdater.getNativeProps(getClass()</span><span class="s2">, </span><span class="s1">getShadowNodeClass())</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Subclasses can implement this method to receive state updates shared between all instances of</span>
   <span class="s3">* this component type.</span>
   <span class="s3">*/</span>
  <span class="s2">public </span><span class="s1">@Nullable Object updateState(</span>
      <span class="s1">@NonNull T view</span><span class="s2">, </span><span class="s1">ReactStylesDiffMap props</span><span class="s2">, </span><span class="s1">StateWrapper stateWrapper) {</span>
    <span class="s2">return null;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Subclasses can override this method to implement custom measure functions for the ViewManager</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">context {</span><span class="s5">@link </span><span class="s3">com.facebook.react.bridge.ReactContext} used for the view.</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">localData {</span><span class="s5">@link </span><span class="s3">ReadableMap} containing &quot;local data&quot; defined in C++</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">props {</span><span class="s5">@link </span><span class="s3">ReadableMap} containing JS props</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">state {</span><span class="s5">@link </span><span class="s3">ReadableMap} containing state defined in C++</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">width width of the view (usually zero)</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">widthMode widthMode used during calculation of layout</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">height height of the view (usually zero)</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">heightMode widthMode used during calculation of layout</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">attachmentsPositions {</span><span class="s5">@link </span><span class="s3">int[]} array containing 2x times the amount of attachments</span>
   <span class="s3">*     of the view. An attachment represents the position of an inline view that needs to be</span>
   <span class="s3">*     rendered inside a component and it requires the content of the parent view in order to be</span>
   <span class="s3">*     positioned. This array is meant to be used by the platform to RETURN the position of each</span>
   <span class="s3">*     attachment, as a result of the calculation of layout. (e.g. this array is used to measure</span>
   <span class="s3">*     inlineViews that are rendered inside Text components). On most of the components this array</span>
   <span class="s3">*     will be contain a null value.</span>
   <span class="s3">*     </span><span class="s6">&lt;p&gt;</span><span class="s3">Even values will represent the TOP of each attachment, Odd values represent the LEFT of</span>
   <span class="s3">*     each attachment.</span>
   <span class="s3">* </span><span class="s5">@return </span><span class="s3">result of calculation of layout for the arguments received as a parameter.</span>
   <span class="s3">*/</span>
  <span class="s2">public long </span><span class="s1">measure(</span>
      <span class="s1">Context context</span><span class="s2">,</span>
      <span class="s1">ReadableMap localData</span><span class="s2">,</span>
      <span class="s1">ReadableMap props</span><span class="s2">,</span>
      <span class="s1">ReadableMap state</span><span class="s2">,</span>
      <span class="s2">float </span><span class="s1">width</span><span class="s2">,</span>
      <span class="s1">YogaMeasureMode widthMode</span><span class="s2">,</span>
      <span class="s2">float </span><span class="s1">height</span><span class="s2">,</span>
      <span class="s1">YogaMeasureMode heightMode</span><span class="s2">,</span>
      <span class="s1">@Nullable </span><span class="s2">float</span><span class="s1">[] attachmentsPositions) {</span>
    <span class="s2">return </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* THIS MEASURE METHOD IS EXPERIMENTAL, MOST LIKELY YOU ARE LOOKING TO USE THE OTHER OVERLOAD</span>
   <span class="s3">* INSTEAD: {</span><span class="s5">@link </span><span class="s3">#measure(Context, ReadableMap, ReadableMap, ReadableMap, float,</span>
   <span class="s3">* YogaMeasureMode, float, YogaMeasureMode, float[])}</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">&lt;p&gt;</span><span class="s3">Subclasses can override this method to implement custom measure functions for the</span>
   <span class="s3">* ViewManager</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">context {</span><span class="s5">@link </span><span class="s3">com.facebook.react.bridge.ReactContext} used for the view.</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">localData {</span><span class="s5">@link </span><span class="s3">MapBuffer} containing &quot;local data&quot; defined in C++</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">props {</span><span class="s5">@link </span><span class="s3">MapBuffer} containing JS props</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">state {</span><span class="s5">@link </span><span class="s3">MapBuffer} containing state defined in C++</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">width width of the view (usually zero)</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">widthMode widthMode used during calculation of layout</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">height height of the view (usually zero)</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">heightMode widthMode used during calculation of layout</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">attachmentsPositions {</span><span class="s5">@link </span><span class="s3">int[]} array containing 2x times the amount of attachments</span>
   <span class="s3">*     of the view. An attachment represents the position of an inline view that needs to be</span>
   <span class="s3">*     rendered inside a component and it requires the content of the parent view in order to be</span>
   <span class="s3">*     positioned. This array is meant to be used by the platform to RETURN the position of each</span>
   <span class="s3">*     attachment, as a result of the calculation of layout. (e.g. this array is used to measure</span>
   <span class="s3">*     inlineViews that are rendered inside Text components). On most of the components this array</span>
   <span class="s3">*     will be contain a null value.</span>
   <span class="s3">*     </span><span class="s6">&lt;p&gt;</span><span class="s3">Even values will represent the TOP of each attachment, Odd values represent the LEFT of</span>
   <span class="s3">*     each attachment.</span>
   <span class="s3">* </span><span class="s5">@return </span><span class="s3">result of calculation of layout for the arguments received as a parameter.</span>
   <span class="s3">*/</span>
  <span class="s2">public long </span><span class="s1">measure(</span>
      <span class="s1">Context context</span><span class="s2">,</span>
      <span class="s1">MapBuffer localData</span><span class="s2">,</span>
      <span class="s1">MapBuffer props</span><span class="s2">,</span>
      <span class="s0">// TODO(T114731225): review whether state parameter is needed</span>
      <span class="s1">@Nullable MapBuffer state</span><span class="s2">,</span>
      <span class="s2">float </span><span class="s1">width</span><span class="s2">,</span>
      <span class="s1">YogaMeasureMode widthMode</span><span class="s2">,</span>
      <span class="s2">float </span><span class="s1">height</span><span class="s2">,</span>
      <span class="s1">YogaMeasureMode heightMode</span><span class="s2">,</span>
      <span class="s1">@Nullable </span><span class="s2">float</span><span class="s1">[] attachmentsPositions) {</span>
    <span class="s2">return </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Subclasses can override this method to set padding for the given View in Fabric. Since not all</span>
   <span class="s3">* components support setting padding, the default implementation of this method does nothing.</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">setPadding(T view</span><span class="s2">, int </span><span class="s1">left</span><span class="s2">, int </span><span class="s1">top</span><span class="s2">, int </span><span class="s1">right</span><span class="s2">, int </span><span class="s1">bottom) {}</span>

  <span class="s3">/**</span>
   <span class="s3">* Lifecycle method: called when a surface is stopped. Currently only used for View Recycling</span>
   <span class="s3">* cleanup. There is no corresponding startSurface lifecycle event for ViewManagers because we</span>
   <span class="s3">* currently only need this for recycling cleanup. Only called in Fabric.</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">onSurfaceStopped(</span><span class="s2">int </span><span class="s1">surfaceId) {</span>
    <span class="s2">if </span><span class="s1">(mRecyclableViews != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mRecyclableViews.remove(surfaceId)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** With even slight memory pressure, we immediately evict all recyclable Views. */</span>
  <span class="s0">/* package */ </span><span class="s2">void </span><span class="s1">trimMemory() {</span>
    <span class="s0">// Wipe out all existing recyclable Views, but do not disable View Recycling entirely.</span>
    <span class="s0">// We only take any action if View Recycling is already enabled.</span>
    <span class="s2">if </span><span class="s1">(mRecyclableViews != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mRecyclableViews = </span><span class="s2">new </span><span class="s1">HashMap&lt;&gt;()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
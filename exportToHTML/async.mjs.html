<html>
<head>
<title>async.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #cc7832;}
.s2 { color: #a9b7c6;}
.s3 { color: #a9b7c6;}
.s4 { color: #ffc66d;}
.s5 { color: #6a8759;}
.s6 { color: #6897bb; font-style: italic;}
.s7 { color: #9876aa; font-style: italic;}
.s8 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
async.mjs</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Creates a continuation function with some arguments already applied. 
 * 
 * Useful as a shorthand when combined with other control flow functions. Any 
 * arguments passed to the returned function are added to the arguments 
 * originally passed to apply. 
 * 
 * </span><span class="s1">@name </span><span class="s2">apply</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util 
 * </span><span class="s1">@param </span><span class="s2">{Function} fn </span><span class="s0">- The function you want to eventually apply all 
 * arguments to. Invokes with (arguments...). 
 * </span><span class="s1">@param </span><span class="s2">{...*} arguments... </span><span class="s0">- Any number of arguments to automatically apply 
 * when the continuation is called. 
 * </span><span class="s1">@returns </span><span class="s2">{Function} </span><span class="s0">the partially-applied function 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // using apply 
 * async.parallel([ 
 *     async.apply(fs.writeFile, 'testfile1', 'test1'), 
 *     async.apply(fs.writeFile, 'testfile2', 'test2') 
 * ]); 
 * 
 * 
 * // the same process without using apply 
 * async.parallel([ 
 *     function(callback) { 
 *         fs.writeFile('testfile1', 'test1', callback); 
 *     }, 
 *     function(callback) { 
 *         fs.writeFile('testfile2', 'test2', callback); 
 *     } 
 * ]); 
 * 
 * // It's possible to pass any number of additional arguments when calling the 
 * // continuation: 
 * 
 * node&gt; var fn = async.apply(sys.puts, 'one'); 
 * node&gt; fn('two', 'three'); 
 * one 
 * two 
 * three 
 */</span>
<span class="s1">function </span><span class="s3">apply(</span><span class="s2">fn</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s3">(</span><span class="s1">...</span><span class="s2">callArgs</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s4">fn</span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">,</span><span class="s1">...</span><span class="s2">callArgs</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">initialParams (</span><span class="s2">fn</span><span class="s3">) {</span>
    <span class="s1">return function </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s0">/*, callback*/</span><span class="s3">) {</span>
        <span class="s1">var </span><span class="s3">callback </span><span class="s1">= </span><span class="s2">args</span><span class="s3">.</span><span class="s4">pop</span><span class="s3">();</span>
        <span class="s1">return </span><span class="s2">fn</span><span class="s3">.</span><span class="s4">call</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s2">args</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">);</span>
    <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">/* istanbul ignore file */</span>

<span class="s1">var </span><span class="s3">hasQueueMicrotask </span><span class="s1">= typeof </span><span class="s2">queueMicrotask </span><span class="s1">=== </span><span class="s5">'function' </span><span class="s1">&amp;&amp; </span><span class="s2">queueMicrotask</span><span class="s3">;</span>
<span class="s1">var </span><span class="s3">hasSetImmediate </span><span class="s1">= typeof </span><span class="s2">setImmediate </span><span class="s1">=== </span><span class="s5">'function' </span><span class="s1">&amp;&amp; </span><span class="s2">setImmediate</span><span class="s3">;</span>
<span class="s1">var </span><span class="s3">hasNextTick </span><span class="s1">= typeof </span><span class="s2">process </span><span class="s1">=== </span><span class="s5">'object' </span><span class="s1">&amp;&amp; typeof </span><span class="s2">process</span><span class="s3">.</span><span class="s2">nextTick </span><span class="s1">=== </span><span class="s5">'function'</span><span class="s3">;</span>

<span class="s1">function </span><span class="s3">fallback(</span><span class="s2">fn</span><span class="s3">) {</span>
    <span class="s4">setTimeout</span><span class="s3">(</span><span class="s2">fn</span><span class="s3">, </span><span class="s6">0</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">wrap(</span><span class="s2">defer</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s3">(</span><span class="s2">fn</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s4">defer</span><span class="s3">(() </span><span class="s1">=&gt; </span><span class="s4">fn</span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">));</span>
<span class="s3">}</span>

<span class="s1">var </span><span class="s3">_defer;</span>

<span class="s1">if </span><span class="s3">(</span><span class="s2">hasQueueMicrotask</span><span class="s3">) {</span>
    <span class="s2">_defer </span><span class="s1">= </span><span class="s2">queueMicrotask</span><span class="s3">;</span>
<span class="s3">} </span><span class="s1">else if </span><span class="s3">(</span><span class="s2">hasSetImmediate</span><span class="s3">) {</span>
    <span class="s2">_defer </span><span class="s1">= </span><span class="s2">setImmediate</span><span class="s3">;</span>
<span class="s3">} </span><span class="s1">else if </span><span class="s3">(</span><span class="s2">hasNextTick</span><span class="s3">) {</span>
    <span class="s2">_defer </span><span class="s1">= </span><span class="s2">process</span><span class="s3">.</span><span class="s2">nextTick</span><span class="s3">;</span>
<span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
    <span class="s2">_defer </span><span class="s1">= </span><span class="s2">fallback</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s1">var </span><span class="s3">setImmediate$1 </span><span class="s1">= </span><span class="s4">wrap</span><span class="s3">(</span><span class="s2">_defer</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* Take a sync function and make it async, passing its return value to a 
 * callback. This is useful for plugging sync functions into a waterfall, 
 * series, or other async functions. Any arguments passed to the generated 
 * function will be passed to the wrapped function (except for the final 
 * callback argument). Errors thrown will be passed to the callback. 
 * 
 * If the function passed to `asyncify` returns a Promise, that promises's 
 * resolved/rejected state will be used to call the callback, rather than simply 
 * the synchronous return value. 
 * 
 * This also means you can asyncify ES2017 `async` functions. 
 * 
 * </span><span class="s1">@name </span><span class="s2">asyncify</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">wrapSync</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util 
 * </span><span class="s1">@param </span><span class="s2">{Function} func </span><span class="s0">- The synchronous function, or Promise-returning 
 * function to convert to an </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">AsyncFunction}</span><span class="s0">. 
 * </span><span class="s1">@returns </span><span class="s2">{AsyncFunction} </span><span class="s0">An asynchronous wrapper of the `func`. To be 
 * invoked with `(args..., callback)`. 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // passing a regular synchronous function 
 * async.waterfall([ 
 *     async.apply(fs.readFile, filename, &quot;utf8&quot;), 
 *     async.asyncify(JSON.parse), 
 *     function (data, next) { 
 *         // data is the result of parsing the text. 
 *         // If there was a parsing error, it would have been caught. 
 *     } 
 * ], callback); 
 * 
 * // passing a function returning a promise 
 * async.waterfall([ 
 *     async.apply(fs.readFile, filename, &quot;utf8&quot;), 
 *     async.asyncify(function (contents) { 
 *         return db.model.create(contents); 
 *     }), 
 *     function (model, next) { 
 *         // `model` is the instantiated model object. 
 *         // If there was an error, this function would be skipped. 
 *     } 
 * ], callback); 
 * 
 * // es2017 example, though `asyncify` is not needed if your JS environment 
 * // supports async functions out of the box 
 * var q = async.queue(async.asyncify(async function(file) { 
 *     var intermediateStep = await processFile(file); 
 *     return await somePromise(intermediateStep) 
 * })); 
 * 
 * q.push(files); 
 */</span>
<span class="s1">function </span><span class="s3">asyncify(</span><span class="s2">func</span><span class="s3">) {</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s4">isAsync</span><span class="s3">(</span><span class="s2">func</span><span class="s3">)) {</span>
        <span class="s1">return function </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s0">/*, callback*/</span><span class="s3">) {</span>
            <span class="s1">const </span><span class="s3">callback </span><span class="s1">= </span><span class="s2">args</span><span class="s3">.</span><span class="s4">pop</span><span class="s3">();</span>
            <span class="s1">const </span><span class="s3">promise </span><span class="s1">= </span><span class="s2">func</span><span class="s3">.</span><span class="s4">apply</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s2">args</span><span class="s3">);</span>
            <span class="s1">return </span><span class="s4">handlePromise</span><span class="s3">(</span><span class="s2">promise</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
        <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s1">return </span><span class="s4">initialParams</span><span class="s3">(</span><span class="s1">function </span><span class="s3">(</span><span class="s2">args</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
        <span class="s1">var </span><span class="s3">result;</span>
        <span class="s1">try </span><span class="s3">{</span>
            <span class="s2">result </span><span class="s1">= </span><span class="s2">func</span><span class="s3">.</span><span class="s4">apply</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s2">args</span><span class="s3">);</span>
        <span class="s3">} </span><span class="s1">catch </span><span class="s3">(</span><span class="s2">e</span><span class="s3">) {</span>
            <span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">e</span><span class="s3">);</span>
        <span class="s3">}</span>
        <span class="s0">// if result is Promise object</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">result </span><span class="s1">&amp;&amp; typeof </span><span class="s2">result</span><span class="s3">.</span><span class="s2">then </span><span class="s1">=== </span><span class="s5">'function'</span><span class="s3">) {</span>
            <span class="s1">return </span><span class="s4">handlePromise</span><span class="s3">(</span><span class="s2">result</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
        <span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
            <span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">, </span><span class="s2">result</span><span class="s3">);</span>
        <span class="s3">}</span>
    <span class="s3">});</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">handlePromise(</span><span class="s2">promise</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s2">promise</span><span class="s3">.</span><span class="s4">then</span><span class="s3">(</span><span class="s2">value </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s4">invokeCallback</span><span class="s3">(</span><span class="s2">callback</span><span class="s3">, </span><span class="s7">null</span><span class="s3">, </span><span class="s2">value</span><span class="s3">);</span>
    <span class="s3">}, </span><span class="s2">err </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s4">invokeCallback</span><span class="s3">(</span><span class="s2">callback</span><span class="s3">, </span><span class="s2">err </span><span class="s1">&amp;&amp; </span><span class="s2">err</span><span class="s3">.</span><span class="s2">message </span><span class="s1">? </span><span class="s2">err </span><span class="s1">: new </span><span class="s4">Error</span><span class="s3">(</span><span class="s2">err</span><span class="s3">));</span>
    <span class="s3">});</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">invokeCallback(</span><span class="s2">callback</span><span class="s3">, </span><span class="s2">error</span><span class="s3">, </span><span class="s2">value</span><span class="s3">) {</span>
    <span class="s1">try </span><span class="s3">{</span>
        <span class="s4">callback</span><span class="s3">(</span><span class="s2">error</span><span class="s3">, </span><span class="s2">value</span><span class="s3">);</span>
    <span class="s3">} </span><span class="s1">catch </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) {</span>
        <span class="s4">setImmediate$1</span><span class="s3">(</span><span class="s2">e </span><span class="s1">=&gt; </span><span class="s3">{ </span><span class="s1">throw </span><span class="s2">e </span><span class="s3">}, </span><span class="s2">err</span><span class="s3">);</span>
    <span class="s3">}</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">isAsync(</span><span class="s2">fn</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s2">fn</span><span class="s3">[</span><span class="s2">Symbol</span><span class="s3">.</span><span class="s2">toStringTag</span><span class="s3">] </span><span class="s1">=== </span><span class="s5">'AsyncFunction'</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">isAsyncGenerator(</span><span class="s2">fn</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s2">fn</span><span class="s3">[</span><span class="s2">Symbol</span><span class="s3">.</span><span class="s2">toStringTag</span><span class="s3">] </span><span class="s1">=== </span><span class="s5">'AsyncGenerator'</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">isAsyncIterable(</span><span class="s2">obj</span><span class="s3">) {</span>
    <span class="s1">return typeof </span><span class="s2">obj</span><span class="s3">[</span><span class="s2">Symbol</span><span class="s3">.</span><span class="s2">asyncIterator</span><span class="s3">] </span><span class="s1">=== </span><span class="s5">'function'</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">wrapAsync(</span><span class="s2">asyncFn</span><span class="s3">) {</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s1">typeof </span><span class="s2">asyncFn </span><span class="s1">!== </span><span class="s5">'function'</span><span class="s3">) </span><span class="s1">throw new </span><span class="s4">Error</span><span class="s3">(</span><span class="s5">'expected a function'</span><span class="s3">)</span>
    <span class="s1">return </span><span class="s4">isAsync</span><span class="s3">(</span><span class="s2">asyncFn</span><span class="s3">) </span><span class="s1">? </span><span class="s4">asyncify</span><span class="s3">(</span><span class="s2">asyncFn</span><span class="s3">) </span><span class="s1">: </span><span class="s2">asyncFn</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// conditionally promisify a function.</span>
<span class="s0">// only return a promise if a callback is omitted</span>
<span class="s1">function </span><span class="s3">awaitify (</span><span class="s2">asyncFn</span><span class="s3">, </span><span class="s2">arity </span><span class="s1">= </span><span class="s2">asyncFn</span><span class="s3">.length) {</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">arity</span><span class="s3">) </span><span class="s1">throw new </span><span class="s4">Error</span><span class="s3">(</span><span class="s5">'arity is undefined'</span><span class="s3">)</span>
    <span class="s1">function </span><span class="s3">awaitable (</span><span class="s1">...</span><span class="s2">args</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s1">typeof </span><span class="s2">args</span><span class="s3">[</span><span class="s2">arity </span><span class="s1">- </span><span class="s6">1</span><span class="s3">] </span><span class="s1">=== </span><span class="s5">'function'</span><span class="s3">) {</span>
            <span class="s1">return </span><span class="s2">asyncFn</span><span class="s3">.</span><span class="s4">apply</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s2">args</span><span class="s3">)</span>
        <span class="s3">}</span>

        <span class="s1">return new </span><span class="s3">Promise((</span><span class="s2">resolve</span><span class="s3">, </span><span class="s2">reject</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s2">args</span><span class="s3">[</span><span class="s2">arity </span><span class="s1">- </span><span class="s6">1</span><span class="s3">] </span><span class="s1">= </span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">cbArgs</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
                <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">reject</span><span class="s3">(</span><span class="s2">err</span><span class="s3">)</span>
                <span class="s4">resolve</span><span class="s3">(</span><span class="s2">cbArgs</span><span class="s3">.length </span><span class="s1">&gt; </span><span class="s6">1 </span><span class="s1">? </span><span class="s2">cbArgs </span><span class="s1">: </span><span class="s2">cbArgs</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]);</span>
            <span class="s3">};</span>
            <span class="s2">asyncFn</span><span class="s3">.</span><span class="s4">apply</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s2">args</span><span class="s3">);</span>
        <span class="s3">})</span>
    <span class="s3">}</span>

    <span class="s1">return </span><span class="s2">awaitable</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">applyEach (</span><span class="s2">eachfn</span><span class="s3">) {</span>
    <span class="s1">return function </span><span class="s3">applyEach(</span><span class="s2">fns</span><span class="s3">, </span><span class="s1">...</span><span class="s2">callArgs</span><span class="s3">) {</span>
        <span class="s1">const </span><span class="s3">go </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s1">function </span><span class="s3">(</span><span class="s2">callback</span><span class="s3">) {</span>
            <span class="s1">var </span><span class="s3">that </span><span class="s1">= </span><span class="s2">this</span><span class="s3">;</span>
            <span class="s1">return </span><span class="s4">eachfn</span><span class="s3">(</span><span class="s2">fns</span><span class="s3">, (</span><span class="s2">fn</span><span class="s3">, </span><span class="s2">cb</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
                <span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">fn</span><span class="s3">).</span><span class="s4">apply</span><span class="s3">(</span><span class="s2">that</span><span class="s3">, </span><span class="s2">callArgs</span><span class="s3">.</span><span class="s4">concat</span><span class="s3">(</span><span class="s2">cb</span><span class="s3">));</span>
            <span class="s3">}, </span><span class="s2">callback</span><span class="s3">);</span>
        <span class="s3">});</span>
        <span class="s1">return </span><span class="s2">go</span><span class="s3">;</span>
    <span class="s3">};</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">_asyncMap(</span><span class="s2">eachfn</span><span class="s3">, </span><span class="s2">arr</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s2">arr </span><span class="s1">= </span><span class="s2">arr </span><span class="s1">|| </span><span class="s3">[];</span>
    <span class="s1">var </span><span class="s3">results </span><span class="s1">= </span><span class="s3">[];</span>
    <span class="s1">var </span><span class="s3">counter </span><span class="s1">= </span><span class="s6">0</span><span class="s3">;</span>
    <span class="s1">var </span><span class="s3">_iteratee </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">iteratee</span><span class="s3">);</span>

    <span class="s1">return </span><span class="s4">eachfn</span><span class="s3">(</span><span class="s2">arr</span><span class="s3">, (</span><span class="s2">value</span><span class="s3">, </span><span class="s2">_</span><span class="s3">, </span><span class="s2">iterCb</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s1">var </span><span class="s3">index </span><span class="s1">= </span><span class="s2">counter</span><span class="s1">++</span><span class="s3">;</span>
        <span class="s4">_iteratee</span><span class="s3">(</span><span class="s2">value</span><span class="s3">, (</span><span class="s2">err</span><span class="s3">, </span><span class="s2">v</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s2">results</span><span class="s3">[</span><span class="s2">index</span><span class="s3">] </span><span class="s1">= </span><span class="s2">v</span><span class="s3">;</span>
            <span class="s4">iterCb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
        <span class="s3">});</span>
    <span class="s3">}, </span><span class="s2">err </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s2">results</span><span class="s3">);</span>
    <span class="s3">});</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">isArrayLike(</span><span class="s2">value</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s2">value </span><span class="s1">&amp;&amp;</span>
        <span class="s1">typeof </span><span class="s2">value</span><span class="s3">.length </span><span class="s1">=== </span><span class="s5">'number' </span><span class="s1">&amp;&amp;</span>
        <span class="s2">value</span><span class="s3">.length </span><span class="s1">&gt;= </span><span class="s6">0 </span><span class="s1">&amp;&amp;</span>
        <span class="s2">value</span><span class="s3">.length </span><span class="s1">% </span><span class="s6">1 </span><span class="s1">=== </span><span class="s6">0</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// A temporary value used to identify if the loop should be broken.</span>
<span class="s0">// See #1064, #1293</span>
<span class="s1">const </span><span class="s3">breakLoop </span><span class="s1">= </span><span class="s3">{};</span>

<span class="s1">function </span><span class="s3">once(</span><span class="s2">fn</span><span class="s3">) {</span>
    <span class="s1">function </span><span class="s3">wrapper (</span><span class="s1">...</span><span class="s2">args</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">fn </span><span class="s1">=== </span><span class="s7">null</span><span class="s3">) </span><span class="s1">return</span><span class="s3">;</span>
        <span class="s1">var </span><span class="s3">callFn </span><span class="s1">= </span><span class="s2">fn</span><span class="s3">;</span>
        <span class="s2">fn </span><span class="s1">= </span><span class="s7">null</span><span class="s3">;</span>
        <span class="s2">callFn</span><span class="s3">.</span><span class="s4">apply</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s2">args</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s2">Object</span><span class="s3">.</span><span class="s4">assign</span><span class="s3">(</span><span class="s2">wrapper</span><span class="s3">, </span><span class="s2">fn</span><span class="s3">);</span>
    <span class="s1">return </span><span class="s2">wrapper</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">getIterator (</span><span class="s2">coll</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s2">coll</span><span class="s3">[</span><span class="s2">Symbol</span><span class="s3">.</span><span class="s2">iterator</span><span class="s3">] </span><span class="s1">&amp;&amp; </span><span class="s2">coll</span><span class="s3">[</span><span class="s2">Symbol</span><span class="s3">.</span><span class="s2">iterator</span><span class="s3">]();</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">createArrayIterator(</span><span class="s2">coll</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">i </span><span class="s1">= -</span><span class="s6">1</span><span class="s3">;</span>
    <span class="s1">var </span><span class="s3">len </span><span class="s1">= </span><span class="s2">coll</span><span class="s3">.length;</span>
    <span class="s1">return function </span><span class="s3">next() {</span>
        <span class="s1">return ++</span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">len </span><span class="s1">? </span><span class="s3">{value: </span><span class="s2">coll</span><span class="s3">[</span><span class="s2">i</span><span class="s3">], key: </span><span class="s2">i</span><span class="s3">} </span><span class="s1">: </span><span class="s7">null</span><span class="s3">;</span>
    <span class="s3">}</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">createES2015Iterator(</span><span class="s2">iterator</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">i </span><span class="s1">= -</span><span class="s6">1</span><span class="s3">;</span>
    <span class="s1">return function </span><span class="s3">next() {</span>
        <span class="s1">var </span><span class="s3">item </span><span class="s1">= </span><span class="s2">iterator</span><span class="s3">.</span><span class="s4">next</span><span class="s3">();</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">item</span><span class="s3">.</span><span class="s2">done</span><span class="s3">)</span>
            <span class="s1">return </span><span class="s7">null</span><span class="s3">;</span>
        <span class="s2">i</span><span class="s1">++</span><span class="s3">;</span>
        <span class="s1">return </span><span class="s3">{value: </span><span class="s2">item</span><span class="s3">.</span><span class="s2">value</span><span class="s3">, key: </span><span class="s2">i</span><span class="s3">};</span>
    <span class="s3">}</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">createObjectIterator(</span><span class="s2">obj</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">okeys </span><span class="s1">= </span><span class="s2">obj </span><span class="s1">? </span><span class="s2">Object</span><span class="s3">.</span><span class="s4">keys</span><span class="s3">(</span><span class="s2">obj</span><span class="s3">) </span><span class="s1">: </span><span class="s3">[];</span>
    <span class="s1">var </span><span class="s3">i </span><span class="s1">= -</span><span class="s6">1</span><span class="s3">;</span>
    <span class="s1">var </span><span class="s3">len </span><span class="s1">= </span><span class="s2">okeys</span><span class="s3">.length;</span>
    <span class="s1">return function </span><span class="s3">next() {</span>
        <span class="s1">var </span><span class="s3">key </span><span class="s1">= </span><span class="s2">okeys</span><span class="s3">[</span><span class="s1">++</span><span class="s2">i</span><span class="s3">];</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">key </span><span class="s1">=== </span><span class="s5">'__proto__'</span><span class="s3">) {</span>
            <span class="s1">return </span><span class="s4">next</span><span class="s3">();</span>
        <span class="s3">}</span>
        <span class="s1">return </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">len </span><span class="s1">? </span><span class="s3">{value: </span><span class="s2">obj</span><span class="s3">[</span><span class="s2">key</span><span class="s3">], </span><span class="s2">key</span><span class="s3">} </span><span class="s1">: </span><span class="s7">null</span><span class="s3">;</span>
    <span class="s3">};</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">createIterator(</span><span class="s2">coll</span><span class="s3">) {</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s4">isArrayLike</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">)) {</span>
        <span class="s1">return </span><span class="s4">createArrayIterator</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s1">var </span><span class="s3">iterator </span><span class="s1">= </span><span class="s4">getIterator</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">);</span>
    <span class="s1">return </span><span class="s2">iterator </span><span class="s1">? </span><span class="s4">createES2015Iterator</span><span class="s3">(</span><span class="s2">iterator</span><span class="s3">) </span><span class="s1">: </span><span class="s4">createObjectIterator</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">onlyOnce(</span><span class="s2">fn</span><span class="s3">) {</span>
    <span class="s1">return function </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">fn </span><span class="s1">=== </span><span class="s7">null</span><span class="s3">) </span><span class="s1">throw new </span><span class="s4">Error</span><span class="s3">(</span><span class="s5">&quot;Callback was already called.&quot;</span><span class="s3">);</span>
        <span class="s1">var </span><span class="s3">callFn </span><span class="s1">= </span><span class="s2">fn</span><span class="s3">;</span>
        <span class="s2">fn </span><span class="s1">= </span><span class="s7">null</span><span class="s3">;</span>
        <span class="s2">callFn</span><span class="s3">.</span><span class="s4">apply</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s2">args</span><span class="s3">);</span>
    <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// for async generators</span>
<span class="s1">function </span><span class="s3">asyncEachOfLimit(</span><span class="s2">generator</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">let </span><span class="s3">done </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
    <span class="s1">let </span><span class="s3">canceled </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
    <span class="s1">let </span><span class="s3">awaiting </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
    <span class="s1">let </span><span class="s3">running </span><span class="s1">= </span><span class="s6">0</span><span class="s3">;</span>
    <span class="s1">let </span><span class="s3">idx </span><span class="s1">= </span><span class="s6">0</span><span class="s3">;</span>

    <span class="s1">function </span><span class="s3">replenish() {</span>
        <span class="s0">//console.log('replenish')</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">running </span><span class="s1">&gt;= </span><span class="s2">limit </span><span class="s1">|| </span><span class="s2">awaiting </span><span class="s1">|| </span><span class="s2">done</span><span class="s3">) </span><span class="s1">return</span>
        <span class="s0">//console.log('replenish awaiting')</span>
        <span class="s2">awaiting </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
        <span class="s2">generator</span><span class="s3">.</span><span class="s4">next</span><span class="s3">().</span><span class="s4">then</span><span class="s3">(({</span><span class="s2">value</span><span class="s3">, </span><span class="s2">done</span><span class="s3">: </span><span class="s2">iterDone</span><span class="s3">}) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s0">//console.log('got value', value)</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">canceled </span><span class="s1">|| </span><span class="s2">done</span><span class="s3">) </span><span class="s1">return</span>
            <span class="s2">awaiting </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">iterDone</span><span class="s3">) {</span>
                <span class="s2">done </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
                <span class="s1">if </span><span class="s3">(</span><span class="s2">running </span><span class="s1">&lt;= </span><span class="s6">0</span><span class="s3">) {</span>
                    <span class="s0">//console.log('done nextCb')</span>
                    <span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">);</span>
                <span class="s3">}</span>
                <span class="s1">return</span><span class="s3">;</span>
            <span class="s3">}</span>
            <span class="s2">running</span><span class="s1">++</span><span class="s3">;</span>
            <span class="s4">iteratee</span><span class="s3">(</span><span class="s2">value</span><span class="s3">, </span><span class="s2">idx</span><span class="s3">, </span><span class="s2">iterateeCallback</span><span class="s3">);</span>
            <span class="s2">idx</span><span class="s1">++</span><span class="s3">;</span>
            <span class="s4">replenish</span><span class="s3">();</span>
        <span class="s3">}).</span><span class="s4">catch</span><span class="s3">(</span><span class="s2">handleError</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s1">function </span><span class="s3">iterateeCallback(</span><span class="s2">err</span><span class="s3">, </span><span class="s2">result</span><span class="s3">) {</span>
        <span class="s0">//console.log('iterateeCallback')</span>
        <span class="s2">running </span><span class="s1">-= </span><span class="s6">1</span><span class="s3">;</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">canceled</span><span class="s3">) </span><span class="s1">return</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">handleError</span><span class="s3">(</span><span class="s2">err</span><span class="s3">)</span>

        <span class="s1">if </span><span class="s3">(</span><span class="s2">err </span><span class="s1">=== </span><span class="s7">false</span><span class="s3">) {</span>
            <span class="s2">done </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
            <span class="s2">canceled </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
            <span class="s1">return</span>
        <span class="s3">}</span>

        <span class="s1">if </span><span class="s3">(</span><span class="s2">result </span><span class="s1">=== </span><span class="s2">breakLoop </span><span class="s1">|| </span><span class="s3">(</span><span class="s2">done </span><span class="s1">&amp;&amp; </span><span class="s2">running </span><span class="s1">&lt;= </span><span class="s6">0</span><span class="s3">)) {</span>
            <span class="s2">done </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
            <span class="s0">//console.log('done iterCb')</span>
            <span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">);</span>
        <span class="s3">}</span>
        <span class="s4">replenish</span><span class="s3">();</span>
    <span class="s3">}</span>

    <span class="s1">function </span><span class="s3">handleError(</span><span class="s2">err</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">canceled</span><span class="s3">) </span><span class="s1">return</span>
        <span class="s2">awaiting </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
        <span class="s2">done </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
        <span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s4">replenish</span><span class="s3">();</span>
<span class="s3">}</span>

<span class="s1">var </span><span class="s3">eachOfLimit </span><span class="s1">= </span><span class="s3">(</span><span class="s2">limit</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
    <span class="s1">return </span><span class="s3">(</span><span class="s2">obj</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s2">callback </span><span class="s1">= </span><span class="s4">once</span><span class="s3">(</span><span class="s2">callback</span><span class="s3">);</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">limit </span><span class="s1">&lt;= </span><span class="s6">0</span><span class="s3">) {</span>
            <span class="s1">throw new </span><span class="s4">RangeError</span><span class="s3">(</span><span class="s5">'concurrency limit cannot be less than 1'</span><span class="s3">)</span>
        <span class="s3">}</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">obj</span><span class="s3">) {</span>
            <span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">);</span>
        <span class="s3">}</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s4">isAsyncGenerator</span><span class="s3">(</span><span class="s2">obj</span><span class="s3">)) {</span>
            <span class="s1">return </span><span class="s4">asyncEachOfLimit</span><span class="s3">(</span><span class="s2">obj</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
        <span class="s3">}</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s4">isAsyncIterable</span><span class="s3">(</span><span class="s2">obj</span><span class="s3">)) {</span>
            <span class="s1">return </span><span class="s4">asyncEachOfLimit</span><span class="s3">(</span><span class="s2">obj</span><span class="s3">[</span><span class="s2">Symbol</span><span class="s3">.</span><span class="s2">asyncIterator</span><span class="s3">](), </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
        <span class="s3">}</span>
        <span class="s1">var </span><span class="s3">nextElem </span><span class="s1">= </span><span class="s4">createIterator</span><span class="s3">(</span><span class="s2">obj</span><span class="s3">);</span>
        <span class="s1">var </span><span class="s3">done </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
        <span class="s1">var </span><span class="s3">canceled </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
        <span class="s1">var </span><span class="s3">running </span><span class="s1">= </span><span class="s6">0</span><span class="s3">;</span>
        <span class="s1">var </span><span class="s3">looping </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>

        <span class="s1">function </span><span class="s3">iterateeCallback(</span><span class="s2">err</span><span class="s3">, </span><span class="s2">value</span><span class="s3">) {</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">canceled</span><span class="s3">) </span><span class="s1">return</span>
            <span class="s2">running </span><span class="s1">-= </span><span class="s6">1</span><span class="s3">;</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) {</span>
                <span class="s2">done </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
                <span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
            <span class="s3">}</span>
            <span class="s1">else if </span><span class="s3">(</span><span class="s2">err </span><span class="s1">=== </span><span class="s7">false</span><span class="s3">) {</span>
                <span class="s2">done </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
                <span class="s2">canceled </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
            <span class="s3">}</span>
            <span class="s1">else if </span><span class="s3">(</span><span class="s2">value </span><span class="s1">=== </span><span class="s2">breakLoop </span><span class="s1">|| </span><span class="s3">(</span><span class="s2">done </span><span class="s1">&amp;&amp; </span><span class="s2">running </span><span class="s1">&lt;= </span><span class="s6">0</span><span class="s3">)) {</span>
                <span class="s2">done </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
                <span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">);</span>
            <span class="s3">}</span>
            <span class="s1">else if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">looping</span><span class="s3">) {</span>
                <span class="s4">replenish</span><span class="s3">();</span>
            <span class="s3">}</span>
        <span class="s3">}</span>

        <span class="s1">function </span><span class="s3">replenish () {</span>
            <span class="s2">looping </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
            <span class="s1">while </span><span class="s3">(</span><span class="s2">running </span><span class="s1">&lt; </span><span class="s2">limit </span><span class="s1">&amp;&amp; !</span><span class="s2">done</span><span class="s3">) {</span>
                <span class="s1">var </span><span class="s3">elem </span><span class="s1">= </span><span class="s4">nextElem</span><span class="s3">();</span>
                <span class="s1">if </span><span class="s3">(</span><span class="s2">elem </span><span class="s1">=== </span><span class="s7">null</span><span class="s3">) {</span>
                    <span class="s2">done </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
                    <span class="s1">if </span><span class="s3">(</span><span class="s2">running </span><span class="s1">&lt;= </span><span class="s6">0</span><span class="s3">) {</span>
                        <span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">);</span>
                    <span class="s3">}</span>
                    <span class="s1">return</span><span class="s3">;</span>
                <span class="s3">}</span>
                <span class="s2">running </span><span class="s1">+= </span><span class="s6">1</span><span class="s3">;</span>
                <span class="s4">iteratee</span><span class="s3">(</span><span class="s2">elem</span><span class="s3">.</span><span class="s2">value</span><span class="s3">, </span><span class="s2">elem</span><span class="s3">.</span><span class="s2">key</span><span class="s3">, </span><span class="s4">onlyOnce</span><span class="s3">(</span><span class="s2">iterateeCallback</span><span class="s3">));</span>
            <span class="s3">}</span>
            <span class="s2">looping </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
        <span class="s3">}</span>

        <span class="s4">replenish</span><span class="s3">();</span>
    <span class="s3">};</span>
<span class="s3">};</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`eachOf`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.eachOf} </span><span class="s0">but runs a maximum of `limit` async operations at a 
 * time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">eachOfLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.eachOf]{</span><span class="s1">@link </span><span class="s2">module:Collections.eachOf}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">forEachOfLimit</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{number} limit </span><span class="s0">- The maximum number of async operations at a time. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async function to apply to each 
 * item in `coll`. The `key` is the item's key, or index in the case of an 
 * array. 
 * Invoked with (item, key, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called when all 
 * `iteratee` functions have finished, or an error occurs. Invoked with (err). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if a callback is omitted 
 */</span>
<span class="s1">function </span><span class="s3">eachOfLimit$1(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">eachOfLimit</span><span class="s3">(</span><span class="s2">limit</span><span class="s3">)(</span><span class="s2">coll</span><span class="s3">, </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">iteratee</span><span class="s3">), </span><span class="s2">callback</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s1">var </span><span class="s3">eachOfLimit$2 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">eachOfLimit$1</span><span class="s3">, </span><span class="s6">4</span><span class="s3">);</span>

<span class="s0">// eachOf implementation optimized for array-likes</span>
<span class="s1">function </span><span class="s3">eachOfArrayLike(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s2">callback </span><span class="s1">= </span><span class="s4">once</span><span class="s3">(</span><span class="s2">callback</span><span class="s3">);</span>
    <span class="s1">var </span><span class="s3">index </span><span class="s1">= </span><span class="s6">0</span><span class="s3">,</span>
        <span class="s3">completed </span><span class="s1">= </span><span class="s6">0</span><span class="s3">,</span>
        <span class="s3">{length} </span><span class="s1">= </span><span class="s2">coll</span><span class="s3">,</span>
        <span class="s3">canceled </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s2">length </span><span class="s1">=== </span><span class="s6">0</span><span class="s3">) {</span>
        <span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s1">function </span><span class="s3">iteratorCallback(</span><span class="s2">err</span><span class="s3">, </span><span class="s2">value</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err </span><span class="s1">=== </span><span class="s7">false</span><span class="s3">) {</span>
            <span class="s2">canceled </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
        <span class="s3">}</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">canceled </span><span class="s1">=== </span><span class="s7">true</span><span class="s3">) </span><span class="s1">return</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) {</span>
            <span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
        <span class="s3">} </span><span class="s1">else if </span><span class="s3">((</span><span class="s1">++</span><span class="s2">completed </span><span class="s1">=== </span><span class="s2">length</span><span class="s3">) </span><span class="s1">|| </span><span class="s2">value </span><span class="s1">=== </span><span class="s2">breakLoop</span><span class="s3">) {</span>
            <span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">);</span>
        <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s1">for </span><span class="s3">(; </span><span class="s2">index </span><span class="s1">&lt; </span><span class="s2">length</span><span class="s3">; </span><span class="s2">index</span><span class="s1">++</span><span class="s3">) {</span>
        <span class="s4">iteratee</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">[</span><span class="s2">index</span><span class="s3">], </span><span class="s2">index</span><span class="s3">, </span><span class="s4">onlyOnce</span><span class="s3">(</span><span class="s2">iteratorCallback</span><span class="s3">));</span>
    <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">// a generic version of eachOf which can handle array, object, and iterator cases.</span>
<span class="s1">function </span><span class="s3">eachOfGeneric (</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">eachOfLimit$2</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">, </span><span class="s7">Infinity</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Like </span><span class="s7">[`each`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.each}</span><span class="s0">, except that it passes the key (or index) as the second argument 
 * to the iteratee. 
 * 
 * </span><span class="s1">@name </span><span class="s2">eachOf</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">forEachOf</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@see </span><span class="s2">[async.each]{</span><span class="s1">@link </span><span class="s2">module:Collections.each}</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- A function to apply to each 
 * item in `coll`. 
 * The `key` is the item's key, or index in the case of an array. 
 * Invoked with (item, key, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called when all 
 * `iteratee` functions have finished, or an error occurs. Invoked with (err). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if a callback is omitted 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // dev.json is a file containing a valid json object config for dev environment 
 * // dev.json is a file containing a valid json object config for test environment 
 * // prod.json is a file containing a valid json object config for prod environment 
 * // invalid.json is a file with a malformed json object 
 * 
 * let configs = {}; //global variable 
 * let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'}; 
 * let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'}; 
 * 
 * // asynchronous function that reads a json file and parses the contents as json object 
 * function parseFile(file, key, callback) { 
 *     fs.readFile(file, &quot;utf8&quot;, function(err, data) { 
 *         if (err) return calback(err); 
 *         try { 
 *             configs[key] = JSON.parse(data); 
 *         } catch (e) { 
 *             return callback(e); 
 *         } 
 *         callback(); 
 *     }); 
 * } 
 * 
 * // Using callbacks 
 * async.forEachOf(validConfigFileMap, parseFile, function (err) { 
 *     if (err) { 
 *         console.error(err); 
 *     } else { 
 *         console.log(configs); 
 *         // configs is now a map of JSON data, e.g. 
 *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json} 
 *     } 
 * }); 
 * 
 * //Error handing 
 * async.forEachOf(invalidConfigFileMap, parseFile, function (err) { 
 *     if (err) { 
 *         console.error(err); 
 *         // JSON parse error exception 
 *     } else { 
 *         console.log(configs); 
 *     } 
 * }); 
 * 
 * // Using Promises 
 * async.forEachOf(validConfigFileMap, parseFile) 
 * .then( () =&gt; { 
 *     console.log(configs); 
 *     // configs is now a map of JSON data, e.g. 
 *     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json} 
 * }).catch( err =&gt; { 
 *     console.error(err); 
 * }); 
 * 
 * //Error handing 
 * async.forEachOf(invalidConfigFileMap, parseFile) 
 * .then( () =&gt; { 
 *     console.log(configs); 
 * }).catch( err =&gt; { 
 *     console.error(err); 
 *     // JSON parse error exception 
 * }); 
 * 
 * // Using async/await 
 * async () =&gt; { 
 *     try { 
 *         let result = await async.forEachOf(validConfigFileMap, parseFile); 
 *         console.log(configs); 
 *         // configs is now a map of JSON data, e.g. 
 *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json} 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 * //Error handing 
 * async () =&gt; { 
 *     try { 
 *         let result = await async.forEachOf(invalidConfigFileMap, parseFile); 
 *         console.log(configs); 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *         // JSON parse error exception 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">eachOf(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">eachOfImplementation </span><span class="s1">= </span><span class="s4">isArrayLike</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">) </span><span class="s1">? </span><span class="s2">eachOfArrayLike </span><span class="s1">: </span><span class="s2">eachOfGeneric</span><span class="s3">;</span>
    <span class="s1">return </span><span class="s4">eachOfImplementation</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">, </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">iteratee</span><span class="s3">), </span><span class="s2">callback</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s1">var </span><span class="s3">eachOf$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">eachOf</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* Produces a new collection of values by mapping each value in `coll` through 
 * the `iteratee` function. The `iteratee` is called with an item from `coll` 
 * and a callback for when it has finished processing. Each of these callbacks 
 * takes 2 arguments: an `error`, and the transformed item from `coll`. If 
 * `iteratee` passes an error to its callback, the main `callback` (for the 
 * `map` function) is immediately called with the error. 
 * 
 * Note, that since this function applies the `iteratee` to each item in 
 * parallel, there is no guarantee that the `iteratee` functions will complete 
 * in order. However, the results array will be in the same order as the 
 * original `coll`. 
 * 
 * If `map` is passed an Object, the results will be an Array.  The results 
 * will roughly be in the order of the original Objects' keys (but this can 
 * vary across JavaScript engines). 
 * 
 * </span><span class="s1">@name </span><span class="s2">map</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async function to apply to each item in 
 * `coll`. 
 * The iteratee should complete with the transformed item. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called when all `iteratee` 
 * functions have finished, or an error occurs. Results is an Array of the 
 * transformed items from the `coll`. Invoked with (err, results). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // file1.txt is a file that is 1000 bytes in size 
 * // file2.txt is a file that is 2000 bytes in size 
 * // file3.txt is a file that is 3000 bytes in size 
 * // file4.txt does not exist 
 * 
 * const fileList = ['file1.txt','file2.txt','file3.txt']; 
 * const withMissingFileList = ['file1.txt','file2.txt','file4.txt']; 
 * 
 * // asynchronous function that returns the file size in bytes 
 * function getFileSizeInBytes(file, callback) { 
 *     fs.stat(file, function(err, stat) { 
 *         if (err) { 
 *             return callback(err); 
 *         } 
 *         callback(null, stat.size); 
 *     }); 
 * } 
 * 
 * // Using callbacks 
 * async.map(fileList, getFileSizeInBytes, function(err, results) { 
 *     if (err) { 
 *         console.log(err); 
 *     } else { 
 *         console.log(results); 
 *         // results is now an array of the file size in bytes for each file, e.g. 
 *         // [ 1000, 2000, 3000] 
 *     } 
 * }); 
 * 
 * // Error Handling 
 * async.map(withMissingFileList, getFileSizeInBytes, function(err, results) { 
 *     if (err) { 
 *         console.log(err); 
 *         // [ Error: ENOENT: no such file or directory ] 
 *     } else { 
 *         console.log(results); 
 *     } 
 * }); 
 * 
 * // Using Promises 
 * async.map(fileList, getFileSizeInBytes) 
 * .then( results =&gt; { 
 *     console.log(results); 
 *     // results is now an array of the file size in bytes for each file, e.g. 
 *     // [ 1000, 2000, 3000] 
 * }).catch( err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * // Error Handling 
 * async.map(withMissingFileList, getFileSizeInBytes) 
 * .then( results =&gt; { 
 *     console.log(results); 
 * }).catch( err =&gt; { 
 *     console.log(err); 
 *     // [ Error: ENOENT: no such file or directory ] 
 * }); 
 * 
 * // Using async/await 
 * async () =&gt; { 
 *     try { 
 *         let results = await async.map(fileList, getFileSizeInBytes); 
 *         console.log(results); 
 *         // results is now an array of the file size in bytes for each file, e.g. 
 *         // [ 1000, 2000, 3000] 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 * // Error Handling 
 * async () =&gt; { 
 *     try { 
 *         let results = await async.map(withMissingFileList, getFileSizeInBytes); 
 *         console.log(results); 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *         // [ Error: ENOENT: no such file or directory ] 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">map (</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">_asyncMap</span><span class="s3">(</span><span class="s2">eachOf$1</span><span class="s3">, </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">map$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">map</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* Applies the provided arguments to each function in the array, calling 
 * `callback` after all functions have completed. If you only provide the first 
 * argument, `fns`, then it will return a function which lets you pass in the 
 * arguments as if it were a single function call. If more arguments are 
 * provided, `callback` is required while `args` is still optional. The results 
 * for each of the applied async functions are passed to the final callback 
 * as an array. 
 * 
 * </span><span class="s1">@name </span><span class="s2">applyEach</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} fns </span><span class="s0">- A collection of </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">AsyncFunction}</span><span class="s0">s 
 * to all call with the same arguments 
 * </span><span class="s1">@param </span><span class="s2">{...*} [args] </span><span class="s0">- any number of separate arguments to pass to the 
 * function. 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- the final argument should be the callback, 
 * called when all functions have completed processing. 
 * </span><span class="s1">@returns </span><span class="s2">{AsyncFunction} </span><span class="s0">- Returns a function that takes no args other than 
 * an optional callback, that is the result of applying the `args` to each 
 * of the functions. 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * const appliedFn = async.applyEach([enableSearch, updateSchema], 'bucket') 
 * 
 * appliedFn((err, results) =&gt; { 
 *     // results[0] is the results for `enableSearch` 
 *     // results[1] is the results for `updateSchema` 
 * }); 
 * 
 * // partial application example: 
 * async.each( 
 *     buckets, 
 *     async (bucket) =&gt; async.applyEach([enableSearch, updateSchema], bucket)(), 
 *     callback 
 * ); 
 */</span>
<span class="s1">var </span><span class="s3">applyEach$1 </span><span class="s1">= </span><span class="s4">applyEach</span><span class="s3">(</span><span class="s2">map$1</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`eachOf`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.eachOf} </span><span class="s0">but runs only a single async operation at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">eachOfSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.eachOf]{</span><span class="s1">@link </span><span class="s2">module:Collections.eachOf}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">forEachOfSeries</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async function to apply to each item in 
 * `coll`. 
 * Invoked with (item, key, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called when all `iteratee` 
 * functions have finished, or an error occurs. Invoked with (err). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if a callback is omitted 
 */</span>
<span class="s1">function </span><span class="s3">eachOfSeries(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">eachOfLimit$2</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">eachOfSeries$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">eachOfSeries</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`map`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.map} </span><span class="s0">but runs only a single async operation at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">mapSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.map]{</span><span class="s1">@link </span><span class="s2">module:Collections.map}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async function to apply to each item in 
 * `coll`. 
 * The iteratee should complete with the transformed item. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called when all `iteratee` 
 * functions have finished, or an error occurs. Results is an array of the 
 * transformed items from the `coll`. Invoked with (err, results). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 */</span>
<span class="s1">function </span><span class="s3">mapSeries (</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">_asyncMap</span><span class="s3">(</span><span class="s2">eachOfSeries$1</span><span class="s3">, </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">mapSeries$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">mapSeries</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`applyEach`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.applyEach} </span><span class="s0">but runs only a single async operation at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">applyEachSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.applyEach]{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.applyEach}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} fns </span><span class="s0">- A collection of </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">AsyncFunction}</span><span class="s0">s to all 
 * call with the same arguments 
 * </span><span class="s1">@param </span><span class="s2">{...*} [args] </span><span class="s0">- any number of separate arguments to pass to the 
 * function. 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- the final argument should be the callback, 
 * called when all functions have completed processing. 
 * </span><span class="s1">@returns </span><span class="s2">{AsyncFunction} </span><span class="s0">- A function, that when called, is the result of 
 * appling the `args` to the list of functions.  It takes no args, other than 
 * a callback. 
 */</span>
<span class="s1">var </span><span class="s3">applyEachSeries </span><span class="s1">= </span><span class="s4">applyEach</span><span class="s3">(</span><span class="s2">mapSeries$1</span><span class="s3">);</span>

<span class="s1">const </span><span class="s3">PROMISE_SYMBOL </span><span class="s1">= </span><span class="s4">Symbol</span><span class="s3">(</span><span class="s5">'promiseCallback'</span><span class="s3">);</span>

<span class="s1">function </span><span class="s3">promiseCallback () {</span>
    <span class="s1">let </span><span class="s3">resolve, reject;</span>
    <span class="s1">function </span><span class="s3">callback (</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">reject</span><span class="s3">(</span><span class="s2">err</span><span class="s3">)</span>
        <span class="s4">resolve</span><span class="s3">(</span><span class="s2">args</span><span class="s3">.length </span><span class="s1">&gt; </span><span class="s6">1 </span><span class="s1">? </span><span class="s2">args </span><span class="s1">: </span><span class="s2">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]);</span>
    <span class="s3">}</span>

    <span class="s2">callback</span><span class="s3">[</span><span class="s2">PROMISE_SYMBOL</span><span class="s3">] </span><span class="s1">= new </span><span class="s3">Promise((</span><span class="s2">res</span><span class="s3">, </span><span class="s2">rej</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s2">resolve </span><span class="s1">= </span><span class="s2">res</span><span class="s3">,</span>
        <span class="s2">reject </span><span class="s1">= </span><span class="s2">rej</span><span class="s3">;</span>
    <span class="s3">});</span>

    <span class="s1">return </span><span class="s2">callback</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Determines the best order for running the </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">AsyncFunction}</span><span class="s0">s in `tasks`, based on 
 * their requirements. Each function can optionally depend on other functions 
 * being completed first, and each function is run as soon as its requirements 
 * are satisfied. 
 * 
 * If any of the </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">AsyncFunction}</span><span class="s0">s pass an error to their callback, the `auto` sequence 
 * will stop. Further tasks will not execute (so any other functions depending 
 * on it will not run), and the main `callback` is immediately called with the 
 * error. 
 * 
 * </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">AsyncFunction}</span><span class="s0">s also receive an object containing the results of functions which 
 * have completed so far as the first argument, if they have dependencies. If a 
 * task function has no dependencies, it will only be passed a callback. 
 * 
 * </span><span class="s1">@name </span><span class="s2">auto</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{Object} tasks </span><span class="s0">- An object. Each of its properties is either a 
 * function or an array of requirements, with the </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">AsyncFunction} </span><span class="s0">itself the last item 
 * in the array. The object's key of a property serves as the name of the task 
 * defined by that property, i.e. can be used when specifying requirements for 
 * other tasks. The function receives one or two arguments: 
 * * a `results` object, containing the results of the previously executed 
 *   functions, only passed if the task has any dependencies, 
 * * a `callback(err, result)` function, which must be called when finished, 
 *   passing an `error` (which can be `null`) and the result of the function's 
 *   execution. 
 * </span><span class="s1">@param </span><span class="s2">{number} [concurrency</span><span class="s1">=</span><span class="s2">Infinity] </span><span class="s0">- An optional `integer` for 
 * determining the maximum number of tasks that can be run in parallel. By 
 * default, as many as possible. 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- An optional callback which is called when all 
 * the tasks have been completed. It receives the `err` argument if any `tasks` 
 * pass an error to their callback. Results are always returned; however, if an 
 * error occurs, no further `tasks` will be performed, and the results object 
 * will only contain partial results. Invoked with (err, results). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if a callback is not passed 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * //Using Callbacks 
 * async.auto({ 
 *     get_data: function(callback) { 
 *         // async code to get some data 
 *         callback(null, 'data', 'converted to array'); 
 *     }, 
 *     make_folder: function(callback) { 
 *         // async code to create a directory to store a file in 
 *         // this is run at the same time as getting the data 
 *         callback(null, 'folder'); 
 *     }, 
 *     write_file: ['get_data', 'make_folder', function(results, callback) { 
 *         // once there is some data and the directory exists, 
 *         // write the data to a file in the directory 
 *         callback(null, 'filename'); 
 *     }], 
 *     email_link: ['write_file', function(results, callback) { 
 *         // once the file is written let's email a link to it... 
 *         callback(null, {'file':results.write_file, 'email':'user@example.com'}); 
 *     }] 
 * }, function(err, results) { 
 *     if (err) { 
 *         console.log('err = ', err); 
 *     } 
 *     console.log('results = ', results); 
 *     // results = { 
 *     //     get_data: ['data', 'converted to array'] 
 *     //     make_folder; 'folder', 
 *     //     write_file: 'filename' 
 *     //     email_link: { file: 'filename', email: 'user@example.com' } 
 *     // } 
 * }); 
 * 
 * //Using Promises 
 * async.auto({ 
 *     get_data: function(callback) { 
 *         console.log('in get_data'); 
 *         // async code to get some data 
 *         callback(null, 'data', 'converted to array'); 
 *     }, 
 *     make_folder: function(callback) { 
 *         console.log('in make_folder'); 
 *         // async code to create a directory to store a file in 
 *         // this is run at the same time as getting the data 
 *         callback(null, 'folder'); 
 *     }, 
 *     write_file: ['get_data', 'make_folder', function(results, callback) { 
 *         // once there is some data and the directory exists, 
 *         // write the data to a file in the directory 
 *         callback(null, 'filename'); 
 *     }], 
 *     email_link: ['write_file', function(results, callback) { 
 *         // once the file is written let's email a link to it... 
 *         callback(null, {'file':results.write_file, 'email':'user@example.com'}); 
 *     }] 
 * }).then(results =&gt; { 
 *     console.log('results = ', results); 
 *     // results = { 
 *     //     get_data: ['data', 'converted to array'] 
 *     //     make_folder; 'folder', 
 *     //     write_file: 'filename' 
 *     //     email_link: { file: 'filename', email: 'user@example.com' } 
 *     // } 
 * }).catch(err =&gt; { 
 *     console.log('err = ', err); 
 * }); 
 * 
 * //Using async/await 
 * async () =&gt; { 
 *     try { 
 *         let results = await async.auto({ 
 *             get_data: function(callback) { 
 *                 // async code to get some data 
 *                 callback(null, 'data', 'converted to array'); 
 *             }, 
 *             make_folder: function(callback) { 
 *                 // async code to create a directory to store a file in 
 *                 // this is run at the same time as getting the data 
 *                 callback(null, 'folder'); 
 *             }, 
 *             write_file: ['get_data', 'make_folder', function(results, callback) { 
 *                 // once there is some data and the directory exists, 
 *                 // write the data to a file in the directory 
 *                 callback(null, 'filename'); 
 *             }], 
 *             email_link: ['write_file', function(results, callback) { 
 *                 // once the file is written let's email a link to it... 
 *                 callback(null, {'file':results.write_file, 'email':'user@example.com'}); 
 *             }] 
 *         }); 
 *         console.log('results = ', results); 
 *         // results = { 
 *         //     get_data: ['data', 'converted to array'] 
 *         //     make_folder; 'folder', 
 *         //     write_file: 'filename' 
 *         //     email_link: { file: 'filename', email: 'user@example.com' } 
 *         // } 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">auto(</span><span class="s2">tasks</span><span class="s3">, </span><span class="s2">concurrency</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s1">typeof </span><span class="s2">concurrency </span><span class="s1">!== </span><span class="s5">'number'</span><span class="s3">) {</span>
        <span class="s0">// concurrency is optional, shift the args.</span>
        <span class="s2">callback </span><span class="s1">= </span><span class="s2">concurrency</span><span class="s3">;</span>
        <span class="s2">concurrency </span><span class="s1">= </span><span class="s7">null</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">callback </span><span class="s1">= </span><span class="s4">once</span><span class="s3">(</span><span class="s2">callback </span><span class="s1">|| </span><span class="s4">promiseCallback</span><span class="s3">());</span>
    <span class="s1">var </span><span class="s3">numTasks </span><span class="s1">= </span><span class="s2">Object</span><span class="s3">.</span><span class="s4">keys</span><span class="s3">(</span><span class="s2">tasks</span><span class="s3">).length;</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">numTasks</span><span class="s3">) {</span>
        <span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">concurrency</span><span class="s3">) {</span>
        <span class="s2">concurrency </span><span class="s1">= </span><span class="s2">numTasks</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s1">var </span><span class="s3">results </span><span class="s1">= </span><span class="s3">{};</span>
    <span class="s1">var </span><span class="s3">runningTasks </span><span class="s1">= </span><span class="s6">0</span><span class="s3">;</span>
    <span class="s1">var </span><span class="s3">canceled </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
    <span class="s1">var </span><span class="s3">hasError </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>

    <span class="s1">var </span><span class="s3">listeners </span><span class="s1">= </span><span class="s2">Object</span><span class="s3">.</span><span class="s4">create</span><span class="s3">(</span><span class="s7">null</span><span class="s3">);</span>

    <span class="s1">var </span><span class="s3">readyTasks </span><span class="s1">= </span><span class="s3">[];</span>

    <span class="s0">// for cycle detection:</span>
    <span class="s1">var </span><span class="s3">readyToCheck </span><span class="s1">= </span><span class="s3">[]; </span><span class="s0">// tasks that have been identified as reachable</span>
    <span class="s0">// without the possibility of returning to an ancestor task</span>
    <span class="s1">var </span><span class="s3">uncheckedDependencies </span><span class="s1">= </span><span class="s3">{};</span>

    <span class="s2">Object</span><span class="s3">.</span><span class="s4">keys</span><span class="s3">(</span><span class="s2">tasks</span><span class="s3">).</span><span class="s4">forEach</span><span class="s3">(</span><span class="s2">key </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s1">var </span><span class="s3">task </span><span class="s1">= </span><span class="s2">tasks</span><span class="s3">[</span><span class="s2">key</span><span class="s3">];</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">Array</span><span class="s3">.</span><span class="s4">isArray</span><span class="s3">(</span><span class="s2">task</span><span class="s3">)) {</span>
            <span class="s0">// no dependencies</span>
            <span class="s4">enqueueTask</span><span class="s3">(</span><span class="s2">key</span><span class="s3">, [</span><span class="s2">task</span><span class="s3">]);</span>
            <span class="s2">readyToCheck</span><span class="s3">.</span><span class="s4">push</span><span class="s3">(</span><span class="s2">key</span><span class="s3">);</span>
            <span class="s1">return</span><span class="s3">;</span>
        <span class="s3">}</span>

        <span class="s1">var </span><span class="s3">dependencies </span><span class="s1">= </span><span class="s2">task</span><span class="s3">.</span><span class="s4">slice</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s2">task</span><span class="s3">.length </span><span class="s1">- </span><span class="s6">1</span><span class="s3">);</span>
        <span class="s1">var </span><span class="s3">remainingDependencies </span><span class="s1">= </span><span class="s2">dependencies</span><span class="s3">.length;</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">remainingDependencies </span><span class="s1">=== </span><span class="s6">0</span><span class="s3">) {</span>
            <span class="s4">enqueueTask</span><span class="s3">(</span><span class="s2">key</span><span class="s3">, </span><span class="s2">task</span><span class="s3">);</span>
            <span class="s2">readyToCheck</span><span class="s3">.</span><span class="s4">push</span><span class="s3">(</span><span class="s2">key</span><span class="s3">);</span>
            <span class="s1">return</span><span class="s3">;</span>
        <span class="s3">}</span>
        <span class="s2">uncheckedDependencies</span><span class="s3">[</span><span class="s2">key</span><span class="s3">] </span><span class="s1">= </span><span class="s2">remainingDependencies</span><span class="s3">;</span>

        <span class="s2">dependencies</span><span class="s3">.</span><span class="s4">forEach</span><span class="s3">(</span><span class="s2">dependencyName </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">tasks</span><span class="s3">[</span><span class="s2">dependencyName</span><span class="s3">]) {</span>
                <span class="s1">throw new </span><span class="s4">Error</span><span class="s3">(</span><span class="s5">'async.auto task `' </span><span class="s1">+ </span><span class="s2">key </span><span class="s1">+</span>
                    <span class="s5">'` has a non-existent dependency `' </span><span class="s1">+</span>
                    <span class="s2">dependencyName </span><span class="s1">+ </span><span class="s5">'` in ' </span><span class="s1">+</span>
                    <span class="s2">dependencies</span><span class="s3">.</span><span class="s4">join</span><span class="s3">(</span><span class="s5">', '</span><span class="s3">));</span>
            <span class="s3">}</span>
            <span class="s4">addListener</span><span class="s3">(</span><span class="s2">dependencyName</span><span class="s3">, () </span><span class="s1">=&gt; </span><span class="s3">{</span>
                <span class="s2">remainingDependencies</span><span class="s1">--</span><span class="s3">;</span>
                <span class="s1">if </span><span class="s3">(</span><span class="s2">remainingDependencies </span><span class="s1">=== </span><span class="s6">0</span><span class="s3">) {</span>
                    <span class="s4">enqueueTask</span><span class="s3">(</span><span class="s2">key</span><span class="s3">, </span><span class="s2">task</span><span class="s3">);</span>
                <span class="s3">}</span>
            <span class="s3">});</span>
        <span class="s3">});</span>
    <span class="s3">});</span>

    <span class="s4">checkForDeadlocks</span><span class="s3">();</span>
    <span class="s4">processQueue</span><span class="s3">();</span>

    <span class="s1">function </span><span class="s3">enqueueTask(</span><span class="s2">key</span><span class="s3">, </span><span class="s2">task</span><span class="s3">) {</span>
        <span class="s2">readyTasks</span><span class="s3">.</span><span class="s4">push</span><span class="s3">(() </span><span class="s1">=&gt; </span><span class="s4">runTask</span><span class="s3">(</span><span class="s2">key</span><span class="s3">, </span><span class="s2">task</span><span class="s3">));</span>
    <span class="s3">}</span>

    <span class="s1">function </span><span class="s3">processQueue() {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">canceled</span><span class="s3">) </span><span class="s1">return</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">readyTasks</span><span class="s3">.length </span><span class="s1">=== </span><span class="s6">0 </span><span class="s1">&amp;&amp; </span><span class="s2">runningTasks </span><span class="s1">=== </span><span class="s6">0</span><span class="s3">) {</span>
            <span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">, </span><span class="s2">results</span><span class="s3">);</span>
        <span class="s3">}</span>
        <span class="s1">while</span><span class="s3">(</span><span class="s2">readyTasks</span><span class="s3">.length </span><span class="s1">&amp;&amp; </span><span class="s2">runningTasks </span><span class="s1">&lt; </span><span class="s2">concurrency</span><span class="s3">) {</span>
            <span class="s1">var </span><span class="s3">run </span><span class="s1">= </span><span class="s2">readyTasks</span><span class="s3">.</span><span class="s4">shift</span><span class="s3">();</span>
            <span class="s4">run</span><span class="s3">();</span>
        <span class="s3">}</span>

    <span class="s3">}</span>

    <span class="s1">function </span><span class="s3">addListener(</span><span class="s2">taskName</span><span class="s3">, </span><span class="s2">fn</span><span class="s3">) {</span>
        <span class="s1">var </span><span class="s3">taskListeners </span><span class="s1">= </span><span class="s2">listeners</span><span class="s3">[</span><span class="s2">taskName</span><span class="s3">];</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">taskListeners</span><span class="s3">) {</span>
            <span class="s2">taskListeners </span><span class="s1">= </span><span class="s2">listeners</span><span class="s3">[</span><span class="s2">taskName</span><span class="s3">] </span><span class="s1">= </span><span class="s3">[];</span>
        <span class="s3">}</span>

        <span class="s2">taskListeners</span><span class="s3">.</span><span class="s4">push</span><span class="s3">(</span><span class="s2">fn</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s1">function </span><span class="s3">taskComplete(</span><span class="s2">taskName</span><span class="s3">) {</span>
        <span class="s1">var </span><span class="s3">taskListeners </span><span class="s1">= </span><span class="s2">listeners</span><span class="s3">[</span><span class="s2">taskName</span><span class="s3">] </span><span class="s1">|| </span><span class="s3">[];</span>
        <span class="s2">taskListeners</span><span class="s3">.</span><span class="s4">forEach</span><span class="s3">(</span><span class="s2">fn </span><span class="s1">=&gt; </span><span class="s4">fn</span><span class="s3">());</span>
        <span class="s4">processQueue</span><span class="s3">();</span>
    <span class="s3">}</span>


    <span class="s1">function </span><span class="s3">runTask(</span><span class="s2">key</span><span class="s3">, </span><span class="s2">task</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">hasError</span><span class="s3">) </span><span class="s1">return</span><span class="s3">;</span>

        <span class="s1">var </span><span class="s3">taskCallback </span><span class="s1">= </span><span class="s4">onlyOnce</span><span class="s3">((</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">result</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s2">runningTasks</span><span class="s1">--</span><span class="s3">;</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">err </span><span class="s1">=== </span><span class="s7">false</span><span class="s3">) {</span>
                <span class="s2">canceled </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
                <span class="s1">return</span>
            <span class="s3">}</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">result</span><span class="s3">.length </span><span class="s1">&lt; </span><span class="s6">2</span><span class="s3">) {</span>
                <span class="s3">[</span><span class="s2">result</span><span class="s3">] </span><span class="s1">= </span><span class="s2">result</span><span class="s3">;</span>
            <span class="s3">}</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) {</span>
                <span class="s1">var </span><span class="s3">safeResults </span><span class="s1">= </span><span class="s3">{};</span>
                <span class="s2">Object</span><span class="s3">.</span><span class="s4">keys</span><span class="s3">(</span><span class="s2">results</span><span class="s3">).</span><span class="s4">forEach</span><span class="s3">(</span><span class="s2">rkey </span><span class="s1">=&gt; </span><span class="s3">{</span>
                    <span class="s2">safeResults</span><span class="s3">[</span><span class="s2">rkey</span><span class="s3">] </span><span class="s1">= </span><span class="s2">results</span><span class="s3">[</span><span class="s2">rkey</span><span class="s3">];</span>
                <span class="s3">});</span>
                <span class="s2">safeResults</span><span class="s3">[</span><span class="s2">key</span><span class="s3">] </span><span class="s1">= </span><span class="s2">result</span><span class="s3">;</span>
                <span class="s2">hasError </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
                <span class="s2">listeners </span><span class="s1">= </span><span class="s2">Object</span><span class="s3">.</span><span class="s4">create</span><span class="s3">(</span><span class="s7">null</span><span class="s3">);</span>
                <span class="s1">if </span><span class="s3">(</span><span class="s2">canceled</span><span class="s3">) </span><span class="s1">return</span>
                <span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s2">safeResults</span><span class="s3">);</span>
            <span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
                <span class="s2">results</span><span class="s3">[</span><span class="s2">key</span><span class="s3">] </span><span class="s1">= </span><span class="s2">result</span><span class="s3">;</span>
                <span class="s4">taskComplete</span><span class="s3">(</span><span class="s2">key</span><span class="s3">);</span>
            <span class="s3">}</span>
        <span class="s3">});</span>

        <span class="s2">runningTasks</span><span class="s1">++</span><span class="s3">;</span>
        <span class="s1">var </span><span class="s3">taskFn </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">task</span><span class="s3">[</span><span class="s2">task</span><span class="s3">.length </span><span class="s1">- </span><span class="s6">1</span><span class="s3">]);</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">task</span><span class="s3">.length </span><span class="s1">&gt; </span><span class="s6">1</span><span class="s3">) {</span>
            <span class="s4">taskFn</span><span class="s3">(</span><span class="s2">results</span><span class="s3">, </span><span class="s2">taskCallback</span><span class="s3">);</span>
        <span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
            <span class="s4">taskFn</span><span class="s3">(</span><span class="s2">taskCallback</span><span class="s3">);</span>
        <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s1">function </span><span class="s3">checkForDeadlocks() {</span>
        <span class="s0">// Kahn's algorithm</span>
        <span class="s0">// https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm</span>
        <span class="s0">// http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html</span>
        <span class="s1">var </span><span class="s3">currentTask;</span>
        <span class="s1">var </span><span class="s3">counter </span><span class="s1">= </span><span class="s6">0</span><span class="s3">;</span>
        <span class="s1">while </span><span class="s3">(</span><span class="s2">readyToCheck</span><span class="s3">.length) {</span>
            <span class="s2">currentTask </span><span class="s1">= </span><span class="s2">readyToCheck</span><span class="s3">.</span><span class="s4">pop</span><span class="s3">();</span>
            <span class="s2">counter</span><span class="s1">++</span><span class="s3">;</span>
            <span class="s4">getDependents</span><span class="s3">(</span><span class="s2">currentTask</span><span class="s3">).</span><span class="s4">forEach</span><span class="s3">(</span><span class="s2">dependent </span><span class="s1">=&gt; </span><span class="s3">{</span>
                <span class="s1">if </span><span class="s3">(</span><span class="s1">--</span><span class="s2">uncheckedDependencies</span><span class="s3">[</span><span class="s2">dependent</span><span class="s3">] </span><span class="s1">=== </span><span class="s6">0</span><span class="s3">) {</span>
                    <span class="s2">readyToCheck</span><span class="s3">.</span><span class="s4">push</span><span class="s3">(</span><span class="s2">dependent</span><span class="s3">);</span>
                <span class="s3">}</span>
            <span class="s3">});</span>
        <span class="s3">}</span>

        <span class="s1">if </span><span class="s3">(</span><span class="s2">counter </span><span class="s1">!== </span><span class="s2">numTasks</span><span class="s3">) {</span>
            <span class="s1">throw new </span><span class="s4">Error</span><span class="s3">(</span>
                <span class="s5">'async.auto cannot execute tasks due to a recursive dependency'</span>
            <span class="s3">);</span>
        <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s1">function </span><span class="s3">getDependents(</span><span class="s2">taskName</span><span class="s3">) {</span>
        <span class="s1">var </span><span class="s3">result </span><span class="s1">= </span><span class="s3">[];</span>
        <span class="s2">Object</span><span class="s3">.</span><span class="s4">keys</span><span class="s3">(</span><span class="s2">tasks</span><span class="s3">).</span><span class="s4">forEach</span><span class="s3">(</span><span class="s2">key </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s1">const </span><span class="s3">task </span><span class="s1">= </span><span class="s2">tasks</span><span class="s3">[</span><span class="s2">key</span><span class="s3">];</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">Array</span><span class="s3">.</span><span class="s4">isArray</span><span class="s3">(</span><span class="s2">task</span><span class="s3">) </span><span class="s1">&amp;&amp; </span><span class="s2">task</span><span class="s3">.</span><span class="s4">indexOf</span><span class="s3">(</span><span class="s2">taskName</span><span class="s3">) </span><span class="s1">&gt;= </span><span class="s6">0</span><span class="s3">) {</span>
                <span class="s2">result</span><span class="s3">.</span><span class="s4">push</span><span class="s3">(</span><span class="s2">key</span><span class="s3">);</span>
            <span class="s3">}</span>
        <span class="s3">});</span>
        <span class="s1">return </span><span class="s2">result</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s1">return </span><span class="s2">callback</span><span class="s3">[</span><span class="s2">PROMISE_SYMBOL</span><span class="s3">]</span>
<span class="s3">}</span>

<span class="s1">var </span><span class="s3">FN_ARGS </span><span class="s1">= </span><span class="s5">/</span><span class="s1">^</span><span class="s5">(?:async</span><span class="s7">\s</span><span class="s1">+</span><span class="s5">)</span><span class="s1">?</span><span class="s5">(?:function)</span><span class="s1">?</span><span class="s7">\s</span><span class="s1">*</span><span class="s7">\w</span><span class="s1">*</span><span class="s7">\s</span><span class="s1">*</span><span class="s8">\(</span><span class="s7">\s</span><span class="s1">*</span><span class="s5">(</span><span class="s7">[</span><span class="s8">^</span><span class="s7">)]</span><span class="s1">+</span><span class="s5">)</span><span class="s7">\s</span><span class="s1">*</span><span class="s8">\)</span><span class="s5">(?:</span><span class="s7">\s</span><span class="s1">*</span><span class="s5">{)/</span><span class="s3">;</span>
<span class="s1">var </span><span class="s3">ARROW_FN_ARGS </span><span class="s1">= </span><span class="s5">/</span><span class="s1">^</span><span class="s5">(?:async</span><span class="s7">\s</span><span class="s1">+</span><span class="s5">)</span><span class="s1">?</span><span class="s8">\(</span><span class="s1">?</span><span class="s7">\s</span><span class="s1">*</span><span class="s5">(</span><span class="s7">[</span><span class="s8">^</span><span class="s7">)=]</span><span class="s1">+</span><span class="s5">)</span><span class="s7">\s</span><span class="s1">*</span><span class="s8">\)</span><span class="s1">?</span><span class="s5">(?:</span><span class="s7">\s</span><span class="s1">*</span><span class="s5">=&gt;)/</span><span class="s3">;</span>
<span class="s1">var </span><span class="s3">FN_ARG_SPLIT </span><span class="s1">= </span><span class="s5">/,/</span><span class="s3">;</span>
<span class="s1">var </span><span class="s3">FN_ARG </span><span class="s1">= </span><span class="s5">/(=</span><span class="s7">.</span><span class="s1">+</span><span class="s5">)</span><span class="s1">?</span><span class="s5">(</span><span class="s7">\s</span><span class="s1">*</span><span class="s5">)</span><span class="s1">$</span><span class="s5">/</span><span class="s3">;</span>

<span class="s1">function </span><span class="s3">stripComments(</span><span class="s2">string</span><span class="s3">) {</span>
    <span class="s1">let </span><span class="s3">stripped </span><span class="s1">= </span><span class="s5">''</span><span class="s3">;</span>
    <span class="s1">let </span><span class="s3">index </span><span class="s1">= </span><span class="s6">0</span><span class="s3">;</span>
    <span class="s1">let </span><span class="s3">endBlockComment </span><span class="s1">= </span><span class="s2">string</span><span class="s3">.</span><span class="s4">indexOf</span><span class="s3">(</span><span class="s5">'*/'</span><span class="s3">);</span>
    <span class="s1">while </span><span class="s3">(</span><span class="s2">index </span><span class="s1">&lt; </span><span class="s2">string</span><span class="s3">.length) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">string</span><span class="s3">[</span><span class="s2">index</span><span class="s3">] </span><span class="s1">=== </span><span class="s5">'/' </span><span class="s1">&amp;&amp; </span><span class="s2">string</span><span class="s3">[</span><span class="s2">index</span><span class="s1">+</span><span class="s6">1</span><span class="s3">] </span><span class="s1">=== </span><span class="s5">'/'</span><span class="s3">) {</span>
            <span class="s0">// inline comment</span>
            <span class="s1">let </span><span class="s3">endIndex </span><span class="s1">= </span><span class="s2">string</span><span class="s3">.</span><span class="s4">indexOf</span><span class="s3">(</span><span class="s5">'</span><span class="s8">\n</span><span class="s5">'</span><span class="s3">, </span><span class="s2">index</span><span class="s3">);</span>
            <span class="s2">index </span><span class="s1">= </span><span class="s3">(</span><span class="s2">endIndex </span><span class="s1">=== -</span><span class="s6">1</span><span class="s3">) </span><span class="s1">? </span><span class="s2">string</span><span class="s3">.length </span><span class="s1">: </span><span class="s2">endIndex</span><span class="s3">;</span>
        <span class="s3">} </span><span class="s1">else if </span><span class="s3">((</span><span class="s2">endBlockComment </span><span class="s1">!== -</span><span class="s6">1</span><span class="s3">) </span><span class="s1">&amp;&amp; </span><span class="s3">(</span><span class="s2">string</span><span class="s3">[</span><span class="s2">index</span><span class="s3">] </span><span class="s1">=== </span><span class="s5">'/'</span><span class="s3">) </span><span class="s1">&amp;&amp; </span><span class="s3">(</span><span class="s2">string</span><span class="s3">[</span><span class="s2">index</span><span class="s1">+</span><span class="s6">1</span><span class="s3">] </span><span class="s1">=== </span><span class="s5">'*'</span><span class="s3">)) {</span>
            <span class="s0">// block comment</span>
            <span class="s1">let </span><span class="s3">endIndex </span><span class="s1">= </span><span class="s2">string</span><span class="s3">.</span><span class="s4">indexOf</span><span class="s3">(</span><span class="s5">'*/'</span><span class="s3">, </span><span class="s2">index</span><span class="s3">);</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">endIndex </span><span class="s1">!== -</span><span class="s6">1</span><span class="s3">) {</span>
                <span class="s2">index </span><span class="s1">= </span><span class="s2">endIndex </span><span class="s1">+ </span><span class="s6">2</span><span class="s3">;</span>
                <span class="s2">endBlockComment </span><span class="s1">= </span><span class="s2">string</span><span class="s3">.</span><span class="s4">indexOf</span><span class="s3">(</span><span class="s5">'*/'</span><span class="s3">, </span><span class="s2">index</span><span class="s3">);</span>
            <span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
                <span class="s2">stripped </span><span class="s1">+= </span><span class="s2">string</span><span class="s3">[</span><span class="s2">index</span><span class="s3">];</span>
                <span class="s2">index</span><span class="s1">++</span><span class="s3">;</span>
            <span class="s3">}</span>
        <span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
            <span class="s2">stripped </span><span class="s1">+= </span><span class="s2">string</span><span class="s3">[</span><span class="s2">index</span><span class="s3">];</span>
            <span class="s2">index</span><span class="s1">++</span><span class="s3">;</span>
        <span class="s3">}</span>
    <span class="s3">}</span>
    <span class="s1">return </span><span class="s2">stripped</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">parseParams(</span><span class="s2">func</span><span class="s3">) {</span>
    <span class="s1">const </span><span class="s3">src </span><span class="s1">= </span><span class="s4">stripComments</span><span class="s3">(</span><span class="s2">func</span><span class="s3">.</span><span class="s4">toString</span><span class="s3">());</span>
    <span class="s1">let </span><span class="s3">match </span><span class="s1">= </span><span class="s2">src</span><span class="s3">.</span><span class="s4">match</span><span class="s3">(</span><span class="s2">FN_ARGS</span><span class="s3">);</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">match</span><span class="s3">) {</span>
        <span class="s2">match </span><span class="s1">= </span><span class="s2">src</span><span class="s3">.</span><span class="s4">match</span><span class="s3">(</span><span class="s2">ARROW_FN_ARGS</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">match</span><span class="s3">) </span><span class="s1">throw new </span><span class="s4">Error</span><span class="s3">(</span><span class="s5">'could not parse args in autoInject</span><span class="s8">\n</span><span class="s5">Source:</span><span class="s8">\n</span><span class="s5">' </span><span class="s1">+ </span><span class="s2">src</span><span class="s3">)</span>
    <span class="s1">let </span><span class="s3">[, args] </span><span class="s1">= </span><span class="s2">match</span><span class="s3">;</span>
    <span class="s1">return </span><span class="s2">args</span>
        <span class="s3">.</span><span class="s4">replace</span><span class="s3">(</span><span class="s5">/</span><span class="s7">\s</span><span class="s5">/</span><span class="s1">g</span><span class="s3">, </span><span class="s5">''</span><span class="s3">)</span>
        <span class="s3">.</span><span class="s4">split</span><span class="s3">(</span><span class="s2">FN_ARG_SPLIT</span><span class="s3">)</span>
        <span class="s3">.</span><span class="s4">map</span><span class="s3">((</span><span class="s2">arg</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">arg</span><span class="s3">.</span><span class="s4">replace</span><span class="s3">(</span><span class="s2">FN_ARG</span><span class="s3">, </span><span class="s5">''</span><span class="s3">).</span><span class="s4">trim</span><span class="s3">());</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* A dependency-injected version of the </span><span class="s7">[async.auto]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.auto} </span><span class="s0">function. Dependent 
 * tasks are specified as parameters to the function, after the usual callback 
 * parameter, with the parameter names matching the names of the tasks it 
 * depends on. This can provide even more readable task graphs which can be 
 * easier to maintain. 
 * 
 * If a final callback is specified, the task results are similarly injected, 
 * specified as named parameters after the initial error parameter. 
 * 
 * The autoInject function is purely syntactic sugar and its semantics are 
 * otherwise equivalent to </span><span class="s7">[async.auto]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.auto}</span><span class="s0">. 
 * 
 * </span><span class="s1">@name </span><span class="s2">autoInject</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.auto]{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.auto}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{Object} tasks </span><span class="s0">- An object, each of whose properties is an </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">AsyncFunction} </span><span class="s0">of 
 * the form 'func([dependencies...], callback). The object's key of a property 
 * serves as the name of the task defined by that property, i.e. can be used 
 * when specifying requirements for other tasks. 
 * * The `callback` parameter is a `callback(err, result)` which must be called 
 *   when finished, passing an `error` (which can be `null`) and the result of 
 *   the function's execution. The remaining parameters name other tasks on 
 *   which the task is dependent, and the results from those tasks are the 
 *   arguments of those parameters. 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- An optional callback which is called when all 
 * the tasks have been completed. It receives the `err` argument if any `tasks` 
 * pass an error to their callback, and a `results` object with any completed 
 * task results, similar to `auto`. 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * //  The example from `auto` can be rewritten as follows: 
 * async.autoInject({ 
 *     get_data: function(callback) { 
 *         // async code to get some data 
 *         callback(null, 'data', 'converted to array'); 
 *     }, 
 *     make_folder: function(callback) { 
 *         // async code to create a directory to store a file in 
 *         // this is run at the same time as getting the data 
 *         callback(null, 'folder'); 
 *     }, 
 *     write_file: function(get_data, make_folder, callback) { 
 *         // once there is some data and the directory exists, 
 *         // write the data to a file in the directory 
 *         callback(null, 'filename'); 
 *     }, 
 *     email_link: function(write_file, callback) { 
 *         // once the file is written let's email a link to it... 
 *         // write_file contains the filename returned by write_file. 
 *         callback(null, {'file':write_file, 'email':'user@example.com'}); 
 *     } 
 * }, function(err, results) { 
 *     console.log('err = ', err); 
 *     console.log('email_link = ', results.email_link); 
 * }); 
 * 
 * // If you are using a JS minifier that mangles parameter names, `autoInject` 
 * // will not work with plain functions, since the parameter names will be 
 * // collapsed to a single letter identifier.  To work around this, you can 
 * // explicitly specify the names of the parameters your task function needs 
 * // in an array, similar to Angular.js dependency injection. 
 * 
 * // This still has an advantage over plain `auto`, since the results a task 
 * // depends on are still spread into arguments. 
 * async.autoInject({ 
 *     //... 
 *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) { 
 *         callback(null, 'filename'); 
 *     }], 
 *     email_link: ['write_file', function(write_file, callback) { 
 *         callback(null, {'file':write_file, 'email':'user@example.com'}); 
 *     }] 
 *     //... 
 * }, function(err, results) { 
 *     console.log('err = ', err); 
 *     console.log('email_link = ', results.email_link); 
 * }); 
 */</span>
<span class="s1">function </span><span class="s3">autoInject(</span><span class="s2">tasks</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">newTasks </span><span class="s1">= </span><span class="s3">{};</span>

    <span class="s2">Object</span><span class="s3">.</span><span class="s4">keys</span><span class="s3">(</span><span class="s2">tasks</span><span class="s3">).</span><span class="s4">forEach</span><span class="s3">(</span><span class="s2">key </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s1">var </span><span class="s3">taskFn </span><span class="s1">= </span><span class="s2">tasks</span><span class="s3">[</span><span class="s2">key</span><span class="s3">];</span>
        <span class="s1">var </span><span class="s3">params;</span>
        <span class="s1">var </span><span class="s3">fnIsAsync </span><span class="s1">= </span><span class="s4">isAsync</span><span class="s3">(</span><span class="s2">taskFn</span><span class="s3">);</span>
        <span class="s1">var </span><span class="s3">hasNoDeps </span><span class="s1">=</span>
            <span class="s3">(</span><span class="s1">!</span><span class="s2">fnIsAsync </span><span class="s1">&amp;&amp; </span><span class="s2">taskFn</span><span class="s3">.length </span><span class="s1">=== </span><span class="s6">1</span><span class="s3">) </span><span class="s1">||</span>
            <span class="s3">(</span><span class="s2">fnIsAsync </span><span class="s1">&amp;&amp; </span><span class="s2">taskFn</span><span class="s3">.length </span><span class="s1">=== </span><span class="s6">0</span><span class="s3">);</span>

        <span class="s1">if </span><span class="s3">(</span><span class="s2">Array</span><span class="s3">.</span><span class="s4">isArray</span><span class="s3">(</span><span class="s2">taskFn</span><span class="s3">)) {</span>
            <span class="s2">params </span><span class="s1">= </span><span class="s3">[</span><span class="s1">...</span><span class="s2">taskFn</span><span class="s3">];</span>
            <span class="s2">taskFn </span><span class="s1">= </span><span class="s2">params</span><span class="s3">.</span><span class="s4">pop</span><span class="s3">();</span>

            <span class="s2">newTasks</span><span class="s3">[</span><span class="s2">key</span><span class="s3">] </span><span class="s1">= </span><span class="s2">params</span><span class="s3">.</span><span class="s4">concat</span><span class="s3">(</span><span class="s2">params</span><span class="s3">.length </span><span class="s1">&gt; </span><span class="s6">0 </span><span class="s1">? </span><span class="s2">newTask </span><span class="s1">: </span><span class="s2">taskFn</span><span class="s3">);</span>
        <span class="s3">} </span><span class="s1">else if </span><span class="s3">(</span><span class="s2">hasNoDeps</span><span class="s3">) {</span>
            <span class="s0">// no dependencies, use the function as-is</span>
            <span class="s2">newTasks</span><span class="s3">[</span><span class="s2">key</span><span class="s3">] </span><span class="s1">= </span><span class="s2">taskFn</span><span class="s3">;</span>
        <span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
            <span class="s2">params </span><span class="s1">= </span><span class="s4">parseParams</span><span class="s3">(</span><span class="s2">taskFn</span><span class="s3">);</span>
            <span class="s1">if </span><span class="s3">((</span><span class="s2">taskFn</span><span class="s3">.length </span><span class="s1">=== </span><span class="s6">0 </span><span class="s1">&amp;&amp; !</span><span class="s2">fnIsAsync</span><span class="s3">) </span><span class="s1">&amp;&amp; </span><span class="s2">params</span><span class="s3">.length </span><span class="s1">=== </span><span class="s6">0</span><span class="s3">) {</span>
                <span class="s1">throw new </span><span class="s4">Error</span><span class="s3">(</span><span class="s5">&quot;autoInject task functions require explicit parameters.&quot;</span><span class="s3">);</span>
            <span class="s3">}</span>

            <span class="s0">// remove callback param</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">fnIsAsync</span><span class="s3">) </span><span class="s2">params</span><span class="s3">.</span><span class="s4">pop</span><span class="s3">();</span>

            <span class="s2">newTasks</span><span class="s3">[</span><span class="s2">key</span><span class="s3">] </span><span class="s1">= </span><span class="s2">params</span><span class="s3">.</span><span class="s4">concat</span><span class="s3">(</span><span class="s2">newTask</span><span class="s3">);</span>
        <span class="s3">}</span>

        <span class="s1">function </span><span class="s3">newTask(</span><span class="s2">results</span><span class="s3">, </span><span class="s2">taskCb</span><span class="s3">) {</span>
            <span class="s1">var </span><span class="s3">newArgs </span><span class="s1">= </span><span class="s2">params</span><span class="s3">.</span><span class="s4">map</span><span class="s3">(</span><span class="s2">name </span><span class="s1">=&gt; </span><span class="s2">results</span><span class="s3">[</span><span class="s2">name</span><span class="s3">]);</span>
            <span class="s2">newArgs</span><span class="s3">.</span><span class="s4">push</span><span class="s3">(</span><span class="s2">taskCb</span><span class="s3">);</span>
            <span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">taskFn</span><span class="s3">)(</span><span class="s1">...</span><span class="s2">newArgs</span><span class="s3">);</span>
        <span class="s3">}</span>
    <span class="s3">});</span>

    <span class="s1">return </span><span class="s4">auto</span><span class="s3">(</span><span class="s2">newTasks</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation</span>
<span class="s0">// used for queues. This implementation assumes that the node provided by the user can be modified</span>
<span class="s0">// to adjust the next and last properties. We implement only the minimal functionality</span>
<span class="s0">// for queue support.</span>
<span class="s1">class </span><span class="s2">DLL </span><span class="s3">{</span>
    <span class="s1">constructor</span><span class="s3">() {</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s2">head </span><span class="s1">= </span><span class="s2">this</span><span class="s3">.</span><span class="s2">tail </span><span class="s1">= </span><span class="s7">null</span><span class="s3">;</span>
        <span class="s2">this</span><span class="s3">.length </span><span class="s1">= </span><span class="s6">0</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s3">removeLink(</span><span class="s2">node</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">node</span><span class="s3">.</span><span class="s2">prev</span><span class="s3">) </span><span class="s2">node</span><span class="s3">.</span><span class="s2">prev</span><span class="s3">.</span><span class="s2">next </span><span class="s1">= </span><span class="s2">node</span><span class="s3">.</span><span class="s2">next</span><span class="s3">;</span>
        <span class="s1">else </span><span class="s2">this</span><span class="s3">.</span><span class="s2">head </span><span class="s1">= </span><span class="s2">node</span><span class="s3">.</span><span class="s2">next</span><span class="s3">;</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">node</span><span class="s3">.</span><span class="s2">next</span><span class="s3">) </span><span class="s2">node</span><span class="s3">.</span><span class="s2">next</span><span class="s3">.</span><span class="s2">prev </span><span class="s1">= </span><span class="s2">node</span><span class="s3">.</span><span class="s2">prev</span><span class="s3">;</span>
        <span class="s1">else </span><span class="s2">this</span><span class="s3">.</span><span class="s2">tail </span><span class="s1">= </span><span class="s2">node</span><span class="s3">.</span><span class="s2">prev</span><span class="s3">;</span>

        <span class="s2">node</span><span class="s3">.</span><span class="s2">prev </span><span class="s1">= </span><span class="s2">node</span><span class="s3">.</span><span class="s2">next </span><span class="s1">= </span><span class="s7">null</span><span class="s3">;</span>
        <span class="s2">this</span><span class="s3">.length </span><span class="s1">-= </span><span class="s6">1</span><span class="s3">;</span>
        <span class="s1">return </span><span class="s2">node</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s3">empty () {</span>
        <span class="s1">while</span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s2">head</span><span class="s3">) </span><span class="s2">this</span><span class="s3">.</span><span class="s4">shift</span><span class="s3">();</span>
        <span class="s1">return </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s3">insertAfter(</span><span class="s2">node</span><span class="s3">, </span><span class="s2">newNode</span><span class="s3">) {</span>
        <span class="s2">newNode</span><span class="s3">.</span><span class="s2">prev </span><span class="s1">= </span><span class="s2">node</span><span class="s3">;</span>
        <span class="s2">newNode</span><span class="s3">.</span><span class="s2">next </span><span class="s1">= </span><span class="s2">node</span><span class="s3">.</span><span class="s2">next</span><span class="s3">;</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">node</span><span class="s3">.</span><span class="s2">next</span><span class="s3">) </span><span class="s2">node</span><span class="s3">.</span><span class="s2">next</span><span class="s3">.</span><span class="s2">prev </span><span class="s1">= </span><span class="s2">newNode</span><span class="s3">;</span>
        <span class="s1">else </span><span class="s2">this</span><span class="s3">.</span><span class="s2">tail </span><span class="s1">= </span><span class="s2">newNode</span><span class="s3">;</span>
        <span class="s2">node</span><span class="s3">.</span><span class="s2">next </span><span class="s1">= </span><span class="s2">newNode</span><span class="s3">;</span>
        <span class="s2">this</span><span class="s3">.length </span><span class="s1">+= </span><span class="s6">1</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s3">insertBefore(</span><span class="s2">node</span><span class="s3">, </span><span class="s2">newNode</span><span class="s3">) {</span>
        <span class="s2">newNode</span><span class="s3">.</span><span class="s2">prev </span><span class="s1">= </span><span class="s2">node</span><span class="s3">.</span><span class="s2">prev</span><span class="s3">;</span>
        <span class="s2">newNode</span><span class="s3">.</span><span class="s2">next </span><span class="s1">= </span><span class="s2">node</span><span class="s3">;</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">node</span><span class="s3">.</span><span class="s2">prev</span><span class="s3">) </span><span class="s2">node</span><span class="s3">.</span><span class="s2">prev</span><span class="s3">.</span><span class="s2">next </span><span class="s1">= </span><span class="s2">newNode</span><span class="s3">;</span>
        <span class="s1">else </span><span class="s2">this</span><span class="s3">.</span><span class="s2">head </span><span class="s1">= </span><span class="s2">newNode</span><span class="s3">;</span>
        <span class="s2">node</span><span class="s3">.</span><span class="s2">prev </span><span class="s1">= </span><span class="s2">newNode</span><span class="s3">;</span>
        <span class="s2">this</span><span class="s3">.length </span><span class="s1">+= </span><span class="s6">1</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s3">unshift(</span><span class="s2">node</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s2">head</span><span class="s3">) </span><span class="s2">this</span><span class="s3">.</span><span class="s4">insertBefore</span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s2">head</span><span class="s3">, </span><span class="s2">node</span><span class="s3">);</span>
        <span class="s1">else </span><span class="s4">setInitial</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s2">node</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s3">push(</span><span class="s2">node</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s2">tail</span><span class="s3">) </span><span class="s2">this</span><span class="s3">.</span><span class="s4">insertAfter</span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s2">tail</span><span class="s3">, </span><span class="s2">node</span><span class="s3">);</span>
        <span class="s1">else </span><span class="s4">setInitial</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s2">node</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s3">shift() {</span>
        <span class="s1">return </span><span class="s2">this</span><span class="s3">.</span><span class="s2">head </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s3">.</span><span class="s4">removeLink</span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s2">head</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s3">pop() {</span>
        <span class="s1">return </span><span class="s2">this</span><span class="s3">.</span><span class="s2">tail </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s3">.</span><span class="s4">removeLink</span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s2">tail</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s3">toArray() {</span>
        <span class="s1">return </span><span class="s3">[</span><span class="s1">...</span><span class="s2">this</span><span class="s3">]</span>
    <span class="s3">}</span>

    <span class="s1">*</span><span class="s3">[</span><span class="s2">Symbol</span><span class="s3">.</span><span class="s2">iterator</span><span class="s3">] () {</span>
        <span class="s1">var </span><span class="s3">cur </span><span class="s1">= </span><span class="s2">this</span><span class="s3">.</span><span class="s2">head</span><span class="s3">;</span>
        <span class="s1">while </span><span class="s3">(</span><span class="s2">cur</span><span class="s3">) {</span>
            <span class="s1">yield </span><span class="s2">cur</span><span class="s3">.</span><span class="s2">data</span><span class="s3">;</span>
            <span class="s2">cur </span><span class="s1">= </span><span class="s2">cur</span><span class="s3">.</span><span class="s2">next</span><span class="s3">;</span>
        <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s3">remove (</span><span class="s2">testFn</span><span class="s3">) {</span>
        <span class="s1">var </span><span class="s3">curr </span><span class="s1">= </span><span class="s2">this</span><span class="s3">.</span><span class="s2">head</span><span class="s3">;</span>
        <span class="s1">while</span><span class="s3">(</span><span class="s2">curr</span><span class="s3">) {</span>
            <span class="s1">var </span><span class="s3">{next} </span><span class="s1">= </span><span class="s2">curr</span><span class="s3">;</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s4">testFn</span><span class="s3">(</span><span class="s2">curr</span><span class="s3">)) {</span>
                <span class="s2">this</span><span class="s3">.</span><span class="s4">removeLink</span><span class="s3">(</span><span class="s2">curr</span><span class="s3">);</span>
            <span class="s3">}</span>
            <span class="s2">curr </span><span class="s1">= </span><span class="s2">next</span><span class="s3">;</span>
        <span class="s3">}</span>
        <span class="s1">return </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s3">}</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">setInitial(</span><span class="s2">dll</span><span class="s3">, </span><span class="s2">node</span><span class="s3">) {</span>
    <span class="s2">dll</span><span class="s3">.length </span><span class="s1">= </span><span class="s6">1</span><span class="s3">;</span>
    <span class="s2">dll</span><span class="s3">.</span><span class="s2">head </span><span class="s1">= </span><span class="s2">dll</span><span class="s3">.</span><span class="s2">tail </span><span class="s1">= </span><span class="s2">node</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">queue(</span><span class="s2">worker</span><span class="s3">, </span><span class="s2">concurrency</span><span class="s3">, </span><span class="s2">payload</span><span class="s3">) {</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s2">concurrency </span><span class="s1">== </span><span class="s7">null</span><span class="s3">) {</span>
        <span class="s2">concurrency </span><span class="s1">= </span><span class="s6">1</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">else if</span><span class="s3">(</span><span class="s2">concurrency </span><span class="s1">=== </span><span class="s6">0</span><span class="s3">) {</span>
        <span class="s1">throw new </span><span class="s4">RangeError</span><span class="s3">(</span><span class="s5">'Concurrency must not be zero'</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s1">var </span><span class="s3">_worker </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">worker</span><span class="s3">);</span>
    <span class="s1">var </span><span class="s3">numRunning </span><span class="s1">= </span><span class="s6">0</span><span class="s3">;</span>
    <span class="s1">var </span><span class="s3">workersList </span><span class="s1">= </span><span class="s3">[];</span>
    <span class="s1">const </span><span class="s3">events </span><span class="s1">= </span><span class="s3">{</span>
        <span class="s3">error: [],</span>
        <span class="s3">drain: [],</span>
        <span class="s3">saturated: [],</span>
        <span class="s3">unsaturated: [],</span>
        <span class="s3">empty: []</span>
    <span class="s3">};</span>

    <span class="s1">function </span><span class="s3">on (</span><span class="s2">event</span><span class="s3">, </span><span class="s2">handler</span><span class="s3">) {</span>
        <span class="s2">events</span><span class="s3">[</span><span class="s2">event</span><span class="s3">].</span><span class="s4">push</span><span class="s3">(</span><span class="s2">handler</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s1">function </span><span class="s3">once (</span><span class="s2">event</span><span class="s3">, </span><span class="s2">handler</span><span class="s3">) {</span>
        <span class="s1">const </span><span class="s3">handleAndRemove </span><span class="s1">= </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s4">off</span><span class="s3">(</span><span class="s2">event</span><span class="s3">, </span><span class="s2">handleAndRemove</span><span class="s3">);</span>
            <span class="s4">handler</span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">);</span>
        <span class="s3">};</span>
        <span class="s2">events</span><span class="s3">[</span><span class="s2">event</span><span class="s3">].</span><span class="s4">push</span><span class="s3">(</span><span class="s2">handleAndRemove</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s1">function </span><span class="s3">off (</span><span class="s2">event</span><span class="s3">, </span><span class="s2">handler</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">event</span><span class="s3">) </span><span class="s1">return </span><span class="s2">Object</span><span class="s3">.</span><span class="s4">keys</span><span class="s3">(</span><span class="s2">events</span><span class="s3">).</span><span class="s4">forEach</span><span class="s3">(</span><span class="s2">ev </span><span class="s1">=&gt; </span><span class="s2">events</span><span class="s3">[</span><span class="s2">ev</span><span class="s3">] </span><span class="s1">= </span><span class="s3">[])</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">handler</span><span class="s3">) </span><span class="s1">return </span><span class="s2">events</span><span class="s3">[</span><span class="s2">event</span><span class="s3">] </span><span class="s1">= </span><span class="s3">[]</span>
        <span class="s2">events</span><span class="s3">[</span><span class="s2">event</span><span class="s3">] </span><span class="s1">= </span><span class="s2">events</span><span class="s3">[</span><span class="s2">event</span><span class="s3">].</span><span class="s4">filter</span><span class="s3">(</span><span class="s2">ev </span><span class="s1">=&gt; </span><span class="s2">ev </span><span class="s1">!== </span><span class="s2">handler</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s1">function </span><span class="s3">trigger (</span><span class="s2">event</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s3">) {</span>
        <span class="s2">events</span><span class="s3">[</span><span class="s2">event</span><span class="s3">].</span><span class="s4">forEach</span><span class="s3">(</span><span class="s2">handler </span><span class="s1">=&gt; </span><span class="s4">handler</span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">));</span>
    <span class="s3">}</span>

    <span class="s1">var </span><span class="s3">processingScheduled </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">_insert(</span><span class="s2">data</span><span class="s3">, </span><span class="s2">insertAtFront</span><span class="s3">, </span><span class="s2">rejectOnError</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">callback </span><span class="s1">!= </span><span class="s7">null </span><span class="s1">&amp;&amp; typeof </span><span class="s2">callback </span><span class="s1">!== </span><span class="s5">'function'</span><span class="s3">) {</span>
            <span class="s1">throw new </span><span class="s4">Error</span><span class="s3">(</span><span class="s5">'task callback must be a function'</span><span class="s3">);</span>
        <span class="s3">}</span>
        <span class="s2">q</span><span class="s3">.</span><span class="s2">started </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>

        <span class="s1">var </span><span class="s3">res, rej;</span>
        <span class="s1">function </span><span class="s3">promiseCallback (</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s3">) {</span>
            <span class="s0">// we don't care about the error, let the global error handler</span>
            <span class="s0">// deal with it</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s2">rejectOnError </span><span class="s1">? </span><span class="s4">rej</span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">: </span><span class="s4">res</span><span class="s3">()</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">args</span><span class="s3">.length </span><span class="s1">&lt;= </span><span class="s6">1</span><span class="s3">) </span><span class="s1">return </span><span class="s4">res</span><span class="s3">(</span><span class="s2">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
            <span class="s4">res</span><span class="s3">(</span><span class="s2">args</span><span class="s3">);</span>
        <span class="s3">}</span>

        <span class="s1">var </span><span class="s3">item </span><span class="s1">= </span><span class="s2">q</span><span class="s3">.</span><span class="s4">_createTaskItem</span><span class="s3">(</span>
            <span class="s2">data</span><span class="s3">,</span>
            <span class="s2">rejectOnError </span><span class="s1">? </span><span class="s2">promiseCallback </span><span class="s1">:</span>
                <span class="s3">(</span><span class="s2">callback </span><span class="s1">|| </span><span class="s2">promiseCallback</span><span class="s3">)</span>
        <span class="s3">);</span>

        <span class="s1">if </span><span class="s3">(</span><span class="s2">insertAtFront</span><span class="s3">) {</span>
            <span class="s2">q</span><span class="s3">.</span><span class="s2">_tasks</span><span class="s3">.</span><span class="s4">unshift</span><span class="s3">(</span><span class="s2">item</span><span class="s3">);</span>
        <span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
            <span class="s2">q</span><span class="s3">.</span><span class="s2">_tasks</span><span class="s3">.</span><span class="s4">push</span><span class="s3">(</span><span class="s2">item</span><span class="s3">);</span>
        <span class="s3">}</span>

        <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">processingScheduled</span><span class="s3">) {</span>
            <span class="s2">processingScheduled </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
            <span class="s4">setImmediate$1</span><span class="s3">(() </span><span class="s1">=&gt; </span><span class="s3">{</span>
                <span class="s2">processingScheduled </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
                <span class="s2">q</span><span class="s3">.</span><span class="s4">process</span><span class="s3">();</span>
            <span class="s3">});</span>
        <span class="s3">}</span>

        <span class="s1">if </span><span class="s3">(</span><span class="s2">rejectOnError </span><span class="s1">|| !</span><span class="s2">callback</span><span class="s3">) {</span>
            <span class="s1">return new </span><span class="s3">Promise((</span><span class="s2">resolve</span><span class="s3">, </span><span class="s2">reject</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
                <span class="s2">res </span><span class="s1">= </span><span class="s2">resolve</span><span class="s3">;</span>
                <span class="s2">rej </span><span class="s1">= </span><span class="s2">reject</span><span class="s3">;</span>
            <span class="s3">})</span>
        <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s1">function </span><span class="s3">_createCB(</span><span class="s2">tasks</span><span class="s3">) {</span>
        <span class="s1">return function </span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s3">) {</span>
            <span class="s2">numRunning </span><span class="s1">-= </span><span class="s6">1</span><span class="s3">;</span>

            <span class="s1">for </span><span class="s3">(</span><span class="s1">var </span><span class="s3">i </span><span class="s1">= </span><span class="s6">0</span><span class="s3">, l </span><span class="s1">= </span><span class="s2">tasks</span><span class="s3">.length; </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">l</span><span class="s3">; </span><span class="s2">i</span><span class="s1">++</span><span class="s3">) {</span>
                <span class="s1">var </span><span class="s3">task </span><span class="s1">= </span><span class="s2">tasks</span><span class="s3">[</span><span class="s2">i</span><span class="s3">];</span>

                <span class="s1">var </span><span class="s3">index </span><span class="s1">= </span><span class="s2">workersList</span><span class="s3">.</span><span class="s4">indexOf</span><span class="s3">(</span><span class="s2">task</span><span class="s3">);</span>
                <span class="s1">if </span><span class="s3">(</span><span class="s2">index </span><span class="s1">=== </span><span class="s6">0</span><span class="s3">) {</span>
                    <span class="s2">workersList</span><span class="s3">.</span><span class="s4">shift</span><span class="s3">();</span>
                <span class="s3">} </span><span class="s1">else if </span><span class="s3">(</span><span class="s2">index </span><span class="s1">&gt; </span><span class="s6">0</span><span class="s3">) {</span>
                    <span class="s2">workersList</span><span class="s3">.</span><span class="s4">splice</span><span class="s3">(</span><span class="s2">index</span><span class="s3">, </span><span class="s6">1</span><span class="s3">);</span>
                <span class="s3">}</span>

                <span class="s2">task</span><span class="s3">.</span><span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s3">);</span>

                <span class="s1">if </span><span class="s3">(</span><span class="s2">err </span><span class="s1">!= </span><span class="s7">null</span><span class="s3">) {</span>
                    <span class="s4">trigger</span><span class="s3">(</span><span class="s5">'error'</span><span class="s3">, </span><span class="s2">err</span><span class="s3">, </span><span class="s2">task</span><span class="s3">.</span><span class="s2">data</span><span class="s3">);</span>
                <span class="s3">}</span>
            <span class="s3">}</span>

            <span class="s1">if </span><span class="s3">(</span><span class="s2">numRunning </span><span class="s1">&lt;= </span><span class="s3">(</span><span class="s2">q</span><span class="s3">.</span><span class="s2">concurrency </span><span class="s1">- </span><span class="s2">q</span><span class="s3">.</span><span class="s2">buffer</span><span class="s3">) ) {</span>
                <span class="s4">trigger</span><span class="s3">(</span><span class="s5">'unsaturated'</span><span class="s3">);</span>
            <span class="s3">}</span>

            <span class="s1">if </span><span class="s3">(</span><span class="s2">q</span><span class="s3">.</span><span class="s4">idle</span><span class="s3">()) {</span>
                <span class="s4">trigger</span><span class="s3">(</span><span class="s5">'drain'</span><span class="s3">);</span>
            <span class="s3">}</span>
            <span class="s2">q</span><span class="s3">.</span><span class="s4">process</span><span class="s3">();</span>
        <span class="s3">};</span>
    <span class="s3">}</span>

    <span class="s1">function </span><span class="s3">_maybeDrain(</span><span class="s2">data</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">data</span><span class="s3">.length </span><span class="s1">=== </span><span class="s6">0 </span><span class="s1">&amp;&amp; </span><span class="s2">q</span><span class="s3">.</span><span class="s4">idle</span><span class="s3">()) {</span>
            <span class="s0">// call drain immediately if there are no tasks</span>
            <span class="s4">setImmediate$1</span><span class="s3">(() </span><span class="s1">=&gt; </span><span class="s4">trigger</span><span class="s3">(</span><span class="s5">'drain'</span><span class="s3">));</span>
            <span class="s1">return </span><span class="s7">true</span>
        <span class="s3">}</span>
        <span class="s1">return </span><span class="s7">false</span>
    <span class="s3">}</span>

    <span class="s1">const </span><span class="s3">eventMethod </span><span class="s1">= </span><span class="s3">(</span><span class="s2">name</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">(</span><span class="s2">handler</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">handler</span><span class="s3">) {</span>
            <span class="s1">return new </span><span class="s3">Promise((</span><span class="s2">resolve</span><span class="s3">, </span><span class="s2">reject</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
                <span class="s4">once</span><span class="s3">(</span><span class="s2">name</span><span class="s3">, (</span><span class="s2">err</span><span class="s3">, </span><span class="s2">data</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
                    <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">reject</span><span class="s3">(</span><span class="s2">err</span><span class="s3">)</span>
                    <span class="s4">resolve</span><span class="s3">(</span><span class="s2">data</span><span class="s3">);</span>
                <span class="s3">});</span>
            <span class="s3">})</span>
        <span class="s3">}</span>
        <span class="s4">off</span><span class="s3">(</span><span class="s2">name</span><span class="s3">);</span>
        <span class="s4">on</span><span class="s3">(</span><span class="s2">name</span><span class="s3">, </span><span class="s2">handler</span><span class="s3">);</span>

    <span class="s3">};</span>

    <span class="s1">var </span><span class="s3">isProcessing </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
    <span class="s1">var </span><span class="s3">q </span><span class="s1">= </span><span class="s3">{</span>
        <span class="s3">_tasks: </span><span class="s1">new </span><span class="s4">DLL</span><span class="s3">(),</span>
        <span class="s3">_createTaskItem (</span><span class="s2">data</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
            <span class="s1">return </span><span class="s3">{</span>
                <span class="s2">data</span><span class="s3">,</span>
                <span class="s2">callback</span>
            <span class="s3">};</span>
        <span class="s3">},</span>
        <span class="s1">*</span><span class="s3">[</span><span class="s2">Symbol</span><span class="s3">.</span><span class="s2">iterator</span><span class="s3">] () {</span>
            <span class="s1">yield* </span><span class="s2">q</span><span class="s3">.</span><span class="s2">_tasks</span><span class="s3">[</span><span class="s2">Symbol</span><span class="s3">.</span><span class="s2">iterator</span><span class="s3">]();</span>
        <span class="s3">},</span>
        <span class="s2">concurrency</span><span class="s3">,</span>
        <span class="s2">payload</span><span class="s3">,</span>
        <span class="s3">buffer: </span><span class="s2">concurrency </span><span class="s1">/ </span><span class="s6">4</span><span class="s3">,</span>
        <span class="s3">started: </span><span class="s7">false</span><span class="s3">,</span>
        <span class="s3">paused: </span><span class="s7">false</span><span class="s3">,</span>
        <span class="s3">push (</span><span class="s2">data</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">Array</span><span class="s3">.</span><span class="s4">isArray</span><span class="s3">(</span><span class="s2">data</span><span class="s3">)) {</span>
                <span class="s1">if </span><span class="s3">(</span><span class="s4">_maybeDrain</span><span class="s3">(</span><span class="s2">data</span><span class="s3">)) </span><span class="s1">return</span>
                <span class="s1">return </span><span class="s2">data</span><span class="s3">.</span><span class="s4">map</span><span class="s3">(</span><span class="s2">datum </span><span class="s1">=&gt; </span><span class="s4">_insert</span><span class="s3">(</span><span class="s2">datum</span><span class="s3">, </span><span class="s7">false</span><span class="s3">, </span><span class="s7">false</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">))</span>
            <span class="s3">}</span>
            <span class="s1">return </span><span class="s4">_insert</span><span class="s3">(</span><span class="s2">data</span><span class="s3">, </span><span class="s7">false</span><span class="s3">, </span><span class="s7">false</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">);</span>
        <span class="s3">},</span>
        <span class="s3">pushAsync (</span><span class="s2">data</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">Array</span><span class="s3">.</span><span class="s4">isArray</span><span class="s3">(</span><span class="s2">data</span><span class="s3">)) {</span>
                <span class="s1">if </span><span class="s3">(</span><span class="s4">_maybeDrain</span><span class="s3">(</span><span class="s2">data</span><span class="s3">)) </span><span class="s1">return</span>
                <span class="s1">return </span><span class="s2">data</span><span class="s3">.</span><span class="s4">map</span><span class="s3">(</span><span class="s2">datum </span><span class="s1">=&gt; </span><span class="s4">_insert</span><span class="s3">(</span><span class="s2">datum</span><span class="s3">, </span><span class="s7">false</span><span class="s3">, </span><span class="s7">true</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">))</span>
            <span class="s3">}</span>
            <span class="s1">return </span><span class="s4">_insert</span><span class="s3">(</span><span class="s2">data</span><span class="s3">, </span><span class="s7">false</span><span class="s3">, </span><span class="s7">true</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">);</span>
        <span class="s3">},</span>
        <span class="s3">kill () {</span>
            <span class="s4">off</span><span class="s3">();</span>
            <span class="s2">q</span><span class="s3">.</span><span class="s2">_tasks</span><span class="s3">.</span><span class="s4">empty</span><span class="s3">();</span>
        <span class="s3">},</span>
        <span class="s3">unshift (</span><span class="s2">data</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">Array</span><span class="s3">.</span><span class="s4">isArray</span><span class="s3">(</span><span class="s2">data</span><span class="s3">)) {</span>
                <span class="s1">if </span><span class="s3">(</span><span class="s4">_maybeDrain</span><span class="s3">(</span><span class="s2">data</span><span class="s3">)) </span><span class="s1">return</span>
                <span class="s1">return </span><span class="s2">data</span><span class="s3">.</span><span class="s4">map</span><span class="s3">(</span><span class="s2">datum </span><span class="s1">=&gt; </span><span class="s4">_insert</span><span class="s3">(</span><span class="s2">datum</span><span class="s3">, </span><span class="s7">true</span><span class="s3">, </span><span class="s7">false</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">))</span>
            <span class="s3">}</span>
            <span class="s1">return </span><span class="s4">_insert</span><span class="s3">(</span><span class="s2">data</span><span class="s3">, </span><span class="s7">true</span><span class="s3">, </span><span class="s7">false</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">);</span>
        <span class="s3">},</span>
        <span class="s3">unshiftAsync (</span><span class="s2">data</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">Array</span><span class="s3">.</span><span class="s4">isArray</span><span class="s3">(</span><span class="s2">data</span><span class="s3">)) {</span>
                <span class="s1">if </span><span class="s3">(</span><span class="s4">_maybeDrain</span><span class="s3">(</span><span class="s2">data</span><span class="s3">)) </span><span class="s1">return</span>
                <span class="s1">return </span><span class="s2">data</span><span class="s3">.</span><span class="s4">map</span><span class="s3">(</span><span class="s2">datum </span><span class="s1">=&gt; </span><span class="s4">_insert</span><span class="s3">(</span><span class="s2">datum</span><span class="s3">, </span><span class="s7">true</span><span class="s3">, </span><span class="s7">true</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">))</span>
            <span class="s3">}</span>
            <span class="s1">return </span><span class="s4">_insert</span><span class="s3">(</span><span class="s2">data</span><span class="s3">, </span><span class="s7">true</span><span class="s3">, </span><span class="s7">true</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">);</span>
        <span class="s3">},</span>
        <span class="s3">remove (</span><span class="s2">testFn</span><span class="s3">) {</span>
            <span class="s2">q</span><span class="s3">.</span><span class="s2">_tasks</span><span class="s3">.</span><span class="s4">remove</span><span class="s3">(</span><span class="s2">testFn</span><span class="s3">);</span>
        <span class="s3">},</span>
        <span class="s3">process () {</span>
            <span class="s0">// Avoid trying to start too many processing operations. This can occur</span>
            <span class="s0">// when callbacks resolve synchronously (#1267).</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">isProcessing</span><span class="s3">) {</span>
                <span class="s1">return</span><span class="s3">;</span>
            <span class="s3">}</span>
            <span class="s2">isProcessing </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
            <span class="s1">while</span><span class="s3">(</span><span class="s1">!</span><span class="s2">q</span><span class="s3">.</span><span class="s2">paused </span><span class="s1">&amp;&amp; </span><span class="s2">numRunning </span><span class="s1">&lt; </span><span class="s2">q</span><span class="s3">.</span><span class="s2">concurrency </span><span class="s1">&amp;&amp; </span><span class="s2">q</span><span class="s3">.</span><span class="s2">_tasks</span><span class="s3">.length){</span>
                <span class="s1">var </span><span class="s3">tasks </span><span class="s1">= </span><span class="s3">[], data </span><span class="s1">= </span><span class="s3">[];</span>
                <span class="s1">var </span><span class="s3">l </span><span class="s1">= </span><span class="s2">q</span><span class="s3">.</span><span class="s2">_tasks</span><span class="s3">.length;</span>
                <span class="s1">if </span><span class="s3">(</span><span class="s2">q</span><span class="s3">.</span><span class="s2">payload</span><span class="s3">) </span><span class="s2">l </span><span class="s1">= </span><span class="s2">Math</span><span class="s3">.</span><span class="s4">min</span><span class="s3">(</span><span class="s2">l</span><span class="s3">, </span><span class="s2">q</span><span class="s3">.</span><span class="s2">payload</span><span class="s3">);</span>
                <span class="s1">for </span><span class="s3">(</span><span class="s1">var </span><span class="s3">i </span><span class="s1">= </span><span class="s6">0</span><span class="s3">; </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">l</span><span class="s3">; </span><span class="s2">i</span><span class="s1">++</span><span class="s3">) {</span>
                    <span class="s1">var </span><span class="s3">node </span><span class="s1">= </span><span class="s2">q</span><span class="s3">.</span><span class="s2">_tasks</span><span class="s3">.</span><span class="s4">shift</span><span class="s3">();</span>
                    <span class="s2">tasks</span><span class="s3">.</span><span class="s4">push</span><span class="s3">(</span><span class="s2">node</span><span class="s3">);</span>
                    <span class="s2">workersList</span><span class="s3">.</span><span class="s4">push</span><span class="s3">(</span><span class="s2">node</span><span class="s3">);</span>
                    <span class="s2">data</span><span class="s3">.</span><span class="s4">push</span><span class="s3">(</span><span class="s2">node</span><span class="s3">.</span><span class="s2">data</span><span class="s3">);</span>
                <span class="s3">}</span>

                <span class="s2">numRunning </span><span class="s1">+= </span><span class="s6">1</span><span class="s3">;</span>

                <span class="s1">if </span><span class="s3">(</span><span class="s2">q</span><span class="s3">.</span><span class="s2">_tasks</span><span class="s3">.length </span><span class="s1">=== </span><span class="s6">0</span><span class="s3">) {</span>
                    <span class="s4">trigger</span><span class="s3">(</span><span class="s5">'empty'</span><span class="s3">);</span>
                <span class="s3">}</span>

                <span class="s1">if </span><span class="s3">(</span><span class="s2">numRunning </span><span class="s1">=== </span><span class="s2">q</span><span class="s3">.</span><span class="s2">concurrency</span><span class="s3">) {</span>
                    <span class="s4">trigger</span><span class="s3">(</span><span class="s5">'saturated'</span><span class="s3">);</span>
                <span class="s3">}</span>

                <span class="s1">var </span><span class="s3">cb </span><span class="s1">= </span><span class="s4">onlyOnce</span><span class="s3">(</span><span class="s4">_createCB</span><span class="s3">(</span><span class="s2">tasks</span><span class="s3">));</span>
                <span class="s4">_worker</span><span class="s3">(</span><span class="s2">data</span><span class="s3">, </span><span class="s2">cb</span><span class="s3">);</span>
            <span class="s3">}</span>
            <span class="s2">isProcessing </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
        <span class="s3">},</span>
        <span class="s3">length () {</span>
            <span class="s1">return </span><span class="s2">q</span><span class="s3">.</span><span class="s2">_tasks</span><span class="s3">.length;</span>
        <span class="s3">},</span>
        <span class="s3">running () {</span>
            <span class="s1">return </span><span class="s2">numRunning</span><span class="s3">;</span>
        <span class="s3">},</span>
        <span class="s3">workersList () {</span>
            <span class="s1">return </span><span class="s2">workersList</span><span class="s3">;</span>
        <span class="s3">},</span>
        <span class="s3">idle() {</span>
            <span class="s1">return </span><span class="s2">q</span><span class="s3">.</span><span class="s2">_tasks</span><span class="s3">.length </span><span class="s1">+ </span><span class="s2">numRunning </span><span class="s1">=== </span><span class="s6">0</span><span class="s3">;</span>
        <span class="s3">},</span>
        <span class="s3">pause () {</span>
            <span class="s2">q</span><span class="s3">.</span><span class="s2">paused </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
        <span class="s3">},</span>
        <span class="s3">resume () {</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">q</span><span class="s3">.</span><span class="s2">paused </span><span class="s1">=== </span><span class="s7">false</span><span class="s3">) { </span><span class="s1">return</span><span class="s3">; }</span>
            <span class="s2">q</span><span class="s3">.</span><span class="s2">paused </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
            <span class="s4">setImmediate$1</span><span class="s3">(</span><span class="s2">q</span><span class="s3">.</span><span class="s2">process</span><span class="s3">);</span>
        <span class="s3">}</span>
    <span class="s3">};</span>
    <span class="s0">// define these as fixed properties, so people get useful errors when updating</span>
    <span class="s2">Object</span><span class="s3">.</span><span class="s4">defineProperties</span><span class="s3">(</span><span class="s2">q</span><span class="s3">, {</span>
        <span class="s3">saturated: {</span>
            <span class="s3">writable: </span><span class="s7">false</span><span class="s3">,</span>
            <span class="s3">value: </span><span class="s4">eventMethod</span><span class="s3">(</span><span class="s5">'saturated'</span><span class="s3">)</span>
        <span class="s3">},</span>
        <span class="s3">unsaturated: {</span>
            <span class="s3">writable: </span><span class="s7">false</span><span class="s3">,</span>
            <span class="s3">value: </span><span class="s4">eventMethod</span><span class="s3">(</span><span class="s5">'unsaturated'</span><span class="s3">)</span>
        <span class="s3">},</span>
        <span class="s3">empty: {</span>
            <span class="s3">writable: </span><span class="s7">false</span><span class="s3">,</span>
            <span class="s3">value: </span><span class="s4">eventMethod</span><span class="s3">(</span><span class="s5">'empty'</span><span class="s3">)</span>
        <span class="s3">},</span>
        <span class="s3">drain: {</span>
            <span class="s3">writable: </span><span class="s7">false</span><span class="s3">,</span>
            <span class="s3">value: </span><span class="s4">eventMethod</span><span class="s3">(</span><span class="s5">'drain'</span><span class="s3">)</span>
        <span class="s3">},</span>
        <span class="s3">error: {</span>
            <span class="s3">writable: </span><span class="s7">false</span><span class="s3">,</span>
            <span class="s3">value: </span><span class="s4">eventMethod</span><span class="s3">(</span><span class="s5">'error'</span><span class="s3">)</span>
        <span class="s3">},</span>
    <span class="s3">});</span>
    <span class="s1">return </span><span class="s2">q</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a `cargo` object with the specified payload. Tasks added to the 
 * cargo will be processed altogether (up to the `payload` limit). If the 
 * `worker` is in progress, the task is queued until it becomes available. Once 
 * the `worker` has completed some tasks, each callback of those tasks is 
 * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966) 
 * for how `cargo` and `queue` work. 
 * 
 * While </span><span class="s7">[`queue`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.queue} </span><span class="s0">passes only one task to one of a group of workers 
 * at a time, cargo passes an array of tasks to a single worker, repeating 
 * when the worker is finished. 
 * 
 * </span><span class="s1">@name </span><span class="s2">cargo</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.queue]{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.queue}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} worker </span><span class="s0">- An asynchronous function for processing an array 
 * of queued tasks. Invoked with `(tasks, callback)`. 
 * </span><span class="s1">@param </span><span class="s2">{number} [payload</span><span class="s1">=</span><span class="s2">Infinity] </span><span class="s0">- An optional `integer` for determining 
 * how many tasks should be processed per round; if omitted, the default is 
 * unlimited. 
 * </span><span class="s1">@returns </span><span class="s2">{module:ControlFlow.QueueObject} </span><span class="s0">A cargo object to manage the tasks. Callbacks can 
 * attached as certain properties to listen for specific events during the 
 * lifecycle of the cargo and inner queue. 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // create a cargo object with payload 2 
 * var cargo = async.cargo(function(tasks, callback) { 
 *     for (var i=0; i&lt;tasks.length; i++) { 
 *         console.log('hello ' + tasks[i].name); 
 *     } 
 *     callback(); 
 * }, 2); 
 * 
 * // add some items 
 * cargo.push({name: 'foo'}, function(err) { 
 *     console.log('finished processing foo'); 
 * }); 
 * cargo.push({name: 'bar'}, function(err) { 
 *     console.log('finished processing bar'); 
 * }); 
 * await cargo.push({name: 'baz'}); 
 * console.log('finished processing baz'); 
 */</span>
<span class="s1">function </span><span class="s3">cargo(</span><span class="s2">worker</span><span class="s3">, </span><span class="s2">payload</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">queue</span><span class="s3">(</span><span class="s2">worker</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s2">payload</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a `cargoQueue` object with the specified payload. Tasks added to the 
 * cargoQueue will be processed together (up to the `payload` limit) in `concurrency` parallel workers. 
 * If the all `workers` are in progress, the task is queued until one becomes available. Once 
 * a `worker` has completed some tasks, each callback of those tasks is 
 * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966) 
 * for how `cargo` and `queue` work. 
 * 
 * While </span><span class="s7">[`queue`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.queue} </span><span class="s0">passes only one task to one of a group of workers 
 * at a time, and </span><span class="s7">[`cargo`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.cargo} </span><span class="s0">passes an array of tasks to a single worker, 
 * the cargoQueue passes an array of tasks to multiple parallel workers. 
 * 
 * </span><span class="s1">@name </span><span class="s2">cargoQueue</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.queue]{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.queue}</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.cargo]{</span><span class="s1">@link </span><span class="s2">module:ControlFLow.cargo}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} worker </span><span class="s0">- An asynchronous function for processing an array 
 * of queued tasks. Invoked with `(tasks, callback)`. 
 * </span><span class="s1">@param </span><span class="s2">{number} [concurrency</span><span class="s1">=</span><span class="s2">1] </span><span class="s0">- An `integer` for determining how many 
 * `worker` functions should be run in parallel.  If omitted, the concurrency 
 * defaults to `1`.  If the concurrency is `0`, an error is thrown. 
 * </span><span class="s1">@param </span><span class="s2">{number} [payload</span><span class="s1">=</span><span class="s2">Infinity] </span><span class="s0">- An optional `integer` for determining 
 * how many tasks should be processed per round; if omitted, the default is 
 * unlimited. 
 * </span><span class="s1">@returns </span><span class="s2">{module:ControlFlow.QueueObject} </span><span class="s0">A cargoQueue object to manage the tasks. Callbacks can 
 * attached as certain properties to listen for specific events during the 
 * lifecycle of the cargoQueue and inner queue. 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // create a cargoQueue object with payload 2 and concurrency 2 
 * var cargoQueue = async.cargoQueue(function(tasks, callback) { 
 *     for (var i=0; i&lt;tasks.length; i++) { 
 *         console.log('hello ' + tasks[i].name); 
 *     } 
 *     callback(); 
 * }, 2, 2); 
 * 
 * // add some items 
 * cargoQueue.push({name: 'foo'}, function(err) { 
 *     console.log('finished processing foo'); 
 * }); 
 * cargoQueue.push({name: 'bar'}, function(err) { 
 *     console.log('finished processing bar'); 
 * }); 
 * cargoQueue.push({name: 'baz'}, function(err) { 
 *     console.log('finished processing baz'); 
 * }); 
 * cargoQueue.push({name: 'boo'}, function(err) { 
 *     console.log('finished processing boo'); 
 * }); 
 */</span>
<span class="s1">function </span><span class="s3">cargo$1(</span><span class="s2">worker</span><span class="s3">, </span><span class="s2">concurrency</span><span class="s3">, </span><span class="s2">payload</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">queue</span><span class="s3">(</span><span class="s2">worker</span><span class="s3">, </span><span class="s2">concurrency</span><span class="s3">, </span><span class="s2">payload</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Reduces `coll` into a single value using an async `iteratee` to return each 
 * successive step. `memo` is the initial state of the reduction. This function 
 * only operates in series. 
 * 
 * For performance reasons, it may make sense to split a call to this function 
 * into a parallel map, and then use the normal `Array.prototype.reduce` on the 
 * results. This function is for situations where each step in the reduction 
 * needs to be async; if you can get the data before reducing it, then it's 
 * probably a good idea to do so. 
 * 
 * </span><span class="s1">@name </span><span class="s2">reduce</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">inject</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">foldl</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{*} memo </span><span class="s0">- The initial state of the reduction. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- A function applied to each item in the 
 * array to produce the next step in the reduction. 
 * The `iteratee` should complete with the next state of the reduction. 
 * If the iteratee completes with an error, the reduction is stopped and the 
 * main `callback` is immediately called with the error. 
 * Invoked with (memo, item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after all the 
 * `iteratee` functions have finished. Result is the reduced value. Invoked with 
 * (err, result). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // file1.txt is a file that is 1000 bytes in size 
 * // file2.txt is a file that is 2000 bytes in size 
 * // file3.txt is a file that is 3000 bytes in size 
 * // file4.txt does not exist 
 * 
 * const fileList = ['file1.txt','file2.txt','file3.txt']; 
 * const withMissingFileList = ['file1.txt','file2.txt','file3.txt', 'file4.txt']; 
 * 
 * // asynchronous function that computes the file size in bytes 
 * // file size is added to the memoized value, then returned 
 * function getFileSizeInBytes(memo, file, callback) { 
 *     fs.stat(file, function(err, stat) { 
 *         if (err) { 
 *             return callback(err); 
 *         } 
 *         callback(null, memo + stat.size); 
 *     }); 
 * } 
 * 
 * // Using callbacks 
 * async.reduce(fileList, 0, getFileSizeInBytes, function(err, result) { 
 *     if (err) { 
 *         console.log(err); 
 *     } else { 
 *         console.log(result); 
 *         // 6000 
 *         // which is the sum of the file sizes of the three files 
 *     } 
 * }); 
 * 
 * // Error Handling 
 * async.reduce(withMissingFileList, 0, getFileSizeInBytes, function(err, result) { 
 *     if (err) { 
 *         console.log(err); 
 *         // [ Error: ENOENT: no such file or directory ] 
 *     } else { 
 *         console.log(result); 
 *     } 
 * }); 
 * 
 * // Using Promises 
 * async.reduce(fileList, 0, getFileSizeInBytes) 
 * .then( result =&gt; { 
 *     console.log(result); 
 *     // 6000 
 *     // which is the sum of the file sizes of the three files 
 * }).catch( err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * // Error Handling 
 * async.reduce(withMissingFileList, 0, getFileSizeInBytes) 
 * .then( result =&gt; { 
 *     console.log(result); 
 * }).catch( err =&gt; { 
 *     console.log(err); 
 *     // [ Error: ENOENT: no such file or directory ] 
 * }); 
 * 
 * // Using async/await 
 * async () =&gt; { 
 *     try { 
 *         let result = await async.reduce(fileList, 0, getFileSizeInBytes); 
 *         console.log(result); 
 *         // 6000 
 *         // which is the sum of the file sizes of the three files 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 * // Error Handling 
 * async () =&gt; { 
 *     try { 
 *         let result = await async.reduce(withMissingFileList, 0, getFileSizeInBytes); 
 *         console.log(result); 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *         // [ Error: ENOENT: no such file or directory ] 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">reduce(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">memo</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s2">callback </span><span class="s1">= </span><span class="s4">once</span><span class="s3">(</span><span class="s2">callback</span><span class="s3">);</span>
    <span class="s1">var </span><span class="s3">_iteratee </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">iteratee</span><span class="s3">);</span>
    <span class="s1">return </span><span class="s4">eachOfSeries$1</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">, (</span><span class="s2">x</span><span class="s3">, </span><span class="s2">i</span><span class="s3">, </span><span class="s2">iterCb</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s4">_iteratee</span><span class="s3">(</span><span class="s2">memo</span><span class="s3">, </span><span class="s2">x</span><span class="s3">, (</span><span class="s2">err</span><span class="s3">, </span><span class="s2">v</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s2">memo </span><span class="s1">= </span><span class="s2">v</span><span class="s3">;</span>
            <span class="s4">iterCb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
        <span class="s3">});</span>
    <span class="s3">}, </span><span class="s2">err </span><span class="s1">=&gt; </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s2">memo</span><span class="s3">));</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">reduce$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">reduce</span><span class="s3">, </span><span class="s6">4</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* Version of the compose function that is more natural to read. Each function 
 * consumes the return value of the previous function. It is the equivalent of 
 * </span><span class="s7">[compose]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.compose} </span><span class="s0">with the arguments reversed. 
 * 
 * Each function is executed with the `this` binding of the composed function. 
 * 
 * </span><span class="s1">@name </span><span class="s2">seq</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.compose]{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.compose}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{...AsyncFunction} functions </span><span class="s0">- the asynchronous functions to compose 
 * </span><span class="s1">@returns </span><span class="s2">{Function} </span><span class="s0">a function that composes the `functions` in order 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // Requires lodash (or underscore), express3 and dresende's orm2. 
 * // Part of an app, that fetches cats of the logged user. 
 * // This example uses `seq` function to avoid overnesting and error 
 * // handling clutter. 
 * app.get('/cats', function(request, response) { 
 *     var User = request.models.User; 
 *     async.seq( 
 *         User.get.bind(User),  // 'User.get' has signature (id, callback(err, data)) 
 *         function(user, fn) { 
 *             user.getCats(fn);      // 'getCats' has signature (callback(err, data)) 
 *         } 
 *     )(req.session.user_id, function (err, cats) { 
 *         if (err) { 
 *             console.error(err); 
 *             response.json({ status: 'error', message: err.message }); 
 *         } else { 
 *             response.json({ status: 'ok', message: 'Cats found', data: cats }); 
 *         } 
 *     }); 
 * }); 
 */</span>
<span class="s1">function </span><span class="s3">seq(</span><span class="s1">...</span><span class="s2">functions</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">_functions </span><span class="s1">= </span><span class="s2">functions</span><span class="s3">.</span><span class="s4">map</span><span class="s3">(</span><span class="s2">wrapAsync</span><span class="s3">);</span>
    <span class="s1">return function </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">) {</span>
        <span class="s1">var </span><span class="s3">that </span><span class="s1">= </span><span class="s2">this</span><span class="s3">;</span>

        <span class="s1">var </span><span class="s3">cb </span><span class="s1">= </span><span class="s2">args</span><span class="s3">[</span><span class="s2">args</span><span class="s3">.length </span><span class="s1">- </span><span class="s6">1</span><span class="s3">];</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s1">typeof </span><span class="s2">cb </span><span class="s1">== </span><span class="s5">'function'</span><span class="s3">) {</span>
            <span class="s2">args</span><span class="s3">.</span><span class="s4">pop</span><span class="s3">();</span>
        <span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
            <span class="s2">cb </span><span class="s1">= </span><span class="s4">promiseCallback</span><span class="s3">();</span>
        <span class="s3">}</span>

        <span class="s4">reduce$1</span><span class="s3">(</span><span class="s2">_functions</span><span class="s3">, </span><span class="s2">args</span><span class="s3">, (</span><span class="s2">newargs</span><span class="s3">, </span><span class="s2">fn</span><span class="s3">, </span><span class="s2">iterCb</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s2">fn</span><span class="s3">.</span><span class="s4">apply</span><span class="s3">(</span><span class="s2">that</span><span class="s3">, </span><span class="s2">newargs</span><span class="s3">.</span><span class="s4">concat</span><span class="s3">((</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">nextargs</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
                <span class="s4">iterCb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s2">nextargs</span><span class="s3">);</span>
            <span class="s3">}));</span>
        <span class="s3">},</span>
        <span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s2">results</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s4">cb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">results</span><span class="s3">));</span>

        <span class="s1">return </span><span class="s2">cb</span><span class="s3">[</span><span class="s2">PROMISE_SYMBOL</span><span class="s3">]</span>
    <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a function which is a composition of the passed asynchronous 
 * functions. Each function consumes the return value of the function that 
 * follows. Composing functions `f()`, `g()`, and `h()` would produce the result 
 * of `f(g(h()))`, only this version uses callbacks to obtain the return values. 
 * 
 * If the last argument to the composed function is not a function, a promise 
 * is returned when you call it. 
 * 
 * Each function is executed with the `this` binding of the composed function. 
 * 
 * </span><span class="s1">@name </span><span class="s2">compose</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{...AsyncFunction} functions </span><span class="s0">- the asynchronous functions to compose 
 * </span><span class="s1">@returns </span><span class="s2">{Function} </span><span class="s0">an asynchronous function that is the composed 
 * asynchronous `functions` 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * function add1(n, callback) { 
 *     setTimeout(function () { 
 *         callback(null, n + 1); 
 *     }, 10); 
 * } 
 * 
 * function mul3(n, callback) { 
 *     setTimeout(function () { 
 *         callback(null, n * 3); 
 *     }, 10); 
 * } 
 * 
 * var add1mul3 = async.compose(mul3, add1); 
 * add1mul3(4, function (err, result) { 
 *     // result now equals 15 
 * }); 
 */</span>
<span class="s1">function </span><span class="s3">compose(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">seq</span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">.</span><span class="s4">reverse</span><span class="s3">());</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`map`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.map} </span><span class="s0">but runs a maximum of `limit` async operations at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">mapLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.map]{</span><span class="s1">@link </span><span class="s2">module:Collections.map}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{number} limit </span><span class="s0">- The maximum number of async operations at a time. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async function to apply to each item in 
 * `coll`. 
 * The iteratee should complete with the transformed item. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called when all `iteratee` 
 * functions have finished, or an error occurs. Results is an array of the 
 * transformed items from the `coll`. Invoked with (err, results). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 */</span>
<span class="s1">function </span><span class="s3">mapLimit (</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">_asyncMap</span><span class="s3">(</span><span class="s4">eachOfLimit</span><span class="s3">(</span><span class="s2">limit</span><span class="s3">), </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">mapLimit$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">mapLimit</span><span class="s3">, </span><span class="s6">4</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`concat`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.concat} </span><span class="s0">but runs a maximum of `limit` async operations at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">concatLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.concat]{</span><span class="s1">@link </span><span class="s2">module:Collections.concat}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@alias </span><span class="s2">flatMapLimit</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{number} limit </span><span class="s0">- The maximum number of async operations at a time. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- A function to apply to each item in `coll`, 
 * which should use an array as its result. Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after all the 
 * `iteratee` functions have finished, or an error occurs. Results is an array 
 * containing the concatenated results of the `iteratee` function. Invoked with 
 * (err, results). 
 * </span><span class="s1">@returns </span><span class="s0">A Promise, if no callback is passed 
 */</span>
<span class="s1">function </span><span class="s3">concatLimit(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">_iteratee </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">iteratee</span><span class="s3">);</span>
    <span class="s1">return </span><span class="s4">mapLimit$1</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, (</span><span class="s2">val</span><span class="s3">, </span><span class="s2">iterCb</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s4">_iteratee</span><span class="s3">(</span><span class="s2">val</span><span class="s3">, (</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">iterCb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
            <span class="s1">return </span><span class="s4">iterCb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s2">args</span><span class="s3">);</span>
        <span class="s3">});</span>
    <span class="s3">}, (</span><span class="s2">err</span><span class="s3">, </span><span class="s2">mapResults</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s1">var </span><span class="s3">result </span><span class="s1">= </span><span class="s3">[];</span>
        <span class="s1">for </span><span class="s3">(</span><span class="s1">var </span><span class="s3">i </span><span class="s1">= </span><span class="s6">0</span><span class="s3">; </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">mapResults</span><span class="s3">.length; </span><span class="s2">i</span><span class="s1">++</span><span class="s3">) {</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">mapResults</span><span class="s3">[</span><span class="s2">i</span><span class="s3">]) {</span>
                <span class="s2">result </span><span class="s1">= </span><span class="s2">result</span><span class="s3">.</span><span class="s4">concat</span><span class="s3">(</span><span class="s1">...</span><span class="s2">mapResults</span><span class="s3">[</span><span class="s2">i</span><span class="s3">]);</span>
            <span class="s3">}</span>
        <span class="s3">}</span>

        <span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s2">result</span><span class="s3">);</span>
    <span class="s3">});</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">concatLimit$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">concatLimit</span><span class="s3">, </span><span class="s6">4</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* Applies `iteratee` to each item in `coll`, concatenating the results. Returns 
 * the concatenated list. The `iteratee`s are called in parallel, and the 
 * results are concatenated as they return. The results array will be returned in 
 * the original order of `coll` passed to the `iteratee` function. 
 * 
 * </span><span class="s1">@name </span><span class="s2">concat</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@alias </span><span class="s2">flatMap</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- A function to apply to each item in `coll`, 
 * which should use an array as its result. Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after all the 
 * `iteratee` functions have finished, or an error occurs. Results is an array 
 * containing the concatenated results of the `iteratee` function. Invoked with 
 * (err, results). 
 * </span><span class="s1">@returns </span><span class="s0">A Promise, if no callback is passed 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // dir1 is a directory that contains file1.txt, file2.txt 
 * // dir2 is a directory that contains file3.txt, file4.txt 
 * // dir3 is a directory that contains file5.txt 
 * // dir4 does not exist 
 * 
 * let directoryList = ['dir1','dir2','dir3']; 
 * let withMissingDirectoryList = ['dir1','dir2','dir3', 'dir4']; 
 * 
 * // Using callbacks 
 * async.concat(directoryList, fs.readdir, function(err, results) { 
 *    if (err) { 
 *        console.log(err); 
 *    } else { 
 *        console.log(results); 
 *        // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ] 
 *    } 
 * }); 
 * 
 * // Error Handling 
 * async.concat(withMissingDirectoryList, fs.readdir, function(err, results) { 
 *    if (err) { 
 *        console.log(err); 
 *        // [ Error: ENOENT: no such file or directory ] 
 *        // since dir4 does not exist 
 *    } else { 
 *        console.log(results); 
 *    } 
 * }); 
 * 
 * // Using Promises 
 * async.concat(directoryList, fs.readdir) 
 * .then(results =&gt; { 
 *     console.log(results); 
 *     // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ] 
 * }).catch(err =&gt; { 
 *      console.log(err); 
 * }); 
 * 
 * // Error Handling 
 * async.concat(withMissingDirectoryList, fs.readdir) 
 * .then(results =&gt; { 
 *     console.log(results); 
 * }).catch(err =&gt; { 
 *     console.log(err); 
 *     // [ Error: ENOENT: no such file or directory ] 
 *     // since dir4 does not exist 
 * }); 
 * 
 * // Using async/await 
 * async () =&gt; { 
 *     try { 
 *         let results = await async.concat(directoryList, fs.readdir); 
 *         console.log(results); 
 *         // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ] 
 *     } catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 * // Error Handling 
 * async () =&gt; { 
 *     try { 
 *         let results = await async.concat(withMissingDirectoryList, fs.readdir); 
 *         console.log(results); 
 *     } catch (err) { 
 *         console.log(err); 
 *         // [ Error: ENOENT: no such file or directory ] 
 *         // since dir4 does not exist 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">concat(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">concatLimit$1</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">, </span><span class="s7">Infinity</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">concat$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">concat</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`concat`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.concat} </span><span class="s0">but runs only a single async operation at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">concatSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.concat]{</span><span class="s1">@link </span><span class="s2">module:Collections.concat}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@alias </span><span class="s2">flatMapSeries</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- A function to apply to each item in `coll`. 
 * The iteratee should complete with an array an array of results. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after all the 
 * `iteratee` functions have finished, or an error occurs. Results is an array 
 * containing the concatenated results of the `iteratee` function. Invoked with 
 * (err, results). 
 * </span><span class="s1">@returns </span><span class="s0">A Promise, if no callback is passed 
 */</span>
<span class="s1">function </span><span class="s3">concatSeries(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">concatLimit$1</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">concatSeries$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">concatSeries</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a function that when called, calls-back with the values provided. 
 * Useful as the first function in a </span><span class="s7">[`waterfall`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.waterfall}</span><span class="s0">, or for plugging values in to 
 * </span><span class="s7">[`auto`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.auto}</span><span class="s0">. 
 * 
 * </span><span class="s1">@name </span><span class="s2">constant</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util 
 * </span><span class="s1">@param </span><span class="s2">{...*} arguments... </span><span class="s0">- Any number of arguments to automatically invoke 
 * callback with. 
 * </span><span class="s1">@returns </span><span class="s2">{AsyncFunction} </span><span class="s0">Returns a function that when invoked, automatically 
 * invokes the callback with the previous given arguments. 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * async.waterfall([ 
 *     async.constant(42), 
 *     function (value, next) { 
 *         // value === 42 
 *     }, 
 *     //... 
 * ], callback); 
 * 
 * async.waterfall([ 
 *     async.constant(filename, &quot;utf8&quot;), 
 *     fs.readFile, 
 *     function (fileData, next) { 
 *         //... 
 *     } 
 *     //... 
 * ], callback); 
 * 
 * async.auto({ 
 *     hostname: async.constant(&quot;https://server.net/&quot;), 
 *     port: findFreePort, 
 *     launchServer: [&quot;hostname&quot;, &quot;port&quot;, function (options, cb) { 
 *         startServer(options, cb); 
 *     }], 
 *     //... 
 * }, callback); 
 */</span>
<span class="s1">function </span><span class="s3">constant(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">) {</span>
    <span class="s1">return function </span><span class="s3">(</span><span class="s1">...</span><span class="s2">ignoredArgs</span><span class="s0">/*, callback*/</span><span class="s3">) {</span>
        <span class="s1">var </span><span class="s3">callback </span><span class="s1">= </span><span class="s2">ignoredArgs</span><span class="s3">.</span><span class="s4">pop</span><span class="s3">();</span>
        <span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s3">);</span>
    <span class="s3">};</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">_createTester(</span><span class="s2">check</span><span class="s3">, </span><span class="s2">getResult</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s3">(</span><span class="s2">eachfn</span><span class="s3">, </span><span class="s2">arr</span><span class="s3">, </span><span class="s2">_iteratee</span><span class="s3">, </span><span class="s2">cb</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s1">var </span><span class="s3">testPassed </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
        <span class="s1">var </span><span class="s3">testResult;</span>
        <span class="s1">const </span><span class="s3">iteratee </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">_iteratee</span><span class="s3">);</span>
        <span class="s4">eachfn</span><span class="s3">(</span><span class="s2">arr</span><span class="s3">, (</span><span class="s2">value</span><span class="s3">, </span><span class="s2">_</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s4">iteratee</span><span class="s3">(</span><span class="s2">value</span><span class="s3">, (</span><span class="s2">err</span><span class="s3">, </span><span class="s2">result</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
                <span class="s1">if </span><span class="s3">(</span><span class="s2">err </span><span class="s1">|| </span><span class="s2">err </span><span class="s1">=== </span><span class="s7">false</span><span class="s3">) </span><span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>

                <span class="s1">if </span><span class="s3">(</span><span class="s4">check</span><span class="s3">(</span><span class="s2">result</span><span class="s3">) </span><span class="s1">&amp;&amp; !</span><span class="s2">testResult</span><span class="s3">) {</span>
                    <span class="s2">testPassed </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
                    <span class="s2">testResult </span><span class="s1">= </span><span class="s4">getResult</span><span class="s3">(</span><span class="s7">true</span><span class="s3">, </span><span class="s2">value</span><span class="s3">);</span>
                    <span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">, </span><span class="s2">breakLoop</span><span class="s3">);</span>
                <span class="s3">}</span>
                <span class="s4">callback</span><span class="s3">();</span>
            <span class="s3">});</span>
        <span class="s3">}, </span><span class="s2">err </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">cb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
            <span class="s4">cb</span><span class="s3">(</span><span class="s7">null</span><span class="s3">, </span><span class="s2">testPassed </span><span class="s1">? </span><span class="s2">testResult </span><span class="s1">: </span><span class="s4">getResult</span><span class="s3">(</span><span class="s7">false</span><span class="s3">));</span>
        <span class="s3">});</span>
    <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the first value in `coll` that passes an async truth test. The 
 * `iteratee` is applied in parallel, meaning the first iteratee to return 
 * `true` will fire the detect `callback` with that result. That means the 
 * result might not be the first item in the original `coll` (in terms of order) 
 * that passes the test. 
</span>
 <span class="s0">* If order within the original `coll` is important, then look at 
 * </span><span class="s7">[`detectSeries`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.detectSeries}</span><span class="s0">. 
 * 
 * </span><span class="s1">@name </span><span class="s2">detect</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">find</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collections 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- A truth test to apply to each item in `coll`. 
 * The iteratee must complete with a boolean value as its result. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called as soon as any 
 * iteratee returns `true`, or after all the `iteratee` functions have finished. 
 * Result will be the first item in the array that passes the truth test 
 * (iteratee) or the value `undefined` if none passed. Invoked with 
 * (err, result). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if a callback is omitted 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // dir1 is a directory that contains file1.txt, file2.txt 
 * // dir2 is a directory that contains file3.txt, file4.txt 
 * // dir3 is a directory that contains file5.txt 
 * 
 * // asynchronous function that checks if a file exists 
 * function fileExists(file, callback) { 
 *    fs.access(file, fs.constants.F_OK, (err) =&gt; { 
 *        callback(null, !err); 
 *    }); 
 * } 
 * 
 * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists, 
 *    function(err, result) { 
 *        console.log(result); 
 *        // dir1/file1.txt 
 *        // result now equals the first file in the list that exists 
 *    } 
 *); 
 * 
 * // Using Promises 
 * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists) 
 * .then(result =&gt; { 
 *     console.log(result); 
 *     // dir1/file1.txt 
 *     // result now equals the first file in the list that exists 
 * }).catch(err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * // Using async/await 
 * async () =&gt; { 
 *     try { 
 *         let result = await async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists); 
 *         console.log(result); 
 *         // dir1/file1.txt 
 *         // result now equals the file in the list that exists 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">detect(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">_createTester</span><span class="s3">(</span><span class="s2">bool </span><span class="s1">=&gt; </span><span class="s2">bool</span><span class="s3">, (</span><span class="s2">res</span><span class="s3">, </span><span class="s2">item</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">item</span><span class="s3">)(</span><span class="s2">eachOf$1</span><span class="s3">, </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">detect$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">detect</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`detect`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.detect} </span><span class="s0">but runs a maximum of `limit` async operations at a 
 * time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">detectLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.detect]{</span><span class="s1">@link </span><span class="s2">module:Collections.detect}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">findLimit</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collections 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{number} limit </span><span class="s0">- The maximum number of async operations at a time. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- A truth test to apply to each item in `coll`. 
 * The iteratee must complete with a boolean value as its result. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called as soon as any 
 * iteratee returns `true`, or after all the `iteratee` functions have finished. 
 * Result will be the first item in the array that passes the truth test 
 * (iteratee) or the value `undefined` if none passed. Invoked with 
 * (err, result). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if a callback is omitted 
 */</span>
<span class="s1">function </span><span class="s3">detectLimit(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">_createTester</span><span class="s3">(</span><span class="s2">bool </span><span class="s1">=&gt; </span><span class="s2">bool</span><span class="s3">, (</span><span class="s2">res</span><span class="s3">, </span><span class="s2">item</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">item</span><span class="s3">)(</span><span class="s4">eachOfLimit</span><span class="s3">(</span><span class="s2">limit</span><span class="s3">), </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">detectLimit$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">detectLimit</span><span class="s3">, </span><span class="s6">4</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`detect`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.detect} </span><span class="s0">but runs only a single async operation at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">detectSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.detect]{</span><span class="s1">@link </span><span class="s2">module:Collections.detect}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">findSeries</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collections 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- A truth test to apply to each item in `coll`. 
 * The iteratee must complete with a boolean value as its result. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called as soon as any 
 * iteratee returns `true`, or after all the `iteratee` functions have finished. 
 * Result will be the first item in the array that passes the truth test 
 * (iteratee) or the value `undefined` if none passed. Invoked with 
 * (err, result). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if a callback is omitted 
 */</span>
<span class="s1">function </span><span class="s3">detectSeries(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">_createTester</span><span class="s3">(</span><span class="s2">bool </span><span class="s1">=&gt; </span><span class="s2">bool</span><span class="s3">, (</span><span class="s2">res</span><span class="s3">, </span><span class="s2">item</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">item</span><span class="s3">)(</span><span class="s4">eachOfLimit</span><span class="s3">(</span><span class="s6">1</span><span class="s3">), </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s1">var </span><span class="s3">detectSeries$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">detectSeries</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s1">function </span><span class="s3">consoleFunc(</span><span class="s2">name</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s3">(</span><span class="s2">fn</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">fn</span><span class="s3">)(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">, (</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">resultArgs</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s0">/* istanbul ignore else */</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s1">typeof </span><span class="s2">console </span><span class="s1">=== </span><span class="s5">'object'</span><span class="s3">) {</span>
            <span class="s0">/* istanbul ignore else */</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) {</span>
                <span class="s0">/* istanbul ignore else */</span>
                <span class="s1">if </span><span class="s3">(</span><span class="s2">console</span><span class="s3">.</span><span class="s2">error</span><span class="s3">) {</span>
                    <span class="s2">console</span><span class="s3">.</span><span class="s4">error</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
                <span class="s3">}</span>
            <span class="s3">} </span><span class="s1">else if </span><span class="s3">(</span><span class="s2">console</span><span class="s3">[</span><span class="s2">name</span><span class="s3">]) { </span><span class="s0">/* istanbul ignore else */</span>
                <span class="s2">resultArgs</span><span class="s3">.</span><span class="s4">forEach</span><span class="s3">(</span><span class="s2">x </span><span class="s1">=&gt; </span><span class="s2">console</span><span class="s3">[</span><span class="s2">name</span><span class="s3">](</span><span class="s2">x</span><span class="s3">));</span>
            <span class="s3">}</span>
        <span class="s3">}</span>
    <span class="s3">})</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Logs the result of an </span><span class="s7">[`async` function]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">AsyncFunction} </span><span class="s0">to the 
 * `console` using `console.dir` to display the properties of the resulting object. 
 * Only works in Node.js or in browsers that support `console.dir` and 
 * `console.error` (such as FF and Chrome). 
 * If multiple arguments are returned from the async function, 
 * `console.dir` is called on each argument in order. 
 * 
 * </span><span class="s1">@name </span><span class="s2">dir</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} function </span><span class="s0">- The function you want to eventually apply 
 * all arguments to. 
 * </span><span class="s1">@param </span><span class="s2">{...*} arguments... </span><span class="s0">- Any number of arguments to apply to the function. 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // in a module 
 * var hello = function(name, callback) { 
 *     setTimeout(function() { 
 *         callback(null, {hello: name}); 
 *     }, 1000); 
 * }; 
 * 
 * // in the node repl 
 * node&gt; async.dir(hello, 'world'); 
 * {hello: 'world'} 
 */</span>
<span class="s1">var </span><span class="s3">dir </span><span class="s1">= </span><span class="s4">consoleFunc</span><span class="s3">(</span><span class="s5">'dir'</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The post-check version of </span><span class="s7">[`whilst`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.whilst}</span><span class="s0">. To reflect the difference in 
 * the order of operations, the arguments `test` and `iteratee` are switched. 
 * 
 * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript. 
 * 
 * </span><span class="s1">@name </span><span class="s2">doWhilst</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.whilst]{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.whilst}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- A function which is called each time `test` 
 * passes. Invoked with (callback). 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} test </span><span class="s0">- asynchronous truth test to perform after each 
 * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the 
 * non-error args from the previous callback of `iteratee`. 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after the test 
 * function has failed and repeated execution of `iteratee` has stopped. 
 * `callback` will be passed an error and any arguments passed to the final 
 * `iteratee`'s callback. Invoked with (err, [results]); 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 */</span>
<span class="s1">function </span><span class="s3">doWhilst(</span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">test</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s2">callback </span><span class="s1">= </span><span class="s4">onlyOnce</span><span class="s3">(</span><span class="s2">callback</span><span class="s3">);</span>
    <span class="s1">var </span><span class="s3">_fn </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">iteratee</span><span class="s3">);</span>
    <span class="s1">var </span><span class="s3">_test </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">test</span><span class="s3">);</span>
    <span class="s1">var </span><span class="s3">results;</span>

    <span class="s1">function </span><span class="s3">next(</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err </span><span class="s1">=== </span><span class="s7">false</span><span class="s3">) </span><span class="s1">return</span><span class="s3">;</span>
        <span class="s2">results </span><span class="s1">= </span><span class="s2">args</span><span class="s3">;</span>
        <span class="s4">_test</span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">, </span><span class="s2">check</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s1">function </span><span class="s3">check(</span><span class="s2">err</span><span class="s3">, </span><span class="s2">truth</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err </span><span class="s1">=== </span><span class="s7">false</span><span class="s3">) </span><span class="s1">return</span><span class="s3">;</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">truth</span><span class="s3">) </span><span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">, </span><span class="s1">...</span><span class="s2">results</span><span class="s3">);</span>
        <span class="s4">_fn</span><span class="s3">(</span><span class="s2">next</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s1">return </span><span class="s4">check</span><span class="s3">(</span><span class="s7">null</span><span class="s3">, </span><span class="s7">true</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s1">var </span><span class="s3">doWhilst$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">doWhilst</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* Like </span><span class="s7">['doWhilst']</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.doWhilst}</span><span class="s0">, except the `test` is inverted. Note the 
 * argument ordering differs from `until`. 
 * 
 * </span><span class="s1">@name </span><span class="s2">doUntil</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.doWhilst]{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.doWhilst}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async function which is called each time 
 * `test` fails. Invoked with (callback). 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} test </span><span class="s0">- asynchronous truth test to perform after each 
 * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the 
 * non-error args from the previous callback of `iteratee` 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after the test 
 * function has passed and repeated execution of `iteratee` has stopped. `callback` 
 * will be passed an error and any arguments passed to the final `iteratee`'s 
 * callback. Invoked with (err, [results]); 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 */</span>
<span class="s1">function </span><span class="s3">doUntil(</span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">test</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">const </span><span class="s3">_test </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">test</span><span class="s3">);</span>
    <span class="s1">return </span><span class="s4">doWhilst$1</span><span class="s3">(</span><span class="s2">iteratee</span><span class="s3">, (</span><span class="s1">...</span><span class="s2">args</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s1">const </span><span class="s3">cb </span><span class="s1">= </span><span class="s2">args</span><span class="s3">.</span><span class="s4">pop</span><span class="s3">();</span>
        <span class="s4">_test</span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">, (</span><span class="s2">err</span><span class="s3">, </span><span class="s2">truth</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s4">cb </span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s1">!</span><span class="s2">truth</span><span class="s3">));</span>
    <span class="s3">}, </span><span class="s2">callback</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">_withoutIndex(</span><span class="s2">iteratee</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s3">(</span><span class="s2">value</span><span class="s3">, </span><span class="s2">index</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s4">iteratee</span><span class="s3">(</span><span class="s2">value</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Applies the function `iteratee` to each item in `coll`, in parallel. 
 * The `iteratee` is called with an item from the list, and a callback for when 
 * it has finished. If the `iteratee` passes an error to its `callback`, the 
 * main `callback` (for the `each` function) is immediately called with the 
 * error. 
 * 
 * Note, that since this function applies `iteratee` to each item in parallel, 
 * there is no guarantee that the iteratee functions will complete in order. 
 * 
 * </span><span class="s1">@name </span><span class="s2">each</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">forEach</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async function to apply to 
 * each item in `coll`. Invoked with (item, callback). 
 * The array index is not passed to the iteratee. 
 * If you need the index, use `eachOf`. 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called when all 
 * `iteratee` functions have finished, or an error occurs. Invoked with (err). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if a callback is omitted 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // dir1 is a directory that contains file1.txt, file2.txt 
 * // dir2 is a directory that contains file3.txt, file4.txt 
 * // dir3 is a directory that contains file5.txt 
 * // dir4 does not exist 
 * 
 * const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt']; 
 * const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt']; 
 * 
 * // asynchronous function that deletes a file 
 * const deleteFile = function(file, callback) { 
 *     fs.unlink(file, callback); 
 * }; 
 * 
 * // Using callbacks 
 * async.each(fileList, deleteFile, function(err) { 
 *     if( err ) { 
 *         console.log(err); 
 *     } else { 
 *         console.log('All files have been deleted successfully'); 
 *     } 
 * }); 
 * 
 * // Error Handling 
 * async.each(withMissingFileList, deleteFile, function(err){ 
 *     console.log(err); 
 *     // [ Error: ENOENT: no such file or directory ] 
 *     // since dir4/file2.txt does not exist 
 *     // dir1/file1.txt could have been deleted 
 * }); 
 * 
 * // Using Promises 
 * async.each(fileList, deleteFile) 
 * .then( () =&gt; { 
 *     console.log('All files have been deleted successfully'); 
 * }).catch( err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * // Error Handling 
 * async.each(fileList, deleteFile) 
 * .then( () =&gt; { 
 *     console.log('All files have been deleted successfully'); 
 * }).catch( err =&gt; { 
 *     console.log(err); 
 *     // [ Error: ENOENT: no such file or directory ] 
 *     // since dir4/file2.txt does not exist 
 *     // dir1/file1.txt could have been deleted 
 * }); 
 * 
 * // Using async/await 
 * async () =&gt; { 
 *     try { 
 *         await async.each(files, deleteFile); 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 * // Error Handling 
 * async () =&gt; { 
 *     try { 
 *         await async.each(withMissingFileList, deleteFile); 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *         // [ Error: ENOENT: no such file or directory ] 
 *         // since dir4/file2.txt does not exist 
 *         // dir1/file1.txt could have been deleted 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">eachLimit(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">eachOf$1</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">, </span><span class="s4">_withoutIndex</span><span class="s3">(</span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">iteratee</span><span class="s3">)), </span><span class="s2">callback</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s1">var </span><span class="s3">each </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">eachLimit</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`each`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.each} </span><span class="s0">but runs a maximum of `limit` async operations at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">eachLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.each]{</span><span class="s1">@link </span><span class="s2">module:Collections.each}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">forEachLimit</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{number} limit </span><span class="s0">- The maximum number of async operations at a time. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async function to apply to each item in 
 * `coll`. 
 * The array index is not passed to the iteratee. 
 * If you need the index, use `eachOfLimit`. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called when all 
 * `iteratee` functions have finished, or an error occurs. Invoked with (err). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if a callback is omitted 
 */</span>
<span class="s1">function </span><span class="s3">eachLimit$1(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">eachOfLimit</span><span class="s3">(</span><span class="s2">limit</span><span class="s3">)(</span><span class="s2">coll</span><span class="s3">, </span><span class="s4">_withoutIndex</span><span class="s3">(</span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">iteratee</span><span class="s3">)), </span><span class="s2">callback</span><span class="s3">);</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">eachLimit$2 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">eachLimit$1</span><span class="s3">, </span><span class="s6">4</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`each`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.each} </span><span class="s0">but runs only a single async operation at a time. 
 * 
 * Note, that unlike </span><span class="s7">[`each`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.each}</span><span class="s0">, this function applies iteratee to each item 
 * in series and therefore the iteratee functions will complete in order. 
</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s2">eachSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.each]{</span><span class="s1">@link </span><span class="s2">module:Collections.each}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">forEachSeries</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async function to apply to each 
 * item in `coll`. 
 * The array index is not passed to the iteratee. 
 * If you need the index, use `eachOfSeries`. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called when all 
 * `iteratee` functions have finished, or an error occurs. Invoked with (err). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if a callback is omitted 
 */</span>
<span class="s1">function </span><span class="s3">eachSeries(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">eachLimit$2</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">eachSeries$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">eachSeries</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* Wrap an async function and ensure it calls its callback on a later tick of 
 * the event loop.  If the function already calls its callback on a next tick, 
 * no extra deferral is added. This is useful for preventing stack overflows 
 * (`RangeError: Maximum call stack size exceeded`) and generally keeping 
 * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony) 
 * contained. ES2017 `async` functions are returned as-is -- they are immune 
 * to Zalgo's corrupting influences, as they always resolve on a later tick. 
 * 
 * </span><span class="s1">@name </span><span class="s2">ensureAsync</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} fn </span><span class="s0">- an async function, one that expects a node-style 
 * callback as its last argument. 
 * </span><span class="s1">@returns </span><span class="s2">{AsyncFunction} </span><span class="s0">Returns a wrapped function with the exact same call 
 * signature as the function passed in. 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * function sometimesAsync(arg, callback) { 
 *     if (cache[arg]) { 
 *         return callback(null, cache[arg]); // this would be synchronous!! 
 *     } else { 
 *         doSomeIO(arg, callback); // this IO would be asynchronous 
 *     } 
 * } 
 * 
 * // this has a risk of stack overflows if many results are cached in a row 
 * async.mapSeries(args, sometimesAsync, done); 
 * 
 * // this will defer sometimesAsync's callback if necessary, 
 * // preventing stack overflows 
 * async.mapSeries(args, async.ensureAsync(sometimesAsync), done); 
 */</span>
<span class="s1">function </span><span class="s3">ensureAsync(</span><span class="s2">fn</span><span class="s3">) {</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s4">isAsync</span><span class="s3">(</span><span class="s2">fn</span><span class="s3">)) </span><span class="s1">return </span><span class="s2">fn</span><span class="s3">;</span>
    <span class="s1">return function </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s0">/*, callback*/</span><span class="s3">) {</span>
        <span class="s1">var </span><span class="s3">callback </span><span class="s1">= </span><span class="s2">args</span><span class="s3">.</span><span class="s4">pop</span><span class="s3">();</span>
        <span class="s1">var </span><span class="s3">sync </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
        <span class="s2">args</span><span class="s3">.</span><span class="s4">push</span><span class="s3">((</span><span class="s1">...</span><span class="s2">innerArgs</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">sync</span><span class="s3">) {</span>
                <span class="s4">setImmediate$1</span><span class="s3">(() </span><span class="s1">=&gt; </span><span class="s4">callback</span><span class="s3">(</span><span class="s1">...</span><span class="s2">innerArgs</span><span class="s3">));</span>
            <span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
                <span class="s4">callback</span><span class="s3">(</span><span class="s1">...</span><span class="s2">innerArgs</span><span class="s3">);</span>
            <span class="s3">}</span>
        <span class="s3">});</span>
        <span class="s2">fn</span><span class="s3">.</span><span class="s4">apply</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s2">args</span><span class="s3">);</span>
        <span class="s2">sync </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
    <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Returns `true` if every element in `coll` satisfies an async test. If any 
 * iteratee call returns `false`, the main `callback` is immediately called. 
 * 
 * </span><span class="s1">@name </span><span class="s2">every</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">all</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async truth test to apply to each item 
 * in the collection in parallel. 
 * The iteratee must complete with a boolean result value. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after all the 
 * `iteratee` functions have finished. Result will be either `true` or `false` 
 * depending on the values of the async tests. Invoked with (err, result). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback provided 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // dir1 is a directory that contains file1.txt, file2.txt 
 * // dir2 is a directory that contains file3.txt, file4.txt 
 * // dir3 is a directory that contains file5.txt 
 * // dir4 does not exist 
 * 
 * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file5.txt']; 
 * const withMissingFileList = ['file1.txt','file2.txt','file4.txt']; 
 * 
 * // asynchronous function that checks if a file exists 
 * function fileExists(file, callback) { 
 *    fs.access(file, fs.constants.F_OK, (err) =&gt; { 
 *        callback(null, !err); 
 *    }); 
 * } 
 * 
 * // Using callbacks 
 * async.every(fileList, fileExists, function(err, result) { 
 *     console.log(result); 
 *     // true 
 *     // result is true since every file exists 
 * }); 
 * 
 * async.every(withMissingFileList, fileExists, function(err, result) { 
 *     console.log(result); 
 *     // false 
 *     // result is false since NOT every file exists 
 * }); 
 * 
 * // Using Promises 
 * async.every(fileList, fileExists) 
 * .then( result =&gt; { 
 *     console.log(result); 
 *     // true 
 *     // result is true since every file exists 
 * }).catch( err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * async.every(withMissingFileList, fileExists) 
 * .then( result =&gt; { 
 *     console.log(result); 
 *     // false 
 *     // result is false since NOT every file exists 
 * }).catch( err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * // Using async/await 
 * async () =&gt; { 
 *     try { 
 *         let result = await async.every(fileList, fileExists); 
 *         console.log(result); 
 *         // true 
 *         // result is true since every file exists 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 * async () =&gt; { 
 *     try { 
 *         let result = await async.every(withMissingFileList, fileExists); 
 *         console.log(result); 
 *         // false 
 *         // result is false since NOT every file exists 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">every(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">_createTester</span><span class="s3">(</span><span class="s2">bool </span><span class="s1">=&gt; !</span><span class="s2">bool</span><span class="s3">, </span><span class="s2">res </span><span class="s1">=&gt; !</span><span class="s2">res</span><span class="s3">)(</span><span class="s2">eachOf$1</span><span class="s3">, </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">every$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">every</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`every`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.every} </span><span class="s0">but runs a maximum of `limit` async operations at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">everyLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.every]{</span><span class="s1">@link </span><span class="s2">module:Collections.every}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">allLimit</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{number} limit </span><span class="s0">- The maximum number of async operations at a time. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async truth test to apply to each item 
 * in the collection in parallel. 
 * The iteratee must complete with a boolean result value. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after all the 
 * `iteratee` functions have finished. Result will be either `true` or `false` 
 * depending on the values of the async tests. Invoked with (err, result). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback provided 
 */</span>
<span class="s1">function </span><span class="s3">everyLimit(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">_createTester</span><span class="s3">(</span><span class="s2">bool </span><span class="s1">=&gt; !</span><span class="s2">bool</span><span class="s3">, </span><span class="s2">res </span><span class="s1">=&gt; !</span><span class="s2">res</span><span class="s3">)(</span><span class="s4">eachOfLimit</span><span class="s3">(</span><span class="s2">limit</span><span class="s3">), </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">everyLimit$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">everyLimit</span><span class="s3">, </span><span class="s6">4</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`every`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.every} </span><span class="s0">but runs only a single async operation at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">everySeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.every]{</span><span class="s1">@link </span><span class="s2">module:Collections.every}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">allSeries</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async truth test to apply to each item 
 * in the collection in series. 
 * The iteratee must complete with a boolean result value. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after all the 
 * `iteratee` functions have finished. Result will be either `true` or `false` 
 * depending on the values of the async tests. Invoked with (err, result). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback provided 
 */</span>
<span class="s1">function </span><span class="s3">everySeries(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">_createTester</span><span class="s3">(</span><span class="s2">bool </span><span class="s1">=&gt; !</span><span class="s2">bool</span><span class="s3">, </span><span class="s2">res </span><span class="s1">=&gt; !</span><span class="s2">res</span><span class="s3">)(</span><span class="s2">eachOfSeries$1</span><span class="s3">, </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">everySeries$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">everySeries</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s1">function </span><span class="s3">filterArray(</span><span class="s2">eachfn</span><span class="s3">, </span><span class="s2">arr</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">truthValues </span><span class="s1">= new </span><span class="s4">Array</span><span class="s3">(</span><span class="s2">arr</span><span class="s3">.length);</span>
    <span class="s4">eachfn</span><span class="s3">(</span><span class="s2">arr</span><span class="s3">, (</span><span class="s2">x</span><span class="s3">, </span><span class="s2">index</span><span class="s3">, </span><span class="s2">iterCb</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s4">iteratee</span><span class="s3">(</span><span class="s2">x</span><span class="s3">, (</span><span class="s2">err</span><span class="s3">, </span><span class="s2">v</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s2">truthValues</span><span class="s3">[</span><span class="s2">index</span><span class="s3">] </span><span class="s1">= !!</span><span class="s2">v</span><span class="s3">;</span>
            <span class="s4">iterCb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
        <span class="s3">});</span>
    <span class="s3">}, </span><span class="s2">err </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
        <span class="s1">var </span><span class="s3">results </span><span class="s1">= </span><span class="s3">[];</span>
        <span class="s1">for </span><span class="s3">(</span><span class="s1">var </span><span class="s3">i </span><span class="s1">= </span><span class="s6">0</span><span class="s3">; </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">arr</span><span class="s3">.length; </span><span class="s2">i</span><span class="s1">++</span><span class="s3">) {</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">truthValues</span><span class="s3">[</span><span class="s2">i</span><span class="s3">]) </span><span class="s2">results</span><span class="s3">.</span><span class="s4">push</span><span class="s3">(</span><span class="s2">arr</span><span class="s3">[</span><span class="s2">i</span><span class="s3">]);</span>
        <span class="s3">}</span>
        <span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">, </span><span class="s2">results</span><span class="s3">);</span>
    <span class="s3">});</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">filterGeneric(</span><span class="s2">eachfn</span><span class="s3">, </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">results </span><span class="s1">= </span><span class="s3">[];</span>
    <span class="s4">eachfn</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">, (</span><span class="s2">x</span><span class="s3">, </span><span class="s2">index</span><span class="s3">, </span><span class="s2">iterCb</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s4">iteratee</span><span class="s3">(</span><span class="s2">x</span><span class="s3">, (</span><span class="s2">err</span><span class="s3">, </span><span class="s2">v</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">iterCb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">v</span><span class="s3">) {</span>
                <span class="s2">results</span><span class="s3">.</span><span class="s4">push</span><span class="s3">({</span><span class="s2">index</span><span class="s3">, value: </span><span class="s2">x</span><span class="s3">});</span>
            <span class="s3">}</span>
            <span class="s4">iterCb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
        <span class="s3">});</span>
    <span class="s3">}, </span><span class="s2">err </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
        <span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">, </span><span class="s2">results</span>
            <span class="s3">.</span><span class="s4">sort</span><span class="s3">((</span><span class="s2">a</span><span class="s3">, </span><span class="s2">b</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">a</span><span class="s3">.</span><span class="s2">index </span><span class="s1">- </span><span class="s2">b</span><span class="s3">.</span><span class="s2">index</span><span class="s3">)</span>
            <span class="s3">.</span><span class="s4">map</span><span class="s3">(</span><span class="s2">v </span><span class="s1">=&gt; </span><span class="s2">v</span><span class="s3">.</span><span class="s2">value</span><span class="s3">));</span>
    <span class="s3">});</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">_filter(</span><span class="s2">eachfn</span><span class="s3">, </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">filter </span><span class="s1">= </span><span class="s4">isArrayLike</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">) </span><span class="s1">? </span><span class="s2">filterArray </span><span class="s1">: </span><span class="s2">filterGeneric</span><span class="s3">;</span>
    <span class="s1">return </span><span class="s4">filter</span><span class="s3">(</span><span class="s2">eachfn</span><span class="s3">, </span><span class="s2">coll</span><span class="s3">, </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">iteratee</span><span class="s3">), </span><span class="s2">callback</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a new array of all the values in `coll` which pass an async truth 
 * test. This operation is performed in parallel, but the results array will be 
 * in the same order as the original. 
 * 
 * </span><span class="s1">@name </span><span class="s2">filter</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">select</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{Function} iteratee </span><span class="s0">- A truth test to apply to each item in `coll`. 
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called 
 * with a boolean argument once it has completed. Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after all the 
 * `iteratee` functions have finished. Invoked with (err, results). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback provided 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // dir1 is a directory that contains file1.txt, file2.txt 
 * // dir2 is a directory that contains file3.txt, file4.txt 
 * // dir3 is a directory that contains file5.txt 
 * 
 * const files = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt']; 
 * 
 * // asynchronous function that checks if a file exists 
 * function fileExists(file, callback) { 
 *    fs.access(file, fs.constants.F_OK, (err) =&gt; { 
 *        callback(null, !err); 
 *    }); 
 * } 
 * 
 * // Using callbacks 
 * async.filter(files, fileExists, function(err, results) { 
 *    if(err) { 
 *        console.log(err); 
 *    } else { 
 *        console.log(results); 
 *        // [ 'dir1/file1.txt', 'dir2/file3.txt' ] 
 *        // results is now an array of the existing files 
 *    } 
 * }); 
 * 
 * // Using Promises 
 * async.filter(files, fileExists) 
 * .then(results =&gt; { 
 *     console.log(results); 
 *     // [ 'dir1/file1.txt', 'dir2/file3.txt' ] 
 *     // results is now an array of the existing files 
 * }).catch(err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * // Using async/await 
 * async () =&gt; { 
 *     try { 
 *         let results = await async.filter(files, fileExists); 
 *         console.log(results); 
 *         // [ 'dir1/file1.txt', 'dir2/file3.txt' ] 
 *         // results is now an array of the existing files 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">filter (</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">_filter</span><span class="s3">(</span><span class="s2">eachOf$1</span><span class="s3">, </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">filter$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">filter</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`filter`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.filter} </span><span class="s0">but runs a maximum of `limit` async operations at a 
 * time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">filterLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.filter]{</span><span class="s1">@link </span><span class="s2">module:Collections.filter}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">selectLimit</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{number} limit </span><span class="s0">- The maximum number of async operations at a time. 
 * </span><span class="s1">@param </span><span class="s2">{Function} iteratee </span><span class="s0">- A truth test to apply to each item in `coll`. 
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called 
 * with a boolean argument once it has completed. Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after all the 
 * `iteratee` functions have finished. Invoked with (err, results). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback provided 
 */</span>
<span class="s1">function </span><span class="s3">filterLimit (</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">_filter</span><span class="s3">(</span><span class="s4">eachOfLimit</span><span class="s3">(</span><span class="s2">limit</span><span class="s3">), </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">filterLimit$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">filterLimit</span><span class="s3">, </span><span class="s6">4</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`filter`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.filter} </span><span class="s0">but runs only a single async operation at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">filterSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.filter]{</span><span class="s1">@link </span><span class="s2">module:Collections.filter}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">selectSeries</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{Function} iteratee </span><span class="s0">- A truth test to apply to each item in `coll`. 
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called 
 * with a boolean argument once it has completed. Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after all the 
 * `iteratee` functions have finished. Invoked with (err, results) 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback provided 
 */</span>
<span class="s1">function </span><span class="s3">filterSeries (</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">_filter</span><span class="s3">(</span><span class="s2">eachOfSeries$1</span><span class="s3">, </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">filterSeries$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">filterSeries</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* Calls the asynchronous function `fn` with a callback parameter that allows it 
 * to call itself again, in series, indefinitely. 
</span>
 <span class="s0">* If an error is passed to the callback then `errback` is called with the 
 * error, and execution stops, otherwise it will never be called. 
 * 
 * </span><span class="s1">@name </span><span class="s2">forever</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} fn </span><span class="s0">- an async function to call repeatedly. 
 * Invoked with (next). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [errback] </span><span class="s0">- when `fn` passes an error to it's callback, 
 * this function will be called, and execution stops. Invoked with (err). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise that rejects if an error occurs and an errback 
 * is not passed 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * async.forever( 
 *     function(next) { 
 *         // next is suitable for passing to things that need a callback(err [, whatever]); 
 *         // it will result in this function being called again. 
 *     }, 
 *     function(err) { 
 *         // if next is called with a value in its first parameter, it will appear 
 *         // in here as 'err', and execution will stop. 
 *     } 
 * ); 
 */</span>
<span class="s1">function </span><span class="s3">forever(</span><span class="s2">fn</span><span class="s3">, </span><span class="s2">errback</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">done </span><span class="s1">= </span><span class="s4">onlyOnce</span><span class="s3">(</span><span class="s2">errback</span><span class="s3">);</span>
    <span class="s1">var </span><span class="s3">task </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s4">ensureAsync</span><span class="s3">(</span><span class="s2">fn</span><span class="s3">));</span>

    <span class="s1">function </span><span class="s3">next(</span><span class="s2">err</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">done</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err </span><span class="s1">=== </span><span class="s7">false</span><span class="s3">) </span><span class="s1">return</span><span class="s3">;</span>
        <span class="s4">task</span><span class="s3">(</span><span class="s2">next</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s1">return </span><span class="s4">next</span><span class="s3">();</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">forever$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">forever</span><span class="s3">, </span><span class="s6">2</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`groupBy`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.groupBy} </span><span class="s0">but runs a maximum of `limit` async operations at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">groupByLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.groupBy]{</span><span class="s1">@link </span><span class="s2">module:Collections.groupBy}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{number} limit </span><span class="s0">- The maximum number of async operations at a time. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async function to apply to each item in 
 * `coll`. 
 * The iteratee should complete with a `key` to group the value under. 
 * Invoked with (value, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called when all `iteratee` 
 * functions have finished, or an error occurs. Result is an `Object` whoses 
 * properties are arrays of values which returned the corresponding key. 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 */</span>
<span class="s1">function </span><span class="s3">groupByLimit(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">_iteratee </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">iteratee</span><span class="s3">);</span>
    <span class="s1">return </span><span class="s4">mapLimit$1</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, (</span><span class="s2">val</span><span class="s3">, </span><span class="s2">iterCb</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s4">_iteratee</span><span class="s3">(</span><span class="s2">val</span><span class="s3">, (</span><span class="s2">err</span><span class="s3">, </span><span class="s2">key</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">iterCb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
            <span class="s1">return </span><span class="s4">iterCb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, {</span><span class="s2">key</span><span class="s3">, </span><span class="s2">val</span><span class="s3">});</span>
        <span class="s3">});</span>
    <span class="s3">}, (</span><span class="s2">err</span><span class="s3">, </span><span class="s2">mapResults</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s1">var </span><span class="s3">result </span><span class="s1">= </span><span class="s3">{};</span>
        <span class="s0">// from MDN, handle object having an `hasOwnProperty` prop</span>
        <span class="s1">var </span><span class="s3">{hasOwnProperty} </span><span class="s1">= </span><span class="s3">Object.prototype;</span>

        <span class="s1">for </span><span class="s3">(</span><span class="s1">var </span><span class="s3">i </span><span class="s1">= </span><span class="s6">0</span><span class="s3">; </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">mapResults</span><span class="s3">.length; </span><span class="s2">i</span><span class="s1">++</span><span class="s3">) {</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">mapResults</span><span class="s3">[</span><span class="s2">i</span><span class="s3">]) {</span>
                <span class="s1">var </span><span class="s3">{key} </span><span class="s1">= </span><span class="s2">mapResults</span><span class="s3">[</span><span class="s2">i</span><span class="s3">];</span>
                <span class="s1">var </span><span class="s3">{val} </span><span class="s1">= </span><span class="s2">mapResults</span><span class="s3">[</span><span class="s2">i</span><span class="s3">];</span>

                <span class="s1">if </span><span class="s3">(</span><span class="s2">hasOwnProperty</span><span class="s3">.</span><span class="s4">call</span><span class="s3">(</span><span class="s2">result</span><span class="s3">, </span><span class="s2">key</span><span class="s3">)) {</span>
                    <span class="s2">result</span><span class="s3">[</span><span class="s2">key</span><span class="s3">].</span><span class="s4">push</span><span class="s3">(</span><span class="s2">val</span><span class="s3">);</span>
                <span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
                    <span class="s2">result</span><span class="s3">[</span><span class="s2">key</span><span class="s3">] </span><span class="s1">= </span><span class="s3">[</span><span class="s2">val</span><span class="s3">];</span>
                <span class="s3">}</span>
            <span class="s3">}</span>
        <span class="s3">}</span>

        <span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s2">result</span><span class="s3">);</span>
    <span class="s3">});</span>
<span class="s3">}</span>

<span class="s1">var </span><span class="s3">groupByLimit$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">groupByLimit</span><span class="s3">, </span><span class="s6">4</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a new object, where each value corresponds to an array of items, from 
 * `coll`, that returned the corresponding key. That is, the keys of the object 
 * correspond to the values passed to the `iteratee` callback. 
 * 
 * Note: Since this function applies the `iteratee` to each item in parallel, 
 * there is no guarantee that the `iteratee` functions will complete in order. 
 * However, the values for each key in the `result` will be in the same order as 
 * the original `coll`. For Objects, the values will roughly be in the order of 
 * the original Objects' keys (but this can vary across JavaScript engines). 
 * 
 * </span><span class="s1">@name </span><span class="s2">groupBy</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async function to apply to each item in 
 * `coll`. 
 * The iteratee should complete with a `key` to group the value under. 
 * Invoked with (value, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called when all `iteratee` 
 * functions have finished, or an error occurs. Result is an `Object` whoses 
 * properties are arrays of values which returned the corresponding key. 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // dir1 is a directory that contains file1.txt, file2.txt 
 * // dir2 is a directory that contains file3.txt, file4.txt 
 * // dir3 is a directory that contains file5.txt 
 * // dir4 does not exist 
 * 
 * const files = ['dir1/file1.txt','dir2','dir4'] 
 * 
 * // asynchronous function that detects file type as none, file, or directory 
 * function detectFile(file, callback) { 
 *     fs.stat(file, function(err, stat) { 
 *         if (err) { 
 *             return callback(null, 'none'); 
 *         } 
 *         callback(null, stat.isDirectory() ? 'directory' : 'file'); 
 *     }); 
 * } 
 * 
 * //Using callbacks 
 * async.groupBy(files, detectFile, function(err, result) { 
 *     if(err) { 
 *         console.log(err); 
 *     } else { 
 *          console.log(result); 
 *         // { 
 *         //     file: [ 'dir1/file1.txt' ], 
 *         //     none: [ 'dir4' ], 
 *         //     directory: [ 'dir2'] 
 *         // } 
 *         // result is object containing the files grouped by type 
 *     } 
 * }); 
 * 
 * // Using Promises 
 * async.groupBy(files, detectFile) 
 * .then( result =&gt; { 
 *     console.log(result); 
 *     // { 
 *     //     file: [ 'dir1/file1.txt' ], 
 *     //     none: [ 'dir4' ], 
 *     //     directory: [ 'dir2'] 
 *     // } 
 *     // result is object containing the files grouped by type 
 * }).catch( err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * // Using async/await 
 * async () =&gt; { 
 *     try { 
 *         let result = await async.groupBy(files, detectFile); 
 *         console.log(result); 
 *         // { 
 *         //     file: [ 'dir1/file1.txt' ], 
 *         //     none: [ 'dir4' ], 
 *         //     directory: [ 'dir2'] 
 *         // } 
 *         // result is object containing the files grouped by type 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">groupBy (</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">groupByLimit$1</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">, </span><span class="s7">Infinity</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`groupBy`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.groupBy} </span><span class="s0">but runs only a single async operation at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">groupBySeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.groupBy]{</span><span class="s1">@link </span><span class="s2">module:Collections.groupBy}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async function to apply to each item in 
 * `coll`. 
 * The iteratee should complete with a `key` to group the value under. 
 * Invoked with (value, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called when all `iteratee` 
 * functions have finished, or an error occurs. Result is an `Object` whose 
 * properties are arrays of values which returned the corresponding key. 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 */</span>
<span class="s1">function </span><span class="s3">groupBySeries (</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">groupByLimit$1</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Logs the result of an `async` function to the `console`. Only works in 
 * Node.js or in browsers that support `console.log` and `console.error` (such 
 * as FF and Chrome). If multiple arguments are returned from the async 
 * function, `console.log` is called on each argument in order. 
 * 
 * </span><span class="s1">@name </span><span class="s2">log</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} function </span><span class="s0">- The function you want to eventually apply 
 * all arguments to. 
 * </span><span class="s1">@param </span><span class="s2">{...*} arguments... </span><span class="s0">- Any number of arguments to apply to the function. 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // in a module 
 * var hello = function(name, callback) { 
 *     setTimeout(function() { 
 *         callback(null, 'hello ' + name); 
 *     }, 1000); 
 * }; 
 * 
 * // in the node repl 
 * node&gt; async.log(hello, 'world'); 
 * 'hello world' 
 */</span>
<span class="s1">var </span><span class="s3">log </span><span class="s1">= </span><span class="s4">consoleFunc</span><span class="s3">(</span><span class="s5">'log'</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`mapValues`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.mapValues} </span><span class="s0">but runs a maximum of `limit` async operations at a 
 * time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">mapValuesLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.mapValues]{</span><span class="s1">@link </span><span class="s2">module:Collections.mapValues}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Object} obj </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{number} limit </span><span class="s0">- The maximum number of async operations at a time. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- A function to apply to each value and key 
 * in `coll`. 
 * The iteratee should complete with the transformed value as its result. 
 * Invoked with (value, key, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called when all `iteratee` 
 * functions have finished, or an error occurs. `result` is a new object consisting 
 * of each key from `obj`, with each transformed value on the right-hand side. 
 * Invoked with (err, result). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 */</span>
<span class="s1">function </span><span class="s3">mapValuesLimit(</span><span class="s2">obj</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s2">callback </span><span class="s1">= </span><span class="s4">once</span><span class="s3">(</span><span class="s2">callback</span><span class="s3">);</span>
    <span class="s1">var </span><span class="s3">newObj </span><span class="s1">= </span><span class="s3">{};</span>
    <span class="s1">var </span><span class="s3">_iteratee </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">iteratee</span><span class="s3">);</span>
    <span class="s1">return </span><span class="s4">eachOfLimit</span><span class="s3">(</span><span class="s2">limit</span><span class="s3">)(</span><span class="s2">obj</span><span class="s3">, (</span><span class="s2">val</span><span class="s3">, </span><span class="s2">key</span><span class="s3">, </span><span class="s2">next</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s4">_iteratee</span><span class="s3">(</span><span class="s2">val</span><span class="s3">, </span><span class="s2">key</span><span class="s3">, (</span><span class="s2">err</span><span class="s3">, </span><span class="s2">result</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">next</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
            <span class="s2">newObj</span><span class="s3">[</span><span class="s2">key</span><span class="s3">] </span><span class="s1">= </span><span class="s2">result</span><span class="s3">;</span>
            <span class="s4">next</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
        <span class="s3">});</span>
    <span class="s3">}, </span><span class="s2">err </span><span class="s1">=&gt; </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s2">newObj</span><span class="s3">));</span>
<span class="s3">}</span>

<span class="s1">var </span><span class="s3">mapValuesLimit$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">mapValuesLimit</span><span class="s3">, </span><span class="s6">4</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* A relative of </span><span class="s7">[`map`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.map}</span><span class="s0">, designed for use with objects. 
 * 
 * Produces a new Object by mapping each value of `obj` through the `iteratee` 
 * function. The `iteratee` is called each `value` and `key` from `obj` and a 
 * callback for when it has finished processing. Each of these callbacks takes 
 * two arguments: an `error`, and the transformed item from `obj`. If `iteratee` 
 * passes an error to its callback, the main `callback` (for the `mapValues` 
 * function) is immediately called with the error. 
 * 
 * Note, the order of the keys in the result is not guaranteed.  The keys will 
 * be roughly in the order they complete, (but this is very engine-specific) 
 * 
 * </span><span class="s1">@name </span><span class="s2">mapValues</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Object} obj </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- A function to apply to each value and key 
 * in `coll`. 
 * The iteratee should complete with the transformed value as its result. 
 * Invoked with (value, key, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called when all `iteratee` 
 * functions have finished, or an error occurs. `result` is a new object consisting 
 * of each key from `obj`, with each transformed value on the right-hand side. 
 * Invoked with (err, result). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // file1.txt is a file that is 1000 bytes in size 
 * // file2.txt is a file that is 2000 bytes in size 
 * // file3.txt is a file that is 3000 bytes in size 
 * // file4.txt does not exist 
 * 
 * const fileMap = { 
 *     f1: 'file1.txt', 
 *     f2: 'file2.txt', 
 *     f3: 'file3.txt' 
 * }; 
 * 
 * const withMissingFileMap = { 
 *     f1: 'file1.txt', 
 *     f2: 'file2.txt', 
 *     f3: 'file4.txt' 
 * }; 
 * 
 * // asynchronous function that returns the file size in bytes 
 * function getFileSizeInBytes(file, key, callback) { 
 *     fs.stat(file, function(err, stat) { 
 *         if (err) { 
 *             return callback(err); 
 *         } 
 *         callback(null, stat.size); 
 *     }); 
 * } 
 * 
 * // Using callbacks 
 * async.mapValues(fileMap, getFileSizeInBytes, function(err, result) { 
 *     if (err) { 
 *         console.log(err); 
 *     } else { 
 *         console.log(result); 
 *         // result is now a map of file size in bytes for each file, e.g. 
 *         // { 
 *         //     f1: 1000, 
 *         //     f2: 2000, 
 *         //     f3: 3000 
 *         // } 
 *     } 
 * }); 
 * 
 * // Error handling 
 * async.mapValues(withMissingFileMap, getFileSizeInBytes, function(err, result) { 
 *     if (err) { 
 *         console.log(err); 
 *         // [ Error: ENOENT: no such file or directory ] 
 *     } else { 
 *         console.log(result); 
 *     } 
 * }); 
 * 
 * // Using Promises 
 * async.mapValues(fileMap, getFileSizeInBytes) 
 * .then( result =&gt; { 
 *     console.log(result); 
 *     // result is now a map of file size in bytes for each file, e.g. 
 *     // { 
 *     //     f1: 1000, 
 *     //     f2: 2000, 
 *     //     f3: 3000 
 *     // } 
 * }).catch (err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * // Error Handling 
 * async.mapValues(withMissingFileMap, getFileSizeInBytes) 
 * .then( result =&gt; { 
 *     console.log(result); 
 * }).catch (err =&gt; { 
 *     console.log(err); 
 *     // [ Error: ENOENT: no such file or directory ] 
 * }); 
 * 
 * // Using async/await 
 * async () =&gt; { 
 *     try { 
 *         let result = await async.mapValues(fileMap, getFileSizeInBytes); 
 *         console.log(result); 
 *         // result is now a map of file size in bytes for each file, e.g. 
 *         // { 
 *         //     f1: 1000, 
 *         //     f2: 2000, 
 *         //     f3: 3000 
 *         // } 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 * // Error Handling 
 * async () =&gt; { 
 *     try { 
 *         let result = await async.mapValues(withMissingFileMap, getFileSizeInBytes); 
 *         console.log(result); 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *         // [ Error: ENOENT: no such file or directory ] 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">mapValues(</span><span class="s2">obj</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">mapValuesLimit$1</span><span class="s3">(</span><span class="s2">obj</span><span class="s3">, </span><span class="s7">Infinity</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`mapValues`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.mapValues} </span><span class="s0">but runs only a single async operation at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">mapValuesSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.mapValues]{</span><span class="s1">@link </span><span class="s2">module:Collections.mapValues}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Object} obj </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- A function to apply to each value and key 
 * in `coll`. 
 * The iteratee should complete with the transformed value as its result. 
 * Invoked with (value, key, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called when all `iteratee` 
 * functions have finished, or an error occurs. `result` is a new object consisting 
 * of each key from `obj`, with each transformed value on the right-hand side. 
 * Invoked with (err, result). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 */</span>
<span class="s1">function </span><span class="s3">mapValuesSeries(</span><span class="s2">obj</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">mapValuesLimit$1</span><span class="s3">(</span><span class="s2">obj</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Caches the results of an async function. When creating a hash to store 
 * function results against, the callback is omitted from the hash and an 
 * optional hash function can be used. 
 * 
 * **Note: if the async function errs, the result will not be cached and 
 * subsequent calls will call the wrapped function.** 
 * 
 * If no hash function is specified, the first argument is used as a hash key, 
 * which may work reasonably if it is a string or a data type that converts to a 
 * distinct string. Note that objects and arrays will not behave reasonably. 
 * Neither will cases where the other arguments are significant. In such cases, 
 * specify your own hash function. 
 * 
 * The cache of results is exposed as the `memo` property of the function 
 * returned by `memoize`. 
 * 
 * </span><span class="s1">@name </span><span class="s2">memoize</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} fn </span><span class="s0">- The async function to proxy and cache results from. 
 * </span><span class="s1">@param </span><span class="s2">{Function} hasher </span><span class="s0">- An optional function for generating a custom hash 
 * for storing results. It has all the arguments applied to it apart from the 
 * callback, and must be synchronous. 
 * </span><span class="s1">@returns </span><span class="s2">{AsyncFunction} </span><span class="s0">a memoized version of `fn` 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * var slow_fn = function(name, callback) { 
 *     // do something 
 *     callback(null, result); 
 * }; 
 * var fn = async.memoize(slow_fn); 
 * 
 * // fn can now be used as if it were slow_fn 
 * fn('some name', function() { 
 *     // callback 
 * }); 
 */</span>
<span class="s1">function </span><span class="s3">memoize(</span><span class="s2">fn</span><span class="s3">, </span><span class="s4">hasher </span><span class="s1">= </span><span class="s2">v </span><span class="s1">=&gt; </span><span class="s2">v</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">memo </span><span class="s1">= </span><span class="s2">Object</span><span class="s3">.</span><span class="s4">create</span><span class="s3">(</span><span class="s7">null</span><span class="s3">);</span>
    <span class="s1">var </span><span class="s3">queues </span><span class="s1">= </span><span class="s2">Object</span><span class="s3">.</span><span class="s4">create</span><span class="s3">(</span><span class="s7">null</span><span class="s3">);</span>
    <span class="s1">var </span><span class="s3">_fn </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">fn</span><span class="s3">);</span>
    <span class="s1">var </span><span class="s3">memoized </span><span class="s1">= </span><span class="s4">initialParams</span><span class="s3">((</span><span class="s2">args</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s1">var </span><span class="s3">key </span><span class="s1">= </span><span class="s4">hasher</span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">);</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">key </span><span class="s1">in </span><span class="s2">memo</span><span class="s3">) {</span>
            <span class="s4">setImmediate$1</span><span class="s3">(() </span><span class="s1">=&gt; </span><span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">, </span><span class="s1">...</span><span class="s2">memo</span><span class="s3">[</span><span class="s2">key</span><span class="s3">]));</span>
        <span class="s3">} </span><span class="s1">else if </span><span class="s3">(</span><span class="s2">key </span><span class="s1">in </span><span class="s2">queues</span><span class="s3">) {</span>
            <span class="s2">queues</span><span class="s3">[</span><span class="s2">key</span><span class="s3">].</span><span class="s4">push</span><span class="s3">(</span><span class="s2">callback</span><span class="s3">);</span>
        <span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
            <span class="s2">queues</span><span class="s3">[</span><span class="s2">key</span><span class="s3">] </span><span class="s1">= </span><span class="s3">[</span><span class="s2">callback</span><span class="s3">];</span>
            <span class="s4">_fn</span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">, (</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">resultArgs</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
                <span class="s0">// #1465 don't memoize if an error occurred</span>
                <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">err</span><span class="s3">) {</span>
                    <span class="s2">memo</span><span class="s3">[</span><span class="s2">key</span><span class="s3">] </span><span class="s1">= </span><span class="s2">resultArgs</span><span class="s3">;</span>
                <span class="s3">}</span>
                <span class="s1">var </span><span class="s3">q </span><span class="s1">= </span><span class="s2">queues</span><span class="s3">[</span><span class="s2">key</span><span class="s3">];</span>
                <span class="s1">delete </span><span class="s2">queues</span><span class="s3">[</span><span class="s2">key</span><span class="s3">];</span>
                <span class="s1">for </span><span class="s3">(</span><span class="s1">var </span><span class="s3">i </span><span class="s1">= </span><span class="s6">0</span><span class="s3">, l </span><span class="s1">= </span><span class="s2">q</span><span class="s3">.length; </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">l</span><span class="s3">; </span><span class="s2">i</span><span class="s1">++</span><span class="s3">) {</span>
                    <span class="s2">q</span><span class="s3">[</span><span class="s2">i</span><span class="s3">](</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">resultArgs</span><span class="s3">);</span>
                <span class="s3">}</span>
            <span class="s3">});</span>
        <span class="s3">}</span>
    <span class="s3">});</span>
    <span class="s2">memoized</span><span class="s3">.</span><span class="s2">memo </span><span class="s1">= </span><span class="s2">memo</span><span class="s3">;</span>
    <span class="s2">memoized</span><span class="s3">.</span><span class="s2">unmemoized </span><span class="s1">= </span><span class="s2">fn</span><span class="s3">;</span>
    <span class="s1">return </span><span class="s2">memoized</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">/* istanbul ignore file */</span>

<span class="s0">/**</span>
 <span class="s0">* Calls `callback` on a later loop around the event loop. In Node.js this just 
 * calls `process.nextTick`.  In the browser it will use `setImmediate` if 
 * available, otherwise `setTimeout(callback, 0)`, which means other higher 
 * priority events may precede the execution of `callback`. 
 * 
 * This is used internally for browser-compatibility purposes. 
 * 
 * </span><span class="s1">@name </span><span class="s2">nextTick</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.setImmediate]{</span><span class="s1">@link </span><span class="s2">module:Utils.setImmediate}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util 
 * </span><span class="s1">@param </span><span class="s2">{Function} callback </span><span class="s0">- The function to call on a later loop around 
 * the event loop. Invoked with (args...). 
 * </span><span class="s1">@param </span><span class="s2">{...*} args... </span><span class="s0">- any number of additional arguments to pass to the 
 * callback on the next tick. 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * var call_order = []; 
 * async.nextTick(function() { 
 *     call_order.push('two'); 
 *     // call_order now equals ['one','two'] 
 * }); 
 * call_order.push('one'); 
 * 
 * async.setImmediate(function (a, b, c) { 
 *     // a, b, and c equal 1, 2, and 3 
 * }, 1, 2, 3); 
 */</span>
<span class="s1">var </span><span class="s3">_defer$1;</span>

<span class="s1">if </span><span class="s3">(</span><span class="s2">hasNextTick</span><span class="s3">) {</span>
    <span class="s2">_defer$1 </span><span class="s1">= </span><span class="s2">process</span><span class="s3">.</span><span class="s2">nextTick</span><span class="s3">;</span>
<span class="s3">} </span><span class="s1">else if </span><span class="s3">(</span><span class="s2">hasSetImmediate</span><span class="s3">) {</span>
    <span class="s2">_defer$1 </span><span class="s1">= </span><span class="s2">setImmediate</span><span class="s3">;</span>
<span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
    <span class="s2">_defer$1 </span><span class="s1">= </span><span class="s2">fallback</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s1">var </span><span class="s3">nextTick </span><span class="s1">= </span><span class="s4">wrap</span><span class="s3">(</span><span class="s2">_defer$1</span><span class="s3">);</span>

<span class="s1">var </span><span class="s3">parallel </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">((</span><span class="s2">eachfn</span><span class="s3">, </span><span class="s2">tasks</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
    <span class="s1">var </span><span class="s3">results </span><span class="s1">= </span><span class="s4">isArrayLike</span><span class="s3">(</span><span class="s2">tasks</span><span class="s3">) </span><span class="s1">? </span><span class="s3">[] </span><span class="s1">: </span><span class="s3">{};</span>

    <span class="s4">eachfn</span><span class="s3">(</span><span class="s2">tasks</span><span class="s3">, (</span><span class="s2">task</span><span class="s3">, </span><span class="s2">key</span><span class="s3">, </span><span class="s2">taskCb</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">task</span><span class="s3">)((</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">result</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">result</span><span class="s3">.length </span><span class="s1">&lt; </span><span class="s6">2</span><span class="s3">) {</span>
                <span class="s3">[</span><span class="s2">result</span><span class="s3">] </span><span class="s1">= </span><span class="s2">result</span><span class="s3">;</span>
            <span class="s3">}</span>
            <span class="s2">results</span><span class="s3">[</span><span class="s2">key</span><span class="s3">] </span><span class="s1">= </span><span class="s2">result</span><span class="s3">;</span>
            <span class="s4">taskCb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
        <span class="s3">});</span>
    <span class="s3">}, </span><span class="s2">err </span><span class="s1">=&gt; </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s2">results</span><span class="s3">));</span>
<span class="s3">}, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* Run the `tasks` collection of functions in parallel, without waiting until 
 * the previous function has completed. If any of the functions pass an error to 
 * its callback, the main `callback` is immediately called with the value of the 
 * error. Once the `tasks` have completed, the results are passed to the final 
 * `callback` as an array. 
 * 
 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about 
 * parallel execution of code.  If your tasks do not use any timers or perform 
 * any I/O, they will actually be executed in series.  Any synchronous setup 
 * sections for each task will happen one after the other.  JavaScript remains 
 * single-threaded. 
 * 
 * **Hint:** Use </span><span class="s7">[`reflect`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Utils.reflect} </span><span class="s0">to continue the 
 * execution of other tasks when a task fails. 
 * 
 * It is also possible to use an object instead of an array. Each property will 
 * be run as a function and the results will be passed to the final `callback` 
 * as an object instead of an array. This can be a more readable way of handling 
 * results from </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">async.parallel}</span><span class="s0">. 
 * 
 * </span><span class="s1">@name </span><span class="s2">parallel</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} tasks </span><span class="s0">- A collection of 
 * </span><span class="s7">[async functions]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">AsyncFunction} </span><span class="s0">to run. 
 * Each async function can complete with any number of optional `result` values. 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- An optional callback to run once all the 
 * functions have completed successfully. This function gets a results array 
 * (or object) containing all the result arguments passed to the task callbacks. 
 * Invoked with (err, results). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if a callback is not passed 
 * 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * //Using Callbacks 
 * async.parallel([ 
 *     function(callback) { 
 *         setTimeout(function() { 
 *             callback(null, 'one'); 
 *         }, 200); 
 *     }, 
 *     function(callback) { 
 *         setTimeout(function() { 
 *             callback(null, 'two'); 
 *         }, 100); 
 *     } 
 * ], function(err, results) { 
 *     console.log(results); 
 *     // results is equal to ['one','two'] even though 
 *     // the second function had a shorter timeout. 
 * }); 
 * 
 * // an example using an object instead of an array 
 * async.parallel({ 
 *     one: function(callback) { 
 *         setTimeout(function() { 
 *             callback(null, 1); 
 *         }, 200); 
 *     }, 
 *     two: function(callback) { 
 *         setTimeout(function() { 
 *             callback(null, 2); 
 *         }, 100); 
 *     } 
 * }, function(err, results) { 
 *     console.log(results); 
 *     // results is equal to: { one: 1, two: 2 } 
 * }); 
 * 
 * //Using Promises 
 * async.parallel([ 
 *     function(callback) { 
 *         setTimeout(function() { 
 *             callback(null, 'one'); 
 *         }, 200); 
 *     }, 
 *     function(callback) { 
 *         setTimeout(function() { 
 *             callback(null, 'two'); 
 *         }, 100); 
 *     } 
 * ]).then(results =&gt; { 
 *     console.log(results); 
 *     // results is equal to ['one','two'] even though 
 *     // the second function had a shorter timeout. 
 * }).catch(err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * // an example using an object instead of an array 
 * async.parallel({ 
 *     one: function(callback) { 
 *         setTimeout(function() { 
 *             callback(null, 1); 
 *         }, 200); 
 *     }, 
 *     two: function(callback) { 
 *         setTimeout(function() { 
 *             callback(null, 2); 
 *         }, 100); 
 *     } 
 * }).then(results =&gt; { 
 *     console.log(results); 
 *     // results is equal to: { one: 1, two: 2 } 
 * }).catch(err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * //Using async/await 
 * async () =&gt; { 
 *     try { 
 *         let results = await async.parallel([ 
 *             function(callback) { 
 *                 setTimeout(function() { 
 *                     callback(null, 'one'); 
 *                 }, 200); 
 *             }, 
 *             function(callback) { 
 *                 setTimeout(function() { 
 *                     callback(null, 'two'); 
 *                 }, 100); 
 *             } 
 *         ]); 
 *         console.log(results); 
 *         // results is equal to ['one','two'] even though 
 *         // the second function had a shorter timeout. 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 * // an example using an object instead of an array 
 * async () =&gt; { 
 *     try { 
 *         let results = await async.parallel({ 
 *             one: function(callback) { 
 *                 setTimeout(function() { 
 *                     callback(null, 1); 
 *                 }, 200); 
 *             }, 
 *            two: function(callback) { 
 *                 setTimeout(function() { 
 *                     callback(null, 2); 
 *                 }, 100); 
 *            } 
 *         }); 
 *         console.log(results); 
 *         // results is equal to: { one: 1, two: 2 } 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">parallel$1(</span><span class="s2">tasks</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">parallel</span><span class="s3">(</span><span class="s2">eachOf$1</span><span class="s3">, </span><span class="s2">tasks</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`parallel`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.parallel} </span><span class="s0">but runs a maximum of `limit` async operations at a 
 * time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">parallelLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.parallel]{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.parallel}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} tasks </span><span class="s0">- A collection of 
 * </span><span class="s7">[async functions]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">AsyncFunction} </span><span class="s0">to run. 
 * Each async function can complete with any number of optional `result` values. 
 * </span><span class="s1">@param </span><span class="s2">{number} limit </span><span class="s0">- The maximum number of async operations at a time. 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- An optional callback to run once all the 
 * functions have completed successfully. This function gets a results array 
 * (or object) containing all the result arguments passed to the task callbacks. 
 * Invoked with (err, results). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if a callback is not passed 
 */</span>
<span class="s1">function </span><span class="s3">parallelLimit(</span><span class="s2">tasks</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">parallel</span><span class="s3">(</span><span class="s4">eachOfLimit</span><span class="s3">(</span><span class="s2">limit</span><span class="s3">), </span><span class="s2">tasks</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* A queue of tasks for the worker function to complete. 
 * </span><span class="s1">@typedef </span><span class="s2">{Iterable} QueueObject</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@property </span><span class="s2">{Function} length </span><span class="s0">- a function returning the number of items 
 * waiting to be processed. Invoke with `queue.length()`. 
 * </span><span class="s1">@property </span><span class="s2">{boolean} started </span><span class="s0">- a boolean indicating whether or not any 
 * items have been pushed and processed by the queue. 
 * </span><span class="s1">@property </span><span class="s2">{Function} running </span><span class="s0">- a function returning the number of items 
 * currently being processed. Invoke with `queue.running()`. 
 * </span><span class="s1">@property </span><span class="s2">{Function} workersList </span><span class="s0">- a function returning the array of items 
 * currently being processed. Invoke with `queue.workersList()`. 
 * </span><span class="s1">@property </span><span class="s2">{Function} idle </span><span class="s0">- a function returning false if there are items 
 * waiting or being processed, or true if not. Invoke with `queue.idle()`. 
 * </span><span class="s1">@property </span><span class="s2">{number} concurrency </span><span class="s0">- an integer for determining how many `worker` 
 * functions should be run in parallel. This property can be changed after a 
 * `queue` is created to alter the concurrency on-the-fly. 
 * </span><span class="s1">@property </span><span class="s2">{number} payload </span><span class="s0">- an integer that specifies how many items are 
 * passed to the worker function at a time. only applies if this is a 
 * </span><span class="s7">[cargo]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.cargo} </span><span class="s0">object 
 * </span><span class="s1">@property </span><span class="s2">{AsyncFunction} push </span><span class="s0">- add a new task to the `queue`. Calls `callback` 
 * once the `worker` has finished processing the task. Instead of a single task, 
 * a `tasks` array can be submitted. The respective callback is used for every 
 * task in the list. Invoke with `queue.push(task, [callback])`, 
 * </span><span class="s1">@property </span><span class="s2">{AsyncFunction} unshift </span><span class="s0">- add a new task to the front of the `queue`. 
 * Invoke with `queue.unshift(task, [callback])`. 
 * </span><span class="s1">@property </span><span class="s2">{AsyncFunction} pushAsync </span><span class="s0">- the same as `q.push`, except this returns 
 * a promise that rejects if an error occurs. 
 * </span><span class="s1">@property </span><span class="s2">{AsyncFunction} unshiftAsync </span><span class="s0">- the same as `q.unshift`, except this returns 
 * a promise that rejects if an error occurs. 
 * </span><span class="s1">@property </span><span class="s2">{Function} remove </span><span class="s0">- remove items from the queue that match a test 
 * function.  The test function will be passed an object with a `data` property, 
 * and a `priority` property, if this is a 
 * </span><span class="s7">[priorityQueue]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.priorityQueue} </span><span class="s0">object. 
 * Invoked with `queue.remove(testFn)`, where `testFn` is of the form 
 * `function ({data, priority}) {}` and returns a Boolean. 
 * </span><span class="s1">@property </span><span class="s2">{Function} saturated </span><span class="s0">- a function that sets a callback that is 
 * called when the number of running workers hits the `concurrency` limit, and 
 * further tasks will be queued.  If the callback is omitted, `q.saturated()` 
 * returns a promise for the next occurrence. 
 * </span><span class="s1">@property </span><span class="s2">{Function} unsaturated </span><span class="s0">- a function that sets a callback that is 
 * called when the number of running workers is less than the `concurrency` &amp; 
 * `buffer` limits, and further tasks will not be queued. If the callback is 
 * omitted, `q.unsaturated()` returns a promise for the next occurrence. 
 * </span><span class="s1">@property </span><span class="s2">{number} buffer </span><span class="s0">- A minimum threshold buffer in order to say that 
 * the `queue` is `unsaturated`. 
 * </span><span class="s1">@property </span><span class="s2">{Function} empty </span><span class="s0">- a function that sets a callback that is called 
 * when the last item from the `queue` is given to a `worker`. If the callback 
 * is omitted, `q.empty()` returns a promise for the next occurrence. 
 * </span><span class="s1">@property </span><span class="s2">{Function} drain </span><span class="s0">- a function that sets a callback that is called 
 * when the last item from the `queue` has returned from the `worker`. If the 
 * callback is omitted, `q.drain()` returns a promise for the next occurrence. 
 * </span><span class="s1">@property </span><span class="s2">{Function} error </span><span class="s0">- a function that sets a callback that is called 
 * when a task errors. Has the signature `function(error, task)`. If the 
 * callback is omitted, `error()` returns a promise that rejects on the next 
 * error. 
 * </span><span class="s1">@property </span><span class="s2">{boolean} paused </span><span class="s0">- a boolean for determining whether the queue is 
 * in a paused state. 
 * </span><span class="s1">@property </span><span class="s2">{Function} pause </span><span class="s0">- a function that pauses the processing of tasks 
 * until `resume()` is called. Invoke with `queue.pause()`. 
 * </span><span class="s1">@property </span><span class="s2">{Function} resume </span><span class="s0">- a function that resumes the processing of 
 * queued tasks when the queue is paused. Invoke with `queue.resume()`. 
 * </span><span class="s1">@property </span><span class="s2">{Function} kill </span><span class="s0">- a function that removes the `drain` callback and 
 * empties remaining tasks from the queue forcing it to go idle. No more tasks 
 * should be pushed to the queue after calling this function. Invoke with `queue.kill()`. 
 * 
 * </span><span class="s1">@example</span>
 <span class="s0">* const q = async.queue(worker, 2) 
 * q.push(item1) 
 * q.push(item2) 
 * q.push(item3) 
 * // queues are iterable, spread into an array to inspect 
 * const items = [...q] // [item1, item2, item3] 
 * // or use for of 
 * for (let item of q) { 
 *     console.log(item) 
 * } 
 * 
 * q.drain(() =&gt; { 
 *     console.log('all done') 
 * }) 
 * // or 
 * await q.drain() 
 */</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a `queue` object with the specified `concurrency`. Tasks added to the 
 * `queue` are processed in parallel (up to the `concurrency` limit). If all 
 * `worker`s are in progress, the task is queued until one becomes available. 
 * Once a `worker` completes a `task`, that `task`'s callback is called. 
 * 
 * </span><span class="s1">@name </span><span class="s2">queue</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} worker </span><span class="s0">- An async function for processing a queued task. 
 * If you want to handle errors from an individual task, pass a callback to 
 * `q.push()`. Invoked with (task, callback). 
 * </span><span class="s1">@param </span><span class="s2">{number} [concurrency</span><span class="s1">=</span><span class="s2">1] </span><span class="s0">- An `integer` for determining how many 
 * `worker` functions should be run in parallel.  If omitted, the concurrency 
 * defaults to `1`.  If the concurrency is `0`, an error is thrown. 
 * </span><span class="s1">@returns </span><span class="s2">{module:ControlFlow.QueueObject} </span><span class="s0">A queue object to manage the tasks. Callbacks can be 
 * attached as certain properties to listen for specific events during the 
 * lifecycle of the queue. 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // create a queue object with concurrency 2 
 * var q = async.queue(function(task, callback) { 
 *     console.log('hello ' + task.name); 
 *     callback(); 
 * }, 2); 
 * 
 * // assign a callback 
 * q.drain(function() { 
 *     console.log('all items have been processed'); 
 * }); 
 * // or await the end 
 * await q.drain() 
 * 
 * // assign an error callback 
 * q.error(function(err, task) { 
 *     console.error('task experienced an error'); 
 * }); 
 * 
 * // add some items to the queue 
 * q.push({name: 'foo'}, function(err) { 
 *     console.log('finished processing foo'); 
 * }); 
 * // callback is optional 
 * q.push({name: 'bar'}); 
 * 
 * // add some items to the queue (batch-wise) 
 * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) { 
 *     console.log('finished processing item'); 
 * }); 
 * 
 * // add some items to the front of the queue 
 * q.unshift({name: 'bar'}, function (err) { 
 *     console.log('finished processing bar'); 
 * }); 
 */</span>
<span class="s1">function </span><span class="s3">queue$1 (</span><span class="s2">worker</span><span class="s3">, </span><span class="s2">concurrency</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">_worker </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">worker</span><span class="s3">);</span>
    <span class="s1">return </span><span class="s4">queue</span><span class="s3">((</span><span class="s2">items</span><span class="s3">, </span><span class="s2">cb</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s4">_worker</span><span class="s3">(</span><span class="s2">items</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s2">cb</span><span class="s3">);</span>
    <span class="s3">}, </span><span class="s2">concurrency</span><span class="s3">, </span><span class="s6">1</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Binary min-heap implementation used for priority queue.</span>
<span class="s0">// Implementation is stable, i.e. push time is considered for equal priorities</span>
<span class="s1">class </span><span class="s2">Heap </span><span class="s3">{</span>
    <span class="s1">constructor</span><span class="s3">() {</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s2">heap </span><span class="s1">= </span><span class="s3">[];</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s2">pushCount </span><span class="s1">= </span><span class="s2">Number</span><span class="s3">.MIN_SAFE_INTEGER;</span>
    <span class="s3">}</span>

    <span class="s1">get </span><span class="s3">length() {</span>
        <span class="s1">return </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">.length;</span>
    <span class="s3">}</span>

    <span class="s3">empty () {</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s2">heap </span><span class="s1">= </span><span class="s3">[];</span>
        <span class="s1">return </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s3">percUp(</span><span class="s2">index</span><span class="s3">) {</span>
        <span class="s1">let </span><span class="s3">p;</span>

        <span class="s1">while </span><span class="s3">(</span><span class="s2">index </span><span class="s1">&gt; </span><span class="s6">0 </span><span class="s1">&amp;&amp; </span><span class="s4">smaller</span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">index</span><span class="s3">], </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">p</span><span class="s1">=</span><span class="s4">parent</span><span class="s3">(</span><span class="s2">index</span><span class="s3">)])) {</span>
            <span class="s1">let </span><span class="s3">t </span><span class="s1">= </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">index</span><span class="s3">];</span>
            <span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">index</span><span class="s3">] </span><span class="s1">= </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">p</span><span class="s3">];</span>
            <span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">p</span><span class="s3">] </span><span class="s1">= </span><span class="s2">t</span><span class="s3">;</span>

            <span class="s2">index </span><span class="s1">= </span><span class="s2">p</span><span class="s3">;</span>
        <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s3">percDown(</span><span class="s2">index</span><span class="s3">) {</span>
        <span class="s1">let </span><span class="s3">l;</span>

        <span class="s1">while </span><span class="s3">((</span><span class="s2">l</span><span class="s1">=</span><span class="s4">leftChi</span><span class="s3">(</span><span class="s2">index</span><span class="s3">)) </span><span class="s1">&lt; </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">.length) {</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">l</span><span class="s1">+</span><span class="s6">1 </span><span class="s1">&lt; </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">.length </span><span class="s1">&amp;&amp; </span><span class="s4">smaller</span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">l</span><span class="s1">+</span><span class="s6">1</span><span class="s3">], </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">l</span><span class="s3">])) {</span>
                <span class="s2">l </span><span class="s1">= </span><span class="s2">l</span><span class="s1">+</span><span class="s6">1</span><span class="s3">;</span>
            <span class="s3">}</span>

            <span class="s1">if </span><span class="s3">(</span><span class="s4">smaller</span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">index</span><span class="s3">], </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">l</span><span class="s3">])) {</span>
                <span class="s1">break</span><span class="s3">;</span>
            <span class="s3">}</span>

            <span class="s1">let </span><span class="s3">t </span><span class="s1">= </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">index</span><span class="s3">];</span>
            <span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">index</span><span class="s3">] </span><span class="s1">= </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">l</span><span class="s3">];</span>
            <span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">l</span><span class="s3">] </span><span class="s1">= </span><span class="s2">t</span><span class="s3">;</span>

            <span class="s2">index </span><span class="s1">= </span><span class="s2">l</span><span class="s3">;</span>
        <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s3">push(</span><span class="s2">node</span><span class="s3">) {</span>
        <span class="s2">node</span><span class="s3">.</span><span class="s2">pushCount </span><span class="s1">= ++</span><span class="s2">this</span><span class="s3">.</span><span class="s2">pushCount</span><span class="s3">;</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">.</span><span class="s4">push</span><span class="s3">(</span><span class="s2">node</span><span class="s3">);</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s4">percUp</span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">.length</span><span class="s1">-</span><span class="s6">1</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s3">unshift(</span><span class="s2">node</span><span class="s3">) {</span>
        <span class="s1">return </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">.</span><span class="s4">push</span><span class="s3">(</span><span class="s2">node</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s3">shift() {</span>
        <span class="s1">let </span><span class="s3">[top] </span><span class="s1">= </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">;</span>

        <span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s1">= </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">.length</span><span class="s1">-</span><span class="s6">1</span><span class="s3">];</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">.</span><span class="s4">pop</span><span class="s3">();</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s4">percDown</span><span class="s3">(</span><span class="s6">0</span><span class="s3">);</span>

        <span class="s1">return </span><span class="s2">top</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s3">toArray() {</span>
        <span class="s1">return </span><span class="s3">[</span><span class="s1">...</span><span class="s2">this</span><span class="s3">];</span>
    <span class="s3">}</span>

    <span class="s1">*</span><span class="s3">[</span><span class="s2">Symbol</span><span class="s3">.</span><span class="s2">iterator</span><span class="s3">] () {</span>
        <span class="s1">for </span><span class="s3">(</span><span class="s1">let </span><span class="s3">i </span><span class="s1">= </span><span class="s6">0</span><span class="s3">; </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">.length; </span><span class="s2">i</span><span class="s1">++</span><span class="s3">) {</span>
            <span class="s1">yield </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">i</span><span class="s3">].</span><span class="s2">data</span><span class="s3">;</span>
        <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s3">remove (</span><span class="s2">testFn</span><span class="s3">) {</span>
        <span class="s1">let </span><span class="s3">j </span><span class="s1">= </span><span class="s6">0</span><span class="s3">;</span>
        <span class="s1">for </span><span class="s3">(</span><span class="s1">let </span><span class="s3">i </span><span class="s1">= </span><span class="s6">0</span><span class="s3">; </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">.length; </span><span class="s2">i</span><span class="s1">++</span><span class="s3">) {</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s4">testFn</span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">i</span><span class="s3">])) {</span>
                <span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">j</span><span class="s3">] </span><span class="s1">= </span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">[</span><span class="s2">i</span><span class="s3">];</span>
                <span class="s2">j</span><span class="s1">++</span><span class="s3">;</span>
            <span class="s3">}</span>
        <span class="s3">}</span>

        <span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">.</span><span class="s4">splice</span><span class="s3">(</span><span class="s2">j</span><span class="s3">);</span>

        <span class="s1">for </span><span class="s3">(</span><span class="s1">let </span><span class="s3">i </span><span class="s1">= </span><span class="s4">parent</span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s2">heap</span><span class="s3">.length</span><span class="s1">-</span><span class="s6">1</span><span class="s3">); </span><span class="s2">i </span><span class="s1">&gt;= </span><span class="s6">0</span><span class="s3">; </span><span class="s2">i</span><span class="s1">--</span><span class="s3">) {</span>
            <span class="s2">this</span><span class="s3">.</span><span class="s4">percDown</span><span class="s3">(</span><span class="s2">i</span><span class="s3">);</span>
        <span class="s3">}</span>

        <span class="s1">return </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s3">}</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">leftChi(</span><span class="s2">i</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s3">(</span><span class="s2">i</span><span class="s1">&lt;&lt;</span><span class="s6">1</span><span class="s3">)</span><span class="s1">+</span><span class="s6">1</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">parent(</span><span class="s2">i</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s3">((</span><span class="s2">i</span><span class="s1">+</span><span class="s6">1</span><span class="s3">)</span><span class="s1">&gt;&gt;</span><span class="s6">1</span><span class="s3">)</span><span class="s1">-</span><span class="s6">1</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">smaller(</span><span class="s2">x</span><span class="s3">, </span><span class="s2">y</span><span class="s3">) {</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s2">x</span><span class="s3">.</span><span class="s2">priority </span><span class="s1">!== </span><span class="s2">y</span><span class="s3">.</span><span class="s2">priority</span><span class="s3">) {</span>
        <span class="s1">return </span><span class="s2">x</span><span class="s3">.</span><span class="s2">priority </span><span class="s1">&lt; </span><span class="s2">y</span><span class="s3">.</span><span class="s2">priority</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">else </span><span class="s3">{</span>
        <span class="s1">return </span><span class="s2">x</span><span class="s3">.</span><span class="s2">pushCount </span><span class="s1">&lt; </span><span class="s2">y</span><span class="s3">.</span><span class="s2">pushCount</span><span class="s3">;</span>
    <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[async.queue]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.queue} </span><span class="s0">only tasks are assigned a priority and 
 * completed in ascending priority order. 
 * 
 * </span><span class="s1">@name </span><span class="s2">priorityQueue</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.queue]{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.queue}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} worker </span><span class="s0">- An async function for processing a queued task. 
 * If you want to handle errors from an individual task, pass a callback to 
 * `q.push()`. 
 * Invoked with (task, callback). 
 * </span><span class="s1">@param </span><span class="s2">{number} concurrency </span><span class="s0">- An `integer` for determining how many `worker` 
 * functions should be run in parallel.  If omitted, the concurrency defaults to 
 * `1`.  If the concurrency is `0`, an error is thrown. 
 * </span><span class="s1">@returns </span><span class="s2">{module:ControlFlow.QueueObject} </span><span class="s0">A priorityQueue object to manage the tasks. There are three 
 * differences between `queue` and `priorityQueue` objects: 
 * * `push(task, priority, [callback])` - `priority` should be a number. If an 
 *   array of `tasks` is given, all tasks will be assigned the same priority. 
 * * `pushAsync(task, priority, [callback])` - the same as `priorityQueue.push`, 
 *   except this returns a promise that rejects if an error occurs. 
 * * The `unshift` and `unshiftAsync` methods were removed. 
 */</span>
<span class="s1">function </span><span class="s3">priorityQueue(</span><span class="s2">worker</span><span class="s3">, </span><span class="s2">concurrency</span><span class="s3">) {</span>
    <span class="s0">// Start with a normal queue</span>
    <span class="s1">var </span><span class="s3">q </span><span class="s1">= </span><span class="s4">queue$1</span><span class="s3">(</span><span class="s2">worker</span><span class="s3">, </span><span class="s2">concurrency</span><span class="s3">);</span>

    <span class="s1">var </span><span class="s3">{</span>
        <span class="s3">push,</span>
        <span class="s3">pushAsync</span>
    <span class="s3">} </span><span class="s1">= </span><span class="s2">q</span><span class="s3">;</span>

    <span class="s2">q</span><span class="s3">.</span><span class="s2">_tasks </span><span class="s1">= new </span><span class="s4">Heap</span><span class="s3">();</span>
    <span class="s2">q</span><span class="s3">.</span><span class="s4">_createTaskItem </span><span class="s1">= </span><span class="s3">({</span><span class="s2">data</span><span class="s3">, </span><span class="s2">priority</span><span class="s3">}, </span><span class="s2">callback</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s1">return </span><span class="s3">{</span>
            <span class="s2">data</span><span class="s3">,</span>
            <span class="s2">priority</span><span class="s3">,</span>
            <span class="s2">callback</span>
        <span class="s3">};</span>
    <span class="s3">};</span>

    <span class="s1">function </span><span class="s3">createDataItems(</span><span class="s2">tasks</span><span class="s3">, </span><span class="s2">priority</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">Array</span><span class="s3">.</span><span class="s4">isArray</span><span class="s3">(</span><span class="s2">tasks</span><span class="s3">)) {</span>
            <span class="s1">return </span><span class="s3">{data: </span><span class="s2">tasks</span><span class="s3">, </span><span class="s2">priority</span><span class="s3">};</span>
        <span class="s3">}</span>
        <span class="s1">return </span><span class="s2">tasks</span><span class="s3">.</span><span class="s4">map</span><span class="s3">(</span><span class="s2">data </span><span class="s1">=&gt; </span><span class="s3">{ </span><span class="s1">return </span><span class="s3">{</span><span class="s2">data</span><span class="s3">, </span><span class="s2">priority</span><span class="s3">}; });</span>
    <span class="s3">}</span>

    <span class="s0">// Override push to accept second parameter representing priority</span>
    <span class="s2">q</span><span class="s3">.</span><span class="s4">push </span><span class="s1">= function</span><span class="s3">(</span><span class="s2">data</span><span class="s3">, </span><span class="s2">priority </span><span class="s1">= </span><span class="s6">0</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
        <span class="s1">return </span><span class="s4">push</span><span class="s3">(</span><span class="s4">createDataItems</span><span class="s3">(</span><span class="s2">data</span><span class="s3">, </span><span class="s2">priority</span><span class="s3">), </span><span class="s2">callback</span><span class="s3">);</span>
    <span class="s3">};</span>

    <span class="s2">q</span><span class="s3">.</span><span class="s4">pushAsync </span><span class="s1">= function</span><span class="s3">(</span><span class="s2">data</span><span class="s3">, </span><span class="s2">priority </span><span class="s1">= </span><span class="s6">0</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
        <span class="s1">return </span><span class="s4">pushAsync</span><span class="s3">(</span><span class="s4">createDataItems</span><span class="s3">(</span><span class="s2">data</span><span class="s3">, </span><span class="s2">priority</span><span class="s3">), </span><span class="s2">callback</span><span class="s3">);</span>
    <span class="s3">};</span>

    <span class="s0">// Remove unshift functions</span>
    <span class="s1">delete </span><span class="s2">q</span><span class="s3">.</span><span class="s2">unshift</span><span class="s3">;</span>
    <span class="s1">delete </span><span class="s2">q</span><span class="s3">.</span><span class="s2">unshiftAsync</span><span class="s3">;</span>

    <span class="s1">return </span><span class="s2">q</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Runs the `tasks` array of functions in parallel, without waiting until the 
 * previous function has completed. Once any of the `tasks` complete or pass an 
 * error to its callback, the main `callback` is immediately called. It's 
 * equivalent to `Promise.race()`. 
 * 
 * </span><span class="s1">@name </span><span class="s2">race</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{Array} tasks </span><span class="s0">- An array containing </span><span class="s7">[async functions]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">AsyncFunction}</span>
 <span class="s0">* to run. Each function can complete with an optional `result` value. 
 * </span><span class="s1">@param </span><span class="s2">{Function} callback </span><span class="s0">- A callback to run once any of the functions have 
 * completed. This function gets an error or result from the first function that 
 * completed. Invoked with (err, result). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if a callback is omitted 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * async.race([ 
 *     function(callback) { 
 *         setTimeout(function() { 
 *             callback(null, 'one'); 
 *         }, 200); 
 *     }, 
 *     function(callback) { 
 *         setTimeout(function() { 
 *             callback(null, 'two'); 
 *         }, 100); 
 *     } 
 * ], 
 * // main callback 
 * function(err, result) { 
 *     // the result will be equal to 'two' as it finishes earlier 
 * }); 
 */</span>
<span class="s1">function </span><span class="s3">race(</span><span class="s2">tasks</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s2">callback </span><span class="s1">= </span><span class="s4">once</span><span class="s3">(</span><span class="s2">callback</span><span class="s3">);</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">Array</span><span class="s3">.</span><span class="s4">isArray</span><span class="s3">(</span><span class="s2">tasks</span><span class="s3">)) </span><span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s1">new </span><span class="s4">TypeError</span><span class="s3">(</span><span class="s5">'First argument to race must be an array of functions'</span><span class="s3">));</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">tasks</span><span class="s3">.length) </span><span class="s1">return </span><span class="s4">callback</span><span class="s3">();</span>
    <span class="s1">for </span><span class="s3">(</span><span class="s1">var </span><span class="s3">i </span><span class="s1">= </span><span class="s6">0</span><span class="s3">, l </span><span class="s1">= </span><span class="s2">tasks</span><span class="s3">.length; </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">l</span><span class="s3">; </span><span class="s2">i</span><span class="s1">++</span><span class="s3">) {</span>
        <span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">tasks</span><span class="s3">[</span><span class="s2">i</span><span class="s3">])(</span><span class="s2">callback</span><span class="s3">);</span>
    <span class="s3">}</span>
<span class="s3">}</span>

<span class="s1">var </span><span class="s3">race$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">race</span><span class="s3">, </span><span class="s6">2</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* Same as </span><span class="s7">[`reduce`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.reduce}</span><span class="s0">, only operates on `array` in reverse order. 
 * 
 * </span><span class="s1">@name </span><span class="s2">reduceRight</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.reduce]{</span><span class="s1">@link </span><span class="s2">module:Collections.reduce}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">foldr</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array} array </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{*} memo </span><span class="s0">- The initial state of the reduction. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- A function applied to each item in the 
 * array to produce the next step in the reduction. 
 * The `iteratee` should complete with the next state of the reduction. 
 * If the iteratee completes with an error, the reduction is stopped and the 
 * main `callback` is immediately called with the error. 
 * Invoked with (memo, item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after all the 
 * `iteratee` functions have finished. Result is the reduced value. Invoked with 
 * (err, result). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 */</span>
<span class="s1">function </span><span class="s3">reduceRight (</span><span class="s2">array</span><span class="s3">, </span><span class="s2">memo</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">reversed </span><span class="s1">= </span><span class="s3">[</span><span class="s1">...</span><span class="s2">array</span><span class="s3">].</span><span class="s4">reverse</span><span class="s3">();</span>
    <span class="s1">return </span><span class="s4">reduce$1</span><span class="s3">(</span><span class="s2">reversed</span><span class="s3">, </span><span class="s2">memo</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Wraps the async function in another function that always completes with a 
 * result object, even when it errors. 
 * 
 * The result object has either the property `error` or `value`. 
 * 
 * </span><span class="s1">@name </span><span class="s2">reflect</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} fn </span><span class="s0">- The async function you want to wrap 
 * </span><span class="s1">@returns </span><span class="s2">{Function} </span><span class="s0">- A function that always passes null to it's callback as 
 * the error. The second argument to the callback will be an `object` with 
 * either an `error` or a `value` property. 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * async.parallel([ 
 *     async.reflect(function(callback) { 
 *         // do some stuff ... 
 *         callback(null, 'one'); 
 *     }), 
 *     async.reflect(function(callback) { 
 *         // do some more stuff but error ... 
 *         callback('bad stuff happened'); 
 *     }), 
 *     async.reflect(function(callback) { 
 *         // do some more stuff ... 
 *         callback(null, 'two'); 
 *     }) 
 * ], 
 * // optional callback 
 * function(err, results) { 
 *     // values 
 *     // results[0].value = 'one' 
 *     // results[1].error = 'bad stuff happened' 
 *     // results[2].value = 'two' 
 * }); 
 */</span>
<span class="s1">function </span><span class="s3">reflect(</span><span class="s2">fn</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">_fn </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">fn</span><span class="s3">);</span>
    <span class="s1">return </span><span class="s4">initialParams</span><span class="s3">(</span><span class="s1">function </span><span class="s3">reflectOn(</span><span class="s2">args</span><span class="s3">, </span><span class="s2">reflectCallback</span><span class="s3">) {</span>
        <span class="s2">args</span><span class="s3">.</span><span class="s4">push</span><span class="s3">((</span><span class="s2">error</span><span class="s3">, </span><span class="s1">...</span><span class="s2">cbArgs</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s1">let </span><span class="s3">retVal </span><span class="s1">= </span><span class="s3">{};</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">error</span><span class="s3">) {</span>
                <span class="s2">retVal</span><span class="s3">.</span><span class="s2">error </span><span class="s1">= </span><span class="s2">error</span><span class="s3">;</span>
            <span class="s3">}</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">cbArgs</span><span class="s3">.length </span><span class="s1">&gt; </span><span class="s6">0</span><span class="s3">){</span>
                <span class="s1">var </span><span class="s3">value </span><span class="s1">= </span><span class="s2">cbArgs</span><span class="s3">;</span>
                <span class="s1">if </span><span class="s3">(</span><span class="s2">cbArgs</span><span class="s3">.length </span><span class="s1">&lt;= </span><span class="s6">1</span><span class="s3">) {</span>
                    <span class="s3">[</span><span class="s2">value</span><span class="s3">] </span><span class="s1">= </span><span class="s2">cbArgs</span><span class="s3">;</span>
                <span class="s3">}</span>
                <span class="s2">retVal</span><span class="s3">.</span><span class="s2">value </span><span class="s1">= </span><span class="s2">value</span><span class="s3">;</span>
            <span class="s3">}</span>
            <span class="s4">reflectCallback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">, </span><span class="s2">retVal</span><span class="s3">);</span>
        <span class="s3">});</span>

        <span class="s1">return </span><span class="s2">_fn</span><span class="s3">.</span><span class="s4">apply</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s2">args</span><span class="s3">);</span>
    <span class="s3">});</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* A helper function that wraps an array or an object of functions with `reflect`. 
 * 
 * </span><span class="s1">@name </span><span class="s2">reflectAll</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.reflect]{</span><span class="s1">@link </span><span class="s2">module:Utils.reflect}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util 
 * </span><span class="s1">@param </span><span class="s2">{Array|Object|Iterable} tasks </span><span class="s0">- The collection of 
 * </span><span class="s7">[async functions]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">AsyncFunction} </span><span class="s0">to wrap in `async.reflect`. 
 * </span><span class="s1">@returns </span><span class="s2">{Array} </span><span class="s0">Returns an array of async functions, each wrapped in 
 * `async.reflect` 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * let tasks = [ 
 *     function(callback) { 
 *         setTimeout(function() { 
 *             callback(null, 'one'); 
 *         }, 200); 
 *     }, 
 *     function(callback) { 
 *         // do some more stuff but error ... 
 *         callback(new Error('bad stuff happened')); 
 *     }, 
 *     function(callback) { 
 *         setTimeout(function() { 
 *             callback(null, 'two'); 
 *         }, 100); 
 *     } 
 * ]; 
 * 
 * async.parallel(async.reflectAll(tasks), 
 * // optional callback 
 * function(err, results) { 
 *     // values 
 *     // results[0].value = 'one' 
 *     // results[1].error = Error('bad stuff happened') 
 *     // results[2].value = 'two' 
 * }); 
 * 
 * // an example using an object instead of an array 
 * let tasks = { 
 *     one: function(callback) { 
 *         setTimeout(function() { 
 *             callback(null, 'one'); 
 *         }, 200); 
 *     }, 
 *     two: function(callback) { 
 *         callback('two'); 
 *     }, 
 *     three: function(callback) { 
 *         setTimeout(function() { 
 *             callback(null, 'three'); 
 *         }, 100); 
 *     } 
 * }; 
 * 
 * async.parallel(async.reflectAll(tasks), 
 * // optional callback 
 * function(err, results) { 
 *     // values 
 *     // results.one.value = 'one' 
 *     // results.two.error = 'two' 
 *     // results.three.value = 'three' 
 * }); 
 */</span>
<span class="s1">function </span><span class="s3">reflectAll(</span><span class="s2">tasks</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">results;</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s2">Array</span><span class="s3">.</span><span class="s4">isArray</span><span class="s3">(</span><span class="s2">tasks</span><span class="s3">)) {</span>
        <span class="s2">results </span><span class="s1">= </span><span class="s2">tasks</span><span class="s3">.</span><span class="s4">map</span><span class="s3">(</span><span class="s2">reflect</span><span class="s3">);</span>
    <span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
        <span class="s2">results </span><span class="s1">= </span><span class="s3">{};</span>
        <span class="s2">Object</span><span class="s3">.</span><span class="s4">keys</span><span class="s3">(</span><span class="s2">tasks</span><span class="s3">).</span><span class="s4">forEach</span><span class="s3">(</span><span class="s2">key </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s2">results</span><span class="s3">[</span><span class="s2">key</span><span class="s3">] </span><span class="s1">= </span><span class="s2">reflect</span><span class="s3">.</span><span class="s4">call</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s2">tasks</span><span class="s3">[</span><span class="s2">key</span><span class="s3">]);</span>
        <span class="s3">});</span>
    <span class="s3">}</span>
    <span class="s1">return </span><span class="s2">results</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">reject(</span><span class="s2">eachfn</span><span class="s3">, </span><span class="s2">arr</span><span class="s3">, </span><span class="s2">_iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">const </span><span class="s3">iteratee </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">_iteratee</span><span class="s3">);</span>
    <span class="s1">return </span><span class="s4">_filter</span><span class="s3">(</span><span class="s2">eachfn</span><span class="s3">, </span><span class="s2">arr</span><span class="s3">, (</span><span class="s2">value</span><span class="s3">, </span><span class="s2">cb</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s4">iteratee</span><span class="s3">(</span><span class="s2">value</span><span class="s3">, (</span><span class="s2">err</span><span class="s3">, </span><span class="s2">v</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s4">cb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s1">!</span><span class="s2">v</span><span class="s3">);</span>
        <span class="s3">});</span>
    <span class="s3">}, </span><span class="s2">callback</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* The opposite of </span><span class="s7">[`filter`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.filter}</span><span class="s0">. Removes values that pass an `async` truth test. 
 * 
 * </span><span class="s1">@name </span><span class="s2">reject</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.filter]{</span><span class="s1">@link </span><span class="s2">module:Collections.filter}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{Function} iteratee </span><span class="s0">- An async truth test to apply to each item in 
 * `coll`. 
 * The should complete with a boolean value as its `result`. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after all the 
 * `iteratee` functions have finished. Invoked with (err, results). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // dir1 is a directory that contains file1.txt, file2.txt 
 * // dir2 is a directory that contains file3.txt, file4.txt 
 * // dir3 is a directory that contains file5.txt 
 * 
 * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt']; 
 * 
 * // asynchronous function that checks if a file exists 
 * function fileExists(file, callback) { 
 *    fs.access(file, fs.constants.F_OK, (err) =&gt; { 
 *        callback(null, !err); 
 *    }); 
 * } 
 * 
 * // Using callbacks 
 * async.reject(fileList, fileExists, function(err, results) { 
 *    // [ 'dir3/file6.txt' ] 
 *    // results now equals an array of the non-existing files 
 * }); 
 * 
 * // Using Promises 
 * async.reject(fileList, fileExists) 
 * .then( results =&gt; { 
 *     console.log(results); 
 *     // [ 'dir3/file6.txt' ] 
 *     // results now equals an array of the non-existing files 
 * }).catch( err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * // Using async/await 
 * async () =&gt; { 
 *     try { 
 *         let results = await async.reject(fileList, fileExists); 
 *         console.log(results); 
 *         // [ 'dir3/file6.txt' ] 
 *         // results now equals an array of the non-existing files 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">reject$1 (</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">reject</span><span class="s3">(</span><span class="s2">eachOf$1</span><span class="s3">, </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">reject$2 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">reject$1</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`reject`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.reject} </span><span class="s0">but runs a maximum of `limit` async operations at a 
 * time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">rejectLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.reject]{</span><span class="s1">@link </span><span class="s2">module:Collections.reject}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{number} limit </span><span class="s0">- The maximum number of async operations at a time. 
 * </span><span class="s1">@param </span><span class="s2">{Function} iteratee </span><span class="s0">- An async truth test to apply to each item in 
 * `coll`. 
 * The should complete with a boolean value as its `result`. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after all the 
 * `iteratee` functions have finished. Invoked with (err, results). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 */</span>
<span class="s1">function </span><span class="s3">rejectLimit (</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">reject</span><span class="s3">(</span><span class="s4">eachOfLimit</span><span class="s3">(</span><span class="s2">limit</span><span class="s3">), </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">rejectLimit$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">rejectLimit</span><span class="s3">, </span><span class="s6">4</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`reject`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.reject} </span><span class="s0">but runs only a single async operation at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">rejectSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.reject]{</span><span class="s1">@link </span><span class="s2">module:Collections.reject}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{Function} iteratee </span><span class="s0">- An async truth test to apply to each item in 
 * `coll`. 
 * The should complete with a boolean value as its `result`. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after all the 
 * `iteratee` functions have finished. Invoked with (err, results). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 */</span>
<span class="s1">function </span><span class="s3">rejectSeries (</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">reject</span><span class="s3">(</span><span class="s2">eachOfSeries$1</span><span class="s3">, </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">rejectSeries$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">rejectSeries</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s1">function </span><span class="s3">constant$1(</span><span class="s2">value</span><span class="s3">) {</span>
    <span class="s1">return function </span><span class="s3">() {</span>
        <span class="s1">return </span><span class="s2">value</span><span class="s3">;</span>
    <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Attempts to get a successful response from `task` no more than `times` times 
 * before returning an error. If the task is successful, the `callback` will be 
 * passed the result of the successful task. If all attempts fail, the callback 
 * will be passed the error and result (if any) of the final attempt. 
 * 
 * </span><span class="s1">@name </span><span class="s2">retry</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@see </span><span class="s2">[async.retryable]{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.retryable}</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s2">{Object|number} [opts </span><span class="s1">= </span><span class="s2">{times: 5, interval: 0}| 5] </span><span class="s0">- Can be either an 
 * object with `times` and `interval` or a number. 
 * * `times` - The number of attempts to make before giving up.  The default 
 *   is `5`. 
 * * `interval` - The time to wait between retries, in milliseconds.  The 
 *   default is `0`. The interval may also be specified as a function of the 
 *   retry count (see example). 
 * * `errorFilter` - An optional synchronous function that is invoked on 
 *   erroneous result. If it returns `true` the retry attempts will continue; 
 *   if the function returns `false` the retry flow is aborted with the current 
 *   attempt's error and result being returned to the final callback. 
 *   Invoked with (err). 
 * * If `opts` is a number, the number specifies the number of times to retry, 
 *   with the default interval of `0`. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} task </span><span class="s0">- An async function to retry. 
 * Invoked with (callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- An optional callback which is called when the 
 * task has succeeded, or after the final failed attempt. It receives the `err` 
 * and `result` arguments of the last attempt at completing the `task`. Invoked 
 * with (err, results). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise if no callback provided 
 * 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // The `retry` function can be used as a stand-alone control flow by passing 
 * // a callback, as shown below: 
 * 
 * // try calling apiMethod 3 times 
 * async.retry(3, apiMethod, function(err, result) { 
 *     // do something with the result 
 * }); 
 * 
 * // try calling apiMethod 3 times, waiting 200 ms between each retry 
 * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) { 
 *     // do something with the result 
 * }); 
 * 
 * // try calling apiMethod 10 times with exponential backoff 
 * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds) 
 * async.retry({ 
 *   times: 10, 
 *   interval: function(retryCount) { 
 *     return 50 * Math.pow(2, retryCount); 
 *   } 
 * }, apiMethod, function(err, result) { 
 *     // do something with the result 
 * }); 
 * 
 * // try calling apiMethod the default 5 times no delay between each retry 
 * async.retry(apiMethod, function(err, result) { 
 *     // do something with the result 
 * }); 
 * 
 * // try calling apiMethod only when error condition satisfies, all other 
 * // errors will abort the retry control flow and return to final callback 
 * async.retry({ 
 *   errorFilter: function(err) { 
 *     return err.message === 'Temporary error'; // only retry on a specific error 
 *   } 
 * }, apiMethod, function(err, result) { 
 *     // do something with the result 
 * }); 
 * 
 * // to retry individual methods that are not as reliable within other 
 * // control flow functions, use the `retryable` wrapper: 
 * async.auto({ 
 *     users: api.getUsers.bind(api), 
 *     payments: async.retryable(3, api.getPayments.bind(api)) 
 * }, function(err, results) { 
 *     // do something with the results 
 * }); 
 * 
 */</span>
<span class="s1">const </span><span class="s3">DEFAULT_TIMES </span><span class="s1">= </span><span class="s6">5</span><span class="s3">;</span>
<span class="s1">const </span><span class="s3">DEFAULT_INTERVAL </span><span class="s1">= </span><span class="s6">0</span><span class="s3">;</span>

<span class="s1">function </span><span class="s3">retry(</span><span class="s2">opts</span><span class="s3">, </span><span class="s2">task</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">options </span><span class="s1">= </span><span class="s3">{</span>
        <span class="s3">times: </span><span class="s2">DEFAULT_TIMES</span><span class="s3">,</span>
        <span class="s3">intervalFunc: </span><span class="s4">constant$1</span><span class="s3">(</span><span class="s2">DEFAULT_INTERVAL</span><span class="s3">)</span>
    <span class="s3">};</span>

    <span class="s1">if </span><span class="s3">(</span><span class="s2">arguments</span><span class="s3">.length </span><span class="s1">&lt; </span><span class="s6">3 </span><span class="s1">&amp;&amp; typeof </span><span class="s2">opts </span><span class="s1">=== </span><span class="s5">'function'</span><span class="s3">) {</span>
        <span class="s2">callback </span><span class="s1">= </span><span class="s2">task </span><span class="s1">|| </span><span class="s4">promiseCallback</span><span class="s3">();</span>
        <span class="s2">task </span><span class="s1">= </span><span class="s2">opts</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
        <span class="s4">parseTimes</span><span class="s3">(</span><span class="s2">options</span><span class="s3">, </span><span class="s2">opts</span><span class="s3">);</span>
        <span class="s2">callback </span><span class="s1">= </span><span class="s2">callback </span><span class="s1">|| </span><span class="s4">promiseCallback</span><span class="s3">();</span>
    <span class="s3">}</span>

    <span class="s1">if </span><span class="s3">(</span><span class="s1">typeof </span><span class="s2">task </span><span class="s1">!== </span><span class="s5">'function'</span><span class="s3">) {</span>
        <span class="s1">throw new </span><span class="s4">Error</span><span class="s3">(</span><span class="s5">&quot;Invalid arguments for async.retry&quot;</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s1">var </span><span class="s3">_task </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">task</span><span class="s3">);</span>

    <span class="s1">var </span><span class="s3">attempt </span><span class="s1">= </span><span class="s6">1</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">retryAttempt() {</span>
        <span class="s4">_task</span><span class="s3">((</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">err </span><span class="s1">=== </span><span class="s7">false</span><span class="s3">) </span><span class="s1">return</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">err </span><span class="s1">&amp;&amp; </span><span class="s2">attempt</span><span class="s1">++ &lt; </span><span class="s2">options</span><span class="s3">.</span><span class="s2">times </span><span class="s1">&amp;&amp;</span>
                <span class="s3">(</span><span class="s1">typeof </span><span class="s2">options</span><span class="s3">.</span><span class="s2">errorFilter </span><span class="s1">!= </span><span class="s5">'function' </span><span class="s1">||</span>
                    <span class="s2">options</span><span class="s3">.</span><span class="s4">errorFilter</span><span class="s3">(</span><span class="s2">err</span><span class="s3">))) {</span>
                <span class="s4">setTimeout</span><span class="s3">(</span><span class="s2">retryAttempt</span><span class="s3">, </span><span class="s2">options</span><span class="s3">.</span><span class="s4">intervalFunc</span><span class="s3">(</span><span class="s2">attempt </span><span class="s1">- </span><span class="s6">1</span><span class="s3">));</span>
            <span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
                <span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s3">);</span>
            <span class="s3">}</span>
        <span class="s3">});</span>
    <span class="s3">}</span>

    <span class="s4">retryAttempt</span><span class="s3">();</span>
    <span class="s1">return </span><span class="s2">callback</span><span class="s3">[</span><span class="s2">PROMISE_SYMBOL</span><span class="s3">]</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">parseTimes(</span><span class="s2">acc</span><span class="s3">, </span><span class="s2">t</span><span class="s3">) {</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s1">typeof </span><span class="s2">t </span><span class="s1">=== </span><span class="s5">'object'</span><span class="s3">) {</span>
        <span class="s2">acc</span><span class="s3">.</span><span class="s2">times </span><span class="s1">= +</span><span class="s2">t</span><span class="s3">.</span><span class="s2">times </span><span class="s1">|| </span><span class="s2">DEFAULT_TIMES</span><span class="s3">;</span>

        <span class="s2">acc</span><span class="s3">.</span><span class="s2">intervalFunc </span><span class="s1">= typeof </span><span class="s2">t</span><span class="s3">.</span><span class="s2">interval </span><span class="s1">=== </span><span class="s5">'function' </span><span class="s1">?</span>
            <span class="s2">t</span><span class="s3">.</span><span class="s2">interval </span><span class="s1">:</span>
            <span class="s4">constant$1</span><span class="s3">(</span><span class="s1">+</span><span class="s2">t</span><span class="s3">.</span><span class="s2">interval </span><span class="s1">|| </span><span class="s2">DEFAULT_INTERVAL</span><span class="s3">);</span>

        <span class="s2">acc</span><span class="s3">.</span><span class="s2">errorFilter </span><span class="s1">= </span><span class="s2">t</span><span class="s3">.</span><span class="s2">errorFilter</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s1">else if </span><span class="s3">(</span><span class="s1">typeof </span><span class="s2">t </span><span class="s1">=== </span><span class="s5">'number' </span><span class="s1">|| typeof </span><span class="s2">t </span><span class="s1">=== </span><span class="s5">'string'</span><span class="s3">) {</span>
        <span class="s2">acc</span><span class="s3">.</span><span class="s2">times </span><span class="s1">= +</span><span class="s2">t </span><span class="s1">|| </span><span class="s2">DEFAULT_TIMES</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
        <span class="s1">throw new </span><span class="s4">Error</span><span class="s3">(</span><span class="s5">&quot;Invalid arguments for async.retry&quot;</span><span class="s3">);</span>
    <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* A close relative of </span><span class="s7">[`retry`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.retry}</span><span class="s0">.  This method 
 * wraps a task and makes it retryable, rather than immediately calling it 
 * with retries. 
 * 
 * </span><span class="s1">@name </span><span class="s2">retryable</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.retry]{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.retry}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{Object|number} [opts </span><span class="s1">= </span><span class="s2">{times: 5, interval: 0}| 5] </span><span class="s0">- optional 
 * options, exactly the same as from `retry`, except for a `opts.arity` that 
 * is the arity of the `task` function, defaulting to `task.length` 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} task </span><span class="s0">- the asynchronous function to wrap. 
 * This function will be passed any arguments passed to the returned wrapper. 
 * Invoked with (...args, callback). 
 * </span><span class="s1">@returns </span><span class="s2">{AsyncFunction} </span><span class="s0">The wrapped function, which when invoked, will 
 * retry on an error, based on the parameters specified in `opts`. 
 * This function will accept the same parameters as `task`. 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * async.auto({ 
 *     dep1: async.retryable(3, getFromFlakyService), 
 *     process: [&quot;dep1&quot;, async.retryable(3, function (results, cb) { 
 *         maybeProcessData(results.dep1, cb); 
 *     })] 
 * }, callback); 
 */</span>
<span class="s1">function </span><span class="s3">retryable (</span><span class="s2">opts</span><span class="s3">, </span><span class="s2">task</span><span class="s3">) {</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">task</span><span class="s3">) {</span>
        <span class="s2">task </span><span class="s1">= </span><span class="s2">opts</span><span class="s3">;</span>
        <span class="s2">opts </span><span class="s1">= </span><span class="s7">null</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">let </span><span class="s3">arity </span><span class="s1">= </span><span class="s3">(</span><span class="s2">opts </span><span class="s1">&amp;&amp; </span><span class="s2">opts</span><span class="s3">.</span><span class="s2">arity</span><span class="s3">) </span><span class="s1">|| </span><span class="s2">task</span><span class="s3">.length;</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s4">isAsync</span><span class="s3">(</span><span class="s2">task</span><span class="s3">)) {</span>
        <span class="s2">arity </span><span class="s1">+= </span><span class="s6">1</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">var </span><span class="s3">_task </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">task</span><span class="s3">);</span>
    <span class="s1">return </span><span class="s4">initialParams</span><span class="s3">((</span><span class="s2">args</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">args</span><span class="s3">.length </span><span class="s1">&lt; </span><span class="s2">arity </span><span class="s1">- </span><span class="s6">1 </span><span class="s1">|| </span><span class="s2">callback </span><span class="s1">== </span><span class="s7">null</span><span class="s3">) {</span>
            <span class="s2">args</span><span class="s3">.</span><span class="s4">push</span><span class="s3">(</span><span class="s2">callback</span><span class="s3">);</span>
            <span class="s2">callback </span><span class="s1">= </span><span class="s4">promiseCallback</span><span class="s3">();</span>
        <span class="s3">}</span>
        <span class="s1">function </span><span class="s3">taskFn(</span><span class="s2">cb</span><span class="s3">) {</span>
            <span class="s4">_task</span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">, </span><span class="s2">cb</span><span class="s3">);</span>
        <span class="s3">}</span>

        <span class="s1">if </span><span class="s3">(</span><span class="s2">opts</span><span class="s3">) </span><span class="s4">retry</span><span class="s3">(</span><span class="s2">opts</span><span class="s3">, </span><span class="s2">taskFn</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">);</span>
        <span class="s1">else </span><span class="s4">retry</span><span class="s3">(</span><span class="s2">taskFn</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">);</span>

        <span class="s1">return </span><span class="s2">callback</span><span class="s3">[</span><span class="s2">PROMISE_SYMBOL</span><span class="s3">]</span>
    <span class="s3">});</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Run the functions in the `tasks` collection in series, each one running once 
 * the previous function has completed. If any functions in the series pass an 
 * error to its callback, no more functions are run, and `callback` is 
 * immediately called with the value of the error. Otherwise, `callback` 
 * receives an array of results when `tasks` have completed. 
 * 
 * It is also possible to use an object instead of an array. Each property will 
 * be run as a function, and the results will be passed to the final `callback` 
 * as an object instead of an array. This can be a more readable way of handling 
 *  results from </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">async.series}</span><span class="s0">. 
 * 
 * **Note** that while many implementations preserve the order of object 
 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) 
 * explicitly states that 
 * 
 * &gt; The mechanics and order of enumerating the properties is not specified. 
 * 
 * So if you rely on the order in which your series of functions are executed, 
 * and want this to work on all platforms, consider using an array. 
 * 
 * </span><span class="s1">@name </span><span class="s2">series</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} tasks </span><span class="s0">- A collection containing 
 * </span><span class="s7">[async functions]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">AsyncFunction} </span><span class="s0">to run in series. 
 * Each function can complete with any number of optional `result` values. 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- An optional callback to run once all the 
 * functions have completed. This function gets a results array (or object) 
 * containing all the result arguments passed to the `task` callbacks. Invoked 
 * with (err, result). 
 * </span><span class="s1">@return </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * //Using Callbacks 
 * async.series([ 
 *     function(callback) { 
 *         setTimeout(function() { 
 *             // do some async task 
 *             callback(null, 'one'); 
 *         }, 200); 
 *     }, 
 *     function(callback) { 
 *         setTimeout(function() { 
 *             // then do another async task 
 *             callback(null, 'two'); 
 *         }, 100); 
 *     } 
 * ], function(err, results) { 
 *     console.log(results); 
 *     // results is equal to ['one','two'] 
 * }); 
 * 
 * // an example using objects instead of arrays 
 * async.series({ 
 *     one: function(callback) { 
 *         setTimeout(function() { 
 *             // do some async task 
 *             callback(null, 1); 
 *         }, 200); 
 *     }, 
 *     two: function(callback) { 
 *         setTimeout(function() { 
 *             // then do another async task 
 *             callback(null, 2); 
 *         }, 100); 
 *     } 
 * }, function(err, results) { 
 *     console.log(results); 
 *     // results is equal to: { one: 1, two: 2 } 
 * }); 
 * 
 * //Using Promises 
 * async.series([ 
 *     function(callback) { 
 *         setTimeout(function() { 
 *             callback(null, 'one'); 
 *         }, 200); 
 *     }, 
 *     function(callback) { 
 *         setTimeout(function() { 
 *             callback(null, 'two'); 
 *         }, 100); 
 *     } 
 * ]).then(results =&gt; { 
 *     console.log(results); 
 *     // results is equal to ['one','two'] 
 * }).catch(err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * // an example using an object instead of an array 
 * async.series({ 
 *     one: function(callback) { 
 *         setTimeout(function() { 
 *             // do some async task 
 *             callback(null, 1); 
 *         }, 200); 
 *     }, 
 *     two: function(callback) { 
 *         setTimeout(function() { 
 *             // then do another async task 
 *             callback(null, 2); 
 *         }, 100); 
 *     } 
 * }).then(results =&gt; { 
 *     console.log(results); 
 *     // results is equal to: { one: 1, two: 2 } 
 * }).catch(err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * //Using async/await 
 * async () =&gt; { 
 *     try { 
 *         let results = await async.series([ 
 *             function(callback) { 
 *                 setTimeout(function() { 
 *                     // do some async task 
 *                     callback(null, 'one'); 
 *                 }, 200); 
 *             }, 
 *             function(callback) { 
 *                 setTimeout(function() { 
 *                     // then do another async task 
 *                     callback(null, 'two'); 
 *                 }, 100); 
 *             } 
 *         ]); 
 *         console.log(results); 
 *         // results is equal to ['one','two'] 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 * // an example using an object instead of an array 
 * async () =&gt; { 
 *     try { 
 *         let results = await async.parallel({ 
 *             one: function(callback) { 
 *                 setTimeout(function() { 
 *                     // do some async task 
 *                     callback(null, 1); 
 *                 }, 200); 
 *             }, 
 *            two: function(callback) { 
 *                 setTimeout(function() { 
 *                     // then do another async task 
 *                     callback(null, 2); 
 *                 }, 100); 
 *            } 
 *         }); 
 *         console.log(results); 
 *         // results is equal to: { one: 1, two: 2 } 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">series(</span><span class="s2">tasks</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">parallel</span><span class="s3">(</span><span class="s2">eachOfSeries$1</span><span class="s3">, </span><span class="s2">tasks</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Returns `true` if at least one element in the `coll` satisfies an async test. 
 * If any iteratee call returns `true`, the main `callback` is immediately 
 * called. 
 * 
 * </span><span class="s1">@name </span><span class="s2">some</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">any</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async truth test to apply to each item 
 * in the collections in parallel. 
 * The iteratee should complete with a boolean `result` value. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called as soon as any 
 * iteratee returns `true`, or after all the iteratee functions have finished. 
 * Result will be either `true` or `false` depending on the values of the async 
 * tests. Invoked with (err, result). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback provided 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // dir1 is a directory that contains file1.txt, file2.txt 
 * // dir2 is a directory that contains file3.txt, file4.txt 
 * // dir3 is a directory that contains file5.txt 
 * // dir4 does not exist 
 * 
 * // asynchronous function that checks if a file exists 
 * function fileExists(file, callback) { 
 *    fs.access(file, fs.constants.F_OK, (err) =&gt; { 
 *        callback(null, !err); 
 *    }); 
 * } 
 * 
 * // Using callbacks 
 * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists, 
 *    function(err, result) { 
 *        console.log(result); 
 *        // true 
 *        // result is true since some file in the list exists 
 *    } 
 *); 
 * 
 * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists, 
 *    function(err, result) { 
 *        console.log(result); 
 *        // false 
 *        // result is false since none of the files exists 
 *    } 
 *); 
 * 
 * // Using Promises 
 * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists) 
 * .then( result =&gt; { 
 *     console.log(result); 
 *     // true 
 *     // result is true since some file in the list exists 
 * }).catch( err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists) 
 * .then( result =&gt; { 
 *     console.log(result); 
 *     // false 
 *     // result is false since none of the files exists 
 * }).catch( err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * // Using async/await 
 * async () =&gt; { 
 *     try { 
 *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists); 
 *         console.log(result); 
 *         // true 
 *         // result is true since some file in the list exists 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 * async () =&gt; { 
 *     try { 
 *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists); 
 *         console.log(result); 
 *         // false 
 *         // result is false since none of the files exists 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">some(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">_createTester</span><span class="s3">(</span><span class="s2">Boolean</span><span class="s3">, </span><span class="s2">res </span><span class="s1">=&gt; </span><span class="s2">res</span><span class="s3">)(</span><span class="s2">eachOf$1</span><span class="s3">, </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">some$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">some</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`some`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.some} </span><span class="s0">but runs a maximum of `limit` async operations at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">someLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.some]{</span><span class="s1">@link </span><span class="s2">module:Collections.some}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">anyLimit</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{number} limit </span><span class="s0">- The maximum number of async operations at a time. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async truth test to apply to each item 
 * in the collections in parallel. 
 * The iteratee should complete with a boolean `result` value. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called as soon as any 
 * iteratee returns `true`, or after all the iteratee functions have finished. 
 * Result will be either `true` or `false` depending on the values of the async 
 * tests. Invoked with (err, result). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback provided 
 */</span>
<span class="s1">function </span><span class="s3">someLimit(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">_createTester</span><span class="s3">(</span><span class="s2">Boolean</span><span class="s3">, </span><span class="s2">res </span><span class="s1">=&gt; </span><span class="s2">res</span><span class="s3">)(</span><span class="s4">eachOfLimit</span><span class="s3">(</span><span class="s2">limit</span><span class="s3">), </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">someLimit$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">someLimit</span><span class="s3">, </span><span class="s6">4</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[`some`]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.some} </span><span class="s0">but runs only a single async operation at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">someSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.some]{</span><span class="s1">@link </span><span class="s2">module:Collections.some}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s2">anySeries</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async truth test to apply to each item 
 * in the collections in series. 
 * The iteratee should complete with a boolean `result` value. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called as soon as any 
 * iteratee returns `true`, or after all the iteratee functions have finished. 
 * Result will be either `true` or `false` depending on the values of the async 
 * tests. Invoked with (err, result). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback provided 
 */</span>
<span class="s1">function </span><span class="s3">someSeries(</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">_createTester</span><span class="s3">(</span><span class="s2">Boolean</span><span class="s3">, </span><span class="s2">res </span><span class="s1">=&gt; </span><span class="s2">res</span><span class="s3">)(</span><span class="s2">eachOfSeries$1</span><span class="s3">, </span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">someSeries$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">someSeries</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* Sorts a list by the results of running each `coll` value through an async 
 * `iteratee`. 
 * 
 * </span><span class="s1">@name </span><span class="s2">sortBy</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async function to apply to each item in 
 * `coll`. 
 * The iteratee should complete with a value to use as the sort criteria as 
 * its `result`. 
 * Invoked with (item, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} callback </span><span class="s0">- A callback which is called after all the 
 * `iteratee` functions have finished, or an error occurs. Results is the items 
 * from the original `coll` sorted by the values returned by the `iteratee` 
 * calls. Invoked with (err, results). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback passed 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // bigfile.txt is a file that is 251100 bytes in size 
 * // mediumfile.txt is a file that is 11000 bytes in size 
 * // smallfile.txt is a file that is 121 bytes in size 
 * 
 * // asynchronous function that returns the file size in bytes 
 * function getFileSizeInBytes(file, callback) { 
 *     fs.stat(file, function(err, stat) { 
 *         if (err) { 
 *             return callback(err); 
 *         } 
 *         callback(null, stat.size); 
 *     }); 
 * } 
 * 
 * // Using callbacks 
 * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes, 
 *     function(err, results) { 
 *         if (err) { 
 *             console.log(err); 
 *         } else { 
 *             console.log(results); 
 *             // results is now the original array of files sorted by 
 *             // file size (ascending by default), e.g. 
 *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt'] 
 *         } 
 *     } 
 * ); 
 * 
 * // By modifying the callback parameter the 
 * // sorting order can be influenced: 
 * 
 * // ascending order 
 * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], function(file, callback) { 
 *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) { 
 *         if (getFileSizeErr) return callback(getFileSizeErr); 
 *         callback(null, fileSize); 
 *     }); 
 * }, function(err, results) { 
 *         if (err) { 
 *             console.log(err); 
 *         } else { 
 *             console.log(results); 
 *             // results is now the original array of files sorted by 
 *             // file size (ascending by default), e.g. 
 *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt'] 
 *         } 
 *     } 
 * ); 
 * 
 * // descending order 
 * async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], function(file, callback) { 
 *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) { 
 *         if (getFileSizeErr) { 
 *             return callback(getFileSizeErr); 
 *         } 
 *         callback(null, fileSize * -1); 
 *     }); 
 * }, function(err, results) { 
 *         if (err) { 
 *             console.log(err); 
 *         } else { 
 *             console.log(results); 
 *             // results is now the original array of files sorted by 
 *             // file size (ascending by default), e.g. 
 *             // [ 'bigfile.txt', 'mediumfile.txt', 'smallfile.txt'] 
 *         } 
 *     } 
 * ); 
 * 
 * // Error handling 
 * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes, 
 *     function(err, results) { 
 *         if (err) { 
 *             console.log(err); 
 *             // [ Error: ENOENT: no such file or directory ] 
 *         } else { 
 *             console.log(results); 
 *         } 
 *     } 
 * ); 
 * 
 * // Using Promises 
 * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes) 
 * .then( results =&gt; { 
 *     console.log(results); 
 *     // results is now the original array of files sorted by 
 *     // file size (ascending by default), e.g. 
 *     // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt'] 
 * }).catch( err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * // Error handling 
 * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes) 
 * .then( results =&gt; { 
 *     console.log(results); 
 * }).catch( err =&gt; { 
 *     console.log(err); 
 *     // [ Error: ENOENT: no such file or directory ] 
 * }); 
 * 
 * // Using async/await 
 * (async () =&gt; { 
 *     try { 
 *         let results = await async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes); 
 *         console.log(results); 
 *         // results is now the original array of files sorted by 
 *         // file size (ascending by default), e.g. 
 *         // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt'] 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * })(); 
 * 
 * // Error handling 
 * async () =&gt; { 
 *     try { 
 *         let results = await async.sortBy(['missingfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes); 
 *         console.log(results); 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *         // [ Error: ENOENT: no such file or directory ] 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">sortBy (</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">_iteratee </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">iteratee</span><span class="s3">);</span>
    <span class="s1">return </span><span class="s4">map$1</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">, (</span><span class="s2">x</span><span class="s3">, </span><span class="s2">iterCb</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s4">_iteratee</span><span class="s3">(</span><span class="s2">x</span><span class="s3">, (</span><span class="s2">err</span><span class="s3">, </span><span class="s2">criteria</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">iterCb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
            <span class="s4">iterCb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, {value: </span><span class="s2">x</span><span class="s3">, </span><span class="s2">criteria</span><span class="s3">});</span>
        <span class="s3">});</span>
    <span class="s3">}, (</span><span class="s2">err</span><span class="s3">, </span><span class="s2">results</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
        <span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">, </span><span class="s2">results</span><span class="s3">.</span><span class="s4">sort</span><span class="s3">(</span><span class="s2">comparator</span><span class="s3">).</span><span class="s4">map</span><span class="s3">(</span><span class="s2">v </span><span class="s1">=&gt; </span><span class="s2">v</span><span class="s3">.</span><span class="s2">value</span><span class="s3">));</span>
    <span class="s3">});</span>

    <span class="s1">function </span><span class="s3">comparator(</span><span class="s2">left</span><span class="s3">, </span><span class="s2">right</span><span class="s3">) {</span>
        <span class="s1">var </span><span class="s3">a </span><span class="s1">= </span><span class="s2">left</span><span class="s3">.</span><span class="s2">criteria</span><span class="s3">, b </span><span class="s1">= </span><span class="s2">right</span><span class="s3">.</span><span class="s2">criteria</span><span class="s3">;</span>
        <span class="s1">return </span><span class="s2">a </span><span class="s1">&lt; </span><span class="s2">b </span><span class="s1">? -</span><span class="s6">1 </span><span class="s1">: </span><span class="s2">a </span><span class="s1">&gt; </span><span class="s2">b </span><span class="s1">? </span><span class="s6">1 </span><span class="s1">: </span><span class="s6">0</span><span class="s3">;</span>
    <span class="s3">}</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">sortBy$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">sortBy</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a time limit on an asynchronous function. If the function does not call 
 * its callback within the specified milliseconds, it will be called with a 
 * timeout error. The code property for the error object will be `'ETIMEDOUT'`. 
 * 
 * </span><span class="s1">@name </span><span class="s2">timeout</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} asyncFn </span><span class="s0">- The async function to limit in time. 
 * </span><span class="s1">@param </span><span class="s2">{number} milliseconds </span><span class="s0">- The specified time limit. 
 * </span><span class="s1">@param </span><span class="s2">{*} [info] </span><span class="s0">- Any variable you want attached (`string`, `object`, etc) 
 * to timeout Error for more information.. 
 * </span><span class="s1">@returns </span><span class="s2">{AsyncFunction} </span><span class="s0">Returns a wrapped function that can be used with any 
 * of the control flow functions. 
 * Invoke this function with the same parameters as you would `asyncFunc`. 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * function myFunction(foo, callback) { 
 *     doAsyncTask(foo, function(err, data) { 
 *         // handle errors 
 *         if (err) return callback(err); 
 * 
 *         // do some stuff ... 
 * 
 *         // return processed data 
 *         return callback(null, data); 
 *     }); 
 * } 
 * 
 * var wrapped = async.timeout(myFunction, 1000); 
 * 
 * // call `wrapped` as you would `myFunction` 
 * wrapped({ bar: 'bar' }, function(err, data) { 
 *     // if `myFunction` takes &lt; 1000 ms to execute, `err` 
 *     // and `data` will have their expected values 
 * 
 *     // else `err` will be an Error with the code 'ETIMEDOUT' 
 * }); 
 */</span>
<span class="s1">function </span><span class="s3">timeout(</span><span class="s2">asyncFn</span><span class="s3">, </span><span class="s2">milliseconds</span><span class="s3">, </span><span class="s2">info</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">fn </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">asyncFn</span><span class="s3">);</span>

    <span class="s1">return </span><span class="s4">initialParams</span><span class="s3">((</span><span class="s2">args</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s1">var </span><span class="s3">timedOut </span><span class="s1">= </span><span class="s7">false</span><span class="s3">;</span>
        <span class="s1">var </span><span class="s3">timer;</span>

        <span class="s1">function </span><span class="s3">timeoutCallback() {</span>
            <span class="s1">var </span><span class="s3">name </span><span class="s1">= </span><span class="s2">asyncFn</span><span class="s3">.</span><span class="s2">name </span><span class="s1">|| </span><span class="s5">'anonymous'</span><span class="s3">;</span>
            <span class="s1">var </span><span class="s3">error  </span><span class="s1">= new </span><span class="s4">Error</span><span class="s3">(</span><span class="s5">'Callback function &quot;' </span><span class="s1">+ </span><span class="s2">name </span><span class="s1">+ </span><span class="s5">'&quot; timed out.'</span><span class="s3">);</span>
            <span class="s2">error</span><span class="s3">.</span><span class="s2">code </span><span class="s1">= </span><span class="s5">'ETIMEDOUT'</span><span class="s3">;</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">info</span><span class="s3">) {</span>
                <span class="s2">error</span><span class="s3">.</span><span class="s2">info </span><span class="s1">= </span><span class="s2">info</span><span class="s3">;</span>
            <span class="s3">}</span>
            <span class="s2">timedOut </span><span class="s1">= </span><span class="s7">true</span><span class="s3">;</span>
            <span class="s4">callback</span><span class="s3">(</span><span class="s2">error</span><span class="s3">);</span>
        <span class="s3">}</span>

        <span class="s2">args</span><span class="s3">.</span><span class="s4">push</span><span class="s3">((</span><span class="s1">...</span><span class="s2">cbArgs</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">timedOut</span><span class="s3">) {</span>
                <span class="s4">callback</span><span class="s3">(</span><span class="s1">...</span><span class="s2">cbArgs</span><span class="s3">);</span>
                <span class="s4">clearTimeout</span><span class="s3">(</span><span class="s2">timer</span><span class="s3">);</span>
            <span class="s3">}</span>
        <span class="s3">});</span>

        <span class="s0">// setup timer and call original function</span>
        <span class="s2">timer </span><span class="s1">= </span><span class="s4">setTimeout</span><span class="s3">(</span><span class="s2">timeoutCallback</span><span class="s3">, </span><span class="s2">milliseconds</span><span class="s3">);</span>
        <span class="s4">fn</span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">);</span>
    <span class="s3">});</span>
<span class="s3">}</span>

<span class="s1">function </span><span class="s3">range(</span><span class="s2">size</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">result </span><span class="s1">= </span><span class="s4">Array</span><span class="s3">(</span><span class="s2">size</span><span class="s3">);</span>
    <span class="s1">while </span><span class="s3">(</span><span class="s2">size</span><span class="s1">--</span><span class="s3">) {</span>
        <span class="s2">result</span><span class="s3">[</span><span class="s2">size</span><span class="s3">] </span><span class="s1">= </span><span class="s2">size</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">return </span><span class="s2">result</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[times]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.times} </span><span class="s0">but runs a maximum of `limit` async operations at a 
 * time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">timesLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.times]{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.times}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{number} count </span><span class="s0">- The number of times to run the function. 
 * </span><span class="s1">@param </span><span class="s2">{number} limit </span><span class="s0">- The maximum number of async operations at a time. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- The async function to call `n` times. 
 * Invoked with the iteration index and a callback: (n, next). 
 * </span><span class="s1">@param </span><span class="s2">{Function} callback </span><span class="s0">- see </span><span class="s7">[async.map]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.map}</span><span class="s0">. 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is provided 
 */</span>
<span class="s1">function </span><span class="s3">timesLimit(</span><span class="s2">count</span><span class="s3">, </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">_iteratee </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">iteratee</span><span class="s3">);</span>
    <span class="s1">return </span><span class="s4">mapLimit$1</span><span class="s3">(</span><span class="s4">range</span><span class="s3">(</span><span class="s2">count</span><span class="s3">), </span><span class="s2">limit</span><span class="s3">, </span><span class="s2">_iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Calls the `iteratee` function `n` times, and accumulates results in the same 
 * manner you would use with </span><span class="s7">[map]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.map}</span><span class="s0">. 
 * 
 * </span><span class="s1">@name </span><span class="s2">times</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.map]{</span><span class="s1">@link </span><span class="s2">module:Collections.map}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{number} n </span><span class="s0">- The number of times to run the function. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- The async function to call `n` times. 
 * Invoked with the iteration index and a callback: (n, next). 
 * </span><span class="s1">@param </span><span class="s2">{Function} callback </span><span class="s0">- see </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.map}</span><span class="s0">. 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is provided 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // Pretend this is some complicated async factory 
 * var createUser = function(id, callback) { 
 *     callback(null, { 
 *         id: 'user' + id 
 *     }); 
 * }; 
 * 
 * // generate 5 users 
 * async.times(5, function(n, next) { 
 *     createUser(n, function(err, user) { 
 *         next(err, user); 
 *     }); 
 * }, function(err, users) { 
 *     // we should now have 5 users 
 * }); 
 */</span>
<span class="s1">function </span><span class="s3">times (</span><span class="s2">n</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">timesLimit</span><span class="s3">(</span><span class="s2">n</span><span class="s3">, </span><span class="s7">Infinity</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* The same as </span><span class="s7">[times]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.times} </span><span class="s0">but runs only a single async operation at a time. 
 * 
 * </span><span class="s1">@name </span><span class="s2">timesSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.times]{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.times}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{number} n </span><span class="s0">- The number of times to run the function. 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- The async function to call `n` times. 
 * Invoked with the iteration index and a callback: (n, next). 
 * </span><span class="s1">@param </span><span class="s2">{Function} callback </span><span class="s0">- see </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Collections.map}</span><span class="s0">. 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is provided 
 */</span>
<span class="s1">function </span><span class="s3">timesSeries (</span><span class="s2">n</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s4">timesLimit</span><span class="s3">(</span><span class="s2">n</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* A relative of `reduce`.  Takes an Object or Array, and iterates over each 
 * element in parallel, each step potentially mutating an `accumulator` value. 
 * The type of the accumulator defaults to the type of collection passed in. 
 * 
 * </span><span class="s1">@name </span><span class="s2">transform</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} coll </span><span class="s0">- A collection to iterate over. 
 * </span><span class="s1">@param </span><span class="s2">{*} [accumulator] </span><span class="s0">- The initial state of the transform.  If omitted, 
 * it will default to an empty Object or Array, depending on the type of `coll` 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- A function applied to each item in the 
 * collection that potentially modifies the accumulator. 
 * Invoked with (accumulator, item, key, callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after all the 
 * `iteratee` functions have finished. Result is the transformed accumulator. 
 * Invoked with (err, result). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback provided 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // file1.txt is a file that is 1000 bytes in size 
 * // file2.txt is a file that is 2000 bytes in size 
 * // file3.txt is a file that is 3000 bytes in size 
 * 
 * // helper function that returns human-readable size format from bytes 
 * function formatBytes(bytes, decimals = 2) { 
 *   // implementation not included for brevity 
 *   return humanReadbleFilesize; 
 * } 
 * 
 * const fileList = ['file1.txt','file2.txt','file3.txt']; 
 * 
 * // asynchronous function that returns the file size, transformed to human-readable format 
 * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc. 
 * function transformFileSize(acc, value, key, callback) { 
 *     fs.stat(value, function(err, stat) { 
 *         if (err) { 
 *             return callback(err); 
 *         } 
 *         acc[key] = formatBytes(stat.size); 
 *         callback(null); 
 *     }); 
 * } 
 * 
 * // Using callbacks 
 * async.transform(fileList, transformFileSize, function(err, result) { 
 *     if(err) { 
 *         console.log(err); 
 *     } else { 
 *         console.log(result); 
 *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ] 
 *     } 
 * }); 
 * 
 * // Using Promises 
 * async.transform(fileList, transformFileSize) 
 * .then(result =&gt; { 
 *     console.log(result); 
 *     // [ '1000 Bytes', '1.95 KB', '2.93 KB' ] 
 * }).catch(err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * // Using async/await 
 * (async () =&gt; { 
 *     try { 
 *         let result = await async.transform(fileList, transformFileSize); 
 *         console.log(result); 
 *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ] 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * })(); 
 * 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * // file1.txt is a file that is 1000 bytes in size 
 * // file2.txt is a file that is 2000 bytes in size 
 * // file3.txt is a file that is 3000 bytes in size 
 * 
 * // helper function that returns human-readable size format from bytes 
 * function formatBytes(bytes, decimals = 2) { 
 *   // implementation not included for brevity 
 *   return humanReadbleFilesize; 
 * } 
 * 
 * const fileMap = { f1: 'file1.txt', f2: 'file2.txt', f3: 'file3.txt' }; 
 * 
 * // asynchronous function that returns the file size, transformed to human-readable format 
 * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc. 
 * function transformFileSize(acc, value, key, callback) { 
 *     fs.stat(value, function(err, stat) { 
 *         if (err) { 
 *             return callback(err); 
 *         } 
 *         acc[key] = formatBytes(stat.size); 
 *         callback(null); 
 *     }); 
 * } 
 * 
 * // Using callbacks 
 * async.transform(fileMap, transformFileSize, function(err, result) { 
 *     if(err) { 
 *         console.log(err); 
 *     } else { 
 *         console.log(result); 
 *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' } 
 *     } 
 * }); 
 * 
 * // Using Promises 
 * async.transform(fileMap, transformFileSize) 
 * .then(result =&gt; { 
 *     console.log(result); 
 *     // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' } 
 * }).catch(err =&gt; { 
 *     console.log(err); 
 * }); 
 * 
 * // Using async/await 
 * async () =&gt; { 
 *     try { 
 *         let result = await async.transform(fileMap, transformFileSize); 
 *         console.log(result); 
 *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' } 
 *     } 
 *     catch (err) { 
 *         console.log(err); 
 *     } 
 * } 
 * 
 */</span>
<span class="s1">function </span><span class="s3">transform (</span><span class="s2">coll</span><span class="s3">, </span><span class="s2">accumulator</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s2">arguments</span><span class="s3">.length </span><span class="s1">&lt;= </span><span class="s6">3 </span><span class="s1">&amp;&amp; typeof </span><span class="s2">accumulator </span><span class="s1">=== </span><span class="s5">'function'</span><span class="s3">) {</span>
        <span class="s2">callback </span><span class="s1">= </span><span class="s2">iteratee</span><span class="s3">;</span>
        <span class="s2">iteratee </span><span class="s1">= </span><span class="s2">accumulator</span><span class="s3">;</span>
        <span class="s2">accumulator </span><span class="s1">= </span><span class="s2">Array</span><span class="s3">.</span><span class="s4">isArray</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">) </span><span class="s1">? </span><span class="s3">[] </span><span class="s1">: </span><span class="s3">{};</span>
    <span class="s3">}</span>
    <span class="s2">callback </span><span class="s1">= </span><span class="s4">once</span><span class="s3">(</span><span class="s2">callback </span><span class="s1">|| </span><span class="s4">promiseCallback</span><span class="s3">());</span>
    <span class="s1">var </span><span class="s3">_iteratee </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">iteratee</span><span class="s3">);</span>

    <span class="s4">eachOf$1</span><span class="s3">(</span><span class="s2">coll</span><span class="s3">, (</span><span class="s2">v</span><span class="s3">, </span><span class="s2">k</span><span class="s3">, </span><span class="s2">cb</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s4">_iteratee</span><span class="s3">(</span><span class="s2">accumulator</span><span class="s3">, </span><span class="s2">v</span><span class="s3">, </span><span class="s2">k</span><span class="s3">, </span><span class="s2">cb</span><span class="s3">);</span>
    <span class="s3">}, </span><span class="s2">err </span><span class="s1">=&gt; </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s2">accumulator</span><span class="s3">));</span>
    <span class="s1">return </span><span class="s2">callback</span><span class="s3">[</span><span class="s2">PROMISE_SYMBOL</span><span class="s3">]</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* It runs each task in series but stops whenever any of the functions were 
 * successful. If one of the tasks were successful, the `callback` will be 
 * passed the result of the successful task. If all tasks fail, the callback 
 * will be passed the error and result (if any) of the final attempt. 
 * 
 * </span><span class="s1">@name </span><span class="s2">tryEach</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{Array|Iterable|AsyncIterable|Object} tasks </span><span class="s0">- A collection containing functions to 
 * run, each function is passed a `callback(err, result)` it must call on 
 * completion with an error `err` (which can be `null`) and an optional `result` 
 * value. 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- An optional callback which is called when one 
 * of the tasks has succeeded, or all have failed. It receives the `err` and 
 * `result` arguments of the last attempt at completing the `task`. Invoked with 
 * (err, results). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 * </span><span class="s1">@example</span>
 <span class="s0">* async.tryEach([ 
 *     function getDataFromFirstWebsite(callback) { 
 *         // Try getting the data from the first website 
 *         callback(err, data); 
 *     }, 
 *     function getDataFromSecondWebsite(callback) { 
 *         // First website failed, 
 *         // Try getting the data from the backup website 
 *         callback(err, data); 
 *     } 
 * ], 
 * // optional callback 
 * function(err, results) { 
 *     Now do something with the data. 
 * }); 
 * 
 */</span>
<span class="s1">function </span><span class="s3">tryEach(</span><span class="s2">tasks</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">var </span><span class="s3">error </span><span class="s1">= </span><span class="s7">null</span><span class="s3">;</span>
    <span class="s1">var </span><span class="s3">result;</span>
    <span class="s1">return </span><span class="s4">eachSeries$1</span><span class="s3">(</span><span class="s2">tasks</span><span class="s3">, (</span><span class="s2">task</span><span class="s3">, </span><span class="s2">taskCb</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">task</span><span class="s3">)((</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
            <span class="s1">if </span><span class="s3">(</span><span class="s2">err </span><span class="s1">=== </span><span class="s7">false</span><span class="s3">) </span><span class="s1">return </span><span class="s4">taskCb</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>

            <span class="s1">if </span><span class="s3">(</span><span class="s2">args</span><span class="s3">.length </span><span class="s1">&lt; </span><span class="s6">2</span><span class="s3">) {</span>
                <span class="s3">[</span><span class="s2">result</span><span class="s3">] </span><span class="s1">= </span><span class="s2">args</span><span class="s3">;</span>
            <span class="s3">} </span><span class="s1">else </span><span class="s3">{</span>
                <span class="s2">result </span><span class="s1">= </span><span class="s2">args</span><span class="s3">;</span>
            <span class="s3">}</span>
            <span class="s2">error </span><span class="s1">= </span><span class="s2">err</span><span class="s3">;</span>
            <span class="s4">taskCb</span><span class="s3">(</span><span class="s2">err </span><span class="s1">? </span><span class="s7">null </span><span class="s1">: </span><span class="s3">{});</span>
        <span class="s3">});</span>
    <span class="s3">}, () </span><span class="s1">=&gt; </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">error</span><span class="s3">, </span><span class="s2">result</span><span class="s3">));</span>
<span class="s3">}</span>

<span class="s1">var </span><span class="s3">tryEach$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">tryEach</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* Undoes a </span><span class="s7">[memoize]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Utils.memoize}</span><span class="s0">d function, reverting it to the original, 
 * unmemoized form. Handy for testing. 
 * 
 * </span><span class="s1">@name </span><span class="s2">unmemoize</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.memoize]{</span><span class="s1">@link </span><span class="s2">module:Utils.memoize}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} fn </span><span class="s0">- the memoized function 
 * </span><span class="s1">@returns </span><span class="s2">{AsyncFunction} </span><span class="s0">a function that calls the original unmemoized function 
 */</span>
<span class="s1">function </span><span class="s3">unmemoize(</span><span class="s2">fn</span><span class="s3">) {</span>
    <span class="s1">return </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s3">{</span>
        <span class="s1">return </span><span class="s3">(</span><span class="s2">fn</span><span class="s3">.</span><span class="s2">unmemoized </span><span class="s1">|| </span><span class="s2">fn</span><span class="s3">)(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">);</span>
    <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when 
 * stopped, or an error occurs. 
 * 
 * </span><span class="s1">@name </span><span class="s2">whilst</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} test </span><span class="s0">- asynchronous truth test to perform before each 
 * execution of `iteratee`. Invoked with (). 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async function which is called each time 
 * `test` passes. Invoked with (callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after the test 
 * function has failed and repeated execution of `iteratee` has stopped. `callback` 
 * will be passed an error and any arguments passed to the final `iteratee`'s 
 * callback. Invoked with (err, [results]); 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if no callback is passed 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * var count = 0; 
 * async.whilst( 
 *     function test(cb) { cb(null, count &lt; 5); }, 
 *     function iter(callback) { 
 *         count++; 
 *         setTimeout(function() { 
 *             callback(null, count); 
 *         }, 1000); 
 *     }, 
 *     function (err, n) { 
 *         // 5 seconds have passed, n = 5 
 *     } 
 * ); 
 */</span>
<span class="s1">function </span><span class="s3">whilst(</span><span class="s2">test</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s2">callback </span><span class="s1">= </span><span class="s4">onlyOnce</span><span class="s3">(</span><span class="s2">callback</span><span class="s3">);</span>
    <span class="s1">var </span><span class="s3">_fn </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">iteratee</span><span class="s3">);</span>
    <span class="s1">var </span><span class="s3">_test </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">test</span><span class="s3">);</span>
    <span class="s1">var </span><span class="s3">results </span><span class="s1">= </span><span class="s3">[];</span>

    <span class="s1">function </span><span class="s3">next(</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">rest</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
        <span class="s2">results </span><span class="s1">= </span><span class="s2">rest</span><span class="s3">;</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err </span><span class="s1">=== </span><span class="s7">false</span><span class="s3">) </span><span class="s1">return</span><span class="s3">;</span>
        <span class="s4">_test</span><span class="s3">(</span><span class="s2">check</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s1">function </span><span class="s3">check(</span><span class="s2">err</span><span class="s3">, </span><span class="s2">truth</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err</span><span class="s3">) </span><span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">);</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err </span><span class="s1">=== </span><span class="s7">false</span><span class="s3">) </span><span class="s1">return</span><span class="s3">;</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">truth</span><span class="s3">) </span><span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s7">null</span><span class="s3">, </span><span class="s1">...</span><span class="s2">results</span><span class="s3">);</span>
        <span class="s4">_fn</span><span class="s3">(</span><span class="s2">next</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s1">return </span><span class="s4">_test</span><span class="s3">(</span><span class="s2">check</span><span class="s3">);</span>
<span class="s3">}</span>
<span class="s1">var </span><span class="s3">whilst$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">whilst</span><span class="s3">, </span><span class="s6">3</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when 
 * stopped, or an error occurs. `callback` will be passed an error and any 
 * arguments passed to the final `iteratee`'s callback. 
 * 
 * The inverse of </span><span class="s7">[whilst]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.whilst}</span><span class="s0">. 
 * 
 * </span><span class="s1">@name </span><span class="s2">until</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s2">[async.whilst]{</span><span class="s1">@link </span><span class="s2">module:ControlFlow.whilst}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} test </span><span class="s0">- asynchronous truth test to perform before each 
 * execution of `iteratee`. Invoked with (callback). 
 * </span><span class="s1">@param </span><span class="s2">{AsyncFunction} iteratee </span><span class="s0">- An async function which is called each time 
 * `test` fails. Invoked with (callback). 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- A callback which is called after the test 
 * function has passed and repeated execution of `iteratee` has stopped. `callback` 
 * will be passed an error and any arguments passed to the final `iteratee`'s 
 * callback. Invoked with (err, [results]); 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if a callback is not passed 
 * 
 * </span><span class="s1">@example</span>
 <span class="s0">* const results = [] 
 * let finished = false 
 * async.until(function test(cb) { 
 *     cb(null, finished) 
 * }, function iter(next) { 
 *     fetchPage(url, (err, body) =&gt; { 
 *         if (err) return next(err) 
 *         results = results.concat(body.objects) 
 *         finished = !!body.next 
 *         next(err) 
 *     }) 
 * }, function done (err) { 
 *     // all pages have been fetched 
 * }) 
 */</span>
<span class="s1">function </span><span class="s3">until(</span><span class="s2">test</span><span class="s3">, </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s1">const </span><span class="s3">_test </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">test</span><span class="s3">);</span>
    <span class="s1">return </span><span class="s4">whilst$1</span><span class="s3">((</span><span class="s2">cb</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s4">_test</span><span class="s3">((</span><span class="s2">err</span><span class="s3">, </span><span class="s2">truth</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s4">cb </span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s1">!</span><span class="s2">truth</span><span class="s3">)), </span><span class="s2">iteratee</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* Runs the `tasks` array of functions in series, each passing their results to 
 * the next in the array. However, if any of the `tasks` pass an error to their 
 * own callback, the next function is not executed, and the main `callback` is 
 * immediately called with the error. 
 * 
 * </span><span class="s1">@name </span><span class="s2">waterfall</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow 
 * </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow 
 * </span><span class="s1">@param </span><span class="s2">{Array} tasks </span><span class="s0">- An array of </span><span class="s7">[async functions]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">AsyncFunction}</span>
 <span class="s0">* to run. 
 * Each function should complete with any number of `result` values. 
 * The `result` values will be passed as arguments, in order, to the next task. 
 * </span><span class="s1">@param </span><span class="s2">{Function} [callback] </span><span class="s0">- An optional callback to run once all the 
 * functions have completed. This will be passed the results of the last task's 
 * callback. Invoked with (err, [results]). 
 * </span><span class="s1">@returns </span><span class="s2">{Promise} </span><span class="s0">a promise, if a callback is omitted 
 * </span><span class="s1">@example</span>
 <span class="s0">* 
 * async.waterfall([ 
 *     function(callback) { 
 *         callback(null, 'one', 'two'); 
 *     }, 
 *     function(arg1, arg2, callback) { 
 *         // arg1 now equals 'one' and arg2 now equals 'two' 
 *         callback(null, 'three'); 
 *     }, 
 *     function(arg1, callback) { 
 *         // arg1 now equals 'three' 
 *         callback(null, 'done'); 
 *     } 
 * ], function (err, result) { 
 *     // result now equals 'done' 
 * }); 
 * 
 * // Or, with named functions: 
 * async.waterfall([ 
 *     myFirstFunction, 
 *     mySecondFunction, 
 *     myLastFunction, 
 * ], function (err, result) { 
 *     // result now equals 'done' 
 * }); 
 * function myFirstFunction(callback) { 
 *     callback(null, 'one', 'two'); 
 * } 
 * function mySecondFunction(arg1, arg2, callback) { 
 *     // arg1 now equals 'one' and arg2 now equals 'two' 
 *     callback(null, 'three'); 
 * } 
 * function myLastFunction(arg1, callback) { 
 *     // arg1 now equals 'three' 
 *     callback(null, 'done'); 
 * } 
 */</span>
<span class="s1">function </span><span class="s3">waterfall (</span><span class="s2">tasks</span><span class="s3">, </span><span class="s2">callback</span><span class="s3">) {</span>
    <span class="s2">callback </span><span class="s1">= </span><span class="s4">once</span><span class="s3">(</span><span class="s2">callback</span><span class="s3">);</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">Array</span><span class="s3">.</span><span class="s4">isArray</span><span class="s3">(</span><span class="s2">tasks</span><span class="s3">)) </span><span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s1">new </span><span class="s4">Error</span><span class="s3">(</span><span class="s5">'First argument to waterfall must be an array of functions'</span><span class="s3">));</span>
    <span class="s1">if </span><span class="s3">(</span><span class="s1">!</span><span class="s2">tasks</span><span class="s3">.length) </span><span class="s1">return </span><span class="s4">callback</span><span class="s3">();</span>
    <span class="s1">var </span><span class="s3">taskIndex </span><span class="s1">= </span><span class="s6">0</span><span class="s3">;</span>

    <span class="s1">function </span><span class="s3">nextTask(</span><span class="s2">args</span><span class="s3">) {</span>
        <span class="s1">var </span><span class="s3">task </span><span class="s1">= </span><span class="s4">wrapAsync</span><span class="s3">(</span><span class="s2">tasks</span><span class="s3">[</span><span class="s2">taskIndex</span><span class="s1">++</span><span class="s3">]);</span>
        <span class="s4">task</span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s3">, </span><span class="s4">onlyOnce</span><span class="s3">(</span><span class="s2">next</span><span class="s3">));</span>
    <span class="s3">}</span>

    <span class="s1">function </span><span class="s3">next(</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s3">) {</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err </span><span class="s1">=== </span><span class="s7">false</span><span class="s3">) </span><span class="s1">return</span>
        <span class="s1">if </span><span class="s3">(</span><span class="s2">err </span><span class="s1">|| </span><span class="s2">taskIndex </span><span class="s1">=== </span><span class="s2">tasks</span><span class="s3">.length) {</span>
            <span class="s1">return </span><span class="s4">callback</span><span class="s3">(</span><span class="s2">err</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s3">);</span>
        <span class="s3">}</span>
        <span class="s4">nextTask</span><span class="s3">(</span><span class="s2">args</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s4">nextTask</span><span class="s3">([]);</span>
<span class="s3">}</span>

<span class="s1">var </span><span class="s3">waterfall$1 </span><span class="s1">= </span><span class="s4">awaitify</span><span class="s3">(</span><span class="s2">waterfall</span><span class="s3">);</span>

<span class="s0">/**</span>
 <span class="s0">* An &quot;async function&quot; in the context of Async is an asynchronous function with 
 * a variable number of parameters, with the final parameter being a callback. 
 * (`function (arg1, arg2, ..., callback) {}`) 
 * The final callback is of the form `callback(err, results...)`, which must be 
 * called once the function is completed.  The callback should be called with a 
 * Error as its first argument to signal that an error occurred. 
 * Otherwise, if no error occurred, it should be called with `null` as the first 
 * argument, and any additional `result` arguments that may apply, to signal 
 * successful completion. 
 * The callback must be called exactly once, ideally on a later tick of the 
 * JavaScript event loop. 
 * 
 * This type of function is also referred to as a &quot;Node-style async function&quot;, 
 * or a &quot;continuation passing-style function&quot; (CPS). Most of the methods of this 
 * library are themselves CPS/Node-style async functions, or functions that 
 * return CPS/Node-style async functions. 
 * 
 * Wherever we accept a Node-style async function, we also directly accept an 
 * </span><span class="s7">[ES2017 `async` function]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}</span><span class="s0">. 
 * In this case, the `async` function will not be passed a final callback 
 * argument, and any thrown error will be used as the `err` argument of the 
 * implicit callback, and the return value will be used as the `result` value. 
 * (i.e. a `rejected` of the returned Promise becomes the `err` callback 
 * argument, and a `resolved` value becomes the `result`.) 
 * 
 * Note, due to JavaScript limitations, we can only detect native `async` 
 * functions and not transpilied implementations. 
 * Your environment must have `async`/`await` support for this to work. 
 * (e.g. Node &gt; v7.6, or a recent version of a modern browser). 
 * If you are using `async` functions through a transpiler (e.g. Babel), you 
 * must still wrap the function with </span><span class="s7">[asyncify]</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">module:Utils.asyncify}</span><span class="s0">, 
 * because the `async function` will be compiled to an ordinary function that 
 * returns a promise. 
 * 
 * </span><span class="s1">@typedef </span><span class="s2">{Function} AsyncFunction</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">*/</span>

<span class="s1">var </span><span class="s3">index </span><span class="s1">= </span><span class="s3">{</span>
    <span class="s2">apply</span><span class="s3">,</span>
    <span class="s3">applyEach: </span><span class="s2">applyEach$1</span><span class="s3">,</span>
    <span class="s2">applyEachSeries</span><span class="s3">,</span>
    <span class="s2">asyncify</span><span class="s3">,</span>
    <span class="s2">auto</span><span class="s3">,</span>
    <span class="s2">autoInject</span><span class="s3">,</span>
    <span class="s2">cargo</span><span class="s3">,</span>
    <span class="s3">cargoQueue: </span><span class="s2">cargo$1</span><span class="s3">,</span>
    <span class="s2">compose</span><span class="s3">,</span>
    <span class="s3">concat: </span><span class="s2">concat$1</span><span class="s3">,</span>
    <span class="s3">concatLimit: </span><span class="s2">concatLimit$1</span><span class="s3">,</span>
    <span class="s3">concatSeries: </span><span class="s2">concatSeries$1</span><span class="s3">,</span>
    <span class="s2">constant</span><span class="s3">,</span>
    <span class="s3">detect: </span><span class="s2">detect$1</span><span class="s3">,</span>
    <span class="s3">detectLimit: </span><span class="s2">detectLimit$1</span><span class="s3">,</span>
    <span class="s3">detectSeries: </span><span class="s2">detectSeries$1</span><span class="s3">,</span>
    <span class="s2">dir</span><span class="s3">,</span>
    <span class="s2">doUntil</span><span class="s3">,</span>
    <span class="s3">doWhilst: </span><span class="s2">doWhilst$1</span><span class="s3">,</span>
    <span class="s2">each</span><span class="s3">,</span>
    <span class="s3">eachLimit: </span><span class="s2">eachLimit$2</span><span class="s3">,</span>
    <span class="s3">eachOf: </span><span class="s2">eachOf$1</span><span class="s3">,</span>
    <span class="s3">eachOfLimit: </span><span class="s2">eachOfLimit$2</span><span class="s3">,</span>
    <span class="s3">eachOfSeries: </span><span class="s2">eachOfSeries$1</span><span class="s3">,</span>
    <span class="s3">eachSeries: </span><span class="s2">eachSeries$1</span><span class="s3">,</span>
    <span class="s2">ensureAsync</span><span class="s3">,</span>
    <span class="s3">every: </span><span class="s2">every$1</span><span class="s3">,</span>
    <span class="s3">everyLimit: </span><span class="s2">everyLimit$1</span><span class="s3">,</span>
    <span class="s3">everySeries: </span><span class="s2">everySeries$1</span><span class="s3">,</span>
    <span class="s3">filter: </span><span class="s2">filter$1</span><span class="s3">,</span>
    <span class="s3">filterLimit: </span><span class="s2">filterLimit$1</span><span class="s3">,</span>
    <span class="s3">filterSeries: </span><span class="s2">filterSeries$1</span><span class="s3">,</span>
    <span class="s3">forever: </span><span class="s2">forever$1</span><span class="s3">,</span>
    <span class="s2">groupBy</span><span class="s3">,</span>
    <span class="s3">groupByLimit: </span><span class="s2">groupByLimit$1</span><span class="s3">,</span>
    <span class="s2">groupBySeries</span><span class="s3">,</span>
    <span class="s2">log</span><span class="s3">,</span>
    <span class="s3">map: </span><span class="s2">map$1</span><span class="s3">,</span>
    <span class="s3">mapLimit: </span><span class="s2">mapLimit$1</span><span class="s3">,</span>
    <span class="s3">mapSeries: </span><span class="s2">mapSeries$1</span><span class="s3">,</span>
    <span class="s2">mapValues</span><span class="s3">,</span>
    <span class="s3">mapValuesLimit: </span><span class="s2">mapValuesLimit$1</span><span class="s3">,</span>
    <span class="s2">mapValuesSeries</span><span class="s3">,</span>
    <span class="s2">memoize</span><span class="s3">,</span>
    <span class="s2">nextTick</span><span class="s3">,</span>
    <span class="s3">parallel: </span><span class="s2">parallel$1</span><span class="s3">,</span>
    <span class="s2">parallelLimit</span><span class="s3">,</span>
    <span class="s2">priorityQueue</span><span class="s3">,</span>
    <span class="s3">queue: </span><span class="s2">queue$1</span><span class="s3">,</span>
    <span class="s3">race: </span><span class="s2">race$1</span><span class="s3">,</span>
    <span class="s3">reduce: </span><span class="s2">reduce$1</span><span class="s3">,</span>
    <span class="s2">reduceRight</span><span class="s3">,</span>
    <span class="s2">reflect</span><span class="s3">,</span>
    <span class="s2">reflectAll</span><span class="s3">,</span>
    <span class="s3">reject: </span><span class="s2">reject$2</span><span class="s3">,</span>
    <span class="s3">rejectLimit: </span><span class="s2">rejectLimit$1</span><span class="s3">,</span>
    <span class="s3">rejectSeries: </span><span class="s2">rejectSeries$1</span><span class="s3">,</span>
    <span class="s2">retry</span><span class="s3">,</span>
    <span class="s2">retryable</span><span class="s3">,</span>
    <span class="s2">seq</span><span class="s3">,</span>
    <span class="s2">series</span><span class="s3">,</span>
    <span class="s3">setImmediate: </span><span class="s2">setImmediate$1</span><span class="s3">,</span>
    <span class="s3">some: </span><span class="s2">some$1</span><span class="s3">,</span>
    <span class="s3">someLimit: </span><span class="s2">someLimit$1</span><span class="s3">,</span>
    <span class="s3">someSeries: </span><span class="s2">someSeries$1</span><span class="s3">,</span>
    <span class="s3">sortBy: </span><span class="s2">sortBy$1</span><span class="s3">,</span>
    <span class="s2">timeout</span><span class="s3">,</span>
    <span class="s2">times</span><span class="s3">,</span>
    <span class="s2">timesLimit</span><span class="s3">,</span>
    <span class="s2">timesSeries</span><span class="s3">,</span>
    <span class="s2">transform</span><span class="s3">,</span>
    <span class="s3">tryEach: </span><span class="s2">tryEach$1</span><span class="s3">,</span>
    <span class="s2">unmemoize</span><span class="s3">,</span>
    <span class="s2">until</span><span class="s3">,</span>
    <span class="s3">waterfall: </span><span class="s2">waterfall$1</span><span class="s3">,</span>
    <span class="s3">whilst: </span><span class="s2">whilst$1</span><span class="s3">,</span>

    <span class="s0">// aliases</span>
    <span class="s3">all: </span><span class="s2">every$1</span><span class="s3">,</span>
    <span class="s3">allLimit: </span><span class="s2">everyLimit$1</span><span class="s3">,</span>
    <span class="s3">allSeries: </span><span class="s2">everySeries$1</span><span class="s3">,</span>
    <span class="s3">any: </span><span class="s2">some$1</span><span class="s3">,</span>
    <span class="s3">anyLimit: </span><span class="s2">someLimit$1</span><span class="s3">,</span>
    <span class="s3">anySeries: </span><span class="s2">someSeries$1</span><span class="s3">,</span>
    <span class="s3">find: </span><span class="s2">detect$1</span><span class="s3">,</span>
    <span class="s3">findLimit: </span><span class="s2">detectLimit$1</span><span class="s3">,</span>
    <span class="s3">findSeries: </span><span class="s2">detectSeries$1</span><span class="s3">,</span>
    <span class="s3">flatMap: </span><span class="s2">concat$1</span><span class="s3">,</span>
    <span class="s3">flatMapLimit: </span><span class="s2">concatLimit$1</span><span class="s3">,</span>
    <span class="s3">flatMapSeries: </span><span class="s2">concatSeries$1</span><span class="s3">,</span>
    <span class="s3">forEach: </span><span class="s2">each</span><span class="s3">,</span>
    <span class="s3">forEachSeries: </span><span class="s2">eachSeries$1</span><span class="s3">,</span>
    <span class="s3">forEachLimit: </span><span class="s2">eachLimit$2</span><span class="s3">,</span>
    <span class="s3">forEachOf: </span><span class="s2">eachOf$1</span><span class="s3">,</span>
    <span class="s3">forEachOfSeries: </span><span class="s2">eachOfSeries$1</span><span class="s3">,</span>
    <span class="s3">forEachOfLimit: </span><span class="s2">eachOfLimit$2</span><span class="s3">,</span>
    <span class="s3">inject: </span><span class="s2">reduce$1</span><span class="s3">,</span>
    <span class="s3">foldl: </span><span class="s2">reduce$1</span><span class="s3">,</span>
    <span class="s3">foldr: </span><span class="s2">reduceRight</span><span class="s3">,</span>
    <span class="s3">select: </span><span class="s2">filter$1</span><span class="s3">,</span>
    <span class="s3">selectLimit: </span><span class="s2">filterLimit$1</span><span class="s3">,</span>
    <span class="s3">selectSeries: </span><span class="s2">filterSeries$1</span><span class="s3">,</span>
    <span class="s3">wrapSync: </span><span class="s2">asyncify</span><span class="s3">,</span>
    <span class="s3">during: </span><span class="s2">whilst$1</span><span class="s3">,</span>
    <span class="s3">doDuring: </span><span class="s2">doWhilst$1</span>
<span class="s3">};</span>

<span class="s1">export default </span><span class="s2">index</span><span class="s3">;</span>
<span class="s1">export </span><span class="s3">{ </span><span class="s2">apply</span><span class="s3">, </span><span class="s2">applyEach$1 </span><span class="s1">as </span><span class="s2">applyEach</span><span class="s3">, </span><span class="s2">applyEachSeries</span><span class="s3">, </span><span class="s2">asyncify</span><span class="s3">, </span><span class="s2">auto</span><span class="s3">, </span><span class="s2">autoInject</span><span class="s3">, </span><span class="s2">cargo</span><span class="s3">, </span><span class="s2">cargo$1 </span><span class="s1">as </span><span class="s2">cargoQueue</span><span class="s3">, </span><span class="s2">compose</span><span class="s3">, </span><span class="s2">concat$1 </span><span class="s1">as </span><span class="s2">concat</span><span class="s3">, </span><span class="s2">concatLimit$1 </span><span class="s1">as </span><span class="s2">concatLimit</span><span class="s3">, </span><span class="s2">concatSeries$1 </span><span class="s1">as </span><span class="s2">concatSeries</span><span class="s3">, </span><span class="s2">constant</span><span class="s3">, </span><span class="s2">detect$1 </span><span class="s1">as </span><span class="s2">detect</span><span class="s3">, </span><span class="s2">detectLimit$1 </span><span class="s1">as </span><span class="s2">detectLimit</span><span class="s3">, </span><span class="s2">detectSeries$1 </span><span class="s1">as </span><span class="s2">detectSeries</span><span class="s3">, </span><span class="s2">dir</span><span class="s3">, </span><span class="s2">doUntil</span><span class="s3">, </span><span class="s2">doWhilst$1 </span><span class="s1">as </span><span class="s2">doWhilst</span><span class="s3">, </span><span class="s2">each</span><span class="s3">, </span><span class="s2">eachLimit$2 </span><span class="s1">as </span><span class="s2">eachLimit</span><span class="s3">, </span><span class="s2">eachOf$1 </span><span class="s1">as </span><span class="s2">eachOf</span><span class="s3">, </span><span class="s2">eachOfLimit$2 </span><span class="s1">as </span><span class="s2">eachOfLimit</span><span class="s3">, </span><span class="s2">eachOfSeries$1 </span><span class="s1">as </span><span class="s2">eachOfSeries</span><span class="s3">, </span><span class="s2">eachSeries$1 </span><span class="s1">as </span><span class="s2">eachSeries</span><span class="s3">, </span><span class="s2">ensureAsync</span><span class="s3">, </span><span class="s2">every$1 </span><span class="s1">as </span><span class="s2">every</span><span class="s3">, </span><span class="s2">everyLimit$1 </span><span class="s1">as </span><span class="s2">everyLimit</span><span class="s3">, </span><span class="s2">everySeries$1 </span><span class="s1">as </span><span class="s2">everySeries</span><span class="s3">, </span><span class="s2">filter$1 </span><span class="s1">as </span><span class="s2">filter</span><span class="s3">, </span><span class="s2">filterLimit$1 </span><span class="s1">as </span><span class="s2">filterLimit</span><span class="s3">, </span><span class="s2">filterSeries$1 </span><span class="s1">as </span><span class="s2">filterSeries</span><span class="s3">, </span><span class="s2">forever$1 </span><span class="s1">as </span><span class="s2">forever</span><span class="s3">, </span><span class="s2">groupBy</span><span class="s3">, </span><span class="s2">groupByLimit$1 </span><span class="s1">as </span><span class="s2">groupByLimit</span><span class="s3">, </span><span class="s2">groupBySeries</span><span class="s3">, </span><span class="s2">log</span><span class="s3">, </span><span class="s2">map$1 </span><span class="s1">as </span><span class="s2">map</span><span class="s3">, </span><span class="s2">mapLimit$1 </span><span class="s1">as </span><span class="s2">mapLimit</span><span class="s3">, </span><span class="s2">mapSeries$1 </span><span class="s1">as </span><span class="s2">mapSeries</span><span class="s3">, </span><span class="s2">mapValues</span><span class="s3">, </span><span class="s2">mapValuesLimit$1 </span><span class="s1">as </span><span class="s2">mapValuesLimit</span><span class="s3">, </span><span class="s2">mapValuesSeries</span><span class="s3">, </span><span class="s2">memoize</span><span class="s3">, </span><span class="s2">nextTick</span><span class="s3">, </span><span class="s2">parallel$1 </span><span class="s1">as </span><span class="s2">parallel</span><span class="s3">, </span><span class="s2">parallelLimit</span><span class="s3">, </span><span class="s2">priorityQueue</span><span class="s3">, </span><span class="s2">queue$1 </span><span class="s1">as </span><span class="s2">queue</span><span class="s3">, </span><span class="s2">race$1 </span><span class="s1">as </span><span class="s2">race</span><span class="s3">, </span><span class="s2">reduce$1 </span><span class="s1">as </span><span class="s2">reduce</span><span class="s3">, </span><span class="s2">reduceRight</span><span class="s3">, </span><span class="s2">reflect</span><span class="s3">, </span><span class="s2">reflectAll</span><span class="s3">, </span><span class="s2">reject$2 </span><span class="s1">as </span><span class="s2">reject</span><span class="s3">, </span><span class="s2">rejectLimit$1 </span><span class="s1">as </span><span class="s2">rejectLimit</span><span class="s3">, </span><span class="s2">rejectSeries$1 </span><span class="s1">as </span><span class="s2">rejectSeries</span><span class="s3">, </span><span class="s2">retry</span><span class="s3">, </span><span class="s2">retryable</span><span class="s3">, </span><span class="s2">seq</span><span class="s3">, </span><span class="s2">series</span><span class="s3">, </span><span class="s2">setImmediate$1 </span><span class="s1">as </span><span class="s2">setImmediate</span><span class="s3">, </span><span class="s2">some$1 </span><span class="s1">as </span><span class="s2">some</span><span class="s3">, </span><span class="s2">someLimit$1 </span><span class="s1">as </span><span class="s2">someLimit</span><span class="s3">, </span><span class="s2">someSeries$1 </span><span class="s1">as </span><span class="s2">someSeries</span><span class="s3">, </span><span class="s2">sortBy$1 </span><span class="s1">as </span><span class="s2">sortBy</span><span class="s3">, </span><span class="s2">timeout</span><span class="s3">, </span><span class="s2">times</span><span class="s3">, </span><span class="s2">timesLimit</span><span class="s3">, </span><span class="s2">timesSeries</span><span class="s3">, </span><span class="s2">transform</span><span class="s3">, </span><span class="s2">tryEach$1 </span><span class="s1">as </span><span class="s2">tryEach</span><span class="s3">, </span><span class="s2">unmemoize</span><span class="s3">, </span><span class="s2">until</span><span class="s3">, </span><span class="s2">waterfall$1 </span><span class="s1">as </span><span class="s2">waterfall</span><span class="s3">, </span><span class="s2">whilst$1 </span><span class="s1">as </span><span class="s2">whilst</span><span class="s3">, </span><span class="s2">every$1 </span><span class="s1">as </span><span class="s2">all</span><span class="s3">, </span><span class="s2">everyLimit$1 </span><span class="s1">as </span><span class="s2">allLimit</span><span class="s3">, </span><span class="s2">everySeries$1 </span><span class="s1">as </span><span class="s2">allSeries</span><span class="s3">, </span><span class="s2">some$1 </span><span class="s1">as </span><span class="s2">any</span><span class="s3">, </span><span class="s2">someLimit$1 </span><span class="s1">as </span><span class="s2">anyLimit</span><span class="s3">, </span><span class="s2">someSeries$1 </span><span class="s1">as </span><span class="s2">anySeries</span><span class="s3">, </span><span class="s2">detect$1 </span><span class="s1">as </span><span class="s2">find</span><span class="s3">, </span><span class="s2">detectLimit$1 </span><span class="s1">as </span><span class="s2">findLimit</span><span class="s3">, </span><span class="s2">detectSeries$1 </span><span class="s1">as </span><span class="s2">findSeries</span><span class="s3">, </span><span class="s2">concat$1 </span><span class="s1">as </span><span class="s2">flatMap</span><span class="s3">, </span><span class="s2">concatLimit$1 </span><span class="s1">as </span><span class="s2">flatMapLimit</span><span class="s3">, </span><span class="s2">concatSeries$1 </span><span class="s1">as </span><span class="s2">flatMapSeries</span><span class="s3">, </span><span class="s2">each </span><span class="s1">as </span><span class="s2">forEach</span><span class="s3">, </span><span class="s2">eachSeries$1 </span><span class="s1">as </span><span class="s2">forEachSeries</span><span class="s3">, </span><span class="s2">eachLimit$2 </span><span class="s1">as </span><span class="s2">forEachLimit</span><span class="s3">, </span><span class="s2">eachOf$1 </span><span class="s1">as </span><span class="s2">forEachOf</span><span class="s3">, </span><span class="s2">eachOfSeries$1 </span><span class="s1">as </span><span class="s2">forEachOfSeries</span><span class="s3">, </span><span class="s2">eachOfLimit$2 </span><span class="s1">as </span><span class="s2">forEachOfLimit</span><span class="s3">, </span><span class="s2">reduce$1 </span><span class="s1">as </span><span class="s2">inject</span><span class="s3">, </span><span class="s2">reduce$1 </span><span class="s1">as </span><span class="s2">foldl</span><span class="s3">, </span><span class="s2">reduceRight </span><span class="s1">as </span><span class="s2">foldr</span><span class="s3">, </span><span class="s2">filter$1 </span><span class="s1">as </span><span class="s2">select</span><span class="s3">, </span><span class="s2">filterLimit$1 </span><span class="s1">as </span><span class="s2">selectLimit</span><span class="s3">, </span><span class="s2">filterSeries$1 </span><span class="s1">as </span><span class="s2">selectSeries</span><span class="s3">, </span><span class="s2">asyncify </span><span class="s1">as </span><span class="s2">wrapSync</span><span class="s3">, </span><span class="s2">whilst$1 </span><span class="s1">as </span><span class="s2">during</span><span class="s3">, </span><span class="s2">doWhilst$1 </span><span class="s1">as </span><span class="s2">doDuring </span><span class="s3">};</span>
</pre>
</body>
</html>
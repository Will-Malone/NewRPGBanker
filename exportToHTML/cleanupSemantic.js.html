<html>
<head>
<title>cleanupSemantic.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cleanupSemantic.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">'__esModule'</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.cleanupSemantic =</span>
  <span class="s1">exports.Diff =</span>
  <span class="s1">exports.DIFF_INSERT =</span>
  <span class="s1">exports.DIFF_EQUAL =</span>
  <span class="s1">exports.DIFF_DELETE =</span>
    <span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s4">/** 
 * Diff Match and Patch 
 * Copyright 2018 The diff-match-patch Authors. 
 * https://github.com/google/diff-match-patch 
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0 
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License. 
 */</span>

<span class="s4">/** 
 * @fileoverview Computes the difference between two texts to create a patch. 
 * Applies the patch onto another text, allowing for errors. 
 * @author fraser@google.com (Neil Fraser) 
 */</span>

<span class="s4">/** 
 * CHANGES by pedrottimark to diff_match_patch_uncompressed.ts file: 
 * 
 * 1. Delete anything not needed to use diff_cleanupSemantic method 
 * 2. Convert from prototype properties to var declarations 
 * 3. Convert Diff to class from constructor and prototype 
 * 4. Add type annotations for arguments and return values 
 * 5. Add exports 
 */</span>

<span class="s4">/** 
 * The data structure representing a diff is an array of tuples: 
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']] 
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.' 
 */</span>
<span class="s2">var </span><span class="s1">DIFF_DELETE = -</span><span class="s3">1</span><span class="s1">;</span>
<span class="s1">exports.DIFF_DELETE = DIFF_DELETE;</span>
<span class="s2">var </span><span class="s1">DIFF_INSERT = </span><span class="s3">1</span><span class="s1">;</span>
<span class="s1">exports.DIFF_INSERT = DIFF_INSERT;</span>
<span class="s2">var </span><span class="s1">DIFF_EQUAL = </span><span class="s3">0</span><span class="s1">;</span>

<span class="s4">/** 
 * Class representing one diff tuple. 
 * Attempts to look like a two-element array (which is what this used to be). 
 * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL. 
 * @param {string} text Text to be deleted, inserted, or retained. 
 * @constructor 
 */</span>
<span class="s1">exports.DIFF_EQUAL = DIFF_EQUAL;</span>
<span class="s1">class Diff {</span>
  <span class="s3">0</span><span class="s1">;</span>
  <span class="s3">1</span><span class="s1">;</span>
  <span class="s1">constructor(op, text) {</span>
    <span class="s2">this</span><span class="s1">[</span><span class="s3">0</span><span class="s1">] = op;</span>
    <span class="s2">this</span><span class="s1">[</span><span class="s3">1</span><span class="s1">] = text;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">/** 
 * Determine the common prefix of two strings. 
 * @param {string} text1 First string. 
 * @param {string} text2 Second string. 
 * @return {number} The number of characters common to the start of each 
 *     string. 
 */</span>
<span class="s1">exports.Diff = Diff;</span>
<span class="s2">var </span><span class="s1">diff_commonPrefix = </span><span class="s2">function </span><span class="s1">(text1, text2) {</span>
  <span class="s4">// Quick check for common null cases.</span>
  <span class="s2">if </span><span class="s1">(!text1 || !text2 || text1.charAt(</span><span class="s3">0</span><span class="s1">) != text2.charAt(</span><span class="s3">0</span><span class="s1">)) {</span>
    <span class="s2">return </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s4">// Binary search.</span>
  <span class="s4">// Performance analysis: https://neil.fraser.name/news/2007/10/09/</span>
  <span class="s2">var </span><span class="s1">pointermin = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">pointermax = Math.min(text1.length, text2.length);</span>
  <span class="s2">var </span><span class="s1">pointermid = pointermax;</span>
  <span class="s2">var </span><span class="s1">pointerstart = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s2">while </span><span class="s1">(pointermin &lt; pointermid) {</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s1">text1.substring(pointerstart, pointermid) ==</span>
      <span class="s1">text2.substring(pointerstart, pointermid)</span>
    <span class="s1">) {</span>
      <span class="s1">pointermin = pointermid;</span>
      <span class="s1">pointerstart = pointermin;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">pointermax = pointermid;</span>
    <span class="s1">}</span>
    <span class="s1">pointermid = Math.floor((pointermax - pointermin) / </span><span class="s3">2 </span><span class="s1">+ pointermin);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">pointermid;</span>
<span class="s1">};</span>

<span class="s4">/** 
 * Determine the common suffix of two strings. 
 * @param {string} text1 First string. 
 * @param {string} text2 Second string. 
 * @return {number} The number of characters common to the end of each string. 
 */</span>
<span class="s2">var </span><span class="s1">diff_commonSuffix = </span><span class="s2">function </span><span class="s1">(text1, text2) {</span>
  <span class="s4">// Quick check for common null cases.</span>
  <span class="s2">if </span><span class="s1">(</span>
    <span class="s1">!text1 ||</span>
    <span class="s1">!text2 ||</span>
    <span class="s1">text1.charAt(text1.length - </span><span class="s3">1</span><span class="s1">) != text2.charAt(text2.length - </span><span class="s3">1</span><span class="s1">)</span>
  <span class="s1">) {</span>
    <span class="s2">return </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s4">// Binary search.</span>
  <span class="s4">// Performance analysis: https://neil.fraser.name/news/2007/10/09/</span>
  <span class="s2">var </span><span class="s1">pointermin = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">pointermax = Math.min(text1.length, text2.length);</span>
  <span class="s2">var </span><span class="s1">pointermid = pointermax;</span>
  <span class="s2">var </span><span class="s1">pointerend = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s2">while </span><span class="s1">(pointermin &lt; pointermid) {</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s1">text1.substring(text1.length - pointermid, text1.length - pointerend) ==</span>
      <span class="s1">text2.substring(text2.length - pointermid, text2.length - pointerend)</span>
    <span class="s1">) {</span>
      <span class="s1">pointermin = pointermid;</span>
      <span class="s1">pointerend = pointermin;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">pointermax = pointermid;</span>
    <span class="s1">}</span>
    <span class="s1">pointermid = Math.floor((pointermax - pointermin) / </span><span class="s3">2 </span><span class="s1">+ pointermin);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">pointermid;</span>
<span class="s1">};</span>

<span class="s4">/** 
 * Determine if the suffix of one string is the prefix of another. 
 * @param {string} text1 First string. 
 * @param {string} text2 Second string. 
 * @return {number} The number of characters common to the end of the first 
 *     string and the start of the second string. 
 * @private 
 */</span>
<span class="s2">var </span><span class="s1">diff_commonOverlap_ = </span><span class="s2">function </span><span class="s1">(text1, text2) {</span>
  <span class="s4">// Cache the text lengths to prevent multiple calls.</span>
  <span class="s2">var </span><span class="s1">text1_length = text1.length;</span>
  <span class="s2">var </span><span class="s1">text2_length = text2.length;</span>
  <span class="s4">// Eliminate the null case.</span>
  <span class="s2">if </span><span class="s1">(text1_length == </span><span class="s3">0 </span><span class="s1">|| text2_length == </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s4">// Truncate the longer string.</span>
  <span class="s2">if </span><span class="s1">(text1_length &gt; text2_length) {</span>
    <span class="s1">text1 = text1.substring(text1_length - text2_length);</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(text1_length &lt; text2_length) {</span>
    <span class="s1">text2 = text2.substring(</span><span class="s3">0</span><span class="s1">, text1_length);</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">text_length = Math.min(text1_length, text2_length);</span>
  <span class="s4">// Quick check for the worst case.</span>
  <span class="s2">if </span><span class="s1">(text1 == text2) {</span>
    <span class="s2">return </span><span class="s1">text_length;</span>
  <span class="s1">}</span>

  <span class="s4">// Start by looking for a single character match</span>
  <span class="s4">// and increase length until no match is found.</span>
  <span class="s4">// Performance analysis: https://neil.fraser.name/news/2010/11/04/</span>
  <span class="s2">var </span><span class="s1">best = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">length = </span><span class="s3">1</span><span class="s1">;</span>
  <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">var </span><span class="s1">pattern = text1.substring(text_length - length);</span>
    <span class="s2">var </span><span class="s1">found = text2.indexOf(pattern);</span>
    <span class="s2">if </span><span class="s1">(found == -</span><span class="s3">1</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">best;</span>
    <span class="s1">}</span>
    <span class="s1">length += found;</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s1">found == </span><span class="s3">0 </span><span class="s1">||</span>
      <span class="s1">text1.substring(text_length - length) == text2.substring(</span><span class="s3">0</span><span class="s1">, length)</span>
    <span class="s1">) {</span>
      <span class="s1">best = length;</span>
      <span class="s1">length++;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s4">/** 
 * Reduce the number of edits by eliminating semantically trivial equalities. 
 * @param {!Array.&lt;!diff_match_patch.Diff&gt;} diffs Array of diff tuples. 
 */</span>
<span class="s2">var </span><span class="s1">diff_cleanupSemantic = </span><span class="s2">function </span><span class="s1">(diffs) {</span>
  <span class="s2">var </span><span class="s1">changes = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">equalities = []; </span><span class="s4">// Stack of indices where equalities are found.</span>
  <span class="s2">var </span><span class="s1">equalitiesLength = </span><span class="s3">0</span><span class="s1">; </span><span class="s4">// Keeping our own length var is faster in JS.</span>
  <span class="s4">/** @type {?string} */</span>
  <span class="s2">var </span><span class="s1">lastEquality = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s4">// Always equal to diffs[equalities[equalitiesLength - 1]][1]</span>
  <span class="s2">var </span><span class="s1">pointer = </span><span class="s3">0</span><span class="s1">; </span><span class="s4">// Index of current position.</span>
  <span class="s4">// Number of characters that changed prior to the equality.</span>
  <span class="s2">var </span><span class="s1">length_insertions1 = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">length_deletions1 = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s4">// Number of characters that changed after the equality.</span>
  <span class="s2">var </span><span class="s1">length_insertions2 = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">length_deletions2 = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s2">while </span><span class="s1">(pointer &lt; diffs.length) {</span>
    <span class="s2">if </span><span class="s1">(diffs[pointer][</span><span class="s3">0</span><span class="s1">] == DIFF_EQUAL) {</span>
      <span class="s4">// Equality found.</span>
      <span class="s1">equalities[equalitiesLength++] = pointer;</span>
      <span class="s1">length_insertions1 = length_insertions2;</span>
      <span class="s1">length_deletions1 = length_deletions2;</span>
      <span class="s1">length_insertions2 = </span><span class="s3">0</span><span class="s1">;</span>
      <span class="s1">length_deletions2 = </span><span class="s3">0</span><span class="s1">;</span>
      <span class="s1">lastEquality = diffs[pointer][</span><span class="s3">1</span><span class="s1">];</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s4">// An insertion or deletion.</span>
      <span class="s2">if </span><span class="s1">(diffs[pointer][</span><span class="s3">0</span><span class="s1">] == DIFF_INSERT) {</span>
        <span class="s1">length_insertions2 += diffs[pointer][</span><span class="s3">1</span><span class="s1">].length;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">length_deletions2 += diffs[pointer][</span><span class="s3">1</span><span class="s1">].length;</span>
      <span class="s1">}</span>
      <span class="s4">// Eliminate an equality that is smaller or equal to the edits on both</span>
      <span class="s4">// sides of it.</span>
      <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">lastEquality &amp;&amp;</span>
        <span class="s1">lastEquality.length &lt;=</span>
          <span class="s1">Math.max(length_insertions1, length_deletions1) &amp;&amp;</span>
        <span class="s1">lastEquality.length &lt;= Math.max(length_insertions2, length_deletions2)</span>
      <span class="s1">) {</span>
        <span class="s4">// Duplicate record.</span>
        <span class="s1">diffs.splice(</span>
          <span class="s1">equalities[equalitiesLength - </span><span class="s3">1</span><span class="s1">],</span>
          <span class="s3">0</span><span class="s1">,</span>
          <span class="s2">new </span><span class="s1">Diff(DIFF_DELETE, lastEquality)</span>
        <span class="s1">);</span>
        <span class="s4">// Change second copy to insert.</span>
        <span class="s1">diffs[equalities[equalitiesLength - </span><span class="s3">1</span><span class="s1">] + </span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] = DIFF_INSERT;</span>
        <span class="s4">// Throw away the equality we just deleted.</span>
        <span class="s1">equalitiesLength--;</span>
        <span class="s4">// Throw away the previous equality (it needs to be reevaluated).</span>
        <span class="s1">equalitiesLength--;</span>
        <span class="s1">pointer = equalitiesLength &gt; </span><span class="s3">0 </span><span class="s1">? equalities[equalitiesLength - </span><span class="s3">1</span><span class="s1">] : -</span><span class="s3">1</span><span class="s1">;</span>
        <span class="s1">length_insertions1 = </span><span class="s3">0</span><span class="s1">; </span><span class="s4">// Reset the counters.</span>
        <span class="s1">length_deletions1 = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s1">length_insertions2 = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s1">length_deletions2 = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s1">lastEquality = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">changes = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">pointer++;</span>
  <span class="s1">}</span>

  <span class="s4">// Normalize the diff.</span>
  <span class="s2">if </span><span class="s1">(changes) {</span>
    <span class="s1">diff_cleanupMerge(diffs);</span>
  <span class="s1">}</span>
  <span class="s1">diff_cleanupSemanticLossless(diffs);</span>

  <span class="s4">// Find any overlaps between deletions and insertions.</span>
  <span class="s4">// e.g: &lt;del&gt;abcxxx&lt;/del&gt;&lt;ins&gt;xxxdef&lt;/ins&gt;</span>
  <span class="s4">//   -&gt; &lt;del&gt;abc&lt;/del&gt;xxx&lt;ins&gt;def&lt;/ins&gt;</span>
  <span class="s4">// e.g: &lt;del&gt;xxxabc&lt;/del&gt;&lt;ins&gt;defxxx&lt;/ins&gt;</span>
  <span class="s4">//   -&gt; &lt;ins&gt;def&lt;/ins&gt;xxx&lt;del&gt;abc&lt;/del&gt;</span>
  <span class="s4">// Only extract an overlap if it is as big as the edit ahead or behind it.</span>
  <span class="s1">pointer = </span><span class="s3">1</span><span class="s1">;</span>
  <span class="s2">while </span><span class="s1">(pointer &lt; diffs.length) {</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s1">diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == DIFF_DELETE &amp;&amp;</span>
      <span class="s1">diffs[pointer][</span><span class="s3">0</span><span class="s1">] == DIFF_INSERT</span>
    <span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">deletion = diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">];</span>
      <span class="s2">var </span><span class="s1">insertion = diffs[pointer][</span><span class="s3">1</span><span class="s1">];</span>
      <span class="s2">var </span><span class="s1">overlap_length1 = diff_commonOverlap_(deletion, insertion);</span>
      <span class="s2">var </span><span class="s1">overlap_length2 = diff_commonOverlap_(insertion, deletion);</span>
      <span class="s2">if </span><span class="s1">(overlap_length1 &gt;= overlap_length2) {</span>
        <span class="s2">if </span><span class="s1">(</span>
          <span class="s1">overlap_length1 &gt;= deletion.length / </span><span class="s3">2 </span><span class="s1">||</span>
          <span class="s1">overlap_length1 &gt;= insertion.length / </span><span class="s3">2</span>
        <span class="s1">) {</span>
          <span class="s4">// Overlap found.  Insert an equality and trim the surrounding edits.</span>
          <span class="s1">diffs.splice(</span>
            <span class="s1">pointer,</span>
            <span class="s3">0</span><span class="s1">,</span>
            <span class="s2">new </span><span class="s1">Diff(DIFF_EQUAL, insertion.substring(</span><span class="s3">0</span><span class="s1">, overlap_length1))</span>
          <span class="s1">);</span>
          <span class="s1">diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">] = deletion.substring(</span>
            <span class="s3">0</span><span class="s1">,</span>
            <span class="s1">deletion.length - overlap_length1</span>
          <span class="s1">);</span>
          <span class="s1">diffs[pointer + </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">] = insertion.substring(overlap_length1);</span>
          <span class="s1">pointer++;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(</span>
          <span class="s1">overlap_length2 &gt;= deletion.length / </span><span class="s3">2 </span><span class="s1">||</span>
          <span class="s1">overlap_length2 &gt;= insertion.length / </span><span class="s3">2</span>
        <span class="s1">) {</span>
          <span class="s4">// Reverse overlap found.</span>
          <span class="s4">// Insert an equality and swap and trim the surrounding edits.</span>
          <span class="s1">diffs.splice(</span>
            <span class="s1">pointer,</span>
            <span class="s3">0</span><span class="s1">,</span>
            <span class="s2">new </span><span class="s1">Diff(DIFF_EQUAL, deletion.substring(</span><span class="s3">0</span><span class="s1">, overlap_length2))</span>
          <span class="s1">);</span>
          <span class="s1">diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] = DIFF_INSERT;</span>
          <span class="s1">diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">] = insertion.substring(</span>
            <span class="s3">0</span><span class="s1">,</span>
            <span class="s1">insertion.length - overlap_length2</span>
          <span class="s1">);</span>
          <span class="s1">diffs[pointer + </span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] = DIFF_DELETE;</span>
          <span class="s1">diffs[pointer + </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">] = deletion.substring(overlap_length2);</span>
          <span class="s1">pointer++;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">pointer++;</span>
    <span class="s1">}</span>
    <span class="s1">pointer++;</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s4">/** 
 * Look for single edits surrounded on both sides by equalities 
 * which can be shifted sideways to align the edit to a word boundary. 
 * e.g: The c&lt;ins&gt;at c&lt;/ins&gt;ame. -&gt; The &lt;ins&gt;cat &lt;/ins&gt;came. 
 * @param {!Array.&lt;!diff_match_patch.Diff&gt;} diffs Array of diff tuples. 
 */</span>
<span class="s1">exports.cleanupSemantic = diff_cleanupSemantic;</span>
<span class="s2">var </span><span class="s1">diff_cleanupSemanticLossless = </span><span class="s2">function </span><span class="s1">(diffs) {</span>
  <span class="s4">/** 
   * Given two strings, compute a score representing whether the internal 
   * boundary falls on logical boundaries. 
   * Scores range from 6 (best) to 0 (worst). 
   * Closure, but does not reference any external variables. 
   * @param {string} one First string. 
   * @param {string} two Second string. 
   * @return {number} The score. 
   * @private 
   */</span>
  <span class="s2">function </span><span class="s1">diff_cleanupSemanticScore_(one, two) {</span>
    <span class="s2">if </span><span class="s1">(!one || !two) {</span>
      <span class="s4">// Edges are the best.</span>
      <span class="s2">return </span><span class="s3">6</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s4">// Each port of this function behaves slightly differently due to</span>
    <span class="s4">// subtle differences in each language's definition of things like</span>
    <span class="s4">// 'whitespace'.  Since this function's purpose is largely cosmetic,</span>
    <span class="s4">// the choice has been made to use each language's native features</span>
    <span class="s4">// rather than force total conformity.</span>
    <span class="s2">var </span><span class="s1">char1 = one.charAt(one.length - </span><span class="s3">1</span><span class="s1">);</span>
    <span class="s2">var </span><span class="s1">char2 = two.charAt(</span><span class="s3">0</span><span class="s1">);</span>
    <span class="s2">var </span><span class="s1">nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);</span>
    <span class="s2">var </span><span class="s1">nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);</span>
    <span class="s2">var </span><span class="s1">whitespace1 = nonAlphaNumeric1 &amp;&amp; char1.match(whitespaceRegex_);</span>
    <span class="s2">var </span><span class="s1">whitespace2 = nonAlphaNumeric2 &amp;&amp; char2.match(whitespaceRegex_);</span>
    <span class="s2">var </span><span class="s1">lineBreak1 = whitespace1 &amp;&amp; char1.match(linebreakRegex_);</span>
    <span class="s2">var </span><span class="s1">lineBreak2 = whitespace2 &amp;&amp; char2.match(linebreakRegex_);</span>
    <span class="s2">var </span><span class="s1">blankLine1 = lineBreak1 &amp;&amp; one.match(blanklineEndRegex_);</span>
    <span class="s2">var </span><span class="s1">blankLine2 = lineBreak2 &amp;&amp; two.match(blanklineStartRegex_);</span>
    <span class="s2">if </span><span class="s1">(blankLine1 || blankLine2) {</span>
      <span class="s4">// Five points for blank lines.</span>
      <span class="s2">return </span><span class="s3">5</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(lineBreak1 || lineBreak2) {</span>
      <span class="s4">// Four points for line breaks.</span>
      <span class="s2">return </span><span class="s3">4</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(nonAlphaNumeric1 &amp;&amp; !whitespace1 &amp;&amp; whitespace2) {</span>
      <span class="s4">// Three points for end of sentences.</span>
      <span class="s2">return </span><span class="s3">3</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(whitespace1 || whitespace2) {</span>
      <span class="s4">// Two points for whitespace.</span>
      <span class="s2">return </span><span class="s3">2</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(nonAlphaNumeric1 || nonAlphaNumeric2) {</span>
      <span class="s4">// One point for non-alphanumeric.</span>
      <span class="s2">return </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">pointer = </span><span class="s3">1</span><span class="s1">;</span>
  <span class="s4">// Intentionally ignore the first and last element (don't need checking).</span>
  <span class="s2">while </span><span class="s1">(pointer &lt; diffs.length - </span><span class="s3">1</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s1">diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == DIFF_EQUAL &amp;&amp;</span>
      <span class="s1">diffs[pointer + </span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == DIFF_EQUAL</span>
    <span class="s1">) {</span>
      <span class="s4">// This is a single edit surrounded by equalities.</span>
      <span class="s2">var </span><span class="s1">equality1 = diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">];</span>
      <span class="s2">var </span><span class="s1">edit = diffs[pointer][</span><span class="s3">1</span><span class="s1">];</span>
      <span class="s2">var </span><span class="s1">equality2 = diffs[pointer + </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">];</span>

      <span class="s4">// First, shift the edit as far left as possible.</span>
      <span class="s2">var </span><span class="s1">commonOffset = diff_commonSuffix(equality1, edit);</span>
      <span class="s2">if </span><span class="s1">(commonOffset) {</span>
        <span class="s2">var </span><span class="s1">commonString = edit.substring(edit.length - commonOffset);</span>
        <span class="s1">equality1 = equality1.substring(</span><span class="s3">0</span><span class="s1">, equality1.length - commonOffset);</span>
        <span class="s1">edit = commonString + edit.substring(</span><span class="s3">0</span><span class="s1">, edit.length - commonOffset);</span>
        <span class="s1">equality2 = commonString + equality2;</span>
      <span class="s1">}</span>

      <span class="s4">// Second, step character by character right, looking for the best fit.</span>
      <span class="s2">var </span><span class="s1">bestEquality1 = equality1;</span>
      <span class="s2">var </span><span class="s1">bestEdit = edit;</span>
      <span class="s2">var </span><span class="s1">bestEquality2 = equality2;</span>
      <span class="s2">var </span><span class="s1">bestScore =</span>
        <span class="s1">diff_cleanupSemanticScore_(equality1, edit) +</span>
        <span class="s1">diff_cleanupSemanticScore_(edit, equality2);</span>
      <span class="s2">while </span><span class="s1">(edit.charAt(</span><span class="s3">0</span><span class="s1">) === equality2.charAt(</span><span class="s3">0</span><span class="s1">)) {</span>
        <span class="s1">equality1 += edit.charAt(</span><span class="s3">0</span><span class="s1">);</span>
        <span class="s1">edit = edit.substring(</span><span class="s3">1</span><span class="s1">) + equality2.charAt(</span><span class="s3">0</span><span class="s1">);</span>
        <span class="s1">equality2 = equality2.substring(</span><span class="s3">1</span><span class="s1">);</span>
        <span class="s2">var </span><span class="s1">score =</span>
          <span class="s1">diff_cleanupSemanticScore_(equality1, edit) +</span>
          <span class="s1">diff_cleanupSemanticScore_(edit, equality2);</span>
        <span class="s4">// The &gt;= encourages trailing rather than leading whitespace on edits.</span>
        <span class="s2">if </span><span class="s1">(score &gt;= bestScore) {</span>
          <span class="s1">bestScore = score;</span>
          <span class="s1">bestEquality1 = equality1;</span>
          <span class="s1">bestEdit = edit;</span>
          <span class="s1">bestEquality2 = equality2;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">] != bestEquality1) {</span>
        <span class="s4">// We have an improvement, save it back to the diff.</span>
        <span class="s2">if </span><span class="s1">(bestEquality1) {</span>
          <span class="s1">diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">] = bestEquality1;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">diffs.splice(pointer - </span><span class="s3">1</span><span class="s1">, </span><span class="s3">1</span><span class="s1">);</span>
          <span class="s1">pointer--;</span>
        <span class="s1">}</span>
        <span class="s1">diffs[pointer][</span><span class="s3">1</span><span class="s1">] = bestEdit;</span>
        <span class="s2">if </span><span class="s1">(bestEquality2) {</span>
          <span class="s1">diffs[pointer + </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">] = bestEquality2;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">diffs.splice(pointer + </span><span class="s3">1</span><span class="s1">, </span><span class="s3">1</span><span class="s1">);</span>
          <span class="s1">pointer--;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">pointer++;</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s4">// Define some regex patterns for matching boundaries.</span>
<span class="s2">var </span><span class="s1">nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;</span>
<span class="s2">var </span><span class="s1">whitespaceRegex_ = /\s/;</span>
<span class="s2">var </span><span class="s1">linebreakRegex_ = /[\r\n]/;</span>
<span class="s2">var </span><span class="s1">blanklineEndRegex_ = /\n\r?\n$/;</span>
<span class="s2">var </span><span class="s1">blanklineStartRegex_ = /^\r?\n\r?\n/;</span>

<span class="s4">/** 
 * Reorder and merge like edit sections.  Merge equalities. 
 * Any edit section can move as long as it doesn't cross an equality. 
 * @param {!Array.&lt;!diff_match_patch.Diff&gt;} diffs Array of diff tuples. 
 */</span>
<span class="s2">var </span><span class="s1">diff_cleanupMerge = </span><span class="s2">function </span><span class="s1">(diffs) {</span>
  <span class="s4">// Add a dummy entry at the end.</span>
  <span class="s1">diffs.push(</span><span class="s2">new </span><span class="s1">Diff(DIFF_EQUAL, </span><span class="s0">''</span><span class="s1">));</span>
  <span class="s2">var </span><span class="s1">pointer = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">count_delete = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">count_insert = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">text_delete = </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">text_insert = </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">commonlength;</span>
  <span class="s2">while </span><span class="s1">(pointer &lt; diffs.length) {</span>
    <span class="s2">switch </span><span class="s1">(diffs[pointer][</span><span class="s3">0</span><span class="s1">]) {</span>
      <span class="s2">case </span><span class="s1">DIFF_INSERT:</span>
        <span class="s1">count_insert++;</span>
        <span class="s1">text_insert += diffs[pointer][</span><span class="s3">1</span><span class="s1">];</span>
        <span class="s1">pointer++;</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s1">DIFF_DELETE:</span>
        <span class="s1">count_delete++;</span>
        <span class="s1">text_delete += diffs[pointer][</span><span class="s3">1</span><span class="s1">];</span>
        <span class="s1">pointer++;</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s1">DIFF_EQUAL:</span>
        <span class="s4">// Upon reaching an equality, check for prior redundancies.</span>
        <span class="s2">if </span><span class="s1">(count_delete + count_insert &gt; </span><span class="s3">1</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(count_delete !== </span><span class="s3">0 </span><span class="s1">&amp;&amp; count_insert !== </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s4">// Factor out any common prefixies.</span>
            <span class="s1">commonlength = diff_commonPrefix(text_insert, text_delete);</span>
            <span class="s2">if </span><span class="s1">(commonlength !== </span><span class="s3">0</span><span class="s1">) {</span>
              <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">pointer - count_delete - count_insert &gt; </span><span class="s3">0 </span><span class="s1">&amp;&amp;</span>
                <span class="s1">diffs[pointer - count_delete - count_insert - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] ==</span>
                  <span class="s1">DIFF_EQUAL</span>
              <span class="s1">) {</span>
                <span class="s1">diffs[pointer - count_delete - count_insert - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">] +=</span>
                  <span class="s1">text_insert.substring(</span><span class="s3">0</span><span class="s1">, commonlength);</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">diffs.splice(</span>
                  <span class="s3">0</span><span class="s1">,</span>
                  <span class="s3">0</span><span class="s1">,</span>
                  <span class="s2">new </span><span class="s1">Diff(DIFF_EQUAL, text_insert.substring(</span><span class="s3">0</span><span class="s1">, commonlength))</span>
                <span class="s1">);</span>
                <span class="s1">pointer++;</span>
              <span class="s1">}</span>
              <span class="s1">text_insert = text_insert.substring(commonlength);</span>
              <span class="s1">text_delete = text_delete.substring(commonlength);</span>
            <span class="s1">}</span>
            <span class="s4">// Factor out any common suffixies.</span>
            <span class="s1">commonlength = diff_commonSuffix(text_insert, text_delete);</span>
            <span class="s2">if </span><span class="s1">(commonlength !== </span><span class="s3">0</span><span class="s1">) {</span>
              <span class="s1">diffs[pointer][</span><span class="s3">1</span><span class="s1">] =</span>
                <span class="s1">text_insert.substring(text_insert.length - commonlength) +</span>
                <span class="s1">diffs[pointer][</span><span class="s3">1</span><span class="s1">];</span>
              <span class="s1">text_insert = text_insert.substring(</span>
                <span class="s3">0</span><span class="s1">,</span>
                <span class="s1">text_insert.length - commonlength</span>
              <span class="s1">);</span>
              <span class="s1">text_delete = text_delete.substring(</span>
                <span class="s3">0</span><span class="s1">,</span>
                <span class="s1">text_delete.length - commonlength</span>
              <span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s4">// Delete the offending records and add the merged ones.</span>
          <span class="s1">pointer -= count_delete + count_insert;</span>
          <span class="s1">diffs.splice(pointer, count_delete + count_insert);</span>
          <span class="s2">if </span><span class="s1">(text_delete.length) {</span>
            <span class="s1">diffs.splice(pointer, </span><span class="s3">0</span><span class="s1">, </span><span class="s2">new </span><span class="s1">Diff(DIFF_DELETE, text_delete));</span>
            <span class="s1">pointer++;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(text_insert.length) {</span>
            <span class="s1">diffs.splice(pointer, </span><span class="s3">0</span><span class="s1">, </span><span class="s2">new </span><span class="s1">Diff(DIFF_INSERT, text_insert));</span>
            <span class="s1">pointer++;</span>
          <span class="s1">}</span>
          <span class="s1">pointer++;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(pointer !== </span><span class="s3">0 </span><span class="s1">&amp;&amp; diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == DIFF_EQUAL) {</span>
          <span class="s4">// Merge this equality with the previous one.</span>
          <span class="s1">diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">] += diffs[pointer][</span><span class="s3">1</span><span class="s1">];</span>
          <span class="s1">diffs.splice(pointer, </span><span class="s3">1</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">pointer++;</span>
        <span class="s1">}</span>
        <span class="s1">count_insert = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s1">count_delete = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s1">text_delete = </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s1">text_insert = </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(diffs[diffs.length - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">] === </span><span class="s0">''</span><span class="s1">) {</span>
    <span class="s1">diffs.pop(); </span><span class="s4">// Remove the dummy entry at the end.</span>
  <span class="s1">}</span>

  <span class="s4">// Second pass: look for single edits surrounded on both sides by equalities</span>
  <span class="s4">// which can be shifted sideways to eliminate an equality.</span>
  <span class="s4">// e.g: A&lt;ins&gt;BA&lt;/ins&gt;C -&gt; &lt;ins&gt;AB&lt;/ins&gt;AC</span>
  <span class="s2">var </span><span class="s1">changes = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">pointer = </span><span class="s3">1</span><span class="s1">;</span>
  <span class="s4">// Intentionally ignore the first and last element (don't need checking).</span>
  <span class="s2">while </span><span class="s1">(pointer &lt; diffs.length - </span><span class="s3">1</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s1">diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == DIFF_EQUAL &amp;&amp;</span>
      <span class="s1">diffs[pointer + </span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == DIFF_EQUAL</span>
    <span class="s1">) {</span>
      <span class="s4">// This is a single edit surrounded by equalities.</span>
      <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">diffs[pointer][</span><span class="s3">1</span><span class="s1">].substring(</span>
          <span class="s1">diffs[pointer][</span><span class="s3">1</span><span class="s1">].length - diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">].length</span>
        <span class="s1">) == diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]</span>
      <span class="s1">) {</span>
        <span class="s4">// Shift the edit over the previous equality.</span>
        <span class="s1">diffs[pointer][</span><span class="s3">1</span><span class="s1">] =</span>
          <span class="s1">diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">] +</span>
          <span class="s1">diffs[pointer][</span><span class="s3">1</span><span class="s1">].substring(</span>
            <span class="s3">0</span><span class="s1">,</span>
            <span class="s1">diffs[pointer][</span><span class="s3">1</span><span class="s1">].length - diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">].length</span>
          <span class="s1">);</span>
        <span class="s1">diffs[pointer + </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">] = diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">] + diffs[pointer + </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">];</span>
        <span class="s1">diffs.splice(pointer - </span><span class="s3">1</span><span class="s1">, </span><span class="s3">1</span><span class="s1">);</span>
        <span class="s1">changes = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>
        <span class="s1">diffs[pointer][</span><span class="s3">1</span><span class="s1">].substring(</span><span class="s3">0</span><span class="s1">, diffs[pointer + </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">].length) ==</span>
        <span class="s1">diffs[pointer + </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]</span>
      <span class="s1">) {</span>
        <span class="s4">// Shift the edit over the next equality.</span>
        <span class="s1">diffs[pointer - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">] += diffs[pointer + </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">];</span>
        <span class="s1">diffs[pointer][</span><span class="s3">1</span><span class="s1">] =</span>
          <span class="s1">diffs[pointer][</span><span class="s3">1</span><span class="s1">].substring(diffs[pointer + </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">].length) +</span>
          <span class="s1">diffs[pointer + </span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">];</span>
        <span class="s1">diffs.splice(pointer + </span><span class="s3">1</span><span class="s1">, </span><span class="s3">1</span><span class="s1">);</span>
        <span class="s1">changes = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">pointer++;</span>
  <span class="s1">}</span>
  <span class="s4">// If shifts were made, the diff needs reordering and another shift sweep.</span>
  <span class="s2">if </span><span class="s1">(changes) {</span>
    <span class="s1">diff_cleanupMerge(diffs);</span>
  <span class="s1">}</span>
<span class="s1">};</span>
</pre>
</body>
</html>
<html>
<head>
<title>sprintf.min.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sprintf.min.js</font>
</center></td></tr></table>
<pre><span class="s0">/*! sprintf-js | Alexandru Marasteanu &lt;hello@alexei.ro&gt; (http://alexei.ro/) | BSD-3-Clause */</span>

<span class="s1">!</span><span class="s2">function</span><span class="s1">(a){</span><span class="s2">function </span><span class="s1">b(){</span><span class="s2">var </span><span class="s1">a=arguments[</span><span class="s3">0</span><span class="s1">],c=b.cache;</span><span class="s2">return </span><span class="s1">c[a]&amp;&amp;c.hasOwnProperty(a)||(c[a]=b.parse(a)),b.format.call(</span><span class="s2">null</span><span class="s1">,c[a],arguments)}</span><span class="s2">function </span><span class="s1">c(a){</span><span class="s2">return </span><span class="s1">Object.prototype.toString.call(a).slice(</span><span class="s3">8</span><span class="s1">,-</span><span class="s3">1</span><span class="s1">).toLowerCase()}</span><span class="s2">function </span><span class="s1">d(a,b){</span><span class="s2">return </span><span class="s1">Array(b+</span><span class="s3">1</span><span class="s1">).join(a)}</span><span class="s2">var </span><span class="s1">e={not_string:/[^s]/,number:/[diefg]/,json:/[j]/,not_json:/[^j]/,text:/^[^\x25]+/,modulo:/^\x25{</span><span class="s3">2</span><span class="s1">}/,placeholder:/^\x25(?:([</span><span class="s3">1</span><span class="s1">-</span><span class="s3">9</span><span class="s1">]\d*)\$|\(([^\)]+)\))?(\+)?(</span><span class="s3">0</span><span class="s1">|</span><span class="s4">'[^$])?(-)?(</span><span class="s5">\d</span><span class="s4">+)?(?:</span><span class="s5">\.</span><span class="s4">(</span><span class="s5">\d</span><span class="s4">+))?([b-gijosuxX])/,key:/^([a-z_][a-z_</span><span class="s5">\d</span><span class="s4">]*)/i,key_access:/^</span><span class="s5">\.</span><span class="s4">([a-z_][a-z_</span><span class="s5">\d</span><span class="s4">]*)/i,index_access:/^</span><span class="s5">\[</span><span class="s4">(</span><span class="s5">\d</span><span class="s4">+)</span><span class="s5">\]</span><span class="s4">/,sign:/^[</span><span class="s5">\+\-</span><span class="s4">]/};b.format=function(a,f){var g,h,i,j,k,l,m,n=1,o=a.length,p=&quot;&quot;,q=[],r=!0,s=&quot;&quot;;for(h=0;o&gt;h;h++)if(p=c(a[h]),&quot;string&quot;===p)q[q.length]=a[h];else if(&quot;array&quot;===p){if(j=a[h],j[2])for(g=f[n],i=0;i&lt;j[2].length;i++){if(!g.hasOwnProperty(j[2][i]))throw new Error(b(&quot;[sprintf] property '</span><span class="s1">%s</span><span class="s4">' does not exist&quot;,j[2][i]));g=g[j[2][i]]}else g=j[1]?f[j[1]]:f[n++];if(&quot;function&quot;==c(g)&amp;&amp;(g=g()),e.not_string.test(j[8])&amp;&amp;e.not_json.test(j[8])&amp;&amp;&quot;number&quot;!=c(g)&amp;&amp;isNaN(g))throw new TypeError(b(&quot;[sprintf] expecting number but found %s&quot;,c(g)));switch(e.number.test(j[8])&amp;&amp;(r=g&gt;=0),j[8]){case&quot;b&quot;:g=g.toString(2);break;case&quot;c&quot;:g=String.fromCharCode(g);break;case&quot;d&quot;:case&quot;i&quot;:g=parseInt(g,10);break;case&quot;j&quot;:g=JSON.stringify(g,null,j[6]?parseInt(j[6]):0);break;case&quot;e&quot;:g=j[7]?g.toExponential(j[7]):g.toExponential();break;case&quot;f&quot;:g=j[7]?parseFloat(g).toFixed(j[7]):parseFloat(g);break;case&quot;g&quot;:g=j[7]?parseFloat(g).toPrecision(j[7]):parseFloat(g);break;case&quot;o&quot;:g=g.toString(8);break;case&quot;s&quot;:g=(g=String(g))&amp;&amp;j[7]?g.substring(0,j[7]):g;break;case&quot;u&quot;:g&gt;&gt;&gt;=0;break;case&quot;x&quot;:g=g.toString(16);break;case&quot;X&quot;:g=g.toString(16).toUpperCase()}e.json.test(j[8])?q[q.length]=g:(!e.number.test(j[8])||r&amp;&amp;!j[3]?s=&quot;&quot;:(s=r?&quot;+&quot;:&quot;-&quot;,g=g.toString().replace(e.sign,&quot;&quot;)),l=j[4]?&quot;0&quot;===j[4]?&quot;0&quot;:j[4].charAt(1):&quot; &quot;,m=j[6]-(s+g).length,k=j[6]&amp;&amp;m&gt;0?d(l,m):&quot;&quot;,q[q.length]=j[5]?s+g+k:&quot;0&quot;===l?s+k+g:k+s+g)}return q.join(&quot;&quot;)},b.cache={},b.parse=function(a){for(var b=a,c=[],d=[],f=0;b;){if(null!==(c=e.text.exec(b)))d[d.length]=c[0];else if(null!==(c=e.modulo.exec(b)))d[d.length]=&quot;%&quot;;else{if(null===(c=e.placeholder.exec(b)))throw new SyntaxError(&quot;[sprintf] unexpected placeholder&quot;);if(c[2]){f|=1;var g=[],h=c[2],i=[];if(null===(i=e.key.exec(h)))throw new SyntaxError(&quot;[sprintf] failed to parse named argument key&quot;);for(g[g.length]=i[1];&quot;&quot;!==(h=h.substring(i[0].length));)if(null!==(i=e.key_access.exec(h)))g[g.length]=i[1];else{if(null===(i=e.index_access.exec(h)))throw new SyntaxError(&quot;[sprintf] failed to parse named argument key&quot;);g[g.length]=i[1]}c[2]=g}else f|=2;if(3===f)throw new Error(&quot;[sprintf] mixing positional and named placeholders is not (yet) supported&quot;);d[d.length]=c}b=b.substring(c[0].length)}return d};var f=function(a,c,d){return d=(c||[]).slice(0),d.splice(0,0,a),b.apply(null,d)};&quot;undefined&quot;!=typeof exports?(exports.sprintf=b,exports.vsprintf=f):(a.sprintf=b,a.vsprintf=f,&quot;function&quot;==typeof define&amp;&amp;define.amd&amp;&amp;define(function(){return{sprintf:b,vsprintf:f}}))}(&quot;undefined&quot;==typeof window?this:window);</span>
<span class="s0">//# sourceMappingURL=sprintf.min.map</span></pre>
</body>
</html>
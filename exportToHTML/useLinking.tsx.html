<html>
<head>
<title>useLinking.tsx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #a9b7c6;}
.s3 { color: #6a8759;}
.s4 { color: #9876aa; font-style: italic;}
.s5 { color: #808080;}
.s6 { color: #ffc66d;}
.s7 { color: #cc7832; font-style: italic;}
.s8 { color: #6897bb; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
useLinking.tsx</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{</span>
  <span class="s2">findFocusedRoute</span><span class="s1">,</span>
  <span class="s2">getActionFromState </span><span class="s0">as </span><span class="s2">getActionFromStateDefault</span><span class="s1">,</span>
  <span class="s2">getPathFromState </span><span class="s0">as </span><span class="s2">getPathFromStateDefault</span><span class="s1">,</span>
  <span class="s2">getStateFromPath </span><span class="s0">as </span><span class="s2">getStateFromPathDefault</span><span class="s1">,</span>
  <span class="s2">NavigationContainerRef</span><span class="s1">,</span>
  <span class="s2">NavigationState</span><span class="s1">,</span>
  <span class="s2">ParamListBase</span><span class="s1">,</span>
<span class="s1">} </span><span class="s0">from </span><span class="s3">'@react-navigation/core'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s2">isEqual </span><span class="s0">from </span><span class="s3">'fast-deep-equal'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s4">* </span><span class="s0">as </span><span class="s2">React </span><span class="s0">from </span><span class="s3">'react'</span><span class="s1">;</span>

<span class="s0">import </span><span class="s2">createMemoryHistory </span><span class="s0">from </span><span class="s3">'./createMemoryHistory'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s2">ServerContext </span><span class="s0">from </span><span class="s3">'./ServerContext'</span><span class="s1">;</span>
<span class="s0">import type </span><span class="s1">{ </span><span class="s2">LinkingOptions </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'./types'</span><span class="s1">;</span>

<span class="s0">type </span><span class="s2">ResultState </span><span class="s0">= </span><span class="s2">ReturnType</span><span class="s1">&lt;</span><span class="s0">typeof </span><span class="s2">getStateFromPathDefault</span><span class="s1">&gt;;</span>

<span class="s5">/**</span>
 <span class="s5">* Find the matching navigation state that changed between 2 navigation states 
 * e.g.: a -&gt; b -&gt; c -&gt; d and a -&gt; b -&gt; c -&gt; e -&gt; f, if history in b changed, b is the matching state 
 */</span>
<span class="s0">const </span><span class="s1">findMatchingState </span><span class="s0">= </span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">NavigationState</span><span class="s1">&gt;(</span>
  <span class="s2">a</span><span class="s0">: </span><span class="s2">T </span><span class="s0">| </span><span class="s2">undefined</span><span class="s1">,</span>
  <span class="s2">b</span><span class="s0">: </span><span class="s2">T </span><span class="s0">| </span><span class="s2">undefined</span>
<span class="s1">)</span><span class="s0">: </span><span class="s1">[</span><span class="s2">T </span><span class="s0">| </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">T </span><span class="s0">| </span><span class="s2">undefined</span><span class="s1">] </span><span class="s0">=&gt; </span><span class="s1">{</span>
  <span class="s0">if </span><span class="s1">(</span><span class="s2">a </span><span class="s0">=== </span><span class="s4">undefined </span><span class="s0">|| </span><span class="s2">b </span><span class="s0">=== </span><span class="s4">undefined </span><span class="s0">|| </span><span class="s2">a</span><span class="s1">.</span><span class="s2">key </span><span class="s0">!== </span><span class="s2">b</span><span class="s1">.</span><span class="s2">key</span><span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">[</span><span class="s4">undefined</span><span class="s1">, </span><span class="s4">undefined</span><span class="s1">];</span>
  <span class="s1">}</span>

  <span class="s5">// Tab and drawer will have `history` property, but stack will have history in `routes`</span>
  <span class="s0">const </span><span class="s1">aHistoryLength </span><span class="s0">= </span><span class="s2">a</span><span class="s1">.</span><span class="s2">history </span><span class="s0">? </span><span class="s2">a</span><span class="s1">.</span><span class="s2">history</span><span class="s1">.length </span><span class="s0">: </span><span class="s2">a</span><span class="s1">.</span><span class="s2">routes</span><span class="s1">.length;</span>
  <span class="s0">const </span><span class="s1">bHistoryLength </span><span class="s0">= </span><span class="s2">b</span><span class="s1">.</span><span class="s2">history </span><span class="s0">? </span><span class="s2">b</span><span class="s1">.</span><span class="s2">history</span><span class="s1">.length </span><span class="s0">: </span><span class="s2">b</span><span class="s1">.</span><span class="s2">routes</span><span class="s1">.length;</span>

  <span class="s0">const </span><span class="s1">aRoute </span><span class="s0">= </span><span class="s2">a</span><span class="s1">.</span><span class="s2">routes</span><span class="s1">[</span><span class="s2">a</span><span class="s1">.</span><span class="s2">index</span><span class="s1">];</span>
  <span class="s0">const </span><span class="s1">bRoute </span><span class="s0">= </span><span class="s2">b</span><span class="s1">.</span><span class="s2">routes</span><span class="s1">[</span><span class="s2">b</span><span class="s1">.</span><span class="s2">index</span><span class="s1">];</span>

  <span class="s0">const </span><span class="s1">aChildState </span><span class="s0">= </span><span class="s2">aRoute</span><span class="s1">.</span><span class="s2">state </span><span class="s0">as </span><span class="s2">T </span><span class="s0">| </span><span class="s2">undefined</span><span class="s1">;</span>
  <span class="s0">const </span><span class="s1">bChildState </span><span class="s0">= </span><span class="s2">bRoute</span><span class="s1">.</span><span class="s2">state </span><span class="s0">as </span><span class="s2">T </span><span class="s0">| </span><span class="s2">undefined</span><span class="s1">;</span>

  <span class="s5">// Stop here if this is the state object that changed:</span>
  <span class="s5">// - history length is different</span>
  <span class="s5">// - focused routes are different</span>
  <span class="s5">// - one of them doesn't have child state</span>
  <span class="s5">// - child state keys are different</span>
  <span class="s0">if </span><span class="s1">(</span>
    <span class="s2">aHistoryLength </span><span class="s0">!== </span><span class="s2">bHistoryLength </span><span class="s0">||</span>
    <span class="s2">aRoute</span><span class="s1">.</span><span class="s2">key </span><span class="s0">!== </span><span class="s2">bRoute</span><span class="s1">.</span><span class="s2">key </span><span class="s0">||</span>
    <span class="s2">aChildState </span><span class="s0">=== </span><span class="s4">undefined </span><span class="s0">||</span>
    <span class="s2">bChildState </span><span class="s0">=== </span><span class="s4">undefined </span><span class="s0">||</span>
    <span class="s2">aChildState</span><span class="s1">.</span><span class="s2">key </span><span class="s0">!== </span><span class="s2">bChildState</span><span class="s1">.</span><span class="s2">key</span>
  <span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">[</span><span class="s2">a</span><span class="s1">, </span><span class="s2">b</span><span class="s1">];</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s6">findMatchingState</span><span class="s1">(</span><span class="s2">aChildState</span><span class="s1">, </span><span class="s2">bChildState</span><span class="s1">);</span>
<span class="s1">};</span>

<span class="s5">/**</span>
 <span class="s5">* Run async function in series as it's called. 
 */</span>
<span class="s0">const </span><span class="s1">series </span><span class="s0">= </span><span class="s1">(</span><span class="s6">cb</span><span class="s0">: </span><span class="s1">() </span><span class="s0">=&gt; </span><span class="s2">Promise</span><span class="s1">&lt;</span><span class="s2">void</span><span class="s1">&gt;) </span><span class="s0">=&gt; </span><span class="s1">{</span>
  <span class="s5">// Whether we're currently handling a callback</span>
  <span class="s0">let </span><span class="s1">handling </span><span class="s0">= </span><span class="s4">false</span><span class="s1">;</span>
  <span class="s0">let </span><span class="s1">queue</span><span class="s0">: </span><span class="s1">(() </span><span class="s0">=&gt; </span><span class="s2">Promise</span><span class="s1">&lt;</span><span class="s2">void</span><span class="s1">&gt;)[] </span><span class="s0">= </span><span class="s1">[];</span>

  <span class="s0">const </span><span class="s1">callback </span><span class="s0">= async </span><span class="s1">() </span><span class="s0">=&gt; </span><span class="s1">{</span>
    <span class="s0">try </span><span class="s1">{</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s2">handling</span><span class="s1">) {</span>
        <span class="s5">// If we're currently handling a previous event, wait before handling this one</span>
        <span class="s5">// Add the callback to the beginning of the queue</span>
        <span class="s2">queue</span><span class="s1">.</span><span class="s6">unshift</span><span class="s1">(</span><span class="s2">callback</span><span class="s1">);</span>
        <span class="s0">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">handling </span><span class="s0">= </span><span class="s4">true</span><span class="s1">;</span>

      <span class="s0">await </span><span class="s6">cb</span><span class="s1">();</span>
    <span class="s1">} </span><span class="s0">finally </span><span class="s1">{</span>
      <span class="s2">handling </span><span class="s0">= </span><span class="s4">false</span><span class="s1">;</span>

      <span class="s0">if </span><span class="s1">(</span><span class="s2">queue</span><span class="s1">.length) {</span>
        <span class="s5">// If we have queued items, handle the last one</span>
        <span class="s0">const </span><span class="s1">last </span><span class="s0">= </span><span class="s2">queue</span><span class="s1">.</span><span class="s6">pop</span><span class="s1">();</span>

        <span class="s6">last</span><span class="s1">?.();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s0">return </span><span class="s2">callback</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s0">let </span><span class="s1">linkingHandlers</span><span class="s0">: </span><span class="s2">Symbol</span><span class="s1">[] </span><span class="s0">= </span><span class="s1">[];</span>

<span class="s0">type </span><span class="s2">Options </span><span class="s0">= </span><span class="s2">LinkingOptions</span><span class="s1">&lt;</span><span class="s2">ParamListBase</span><span class="s1">&gt; </span><span class="s0">&amp; </span><span class="s1">{</span>
  <span class="s1">independent</span><span class="s0">?: </span><span class="s2">boolean</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s0">export default function </span><span class="s1">useLinking(</span>
  <span class="s2">ref</span><span class="s0">: </span><span class="s2">React</span><span class="s1">.</span><span class="s2">RefObject</span><span class="s1">&lt;</span><span class="s2">NavigationContainerRef</span><span class="s1">&lt;</span><span class="s2">ParamListBase</span><span class="s1">&gt;&gt;,</span>
  <span class="s1">{</span>
    <span class="s2">independent</span><span class="s1">,</span>
    <span class="s2">enabled </span><span class="s0">= </span><span class="s4">true</span><span class="s1">,</span>
    <span class="s2">config</span><span class="s1">,</span>
    <span class="s2">getStateFromPath </span><span class="s0">= </span><span class="s2">getStateFromPathDefault</span><span class="s1">,</span>
    <span class="s2">getPathFromState </span><span class="s0">= </span><span class="s2">getPathFromStateDefault</span><span class="s1">,</span>
    <span class="s2">getActionFromState </span><span class="s0">= </span><span class="s2">getActionFromStateDefault</span><span class="s1">,</span>
  <span class="s1">}</span><span class="s0">: </span><span class="s2">Options</span>
<span class="s1">) {</span>
  <span class="s2">React</span><span class="s1">.</span><span class="s6">useEffect</span><span class="s1">(() </span><span class="s0">=&gt; </span><span class="s1">{</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s2">process</span><span class="s1">.</span><span class="s2">env</span><span class="s1">.</span><span class="s2">NODE_ENV </span><span class="s0">=== </span><span class="s3">'production'</span><span class="s1">) {</span>
      <span class="s0">return </span><span class="s4">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">if </span><span class="s1">(</span><span class="s2">independent</span><span class="s1">) {</span>
      <span class="s0">return </span><span class="s4">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">if </span><span class="s1">(</span><span class="s2">enabled </span><span class="s0">!== </span><span class="s4">false </span><span class="s0">&amp;&amp; </span><span class="s2">linkingHandlers</span><span class="s1">.length) {</span>
      <span class="s2">console</span><span class="s1">.</span><span class="s6">error</span><span class="s1">(</span>
        <span class="s1">[</span>
          <span class="s3">'Looks like you have configured linking in multiple places. This is likely an error since deep links should only be handled in one place to avoid conflicts. Make sure that:'</span><span class="s1">,</span>
          <span class="s3">&quot;- You don't have multiple NavigationContainers in the app each with 'linking' enabled&quot;</span><span class="s1">,</span>
          <span class="s3">'- Only a single instance of the root component is rendered'</span><span class="s1">,</span>
        <span class="s1">]</span>
          <span class="s1">.</span><span class="s6">join</span><span class="s1">(</span><span class="s3">'</span><span class="s7">\n</span><span class="s3">'</span><span class="s1">)</span>
          <span class="s1">.</span><span class="s6">trim</span><span class="s1">()</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">const </span><span class="s1">handler </span><span class="s0">= </span><span class="s6">Symbol</span><span class="s1">();</span>

    <span class="s0">if </span><span class="s1">(</span><span class="s2">enabled </span><span class="s0">!== </span><span class="s4">false</span><span class="s1">) {</span>
      <span class="s2">linkingHandlers</span><span class="s1">.</span><span class="s6">push</span><span class="s1">(</span><span class="s2">handler</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">return </span><span class="s1">() </span><span class="s0">=&gt; </span><span class="s1">{</span>
      <span class="s0">const </span><span class="s1">index </span><span class="s0">= </span><span class="s2">linkingHandlers</span><span class="s1">.</span><span class="s6">indexOf</span><span class="s1">(</span><span class="s2">handler</span><span class="s1">);</span>

      <span class="s0">if </span><span class="s1">(</span><span class="s2">index </span><span class="s0">&gt; -</span><span class="s8">1</span><span class="s1">) {</span>
        <span class="s2">linkingHandlers</span><span class="s1">.</span><span class="s6">splice</span><span class="s1">(</span><span class="s2">index</span><span class="s1">, </span><span class="s8">1</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}, [</span><span class="s2">enabled</span><span class="s1">, </span><span class="s2">independent</span><span class="s1">]);</span>

  <span class="s0">const </span><span class="s1">[history] </span><span class="s0">= </span><span class="s2">React</span><span class="s1">.</span><span class="s6">useState</span><span class="s1">(</span><span class="s2">createMemoryHistory</span><span class="s1">);</span>

  <span class="s5">// We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners</span>
  <span class="s5">// This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`</span>
  <span class="s5">// Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect</span>
  <span class="s0">const </span><span class="s1">enabledRef </span><span class="s0">= </span><span class="s2">React</span><span class="s1">.</span><span class="s6">useRef</span><span class="s1">(</span><span class="s2">enabled</span><span class="s1">);</span>
  <span class="s0">const </span><span class="s1">configRef </span><span class="s0">= </span><span class="s2">React</span><span class="s1">.</span><span class="s6">useRef</span><span class="s1">(</span><span class="s2">config</span><span class="s1">);</span>
  <span class="s0">const </span><span class="s1">getStateFromPathRef </span><span class="s0">= </span><span class="s2">React</span><span class="s1">.</span><span class="s6">useRef</span><span class="s1">(</span><span class="s2">getStateFromPath</span><span class="s1">);</span>
  <span class="s0">const </span><span class="s1">getPathFromStateRef </span><span class="s0">= </span><span class="s2">React</span><span class="s1">.</span><span class="s6">useRef</span><span class="s1">(</span><span class="s2">getPathFromState</span><span class="s1">);</span>
  <span class="s0">const </span><span class="s1">getActionFromStateRef </span><span class="s0">= </span><span class="s2">React</span><span class="s1">.</span><span class="s6">useRef</span><span class="s1">(</span><span class="s2">getActionFromState</span><span class="s1">);</span>

  <span class="s2">React</span><span class="s1">.</span><span class="s6">useEffect</span><span class="s1">(() </span><span class="s0">=&gt; </span><span class="s1">{</span>
    <span class="s2">enabledRef</span><span class="s1">.</span><span class="s2">current </span><span class="s0">= </span><span class="s2">enabled</span><span class="s1">;</span>
    <span class="s2">configRef</span><span class="s1">.</span><span class="s2">current </span><span class="s0">= </span><span class="s2">config</span><span class="s1">;</span>
    <span class="s2">getStateFromPathRef</span><span class="s1">.</span><span class="s2">current </span><span class="s0">= </span><span class="s2">getStateFromPath</span><span class="s1">;</span>
    <span class="s2">getPathFromStateRef</span><span class="s1">.</span><span class="s2">current </span><span class="s0">= </span><span class="s2">getPathFromState</span><span class="s1">;</span>
    <span class="s2">getActionFromStateRef</span><span class="s1">.</span><span class="s2">current </span><span class="s0">= </span><span class="s2">getActionFromState</span><span class="s1">;</span>
  <span class="s1">});</span>

  <span class="s0">const </span><span class="s1">server </span><span class="s0">= </span><span class="s2">React</span><span class="s1">.</span><span class="s6">useContext</span><span class="s1">(</span><span class="s2">ServerContext</span><span class="s1">);</span>

  <span class="s0">const </span><span class="s1">getInitialState </span><span class="s0">= </span><span class="s2">React</span><span class="s1">.</span><span class="s6">useCallback</span><span class="s1">(() </span><span class="s0">=&gt; </span><span class="s1">{</span>
    <span class="s0">let </span><span class="s1">value</span><span class="s0">: </span><span class="s2">ResultState </span><span class="s0">| </span><span class="s2">undefined</span><span class="s1">;</span>

    <span class="s0">if </span><span class="s1">(</span><span class="s2">enabledRef</span><span class="s1">.</span><span class="s2">current</span><span class="s1">) {</span>
      <span class="s0">const </span><span class="s1">location </span><span class="s0">=</span>
        <span class="s2">server</span><span class="s1">?.</span><span class="s2">location </span><span class="s0">??</span>
        <span class="s1">(</span><span class="s0">typeof </span><span class="s2">window </span><span class="s0">!== </span><span class="s3">'undefined' </span><span class="s0">? </span><span class="s2">window</span><span class="s1">.</span><span class="s2">location </span><span class="s0">: </span><span class="s4">undefined</span><span class="s1">);</span>

      <span class="s0">const </span><span class="s1">path </span><span class="s0">= </span><span class="s2">location </span><span class="s0">? </span><span class="s2">location</span><span class="s1">.</span><span class="s2">pathname </span><span class="s0">+ </span><span class="s2">location</span><span class="s1">.</span><span class="s2">search </span><span class="s0">: </span><span class="s4">undefined</span><span class="s1">;</span>

      <span class="s0">if </span><span class="s1">(</span><span class="s2">path</span><span class="s1">) {</span>
        <span class="s2">value </span><span class="s0">= </span><span class="s2">getStateFromPathRef</span><span class="s1">.</span><span class="s6">current</span><span class="s1">(</span><span class="s2">path</span><span class="s1">, </span><span class="s2">configRef</span><span class="s1">.</span><span class="s2">current</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">const </span><span class="s1">thenable </span><span class="s0">= </span><span class="s1">{</span>
      <span class="s1">then(</span><span class="s6">onfulfilled</span><span class="s0">?: </span><span class="s1">(</span><span class="s2">state</span><span class="s0">: </span><span class="s2">ResultState </span><span class="s0">| </span><span class="s2">undefined</span><span class="s1">) </span><span class="s0">=&gt; </span><span class="s2">void</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">Promise.</span><span class="s6">resolve</span><span class="s1">(</span><span class="s2">onfulfilled </span><span class="s0">? </span><span class="s6">onfulfilled</span><span class="s1">(</span><span class="s2">value</span><span class="s1">) </span><span class="s0">: </span><span class="s2">value</span><span class="s1">);</span>
      <span class="s1">},</span>
      <span class="s1">catch() {</span>
        <span class="s0">return </span><span class="s2">thenable</span><span class="s1">;</span>
      <span class="s1">},</span>
    <span class="s1">};</span>

    <span class="s0">return </span><span class="s2">thenable </span><span class="s0">as </span><span class="s2">PromiseLike</span><span class="s1">&lt;</span><span class="s2">ResultState </span><span class="s0">| </span><span class="s2">undefined</span><span class="s1">&gt;;</span>
    <span class="s5">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  <span class="s1">}, []);</span>

  <span class="s0">const </span><span class="s1">previousIndexRef </span><span class="s0">= </span><span class="s2">React</span><span class="s1">.</span><span class="s6">useRef</span><span class="s1">&lt;</span><span class="s2">number </span><span class="s0">| </span><span class="s2">undefined</span><span class="s1">&gt;(</span><span class="s4">undefined</span><span class="s1">);</span>
  <span class="s0">const </span><span class="s1">previousStateRef </span><span class="s0">= </span><span class="s2">React</span><span class="s1">.</span><span class="s6">useRef</span><span class="s1">&lt;</span><span class="s2">NavigationState </span><span class="s0">| </span><span class="s2">undefined</span><span class="s1">&gt;(</span><span class="s4">undefined</span><span class="s1">);</span>
  <span class="s0">const </span><span class="s1">pendingPopStatePathRef </span><span class="s0">= </span><span class="s2">React</span><span class="s1">.</span><span class="s6">useRef</span><span class="s1">&lt;</span><span class="s2">string </span><span class="s0">| </span><span class="s2">undefined</span><span class="s1">&gt;(</span><span class="s4">undefined</span><span class="s1">);</span>

  <span class="s2">React</span><span class="s1">.</span><span class="s6">useEffect</span><span class="s1">(() </span><span class="s0">=&gt; </span><span class="s1">{</span>
    <span class="s2">previousIndexRef</span><span class="s1">.</span><span class="s2">current </span><span class="s0">= </span><span class="s2">history</span><span class="s1">.</span><span class="s2">index</span><span class="s1">;</span>

    <span class="s0">return </span><span class="s2">history</span><span class="s1">.</span><span class="s6">listen</span><span class="s1">(() </span><span class="s0">=&gt; </span><span class="s1">{</span>
      <span class="s0">const </span><span class="s1">navigation </span><span class="s0">= </span><span class="s2">ref</span><span class="s1">.</span><span class="s2">current</span><span class="s1">;</span>

      <span class="s0">if </span><span class="s1">(</span><span class="s0">!</span><span class="s2">navigation </span><span class="s0">|| !</span><span class="s2">enabled</span><span class="s1">) {</span>
        <span class="s0">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s0">const </span><span class="s1">path </span><span class="s0">= </span><span class="s2">location</span><span class="s1">.</span><span class="s2">pathname </span><span class="s0">+ </span><span class="s2">location</span><span class="s1">.</span><span class="s2">search</span><span class="s1">;</span>
      <span class="s0">const </span><span class="s1">index </span><span class="s0">= </span><span class="s2">history</span><span class="s1">.</span><span class="s2">index</span><span class="s1">;</span>

      <span class="s0">const </span><span class="s1">previousIndex </span><span class="s0">= </span><span class="s2">previousIndexRef</span><span class="s1">.</span><span class="s2">current </span><span class="s0">?? </span><span class="s8">0</span><span class="s1">;</span>

      <span class="s2">previousIndexRef</span><span class="s1">.</span><span class="s2">current </span><span class="s0">= </span><span class="s2">index</span><span class="s1">;</span>
      <span class="s2">pendingPopStatePathRef</span><span class="s1">.</span><span class="s2">current </span><span class="s0">= </span><span class="s2">path</span><span class="s1">;</span>

      <span class="s5">// When browser back/forward is clicked, we first need to check if state object for this index exists</span>
      <span class="s5">// If it does we'll reset to that state object</span>
      <span class="s5">// Otherwise, we'll handle it like a regular deep link</span>
      <span class="s0">const </span><span class="s1">record </span><span class="s0">= </span><span class="s2">history</span><span class="s1">.</span><span class="s6">get</span><span class="s1">(</span><span class="s2">index</span><span class="s1">);</span>

      <span class="s0">if </span><span class="s1">(</span><span class="s2">record</span><span class="s1">?.</span><span class="s2">path </span><span class="s0">=== </span><span class="s2">path </span><span class="s0">&amp;&amp; </span><span class="s2">record</span><span class="s1">?.</span><span class="s2">state</span><span class="s1">) {</span>
        <span class="s2">navigation</span><span class="s1">.</span><span class="s6">resetRoot</span><span class="s1">(</span><span class="s2">record</span><span class="s1">.</span><span class="s2">state</span><span class="s1">);</span>
        <span class="s0">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s0">const </span><span class="s1">state </span><span class="s0">= </span><span class="s2">getStateFromPathRef</span><span class="s1">.</span><span class="s6">current</span><span class="s1">(</span><span class="s2">path</span><span class="s1">, </span><span class="s2">configRef</span><span class="s1">.</span><span class="s2">current</span><span class="s1">);</span>

      <span class="s5">// We should only dispatch an action when going forward</span>
      <span class="s5">// Otherwise the action will likely add items to history, which would mess things up</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s2">state</span><span class="s1">) {</span>
        <span class="s5">// Make sure that the routes in the state exist in the root navigator</span>
        <span class="s5">// Otherwise there's an error in the linking configuration</span>
        <span class="s0">const </span><span class="s1">rootState </span><span class="s0">= </span><span class="s2">navigation</span><span class="s1">.</span><span class="s6">getRootState</span><span class="s1">();</span>

        <span class="s0">if </span><span class="s1">(</span><span class="s2">state</span><span class="s1">.</span><span class="s2">routes</span><span class="s1">.</span><span class="s6">some</span><span class="s1">((</span><span class="s2">r</span><span class="s1">) </span><span class="s0">=&gt; !</span><span class="s2">rootState</span><span class="s1">?.</span><span class="s2">routeNames</span><span class="s1">.</span><span class="s6">includes</span><span class="s1">(</span><span class="s2">r</span><span class="s1">.</span><span class="s2">name</span><span class="s1">))) {</span>
          <span class="s2">console</span><span class="s1">.</span><span class="s6">warn</span><span class="s1">(</span>
            <span class="s3">&quot;The navigation state parsed from the URL contains routes not present in the root navigator. This usually means that the linking configuration doesn't match the navigation structure. See https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.&quot;</span>
          <span class="s1">);</span>
          <span class="s0">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s0">if </span><span class="s1">(</span><span class="s2">index </span><span class="s0">&gt; </span><span class="s2">previousIndex</span><span class="s1">) {</span>
          <span class="s0">const </span><span class="s1">action </span><span class="s0">= </span><span class="s2">getActionFromStateRef</span><span class="s1">.</span><span class="s6">current</span><span class="s1">(</span>
            <span class="s2">state</span><span class="s1">,</span>
            <span class="s2">configRef</span><span class="s1">.</span><span class="s2">current</span>
          <span class="s1">);</span>

          <span class="s0">if </span><span class="s1">(</span><span class="s2">action </span><span class="s0">!== </span><span class="s4">undefined</span><span class="s1">) {</span>
            <span class="s0">try </span><span class="s1">{</span>
              <span class="s2">navigation</span><span class="s1">.</span><span class="s6">dispatch</span><span class="s1">(</span><span class="s2">action</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s0">catch </span><span class="s1">(</span><span class="s2">e</span><span class="s1">) {</span>
              <span class="s5">// Ignore any errors from deep linking.</span>
              <span class="s5">// This could happen in case of malformed links, navigation object not being initialized etc.</span>
              <span class="s2">console</span><span class="s1">.</span><span class="s6">warn</span><span class="s1">(</span>
                <span class="s3">`An error occurred when trying to handle the link '${</span><span class="s2">path</span><span class="s3">}': ${</span>
                  <span class="s0">typeof </span><span class="s2">e </span><span class="s0">=== </span><span class="s3">'object' </span><span class="s0">&amp;&amp; </span><span class="s2">e </span><span class="s0">!= </span><span class="s4">null </span><span class="s0">&amp;&amp; </span><span class="s3">'message' </span><span class="s0">in </span><span class="s2">e</span>
                    <span class="s0">? </span><span class="s2">e</span><span class="s3">.</span><span class="s2">message</span>
                    <span class="s0">: </span><span class="s2">e</span>
                <span class="s3">}`</span>
              <span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
            <span class="s2">navigation</span><span class="s1">.</span><span class="s6">resetRoot</span><span class="s1">(</span><span class="s2">state</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
          <span class="s2">navigation</span><span class="s1">.</span><span class="s6">resetRoot</span><span class="s1">(</span><span class="s2">state</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s5">// if current path didn't return any state, we should revert to initial state</span>
        <span class="s2">navigation</span><span class="s1">.</span><span class="s6">resetRoot</span><span class="s1">(</span><span class="s2">state</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s1">}, [</span><span class="s2">enabled</span><span class="s1">, </span><span class="s2">history</span><span class="s1">, </span><span class="s2">ref</span><span class="s1">]);</span>

  <span class="s2">React</span><span class="s1">.</span><span class="s6">useEffect</span><span class="s1">(() </span><span class="s0">=&gt; </span><span class="s1">{</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">!</span><span class="s2">enabled</span><span class="s1">) {</span>
      <span class="s0">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">const </span><span class="s1">getPathForRoute </span><span class="s0">= </span><span class="s1">(</span>
      <span class="s2">route</span><span class="s0">: </span><span class="s2">ReturnType</span><span class="s1">&lt;</span><span class="s0">typeof </span><span class="s2">findFocusedRoute</span><span class="s1">&gt;,</span>
      <span class="s2">state</span><span class="s0">: </span><span class="s2">NavigationState</span>
    <span class="s1">): </span><span class="s2">string </span><span class="s0">=&gt; </span><span class="s1">{</span>
      <span class="s5">// If the `route` object contains a `path`, use that path as long as `route.name` and `params` still match</span>
      <span class="s5">// This makes sure that we preserve the original URL for wildcard routes</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s2">route</span><span class="s1">?.</span><span class="s2">path</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">stateForPath </span><span class="s0">= </span><span class="s2">getStateFromPathRef</span><span class="s1">.</span><span class="s6">current</span><span class="s1">(</span>
          <span class="s2">route</span><span class="s1">.</span><span class="s2">path</span><span class="s1">,</span>
          <span class="s2">configRef</span><span class="s1">.</span><span class="s2">current</span>
        <span class="s1">);</span>

        <span class="s0">if </span><span class="s1">(</span><span class="s2">stateForPath</span><span class="s1">) {</span>
          <span class="s0">const </span><span class="s1">focusedRoute </span><span class="s0">= </span><span class="s6">findFocusedRoute</span><span class="s1">(</span><span class="s2">stateForPath</span><span class="s1">);</span>

          <span class="s0">if </span><span class="s1">(</span>
            <span class="s2">focusedRoute </span><span class="s0">&amp;&amp;</span>
            <span class="s2">focusedRoute</span><span class="s1">.</span><span class="s2">name </span><span class="s0">=== </span><span class="s2">route</span><span class="s1">.</span><span class="s2">name </span><span class="s0">&amp;&amp;</span>
            <span class="s6">isEqual</span><span class="s1">(</span><span class="s2">focusedRoute</span><span class="s1">.</span><span class="s2">params</span><span class="s1">, </span><span class="s2">route</span><span class="s1">.</span><span class="s2">params</span><span class="s1">)</span>
          <span class="s1">) {</span>
            <span class="s0">return </span><span class="s2">route</span><span class="s1">.</span><span class="s2">path</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">return </span><span class="s2">getPathFromStateRef</span><span class="s1">.</span><span class="s6">current</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">configRef</span><span class="s1">.</span><span class="s2">current</span><span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s0">if </span><span class="s1">(</span><span class="s2">ref</span><span class="s1">.</span><span class="s2">current</span><span class="s1">) {</span>
      <span class="s5">// We need to record the current metadata on the first render if they aren't set</span>
      <span class="s5">// This will allow the initial state to be in the history entry</span>
      <span class="s0">const </span><span class="s1">state </span><span class="s0">= </span><span class="s2">ref</span><span class="s1">.</span><span class="s2">current</span><span class="s1">.</span><span class="s6">getRootState</span><span class="s1">();</span>

      <span class="s0">if </span><span class="s1">(</span><span class="s2">state</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">route </span><span class="s0">= </span><span class="s6">findFocusedRoute</span><span class="s1">(</span><span class="s2">state</span><span class="s1">);</span>
        <span class="s0">const </span><span class="s1">path </span><span class="s0">= </span><span class="s6">getPathForRoute</span><span class="s1">(</span><span class="s2">route</span><span class="s1">, </span><span class="s2">state</span><span class="s1">);</span>

        <span class="s0">if </span><span class="s1">(</span><span class="s2">previousStateRef</span><span class="s1">.</span><span class="s2">current </span><span class="s0">=== </span><span class="s4">undefined</span><span class="s1">) {</span>
          <span class="s2">previousStateRef</span><span class="s1">.</span><span class="s2">current </span><span class="s0">= </span><span class="s2">state</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">history</span><span class="s1">.</span><span class="s6">replace</span><span class="s1">({ </span><span class="s2">path</span><span class="s1">, </span><span class="s2">state </span><span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">const </span><span class="s1">onStateChange </span><span class="s0">= async </span><span class="s1">() </span><span class="s0">=&gt; </span><span class="s1">{</span>
      <span class="s0">const </span><span class="s1">navigation </span><span class="s0">= </span><span class="s2">ref</span><span class="s1">.</span><span class="s2">current</span><span class="s1">;</span>

      <span class="s0">if </span><span class="s1">(</span><span class="s0">!</span><span class="s2">navigation </span><span class="s0">|| !</span><span class="s2">enabled</span><span class="s1">) {</span>
        <span class="s0">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s0">const </span><span class="s1">previousState </span><span class="s0">= </span><span class="s2">previousStateRef</span><span class="s1">.</span><span class="s2">current</span><span class="s1">;</span>
      <span class="s0">const </span><span class="s1">state </span><span class="s0">= </span><span class="s2">navigation</span><span class="s1">.</span><span class="s6">getRootState</span><span class="s1">();</span>

      <span class="s5">// root state may not available, for example when root navigators switch inside the container</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s0">!</span><span class="s2">state</span><span class="s1">) {</span>
        <span class="s0">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s0">const </span><span class="s1">pendingPath </span><span class="s0">= </span><span class="s2">pendingPopStatePathRef</span><span class="s1">.</span><span class="s2">current</span><span class="s1">;</span>
      <span class="s0">const </span><span class="s1">route </span><span class="s0">= </span><span class="s6">findFocusedRoute</span><span class="s1">(</span><span class="s2">state</span><span class="s1">);</span>
      <span class="s0">const </span><span class="s1">path </span><span class="s0">= </span><span class="s6">getPathForRoute</span><span class="s1">(</span><span class="s2">route</span><span class="s1">, </span><span class="s2">state</span><span class="s1">);</span>

      <span class="s2">previousStateRef</span><span class="s1">.</span><span class="s2">current </span><span class="s0">= </span><span class="s2">state</span><span class="s1">;</span>
      <span class="s2">pendingPopStatePathRef</span><span class="s1">.</span><span class="s2">current </span><span class="s0">= </span><span class="s4">undefined</span><span class="s1">;</span>

      <span class="s5">// To detect the kind of state change, we need to:</span>
      <span class="s5">// - Find the common focused navigation state in previous and current state</span>
      <span class="s5">// - If only the route keys changed, compare history/routes.length to check if we go back/forward/replace</span>
      <span class="s5">// - If no common focused navigation state found, it's a replace</span>
      <span class="s0">const </span><span class="s1">[previousFocusedState, focusedState] </span><span class="s0">= </span><span class="s6">findMatchingState</span><span class="s1">(</span>
        <span class="s2">previousState</span><span class="s1">,</span>
        <span class="s2">state</span>
      <span class="s1">);</span>

      <span class="s0">if </span><span class="s1">(</span>
        <span class="s2">previousFocusedState </span><span class="s0">&amp;&amp;</span>
        <span class="s2">focusedState </span><span class="s0">&amp;&amp;</span>
        <span class="s5">// We should only handle push/pop if path changed from what was in last `popstate`</span>
        <span class="s5">// Otherwise it's likely a change triggered by `popstate`</span>
        <span class="s2">path </span><span class="s0">!== </span><span class="s2">pendingPath</span>
      <span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">historyDelta </span><span class="s0">=</span>
          <span class="s1">(</span><span class="s2">focusedState</span><span class="s1">.</span><span class="s2">history</span>
            <span class="s0">? </span><span class="s2">focusedState</span><span class="s1">.</span><span class="s2">history</span><span class="s1">.length</span>
            <span class="s0">: </span><span class="s2">focusedState</span><span class="s1">.</span><span class="s2">routes</span><span class="s1">.length) </span><span class="s0">-</span>
          <span class="s1">(</span><span class="s2">previousFocusedState</span><span class="s1">.</span><span class="s2">history</span>
            <span class="s0">? </span><span class="s2">previousFocusedState</span><span class="s1">.</span><span class="s2">history</span><span class="s1">.length</span>
            <span class="s0">: </span><span class="s2">previousFocusedState</span><span class="s1">.</span><span class="s2">routes</span><span class="s1">.length);</span>

        <span class="s0">if </span><span class="s1">(</span><span class="s2">historyDelta </span><span class="s0">&gt; </span><span class="s8">0</span><span class="s1">) {</span>
          <span class="s5">// If history length is increased, we should pushState</span>
          <span class="s5">// Note that path might not actually change here, for example, drawer open should pushState</span>
          <span class="s2">history</span><span class="s1">.</span><span class="s6">push</span><span class="s1">({ </span><span class="s2">path</span><span class="s1">, </span><span class="s2">state </span><span class="s1">});</span>
        <span class="s1">} </span><span class="s0">else if </span><span class="s1">(</span><span class="s2">historyDelta </span><span class="s0">&lt; </span><span class="s8">0</span><span class="s1">) {</span>
          <span class="s5">// If history length is decreased, i.e. entries were removed, we want to go back</span>

          <span class="s0">const </span><span class="s1">nextIndex </span><span class="s0">= </span><span class="s2">history</span><span class="s1">.</span><span class="s6">backIndex</span><span class="s1">({ </span><span class="s2">path </span><span class="s1">});</span>
          <span class="s0">const </span><span class="s1">currentIndex </span><span class="s0">= </span><span class="s2">history</span><span class="s1">.</span><span class="s2">index</span><span class="s1">;</span>

          <span class="s0">try </span><span class="s1">{</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s2">nextIndex </span><span class="s0">!== -</span><span class="s8">1 </span><span class="s0">&amp;&amp; </span><span class="s2">nextIndex </span><span class="s0">&lt; </span><span class="s2">currentIndex</span><span class="s1">) {</span>
              <span class="s5">// An existing entry for this path exists and it's less than current index, go back to that</span>
              <span class="s0">await </span><span class="s2">history</span><span class="s1">.</span><span class="s6">go</span><span class="s1">(</span><span class="s2">nextIndex </span><span class="s0">- </span><span class="s2">currentIndex</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
              <span class="s5">// We couldn't find an existing entry to go back to, so we'll go back by the delta</span>
              <span class="s5">// This won't be correct if multiple routes were pushed in one go before</span>
              <span class="s5">// Usually this shouldn't happen and this is a fallback for that</span>
              <span class="s0">await </span><span class="s2">history</span><span class="s1">.</span><span class="s6">go</span><span class="s1">(</span><span class="s2">historyDelta</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s5">// Store the updated state as well as fix the path if incorrect</span>
            <span class="s2">history</span><span class="s1">.</span><span class="s6">replace</span><span class="s1">({ </span><span class="s2">path</span><span class="s1">, </span><span class="s2">state </span><span class="s1">});</span>
          <span class="s1">} </span><span class="s0">catch </span><span class="s1">(</span><span class="s2">e</span><span class="s1">) {</span>
            <span class="s5">// The navigation was interrupted</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
          <span class="s5">// If history length is unchanged, we want to replaceState</span>
          <span class="s2">history</span><span class="s1">.</span><span class="s6">replace</span><span class="s1">({ </span><span class="s2">path</span><span class="s1">, </span><span class="s2">state </span><span class="s1">});</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s5">// If no common navigation state was found, assume it's a replace</span>
        <span class="s5">// This would happen if the user did a reset/conditionally changed navigators</span>
        <span class="s2">history</span><span class="s1">.</span><span class="s6">replace</span><span class="s1">({ </span><span class="s2">path</span><span class="s1">, </span><span class="s2">state </span><span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s5">// We debounce onStateChange coz we don't want multiple state changes to be handled at one time</span>
    <span class="s5">// This could happen since `history.go(n)` is asynchronous</span>
    <span class="s5">// If `pushState` or `replaceState` were called before `history.go(n)` completes, it'll mess stuff up</span>
    <span class="s0">return </span><span class="s2">ref</span><span class="s1">.</span><span class="s2">current</span><span class="s1">?.</span><span class="s6">addListener</span><span class="s1">(</span><span class="s3">'state'</span><span class="s1">, </span><span class="s6">series</span><span class="s1">(</span><span class="s2">onStateChange</span><span class="s1">));</span>
  <span class="s1">}, [</span><span class="s2">enabled</span><span class="s1">, </span><span class="s2">history</span><span class="s1">, </span><span class="s2">ref</span><span class="s1">]);</span>

  <span class="s0">return </span><span class="s1">{</span>
    <span class="s2">getInitialState</span><span class="s1">,</span>
  <span class="s1">};</span>
<span class="s1">}</span>
</pre>
</body>
</html>
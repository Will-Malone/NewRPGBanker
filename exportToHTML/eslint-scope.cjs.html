<html>
<head>
<title>eslint-scope.cjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #a9b7c6;}
.s3 { color: #ffc66d;}
.s4 { color: #9876aa; font-style: italic;}
.s5 { color: #cc7832;}
.s6 { color: #808080;}
.s7 { color: #6897bb; font-style: italic;}
.s8 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
eslint-scope.cjs</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s2">Object</span><span class="s1">.</span><span class="s3">defineProperty</span><span class="s1">(</span><span class="s2">exports</span><span class="s1">, </span><span class="s0">'__esModule'</span><span class="s1">, { value: </span><span class="s4">true </span><span class="s1">});</span>

<span class="s5">var </span><span class="s1">assert </span><span class="s5">= </span><span class="s3">require</span><span class="s1">(</span><span class="s0">'assert'</span><span class="s1">);</span>
<span class="s5">var </span><span class="s1">estraverse </span><span class="s5">= </span><span class="s3">require</span><span class="s1">(</span><span class="s0">'estraverse'</span><span class="s1">);</span>
<span class="s5">var </span><span class="s1">esrecurse </span><span class="s5">= </span><span class="s3">require</span><span class="s1">(</span><span class="s0">'esrecurse'</span><span class="s1">);</span>

<span class="s5">function </span><span class="s1">_interopDefaultLegacy (</span><span class="s2">e</span><span class="s1">) { </span><span class="s5">return </span><span class="s2">e </span><span class="s5">&amp;&amp; typeof </span><span class="s2">e </span><span class="s5">=== </span><span class="s0">'object' </span><span class="s5">&amp;&amp; </span><span class="s0">'default' </span><span class="s5">in </span><span class="s2">e </span><span class="s5">? </span><span class="s2">e </span><span class="s5">: </span><span class="s1">{ </span><span class="s0">'default'</span><span class="s1">: </span><span class="s2">e </span><span class="s1">}; }</span>

<span class="s5">var </span><span class="s1">assert__default </span><span class="s5">= </span><span class="s6">/*#__PURE__*/</span><span class="s3">_interopDefaultLegacy</span><span class="s1">(</span><span class="s2">assert</span><span class="s1">);</span>
<span class="s5">var </span><span class="s1">estraverse__default </span><span class="s5">= </span><span class="s6">/*#__PURE__*/</span><span class="s3">_interopDefaultLegacy</span><span class="s1">(</span><span class="s2">estraverse</span><span class="s1">);</span>
<span class="s5">var </span><span class="s1">esrecurse__default </span><span class="s5">= </span><span class="s6">/*#__PURE__*/</span><span class="s3">_interopDefaultLegacy</span><span class="s1">(</span><span class="s2">esrecurse</span><span class="s1">);</span>

<span class="s6">/*</span>
  <span class="s6">Copyright (C) 2015 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt; 
</span>
  <span class="s6">Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are met: 
</span>
    <span class="s6">* Redistributions of source code must retain the above copyright 
      notice, this list of conditions and the following disclaimer. 
    * Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution. 
</span>
  <span class="s6">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY 
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
*/</span>

<span class="s5">const </span><span class="s1">READ </span><span class="s5">= </span><span class="s7">0x1</span><span class="s1">;</span>
<span class="s5">const </span><span class="s1">WRITE </span><span class="s5">= </span><span class="s7">0x2</span><span class="s1">;</span>
<span class="s5">const </span><span class="s1">RW </span><span class="s5">= </span><span class="s2">READ </span><span class="s5">| </span><span class="s2">WRITE</span><span class="s1">;</span>

<span class="s6">/**</span>
 <span class="s6">* A Reference represents a single occurrence of an identifier in code. 
 * </span><span class="s5">@constructor </span><span class="s6">Reference 
 */</span>
<span class="s5">class </span><span class="s2">Reference </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">ident</span><span class="s1">, </span><span class="s2">scope</span><span class="s1">, </span><span class="s2">flag</span><span class="s1">, </span><span class="s2">writeExpr</span><span class="s1">, </span><span class="s2">maybeImplicitGlobal</span><span class="s1">, </span><span class="s2">partial</span><span class="s1">, </span><span class="s2">init</span><span class="s1">) {</span>

        <span class="s6">/**</span>
         <span class="s6">* Identifier syntax node. 
         * </span><span class="s5">@member </span><span class="s2">{espreeIdentifier} Reference</span><span class="s6">#identifier 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">identifier </span><span class="s5">= </span><span class="s2">ident</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* Reference to the enclosing Scope. 
         * </span><span class="s5">@member </span><span class="s2">{Scope} Reference</span><span class="s6">#from 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">from </span><span class="s5">= </span><span class="s2">scope</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* Whether the reference comes from a dynamic scope (such as 'eval', 
         * 'with', etc.), and may be trapped by dynamic scopes. 
         * </span><span class="s5">@member </span><span class="s2">{boolean} Reference</span><span class="s6">#tainted 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">tainted </span><span class="s5">= </span><span class="s4">false</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* The variable this reference is resolved with. 
         * </span><span class="s5">@member </span><span class="s2">{Variable} Reference</span><span class="s6">#resolved 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">resolved </span><span class="s5">= </span><span class="s4">null</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* The read-write mode of the reference. (Value is one of </span><span class="s2">{</span><span class="s5">@link</span>
         <span class="s2">* Reference.READ}</span><span class="s6">, </span><span class="s2">{</span><span class="s5">@link </span><span class="s2">Reference.RW}</span><span class="s6">, </span><span class="s2">{</span><span class="s5">@link </span><span class="s2">Reference.WRITE}</span><span class="s6">). 
         * </span><span class="s5">@member </span><span class="s2">{number} Reference</span><span class="s6">#flag 
         * </span><span class="s5">@private</span>
         <span class="s6">*/</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">flag </span><span class="s5">= </span><span class="s2">flag</span><span class="s1">;</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s3">isWrite</span><span class="s1">()) {</span>

            <span class="s6">/**</span>
             <span class="s6">* If reference is writeable, this is the tree being written to it. 
             * </span><span class="s5">@member </span><span class="s2">{espreeNode} Reference</span><span class="s6">#writeExpr 
             */</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">writeExpr </span><span class="s5">= </span><span class="s2">writeExpr</span><span class="s1">;</span>

            <span class="s6">/**</span>
             <span class="s6">* Whether the Reference might refer to a partial value of writeExpr. 
             * </span><span class="s5">@member </span><span class="s2">{boolean} Reference</span><span class="s6">#partial 
             */</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">partial </span><span class="s5">= </span><span class="s2">partial</span><span class="s1">;</span>

            <span class="s6">/**</span>
             <span class="s6">* Whether the Reference is to write of initialization. 
             * </span><span class="s5">@member </span><span class="s2">{boolean} Reference</span><span class="s6">#init 
             */</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">init </span><span class="s5">= </span><span class="s2">init</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">__maybeImplicitGlobal </span><span class="s5">= </span><span class="s2">maybeImplicitGlobal</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s6">/**</span>
     <span class="s6">* Whether the reference is static. 
     * </span><span class="s5">@function </span><span class="s2">Reference#isStatic</span>
     <span class="s6">* </span><span class="s5">@returns </span><span class="s2">{boolean} </span><span class="s6">static 
     */</span>
    <span class="s1">isStatic() {</span>
        <span class="s5">return !</span><span class="s2">this</span><span class="s1">.</span><span class="s2">tainted </span><span class="s5">&amp;&amp; </span><span class="s2">this</span><span class="s1">.</span><span class="s2">resolved </span><span class="s5">&amp;&amp; </span><span class="s2">this</span><span class="s1">.</span><span class="s2">resolved</span><span class="s1">.</span><span class="s2">scope</span><span class="s1">.</span><span class="s3">isStatic</span><span class="s1">();</span>
    <span class="s1">}</span>

    <span class="s6">/**</span>
     <span class="s6">* Whether the reference is writeable. 
     * </span><span class="s5">@function </span><span class="s2">Reference#isWrite</span>
     <span class="s6">* </span><span class="s5">@returns </span><span class="s2">{boolean} </span><span class="s6">write 
     */</span>
    <span class="s1">isWrite() {</span>
        <span class="s5">return !!</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">flag </span><span class="s5">&amp; </span><span class="s2">Reference</span><span class="s1">.</span><span class="s2">WRITE</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s6">/**</span>
     <span class="s6">* Whether the reference is readable. 
     * </span><span class="s5">@function </span><span class="s2">Reference#isRead</span>
     <span class="s6">* </span><span class="s5">@returns </span><span class="s2">{boolean} </span><span class="s6">read 
     */</span>
    <span class="s1">isRead() {</span>
        <span class="s5">return !!</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">flag </span><span class="s5">&amp; </span><span class="s2">Reference</span><span class="s1">.</span><span class="s2">READ</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s6">/**</span>
     <span class="s6">* Whether the reference is read-only. 
     * </span><span class="s5">@function </span><span class="s2">Reference#isReadOnly</span>
     <span class="s6">* </span><span class="s5">@returns </span><span class="s2">{boolean} </span><span class="s6">read only 
     */</span>
    <span class="s1">isReadOnly() {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">flag </span><span class="s5">=== </span><span class="s2">Reference</span><span class="s1">.</span><span class="s2">READ</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s6">/**</span>
     <span class="s6">* Whether the reference is write-only. 
     * </span><span class="s5">@function </span><span class="s2">Reference#isWriteOnly</span>
     <span class="s6">* </span><span class="s5">@returns </span><span class="s2">{boolean} </span><span class="s6">write only 
     */</span>
    <span class="s1">isWriteOnly() {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">flag </span><span class="s5">=== </span><span class="s2">Reference</span><span class="s1">.</span><span class="s2">WRITE</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s6">/**</span>
     <span class="s6">* Whether the reference is read-write. 
     * </span><span class="s5">@function </span><span class="s2">Reference#isReadWrite</span>
     <span class="s6">* </span><span class="s5">@returns </span><span class="s2">{boolean} </span><span class="s6">read write 
     */</span>
    <span class="s1">isReadWrite() {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">flag </span><span class="s5">=== </span><span class="s2">Reference</span><span class="s1">.</span><span class="s2">RW</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* </span><span class="s5">@constant </span><span class="s2">Reference.READ</span>
 <span class="s6">* </span><span class="s5">@private</span>
 <span class="s6">*/</span>
<span class="s2">Reference</span><span class="s1">.</span><span class="s2">READ </span><span class="s5">= </span><span class="s2">READ</span><span class="s1">;</span>

<span class="s6">/**</span>
 <span class="s6">* </span><span class="s5">@constant </span><span class="s2">Reference.WRITE</span>
 <span class="s6">* </span><span class="s5">@private</span>
 <span class="s6">*/</span>
<span class="s2">Reference</span><span class="s1">.</span><span class="s2">WRITE </span><span class="s5">= </span><span class="s2">WRITE</span><span class="s1">;</span>

<span class="s6">/**</span>
 <span class="s6">* </span><span class="s5">@constant </span><span class="s2">Reference.RW</span>
 <span class="s6">* </span><span class="s5">@private</span>
 <span class="s6">*/</span>
<span class="s2">Reference</span><span class="s1">.</span><span class="s2">RW </span><span class="s5">= </span><span class="s2">RW</span><span class="s1">;</span>

<span class="s6">/* vim: set sw=4 ts=4 et tw=80 : */</span>

<span class="s6">/*</span>
  <span class="s6">Copyright (C) 2015 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt; 
</span>
  <span class="s6">Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are met: 
</span>
    <span class="s6">* Redistributions of source code must retain the above copyright 
      notice, this list of conditions and the following disclaimer. 
    * Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution. 
</span>
  <span class="s6">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY 
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
*/</span>

<span class="s6">/**</span>
 <span class="s6">* A Variable represents a locally scoped identifier. These include arguments to 
 * functions. 
 * </span><span class="s5">@constructor </span><span class="s6">Variable 
 */</span>
<span class="s5">class </span><span class="s2">Variable </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">name</span><span class="s1">, </span><span class="s2">scope</span><span class="s1">) {</span>

        <span class="s6">/**</span>
         <span class="s6">* The variable name, as given in the source code. 
         * </span><span class="s5">@member </span><span class="s2">{string} Variable</span><span class="s6">#name 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">name </span><span class="s5">= </span><span class="s2">name</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* List of defining occurrences of this variable (like in 'var ...' 
         * statements or as parameter), as AST nodes. 
         * </span><span class="s5">@member </span><span class="s2">{espree.Identifier[]} Variable</span><span class="s6">#identifiers 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">identifiers </span><span class="s5">= </span><span class="s1">[];</span>

        <span class="s6">/**</span>
         <span class="s6">* List of </span><span class="s2">{</span><span class="s5">@link </span><span class="s2">Reference|references} </span><span class="s6">of this variable (excluding parameter entries) 
         * in its defining scope and all nested scopes. For defining 
         * occurrences only see </span><span class="s2">{</span><span class="s5">@link </span><span class="s2">Variable#defs}</span><span class="s6">. 
         * </span><span class="s5">@member </span><span class="s2">{Reference[]} Variable</span><span class="s6">#references 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">references </span><span class="s5">= </span><span class="s1">[];</span>

        <span class="s6">/**</span>
         <span class="s6">* List of defining occurrences of this variable (like in 'var ...' 
         * statements or as parameter), as custom objects. 
         * </span><span class="s5">@member </span><span class="s2">{Definition[]} Variable</span><span class="s6">#defs 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">defs </span><span class="s5">= </span><span class="s1">[];</span>

        <span class="s2">this</span><span class="s1">.</span><span class="s2">tainted </span><span class="s5">= </span><span class="s4">false</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* Whether this is a stack variable. 
         * </span><span class="s5">@member </span><span class="s2">{boolean} Variable</span><span class="s6">#stack 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">stack </span><span class="s5">= </span><span class="s4">true</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* Reference to the enclosing Scope. 
         * </span><span class="s5">@member </span><span class="s2">{Scope} Variable</span><span class="s6">#scope 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">scope </span><span class="s5">= </span><span class="s2">scope</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">Variable</span><span class="s1">.</span><span class="s2">CatchClause </span><span class="s5">= </span><span class="s0">&quot;CatchClause&quot;</span><span class="s1">;</span>
<span class="s2">Variable</span><span class="s1">.</span><span class="s2">Parameter </span><span class="s5">= </span><span class="s0">&quot;Parameter&quot;</span><span class="s1">;</span>
<span class="s2">Variable</span><span class="s1">.</span><span class="s2">FunctionName </span><span class="s5">= </span><span class="s0">&quot;FunctionName&quot;</span><span class="s1">;</span>
<span class="s2">Variable</span><span class="s1">.</span><span class="s2">ClassName </span><span class="s5">= </span><span class="s0">&quot;ClassName&quot;</span><span class="s1">;</span>
<span class="s2">Variable</span><span class="s1">.</span><span class="s2">Variable </span><span class="s5">= </span><span class="s0">&quot;Variable&quot;</span><span class="s1">;</span>
<span class="s2">Variable</span><span class="s1">.</span><span class="s2">ImportBinding </span><span class="s5">= </span><span class="s0">&quot;ImportBinding&quot;</span><span class="s1">;</span>
<span class="s2">Variable</span><span class="s1">.</span><span class="s2">ImplicitGlobalVariable </span><span class="s5">= </span><span class="s0">&quot;ImplicitGlobalVariable&quot;</span><span class="s1">;</span>

<span class="s6">/* vim: set sw=4 ts=4 et tw=80 : */</span>

<span class="s6">/*</span>
  <span class="s6">Copyright (C) 2015 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt; 
</span>
  <span class="s6">Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are met: 
</span>
    <span class="s6">* Redistributions of source code must retain the above copyright 
      notice, this list of conditions and the following disclaimer. 
    * Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution. 
</span>
  <span class="s6">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY 
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
*/</span>

<span class="s6">/**</span>
 <span class="s6">* </span><span class="s5">@constructor </span><span class="s6">Definition 
 */</span>
<span class="s5">class </span><span class="s2">Definition </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">type</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, </span><span class="s2">node</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">index</span><span class="s1">, </span><span class="s2">kind</span><span class="s1">) {</span>

        <span class="s6">/**</span>
         <span class="s6">* </span><span class="s5">@member </span><span class="s2">{string} Definition</span><span class="s6">#type - type of the occurrence (e.g. &quot;Parameter&quot;, &quot;Variable&quot;, ...). 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">type </span><span class="s5">= </span><span class="s2">type</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* </span><span class="s5">@member </span><span class="s2">{espree.Identifier} Definition</span><span class="s6">#name - the identifier AST node of the occurrence. 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">name </span><span class="s5">= </span><span class="s2">name</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* </span><span class="s5">@member </span><span class="s2">{espree.Node} Definition</span><span class="s6">#node - the enclosing node of the identifier. 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">node </span><span class="s5">= </span><span class="s2">node</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* </span><span class="s5">@member </span><span class="s2">{espree.Node?} Definition</span><span class="s6">#parent - the enclosing statement node of the identifier. 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">parent </span><span class="s5">= </span><span class="s2">parent</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* </span><span class="s5">@member </span><span class="s2">{number?} Definition</span><span class="s6">#index - the index in the declaration statement. 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">index </span><span class="s5">= </span><span class="s2">index</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* </span><span class="s5">@member </span><span class="s2">{string?} Definition</span><span class="s6">#kind - the kind of the declaration statement. 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">kind </span><span class="s5">= </span><span class="s2">kind</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* </span><span class="s5">@constructor </span><span class="s6">ParameterDefinition 
 */</span>
<span class="s5">class </span><span class="s2">ParameterDefinition </span><span class="s5">extends </span><span class="s2">Definition </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">name</span><span class="s1">, </span><span class="s2">node</span><span class="s1">, </span><span class="s2">index</span><span class="s1">, </span><span class="s2">rest</span><span class="s1">) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s2">Variable</span><span class="s1">.</span><span class="s2">Parameter</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, </span><span class="s2">node</span><span class="s1">, </span><span class="s4">null</span><span class="s1">, </span><span class="s2">index</span><span class="s1">, </span><span class="s4">null</span><span class="s1">);</span>

        <span class="s6">/**</span>
         <span class="s6">* Whether the parameter definition is a part of a rest parameter. 
         * </span><span class="s5">@member </span><span class="s2">{boolean} ParameterDefinition</span><span class="s6">#rest 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">rest </span><span class="s5">= </span><span class="s2">rest</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s6">/* vim: set sw=4 ts=4 et tw=80 : */</span>

<span class="s6">/*</span>
  <span class="s6">Copyright (C) 2015 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt; 
</span>
  <span class="s6">Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are met: 
</span>
    <span class="s6">* Redistributions of source code must retain the above copyright 
      notice, this list of conditions and the following disclaimer. 
    * Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution. 
</span>
  <span class="s6">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY 
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
*/</span>

<span class="s5">const </span><span class="s1">{ </span><span class="s2">Syntax</span><span class="s1">: Syntax$2 } </span><span class="s5">= </span><span class="s2">estraverse__default</span><span class="s1">[</span><span class="s0">&quot;default&quot;</span><span class="s1">];</span>

<span class="s6">/**</span>
 <span class="s6">* Test if scope is struct 
 * </span><span class="s5">@param </span><span class="s2">{Scope} scope </span><span class="s6">scope 
 * </span><span class="s5">@param </span><span class="s2">{Block} block </span><span class="s6">block 
 * </span><span class="s5">@param </span><span class="s2">{boolean} isMethodDefinition </span><span class="s6">is method definition 
 * </span><span class="s5">@param </span><span class="s2">{boolean} useDirective </span><span class="s6">use directive 
 * </span><span class="s5">@returns </span><span class="s2">{boolean} </span><span class="s6">is strict scope 
 */</span>
<span class="s5">function </span><span class="s1">isStrictScope(</span><span class="s2">scope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s2">isMethodDefinition</span><span class="s1">, </span><span class="s2">useDirective</span><span class="s1">) {</span>
    <span class="s5">let </span><span class="s1">body;</span>

    <span class="s6">// When upper scope is exists and strict, inner scope is also strict.</span>
    <span class="s5">if </span><span class="s1">(</span><span class="s2">scope</span><span class="s1">.</span><span class="s2">upper </span><span class="s5">&amp;&amp; </span><span class="s2">scope</span><span class="s1">.</span><span class="s2">upper</span><span class="s1">.</span><span class="s2">isStrict</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s4">true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s5">if </span><span class="s1">(</span><span class="s2">isMethodDefinition</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s4">true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s5">if </span><span class="s1">(</span><span class="s2">scope</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s0">&quot;class&quot; </span><span class="s5">|| </span><span class="s2">scope</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s0">&quot;module&quot;</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s4">true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s5">if </span><span class="s1">(</span><span class="s2">scope</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s0">&quot;block&quot; </span><span class="s5">|| </span><span class="s2">scope</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s0">&quot;switch&quot;</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s4">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s5">if </span><span class="s1">(</span><span class="s2">scope</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">block</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s2">Syntax$2</span><span class="s1">.</span><span class="s2">ArrowFunctionExpression </span><span class="s5">&amp;&amp; </span><span class="s2">block</span><span class="s1">.</span><span class="s2">body</span><span class="s1">.</span><span class="s2">type </span><span class="s5">!== </span><span class="s2">Syntax$2</span><span class="s1">.</span><span class="s2">BlockStatement</span><span class="s1">) {</span>
            <span class="s5">return </span><span class="s4">false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s5">if </span><span class="s1">(</span><span class="s2">block</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s2">Syntax$2</span><span class="s1">.</span><span class="s2">Program</span><span class="s1">) {</span>
            <span class="s2">body </span><span class="s5">= </span><span class="s2">block</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
            <span class="s2">body </span><span class="s5">= </span><span class="s2">block</span><span class="s1">.</span><span class="s2">body</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s5">if </span><span class="s1">(</span><span class="s5">!</span><span class="s2">body</span><span class="s1">) {</span>
            <span class="s5">return </span><span class="s4">false</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span><span class="s2">scope</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s0">&quot;global&quot;</span><span class="s1">) {</span>
        <span class="s2">body </span><span class="s5">= </span><span class="s2">block</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
        <span class="s5">return </span><span class="s4">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s6">// Search 'use strict' directive.</span>
    <span class="s5">if </span><span class="s1">(</span><span class="s2">useDirective</span><span class="s1">) {</span>
        <span class="s5">for </span><span class="s1">(</span><span class="s5">let </span><span class="s1">i </span><span class="s5">= </span><span class="s7">0</span><span class="s1">, iz </span><span class="s5">= </span><span class="s2">body</span><span class="s1">.</span><span class="s2">body</span><span class="s1">.length; </span><span class="s2">i </span><span class="s5">&lt; </span><span class="s2">iz</span><span class="s1">; </span><span class="s5">++</span><span class="s2">i</span><span class="s1">) {</span>
            <span class="s5">const </span><span class="s1">stmt </span><span class="s5">= </span><span class="s2">body</span><span class="s1">.</span><span class="s2">body</span><span class="s1">[</span><span class="s2">i</span><span class="s1">];</span>

            <span class="s5">if </span><span class="s1">(</span><span class="s2">stmt</span><span class="s1">.</span><span class="s2">type </span><span class="s5">!== </span><span class="s2">Syntax$2</span><span class="s1">.</span><span class="s2">DirectiveStatement</span><span class="s1">) {</span>
                <span class="s5">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s5">if </span><span class="s1">(</span><span class="s2">stmt</span><span class="s1">.</span><span class="s2">raw </span><span class="s5">=== </span><span class="s0">&quot;</span><span class="s8">\&quot;</span><span class="s0">use strict</span><span class="s8">\&quot;</span><span class="s0">&quot; </span><span class="s5">|| </span><span class="s2">stmt</span><span class="s1">.</span><span class="s2">raw </span><span class="s5">=== </span><span class="s0">&quot;'use strict'&quot;</span><span class="s1">) {</span>
                <span class="s5">return </span><span class="s4">true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
        <span class="s5">for </span><span class="s1">(</span><span class="s5">let </span><span class="s1">i </span><span class="s5">= </span><span class="s7">0</span><span class="s1">, iz </span><span class="s5">= </span><span class="s2">body</span><span class="s1">.</span><span class="s2">body</span><span class="s1">.length; </span><span class="s2">i </span><span class="s5">&lt; </span><span class="s2">iz</span><span class="s1">; </span><span class="s5">++</span><span class="s2">i</span><span class="s1">) {</span>
            <span class="s5">const </span><span class="s1">stmt </span><span class="s5">= </span><span class="s2">body</span><span class="s1">.</span><span class="s2">body</span><span class="s1">[</span><span class="s2">i</span><span class="s1">];</span>

            <span class="s5">if </span><span class="s1">(</span><span class="s2">stmt</span><span class="s1">.</span><span class="s2">type </span><span class="s5">!== </span><span class="s2">Syntax$2</span><span class="s1">.</span><span class="s2">ExpressionStatement</span><span class="s1">) {</span>
                <span class="s5">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s5">const </span><span class="s1">expr </span><span class="s5">= </span><span class="s2">stmt</span><span class="s1">.</span><span class="s2">expression</span><span class="s1">;</span>

            <span class="s5">if </span><span class="s1">(</span><span class="s2">expr</span><span class="s1">.</span><span class="s2">type </span><span class="s5">!== </span><span class="s2">Syntax$2</span><span class="s1">.</span><span class="s2">Literal </span><span class="s5">|| typeof </span><span class="s2">expr</span><span class="s1">.</span><span class="s2">value </span><span class="s5">!== </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
                <span class="s5">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s5">if </span><span class="s1">(</span><span class="s2">expr</span><span class="s1">.</span><span class="s2">raw </span><span class="s5">!== </span><span class="s4">null </span><span class="s5">&amp;&amp; </span><span class="s2">expr</span><span class="s1">.</span><span class="s2">raw </span><span class="s5">!== </span><span class="s4">undefined</span><span class="s1">) {</span>
                <span class="s5">if </span><span class="s1">(</span><span class="s2">expr</span><span class="s1">.</span><span class="s2">raw </span><span class="s5">=== </span><span class="s0">&quot;</span><span class="s8">\&quot;</span><span class="s0">use strict</span><span class="s8">\&quot;</span><span class="s0">&quot; </span><span class="s5">|| </span><span class="s2">expr</span><span class="s1">.</span><span class="s2">raw </span><span class="s5">=== </span><span class="s0">&quot;'use strict'&quot;</span><span class="s1">) {</span>
                    <span class="s5">return </span><span class="s4">true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
                <span class="s5">if </span><span class="s1">(</span><span class="s2">expr</span><span class="s1">.</span><span class="s2">value </span><span class="s5">=== </span><span class="s0">&quot;use strict&quot;</span><span class="s1">) {</span>
                    <span class="s5">return </span><span class="s4">true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">return </span><span class="s4">false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* Register scope 
 * </span><span class="s5">@param </span><span class="s2">{ScopeManager} scopeManager </span><span class="s6">scope manager 
 * </span><span class="s5">@param </span><span class="s2">{Scope} scope </span><span class="s6">scope 
 * </span><span class="s5">@returns </span><span class="s2">{void}</span>
 <span class="s6">*/ 
function registerScope(scopeManager, scope) { 
    scopeManager.scopes.push(scope); 
</span>
    <span class="s6">const scopes = scopeManager.__nodeToScope.get(scope.block); 
</span>
    <span class="s6">if (scopes) { 
        scopes.push(scope); 
    } else { 
        scopeManager.__nodeToScope.set(scope.block, [scope]); 
    } 
} 
</span>
<span class="s6">/** 
 * Should be statically 
 * </span><span class="s5">@param </span><span class="s2">{Object} def </span><span class="s6">def 
 * </span><span class="s5">@returns </span><span class="s2">{boolean} </span><span class="s6">should be statically 
 */</span>
<span class="s5">function </span><span class="s1">shouldBeStatically(</span><span class="s2">def</span><span class="s1">) {</span>
    <span class="s5">return </span><span class="s1">(</span>
        <span class="s1">(</span><span class="s2">def</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s2">Variable</span><span class="s1">.</span><span class="s2">ClassName</span><span class="s1">) </span><span class="s5">||</span>
        <span class="s1">(</span><span class="s2">def</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s2">Variable</span><span class="s1">.</span><span class="s2">Variable </span><span class="s5">&amp;&amp; </span><span class="s2">def</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">.</span><span class="s2">kind </span><span class="s5">!== </span><span class="s0">&quot;var&quot;</span><span class="s1">)</span>
    <span class="s1">);</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* </span><span class="s5">@constructor </span><span class="s6">Scope 
 */</span>
<span class="s5">class </span><span class="s2">Scope </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s2">isMethodDefinition</span><span class="s1">) {</span>

        <span class="s6">/**</span>
         <span class="s6">* One of &quot;global&quot;, &quot;module&quot;, &quot;function&quot;, &quot;function-expression-name&quot;, &quot;block&quot;, &quot;switch&quot;, &quot;catch&quot;, &quot;with&quot;, &quot;for&quot;, 
         * &quot;class&quot;, &quot;class-field-initializer&quot;, &quot;class-static-block&quot;. 
         * </span><span class="s5">@member </span><span class="s2">{string} Scope</span><span class="s6">#type 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">type </span><span class="s5">= </span><span class="s2">type</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* The scoped </span><span class="s2">{</span><span class="s5">@link </span><span class="s2">Variable}</span><span class="s6">s of this scope, as &lt;code&gt;{ Variable.name 
         * : Variable }&lt;/code&gt;. 
         * </span><span class="s5">@member </span><span class="s2">{Map} Scope</span><span class="s6">#set 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">set </span><span class="s5">= new </span><span class="s3">Map</span><span class="s1">();</span>

        <span class="s6">/**</span>
         <span class="s6">* The tainted variables of this scope, as &lt;code&gt;{ Variable.name : 
         * boolean }&lt;/code&gt;. 
         * </span><span class="s5">@member </span><span class="s2">{Map} Scope</span><span class="s6">#taints */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">taints </span><span class="s5">= new </span><span class="s3">Map</span><span class="s1">();</span>

        <span class="s6">/**</span>
         <span class="s6">* Generally, through the lexical scoping of JS you can always know 
         * which variable an identifier in the source code refers to. There are 
         * a few exceptions to this rule. With 'global' and 'with' scopes you 
         * can only decide at runtime which variable a reference refers to. 
         * Moreover, if 'eval()' is used in a scope, it might introduce new 
         * bindings in this or its parent scopes. 
         * All those scopes are considered 'dynamic'. 
         * </span><span class="s5">@member </span><span class="s2">{boolean} Scope</span><span class="s6">#dynamic 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">dynamic </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s0">&quot;global&quot; </span><span class="s5">|| </span><span class="s2">this</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s0">&quot;with&quot;</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* A reference to the scope-defining syntax node. 
         * </span><span class="s5">@member </span><span class="s2">{espree.Node} Scope</span><span class="s6">#block 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">block </span><span class="s5">= </span><span class="s2">block</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* The </span><span class="s2">{</span><span class="s5">@link </span><span class="s2">Reference|references} </span><span class="s6">that are not resolved with this scope. 
         * </span><span class="s5">@member </span><span class="s2">{Reference[]} Scope</span><span class="s6">#through 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">through </span><span class="s5">= </span><span class="s1">[];</span>

        <span class="s6">/**</span>
         <span class="s6">* The scoped </span><span class="s2">{</span><span class="s5">@link </span><span class="s2">Variable}</span><span class="s6">s of this scope. In the case of a 
         * 'function' scope this includes the automatic argument &lt;em&gt;arguments&lt;/em&gt; as 
         * its first element, as well as all further formal arguments. 
         * </span><span class="s5">@member </span><span class="s2">{Variable[]} Scope</span><span class="s6">#variables 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">variables </span><span class="s5">= </span><span class="s1">[];</span>

        <span class="s6">/**</span>
         <span class="s6">* Any variable </span><span class="s2">{</span><span class="s5">@link </span><span class="s2">Reference|reference} </span><span class="s6">found in this scope. This 
         * includes occurrences of local variables as well as variables from 
         * parent scopes (including the global scope). For local variables 
         * this also includes defining occurrences (like in a 'var' statement). 
         * In a 'function' scope this does not include the occurrences of the 
         * formal parameter in the parameter list. 
         * </span><span class="s5">@member </span><span class="s2">{Reference[]} Scope</span><span class="s6">#references 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">references </span><span class="s5">= </span><span class="s1">[];</span>

        <span class="s6">/**</span>
         <span class="s6">* For 'global' and 'function' scopes, this is a self-reference. For 
         * other scope types this is the &lt;em&gt;variableScope&lt;/em&gt; value of the 
         * parent scope. 
         * </span><span class="s5">@member </span><span class="s2">{Scope} Scope</span><span class="s6">#variableScope 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">variableScope </span><span class="s5">=</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s0">&quot;global&quot; </span><span class="s5">||</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s0">&quot;module&quot; </span><span class="s5">||</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s0">&quot;function&quot; </span><span class="s5">||</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s0">&quot;class-field-initializer&quot; </span><span class="s5">||</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s0">&quot;class-static-block&quot;</span>
                <span class="s5">? </span><span class="s2">this</span>
                <span class="s5">: </span><span class="s2">upperScope</span><span class="s1">.</span><span class="s2">variableScope</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* Whether this scope is created by a FunctionExpression. 
         * </span><span class="s5">@member </span><span class="s2">{boolean} Scope</span><span class="s6">#functionExpressionScope 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">functionExpressionScope </span><span class="s5">= </span><span class="s4">false</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* Whether this is a scope that contains an 'eval()' invocation. 
         * </span><span class="s5">@member </span><span class="s2">{boolean} Scope</span><span class="s6">#directCallToEvalScope 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">directCallToEvalScope </span><span class="s5">= </span><span class="s4">false</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* </span><span class="s5">@member </span><span class="s2">{boolean} Scope</span><span class="s6">#thisFound 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">thisFound </span><span class="s5">= </span><span class="s4">false</span><span class="s1">;</span>

        <span class="s2">this</span><span class="s1">.</span><span class="s2">__left </span><span class="s5">= </span><span class="s1">[];</span>

        <span class="s6">/**</span>
         <span class="s6">* Reference to the parent </span><span class="s2">{</span><span class="s5">@link </span><span class="s2">Scope|scope}</span><span class="s6">. 
         * </span><span class="s5">@member </span><span class="s2">{Scope} Scope</span><span class="s6">#upper 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">upper </span><span class="s5">= </span><span class="s2">upperScope</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* Whether 'use strict' is in effect in this scope. 
         * </span><span class="s5">@member </span><span class="s2">{boolean} Scope</span><span class="s6">#isStrict 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">isStrict </span><span class="s5">= </span><span class="s2">scopeManager</span><span class="s1">.</span><span class="s3">isStrictModeSupported</span><span class="s1">()</span>
            <span class="s5">? </span><span class="s3">isStrictScope</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s2">isMethodDefinition</span><span class="s1">, </span><span class="s2">scopeManager</span><span class="s1">.</span><span class="s3">__useDirective</span><span class="s1">())</span>
            <span class="s5">: </span><span class="s4">false</span><span class="s1">;</span>

        <span class="s6">/**</span>
         <span class="s6">* List of nested </span><span class="s2">{</span><span class="s5">@link </span><span class="s2">Scope}</span><span class="s6">s. 
         * </span><span class="s5">@member </span><span class="s2">{Scope[]} Scope</span><span class="s6">#childScopes 
         */</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">childScopes </span><span class="s5">= </span><span class="s1">[];</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">upper</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">upper</span><span class="s1">.</span><span class="s2">childScopes</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">this</span><span class="s1">.</span><span class="s2">__declaredVariables </span><span class="s5">= </span><span class="s2">scopeManager</span><span class="s1">.</span><span class="s2">__declaredVariables</span><span class="s1">;</span>

        <span class="s3">registerScope</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s2">this</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">__shouldStaticallyClose(</span><span class="s2">scopeManager</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s1">(</span><span class="s5">!</span><span class="s2">this</span><span class="s1">.</span><span class="s2">dynamic </span><span class="s5">|| </span><span class="s2">scopeManager</span><span class="s1">.</span><span class="s3">__isOptimistic</span><span class="s1">());</span>
    <span class="s1">}</span>

    <span class="s1">__shouldStaticallyCloseForGlobal(</span><span class="s2">ref</span><span class="s1">) {</span>

        <span class="s6">// On global scope, let/const/class declarations should be resolved statically.</span>
        <span class="s5">const </span><span class="s1">name </span><span class="s5">= </span><span class="s2">ref</span><span class="s1">.</span><span class="s2">identifier</span><span class="s1">.</span><span class="s2">name</span><span class="s1">;</span>

        <span class="s5">if </span><span class="s1">(</span><span class="s5">!</span><span class="s2">this</span><span class="s1">.</span><span class="s2">set</span><span class="s1">.</span><span class="s3">has</span><span class="s1">(</span><span class="s2">name</span><span class="s1">)) {</span>
            <span class="s5">return </span><span class="s4">false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s5">const </span><span class="s1">variable </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">set</span><span class="s1">.</span><span class="s3">get</span><span class="s1">(</span><span class="s2">name</span><span class="s1">);</span>
        <span class="s5">const </span><span class="s1">defs </span><span class="s5">= </span><span class="s2">variable</span><span class="s1">.</span><span class="s2">defs</span><span class="s1">;</span>

        <span class="s5">return </span><span class="s2">defs</span><span class="s1">.length </span><span class="s5">&gt; </span><span class="s7">0 </span><span class="s5">&amp;&amp; </span><span class="s2">defs</span><span class="s1">.</span><span class="s3">every</span><span class="s1">(</span><span class="s2">shouldBeStatically</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">__staticCloseRef(</span><span class="s2">ref</span><span class="s1">) {</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s5">!</span><span class="s2">this</span><span class="s1">.</span><span class="s3">__resolve</span><span class="s1">(</span><span class="s2">ref</span><span class="s1">)) {</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s3">__delegateToUpperScope</span><span class="s1">(</span><span class="s2">ref</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">__dynamicCloseRef(</span><span class="s2">ref</span><span class="s1">) {</span>

        <span class="s6">// notify all names are through to global</span>
        <span class="s5">let </span><span class="s1">current </span><span class="s5">= </span><span class="s2">this</span><span class="s1">;</span>

        <span class="s5">do </span><span class="s1">{</span>
            <span class="s2">current</span><span class="s1">.</span><span class="s2">through</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">ref</span><span class="s1">);</span>
            <span class="s2">current </span><span class="s5">= </span><span class="s2">current</span><span class="s1">.</span><span class="s2">upper</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s5">while </span><span class="s1">(</span><span class="s2">current</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">__globalCloseRef(</span><span class="s2">ref</span><span class="s1">) {</span>

        <span class="s6">// let/const/class declarations should be resolved statically.</span>
        <span class="s6">// others should be resolved dynamically.</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s3">__shouldStaticallyCloseForGlobal</span><span class="s1">(</span><span class="s2">ref</span><span class="s1">)) {</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s3">__staticCloseRef</span><span class="s1">(</span><span class="s2">ref</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s3">__dynamicCloseRef</span><span class="s1">(</span><span class="s2">ref</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">__close(</span><span class="s2">scopeManager</span><span class="s1">) {</span>
        <span class="s5">let </span><span class="s1">closeRef;</span>

        <span class="s5">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s3">__shouldStaticallyClose</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">)) {</span>
            <span class="s2">closeRef </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__staticCloseRef</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">type </span><span class="s5">!== </span><span class="s0">&quot;global&quot;</span><span class="s1">) {</span>
            <span class="s2">closeRef </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__dynamicCloseRef</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
            <span class="s2">closeRef </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__globalCloseRef</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s6">// Try Resolving all references in this scope.</span>
        <span class="s5">for </span><span class="s1">(</span><span class="s5">let </span><span class="s1">i </span><span class="s5">= </span><span class="s7">0</span><span class="s1">, iz </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__left</span><span class="s1">.length; </span><span class="s2">i </span><span class="s5">&lt; </span><span class="s2">iz</span><span class="s1">; </span><span class="s5">++</span><span class="s2">i</span><span class="s1">) {</span>
            <span class="s5">const </span><span class="s1">ref </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__left</span><span class="s1">[</span><span class="s2">i</span><span class="s1">];</span>

            <span class="s2">closeRef</span><span class="s1">.</span><span class="s3">call</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">ref</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">__left </span><span class="s5">= </span><span class="s4">null</span><span class="s1">;</span>

        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">upper</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s6">// To override by function scopes.</span>
    <span class="s6">// References in default parameters isn't resolved to variables which are in their function body.</span>
    <span class="s1">__isValidResolution(</span><span class="s2">ref</span><span class="s1">, </span><span class="s2">variable</span><span class="s1">) { </span><span class="s6">// eslint-disable-line class-methods-use-this, no-unused-vars</span>
        <span class="s5">return </span><span class="s4">true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">__resolve(</span><span class="s2">ref</span><span class="s1">) {</span>
        <span class="s5">const </span><span class="s1">name </span><span class="s5">= </span><span class="s2">ref</span><span class="s1">.</span><span class="s2">identifier</span><span class="s1">.</span><span class="s2">name</span><span class="s1">;</span>

        <span class="s5">if </span><span class="s1">(</span><span class="s5">!</span><span class="s2">this</span><span class="s1">.</span><span class="s2">set</span><span class="s1">.</span><span class="s3">has</span><span class="s1">(</span><span class="s2">name</span><span class="s1">)) {</span>
            <span class="s5">return </span><span class="s4">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s5">const </span><span class="s1">variable </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">set</span><span class="s1">.</span><span class="s3">get</span><span class="s1">(</span><span class="s2">name</span><span class="s1">);</span>

        <span class="s5">if </span><span class="s1">(</span><span class="s5">!</span><span class="s2">this</span><span class="s1">.</span><span class="s3">__isValidResolution</span><span class="s1">(</span><span class="s2">ref</span><span class="s1">, </span><span class="s2">variable</span><span class="s1">)) {</span>
            <span class="s5">return </span><span class="s4">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">variable</span><span class="s1">.</span><span class="s2">references</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">ref</span><span class="s1">);</span>
        <span class="s2">variable</span><span class="s1">.</span><span class="s2">stack </span><span class="s5">= </span><span class="s2">variable</span><span class="s1">.</span><span class="s2">stack </span><span class="s5">&amp;&amp; </span><span class="s2">ref</span><span class="s1">.</span><span class="s2">from</span><span class="s1">.</span><span class="s2">variableScope </span><span class="s5">=== </span><span class="s2">this</span><span class="s1">.</span><span class="s2">variableScope</span><span class="s1">;</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">ref</span><span class="s1">.</span><span class="s2">tainted</span><span class="s1">) {</span>
            <span class="s2">variable</span><span class="s1">.</span><span class="s2">tainted </span><span class="s5">= </span><span class="s4">true</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">taints</span><span class="s1">.</span><span class="s3">set</span><span class="s1">(</span><span class="s2">variable</span><span class="s1">.</span><span class="s2">name</span><span class="s1">, </span><span class="s4">true</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">ref</span><span class="s1">.</span><span class="s2">resolved </span><span class="s5">= </span><span class="s2">variable</span><span class="s1">;</span>

        <span class="s5">return </span><span class="s4">true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">__delegateToUpperScope(</span><span class="s2">ref</span><span class="s1">) {</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">upper</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">upper</span><span class="s1">.</span><span class="s2">__left</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">ref</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">through</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">ref</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">__addDeclaredVariablesOfNode(</span><span class="s2">variable</span><span class="s1">, </span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">node </span><span class="s5">=== </span><span class="s4">null </span><span class="s5">|| </span><span class="s2">node </span><span class="s5">=== </span><span class="s4">undefined</span><span class="s1">) {</span>
            <span class="s5">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s5">let </span><span class="s1">variables </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__declaredVariables</span><span class="s1">.</span><span class="s3">get</span><span class="s1">(</span><span class="s2">node</span><span class="s1">);</span>

        <span class="s5">if </span><span class="s1">(</span><span class="s2">variables </span><span class="s5">=== </span><span class="s4">null </span><span class="s5">|| </span><span class="s2">variables </span><span class="s5">=== </span><span class="s4">undefined</span><span class="s1">) {</span>
            <span class="s2">variables </span><span class="s5">= </span><span class="s1">[];</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">__declaredVariables</span><span class="s1">.</span><span class="s3">set</span><span class="s1">(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">variables</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">variables</span><span class="s1">.</span><span class="s3">indexOf</span><span class="s1">(</span><span class="s2">variable</span><span class="s1">) </span><span class="s5">=== -</span><span class="s7">1</span><span class="s1">) {</span>
            <span class="s2">variables</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">variable</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">__defineGeneric(</span><span class="s2">name</span><span class="s1">, </span><span class="s2">set</span><span class="s1">, </span><span class="s2">variables</span><span class="s1">, </span><span class="s2">node</span><span class="s1">, </span><span class="s2">def</span><span class="s1">) {</span>
        <span class="s5">let </span><span class="s1">variable;</span>

        <span class="s2">variable </span><span class="s5">= </span><span class="s2">set</span><span class="s1">.</span><span class="s3">get</span><span class="s1">(</span><span class="s2">name</span><span class="s1">);</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s5">!</span><span class="s2">variable</span><span class="s1">) {</span>
            <span class="s2">variable </span><span class="s5">= new </span><span class="s3">Variable</span><span class="s1">(</span><span class="s2">name</span><span class="s1">, </span><span class="s2">this</span><span class="s1">);</span>
            <span class="s2">set</span><span class="s1">.</span><span class="s3">set</span><span class="s1">(</span><span class="s2">name</span><span class="s1">, </span><span class="s2">variable</span><span class="s1">);</span>
            <span class="s2">variables</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">variable</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s5">if </span><span class="s1">(</span><span class="s2">def</span><span class="s1">) {</span>
            <span class="s2">variable</span><span class="s1">.</span><span class="s2">defs</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">def</span><span class="s1">);</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s3">__addDeclaredVariablesOfNode</span><span class="s1">(</span><span class="s2">variable</span><span class="s1">, </span><span class="s2">def</span><span class="s1">.</span><span class="s2">node</span><span class="s1">);</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s3">__addDeclaredVariablesOfNode</span><span class="s1">(</span><span class="s2">variable</span><span class="s1">, </span><span class="s2">def</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">node</span><span class="s1">) {</span>
            <span class="s2">variable</span><span class="s1">.</span><span class="s2">identifiers</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">node</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">__define(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">def</span><span class="s1">) {</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">node </span><span class="s5">&amp;&amp; </span><span class="s2">node</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s2">Syntax$2</span><span class="s1">.</span><span class="s2">Identifier</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s3">__defineGeneric</span><span class="s1">(</span>
                <span class="s2">node</span><span class="s1">.</span><span class="s2">name</span><span class="s1">,</span>
                <span class="s2">this</span><span class="s1">.</span><span class="s2">set</span><span class="s1">,</span>
                <span class="s2">this</span><span class="s1">.</span><span class="s2">variables</span><span class="s1">,</span>
                <span class="s2">node</span><span class="s1">,</span>
                <span class="s2">def</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">__referencing(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">assign</span><span class="s1">, </span><span class="s2">writeExpr</span><span class="s1">, </span><span class="s2">maybeImplicitGlobal</span><span class="s1">, </span><span class="s2">partial</span><span class="s1">, </span><span class="s2">init</span><span class="s1">) {</span>

        <span class="s6">// because Array element may be null</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s5">!</span><span class="s2">node </span><span class="s5">|| </span><span class="s2">node</span><span class="s1">.</span><span class="s2">type </span><span class="s5">!== </span><span class="s2">Syntax$2</span><span class="s1">.</span><span class="s2">Identifier</span><span class="s1">) {</span>
            <span class="s5">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s6">// Specially handle like `this`.</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">name </span><span class="s5">=== </span><span class="s0">&quot;super&quot;</span><span class="s1">) {</span>
            <span class="s5">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s5">const </span><span class="s1">ref </span><span class="s5">= new </span><span class="s3">Reference</span><span class="s1">(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">this</span><span class="s1">, </span><span class="s2">assign </span><span class="s5">|| </span><span class="s2">Reference</span><span class="s1">.</span><span class="s2">READ</span><span class="s1">, </span><span class="s2">writeExpr</span><span class="s1">, </span><span class="s2">maybeImplicitGlobal</span><span class="s1">, </span><span class="s5">!!</span><span class="s2">partial</span><span class="s1">, </span><span class="s5">!!</span><span class="s2">init</span><span class="s1">);</span>

        <span class="s2">this</span><span class="s1">.</span><span class="s2">references</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">ref</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">__left</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">ref</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">__detectEval() {</span>
        <span class="s5">let </span><span class="s1">current </span><span class="s5">= </span><span class="s2">this</span><span class="s1">;</span>

        <span class="s2">this</span><span class="s1">.</span><span class="s2">directCallToEvalScope </span><span class="s5">= </span><span class="s4">true</span><span class="s1">;</span>
        <span class="s5">do </span><span class="s1">{</span>
            <span class="s2">current</span><span class="s1">.</span><span class="s2">dynamic </span><span class="s5">= </span><span class="s4">true</span><span class="s1">;</span>
            <span class="s2">current </span><span class="s5">= </span><span class="s2">current</span><span class="s1">.</span><span class="s2">upper</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s5">while </span><span class="s1">(</span><span class="s2">current</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">__detectThis() {</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">thisFound </span><span class="s5">= </span><span class="s4">true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">__isClosed() {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__left </span><span class="s5">=== </span><span class="s4">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s6">/**</span>
     <span class="s6">* returns resolved {Reference} 
     * </span><span class="s5">@function </span><span class="s2">Scope#resolve</span>
     <span class="s6">* </span><span class="s5">@param </span><span class="s2">{Espree.Identifier} ident </span><span class="s6">identifier to be resolved. 
     * </span><span class="s5">@returns </span><span class="s2">{Reference} </span><span class="s6">reference 
     */</span>
    <span class="s1">resolve(</span><span class="s2">ident</span><span class="s1">) {</span>
        <span class="s5">let </span><span class="s1">ref, i, iz;</span>

        <span class="s2">assert__default</span><span class="s1">[</span><span class="s0">&quot;default&quot;</span><span class="s1">](</span><span class="s2">this</span><span class="s1">.</span><span class="s3">__isClosed</span><span class="s1">(), </span><span class="s0">&quot;Scope should be closed.&quot;</span><span class="s1">);</span>
        <span class="s2">assert__default</span><span class="s1">[</span><span class="s0">&quot;default&quot;</span><span class="s1">](</span><span class="s2">ident</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s2">Syntax$2</span><span class="s1">.</span><span class="s2">Identifier</span><span class="s1">, </span><span class="s0">&quot;Target should be identifier.&quot;</span><span class="s1">);</span>
        <span class="s5">for </span><span class="s1">(</span><span class="s2">i </span><span class="s5">= </span><span class="s7">0</span><span class="s1">, </span><span class="s2">iz </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">references</span><span class="s1">.length; </span><span class="s2">i </span><span class="s5">&lt; </span><span class="s2">iz</span><span class="s1">; </span><span class="s5">++</span><span class="s2">i</span><span class="s1">) {</span>
            <span class="s2">ref </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">references</span><span class="s1">[</span><span class="s2">i</span><span class="s1">];</span>
            <span class="s5">if </span><span class="s1">(</span><span class="s2">ref</span><span class="s1">.</span><span class="s2">identifier </span><span class="s5">=== </span><span class="s2">ident</span><span class="s1">) {</span>
                <span class="s5">return </span><span class="s2">ref</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s5">return </span><span class="s4">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s6">/**</span>
     <span class="s6">* returns this scope is static 
     * </span><span class="s5">@function </span><span class="s2">Scope#isStatic</span>
     <span class="s6">* </span><span class="s5">@returns </span><span class="s2">{boolean} </span><span class="s6">static 
     */</span>
    <span class="s1">isStatic() {</span>
        <span class="s5">return !</span><span class="s2">this</span><span class="s1">.</span><span class="s2">dynamic</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s6">/**</span>
     <span class="s6">* returns this scope has materialized arguments 
     * </span><span class="s5">@function </span><span class="s2">Scope#isArgumentsMaterialized</span>
     <span class="s6">* </span><span class="s5">@returns </span><span class="s2">{boolean} </span><span class="s6">arguemnts materialized 
     */</span>
    <span class="s1">isArgumentsMaterialized() { </span><span class="s6">// eslint-disable-line class-methods-use-this</span>
        <span class="s5">return </span><span class="s4">true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s6">/**</span>
     <span class="s6">* returns this scope has materialized `this` reference 
     * </span><span class="s5">@function </span><span class="s2">Scope#isThisMaterialized</span>
     <span class="s6">* </span><span class="s5">@returns </span><span class="s2">{boolean} </span><span class="s6">this materialized 
     */</span>
    <span class="s1">isThisMaterialized() { </span><span class="s6">// eslint-disable-line class-methods-use-this</span>
        <span class="s5">return </span><span class="s4">true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">isUsedName(</span><span class="s2">name</span><span class="s1">) {</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">set</span><span class="s1">.</span><span class="s3">has</span><span class="s1">(</span><span class="s2">name</span><span class="s1">)) {</span>
            <span class="s5">return </span><span class="s4">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s5">for </span><span class="s1">(</span><span class="s5">let </span><span class="s1">i </span><span class="s5">= </span><span class="s7">0</span><span class="s1">, iz </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">through</span><span class="s1">.length; </span><span class="s2">i </span><span class="s5">&lt; </span><span class="s2">iz</span><span class="s1">; </span><span class="s5">++</span><span class="s2">i</span><span class="s1">) {</span>
            <span class="s5">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">through</span><span class="s1">[</span><span class="s2">i</span><span class="s1">].</span><span class="s2">identifier</span><span class="s1">.</span><span class="s2">name </span><span class="s5">=== </span><span class="s2">name</span><span class="s1">) {</span>
                <span class="s5">return </span><span class="s4">true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s5">return </span><span class="s4">false</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">class </span><span class="s2">GlobalScope </span><span class="s5">extends </span><span class="s2">Scope </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s2">block</span><span class="s1">) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s0">&quot;global&quot;</span><span class="s1">, </span><span class="s4">null</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s4">false</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">implicit </span><span class="s5">= </span><span class="s1">{</span>
            <span class="s1">set: </span><span class="s5">new </span><span class="s3">Map</span><span class="s1">(),</span>
            <span class="s1">variables: [],</span>

            <span class="s6">/**</span>
             <span class="s6">* List of </span><span class="s2">{</span><span class="s5">@link </span><span class="s2">Reference}</span><span class="s6">s that are left to be resolved (i.e. which 
             * need to be linked to the variable they refer to). 
             * </span><span class="s5">@member </span><span class="s2">{Reference[]} Scope</span><span class="s6">#implicit#left 
             */</span>
            <span class="s1">left: []</span>
        <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s1">__close(</span><span class="s2">scopeManager</span><span class="s1">) {</span>
        <span class="s5">const </span><span class="s1">implicit </span><span class="s5">= </span><span class="s1">[];</span>

        <span class="s5">for </span><span class="s1">(</span><span class="s5">let </span><span class="s1">i </span><span class="s5">= </span><span class="s7">0</span><span class="s1">, iz </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__left</span><span class="s1">.length; </span><span class="s2">i </span><span class="s5">&lt; </span><span class="s2">iz</span><span class="s1">; </span><span class="s5">++</span><span class="s2">i</span><span class="s1">) {</span>
            <span class="s5">const </span><span class="s1">ref </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__left</span><span class="s1">[</span><span class="s2">i</span><span class="s1">];</span>

            <span class="s5">if </span><span class="s1">(</span><span class="s2">ref</span><span class="s1">.</span><span class="s2">__maybeImplicitGlobal </span><span class="s5">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.</span><span class="s2">set</span><span class="s1">.</span><span class="s3">has</span><span class="s1">(</span><span class="s2">ref</span><span class="s1">.</span><span class="s2">identifier</span><span class="s1">.</span><span class="s2">name</span><span class="s1">)) {</span>
                <span class="s2">implicit</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">ref</span><span class="s1">.</span><span class="s2">__maybeImplicitGlobal</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s6">// create an implicit global variable from assignment expression</span>
        <span class="s5">for </span><span class="s1">(</span><span class="s5">let </span><span class="s1">i </span><span class="s5">= </span><span class="s7">0</span><span class="s1">, iz </span><span class="s5">= </span><span class="s2">implicit</span><span class="s1">.length; </span><span class="s2">i </span><span class="s5">&lt; </span><span class="s2">iz</span><span class="s1">; </span><span class="s5">++</span><span class="s2">i</span><span class="s1">) {</span>
            <span class="s5">const </span><span class="s1">info </span><span class="s5">= </span><span class="s2">implicit</span><span class="s1">[</span><span class="s2">i</span><span class="s1">];</span>

            <span class="s2">this</span><span class="s1">.</span><span class="s3">__defineImplicit</span><span class="s1">(</span><span class="s2">info</span><span class="s1">.</span><span class="s2">pattern</span><span class="s1">,</span>
                <span class="s5">new </span><span class="s3">Definition</span><span class="s1">(</span>
                    <span class="s2">Variable</span><span class="s1">.</span><span class="s2">ImplicitGlobalVariable</span><span class="s1">,</span>
                    <span class="s2">info</span><span class="s1">.</span><span class="s2">pattern</span><span class="s1">,</span>
                    <span class="s2">info</span><span class="s1">.</span><span class="s2">node</span><span class="s1">,</span>
                    <span class="s4">null</span><span class="s1">,</span>
                    <span class="s4">null</span><span class="s1">,</span>
                    <span class="s4">null</span>
                <span class="s1">));</span>

        <span class="s1">}</span>

        <span class="s2">this</span><span class="s1">.</span><span class="s2">implicit</span><span class="s1">.</span><span class="s2">left </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__left</span><span class="s1">;</span>

        <span class="s5">return </span><span class="s2">super</span><span class="s1">.</span><span class="s3">__close</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">__defineImplicit(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">def</span><span class="s1">) {</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">node </span><span class="s5">&amp;&amp; </span><span class="s2">node</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s2">Syntax$2</span><span class="s1">.</span><span class="s2">Identifier</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s3">__defineGeneric</span><span class="s1">(</span>
                <span class="s2">node</span><span class="s1">.</span><span class="s2">name</span><span class="s1">,</span>
                <span class="s2">this</span><span class="s1">.</span><span class="s2">implicit</span><span class="s1">.</span><span class="s2">set</span><span class="s1">,</span>
                <span class="s2">this</span><span class="s1">.</span><span class="s2">implicit</span><span class="s1">.</span><span class="s2">variables</span><span class="s1">,</span>
                <span class="s2">node</span><span class="s1">,</span>
                <span class="s2">def</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">class </span><span class="s2">ModuleScope </span><span class="s5">extends </span><span class="s2">Scope </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s0">&quot;module&quot;</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s4">false</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">class </span><span class="s2">FunctionExpressionNameScope </span><span class="s5">extends </span><span class="s2">Scope </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s0">&quot;function-expression-name&quot;</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s4">false</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s3">__define</span><span class="s1">(</span><span class="s2">block</span><span class="s1">.</span><span class="s2">id</span><span class="s1">,</span>
            <span class="s5">new </span><span class="s3">Definition</span><span class="s1">(</span>
                <span class="s2">Variable</span><span class="s1">.</span><span class="s2">FunctionName</span><span class="s1">,</span>
                <span class="s2">block</span><span class="s1">.</span><span class="s2">id</span><span class="s1">,</span>
                <span class="s2">block</span><span class="s1">,</span>
                <span class="s4">null</span><span class="s1">,</span>
                <span class="s4">null</span><span class="s1">,</span>
                <span class="s4">null</span>
            <span class="s1">));</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">functionExpressionScope </span><span class="s5">= </span><span class="s4">true</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">class </span><span class="s2">CatchScope </span><span class="s5">extends </span><span class="s2">Scope </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s0">&quot;catch&quot;</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s4">false</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">class </span><span class="s2">WithScope </span><span class="s5">extends </span><span class="s2">Scope </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s0">&quot;with&quot;</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s4">false</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">__close(</span><span class="s2">scopeManager</span><span class="s1">) {</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s3">__shouldStaticallyClose</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">)) {</span>
            <span class="s5">return </span><span class="s2">super</span><span class="s1">.</span><span class="s3">__close</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s5">for </span><span class="s1">(</span><span class="s5">let </span><span class="s1">i </span><span class="s5">= </span><span class="s7">0</span><span class="s1">, iz </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__left</span><span class="s1">.length; </span><span class="s2">i </span><span class="s5">&lt; </span><span class="s2">iz</span><span class="s1">; </span><span class="s5">++</span><span class="s2">i</span><span class="s1">) {</span>
            <span class="s5">const </span><span class="s1">ref </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__left</span><span class="s1">[</span><span class="s2">i</span><span class="s1">];</span>

            <span class="s2">ref</span><span class="s1">.</span><span class="s2">tainted </span><span class="s5">= </span><span class="s4">true</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s3">__delegateToUpperScope</span><span class="s1">(</span><span class="s2">ref</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">__left </span><span class="s5">= </span><span class="s4">null</span><span class="s1">;</span>

        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">upper</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">class </span><span class="s2">BlockScope </span><span class="s5">extends </span><span class="s2">Scope </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s0">&quot;block&quot;</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s4">false</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">class </span><span class="s2">SwitchScope </span><span class="s5">extends </span><span class="s2">Scope </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s0">&quot;switch&quot;</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s4">false</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">class </span><span class="s2">FunctionScope </span><span class="s5">extends </span><span class="s2">Scope </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s2">isMethodDefinition</span><span class="s1">) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s0">&quot;function&quot;</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s2">isMethodDefinition</span><span class="s1">);</span>

        <span class="s6">// section 9.2.13, FunctionDeclarationInstantiation.</span>
        <span class="s6">// NOTE Arrow functions never have an arguments objects.</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">block</span><span class="s1">.</span><span class="s2">type </span><span class="s5">!== </span><span class="s2">Syntax$2</span><span class="s1">.</span><span class="s2">ArrowFunctionExpression</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s3">__defineArguments</span><span class="s1">();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">isArgumentsMaterialized() {</span>

        <span class="s6">// TODO(Constellation)</span>
        <span class="s6">// We can more aggressive on this condition like this.</span>
        <span class="s6">//</span>
        <span class="s6">// function t() {</span>
        <span class="s6">//     // arguments of t is always hidden.</span>
        <span class="s6">//     function arguments() {</span>
        <span class="s6">//     }</span>
        <span class="s6">// }</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">block</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s2">Syntax$2</span><span class="s1">.</span><span class="s2">ArrowFunctionExpression</span><span class="s1">) {</span>
            <span class="s5">return </span><span class="s4">false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s5">if </span><span class="s1">(</span><span class="s5">!</span><span class="s2">this</span><span class="s1">.</span><span class="s3">isStatic</span><span class="s1">()) {</span>
            <span class="s5">return </span><span class="s4">true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s5">const </span><span class="s1">variable </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">set</span><span class="s1">.</span><span class="s3">get</span><span class="s1">(</span><span class="s0">&quot;arguments&quot;</span><span class="s1">);</span>

        <span class="s2">assert__default</span><span class="s1">[</span><span class="s0">&quot;default&quot;</span><span class="s1">](</span><span class="s2">variable</span><span class="s1">, </span><span class="s0">&quot;Always have arguments variable.&quot;</span><span class="s1">);</span>
        <span class="s5">return </span><span class="s2">variable</span><span class="s1">.</span><span class="s2">tainted </span><span class="s5">|| </span><span class="s2">variable</span><span class="s1">.</span><span class="s2">references</span><span class="s1">.length </span><span class="s5">!== </span><span class="s7">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">isThisMaterialized() {</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s5">!</span><span class="s2">this</span><span class="s1">.</span><span class="s3">isStatic</span><span class="s1">()) {</span>
            <span class="s5">return </span><span class="s4">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">thisFound</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">__defineArguments() {</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s3">__defineGeneric</span><span class="s1">(</span>
            <span class="s0">&quot;arguments&quot;</span><span class="s1">,</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">set</span><span class="s1">,</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">variables</span><span class="s1">,</span>
            <span class="s4">null</span><span class="s1">,</span>
            <span class="s4">null</span>
        <span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">taints</span><span class="s1">.</span><span class="s3">set</span><span class="s1">(</span><span class="s0">&quot;arguments&quot;</span><span class="s1">, </span><span class="s4">true</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s6">// References in default parameters isn't resolved to variables which are in their function body.</span>
    <span class="s6">//     const x = 1</span>
    <span class="s6">//     function f(a = x) { // This `x` is resolved to the `x` in the outer scope.</span>
    <span class="s6">//         const x = 2</span>
    <span class="s6">//         console.log(a)</span>
    <span class="s6">//     }</span>
    <span class="s1">__isValidResolution(</span><span class="s2">ref</span><span class="s1">, </span><span class="s2">variable</span><span class="s1">) {</span>

        <span class="s6">// If `options.nodejsScope` is true, `this.block` becomes a Program node.</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">block</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s0">&quot;Program&quot;</span><span class="s1">) {</span>
            <span class="s5">return </span><span class="s4">true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s5">const </span><span class="s1">bodyStart </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">block</span><span class="s1">.</span><span class="s2">body</span><span class="s1">.</span><span class="s2">range</span><span class="s1">[</span><span class="s7">0</span><span class="s1">];</span>

        <span class="s6">// It's invalid resolution in the following case:</span>
        <span class="s5">return !</span><span class="s1">(</span>
            <span class="s2">variable</span><span class="s1">.</span><span class="s2">scope </span><span class="s5">=== </span><span class="s2">this </span><span class="s5">&amp;&amp;</span>
            <span class="s2">ref</span><span class="s1">.</span><span class="s2">identifier</span><span class="s1">.</span><span class="s2">range</span><span class="s1">[</span><span class="s7">0</span><span class="s1">] </span><span class="s5">&lt; </span><span class="s2">bodyStart </span><span class="s5">&amp;&amp; </span><span class="s6">// the reference is in the parameter part.</span>
            <span class="s2">variable</span><span class="s1">.</span><span class="s2">defs</span><span class="s1">.</span><span class="s3">every</span><span class="s1">(</span><span class="s2">d </span><span class="s5">=&gt; </span><span class="s2">d</span><span class="s1">.</span><span class="s2">name</span><span class="s1">.</span><span class="s2">range</span><span class="s1">[</span><span class="s7">0</span><span class="s1">] </span><span class="s5">&gt;= </span><span class="s2">bodyStart</span><span class="s1">) </span><span class="s6">// the variable is in the body.</span>
        <span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">class </span><span class="s2">ForScope </span><span class="s5">extends </span><span class="s2">Scope </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s0">&quot;for&quot;</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s4">false</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">class </span><span class="s2">ClassScope </span><span class="s5">extends </span><span class="s2">Scope </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s0">&quot;class&quot;</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s4">false</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">class </span><span class="s2">ClassFieldInitializerScope </span><span class="s5">extends </span><span class="s2">Scope </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s0">&quot;class-field-initializer&quot;</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s4">true</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">class </span><span class="s2">ClassStaticBlockScope </span><span class="s5">extends </span><span class="s2">Scope </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s0">&quot;class-static-block&quot;</span><span class="s1">, </span><span class="s2">upperScope</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s4">true</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s6">/* vim: set sw=4 ts=4 et tw=80 : */</span>

<span class="s6">/*</span>
  <span class="s6">Copyright (C) 2015 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt; 
</span>
  <span class="s6">Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are met: 
</span>
    <span class="s6">* Redistributions of source code must retain the above copyright 
      notice, this list of conditions and the following disclaimer. 
    * Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution. 
</span>
  <span class="s6">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY 
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
*/</span>

<span class="s6">/**</span>
 <span class="s6">* </span><span class="s5">@constructor </span><span class="s6">ScopeManager 
 */</span>
<span class="s5">class </span><span class="s2">ScopeManager </span><span class="s1">{</span>
    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">options</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">scopes </span><span class="s5">= </span><span class="s1">[];</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">globalScope </span><span class="s5">= </span><span class="s4">null</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">__nodeToScope </span><span class="s5">= new </span><span class="s3">WeakMap</span><span class="s1">();</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">__currentScope </span><span class="s5">= </span><span class="s4">null</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">__options </span><span class="s5">= </span><span class="s2">options</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">__declaredVariables </span><span class="s5">= new </span><span class="s3">WeakMap</span><span class="s1">();</span>
    <span class="s1">}</span>

    <span class="s1">__useDirective() {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__options</span><span class="s1">.</span><span class="s2">directive</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">__isOptimistic() {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__options</span><span class="s1">.</span><span class="s2">optimistic</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">__ignoreEval() {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__options</span><span class="s1">.</span><span class="s2">ignoreEval</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">isGlobalReturn() {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__options</span><span class="s1">.</span><span class="s2">nodejsScope </span><span class="s5">|| </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__options</span><span class="s1">.</span><span class="s2">sourceType </span><span class="s5">=== </span><span class="s0">&quot;commonjs&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">isModule() {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__options</span><span class="s1">.</span><span class="s2">sourceType </span><span class="s5">=== </span><span class="s0">&quot;module&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">isImpliedStrict() {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__options</span><span class="s1">.</span><span class="s2">impliedStrict</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">isStrictModeSupported() {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__options</span><span class="s1">.</span><span class="s2">ecmaVersion </span><span class="s5">&gt;= </span><span class="s7">5</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s6">// Returns appropriate scope for this node.</span>
    <span class="s1">__get(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__nodeToScope</span><span class="s1">.</span><span class="s3">get</span><span class="s1">(</span><span class="s2">node</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s6">/**</span>
     <span class="s6">* Get variables that are declared by the node. 
     * 
     * &quot;are declared by the node&quot; means the node is same as `Variable.defs[].node` or `Variable.defs[].parent`. 
     * If the node declares nothing, this method returns an empty array. 
     * CAUTION: This API is experimental. See https://github.com/estools/escope/pull/69 for more details. 
     * </span><span class="s5">@param </span><span class="s2">{Espree.Node} node </span><span class="s6">a node to get. 
     * </span><span class="s5">@returns </span><span class="s2">{Variable[]} </span><span class="s6">variables that declared by the node. 
     */</span>
    <span class="s1">getDeclaredVariables(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__declaredVariables</span><span class="s1">.</span><span class="s3">get</span><span class="s1">(</span><span class="s2">node</span><span class="s1">) </span><span class="s5">|| </span><span class="s1">[];</span>
    <span class="s1">}</span>

    <span class="s6">/**</span>
     <span class="s6">* acquire scope from node. 
     * </span><span class="s5">@function </span><span class="s2">ScopeManager#acquire</span>
     <span class="s6">* </span><span class="s5">@param </span><span class="s2">{Espree.Node} node </span><span class="s6">node for the acquired scope. 
     * </span><span class="s5">@param </span><span class="s2">{?boolean} [inner</span><span class="s5">=</span><span class="s2">false] </span><span class="s6">look up the most inner scope, default value is false. 
     * </span><span class="s5">@returns </span><span class="s2">{Scope?} </span><span class="s6">Scope from node 
     */</span>
    <span class="s1">acquire(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">inner</span><span class="s1">) {</span>

        <span class="s6">/**</span>
         <span class="s6">* predicate 
         * </span><span class="s5">@param </span><span class="s2">{Scope} testScope </span><span class="s6">scope to test 
         * </span><span class="s5">@returns </span><span class="s2">{boolean} </span><span class="s6">predicate 
         */</span>
        <span class="s5">function </span><span class="s1">predicate(</span><span class="s2">testScope</span><span class="s1">) {</span>
            <span class="s5">if </span><span class="s1">(</span><span class="s2">testScope</span><span class="s1">.</span><span class="s2">type </span><span class="s5">=== </span><span class="s0">&quot;function&quot; </span><span class="s5">&amp;&amp; </span><span class="s2">testScope</span><span class="s1">.</span><span class="s2">functionExpressionScope</span><span class="s1">) {</span>
                <span class="s5">return </span><span class="s4">false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s5">return </span><span class="s4">true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s5">const </span><span class="s1">scopes </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s3">__get</span><span class="s1">(</span><span class="s2">node</span><span class="s1">);</span>

        <span class="s5">if </span><span class="s1">(</span><span class="s5">!</span><span class="s2">scopes </span><span class="s5">|| </span><span class="s2">scopes</span><span class="s1">.length </span><span class="s5">=== </span><span class="s7">0</span><span class="s1">) {</span>
            <span class="s5">return </span><span class="s4">null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s6">// Heuristic selection from all scopes.</span>
        <span class="s6">// If you would like to get all scopes, please use ScopeManager#acquireAll.</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">scopes</span><span class="s1">.length </span><span class="s5">=== </span><span class="s7">1</span><span class="s1">) {</span>
            <span class="s5">return </span><span class="s2">scopes</span><span class="s1">[</span><span class="s7">0</span><span class="s1">];</span>
        <span class="s1">}</span>

        <span class="s5">if </span><span class="s1">(</span><span class="s2">inner</span><span class="s1">) {</span>
            <span class="s5">for </span><span class="s1">(</span><span class="s5">let </span><span class="s1">i </span><span class="s5">= </span><span class="s2">scopes</span><span class="s1">.length </span><span class="s5">- </span><span class="s7">1</span><span class="s1">; </span><span class="s2">i </span><span class="s5">&gt;= </span><span class="s7">0</span><span class="s1">; </span><span class="s5">--</span><span class="s2">i</span><span class="s1">) {</span>
                <span class="s5">const </span><span class="s1">scope </span><span class="s5">= </span><span class="s2">scopes</span><span class="s1">[</span><span class="s2">i</span><span class="s1">];</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s3">predicate</span><span class="s1">(</span><span class="s2">scope</span><span class="s1">)) {</span>
                    <span class="s5">return </span><span class="s2">scope</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
            <span class="s5">for </span><span class="s1">(</span><span class="s5">let </span><span class="s1">i </span><span class="s5">= </span><span class="s7">0</span><span class="s1">, iz </span><span class="s5">= </span><span class="s2">scopes</span><span class="s1">.length; </span><span class="s2">i </span><span class="s5">&lt; </span><span class="s2">iz</span><span class="s1">; </span><span class="s5">++</span><span class="s2">i</span><span class="s1">) {</span>
                <span class="s5">const </span><span class="s1">scope </span><span class="s5">= </span><span class="s2">scopes</span><span class="s1">[</span><span class="s2">i</span><span class="s1">];</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s3">predicate</span><span class="s1">(</span><span class="s2">scope</span><span class="s1">)) {</span>
                    <span class="s5">return </span><span class="s2">scope</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s5">return </span><span class="s4">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s6">/**</span>
     <span class="s6">* acquire all scopes from node. 
     * </span><span class="s5">@function </span><span class="s2">ScopeManager#acquireAll</span>
     <span class="s6">* </span><span class="s5">@param </span><span class="s2">{Espree.Node} node </span><span class="s6">node for the acquired scope. 
     * </span><span class="s5">@returns </span><span class="s2">{Scopes?} </span><span class="s6">Scope array 
     */</span>
    <span class="s1">acquireAll(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s3">__get</span><span class="s1">(</span><span class="s2">node</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s6">/**</span>
     <span class="s6">* release the node. 
     * </span><span class="s5">@function </span><span class="s2">ScopeManager#release</span>
     <span class="s6">* </span><span class="s5">@param </span><span class="s2">{Espree.Node} node </span><span class="s6">releasing node. 
     * </span><span class="s5">@param </span><span class="s2">{?boolean} [inner</span><span class="s5">=</span><span class="s2">false] </span><span class="s6">look up the most inner scope, default value is false. 
     * </span><span class="s5">@returns </span><span class="s2">{Scope?} </span><span class="s6">upper scope for the node. 
     */</span>
    <span class="s1">release(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">inner</span><span class="s1">) {</span>
        <span class="s5">const </span><span class="s1">scopes </span><span class="s5">= </span><span class="s2">this</span><span class="s1">.</span><span class="s3">__get</span><span class="s1">(</span><span class="s2">node</span><span class="s1">);</span>

        <span class="s5">if </span><span class="s1">(</span><span class="s2">scopes </span><span class="s5">&amp;&amp; </span><span class="s2">scopes</span><span class="s1">.length) {</span>
            <span class="s5">const </span><span class="s1">scope </span><span class="s5">= </span><span class="s2">scopes</span><span class="s1">[</span><span class="s7">0</span><span class="s1">].</span><span class="s2">upper</span><span class="s1">;</span>

            <span class="s5">if </span><span class="s1">(</span><span class="s5">!</span><span class="s2">scope</span><span class="s1">) {</span>
                <span class="s5">return </span><span class="s4">null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s3">acquire</span><span class="s1">(</span><span class="s2">scope</span><span class="s1">.</span><span class="s2">block</span><span class="s1">, </span><span class="s2">inner</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s5">return </span><span class="s4">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">attach() { } </span><span class="s6">// eslint-disable-line class-methods-use-this</span>

    <span class="s1">detach() { } </span><span class="s6">// eslint-disable-line class-methods-use-this</span>

    <span class="s1">__nestScope(</span><span class="s2">scope</span><span class="s1">) {</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">scope </span><span class="s5">instanceof </span><span class="s2">GlobalScope</span><span class="s1">) {</span>
            <span class="s2">assert__default</span><span class="s1">[</span><span class="s0">&quot;default&quot;</span><span class="s1">](</span><span class="s2">this</span><span class="s1">.</span><span class="s2">__currentScope </span><span class="s5">=== </span><span class="s4">null</span><span class="s1">);</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">globalScope </span><span class="s5">= </span><span class="s2">scope</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">__currentScope </span><span class="s5">= </span><span class="s2">scope</span><span class="s1">;</span>
        <span class="s5">return </span><span class="s2">scope</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">__nestGlobalScope(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s3">__nestScope</span><span class="s1">(</span><span class="s5">new </span><span class="s3">GlobalScope</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">node</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s1">__nestBlockScope(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s3">__nestScope</span><span class="s1">(</span><span class="s5">new </span><span class="s3">BlockScope</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__currentScope</span><span class="s1">, </span><span class="s2">node</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s1">__nestFunctionScope(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">isMethodDefinition</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s3">__nestScope</span><span class="s1">(</span><span class="s5">new </span><span class="s3">FunctionScope</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__currentScope</span><span class="s1">, </span><span class="s2">node</span><span class="s1">, </span><span class="s2">isMethodDefinition</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s1">__nestForScope(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s3">__nestScope</span><span class="s1">(</span><span class="s5">new </span><span class="s3">ForScope</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__currentScope</span><span class="s1">, </span><span class="s2">node</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s1">__nestCatchScope(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s3">__nestScope</span><span class="s1">(</span><span class="s5">new </span><span class="s3">CatchScope</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__currentScope</span><span class="s1">, </span><span class="s2">node</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s1">__nestWithScope(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s3">__nestScope</span><span class="s1">(</span><span class="s5">new </span><span class="s3">WithScope</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__currentScope</span><span class="s1">, </span><span class="s2">node</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s1">__nestClassScope(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s3">__nestScope</span><span class="s1">(</span><span class="s5">new </span><span class="s3">ClassScope</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__currentScope</span><span class="s1">, </span><span class="s2">node</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s1">__nestClassFieldInitializerScope(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s3">__nestScope</span><span class="s1">(</span><span class="s5">new </span><span class="s3">ClassFieldInitializerScope</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__currentScope</span><span class="s1">, </span><span class="s2">node</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s1">__nestClassStaticBlockScope(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s3">__nestScope</span><span class="s1">(</span><span class="s5">new </span><span class="s3">ClassStaticBlockScope</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__currentScope</span><span class="s1">, </span><span class="s2">node</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s1">__nestSwitchScope(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s3">__nestScope</span><span class="s1">(</span><span class="s5">new </span><span class="s3">SwitchScope</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__currentScope</span><span class="s1">, </span><span class="s2">node</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s1">__nestModuleScope(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s3">__nestScope</span><span class="s1">(</span><span class="s5">new </span><span class="s3">ModuleScope</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__currentScope</span><span class="s1">, </span><span class="s2">node</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s1">__nestFunctionExpressionNameScope(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s3">__nestScope</span><span class="s1">(</span><span class="s5">new </span><span class="s3">FunctionExpressionNameScope</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__currentScope</span><span class="s1">, </span><span class="s2">node</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s1">__isES6() {</span>
        <span class="s5">return </span><span class="s2">this</span><span class="s1">.</span><span class="s2">__options</span><span class="s1">.</span><span class="s2">ecmaVersion </span><span class="s5">&gt;= </span><span class="s7">6</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s6">/* vim: set sw=4 ts=4 et tw=80 : */</span>

<span class="s6">/*</span>
  <span class="s6">Copyright (C) 2015 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt; 
</span>
  <span class="s6">Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are met: 
</span>
    <span class="s6">* Redistributions of source code must retain the above copyright 
      notice, this list of conditions and the following disclaimer. 
    * Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution. 
</span>
  <span class="s6">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY 
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
*/</span>

<span class="s5">const </span><span class="s1">{ </span><span class="s2">Syntax</span><span class="s1">: Syntax$1 } </span><span class="s5">= </span><span class="s2">estraverse__default</span><span class="s1">[</span><span class="s0">&quot;default&quot;</span><span class="s1">];</span>

<span class="s6">/**</span>
 <span class="s6">* Get last array element 
 * </span><span class="s5">@param </span><span class="s2">{Array} xs </span><span class="s6">array 
 * </span><span class="s5">@returns </span><span class="s2">{any} </span><span class="s6">Last elment 
 */</span>
<span class="s5">function </span><span class="s1">getLast(</span><span class="s2">xs</span><span class="s1">) {</span>
    <span class="s5">return </span><span class="s2">xs</span><span class="s1">[</span><span class="s2">xs</span><span class="s1">.length </span><span class="s5">- </span><span class="s7">1</span><span class="s1">] </span><span class="s5">|| </span><span class="s4">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s5">class </span><span class="s2">PatternVisitor </span><span class="s5">extends </span><span class="s2">esrecurse__default</span><span class="s1">[</span><span class="s0">&quot;default&quot;</span><span class="s1">].</span><span class="s2">Visitor </span><span class="s1">{</span>
    <span class="s5">static </span><span class="s1">isPattern(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s5">const </span><span class="s1">nodeType </span><span class="s5">= </span><span class="s2">node</span><span class="s1">.</span><span class="s2">type</span><span class="s1">;</span>

        <span class="s5">return </span><span class="s1">(</span>
            <span class="s2">nodeType </span><span class="s5">=== </span><span class="s2">Syntax$1</span><span class="s1">.</span><span class="s2">Identifier </span><span class="s5">||</span>
            <span class="s2">nodeType </span><span class="s5">=== </span><span class="s2">Syntax$1</span><span class="s1">.</span><span class="s2">ObjectPattern </span><span class="s5">||</span>
            <span class="s2">nodeType </span><span class="s5">=== </span><span class="s2">Syntax$1</span><span class="s1">.</span><span class="s2">ArrayPattern </span><span class="s5">||</span>
            <span class="s2">nodeType </span><span class="s5">=== </span><span class="s2">Syntax$1</span><span class="s1">.</span><span class="s2">SpreadElement </span><span class="s5">||</span>
            <span class="s2">nodeType </span><span class="s5">=== </span><span class="s2">Syntax$1</span><span class="s1">.</span><span class="s2">RestElement </span><span class="s5">||</span>
            <span class="s2">nodeType </span><span class="s5">=== </span><span class="s2">Syntax$1</span><span class="s1">.</span><span class="s2">AssignmentPattern</span>
        <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s5">constructor</span><span class="s1">(</span><span class="s2">options</span><span class="s1">, </span><span class="s2">rootPattern</span><span class="s1">, </span><span class="s2">callback</span><span class="s1">) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s4">null</span><span class="s1">, </span><span class="s2">options</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">rootPattern </span><span class="s5">= </span><span class="s2">rootPattern</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">callback </span><span class="s5">= </span><span class="s2">callback</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">assignments </span><span class="s5">= </span><span class="s1">[];</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">rightHandNodes </span><span class="s5">= </span><span class="s1">[];</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">restElements </span><span class="s5">= </span><span class="s1">[];</span>
    <span class="s1">}</span>

    <span class="s1">Identifier(</span><span class="s2">pattern</span><span class="s1">) {</span>
        <span class="s5">const </span><span class="s1">lastRestElement </span><span class="s5">= </span><span class="s3">getLast</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">restElements</span><span class="s1">);</span>

        <span class="s2">this</span><span class="s1">.</span><span class="s3">callback</span><span class="s1">(</span><span class="s2">pattern</span><span class="s1">, {</span>
            <span class="s1">topLevel: </span><span class="s2">pattern </span><span class="s5">=== </span><span class="s2">this</span><span class="s1">.</span><span class="s2">rootPattern</span><span class="s1">,</span>
            <span class="s1">rest: </span><span class="s2">lastRestElement </span><span class="s5">!== </span><span class="s4">null </span><span class="s5">&amp;&amp; </span><span class="s2">lastRestElement </span><span class="s5">!== </span><span class="s4">undefined </span><span class="s5">&amp;&amp; </span><span class="s2">lastRestElement</span><span class="s1">.</span><span class="s2">argument </span><span class="s5">=== </span><span class="s2">pattern</span><span class="s1">,</span>
            <span class="s1">assignments: </span><span class="s2">this</span><span class="s1">.</span><span class="s2">assignments</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s1">Property(</span><span class="s2">property</span><span class="s1">) {</span>

        <span class="s6">// Computed property's key is a right hand node.</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">property</span><span class="s1">.</span><span class="s2">computed</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">rightHandNodes</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">property</span><span class="s1">.</span><span class="s2">key</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s6">// If it's shorthand, its key is same as its value.</span>
        <span class="s6">// If it's shorthand and has its default value, its key is same as its value.left (the value is AssignmentPattern).</span>
        <span class="s6">// If it's not shorthand, the name of new variable is its value's.</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s3">visit</span><span class="s1">(</span><span class="s2">property</span><span class="s1">.</span><span class="s2">value</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">ArrayPattern(</span><span class="s2">pattern</span><span class="s1">) {</span>
        <span class="s5">for </span><span class="s1">(</span><span class="s5">let </span><span class="s1">i </span><span class="s5">= </span><span class="s7">0</span><span class="s1">, iz </span><span class="s5">= </span><span class="s2">pattern</span><span class="s1">.</span><span class="s2">elements</span><span class="s1">.length; </span><span class="s2">i </span><span class="s5">&lt; </span><span class="s2">iz</span><span class="s1">; </span><span class="s5">++</span><span class="s2">i</span><span class="s1">) {</span>
            <span class="s5">const </span><span class="s1">element </span><span class="s5">= </span><span class="s2">pattern</span><span class="s1">.</span><span class="s2">elements</span><span class="s1">[</span><span class="s2">i</span><span class="s1">];</span>

            <span class="s2">this</span><span class="s1">.</span><span class="s3">visit</span><span class="s1">(</span><span class="s2">element</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">AssignmentPattern(</span><span class="s2">pattern</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">assignments</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">pattern</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s3">visit</span><span class="s1">(</span><span class="s2">pattern</span><span class="s1">.</span><span class="s2">left</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">rightHandNodes</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">pattern</span><span class="s1">.</span><span class="s2">right</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">assignments</span><span class="s1">.</span><span class="s3">pop</span><span class="s1">();</span>
    <span class="s1">}</span>

    <span class="s1">RestElement(</span><span class="s2">pattern</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">restElements</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">pattern</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s3">visit</span><span class="s1">(</span><span class="s2">pattern</span><span class="s1">.</span><span class="s2">argument</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">restElements</span><span class="s1">.</span><span class="s3">pop</span><span class="s1">();</span>
    <span class="s1">}</span>

    <span class="s1">MemberExpression(</span><span class="s2">node</span><span class="s1">) {</span>

        <span class="s6">// Computed property's key is a right hand node.</span>
        <span class="s5">if </span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">computed</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">rightHandNodes</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">property</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s6">// the object is only read, write to its property.</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">rightHandNodes</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">object</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s6">//</span>
    <span class="s6">// ForInStatement.left and AssignmentExpression.left are LeftHandSideExpression.</span>
    <span class="s6">// By spec, LeftHandSideExpression is Pattern or MemberExpression.</span>
    <span class="s6">//   (see also: https://github.com/estree/estree/pull/20#issuecomment-74584758)</span>
    <span class="s6">// But espree 2.0 parses to ArrayExpression, ObjectExpression, etc...</span>
    <span class="s6">//</span>

    <span class="s1">SpreadElement(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s3">visit</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">argument</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">ArrayExpression(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s2">node</span><span class="s1">.</span><span class="s2">elements</span><span class="s1">.</span><span class="s3">forEach</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">visit</span><span class="s1">, </span><span class="s2">this</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">AssignmentExpression(</span><span class="s2">node</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">assignments</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">node</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s3">visit</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">left</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">rightHandNodes</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">right</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s2">assignments</span><span class="s1">.</span><span class="s3">pop</span><span class="s1">();</span>
    <span class="s1">}</span>

    <span class="s1">CallExpression(</span><span class="s2">node</span><span class="s1">) {</span>

        <span class="s6">// arguments are right hand nodes.</span>
        <span class="s2">node</span><span class="s1">.</span><span class="s2">arguments</span><span class="s1">.</span><span class="s3">forEach</span><span class="s1">(</span><span class="s2">a </span><span class="s5">=&gt; </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s2">rightHandNodes</span><span class="s1">.</span><span class="s3">push</span><span class="s1">(</span><span class="s2">a</span><span class="s1">);</span>
        <span class="s1">});</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s3">visit</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">callee</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s6">/* vim: set sw=4 ts=4 et tw=80 : */</span>

<span class="s6">/*</span>
  <span class="s6">Copyright (C) 2015 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt; 
</span>
  <span class="s6">Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are met: 
</span>
    <span class="s6">* Redistributions of source code must retain the above copyright 
      notice, this list of conditions and the following disclaimer. 
    * Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution. 
</span>
  <span class="s6">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY 
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
*/</span>

<span class="s5">const </span><span class="s1">{ Syntax } </span><span class="s5">= </span><span class="s2">estraverse__default</span><span class="s1">[</span><span class="s0">&quot;default&quot;</span><span class="s1">];</span>

<span class="s6">/**</span>
 <span class="s6">* Traverse identifier in pattern 
 * </span><span class="s5">@param </span><span class="s2">{Object} options </span><span class="s6">options 
 * </span><span class="s5">@param </span><span class="s2">{pattern} rootPattern </span><span class="s6">root pattern 
 * </span><span class="s5">@param </span><span class="s2">{Refencer} referencer </span><span class="s6">referencer 
 * </span><span class="s5">@param </span><span class="s2">{callback} callback </span><span class="s6">callback 
 * </span><span class="s5">@returns </span><span class="s2">{void}</span>
 <span class="s6">*/ 
function traverseIdentifierInPattern(options, rootPattern, referencer, callback) { 
</span>
    <span class="s6">// Call the callback at left hand identifier nodes, and Collect right hand nodes. 
    const visitor = new PatternVisitor(options, rootPattern, callback); 
</span>
    <span class="s6">visitor.visit(rootPattern); 
</span>
    <span class="s6">// Process the right hand nodes recursively. 
    if (referencer !== null &amp;&amp; referencer !== undefined) { 
        visitor.rightHandNodes.forEach(referencer.visit, referencer); 
    } 
} 
</span>
<span class="s6">// Importing ImportDeclaration. 
// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-moduledeclarationinstantiation 
// https://github.com/estree/estree/blob/master/es6.md#importdeclaration 
// FIXME: Now, we don't create module environment, because the context is 
// implementation dependent. 
</span>
<span class="s6">class Importer extends esrecurse__default[&quot;default&quot;].Visitor { 
    constructor(declaration, referencer) { 
        super(null, referencer.options); 
        this.declaration = declaration; 
        this.referencer = referencer; 
    } 
</span>
    <span class="s6">visitImport(id, specifier) { 
        this.referencer.visitPattern(id, pattern =&gt; { 
            this.referencer.currentScope().__define(pattern, 
                new Definition( 
                    Variable.ImportBinding, 
                    pattern, 
                    specifier, 
                    this.declaration, 
                    null, 
                    null 
                )); 
        }); 
    } 
</span>
    <span class="s6">ImportNamespaceSpecifier(node) { 
        const local = (node.local || node.id); 
</span>
        <span class="s6">if (local) { 
            this.visitImport(local, node); 
        } 
    } 
</span>
    <span class="s6">ImportDefaultSpecifier(node) { 
        const local = (node.local || node.id); 
</span>
        <span class="s6">this.visitImport(local, node); 
    } 
</span>
    <span class="s6">ImportSpecifier(node) { 
        const local = (node.local || node.id); 
</span>
        <span class="s6">if (node.name) { 
            this.visitImport(node.name, node); 
        } else { 
            this.visitImport(local, node); 
        } 
    } 
} 
</span>
<span class="s6">// Referencing variables and creating bindings. 
class Referencer extends esrecurse__default[&quot;default&quot;].Visitor { 
    constructor(options, scopeManager) { 
        super(null, options); 
        this.options = options; 
        this.scopeManager = scopeManager; 
        this.parent = null; 
        this.isInnerMethodDefinition = false; 
    } 
</span>
    <span class="s6">currentScope() { 
        return this.scopeManager.__currentScope; 
    } 
</span>
    <span class="s6">close(node) { 
        while (this.currentScope() &amp;&amp; node === this.currentScope().block) { 
            this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager); 
        } 
    } 
</span>
    <span class="s6">pushInnerMethodDefinition(isInnerMethodDefinition) { 
        const previous = this.isInnerMethodDefinition; 
</span>
        <span class="s6">this.isInnerMethodDefinition = isInnerMethodDefinition; 
        return previous; 
    } 
</span>
    <span class="s6">popInnerMethodDefinition(isInnerMethodDefinition) { 
        this.isInnerMethodDefinition = isInnerMethodDefinition; 
    } 
</span>
    <span class="s6">referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) { 
        const scope = this.currentScope(); 
</span>
        <span class="s6">assignments.forEach(assignment =&gt; { 
            scope.__referencing( 
                pattern, 
                Reference.WRITE, 
                assignment.right, 
                maybeImplicitGlobal, 
                pattern !== assignment.left, 
                init 
            ); 
        }); 
    } 
</span>
    <span class="s6">visitPattern(node, options, callback) { 
        let visitPatternOptions = options; 
        let visitPatternCallback = callback; 
</span>
        <span class="s6">if (typeof options === &quot;function&quot;) { 
            visitPatternCallback = options; 
            visitPatternOptions = { processRightHandNodes: false }; 
        } 
</span>
        <span class="s6">traverseIdentifierInPattern( 
            this.options, 
            node, 
            visitPatternOptions.processRightHandNodes ? this : null, 
            visitPatternCallback 
        ); 
    } 
</span>
    <span class="s6">visitFunction(node) { 
        let i, iz; 
</span>
        <span class="s6">// FunctionDeclaration name is defined in upper scope 
        // NOTE: Not referring variableScope. It is intended. 
        // Since 
        //  in ES5, FunctionDeclaration should be in FunctionBody. 
        //  in ES6, FunctionDeclaration should be block scoped. 
</span>
        <span class="s6">if (node.type === Syntax.FunctionDeclaration) { 
</span>
            <span class="s6">// id is defined in upper scope 
            this.currentScope().__define(node.id, 
                new Definition( 
                    Variable.FunctionName, 
                    node.id, 
                    node, 
                    null, 
                    null, 
                    null 
                )); 
        } 
</span>
        <span class="s6">// FunctionExpression with name creates its special scope; 
        // FunctionExpressionNameScope. 
        if (node.type === Syntax.FunctionExpression &amp;&amp; node.id) { 
            this.scopeManager.__nestFunctionExpressionNameScope(node); 
        } 
</span>
        <span class="s6">// Consider this function is in the MethodDefinition. 
        this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition); 
</span>
        <span class="s6">const that = this; 
</span>
        <span class="s6">/** 
         * Visit pattern callback 
         * </span><span class="s5">@param </span><span class="s2">{pattern} pattern </span><span class="s6">pattern 
         * </span><span class="s5">@param </span><span class="s2">{Object} info </span><span class="s6">info 
         * </span><span class="s5">@returns </span><span class="s2">{void}</span>
         <span class="s6">*/ 
        function visitPatternCallback(pattern, info) { 
            that.currentScope().__define(pattern, 
                new ParameterDefinition( 
                    pattern, 
                    node, 
                    i, 
                    info.rest 
                )); 
</span>
            <span class="s6">that.referencingDefaultValue(pattern, info.assignments, null, true); 
        } 
</span>
        <span class="s6">// Process parameter declarations. 
        for (i = 0, iz = node.params.length; i &lt; iz; ++i) { 
            this.visitPattern(node.params[i], { processRightHandNodes: true }, visitPatternCallback); 
        } 
</span>
        <span class="s6">// if there's a rest argument, add that 
        if (node.rest) { 
            this.visitPattern({ 
                type: &quot;RestElement&quot;, 
                argument: node.rest 
            }, pattern =&gt; { 
                this.currentScope().__define(pattern, 
                    new ParameterDefinition( 
                        pattern, 
                        node, 
                        node.params.length, 
                        true 
                    )); 
            }); 
        } 
</span>
        <span class="s6">// In TypeScript there are a number of function-like constructs which have no body, 
        // so check it exists before traversing 
        if (node.body) { 
</span>
            <span class="s6">// Skip BlockStatement to prevent creating BlockStatement scope. 
            if (node.body.type === Syntax.BlockStatement) { 
                this.visitChildren(node.body); 
            } else { 
                this.visit(node.body); 
            } 
        } 
</span>
        <span class="s6">this.close(node); 
    } 
</span>
    <span class="s6">visitClass(node) { 
        if (node.type === Syntax.ClassDeclaration) { 
            this.currentScope().__define(node.id, 
                new Definition( 
                    Variable.ClassName, 
                    node.id, 
                    node, 
                    null, 
                    null, 
                    null 
                )); 
        } 
</span>
        <span class="s6">this.visit(node.superClass); 
</span>
        <span class="s6">this.scopeManager.__nestClassScope(node); 
</span>
        <span class="s6">if (node.id) { 
            this.currentScope().__define(node.id, 
                new Definition( 
                    Variable.ClassName, 
                    node.id, 
                    node 
                )); 
        } 
        this.visit(node.body); 
</span>
        <span class="s6">this.close(node); 
    } 
</span>
    <span class="s6">visitProperty(node) { 
        let previous; 
</span>
        <span class="s6">if (node.computed) { 
            this.visit(node.key); 
        } 
</span>
        <span class="s6">const isMethodDefinition = node.type === Syntax.MethodDefinition; 
</span>
        <span class="s6">if (isMethodDefinition) { 
            previous = this.pushInnerMethodDefinition(true); 
        } 
        this.visit(node.value); 
        if (isMethodDefinition) { 
            this.popInnerMethodDefinition(previous); 
        } 
    } 
</span>
    <span class="s6">visitForIn(node) { 
        if (node.left.type === Syntax.VariableDeclaration &amp;&amp; node.left.kind !== &quot;var&quot;) { 
            this.scopeManager.__nestForScope(node); 
        } 
</span>
        <span class="s6">if (node.left.type === Syntax.VariableDeclaration) { 
            this.visit(node.left); 
            this.visitPattern(node.left.declarations[0].id, pattern =&gt; { 
                this.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, true, true); 
            }); 
        } else { 
            this.visitPattern(node.left, { processRightHandNodes: true }, (pattern, info) =&gt; { 
                let maybeImplicitGlobal = null; 
</span>
                <span class="s6">if (!this.currentScope().isStrict) { 
                    maybeImplicitGlobal = { 
                        pattern, 
                        node 
                    }; 
                } 
                this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false); 
                this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, true, false); 
            }); 
        } 
        this.visit(node.right); 
        this.visit(node.body); 
</span>
        <span class="s6">this.close(node); 
    } 
</span>
    <span class="s6">visitVariableDeclaration(variableTargetScope, type, node, index) { 
</span>
        <span class="s6">const decl = node.declarations[index]; 
        const init = decl.init; 
</span>
        <span class="s6">this.visitPattern(decl.id, { processRightHandNodes: true }, (pattern, info) =&gt; { 
            variableTargetScope.__define( 
                pattern, 
                new Definition( 
                    type, 
                    pattern, 
                    decl, 
                    node, 
                    index, 
                    node.kind 
                ) 
            ); 
</span>
            <span class="s6">this.referencingDefaultValue(pattern, info.assignments, null, true); 
            if (init) { 
                this.currentScope().__referencing(pattern, Reference.WRITE, init, null, !info.topLevel, true); 
            } 
        }); 
    } 
</span>
    <span class="s6">AssignmentExpression(node) { 
        if (PatternVisitor.isPattern(node.left)) { 
            if (node.operator === &quot;=&quot;) { 
                this.visitPattern(node.left, { processRightHandNodes: true }, (pattern, info) =&gt; { 
                    let maybeImplicitGlobal = null; 
</span>
                    <span class="s6">if (!this.currentScope().isStrict) { 
                        maybeImplicitGlobal = { 
                            pattern, 
                            node 
                        }; 
                    } 
                    this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false); 
                    this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, false); 
                }); 
            } else { 
                this.currentScope().__referencing(node.left, Reference.RW, node.right); 
            } 
        } else { 
            this.visit(node.left); 
        } 
        this.visit(node.right); 
    } 
</span>
    <span class="s6">CatchClause(node) { 
        this.scopeManager.__nestCatchScope(node); 
</span>
        <span class="s6">this.visitPattern(node.param, { processRightHandNodes: true }, (pattern, info) =&gt; { 
            this.currentScope().__define(pattern, 
                new Definition( 
                    Variable.CatchClause, 
                    node.param, 
                    node, 
                    null, 
                    null, 
                    null 
                )); 
            this.referencingDefaultValue(pattern, info.assignments, null, true); 
        }); 
        this.visit(node.body); 
</span>
        <span class="s6">this.close(node); 
    } 
</span>
    <span class="s6">Program(node) { 
        this.scopeManager.__nestGlobalScope(node); 
</span>
        <span class="s6">if (this.scopeManager.isGlobalReturn()) { 
</span>
            <span class="s6">// Force strictness of GlobalScope to false when using node.js scope. 
            this.currentScope().isStrict = false; 
            this.scopeManager.__nestFunctionScope(node, false); 
        } 
</span>
        <span class="s6">if (this.scopeManager.__isES6() &amp;&amp; this.scopeManager.isModule()) { 
            this.scopeManager.__nestModuleScope(node); 
        } 
</span>
        <span class="s6">if (this.scopeManager.isStrictModeSupported() &amp;&amp; this.scopeManager.isImpliedStrict()) { 
            this.currentScope().isStrict = true; 
        } 
</span>
        <span class="s6">this.visitChildren(node); 
        this.close(node); 
    } 
</span>
    <span class="s6">Identifier(node) { 
        this.currentScope().__referencing(node); 
    } 
</span>
    <span class="s6">// eslint-disable-next-line class-methods-use-this 
    PrivateIdentifier() { 
</span>
        <span class="s6">// Do nothing. 
    } 
</span>
    <span class="s6">UpdateExpression(node) { 
        if (PatternVisitor.isPattern(node.argument)) { 
            this.currentScope().__referencing(node.argument, Reference.RW, null); 
        } else { 
            this.visitChildren(node); 
        } 
    } 
</span>
    <span class="s6">MemberExpression(node) { 
        this.visit(node.object); 
        if (node.computed) { 
            this.visit(node.property); 
        } 
    } 
</span>
    <span class="s6">Property(node) { 
        this.visitProperty(node); 
    } 
</span>
    <span class="s6">PropertyDefinition(node) { 
        const { computed, key, value } = node; 
</span>
        <span class="s6">if (computed) { 
            this.visit(key); 
        } 
        if (value) { 
            this.scopeManager.__nestClassFieldInitializerScope(value); 
            this.visit(value); 
            this.close(value); 
        } 
    } 
</span>
    <span class="s6">StaticBlock(node) { 
        this.scopeManager.__nestClassStaticBlockScope(node); 
</span>
        <span class="s6">this.visitChildren(node); 
</span>
        <span class="s6">this.close(node); 
    } 
</span>
    <span class="s6">MethodDefinition(node) { 
        this.visitProperty(node); 
    } 
</span>
    <span class="s6">BreakStatement() {} // eslint-disable-line class-methods-use-this 
</span>
    <span class="s6">ContinueStatement() {} // eslint-disable-line class-methods-use-this 
</span>
    <span class="s6">LabeledStatement(node) { 
        this.visit(node.body); 
    } 
</span>
    <span class="s6">ForStatement(node) { 
</span>
        <span class="s6">// Create ForStatement declaration. 
        // NOTE: In ES6, ForStatement dynamically generates 
        // per iteration environment. However, escope is 
        // a static analyzer, we only generate one scope for ForStatement. 
        if (node.init &amp;&amp; node.init.type === Syntax.VariableDeclaration &amp;&amp; node.init.kind !== &quot;var&quot;) { 
            this.scopeManager.__nestForScope(node); 
        } 
</span>
        <span class="s6">this.visitChildren(node); 
</span>
        <span class="s6">this.close(node); 
    } 
</span>
    <span class="s6">ClassExpression(node) { 
        this.visitClass(node); 
    } 
</span>
    <span class="s6">ClassDeclaration(node) { 
        this.visitClass(node); 
    } 
</span>
    <span class="s6">CallExpression(node) { 
</span>
        <span class="s6">// Check this is direct call to eval 
        if (!this.scopeManager.__ignoreEval() &amp;&amp; node.callee.type === Syntax.Identifier &amp;&amp; node.callee.name === &quot;eval&quot;) { 
</span>
            <span class="s6">// NOTE: This should be `variableScope`. Since direct eval call always creates Lexical environment and 
            // let / const should be enclosed into it. Only VariableDeclaration affects on the caller's environment. 
            this.currentScope().variableScope.__detectEval(); 
        } 
        this.visitChildren(node); 
    } 
</span>
    <span class="s6">BlockStatement(node) { 
        if (this.scopeManager.__isES6()) { 
            this.scopeManager.__nestBlockScope(node); 
        } 
</span>
        <span class="s6">this.visitChildren(node); 
</span>
        <span class="s6">this.close(node); 
    } 
</span>
    <span class="s6">ThisExpression() { 
        this.currentScope().variableScope.__detectThis(); 
    } 
</span>
    <span class="s6">WithStatement(node) { 
        this.visit(node.object); 
</span>
        <span class="s6">// Then nest scope for WithStatement. 
        this.scopeManager.__nestWithScope(node); 
</span>
        <span class="s6">this.visit(node.body); 
</span>
        <span class="s6">this.close(node); 
    } 
</span>
    <span class="s6">VariableDeclaration(node) { 
        const variableTargetScope = (node.kind === &quot;var&quot;) ? this.currentScope().variableScope : this.currentScope(); 
</span>
        <span class="s6">for (let i = 0, iz = node.declarations.length; i &lt; iz; ++i) { 
            const decl = node.declarations[i]; 
</span>
            <span class="s6">this.visitVariableDeclaration(variableTargetScope, Variable.Variable, node, i); 
            if (decl.init) { 
                this.visit(decl.init); 
            } 
        } 
    } 
</span>
    <span class="s6">// sec 13.11.8 
    SwitchStatement(node) { 
        this.visit(node.discriminant); 
</span>
        <span class="s6">if (this.scopeManager.__isES6()) { 
            this.scopeManager.__nestSwitchScope(node); 
        } 
</span>
        <span class="s6">for (let i = 0, iz = node.cases.length; i &lt; iz; ++i) { 
            this.visit(node.cases[i]); 
        } 
</span>
        <span class="s6">this.close(node); 
    } 
</span>
    <span class="s6">FunctionDeclaration(node) { 
        this.visitFunction(node); 
    } 
</span>
    <span class="s6">FunctionExpression(node) { 
        this.visitFunction(node); 
    } 
</span>
    <span class="s6">ForOfStatement(node) { 
        this.visitForIn(node); 
    } 
</span>
    <span class="s6">ForInStatement(node) { 
        this.visitForIn(node); 
    } 
</span>
    <span class="s6">ArrowFunctionExpression(node) { 
        this.visitFunction(node); 
    } 
</span>
    <span class="s6">ImportDeclaration(node) { 
        assert__default[&quot;default&quot;](this.scopeManager.__isES6() &amp;&amp; this.scopeManager.isModule(), &quot;ImportDeclaration should appear when the mode is ES6 and in the module context.&quot;); 
</span>
        <span class="s6">const importer = new Importer(node, this); 
</span>
        <span class="s6">importer.visit(node); 
    } 
</span>
    <span class="s6">visitExportDeclaration(node) { 
        if (node.source) { 
            return; 
        } 
        if (node.declaration) { 
            this.visit(node.declaration); 
            return; 
        } 
</span>
        <span class="s6">this.visitChildren(node); 
    } 
</span>
    <span class="s6">// TODO: ExportDeclaration doesn't exist. for bc? 
    ExportDeclaration(node) { 
        this.visitExportDeclaration(node); 
    } 
</span>
    <span class="s6">ExportAllDeclaration(node) { 
        this.visitExportDeclaration(node); 
    } 
</span>
    <span class="s6">ExportDefaultDeclaration(node) { 
        this.visitExportDeclaration(node); 
    } 
</span>
    <span class="s6">ExportNamedDeclaration(node) { 
        this.visitExportDeclaration(node); 
    } 
</span>
    <span class="s6">ExportSpecifier(node) { 
</span>
        <span class="s6">// TODO: `node.id` doesn't exist. for bc? 
        const local = (node.id || node.local); 
</span>
        <span class="s6">this.visit(local); 
    } 
</span>
    <span class="s6">MetaProperty() { // eslint-disable-line class-methods-use-this 
</span>
        <span class="s6">// do nothing. 
    } 
} 
</span>
<span class="s6">/* vim: set sw=4 ts=4 et tw=80 : */</span>

<span class="s5">const </span><span class="s1">version </span><span class="s5">= </span><span class="s0">&quot;7.2.1&quot;</span><span class="s1">;</span>

<span class="s6">/*</span>
  <span class="s6">Copyright (C) 2012-2014 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt; 
  Copyright (C) 2013 Alex Seville &lt;hi@alexanderseville.com&gt; 
  Copyright (C) 2014 Thiago de Arruda &lt;tpadilha84@gmail.com&gt; 
</span>
  <span class="s6">Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are met: 
</span>
    <span class="s6">* Redistributions of source code must retain the above copyright 
      notice, this list of conditions and the following disclaimer. 
    * Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution. 
</span>
  <span class="s6">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY 
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
*/</span>

<span class="s6">/**</span>
 <span class="s6">* Set the default options 
 * </span><span class="s5">@returns </span><span class="s2">{Object} </span><span class="s6">options 
 */</span>
<span class="s5">function </span><span class="s1">defaultOptions() {</span>
    <span class="s5">return </span><span class="s1">{</span>
        <span class="s1">optimistic: </span><span class="s4">false</span><span class="s1">,</span>
        <span class="s1">directive: </span><span class="s4">false</span><span class="s1">,</span>
        <span class="s1">nodejsScope: </span><span class="s4">false</span><span class="s1">,</span>
        <span class="s1">impliedStrict: </span><span class="s4">false</span><span class="s1">,</span>
        <span class="s1">sourceType: </span><span class="s0">&quot;script&quot;</span><span class="s1">, </span><span class="s6">// one of ['script', 'module', 'commonjs']</span>
        <span class="s1">ecmaVersion: </span><span class="s7">5</span><span class="s1">,</span>
        <span class="s1">childVisitorKeys: </span><span class="s4">null</span><span class="s1">,</span>
        <span class="s1">fallback: </span><span class="s0">&quot;iteration&quot;</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* Preform deep update on option object 
 * </span><span class="s5">@param </span><span class="s2">{Object} target </span><span class="s6">Options 
 * </span><span class="s5">@param </span><span class="s2">{Object} override </span><span class="s6">Updates 
 * </span><span class="s5">@returns </span><span class="s2">{Object} </span><span class="s6">Updated options 
 */</span>
<span class="s5">function </span><span class="s1">updateDeeply(</span><span class="s2">target</span><span class="s1">, </span><span class="s2">override</span><span class="s1">) {</span>

    <span class="s6">/**</span>
     <span class="s6">* Is hash object 
     * </span><span class="s5">@param </span><span class="s2">{Object} value </span><span class="s6">Test value 
     * </span><span class="s5">@returns </span><span class="s2">{boolean} </span><span class="s6">Result 
     */</span>
    <span class="s5">function </span><span class="s1">isHashObject(</span><span class="s2">value</span><span class="s1">) {</span>
        <span class="s5">return typeof </span><span class="s2">value </span><span class="s5">=== </span><span class="s0">&quot;object&quot; </span><span class="s5">&amp;&amp; </span><span class="s2">value </span><span class="s5">instanceof </span><span class="s2">Object </span><span class="s5">&amp;&amp; !</span><span class="s1">(</span><span class="s2">value </span><span class="s5">instanceof </span><span class="s2">Array</span><span class="s1">) </span><span class="s5">&amp;&amp; !</span><span class="s1">(</span><span class="s2">value </span><span class="s5">instanceof </span><span class="s2">RegExp</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s5">for </span><span class="s1">(</span><span class="s5">const </span><span class="s1">key </span><span class="s5">in </span><span class="s2">override</span><span class="s1">) {</span>
        <span class="s5">if </span><span class="s1">(Object.prototype.</span><span class="s2">hasOwnProperty</span><span class="s1">.</span><span class="s3">call</span><span class="s1">(</span><span class="s2">override</span><span class="s1">, </span><span class="s2">key</span><span class="s1">)) {</span>
            <span class="s5">const </span><span class="s1">val </span><span class="s5">= </span><span class="s2">override</span><span class="s1">[</span><span class="s2">key</span><span class="s1">];</span>

            <span class="s5">if </span><span class="s1">(</span><span class="s3">isHashObject</span><span class="s1">(</span><span class="s2">val</span><span class="s1">)) {</span>
                <span class="s5">if </span><span class="s1">(</span><span class="s3">isHashObject</span><span class="s1">(</span><span class="s2">target</span><span class="s1">[</span><span class="s2">key</span><span class="s1">])) {</span>
                    <span class="s3">updateDeeply</span><span class="s1">(</span><span class="s2">target</span><span class="s1">[</span><span class="s2">key</span><span class="s1">], </span><span class="s2">val</span><span class="s1">);</span>
                <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
                    <span class="s2">target</span><span class="s1">[</span><span class="s2">key</span><span class="s1">] </span><span class="s5">= </span><span class="s3">updateDeeply</span><span class="s1">({}, </span><span class="s2">val</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
                <span class="s2">target</span><span class="s1">[</span><span class="s2">key</span><span class="s1">] </span><span class="s5">= </span><span class="s2">val</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">return </span><span class="s2">target</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* Main interface function. Takes an Espree syntax tree and returns the 
 * analyzed scopes. 
 * </span><span class="s5">@function </span><span class="s2">analyze</span>
 <span class="s6">* </span><span class="s5">@param </span><span class="s2">{espree.Tree} tree </span><span class="s6">Abstract Syntax Tree 
 * </span><span class="s5">@param </span><span class="s2">{Object} providedOptions </span><span class="s6">Options that tailor the scope analysis 
 * </span><span class="s5">@param </span><span class="s2">{boolean} [providedOptions.optimistic</span><span class="s5">=</span><span class="s2">false] </span><span class="s6">the optimistic flag 
 * </span><span class="s5">@param </span><span class="s2">{boolean} [providedOptions.directive</span><span class="s5">=</span><span class="s2">false] </span><span class="s6">the directive flag 
 * </span><span class="s5">@param </span><span class="s2">{boolean} [providedOptions.ignoreEval</span><span class="s5">=</span><span class="s2">false] </span><span class="s6">whether to check 'eval()' calls 
 * </span><span class="s5">@param </span><span class="s2">{boolean} [providedOptions.nodejsScope</span><span class="s5">=</span><span class="s2">false] </span><span class="s6">whether the whole 
 * script is executed under node.js environment. When enabled, escope adds 
 * a function scope immediately following the global scope. 
 * </span><span class="s5">@param </span><span class="s2">{boolean} [providedOptions.impliedStrict</span><span class="s5">=</span><span class="s2">false] </span><span class="s6">implied strict mode 
 * (if ecmaVersion &gt;= 5). 
 * </span><span class="s5">@param </span><span class="s2">{string} [providedOptions.sourceType</span><span class="s5">=</span><span class="s2">'script'] </span><span class="s6">the source type of the script. one of 'script', 'module', and 'commonjs' 
 * </span><span class="s5">@param </span><span class="s2">{number} [providedOptions.ecmaVersion</span><span class="s5">=</span><span class="s2">5] </span><span class="s6">which ECMAScript version is considered 
 * </span><span class="s5">@param </span><span class="s2">{Object} [providedOptions.childVisitorKeys</span><span class="s5">=</span><span class="s2">null] </span><span class="s6">Additional known visitor keys. See [esrecurse](https://github.com/estools/esrecurse)'s the `childVisitorKeys` option. 
 * </span><span class="s5">@param </span><span class="s2">{string} [providedOptions.fallback</span><span class="s5">=</span><span class="s2">'iteration'] </span><span class="s6">A kind of the fallback in order to encounter with unknown node. See [esrecurse](https://github.com/estools/esrecurse)'s the `fallback` option. 
 * </span><span class="s5">@returns </span><span class="s2">{ScopeManager} </span><span class="s6">ScopeManager 
 */</span>
<span class="s5">function </span><span class="s1">analyze(</span><span class="s2">tree</span><span class="s1">, </span><span class="s2">providedOptions</span><span class="s1">) {</span>
    <span class="s5">const </span><span class="s1">options </span><span class="s5">= </span><span class="s3">updateDeeply</span><span class="s1">(</span><span class="s3">defaultOptions</span><span class="s1">(), </span><span class="s2">providedOptions</span><span class="s1">);</span>
    <span class="s5">const </span><span class="s1">scopeManager </span><span class="s5">= new </span><span class="s3">ScopeManager</span><span class="s1">(</span><span class="s2">options</span><span class="s1">);</span>
    <span class="s5">const </span><span class="s1">referencer </span><span class="s5">= new </span><span class="s3">Referencer</span><span class="s1">(</span><span class="s2">options</span><span class="s1">, </span><span class="s2">scopeManager</span><span class="s1">);</span>

    <span class="s2">referencer</span><span class="s1">.</span><span class="s3">visit</span><span class="s1">(</span><span class="s2">tree</span><span class="s1">);</span>

    <span class="s2">assert__default</span><span class="s1">[</span><span class="s0">&quot;default&quot;</span><span class="s1">](</span><span class="s2">scopeManager</span><span class="s1">.</span><span class="s2">__currentScope </span><span class="s5">=== </span><span class="s4">null</span><span class="s1">, </span><span class="s0">&quot;currentScope should be null.&quot;</span><span class="s1">);</span>

    <span class="s5">return </span><span class="s2">scopeManager</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s6">/* vim: set sw=4 ts=4 et tw=80 : */</span>

<span class="s2">exports</span><span class="s1">.</span><span class="s2">Definition </span><span class="s5">= </span><span class="s2">Definition</span><span class="s1">;</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">PatternVisitor </span><span class="s5">= </span><span class="s2">PatternVisitor</span><span class="s1">;</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">Reference </span><span class="s5">= </span><span class="s2">Reference</span><span class="s1">;</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">Referencer </span><span class="s5">= </span><span class="s2">Referencer</span><span class="s1">;</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">Scope </span><span class="s5">= </span><span class="s2">Scope</span><span class="s1">;</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">ScopeManager </span><span class="s5">= </span><span class="s2">ScopeManager</span><span class="s1">;</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">Variable </span><span class="s5">= </span><span class="s2">Variable</span><span class="s1">;</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">analyze </span><span class="s5">= </span><span class="s2">analyze</span><span class="s1">;</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">version </span><span class="s5">= </span><span class="s2">version</span><span class="s1">;</span>
<span class="s6">//# sourceMappingURL=eslint-scope.cjs.map</span>
</pre>
</body>
</html>
<html>
<head>
<title>parse.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
parse.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_parser&quot;</span><span class="s0">,</span><span class="s1">&quot;_codeFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isNewExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isPlaceholder&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isStringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;removePropertiesDeep&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;PATTERN&quot;</span><span class="s0">,</span><span class="s1">&quot;parseAndBuildMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;formatter&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;placeholderWhitelist&quot;</span><span class="s0">,</span><span class="s1">&quot;placeholderPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;preserveComments&quot;</span><span class="s0">,</span><span class="s1">&quot;syntacticPlaceholders&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;parseWithCodeFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;parser&quot;</span><span class="s0">,</span><span class="s1">&quot;validate&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;syntactic&quot;</span><span class="s0">,</span><span class="s1">&quot;placeholders&quot;</span><span class="s0">,</span><span class="s1">&quot;placeholderNames&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;legacy&quot;</span><span class="s0">,</span><span class="s1">&quot;placeholderVisitorHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;ancestors&quot;</span><span class="s0">,</span><span class="s1">&quot;_state$placeholderWhi&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;hasSyntacticPlaceholders&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;expectedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveAncestors&quot;</span><span class="s0">,</span><span class="s1">&quot;isDuplicate&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;parserOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;plugins&quot;</span><span class="s0">,</span><span class="s1">&quot;allowReturnOutsideFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;allowSuperOutsideMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceType&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;codeFrameColumns&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/parse.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">isCallExpression,</span><span class="s3">\n  </span><span class="s1">isExpressionStatement,</span><span class="s3">\n  </span><span class="s1">isFunction,</span><span class="s3">\n  </span><span class="s1">isIdentifier,</span><span class="s3">\n  </span><span class="s1">isJSXIdentifier,</span><span class="s3">\n  </span><span class="s1">isNewExpression,</span><span class="s3">\n  </span><span class="s1">isPlaceholder,</span><span class="s3">\n  </span><span class="s1">isStatement,</span><span class="s3">\n  </span><span class="s1">isStringLiteral,</span><span class="s3">\n  </span><span class="s1">removePropertiesDeep,</span><span class="s3">\n  </span><span class="s1">traverse,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { TraversalAncestors } from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { parse } from </span><span class="s3">\&quot;</span><span class="s1">@babel/parser</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { codeFrameColumns } from </span><span class="s3">\&quot;</span><span class="s1">@babel/code-frame</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { TemplateOpts, ParserOpts } from </span><span class="s3">\&quot;</span><span class="s1">./options</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Formatter } from </span><span class="s3">\&quot;</span><span class="s1">./formatters</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export type Metadata = {</span><span class="s3">\n  </span><span class="s1">ast: t.File;</span><span class="s3">\n  </span><span class="s1">placeholders: Array&lt;Placeholder&gt;;</span><span class="s3">\n  </span><span class="s1">placeholderNames: Set&lt;string&gt;;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">type PlaceholderType = </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">param</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">other</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export type Placeholder = {</span><span class="s3">\n  </span><span class="s1">name: string;</span><span class="s3">\n  </span><span class="s1">resolve: (a: t.File) =&gt; { parent: t.Node; key: string; index?: number };</span><span class="s3">\n  </span><span class="s1">type: PlaceholderType;</span><span class="s3">\n  </span><span class="s1">isDuplicate: boolean;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const PATTERN = /^[_$A-Z0-9]+$/;</span><span class="s3">\n\n</span><span class="s1">export default function parseAndBuildMetadata&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">formatter: Formatter&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">code: string,</span><span class="s3">\n  </span><span class="s1">opts: TemplateOpts,</span><span class="s3">\n</span><span class="s1">): Metadata {</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">placeholderWhitelist,</span><span class="s3">\n    </span><span class="s1">placeholderPattern,</span><span class="s3">\n    </span><span class="s1">preserveComments,</span><span class="s3">\n    </span><span class="s1">syntacticPlaceholders,</span><span class="s3">\n  </span><span class="s1">} = opts;</span><span class="s3">\n\n  </span><span class="s1">const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);</span><span class="s3">\n\n  </span><span class="s1">removePropertiesDeep(ast, {</span><span class="s3">\n    </span><span class="s1">preserveComments,</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">formatter.validate(ast);</span><span class="s3">\n\n  </span><span class="s1">const state: MetadataState = {</span><span class="s3">\n    </span><span class="s1">syntactic: { placeholders: [], placeholderNames: new Set() },</span><span class="s3">\n    </span><span class="s1">legacy: { placeholders: [], placeholderNames: new Set() },</span><span class="s3">\n    </span><span class="s1">placeholderWhitelist,</span><span class="s3">\n    </span><span class="s1">placeholderPattern,</span><span class="s3">\n    </span><span class="s1">syntacticPlaceholders,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">traverse(ast, placeholderVisitorHandler, state);</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">ast,</span><span class="s3">\n    </span><span class="s1">...(state.syntactic.placeholders.length ? state.syntactic : state.legacy),</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function placeholderVisitorHandler(</span><span class="s3">\n  </span><span class="s1">node: t.Node,</span><span class="s3">\n  </span><span class="s1">ancestors: TraversalAncestors,</span><span class="s3">\n  </span><span class="s1">state: MetadataState,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let name: string;</span><span class="s3">\n\n  </span><span class="s1">let hasSyntacticPlaceholders = state.syntactic.placeholders.length &gt; 0;</span><span class="s3">\n\n  </span><span class="s1">if (isPlaceholder(node)) {</span><span class="s3">\n    </span><span class="s1">if (state.syntacticPlaceholders === false) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        \&quot;</span><span class="s1">%%foo%%-style placeholders can't be used when </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot;</span><span class="s1">'.syntacticPlaceholders' is false.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">name = node.name.name;</span><span class="s3">\n    </span><span class="s1">hasSyntacticPlaceholders = true;</span><span class="s3">\n  </span><span class="s1">} else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">} else if (isIdentifier(node) || isJSXIdentifier(node)) {</span><span class="s3">\n    </span><span class="s1">name = node.name;</span><span class="s3">\n  </span><span class="s1">} else if (isStringLiteral(node)) {</span><span class="s3">\n    </span><span class="s1">name = node.value;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">hasSyntacticPlaceholders &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(state.placeholderPattern != null || state.placeholderWhitelist != null)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// This check is also in options.js. We need it there to handle the default</span><span class="s3">\n    </span><span class="s1">// .syntacticPlaceholders behavior.</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">'.placeholderWhitelist' and '.placeholderPattern' aren't compatible</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        \&quot; </span><span class="s1">with '.syntacticPlaceholders: true'</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">!hasSyntacticPlaceholders &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(state.placeholderPattern === false ||</span><span class="s3">\n      </span><span class="s1">!(state.placeholderPattern || PATTERN).test(name)) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!state.placeholderWhitelist?.has(name)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Keep our own copy of the ancestors so we can use it in .resolve().</span><span class="s3">\n  </span><span class="s1">ancestors = ancestors.slice();</span><span class="s3">\n\n  </span><span class="s1">const { node: parent, key } = ancestors[ancestors.length - 1];</span><span class="s3">\n\n  </span><span class="s1">let type: PlaceholderType;</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">isStringLiteral(node) ||</span><span class="s3">\n    </span><span class="s1">isPlaceholder(node, { expectedNode: </span><span class="s3">\&quot;</span><span class="s1">StringLiteral</span><span class="s3">\&quot; </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">type = </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">} else if (</span><span class="s3">\n    </span><span class="s1">(isNewExpression(parent) &amp;&amp; key === </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n    </span><span class="s1">(isCallExpression(parent) &amp;&amp; key === </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n    </span><span class="s1">(isFunction(parent) &amp;&amp; key === </span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">type = </span><span class="s3">\&quot;</span><span class="s1">param</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">} else if (isExpressionStatement(parent) &amp;&amp; !isPlaceholder(node)) {</span><span class="s3">\n    </span><span class="s1">type = </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ancestors = ancestors.slice(0, -1);</span><span class="s3">\n  </span><span class="s1">} else if (isStatement(node) &amp;&amp; isPlaceholder(node)) {</span><span class="s3">\n    </span><span class="s1">type = </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">type = </span><span class="s3">\&quot;</span><span class="s1">other</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { placeholders, placeholderNames } = !hasSyntacticPlaceholders</span><span class="s3">\n    </span><span class="s1">? state.legacy</span><span class="s3">\n    </span><span class="s1">: state.syntactic;</span><span class="s3">\n\n  </span><span class="s1">placeholders.push({</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n    </span><span class="s1">type,</span><span class="s3">\n    </span><span class="s1">resolve: ast =&gt; resolveAncestors(ast, ancestors),</span><span class="s3">\n    </span><span class="s1">isDuplicate: placeholderNames.has(name),</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">placeholderNames.add(name);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function resolveAncestors(ast: t.File, ancestors: TraversalAncestors) {</span><span class="s3">\n  </span><span class="s1">let parent: t.Node = ast;</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; ancestors.length - 1; i++) {</span><span class="s3">\n    </span><span class="s1">const { key, index } = ancestors[i];</span><span class="s3">\n\n    </span><span class="s1">if (index === undefined) {</span><span class="s3">\n      </span><span class="s1">parent = (parent as any)[key];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">parent = (parent as any)[key][index];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { key, index } = ancestors[ancestors.length - 1];</span><span class="s3">\n\n  </span><span class="s1">return { parent, key, index };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type MetadataState = {</span><span class="s3">\n  </span><span class="s1">syntactic: {</span><span class="s3">\n    </span><span class="s1">placeholders: Array&lt;Placeholder&gt;;</span><span class="s3">\n    </span><span class="s1">placeholderNames: Set&lt;string&gt;;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">legacy: {</span><span class="s3">\n    </span><span class="s1">placeholders: Array&lt;Placeholder&gt;;</span><span class="s3">\n    </span><span class="s1">placeholderNames: Set&lt;string&gt;;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">placeholderWhitelist?: Set&lt;string&gt;;</span><span class="s3">\n  </span><span class="s1">placeholderPattern?: RegExp | false;</span><span class="s3">\n  </span><span class="s1">syntacticPlaceholders?: boolean;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function parseWithCodeFrame(</span><span class="s3">\n  </span><span class="s1">code: string,</span><span class="s3">\n  </span><span class="s1">parserOpts: ParserOpts,</span><span class="s3">\n  </span><span class="s1">syntacticPlaceholders?: boolean,</span><span class="s3">\n</span><span class="s1">): t.File {</span><span class="s3">\n  </span><span class="s1">const plugins = (parserOpts.plugins || []).slice();</span><span class="s3">\n  </span><span class="s1">if (syntacticPlaceholders !== false) {</span><span class="s3">\n    </span><span class="s1">plugins.push(</span><span class="s3">\&quot;</span><span class="s1">placeholders</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">parserOpts = {</span><span class="s3">\n    </span><span class="s1">allowReturnOutsideFunction: true,</span><span class="s3">\n    </span><span class="s1">allowSuperOutsideMethod: true,</span><span class="s3">\n    </span><span class="s1">sourceType: </span><span class="s3">\&quot;</span><span class="s1">module</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">...parserOpts,</span><span class="s3">\n    </span><span class="s1">plugins,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error todo: use babel-types ast typings in Babel parser</span><span class="s3">\n    </span><span class="s1">return parse(code, parserOpts);</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">const loc = err.loc;</span><span class="s3">\n    </span><span class="s1">if (loc) {</span><span class="s3">\n      </span><span class="s1">err.message += </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+ codeFrameColumns(code, { start: loc });</span><span class="s3">\n      </span><span class="s1">err.code = </span><span class="s3">\&quot;</span><span class="s1">BABEL_TEMPLATE_PARSE_ERROR</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw err;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>
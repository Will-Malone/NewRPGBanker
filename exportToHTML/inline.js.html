<html>
<head>
<title>inline.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
inline.js</font>
</center></td></tr></table>
<pre><span class="s0">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s1">import {</span>
    <span class="s1">AST_Array,</span>
    <span class="s1">AST_Assign,</span>
    <span class="s1">AST_Block,</span>
    <span class="s1">AST_Call,</span>
    <span class="s1">AST_Catch,</span>
    <span class="s1">AST_Class,</span>
    <span class="s1">AST_ClassExpression,</span>
    <span class="s1">AST_DefaultAssign,</span>
    <span class="s1">AST_DefClass,</span>
    <span class="s1">AST_Defun,</span>
    <span class="s1">AST_Destructuring,</span>
    <span class="s1">AST_EmptyStatement,</span>
    <span class="s1">AST_Expansion,</span>
    <span class="s1">AST_Export,</span>
    <span class="s1">AST_Function,</span>
    <span class="s1">AST_IterationStatement,</span>
    <span class="s1">AST_Lambda,</span>
    <span class="s1">AST_Node,</span>
    <span class="s1">AST_Number,</span>
    <span class="s1">AST_Object,</span>
    <span class="s1">AST_ObjectKeyVal,</span>
    <span class="s1">AST_PropAccess,</span>
    <span class="s1">AST_Return,</span>
    <span class="s1">AST_Scope,</span>
    <span class="s1">AST_SimpleStatement,</span>
    <span class="s1">AST_Statement,</span>
    <span class="s1">AST_SymbolDefun,</span>
    <span class="s1">AST_SymbolFunarg,</span>
    <span class="s1">AST_SymbolLambda,</span>
    <span class="s1">AST_SymbolRef,</span>
    <span class="s1">AST_SymbolVar,</span>
    <span class="s1">AST_This,</span>
    <span class="s1">AST_Toplevel,</span>
    <span class="s1">AST_UnaryPrefix,</span>
    <span class="s1">AST_Undefined,</span>
    <span class="s1">AST_Var,</span>
    <span class="s1">AST_VarDef,</span>

    <span class="s1">walk,</span>

    <span class="s1">_INLINE,</span>
    <span class="s1">_NOINLINE,</span>
    <span class="s1">_PURE</span>
<span class="s1">} from </span><span class="s2">&quot;../ast.js&quot;</span><span class="s1">;</span>
<span class="s1">import { make_node, has_annotation } from </span><span class="s2">&quot;../utils/index.js&quot;</span><span class="s1">;</span>
<span class="s1">import </span><span class="s2">&quot;../size.js&quot;</span><span class="s1">;</span>

<span class="s1">import </span><span class="s2">&quot;./evaluate.js&quot;</span><span class="s1">;</span>
<span class="s1">import </span><span class="s2">&quot;./drop-side-effect-free.js&quot;</span><span class="s1">;</span>
<span class="s1">import </span><span class="s2">&quot;./reduce-vars.js&quot;</span><span class="s1">;</span>
<span class="s1">import {</span>
    <span class="s1">SQUEEZED,</span>
    <span class="s1">INLINED,</span>
    <span class="s1">UNUSED,</span>

    <span class="s1">has_flag,</span>
    <span class="s1">set_flag,</span>
<span class="s1">} from </span><span class="s2">&quot;./compressor-flags.js&quot;</span><span class="s1">;</span>
<span class="s1">import {</span>
    <span class="s1">make_sequence,</span>
    <span class="s1">best_of,</span>
    <span class="s1">make_node_from_constant,</span>
    <span class="s1">identifier_atom,</span>
    <span class="s1">is_empty,</span>
    <span class="s1">is_func_expr,</span>
    <span class="s1">is_iife_call,</span>
    <span class="s1">is_reachable,</span>
    <span class="s1">is_recursive_ref,</span>
    <span class="s1">retain_top_func,</span>
<span class="s1">} from </span><span class="s2">&quot;./common.js&quot;</span><span class="s1">;</span>

<span class="s0">/** 
 * Module that contains the inlining logic. 
 * 
 * @module 
 * 
 * The stars of the show are `inline_into_symbolref` and `inline_into_call`. 
 */</span>

<span class="s3">function </span><span class="s1">within_array_or_object_literal(compressor) {</span>
    <span class="s3">var </span><span class="s1">node, level = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">while </span><span class="s1">(node = compressor.parent(level++)) {</span>
        <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Statement) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Array</span>
            <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_ObjectKeyVal</span>
            <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Object) {</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">scope_encloses_variables_in_this_scope(scope, pulled_scope) {</span>
    <span class="s3">for </span><span class="s1">(const enclosed of pulled_scope.enclosed) {</span>
        <span class="s3">if </span><span class="s1">(pulled_scope.variables.has(enclosed.name)) {</span>
            <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">const looked_up = scope.find_variable(enclosed.name);</span>
        <span class="s3">if </span><span class="s1">(looked_up) {</span>
            <span class="s3">if </span><span class="s1">(looked_up === enclosed) </span><span class="s3">continue</span><span class="s1">;</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">export </span><span class="s3">function </span><span class="s1">inline_into_symbolref(self, compressor) {</span>
    <span class="s1">const parent = compressor.parent();</span>

    <span class="s1">const def = self.definition();</span>
    <span class="s1">const nearest_scope = compressor.find_scope();</span>
    <span class="s3">if </span><span class="s1">(compressor.top_retain &amp;&amp; def.global &amp;&amp; compressor.top_retain(def)) {</span>
        <span class="s1">def.fixed = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">def.single_use = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">}</span>

    <span class="s1">let fixed = self.fixed_value();</span>
    <span class="s1">let single_use = def.single_use</span>
        <span class="s1">&amp;&amp; !(parent </span><span class="s3">instanceof </span><span class="s1">AST_Call</span>
            <span class="s1">&amp;&amp; (parent.is_callee_pure(compressor))</span>
                <span class="s1">|| has_annotation(parent, _NOINLINE))</span>
        <span class="s1">&amp;&amp; !(parent </span><span class="s3">instanceof </span><span class="s1">AST_Export</span>
            <span class="s1">&amp;&amp; fixed </span><span class="s3">instanceof </span><span class="s1">AST_Lambda</span>
            <span class="s1">&amp;&amp; fixed.name);</span>

    <span class="s3">if </span><span class="s1">(single_use &amp;&amp; fixed </span><span class="s3">instanceof </span><span class="s1">AST_Node) {</span>
        <span class="s1">single_use =</span>
            <span class="s1">!fixed.has_side_effects(compressor)</span>
            <span class="s1">&amp;&amp; !fixed.may_throw(compressor);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(single_use &amp;&amp; (fixed </span><span class="s3">instanceof </span><span class="s1">AST_Lambda || fixed </span><span class="s3">instanceof </span><span class="s1">AST_Class)) {</span>
        <span class="s3">if </span><span class="s1">(retain_top_func(fixed, compressor)) {</span>
            <span class="s1">single_use = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(def.scope !== self.scope</span>
            <span class="s1">&amp;&amp; (def.escaped == </span><span class="s4">1</span>
                <span class="s1">|| has_flag(fixed, INLINED)</span>
                <span class="s1">|| within_array_or_object_literal(compressor)</span>
                <span class="s1">|| !compressor.option(</span><span class="s2">&quot;reduce_funcs&quot;</span><span class="s1">))) {</span>
            <span class="s1">single_use = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(is_recursive_ref(compressor, def)) {</span>
            <span class="s1">single_use = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(def.scope !== self.scope || def.orig[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolFunarg) {</span>
            <span class="s1">single_use = fixed.is_constant_expression(self.scope);</span>
            <span class="s3">if </span><span class="s1">(single_use == </span><span class="s2">&quot;f&quot;</span><span class="s1">) {</span>
                <span class="s3">var </span><span class="s1">scope = self.scope;</span>
                <span class="s3">do </span><span class="s1">{</span>
                    <span class="s3">if </span><span class="s1">(scope </span><span class="s3">instanceof </span><span class="s1">AST_Defun || is_func_expr(scope)) {</span>
                        <span class="s1">set_flag(scope, INLINED);</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">while </span><span class="s1">(scope = scope.parent_scope);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(single_use &amp;&amp; (fixed </span><span class="s3">instanceof </span><span class="s1">AST_Lambda || fixed </span><span class="s3">instanceof </span><span class="s1">AST_Class)) {</span>
        <span class="s1">single_use =</span>
            <span class="s1">def.scope === self.scope</span>
                <span class="s1">&amp;&amp; !scope_encloses_variables_in_this_scope(nearest_scope, fixed)</span>
            <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Call</span>
                <span class="s1">&amp;&amp; parent.expression === self</span>
                <span class="s1">&amp;&amp; !scope_encloses_variables_in_this_scope(nearest_scope, fixed)</span>
                <span class="s1">&amp;&amp; !(fixed.name &amp;&amp; fixed.name.definition().recursive_refs &gt; </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(single_use &amp;&amp; fixed) {</span>
        <span class="s3">if </span><span class="s1">(fixed </span><span class="s3">instanceof </span><span class="s1">AST_DefClass) {</span>
            <span class="s1">set_flag(fixed, SQUEEZED);</span>
            <span class="s1">fixed = make_node(AST_ClassExpression, fixed, fixed);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(fixed </span><span class="s3">instanceof </span><span class="s1">AST_Defun) {</span>
            <span class="s1">set_flag(fixed, SQUEEZED);</span>
            <span class="s1">fixed = make_node(AST_Function, fixed, fixed);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(def.recursive_refs &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; fixed.name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDefun) {</span>
            <span class="s1">const defun_def = fixed.name.definition();</span>
            <span class="s1">let lambda_def = fixed.variables.get(fixed.name.name);</span>
            <span class="s1">let name = lambda_def &amp;&amp; lambda_def.orig[</span><span class="s4">0</span><span class="s1">];</span>
            <span class="s3">if </span><span class="s1">(!(name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolLambda)) {</span>
                <span class="s1">name = make_node(AST_SymbolLambda, fixed.name, fixed.name);</span>
                <span class="s1">name.scope = fixed;</span>
                <span class="s1">fixed.name = name;</span>
                <span class="s1">lambda_def = fixed.def_function(name);</span>
            <span class="s1">}</span>
            <span class="s1">walk(fixed, node =&gt; {</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef &amp;&amp; node.definition() === defun_def) {</span>
                    <span class="s1">node.thedef = lambda_def;</span>
                    <span class="s1">lambda_def.references.push(node);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">(fixed </span><span class="s3">instanceof </span><span class="s1">AST_Lambda || fixed </span><span class="s3">instanceof </span><span class="s1">AST_Class)</span>
            <span class="s1">&amp;&amp; fixed.parent_scope !== nearest_scope</span>
        <span class="s1">) {</span>
            <span class="s1">fixed = fixed.clone(</span><span class="s3">true</span><span class="s1">, compressor.get_toplevel());</span>

            <span class="s1">nearest_scope.add_child_scope(fixed);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">fixed.optimize(compressor);</span>
    <span class="s1">}</span>

    <span class="s0">// multiple uses</span>
    <span class="s3">if </span><span class="s1">(fixed) {</span>
        <span class="s1">let replace;</span>

        <span class="s3">if </span><span class="s1">(fixed </span><span class="s3">instanceof </span><span class="s1">AST_This) {</span>
            <span class="s3">if </span><span class="s1">(!(def.orig[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolFunarg)</span>
                <span class="s1">&amp;&amp; def.references.every((ref) =&gt;</span>
                    <span class="s1">def.scope === ref.scope</span>
                <span class="s1">)) {</span>
                <span class="s1">replace = fixed;</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">var </span><span class="s1">ev = fixed.evaluate(compressor);</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">ev !== fixed</span>
                <span class="s1">&amp;&amp; (compressor.option(</span><span class="s2">&quot;unsafe_regexp&quot;</span><span class="s1">) || !(ev </span><span class="s3">instanceof </span><span class="s1">RegExp))</span>
            <span class="s1">) {</span>
                <span class="s1">replace = make_node_from_constant(ev, fixed);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(replace) {</span>
            <span class="s1">const name_length = self.size(compressor);</span>
            <span class="s1">const replace_size = replace.size(compressor);</span>

            <span class="s1">let overhead = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s1">) &amp;&amp; !compressor.exposed(def)) {</span>
                <span class="s1">overhead =</span>
                    <span class="s1">(name_length + </span><span class="s4">2 </span><span class="s1">+ replace_size) /</span>
                    <span class="s1">(def.references.length - def.assignments);</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(replace_size &lt;= name_length + overhead) {</span>
                <span class="s3">return </span><span class="s1">replace;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">self;</span>
<span class="s1">}</span>

<span class="s1">export </span><span class="s3">function </span><span class="s1">inline_into_call(self, fn, compressor) {</span>
    <span class="s3">var </span><span class="s1">exp = self.expression;</span>
    <span class="s3">var </span><span class="s1">simple_args = self.args.every((arg) =&gt; !(arg </span><span class="s3">instanceof </span><span class="s1">AST_Expansion));</span>

    <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;reduce_vars&quot;</span><span class="s1">)</span>
        <span class="s1">&amp;&amp; fn </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
        <span class="s1">&amp;&amp; !has_annotation(self, _NOINLINE)</span>
    <span class="s1">) {</span>
        <span class="s1">const fixed = fn.fixed_value();</span>
        <span class="s3">if </span><span class="s1">(!retain_top_func(fixed, compressor)) {</span>
            <span class="s1">fn = fixed;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">is_func = fn </span><span class="s3">instanceof </span><span class="s1">AST_Lambda;</span>

    <span class="s3">var </span><span class="s1">stat = is_func &amp;&amp; fn.body[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s3">var </span><span class="s1">is_regular_func = is_func &amp;&amp; !fn.is_generator &amp;&amp; !fn.async;</span>
    <span class="s3">var </span><span class="s1">can_inline = is_regular_func &amp;&amp; compressor.option(</span><span class="s2">&quot;inline&quot;</span><span class="s1">) &amp;&amp; !self.is_callee_pure(compressor);</span>
    <span class="s3">if </span><span class="s1">(can_inline &amp;&amp; stat </span><span class="s3">instanceof </span><span class="s1">AST_Return) {</span>
        <span class="s1">let returned = stat.value;</span>
        <span class="s3">if </span><span class="s1">(!returned || returned.is_constant_expression()) {</span>
            <span class="s3">if </span><span class="s1">(returned) {</span>
                <span class="s1">returned = returned.clone(</span><span class="s3">true</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">returned = make_node(AST_Undefined, self);</span>
            <span class="s1">}</span>
            <span class="s1">const args = self.args.concat(returned);</span>
            <span class="s3">return </span><span class="s1">make_sequence(self, args).optimize(compressor);</span>
        <span class="s1">}</span>

        <span class="s0">// optimize identity function</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">fn.argnames.length === </span><span class="s4">1</span>
            <span class="s1">&amp;&amp; (fn.argnames[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolFunarg)</span>
            <span class="s1">&amp;&amp; self.args.length &lt; </span><span class="s4">2</span>
            <span class="s1">&amp;&amp; !(self.args[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_Expansion)</span>
            <span class="s1">&amp;&amp; returned </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
            <span class="s1">&amp;&amp; returned.name === fn.argnames[</span><span class="s4">0</span><span class="s1">].name</span>
        <span class="s1">) {</span>
            <span class="s1">const replacement =</span>
                <span class="s1">(self.args[</span><span class="s4">0</span><span class="s1">] || make_node(AST_Undefined)).optimize(compressor);</span>

            <span class="s1">let parent;</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">replacement </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess</span>
                <span class="s1">&amp;&amp; (parent = compressor.parent()) </span><span class="s3">instanceof </span><span class="s1">AST_Call</span>
                <span class="s1">&amp;&amp; parent.expression === self</span>
            <span class="s1">) {</span>
                <span class="s0">// identity function was being used to remove `this`, like in</span>
                <span class="s0">//</span>
                <span class="s0">// id(bag.no_this)(...)</span>
                <span class="s0">//</span>
                <span class="s0">// Replace with a larger but more effish (0, bag.no_this) wrapper.</span>

                <span class="s3">return </span><span class="s1">make_sequence(self, [</span>
                    <span class="s1">make_node(AST_Number, self, { value: </span><span class="s4">0 </span><span class="s1">}),</span>
                    <span class="s1">replacement</span>
                <span class="s1">]);</span>
            <span class="s1">}</span>
            <span class="s0">// replace call with first argument or undefined if none passed</span>
            <span class="s3">return </span><span class="s1">replacement;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(can_inline) {</span>
        <span class="s3">var </span><span class="s1">scope, in_loop, level = -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">let def;</span>
        <span class="s1">let returned_value;</span>
        <span class="s1">let nearest_scope;</span>
        <span class="s3">if </span><span class="s1">(simple_args</span>
            <span class="s1">&amp;&amp; !fn.uses_arguments</span>
            <span class="s1">&amp;&amp; !(compressor.parent() </span><span class="s3">instanceof </span><span class="s1">AST_Class)</span>
            <span class="s1">&amp;&amp; !(fn.name &amp;&amp; fn </span><span class="s3">instanceof </span><span class="s1">AST_Function)</span>
            <span class="s1">&amp;&amp; (returned_value = can_flatten_body(stat))</span>
            <span class="s1">&amp;&amp; (exp === fn</span>
                <span class="s1">|| has_annotation(self, _INLINE)</span>
                <span class="s1">|| compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s1">)</span>
                    <span class="s1">&amp;&amp; (def = exp.definition()).references.length == </span><span class="s4">1</span>
                    <span class="s1">&amp;&amp; !is_recursive_ref(compressor, def)</span>
                    <span class="s1">&amp;&amp; fn.is_constant_expression(exp.scope))</span>
            <span class="s1">&amp;&amp; !has_annotation(self, _PURE | _NOINLINE)</span>
            <span class="s1">&amp;&amp; !fn.contains_this()</span>
            <span class="s1">&amp;&amp; can_inject_symbols()</span>
            <span class="s1">&amp;&amp; (nearest_scope = compressor.find_scope())</span>
            <span class="s1">&amp;&amp; !scope_encloses_variables_in_this_scope(nearest_scope, fn)</span>
            <span class="s1">&amp;&amp; !(</span><span class="s3">function </span><span class="s1">in_default_assign() {</span>
                    <span class="s0">// Due to the fact function parameters have their own scope</span>
                    <span class="s0">// which can't use `var something` in the function body within,</span>
                    <span class="s0">// we simply don't inline into DefaultAssign.</span>
                    <span class="s1">let i = </span><span class="s4">0</span><span class="s1">;</span>
                    <span class="s1">let p;</span>
                    <span class="s3">while </span><span class="s1">((p = compressor.parent(i++))) {</span>
                        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_DefaultAssign) </span><span class="s3">return true</span><span class="s1">;</span>
                        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_Block) </span><span class="s3">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">})()</span>
            <span class="s1">&amp;&amp; !(scope </span><span class="s3">instanceof </span><span class="s1">AST_Class)</span>
        <span class="s1">) {</span>
            <span class="s1">set_flag(fn, SQUEEZED);</span>
            <span class="s1">nearest_scope.add_child_scope(fn);</span>
            <span class="s3">return </span><span class="s1">make_sequence(self, flatten_fn(returned_value)).optimize(compressor);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(can_inline &amp;&amp; has_annotation(self, _INLINE)) {</span>
        <span class="s1">set_flag(fn, SQUEEZED);</span>
        <span class="s1">fn = make_node(fn.CTOR === AST_Defun ? AST_Function : fn.CTOR, fn, fn);</span>
        <span class="s1">fn = fn.clone(</span><span class="s3">true</span><span class="s1">);</span>
        <span class="s1">fn.figure_out_scope({}, {</span>
            <span class="s1">parent_scope: compressor.find_scope(),</span>
            <span class="s1">toplevel: compressor.get_toplevel()</span>
        <span class="s1">});</span>

        <span class="s3">return </span><span class="s1">make_node(AST_Call, self, {</span>
            <span class="s1">expression: fn,</span>
            <span class="s1">args: self.args,</span>
        <span class="s1">}).optimize(compressor);</span>
    <span class="s1">}</span>

    <span class="s1">const can_drop_this_call = is_regular_func &amp;&amp; compressor.option(</span><span class="s2">&quot;side_effects&quot;</span><span class="s1">) &amp;&amp; fn.body.every(is_empty);</span>
    <span class="s3">if </span><span class="s1">(can_drop_this_call) {</span>
        <span class="s3">var </span><span class="s1">args = self.args.concat(make_node(AST_Undefined, self));</span>
        <span class="s3">return </span><span class="s1">make_sequence(self, args).optimize(compressor);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;negate_iife&quot;</span><span class="s1">)</span>
        <span class="s1">&amp;&amp; compressor.parent() </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement</span>
        <span class="s1">&amp;&amp; is_iife_call(self)) {</span>
        <span class="s3">return </span><span class="s1">self.negate(compressor, </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">ev = self.evaluate(compressor);</span>
    <span class="s3">if </span><span class="s1">(ev !== self) {</span>
        <span class="s1">ev = make_node_from_constant(ev, self).optimize(compressor);</span>
        <span class="s3">return </span><span class="s1">best_of(compressor, ev, self);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">self;</span>

    <span class="s3">function </span><span class="s1">return_value(stat) {</span>
        <span class="s3">if </span><span class="s1">(!stat) </span><span class="s3">return </span><span class="s1">make_node(AST_Undefined, self);</span>
        <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Return) {</span>
            <span class="s3">if </span><span class="s1">(!stat.value) </span><span class="s3">return </span><span class="s1">make_node(AST_Undefined, self);</span>
            <span class="s3">return </span><span class="s1">stat.value.clone(</span><span class="s3">true</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
            <span class="s3">return </span><span class="s1">make_node(AST_UnaryPrefix, stat, {</span>
                <span class="s1">operator: </span><span class="s2">&quot;void&quot;</span><span class="s1">,</span>
                <span class="s1">expression: stat.body.clone(</span><span class="s3">true</span><span class="s1">)</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">can_flatten_body(stat) {</span>
        <span class="s3">var </span><span class="s1">body = fn.body;</span>
        <span class="s3">var </span><span class="s1">len = body.length;</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;inline&quot;</span><span class="s1">) &lt; </span><span class="s4">3</span><span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">len == </span><span class="s4">1 </span><span class="s1">&amp;&amp; return_value(stat);</span>
        <span class="s1">}</span>
        <span class="s1">stat = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; len; i++) {</span>
            <span class="s3">var </span><span class="s1">line = body[i];</span>
            <span class="s3">if </span><span class="s1">(line </span><span class="s3">instanceof </span><span class="s1">AST_Var) {</span>
                <span class="s3">if </span><span class="s1">(stat &amp;&amp; !line.definitions.every((var_def) =&gt;</span>
                    <span class="s1">!var_def.value</span>
                <span class="s1">)) {</span>
                    <span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!(line </span><span class="s3">instanceof </span><span class="s1">AST_EmptyStatement)) {</span>
                <span class="s1">stat = line;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">return_value(stat);</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">can_inject_args(block_scoped, safe_to_inject) {</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = fn.argnames.length; i &lt; len; i++) {</span>
            <span class="s3">var </span><span class="s1">arg = fn.argnames[i];</span>
            <span class="s3">if </span><span class="s1">(arg </span><span class="s3">instanceof </span><span class="s1">AST_DefaultAssign) {</span>
                <span class="s3">if </span><span class="s1">(has_flag(arg.left, UNUSED)) </span><span class="s3">continue</span><span class="s1">;</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(arg </span><span class="s3">instanceof </span><span class="s1">AST_Destructuring) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(arg </span><span class="s3">instanceof </span><span class="s1">AST_Expansion) {</span>
                <span class="s3">if </span><span class="s1">(has_flag(arg.expression, UNUSED)) </span><span class="s3">continue</span><span class="s1">;</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(has_flag(arg, UNUSED)) </span><span class="s3">continue</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(!safe_to_inject</span>
                <span class="s1">|| block_scoped.has(arg.name)</span>
                <span class="s1">|| identifier_atom.has(arg.name)</span>
                <span class="s1">|| scope.conflicting_def(arg.name)) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(in_loop) in_loop.push(arg.definition());</span>
        <span class="s1">}</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">can_inject_vars(block_scoped, safe_to_inject) {</span>
        <span class="s3">var </span><span class="s1">len = fn.body.length;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; len; i++) {</span>
            <span class="s3">var </span><span class="s1">stat = fn.body[i];</span>
            <span class="s3">if </span><span class="s1">(!(stat </span><span class="s3">instanceof </span><span class="s1">AST_Var)) </span><span class="s3">continue</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(!safe_to_inject) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">j = stat.definitions.length; --j &gt;= </span><span class="s4">0</span><span class="s1">;) {</span>
                <span class="s3">var </span><span class="s1">name = stat.definitions[j].name;</span>
                <span class="s3">if </span><span class="s1">(name </span><span class="s3">instanceof </span><span class="s1">AST_Destructuring</span>
                    <span class="s1">|| block_scoped.has(name.name)</span>
                    <span class="s1">|| identifier_atom.has(name.name)</span>
                    <span class="s1">|| scope.conflicting_def(name.name)) {</span>
                    <span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(in_loop) in_loop.push(name.definition());</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">can_inject_symbols() {</span>
        <span class="s3">var </span><span class="s1">block_scoped = </span><span class="s3">new </span><span class="s1">Set();</span>
        <span class="s3">do </span><span class="s1">{</span>
            <span class="s1">scope = compressor.parent(++level);</span>
            <span class="s3">if </span><span class="s1">(scope.is_block_scope() &amp;&amp; scope.block_scope) {</span>
                <span class="s0">// TODO this is sometimes undefined during compression.</span>
                <span class="s0">// But it should always have a value!</span>
                <span class="s1">scope.block_scope.variables.forEach(</span><span class="s3">function </span><span class="s1">(variable) {</span>
                    <span class="s1">block_scoped.add(variable.name);</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(scope </span><span class="s3">instanceof </span><span class="s1">AST_Catch) {</span>
                <span class="s0">// TODO can we delete? AST_Catch is a block scope.</span>
                <span class="s3">if </span><span class="s1">(scope.argname) {</span>
                    <span class="s1">block_scoped.add(scope.argname.name);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(scope </span><span class="s3">instanceof </span><span class="s1">AST_IterationStatement) {</span>
                <span class="s1">in_loop = [];</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(scope </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
                <span class="s3">if </span><span class="s1">(scope.fixed_value() </span><span class="s3">instanceof </span><span class="s1">AST_Scope) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">while </span><span class="s1">(!(scope </span><span class="s3">instanceof </span><span class="s1">AST_Scope));</span>

        <span class="s3">var </span><span class="s1">safe_to_inject = !(scope </span><span class="s3">instanceof </span><span class="s1">AST_Toplevel) || compressor.toplevel.vars;</span>
        <span class="s3">var </span><span class="s1">inline = compressor.option(</span><span class="s2">&quot;inline&quot;</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(!can_inject_vars(block_scoped, inline &gt;= </span><span class="s4">3 </span><span class="s1">&amp;&amp; safe_to_inject)) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(!can_inject_args(block_scoped, inline &gt;= </span><span class="s4">2 </span><span class="s1">&amp;&amp; safe_to_inject)) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">!in_loop || in_loop.length == </span><span class="s4">0 </span><span class="s1">|| !is_reachable(fn, in_loop);</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">append_var(decls, expressions, name, value) {</span>
        <span class="s3">var </span><span class="s1">def = name.definition();</span>

        <span class="s0">// Name already exists, only when a function argument had the same name</span>
        <span class="s1">const already_appended = scope.variables.has(name.name);</span>
        <span class="s3">if </span><span class="s1">(!already_appended) {</span>
            <span class="s1">scope.variables.set(name.name, def);</span>
            <span class="s1">scope.enclosed.push(def);</span>
            <span class="s1">decls.push(make_node(AST_VarDef, name, {</span>
                <span class="s1">name: name,</span>
                <span class="s1">value: </span><span class="s3">null</span>
            <span class="s1">}));</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">sym = make_node(AST_SymbolRef, name, name);</span>
        <span class="s1">def.references.push(sym);</span>
        <span class="s3">if </span><span class="s1">(value) expressions.push(make_node(AST_Assign, self, {</span>
            <span class="s1">operator: </span><span class="s2">&quot;=&quot;</span><span class="s1">,</span>
            <span class="s1">logical: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">left: sym,</span>
            <span class="s1">right: value.clone()</span>
        <span class="s1">}));</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">flatten_args(decls, expressions) {</span>
        <span class="s3">var </span><span class="s1">len = fn.argnames.length;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = self.args.length; --i &gt;= len;) {</span>
            <span class="s1">expressions.push(self.args[i]);</span>
        <span class="s1">}</span>
        <span class="s3">for </span><span class="s1">(i = len; --i &gt;= </span><span class="s4">0</span><span class="s1">;) {</span>
            <span class="s3">var </span><span class="s1">name = fn.argnames[i];</span>
            <span class="s3">var </span><span class="s1">value = self.args[i];</span>
            <span class="s3">if </span><span class="s1">(has_flag(name, UNUSED) || !name.name || scope.conflicting_def(name.name)) {</span>
                <span class="s3">if </span><span class="s1">(value) expressions.push(value);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">var </span><span class="s1">symbol = make_node(AST_SymbolVar, name, name);</span>
                <span class="s1">name.definition().orig.push(symbol);</span>
                <span class="s3">if </span><span class="s1">(!value &amp;&amp; in_loop) value = make_node(AST_Undefined, self);</span>
                <span class="s1">append_var(decls, expressions, symbol, value);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">decls.reverse();</span>
        <span class="s1">expressions.reverse();</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">flatten_vars(decls, expressions) {</span>
        <span class="s3">var </span><span class="s1">pos = expressions.length;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, lines = fn.body.length; i &lt; lines; i++) {</span>
            <span class="s3">var </span><span class="s1">stat = fn.body[i];</span>
            <span class="s3">if </span><span class="s1">(!(stat </span><span class="s3">instanceof </span><span class="s1">AST_Var)) </span><span class="s3">continue</span><span class="s1">;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">j = </span><span class="s4">0</span><span class="s1">, defs = stat.definitions.length; j &lt; defs; j++) {</span>
                <span class="s3">var </span><span class="s1">var_def = stat.definitions[j];</span>
                <span class="s3">var </span><span class="s1">name = var_def.name;</span>
                <span class="s1">append_var(decls, expressions, name, var_def.value);</span>
                <span class="s3">if </span><span class="s1">(in_loop &amp;&amp; fn.argnames.every((argname) =&gt;</span>
                    <span class="s1">argname.name != name.name</span>
                <span class="s1">)) {</span>
                    <span class="s3">var </span><span class="s1">def = fn.variables.get(name.name);</span>
                    <span class="s3">var </span><span class="s1">sym = make_node(AST_SymbolRef, name, name);</span>
                    <span class="s1">def.references.push(sym);</span>
                    <span class="s1">expressions.splice(pos++, </span><span class="s4">0</span><span class="s1">, make_node(AST_Assign, var_def, {</span>
                        <span class="s1">operator: </span><span class="s2">&quot;=&quot;</span><span class="s1">,</span>
                        <span class="s1">logical: </span><span class="s3">false</span><span class="s1">,</span>
                        <span class="s1">left: sym,</span>
                        <span class="s1">right: make_node(AST_Undefined, name)</span>
                    <span class="s1">}));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">flatten_fn(returned_value) {</span>
        <span class="s3">var </span><span class="s1">decls = [];</span>
        <span class="s3">var </span><span class="s1">expressions = [];</span>
        <span class="s1">flatten_args(decls, expressions);</span>
        <span class="s1">flatten_vars(decls, expressions);</span>
        <span class="s1">expressions.push(returned_value);</span>

        <span class="s3">if </span><span class="s1">(decls.length) {</span>
            <span class="s1">const i = scope.body.indexOf(compressor.parent(level - </span><span class="s4">1</span><span class="s1">)) + </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">scope.body.splice(i, </span><span class="s4">0</span><span class="s1">, make_node(AST_Var, fn, {</span>
                <span class="s1">definitions: decls</span>
            <span class="s1">}));</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">expressions.map(exp =&gt; exp.clone(</span><span class="s3">true</span><span class="s1">));</span>
    <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
<html>
<head>
<title>ReactHorizontalScrollView.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #629755; font-weight: bold; font-style: italic;}
.s5 { color: #6897bb;}
.s6 { color: #6a8759;}
.s7 { color: #77b767; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ReactHorizontalScrollView.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.views.scroll</span><span class="s2">;</span>

<span class="s2">import static </span><span class="s1">com.facebook.react.views.scroll.ReactScrollViewHelper.SNAP_ALIGNMENT_CENTER</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.views.scroll.ReactScrollViewHelper.SNAP_ALIGNMENT_DISABLED</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.views.scroll.ReactScrollViewHelper.SNAP_ALIGNMENT_END</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.views.scroll.ReactScrollViewHelper.SNAP_ALIGNMENT_START</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.animation.ObjectAnimator</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.animation.ValueAnimator</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.content.Context</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Canvas</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Color</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Rect</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.drawable.ColorDrawable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.drawable.Drawable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.FocusFinder</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.KeyEvent</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.MotionEvent</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.View</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.ViewGroup</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.widget.HorizontalScrollView</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.widget.OverScroller</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.core.view.ViewCompat</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.logging.FLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.infer.annotation.Assertions</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.ReactConstants</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.build.ReactBuildConfig</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.modules.i18nmanager.I18nUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.FabricViewStateManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.MeasureSpecAssertions</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.PointerEvents</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactClippingViewGroup</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactClippingViewGroupHelper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactOverflowViewWithInset</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ViewProps</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.events.NativeGestureUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.scroll.ReactScrollViewHelper.HasFlingAnimator</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.scroll.ReactScrollViewHelper.HasScrollEventThrottle</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.scroll.ReactScrollViewHelper.HasScrollState</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.scroll.ReactScrollViewHelper.HasSmoothScroll</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.scroll.ReactScrollViewHelper.ReactScrollViewScrollState</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.view.ReactViewBackgroundManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.lang.reflect.Field</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.ArrayList</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.List</span><span class="s2">;</span>

<span class="s3">/** Similar to {</span><span class="s4">@link </span><span class="s3">ReactScrollView} but only supports horizontal scrolling. */</span>
<span class="s2">public class </span><span class="s1">ReactHorizontalScrollView </span><span class="s2">extends </span><span class="s1">HorizontalScrollView</span>
    <span class="s2">implements </span><span class="s1">ReactClippingViewGroup</span><span class="s2">,</span>
        <span class="s1">ViewGroup.OnHierarchyChangeListener</span><span class="s2">,</span>
        <span class="s1">View.OnLayoutChangeListener</span><span class="s2">,</span>
        <span class="s1">FabricViewStateManager.HasFabricViewStateManager</span><span class="s2">,</span>
        <span class="s1">ReactOverflowViewWithInset</span><span class="s2">,</span>
        <span class="s1">HasScrollState</span><span class="s2">,</span>
        <span class="s1">HasFlingAnimator</span><span class="s2">,</span>
        <span class="s1">HasScrollEventThrottle</span><span class="s2">,</span>
        <span class="s1">HasSmoothScroll {</span>

  <span class="s2">private static boolean </span><span class="s1">DEBUG_MODE = </span><span class="s2">false </span><span class="s1">&amp;&amp; ReactBuildConfig.DEBUG</span><span class="s2">;</span>
  <span class="s2">private static </span><span class="s1">String TAG = ReactHorizontalScrollView.</span><span class="s2">class</span><span class="s1">.getSimpleName()</span><span class="s2">;</span>

  <span class="s2">private static int </span><span class="s1">NO_SCROLL_POSITION = Integer.MIN_VALUE</span><span class="s2">;</span>

  <span class="s2">private static </span><span class="s1">@Nullable Field sScrollerField</span><span class="s2">;</span>
  <span class="s2">private static boolean </span><span class="s1">sTriedToGetScrollerField = </span><span class="s2">false;</span>

  <span class="s2">private int </span><span class="s1">mScrollXAfterMeasure = NO_SCROLL_POSITION</span><span class="s2">;</span>

  <span class="s2">private static final int </span><span class="s1">UNSET_CONTENT_OFFSET = -</span><span class="s5">1</span><span class="s2">;</span>

  <span class="s2">private final </span><span class="s1">OnScrollDispatchHelper mOnScrollDispatchHelper = </span><span class="s2">new </span><span class="s1">OnScrollDispatchHelper()</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">@Nullable OverScroller mScroller</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">VelocityHelper mVelocityHelper = </span><span class="s2">new </span><span class="s1">VelocityHelper()</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">Rect mRect = </span><span class="s2">new </span><span class="s1">Rect()</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">Rect mOverflowInset = </span><span class="s2">new </span><span class="s1">Rect()</span><span class="s2">;</span>

  <span class="s2">private boolean </span><span class="s1">mActivelyScrolling</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Rect mClippingRect</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable String mOverflow = ViewProps.HIDDEN</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mDragging</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mPagingEnabled = </span><span class="s2">false;</span>
  <span class="s2">private </span><span class="s1">@Nullable Runnable mPostTouchRunnable</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mRemoveClippedSubviews</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mScrollEnabled = </span><span class="s2">true;</span>
  <span class="s2">private boolean </span><span class="s1">mSendMomentumEvents</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable FpsListener mFpsListener = </span><span class="s2">null;</span>
  <span class="s2">private </span><span class="s1">@Nullable String mScrollPerfTag</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Drawable mEndBackground</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mEndFillColor = Color.TRANSPARENT</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mDisableIntervalMomentum = </span><span class="s2">false;</span>
  <span class="s2">private int </span><span class="s1">mSnapInterval = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable List&lt;Integer&gt; mSnapOffsets</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mSnapToStart = </span><span class="s2">true;</span>
  <span class="s2">private boolean </span><span class="s1">mSnapToEnd = </span><span class="s2">true;</span>
  <span class="s2">private int </span><span class="s1">mSnapToAlignment = SNAP_ALIGNMENT_DISABLED</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">ReactViewBackgroundManager mReactBackgroundManager</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mPagedArrowScrolling = </span><span class="s2">false;</span>
  <span class="s2">private int </span><span class="s1">pendingContentOffsetX = UNSET_CONTENT_OFFSET</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">pendingContentOffsetY = UNSET_CONTENT_OFFSET</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">FabricViewStateManager mFabricViewStateManager = </span><span class="s2">new </span><span class="s1">FabricViewStateManager()</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">ReactScrollViewScrollState mReactScrollViewScrollState</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">ValueAnimator DEFAULT_FLING_ANIMATOR = ObjectAnimator.ofInt(</span><span class="s2">this, </span><span class="s6">&quot;scrollX&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">PointerEvents mPointerEvents = PointerEvents.AUTO</span><span class="s2">;</span>
  <span class="s2">private long </span><span class="s1">mLastScrollDispatchTime = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mScrollEventThrottle = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable View mContentView</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable MaintainVisibleScrollPositionHelper mMaintainVisibleContentPositionHelper</span><span class="s2">;</span>

  <span class="s2">private final </span><span class="s1">Rect mTempRect = </span><span class="s2">new </span><span class="s1">Rect()</span><span class="s2">;</span>

  <span class="s2">public </span><span class="s1">ReactHorizontalScrollView(Context context) {</span>
    <span class="s2">this</span><span class="s1">(context</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">ReactHorizontalScrollView(Context context</span><span class="s2">, </span><span class="s1">@Nullable FpsListener fpsListener) {</span>
    <span class="s2">super</span><span class="s1">(context)</span><span class="s2">;</span>
    <span class="s1">mReactBackgroundManager = </span><span class="s2">new </span><span class="s1">ReactViewBackgroundManager(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">mFpsListener = fpsListener</span><span class="s2">;</span>

    <span class="s1">ViewCompat.setAccessibilityDelegate(</span><span class="s2">this, new </span><span class="s1">ReactScrollViewAccessibilityDelegate())</span><span class="s2">;</span>

    <span class="s1">mScroller = getOverScrollerFromParent()</span><span class="s2">;</span>
    <span class="s1">mReactScrollViewScrollState =</span>
        <span class="s2">new </span><span class="s1">ReactScrollViewScrollState(</span>
            <span class="s1">I18nUtil.getInstance().isRTL(context)</span>
                <span class="s1">? ViewCompat.LAYOUT_DIRECTION_RTL</span>
                <span class="s1">: ViewCompat.LAYOUT_DIRECTION_LTR)</span><span class="s2">;</span>

    <span class="s1">setOnHierarchyChangeListener(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public boolean </span><span class="s1">getScrollEnabled() {</span>
    <span class="s2">return </span><span class="s1">mScrollEnabled</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Nullable</span>
  <span class="s2">private </span><span class="s1">OverScroller getOverScrollerFromParent() {</span>
    <span class="s1">OverScroller scroller</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(!sTriedToGetScrollerField) {</span>
      <span class="s1">sTriedToGetScrollerField = </span><span class="s2">true;</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">sScrollerField = HorizontalScrollView.</span><span class="s2">class</span><span class="s1">.getDeclaredField(</span><span class="s6">&quot;mScroller&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">sScrollerField.setAccessible(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(NoSuchFieldException e) {</span>
        <span class="s1">FLog.w(</span>
            <span class="s1">TAG</span><span class="s2">,</span>
            <span class="s6">&quot;Failed to get mScroller field for HorizontalScrollView! &quot;</span>
                <span class="s1">+ </span><span class="s6">&quot;This app will exhibit the bounce-back scrolling bug :(&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(sScrollerField != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">Object scrollerValue = sScrollerField.get(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(scrollerValue </span><span class="s2">instanceof </span><span class="s1">OverScroller) {</span>
          <span class="s1">scroller = (OverScroller) scrollerValue</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">FLog.w(</span>
              <span class="s1">TAG</span><span class="s2">,</span>
              <span class="s6">&quot;Failed to cast mScroller field in HorizontalScrollView (probably due to OEM changes to AOSP)! &quot;</span>
                  <span class="s1">+ </span><span class="s6">&quot;This app will exhibit the bounce-back scrolling bug :(&quot;</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">scroller = </span><span class="s2">null;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(IllegalAccessException e) {</span>
        <span class="s2">throw new </span><span class="s1">RuntimeException(</span><span class="s6">&quot;Failed to get mScroller from HorizontalScrollView!&quot;</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">scroller = </span><span class="s2">null;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">scroller</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setScrollPerfTag(@Nullable String scrollPerfTag) {</span>
    <span class="s1">mScrollPerfTag = scrollPerfTag</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setRemoveClippedSubviews(</span><span class="s2">boolean </span><span class="s1">removeClippedSubviews) {</span>
    <span class="s2">if </span><span class="s1">(removeClippedSubviews &amp;&amp; mClippingRect == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mClippingRect = </span><span class="s2">new </span><span class="s1">Rect()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mRemoveClippedSubviews = removeClippedSubviews</span><span class="s2">;</span>
    <span class="s1">updateClippingRect()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">getRemoveClippedSubviews() {</span>
    <span class="s2">return </span><span class="s1">mRemoveClippedSubviews</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setDisableIntervalMomentum(</span><span class="s2">boolean </span><span class="s1">disableIntervalMomentum) {</span>
    <span class="s1">mDisableIntervalMomentum = disableIntervalMomentum</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setSendMomentumEvents(</span><span class="s2">boolean </span><span class="s1">sendMomentumEvents) {</span>
    <span class="s1">mSendMomentumEvents = sendMomentumEvents</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setScrollEnabled(</span><span class="s2">boolean </span><span class="s1">scrollEnabled) {</span>
    <span class="s1">mScrollEnabled = scrollEnabled</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setPagingEnabled(</span><span class="s2">boolean </span><span class="s1">pagingEnabled) {</span>
    <span class="s1">mPagingEnabled = pagingEnabled</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setDecelerationRate(</span><span class="s2">float </span><span class="s1">decelerationRate) {</span>
    <span class="s1">getReactScrollViewScrollState().setDecelerationRate(decelerationRate)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mScroller != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mScroller.setFriction(</span><span class="s5">1.0f </span><span class="s1">- decelerationRate)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setSnapInterval(</span><span class="s2">int </span><span class="s1">snapInterval) {</span>
    <span class="s1">mSnapInterval = snapInterval</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setSnapOffsets(List&lt;Integer&gt; snapOffsets) {</span>
    <span class="s1">mSnapOffsets = snapOffsets</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setSnapToStart(</span><span class="s2">boolean </span><span class="s1">snapToStart) {</span>
    <span class="s1">mSnapToStart = snapToStart</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setSnapToEnd(</span><span class="s2">boolean </span><span class="s1">snapToEnd) {</span>
    <span class="s1">mSnapToEnd = snapToEnd</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setSnapToAlignment(</span><span class="s2">int </span><span class="s1">snapToAlignment) {</span>
    <span class="s1">mSnapToAlignment = snapToAlignment</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">flashScrollIndicators() {</span>
    <span class="s1">awakenScrollBars()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setOverflow(String overflow) {</span>
    <span class="s1">mOverflow = overflow</span><span class="s2">;</span>
    <span class="s1">invalidate()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setMaintainVisibleContentPosition(</span>
      <span class="s1">@Nullable MaintainVisibleScrollPositionHelper.Config config) {</span>
    <span class="s2">if </span><span class="s1">(config != </span><span class="s2">null </span><span class="s1">&amp;&amp; mMaintainVisibleContentPositionHelper == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mMaintainVisibleContentPositionHelper = </span><span class="s2">new </span><span class="s1">MaintainVisibleScrollPositionHelper(</span><span class="s2">this, true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">mMaintainVisibleContentPositionHelper.start()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(config == </span><span class="s2">null </span><span class="s1">&amp;&amp; mMaintainVisibleContentPositionHelper != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mMaintainVisibleContentPositionHelper.stop()</span><span class="s2">;</span>
      <span class="s1">mMaintainVisibleContentPositionHelper = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(mMaintainVisibleContentPositionHelper != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mMaintainVisibleContentPositionHelper.setConfig(config)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">@Nullable String getOverflow() {</span>
    <span class="s2">return </span><span class="s1">mOverflow</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setOverflowInset(</span><span class="s2">int </span><span class="s1">left</span><span class="s2">, int </span><span class="s1">top</span><span class="s2">, int </span><span class="s1">right</span><span class="s2">, int </span><span class="s1">bottom) {</span>
    <span class="s1">mOverflowInset.set(left</span><span class="s2">, </span><span class="s1">top</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">bottom)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">Rect getOverflowInset() {</span>
    <span class="s2">return </span><span class="s1">mOverflowInset</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onDraw(Canvas canvas) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.i(TAG</span><span class="s2">, </span><span class="s6">&quot;onDraw[%d]&quot;</span><span class="s2">, </span><span class="s1">getId())</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">getDrawingRect(mRect)</span><span class="s2">;</span>

    <span class="s2">switch </span><span class="s1">(mOverflow) {</span>
      <span class="s2">case </span><span class="s1">ViewProps.VISIBLE:</span>
        <span class="s2">break;</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s1">canvas.clipRect(mRect)</span><span class="s2">;</span>
        <span class="s2">break;</span>
    <span class="s1">}</span>

    <span class="s2">super</span><span class="s1">.onDraw(canvas)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onMeasure(</span><span class="s2">int </span><span class="s1">widthMeasureSpec</span><span class="s2">, int </span><span class="s1">heightMeasureSpec) {</span>
    <span class="s1">MeasureSpecAssertions.assertExplicitMeasureSpec(widthMeasureSpec</span><span class="s2">, </span><span class="s1">heightMeasureSpec)</span><span class="s2">;</span>

    <span class="s2">int </span><span class="s1">measuredWidth = MeasureSpec.getSize(widthMeasureSpec)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">measuredHeight = MeasureSpec.getSize(heightMeasureSpec)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.i(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s6">&quot;onMeasure[%d] measured width: %d measured height: %d&quot;</span><span class="s2">,</span>
          <span class="s1">getId()</span><span class="s2">,</span>
          <span class="s1">measuredWidth</span><span class="s2">,</span>
          <span class="s1">measuredHeight)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">boolean </span><span class="s1">measuredHeightChanged = getMeasuredHeight() != measuredHeight</span><span class="s2">;</span>

    <span class="s1">setMeasuredDimension(measuredWidth</span><span class="s2">, </span><span class="s1">measuredHeight)</span><span class="s2">;</span>

    <span class="s0">// See how `mScrollXAfterMeasure` is used in `onLayout`, and why we only enable the</span>
    <span class="s0">// hack if the height has changed.</span>
    <span class="s2">if </span><span class="s1">(measuredHeightChanged &amp;&amp; mScroller != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mScrollXAfterMeasure = mScroller.getCurrX()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onLayout(</span><span class="s2">boolean </span><span class="s1">changed</span><span class="s2">, int </span><span class="s1">l</span><span class="s2">, int </span><span class="s1">t</span><span class="s2">, int </span><span class="s1">r</span><span class="s2">, int </span><span class="s1">b) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.i(TAG</span><span class="s2">, </span><span class="s6">&quot;onLayout[%d] l %d t %d r %d b %d&quot;</span><span class="s2">, </span><span class="s1">getId()</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Has the scrollX changed between the last onMeasure and this layout?</span>
    <span class="s0">// If so, cancel the animation.</span>
    <span class="s0">// Essentially, if the height changes (due to keyboard popping up, for instance) the</span>
    <span class="s0">// underlying View.layout method will in some cases scroll to an incorrect X position -</span>
    <span class="s0">// see also the hacks in `fling`. The order of layout is called in the order of: onMeasure,</span>
    <span class="s0">// layout, onLayout.</span>
    <span class="s0">// We cannot override `layout` but we can detect the sequence of events between onMeasure</span>
    <span class="s0">// and onLayout.</span>
    <span class="s2">if </span><span class="s1">(mScrollXAfterMeasure != NO_SCROLL_POSITION</span>
        <span class="s1">&amp;&amp; mScroller != </span><span class="s2">null</span>
        <span class="s1">&amp;&amp; mScrollXAfterMeasure != mScroller.getFinalX()</span>
        <span class="s1">&amp;&amp; !mScroller.isFinished()) {</span>
      <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
        <span class="s1">FLog.i(</span>
            <span class="s1">TAG</span><span class="s2">,</span>
            <span class="s6">&quot;onLayout[%d] scroll hack enabled: reset to previous scrollX position of %d&quot;</span><span class="s2">,</span>
            <span class="s1">getId()</span><span class="s2">,</span>
            <span class="s1">mScrollXAfterMeasure)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">mScroller.startScroll(mScrollXAfterMeasure</span><span class="s2">, </span><span class="s1">mScroller.getFinalY()</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">mScroller.forceFinished(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">mScrollXAfterMeasure = NO_SCROLL_POSITION</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Apply pending contentOffset in case it was set before the view was laid out.</span>
    <span class="s2">if </span><span class="s1">(isContentReady()) {</span>
      <span class="s0">// If a &quot;pending&quot; content offset value has been set, we restore that value.</span>
      <span class="s0">// Upon call to scrollTo, the &quot;pending&quot; values will be re-set.</span>
      <span class="s2">int </span><span class="s1">scrollToX =</span>
          <span class="s1">pendingContentOffsetX != UNSET_CONTENT_OFFSET ? pendingContentOffsetX : getScrollX()</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">scrollToY =</span>
          <span class="s1">pendingContentOffsetY != UNSET_CONTENT_OFFSET ? pendingContentOffsetY : getScrollY()</span><span class="s2">;</span>
      <span class="s1">scrollTo(scrollToX</span><span class="s2">, </span><span class="s1">scrollToY)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">ReactScrollViewHelper.emitLayoutEvent(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Since ReactHorizontalScrollView handles layout changes on JS side, it does not call</span>
   <span class="s3">* super.onlayout due to which mIsLayoutDirty flag in HorizontalScrollView remains true and</span>
   <span class="s3">* prevents scrolling to child when requestChildFocus is called. Overriding this method and</span>
   <span class="s3">* scrolling to child without checking any layout dirty flag. This will fix focus navigation issue</span>
   <span class="s3">* for KeyEvents which are not handled in HorizontalScrollView, for example: KEYCODE_TAB.</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">requestChildFocus(View child</span><span class="s2">, </span><span class="s1">View focused) {</span>
    <span class="s2">if </span><span class="s1">(focused != </span><span class="s2">null </span><span class="s1">&amp;&amp; !mPagingEnabled) {</span>
      <span class="s1">scrollToChild(focused)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">super</span><span class="s1">.requestChildFocus(child</span><span class="s2">, </span><span class="s1">focused)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">addFocusables(ArrayList&lt;View&gt; views</span><span class="s2">, int </span><span class="s1">direction</span><span class="s2">, int </span><span class="s1">focusableMode) {</span>
    <span class="s2">if </span><span class="s1">(mPagingEnabled &amp;&amp; !mPagedArrowScrolling) {</span>
      <span class="s0">// Only add elements within the current page to list of focusables</span>
      <span class="s1">ArrayList&lt;View&gt; candidateViews = </span><span class="s2">new </span><span class="s1">ArrayList&lt;View&gt;()</span><span class="s2">;</span>
      <span class="s2">super</span><span class="s1">.addFocusables(candidateViews</span><span class="s2">, </span><span class="s1">direction</span><span class="s2">, </span><span class="s1">focusableMode)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(View candidate : candidateViews) {</span>
        <span class="s0">// We must also include the currently focused in the focusables list or focus search will</span>
        <span class="s0">// always</span>
        <span class="s0">// return the first element within the focusables list</span>
        <span class="s2">if </span><span class="s1">(isScrolledInView(candidate)</span>
            <span class="s1">|| isPartiallyScrolledInView(candidate)</span>
            <span class="s1">|| candidate.isFocused()) {</span>
          <span class="s1">views.add(candidate)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">super</span><span class="s1">.addFocusables(views</span><span class="s2">, </span><span class="s1">direction</span><span class="s2">, </span><span class="s1">focusableMode)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** Calculates the x delta required to scroll the given descendent into view */</span>
  <span class="s2">private int </span><span class="s1">getScrollDelta(View descendent) {</span>
    <span class="s1">descendent.getDrawingRect(mTempRect)</span><span class="s2">;</span>
    <span class="s1">offsetDescendantRectToMyCoords(descendent</span><span class="s2">, </span><span class="s1">mTempRect)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">computeScrollDeltaToGetChildRectOnScreen(mTempRect)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Returns whether the given descendent is scrolled fully in view */</span>
  <span class="s2">private boolean </span><span class="s1">isScrolledInView(View descendent) {</span>
    <span class="s2">return </span><span class="s1">getScrollDelta(descendent) == </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Returns whether the given descendent is partially scrolled in view */</span>
  <span class="s2">public boolean </span><span class="s1">isPartiallyScrolledInView(View descendent) {</span>
    <span class="s2">int </span><span class="s1">scrollDelta = getScrollDelta(descendent)</span><span class="s2">;</span>
    <span class="s1">descendent.getDrawingRect(mTempRect)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">scrollDelta != </span><span class="s5">0 </span><span class="s1">&amp;&amp; Math.abs(scrollDelta) &lt; mTempRect.width()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Returns whether the given descendent is &quot;mostly&quot; (&gt;50%) scrolled in view */</span>
  <span class="s2">private boolean </span><span class="s1">isMostlyScrolledInView(View descendent) {</span>
    <span class="s2">int </span><span class="s1">scrollDelta = getScrollDelta(descendent)</span><span class="s2">;</span>
    <span class="s1">descendent.getDrawingRect(mTempRect)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">scrollDelta != </span><span class="s5">0 </span><span class="s1">&amp;&amp; Math.abs(scrollDelta) &lt; (mTempRect.width() / </span><span class="s5">2</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">scrollToChild(View child) {</span>
    <span class="s2">int </span><span class="s1">scrollDelta = getScrollDelta(child)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(scrollDelta != </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s1">scrollBy(scrollDelta</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onScrollChanged(</span><span class="s2">int </span><span class="s1">x</span><span class="s2">, int </span><span class="s1">y</span><span class="s2">, int </span><span class="s1">oldX</span><span class="s2">, int </span><span class="s1">oldY) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.i(TAG</span><span class="s2">, </span><span class="s6">&quot;onScrollChanged[%d] x %d y %d oldx %d oldy %d&quot;</span><span class="s2">, </span><span class="s1">getId()</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">oldX</span><span class="s2">, </span><span class="s1">oldY)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">super</span><span class="s1">.onScrollChanged(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">oldX</span><span class="s2">, </span><span class="s1">oldY)</span><span class="s2">;</span>

    <span class="s1">mActivelyScrolling = </span><span class="s2">true;</span>

    <span class="s2">if </span><span class="s1">(mOnScrollDispatchHelper.onScrollChanged(x</span><span class="s2">, </span><span class="s1">y)) {</span>
      <span class="s2">if </span><span class="s1">(mRemoveClippedSubviews) {</span>
        <span class="s1">updateClippingRect()</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">ReactScrollViewHelper.updateStateOnScrollChanged(</span>
          <span class="s2">this,</span>
          <span class="s1">mOnScrollDispatchHelper.getXFlingVelocity()</span><span class="s2">,</span>
          <span class="s1">mOnScrollDispatchHelper.getYFlingVelocity())</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">onInterceptTouchEvent(MotionEvent ev) {</span>
    <span class="s2">if </span><span class="s1">(!mScrollEnabled) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>

    <span class="s0">// We intercept the touch event if the children are not supposed to receive it.</span>
    <span class="s2">if </span><span class="s1">(!PointerEvents.canChildrenBeTouchTarget(mPointerEvents)) {</span>
      <span class="s2">return true;</span>
    <span class="s1">}</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">super</span><span class="s1">.onInterceptTouchEvent(ev)) {</span>
        <span class="s1">handleInterceptedTouchEvent(ev)</span><span class="s2">;</span>
        <span class="s2">return true;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(IllegalArgumentException e) {</span>
      <span class="s0">// Log and ignore the error. This seems to be a bug in the android SDK and</span>
      <span class="s0">// this is the commonly accepted workaround.</span>
      <span class="s0">// https://tinyurl.com/mw6qkod (Stack Overflow)</span>
      <span class="s1">FLog.w(ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;Error intercepting touch event.&quot;</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">return false;</span>
  <span class="s1">}</span>

  <span class="s2">protected void </span><span class="s1">handleInterceptedTouchEvent(MotionEvent ev) {</span>
    <span class="s1">NativeGestureUtil.notifyNativeGestureStarted(</span><span class="s2">this, </span><span class="s1">ev)</span><span class="s2">;</span>
    <span class="s1">ReactScrollViewHelper.emitScrollBeginDragEvent(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">mDragging = </span><span class="s2">true;</span>
    <span class="s1">enableFpsListener()</span><span class="s2">;</span>
    <span class="s1">getFlingAnimator().cancel()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">pageScroll(</span><span class="s2">int </span><span class="s1">direction) {</span>
    <span class="s2">boolean </span><span class="s1">handled = </span><span class="s2">super</span><span class="s1">.pageScroll(direction)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mPagingEnabled &amp;&amp; handled) {</span>
      <span class="s1">handlePostTouchScrolling(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">handled</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">arrowScroll(</span><span class="s2">int </span><span class="s1">direction) {</span>
    <span class="s2">boolean </span><span class="s1">handled = </span><span class="s2">false;</span>

    <span class="s2">if </span><span class="s1">(mPagingEnabled) {</span>
      <span class="s1">mPagedArrowScrolling = </span><span class="s2">true;</span>

      <span class="s2">if </span><span class="s1">(getChildCount() &gt; </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s1">View currentFocused = findFocus()</span><span class="s2">;</span>
        <span class="s1">View nextFocused = FocusFinder.getInstance().findNextFocus(</span><span class="s2">this, </span><span class="s1">currentFocused</span><span class="s2">, </span><span class="s1">direction)</span><span class="s2">;</span>
        <span class="s1">View rootChild = getContentView()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(rootChild != </span><span class="s2">null </span><span class="s1">&amp;&amp; nextFocused != </span><span class="s2">null </span><span class="s1">&amp;&amp; nextFocused.getParent() == rootChild) {</span>
          <span class="s2">if </span><span class="s1">(!isScrolledInView(nextFocused) &amp;&amp; !isMostlyScrolledInView(nextFocused)) {</span>
            <span class="s1">smoothScrollToNextPage(direction)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s1">nextFocused.requestFocus()</span><span class="s2">;</span>
          <span class="s1">handled = </span><span class="s2">true;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">smoothScrollToNextPage(direction)</span><span class="s2">;</span>
          <span class="s1">handled = </span><span class="s2">true;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">mPagedArrowScrolling = </span><span class="s2">false;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">handled = </span><span class="s2">super</span><span class="s1">.arrowScroll(direction)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">handled</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">onTouchEvent(MotionEvent ev) {</span>
    <span class="s2">if </span><span class="s1">(!mScrollEnabled) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>

    <span class="s0">// We do not accept the touch event if this view is not supposed to receive it.</span>
    <span class="s2">if </span><span class="s1">(!PointerEvents.canBeTouchTarget(mPointerEvents)) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>

    <span class="s1">mVelocityHelper.calculateVelocity(ev)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">action = ev.getActionMasked()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(action == MotionEvent.ACTION_UP &amp;&amp; mDragging) {</span>
      <span class="s1">ReactScrollViewHelper.updateFabricScrollState(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s2">float </span><span class="s1">velocityX = mVelocityHelper.getXVelocity()</span><span class="s2">;</span>
      <span class="s2">float </span><span class="s1">velocityY = mVelocityHelper.getYVelocity()</span><span class="s2">;</span>
      <span class="s1">ReactScrollViewHelper.emitScrollEndDragEvent(</span><span class="s2">this, </span><span class="s1">velocityX</span><span class="s2">, </span><span class="s1">velocityY)</span><span class="s2">;</span>
      <span class="s1">NativeGestureUtil.notifyNativeGestureEnded(</span><span class="s2">this, </span><span class="s1">ev)</span><span class="s2">;</span>
      <span class="s1">mDragging = </span><span class="s2">false;</span>
      <span class="s0">// After the touch finishes, we may need to do some scrolling afterwards either as a result</span>
      <span class="s0">// of a fling or because we need to page align the content</span>
      <span class="s1">handlePostTouchScrolling(Math.round(velocityX)</span><span class="s2">, </span><span class="s1">Math.round(velocityY))</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(action == MotionEvent.ACTION_DOWN) {</span>
      <span class="s1">cancelPostTouchScrolling()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">return super</span><span class="s1">.onTouchEvent(ev)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">dispatchGenericPointerEvent(MotionEvent ev) {</span>
    <span class="s0">// We do not dispatch the pointer event if its children are not supposed to receive it</span>
    <span class="s2">if </span><span class="s1">(!PointerEvents.canChildrenBeTouchTarget(mPointerEvents)) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>

    <span class="s2">return super</span><span class="s1">.dispatchGenericPointerEvent(ev)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">executeKeyEvent(KeyEvent event) {</span>
    <span class="s2">int </span><span class="s1">eventKeyCode = event.getKeyCode()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!mScrollEnabled</span>
        <span class="s1">&amp;&amp; (eventKeyCode == KeyEvent.KEYCODE_DPAD_LEFT</span>
            <span class="s1">|| eventKeyCode == KeyEvent.KEYCODE_DPAD_RIGHT)) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">return super</span><span class="s1">.executeKeyEvent(event)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">fling(</span><span class="s2">int </span><span class="s1">velocityX) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.i(TAG</span><span class="s2">, </span><span class="s6">&quot;fling[%d] velocityX %d&quot;</span><span class="s2">, </span><span class="s1">getId()</span><span class="s2">, </span><span class="s1">velocityX)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Workaround.</span>
    <span class="s0">// On Android P if a ScrollView is inverted, we will get a wrong sign for</span>
    <span class="s0">// velocityX (see https://issuetracker.google.com/issues/112385925).</span>
    <span class="s0">// At the same time, mOnScrollDispatchHelper tracks the correct velocity direction.</span>
    <span class="s0">//</span>
    <span class="s0">// Hence, we can use the absolute value from whatever the OS gives</span>
    <span class="s0">// us and use the sign of what mOnScrollDispatchHelper has tracked.</span>
    <span class="s2">final int </span><span class="s1">correctedVelocityX =</span>
        <span class="s1">(</span><span class="s2">int</span><span class="s1">) (Math.abs(velocityX) * Math.signum(mOnScrollDispatchHelper.getXFlingVelocity()))</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mPagingEnabled) {</span>
      <span class="s1">flingAndSnap(correctedVelocityX)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(mScroller != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// FB SCROLLVIEW CHANGE</span>

      <span class="s0">// We provide our own version of fling that uses a different call to the standard OverScroller</span>
      <span class="s0">// which takes into account the possibility of adding new content while the ScrollView is</span>
      <span class="s0">// animating. Because we give essentially no max X for the fling, the fling will continue as</span>
      <span class="s0">// long</span>
      <span class="s0">// as there is content. See #onOverScrolled() to see the second part of this change which</span>
      <span class="s0">// properly</span>
      <span class="s0">// aborts the scroller animation when we get to the bottom of the ScrollView content.</span>

      <span class="s2">int </span><span class="s1">scrollWindowWidth =</span>
          <span class="s1">getWidth() - ViewCompat.getPaddingStart(</span><span class="s2">this</span><span class="s1">) - ViewCompat.getPaddingEnd(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s1">mScroller.fling(</span>
          <span class="s1">getScrollX()</span><span class="s2">, </span><span class="s0">// startX</span>
          <span class="s1">getScrollY()</span><span class="s2">, </span><span class="s0">// startY</span>
          <span class="s1">correctedVelocityX</span><span class="s2">, </span><span class="s0">// velocityX</span>
          <span class="s5">0</span><span class="s2">, </span><span class="s0">// velocityY</span>
          <span class="s5">0</span><span class="s2">, </span><span class="s0">// minX</span>
          <span class="s1">Integer.MAX_VALUE</span><span class="s2">, </span><span class="s0">// maxX</span>
          <span class="s5">0</span><span class="s2">, </span><span class="s0">// minY</span>
          <span class="s5">0</span><span class="s2">, </span><span class="s0">// maxY</span>
          <span class="s1">scrollWindowWidth / </span><span class="s5">2</span><span class="s2">, </span><span class="s0">// overX</span>
          <span class="s5">0 </span><span class="s0">// overY</span>
          <span class="s1">)</span><span class="s2">;</span>

      <span class="s1">ViewCompat.postInvalidateOnAnimation(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s0">// END FB SCROLLVIEW CHANGE</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">super</span><span class="s1">.fling(correctedVelocityX)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">handlePostTouchScrolling(correctedVelocityX</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onSizeChanged(</span><span class="s2">int </span><span class="s1">w</span><span class="s2">, int </span><span class="s1">h</span><span class="s2">, int </span><span class="s1">oldw</span><span class="s2">, int </span><span class="s1">oldh) {</span>
    <span class="s2">super</span><span class="s1">.onSizeChanged(w</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">oldw</span><span class="s2">, </span><span class="s1">oldh)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mRemoveClippedSubviews) {</span>
      <span class="s1">updateClippingRect()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onAttachedToWindow() {</span>
    <span class="s2">super</span><span class="s1">.onAttachedToWindow()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mRemoveClippedSubviews) {</span>
      <span class="s1">updateClippingRect()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(mMaintainVisibleContentPositionHelper != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mMaintainVisibleContentPositionHelper.start()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onDetachedFromWindow() {</span>
    <span class="s2">super</span><span class="s1">.onDetachedFromWindow()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mMaintainVisibleContentPositionHelper != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mMaintainVisibleContentPositionHelper.stop()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">updateClippingRect() {</span>
    <span class="s2">if </span><span class="s1">(!mRemoveClippedSubviews) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">Assertions.assertNotNull(mClippingRect)</span><span class="s2">;</span>

    <span class="s1">ReactClippingViewGroupHelper.calculateClippingRect(</span><span class="s2">this, </span><span class="s1">mClippingRect)</span><span class="s2">;</span>
    <span class="s1">View contentView = getContentView()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(contentView </span><span class="s2">instanceof </span><span class="s1">ReactClippingViewGroup) {</span>
      <span class="s1">((ReactClippingViewGroup) contentView).updateClippingRect()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">getClippingRect(Rect outClippingRect) {</span>
    <span class="s1">outClippingRect.set(Assertions.assertNotNull(mClippingRect))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">getChildVisibleRect(View child</span><span class="s2">, </span><span class="s1">Rect r</span><span class="s2">, </span><span class="s1">android.graphics.Point offset) {</span>
    <span class="s2">return super</span><span class="s1">.getChildVisibleRect(child</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">offset)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private int </span><span class="s1">getSnapInterval() {</span>
    <span class="s2">if </span><span class="s1">(mSnapInterval != </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">mSnapInterval</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">getWidth()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private </span><span class="s1">View getContentView() {</span>
    <span class="s2">return </span><span class="s1">getChildAt(</span><span class="s5">0</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setEndFillColor(</span><span class="s2">int </span><span class="s1">color) {</span>
    <span class="s2">if </span><span class="s1">(color != mEndFillColor) {</span>
      <span class="s1">mEndFillColor = color</span><span class="s2">;</span>
      <span class="s1">mEndBackground = </span><span class="s2">new </span><span class="s1">ColorDrawable(mEndFillColor)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onOverScrolled(</span><span class="s2">int </span><span class="s1">scrollX</span><span class="s2">, int </span><span class="s1">scrollY</span><span class="s2">, boolean </span><span class="s1">clampedX</span><span class="s2">, boolean </span><span class="s1">clampedY) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.i(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s6">&quot;onOverScrolled[%d] scrollX %d scrollY %d clampedX %b clampedY %b&quot;</span><span class="s2">,</span>
          <span class="s1">getId()</span><span class="s2">,</span>
          <span class="s1">scrollX</span><span class="s2">,</span>
          <span class="s1">scrollY</span><span class="s2">,</span>
          <span class="s1">clampedX</span><span class="s2">,</span>
          <span class="s1">clampedY)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mScroller != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// FB SCROLLVIEW CHANGE</span>

      <span class="s0">// This is part two of the reimplementation of fling to fix the bounce-back bug. See #fling()</span>
      <span class="s0">// for</span>
      <span class="s0">// more information.</span>

      <span class="s2">if </span><span class="s1">(!mScroller.isFinished() &amp;&amp; mScroller.getCurrX() != mScroller.getFinalX()) {</span>
        <span class="s2">int </span><span class="s1">scrollRange = computeHorizontalScrollRange() - getWidth()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(scrollX &gt;= scrollRange) {</span>
          <span class="s1">mScroller.abortAnimation()</span><span class="s2">;</span>
          <span class="s1">scrollX = scrollRange</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">// END FB SCROLLVIEW CHANGE</span>
    <span class="s1">}</span>

    <span class="s2">super</span><span class="s1">.onOverScrolled(scrollX</span><span class="s2">, </span><span class="s1">scrollY</span><span class="s2">, </span><span class="s1">clampedX</span><span class="s2">, </span><span class="s1">clampedY)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onChildViewAdded(View parent</span><span class="s2">, </span><span class="s1">View child) {</span>
    <span class="s1">mContentView = child</span><span class="s2">;</span>
    <span class="s1">mContentView.addOnLayoutChangeListener(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onChildViewRemoved(View parent</span><span class="s2">, </span><span class="s1">View child) {</span>
    <span class="s1">mContentView.removeOnLayoutChangeListener(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">mContentView = </span><span class="s2">null;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">enableFpsListener() {</span>
    <span class="s2">if </span><span class="s1">(isScrollPerfLoggingEnabled()) {</span>
      <span class="s1">Assertions.assertNotNull(mFpsListener)</span><span class="s2">;</span>
      <span class="s1">Assertions.assertNotNull(mScrollPerfTag)</span><span class="s2">;</span>
      <span class="s1">mFpsListener.enable(mScrollPerfTag)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">disableFpsListener() {</span>
    <span class="s2">if </span><span class="s1">(isScrollPerfLoggingEnabled()) {</span>
      <span class="s1">Assertions.assertNotNull(mFpsListener)</span><span class="s2">;</span>
      <span class="s1">Assertions.assertNotNull(mScrollPerfTag)</span><span class="s2">;</span>
      <span class="s1">mFpsListener.disable(mScrollPerfTag)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private boolean </span><span class="s1">isScrollPerfLoggingEnabled() {</span>
    <span class="s2">return </span><span class="s1">mFpsListener != </span><span class="s2">null </span><span class="s1">&amp;&amp; mScrollPerfTag != </span><span class="s2">null </span><span class="s1">&amp;&amp; !mScrollPerfTag.isEmpty()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">draw(Canvas canvas) {</span>
    <span class="s2">if </span><span class="s1">(mEndFillColor != Color.TRANSPARENT) {</span>
      <span class="s2">final </span><span class="s1">View content = getContentView()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(mEndBackground != </span><span class="s2">null </span><span class="s1">&amp;&amp; content != </span><span class="s2">null </span><span class="s1">&amp;&amp; content.getRight() &lt; getWidth()) {</span>
        <span class="s1">mEndBackground.setBounds(content.getRight()</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">getWidth()</span><span class="s2">, </span><span class="s1">getHeight())</span><span class="s2">;</span>
        <span class="s1">mEndBackground.draw(canvas)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">super</span><span class="s1">.draw(canvas)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* This handles any sort of scrolling that may occur after a touch is finished. This may be</span>
   <span class="s3">* momentum scrolling (fling) or because you have pagingEnabled on the scroll view. Because we</span>
   <span class="s3">* don't get any events from Android about this lifecycle, we do all our detection by creating a</span>
   <span class="s3">* runnable that checks if we scrolled in the last frame and if so assumes we are still scrolling.</span>
   <span class="s3">*/</span>
  <span class="s2">private void </span><span class="s1">handlePostTouchScrolling(</span><span class="s2">int </span><span class="s1">velocityX</span><span class="s2">, int </span><span class="s1">velocityY) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.i(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s6">&quot;handlePostTouchScrolling[%d] velocityX %d velocityY %d&quot;</span><span class="s2">,</span>
          <span class="s1">getId()</span><span class="s2">,</span>
          <span class="s1">velocityX</span><span class="s2">,</span>
          <span class="s1">velocityY)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Check if we are already handling this which may occur if this is called by both the touch up</span>
    <span class="s0">// and a fling call</span>
    <span class="s2">if </span><span class="s1">(mPostTouchRunnable != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mSendMomentumEvents) {</span>
      <span class="s1">ReactScrollViewHelper.emitScrollMomentumBeginEvent(</span><span class="s2">this, </span><span class="s1">velocityX</span><span class="s2">, </span><span class="s1">velocityY)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">mActivelyScrolling = </span><span class="s2">false;</span>
    <span class="s1">mPostTouchRunnable =</span>
        <span class="s2">new </span><span class="s1">Runnable() {</span>

          <span class="s2">private boolean </span><span class="s1">mSnappingToPage = </span><span class="s2">false;</span>
          <span class="s2">private boolean </span><span class="s1">mRunning = </span><span class="s2">true;</span>
          <span class="s2">private int </span><span class="s1">mStableFrames = </span><span class="s5">0</span><span class="s2">;</span>

          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">run() {</span>
            <span class="s2">if </span><span class="s1">(mActivelyScrolling) {</span>
              <span class="s0">// We are still scrolling.</span>
              <span class="s1">mActivelyScrolling = </span><span class="s2">false;</span>
              <span class="s1">mStableFrames = </span><span class="s5">0</span><span class="s2">;</span>
              <span class="s1">mRunning = </span><span class="s2">true;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s0">// There has not been a scroll update since the last time this Runnable executed.</span>
              <span class="s1">ReactScrollViewHelper.updateFabricScrollState(ReactHorizontalScrollView.</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>

              <span class="s0">// We keep checking for updates until the ScrollView has &quot;stabilized&quot; and hasn't</span>
              <span class="s0">// scrolled for N consecutive frames. This number is arbitrary: big enough to catch</span>
              <span class="s0">// a number of race conditions, but small enough to not cause perf regressions, etc.</span>
              <span class="s0">// In anecdotal testing, it seemed like a decent number.</span>
              <span class="s0">// Without this check, sometimes this Runnable stops executing too soon - it will</span>
              <span class="s0">// fire before the first scroll event of an animated scroll/fling, and stop</span>
              <span class="s0">// immediately.</span>
              <span class="s1">mStableFrames++</span><span class="s2">;</span>
              <span class="s1">mRunning = (mStableFrames &lt; </span><span class="s5">3</span><span class="s1">)</span><span class="s2">;</span>

              <span class="s2">if </span><span class="s1">(mPagingEnabled &amp;&amp; !mSnappingToPage) {</span>
                <span class="s0">// Only if we have pagingEnabled and we have not snapped to the page do we</span>
                <span class="s0">// need to continue checking for the scroll.  And we cause that scroll by asking for</span>
                <span class="s0">// it</span>
                <span class="s1">mSnappingToPage = </span><span class="s2">true;</span>
                <span class="s1">flingAndSnap(</span><span class="s5">0</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">ViewCompat.postOnAnimationDelayed(</span>
                    <span class="s1">ReactHorizontalScrollView.</span><span class="s2">this, this, </span><span class="s1">ReactScrollViewHelper.MOMENTUM_DELAY)</span><span class="s2">;</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(mSendMomentumEvents) {</span>
                  <span class="s1">ReactScrollViewHelper.emitScrollMomentumEndEvent(ReactHorizontalScrollView.</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">disableFpsListener()</span><span class="s2">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s0">// We are still scrolling so we just post to check again a frame later</span>
            <span class="s2">if </span><span class="s1">(mRunning) {</span>
              <span class="s1">ViewCompat.postOnAnimationDelayed(</span>
                  <span class="s1">ReactHorizontalScrollView.</span><span class="s2">this, this, </span><span class="s1">ReactScrollViewHelper.MOMENTUM_DELAY)</span><span class="s2">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s1">mPostTouchRunnable = </span><span class="s2">null;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">ViewCompat.postOnAnimationDelayed(</span>
        <span class="s2">this, </span><span class="s1">mPostTouchRunnable</span><span class="s2">, </span><span class="s1">ReactScrollViewHelper.MOMENTUM_DELAY)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">cancelPostTouchScrolling() {</span>
    <span class="s2">if </span><span class="s1">(mPostTouchRunnable != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">removeCallbacks(mPostTouchRunnable)</span><span class="s2">;</span>
      <span class="s1">mPostTouchRunnable = </span><span class="s2">null;</span>
      <span class="s1">getFlingAnimator().cancel()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private int </span><span class="s1">predictFinalScrollPosition(</span><span class="s2">int </span><span class="s1">velocityX) {</span>
    <span class="s0">// predict where a fling would end up so we can scroll to the nearest snap offset</span>
    <span class="s2">final int </span><span class="s1">maximumOffset = Math.max(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">computeHorizontalScrollRange() - getWidth())</span><span class="s2">;</span>
    <span class="s0">// TODO(T106335409): Existing prediction still uses overscroller. Consider change this to use</span>
    <span class="s0">// fling animator instead.</span>
    <span class="s2">return </span><span class="s1">getFlingAnimator() == DEFAULT_FLING_ANIMATOR</span>
        <span class="s1">? ReactScrollViewHelper.predictFinalScrollPosition(</span><span class="s2">this, </span><span class="s1">velocityX</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">maximumOffset</span><span class="s2">, </span><span class="s5">0</span><span class="s1">).x</span>
        <span class="s1">: ReactScrollViewHelper.getNextFlingStartValue(</span>
                <span class="s2">this,</span>
                <span class="s1">getScrollX()</span><span class="s2">,</span>
                <span class="s1">getReactScrollViewScrollState().getFinalAnimatedPositionScroll().x</span><span class="s2">,</span>
                <span class="s1">velocityX)</span>
            <span class="s1">+ getFlingExtrapolatedDistance(velocityX)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* This will smooth scroll us to the nearest snap offset point. It currently just looks at where</span>
   <span class="s3">* the content is and slides to the nearest point. It is intended to be run after we are done</span>
   <span class="s3">* scrolling, and handling any momentum scrolling.</span>
   <span class="s3">*/</span>
  <span class="s2">private void </span><span class="s1">smoothScrollAndSnap(</span><span class="s2">int </span><span class="s1">velocity) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.i(TAG</span><span class="s2">, </span><span class="s6">&quot;smoothScrollAndSnap[%d] velocity %d&quot;</span><span class="s2">, </span><span class="s1">getId()</span><span class="s2">, </span><span class="s1">velocity)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">double </span><span class="s1">interval = (</span><span class="s2">double</span><span class="s1">) getSnapInterval()</span><span class="s2">;</span>
    <span class="s2">double </span><span class="s1">currentOffset =</span>
        <span class="s1">(</span><span class="s2">double</span><span class="s1">)</span>
            <span class="s1">(ReactScrollViewHelper.getNextFlingStartValue(</span>
                <span class="s2">this,</span>
                <span class="s1">getScrollX()</span><span class="s2">,</span>
                <span class="s1">getReactScrollViewScrollState().getFinalAnimatedPositionScroll().x</span><span class="s2">,</span>
                <span class="s1">velocity))</span><span class="s2">;</span>
    <span class="s2">double </span><span class="s1">targetOffset = (</span><span class="s2">double</span><span class="s1">) predictFinalScrollPosition(velocity)</span><span class="s2">;</span>

    <span class="s2">int </span><span class="s1">previousPage = (</span><span class="s2">int</span><span class="s1">) Math.floor(currentOffset / interval)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">nextPage = (</span><span class="s2">int</span><span class="s1">) Math.ceil(currentOffset / interval)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">currentPage = (</span><span class="s2">int</span><span class="s1">) Math.round(currentOffset / interval)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">targetPage = (</span><span class="s2">int</span><span class="s1">) Math.round(targetOffset / interval)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(velocity &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; nextPage == previousPage) {</span>
      <span class="s1">nextPage++</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(velocity &lt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; previousPage == nextPage) {</span>
      <span class="s1">previousPage--</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span>
    <span class="s0">// if scrolling towards next page</span>
    <span class="s1">velocity &gt; </span><span class="s5">0</span>
        <span class="s1">&amp;&amp;</span>
        <span class="s0">// and the middle of the page hasn't been crossed already</span>
        <span class="s1">currentPage &lt; nextPage</span>
        <span class="s1">&amp;&amp;</span>
        <span class="s0">// and it would have been crossed after flinging</span>
        <span class="s1">targetPage &gt; previousPage) {</span>
      <span class="s1">currentPage = nextPage</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>
    <span class="s0">// if scrolling towards previous page</span>
    <span class="s1">velocity &lt; </span><span class="s5">0</span>
        <span class="s1">&amp;&amp;</span>
        <span class="s0">// and the middle of the page hasn't been crossed already</span>
        <span class="s1">currentPage &gt; previousPage</span>
        <span class="s1">&amp;&amp;</span>
        <span class="s0">// and it would have been crossed after flinging</span>
        <span class="s1">targetPage &lt; nextPage) {</span>
      <span class="s1">currentPage = previousPage</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">targetOffset = currentPage * interval</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(targetOffset != currentOffset) {</span>
      <span class="s1">mActivelyScrolling = </span><span class="s2">true;</span>
      <span class="s1">reactSmoothScrollTo((</span><span class="s2">int</span><span class="s1">) targetOffset</span><span class="s2">, </span><span class="s1">getScrollY())</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">flingAndSnap(</span><span class="s2">int </span><span class="s1">velocityX) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.i(TAG</span><span class="s2">, </span><span class="s6">&quot;smoothScrollAndSnap[%d] velocityX %d&quot;</span><span class="s2">, </span><span class="s1">getId()</span><span class="s2">, </span><span class="s1">velocityX)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(getChildCount() &lt;= </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s0">// pagingEnabled only allows snapping one interval at a time</span>
    <span class="s2">if </span><span class="s1">(mSnapInterval == </span><span class="s5">0 </span><span class="s1">&amp;&amp; mSnapOffsets == </span><span class="s2">null </span><span class="s1">&amp;&amp; mSnapToAlignment == SNAP_ALIGNMENT_DISABLED) {</span>
      <span class="s1">smoothScrollAndSnap(velocityX)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">boolean </span><span class="s1">hasCustomizedFlingAnimator = getFlingAnimator() != DEFAULT_FLING_ANIMATOR</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">maximumOffset = Math.max(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">computeHorizontalScrollRange() - getWidth())</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">targetOffset = predictFinalScrollPosition(velocityX)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mDisableIntervalMomentum) {</span>
      <span class="s1">targetOffset = getScrollX()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">int </span><span class="s1">smallerOffset = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">largerOffset = maximumOffset</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">firstOffset = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">lastOffset = maximumOffset</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">width = getWidth() - ViewCompat.getPaddingStart(</span><span class="s2">this</span><span class="s1">) - ViewCompat.getPaddingEnd(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">layoutDirection = getReactScrollViewScrollState().getLayoutDirection()</span><span class="s2">;</span>

    <span class="s0">// offsets are from the right edge in RTL layouts</span>
    <span class="s2">if </span><span class="s1">(layoutDirection == LAYOUT_DIRECTION_RTL) {</span>
      <span class="s1">targetOffset = maximumOffset - targetOffset</span><span class="s2">;</span>
      <span class="s1">velocityX = -velocityX</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// get the nearest snap points to the target offset</span>
    <span class="s2">if </span><span class="s1">(mSnapOffsets != </span><span class="s2">null </span><span class="s1">&amp;&amp; !mSnapOffsets.isEmpty()) {</span>
      <span class="s1">firstOffset = mSnapOffsets.get(</span><span class="s5">0</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">lastOffset = mSnapOffsets.get(mSnapOffsets.size() - </span><span class="s5">1</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s2">; </span><span class="s1">i &lt; mSnapOffsets.size()</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">int </span><span class="s1">offset = mSnapOffsets.get(i)</span><span class="s2">;</span>

        <span class="s2">if </span><span class="s1">(offset &lt;= targetOffset) {</span>
          <span class="s2">if </span><span class="s1">(targetOffset - offset &lt; targetOffset - smallerOffset) {</span>
            <span class="s1">smallerOffset = offset</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(offset &gt;= targetOffset) {</span>
          <span class="s2">if </span><span class="s1">(offset - targetOffset &lt; largerOffset - targetOffset) {</span>
            <span class="s1">largerOffset = offset</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(mSnapToAlignment != SNAP_ALIGNMENT_DISABLED) {</span>
      <span class="s2">if </span><span class="s1">(mSnapInterval &gt; </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s2">double </span><span class="s1">ratio = (</span><span class="s2">double</span><span class="s1">) targetOffset / mSnapInterval</span><span class="s2">;</span>
        <span class="s1">smallerOffset =</span>
            <span class="s1">Math.max(</span>
                <span class="s1">getItemStartOffset(</span>
                    <span class="s1">mSnapToAlignment</span><span class="s2">,</span>
                    <span class="s1">(</span><span class="s2">int</span><span class="s1">) (Math.floor(ratio) * mSnapInterval)</span><span class="s2">,</span>
                    <span class="s1">mSnapInterval</span><span class="s2">,</span>
                    <span class="s1">width)</span><span class="s2">,</span>
                <span class="s5">0</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">largerOffset =</span>
            <span class="s1">Math.min(</span>
                <span class="s1">getItemStartOffset(</span>
                    <span class="s1">mSnapToAlignment</span><span class="s2">,</span>
                    <span class="s1">(</span><span class="s2">int</span><span class="s1">) (Math.ceil(ratio) * mSnapInterval)</span><span class="s2">,</span>
                    <span class="s1">mSnapInterval</span><span class="s2">,</span>
                    <span class="s1">width)</span><span class="s2">,</span>
                <span class="s1">maximumOffset)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">ViewGroup contentView = (ViewGroup) getContentView()</span><span class="s2">;</span>
        <span class="s2">int </span><span class="s1">smallerChildOffset = largerOffset</span><span class="s2">;</span>
        <span class="s2">int </span><span class="s1">largerChildOffset = smallerOffset</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s2">; </span><span class="s1">i &lt; contentView.getChildCount()</span><span class="s2">; </span><span class="s1">i++) {</span>
          <span class="s1">View item = contentView.getChildAt(i)</span><span class="s2">;</span>
          <span class="s2">int </span><span class="s1">itemStartOffset =</span>
              <span class="s1">getItemStartOffset(mSnapToAlignment</span><span class="s2">, </span><span class="s1">item.getLeft()</span><span class="s2">, </span><span class="s1">item.getWidth()</span><span class="s2">, </span><span class="s1">width)</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(itemStartOffset &lt;= targetOffset) {</span>
            <span class="s2">if </span><span class="s1">(targetOffset - itemStartOffset &lt; targetOffset - smallerOffset) {</span>
              <span class="s1">smallerOffset = itemStartOffset</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(itemStartOffset &gt;= targetOffset) {</span>
            <span class="s2">if </span><span class="s1">(itemStartOffset - targetOffset &lt; largerOffset - targetOffset) {</span>
              <span class="s1">largerOffset = itemStartOffset</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">smallerChildOffset = Math.min(smallerChildOffset</span><span class="s2">, </span><span class="s1">itemStartOffset)</span><span class="s2">;</span>
          <span class="s1">largerChildOffset = Math.max(largerChildOffset</span><span class="s2">, </span><span class="s1">itemStartOffset)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s0">// For Recycler ViewGroup, the maximumOffset can be much larger than the total heights of</span>
        <span class="s0">// items in the layout. In this case snapping is not possible beyond the currently rendered</span>
        <span class="s0">// children.</span>
        <span class="s1">smallerOffset = Math.max(smallerOffset</span><span class="s2">, </span><span class="s1">smallerChildOffset)</span><span class="s2">;</span>
        <span class="s1">largerOffset = Math.min(largerOffset</span><span class="s2">, </span><span class="s1">largerChildOffset)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">double </span><span class="s1">interval = getSnapInterval()</span><span class="s2">;</span>
      <span class="s2">double </span><span class="s1">ratio = (</span><span class="s2">double</span><span class="s1">) targetOffset / interval</span><span class="s2">;</span>
      <span class="s1">smallerOffset = (</span><span class="s2">int</span><span class="s1">) (Math.floor(ratio) * interval)</span><span class="s2">;</span>
      <span class="s1">largerOffset = Math.min((</span><span class="s2">int</span><span class="s1">) (Math.ceil(ratio) * interval)</span><span class="s2">, </span><span class="s1">maximumOffset)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Calculate the nearest offset</span>
    <span class="s2">int </span><span class="s1">nearestOffset =</span>
        <span class="s1">Math.abs(targetOffset - smallerOffset) &lt; Math.abs(largerOffset - targetOffset)</span>
            <span class="s1">? smallerOffset</span>
            <span class="s1">: largerOffset</span><span class="s2">;</span>

    <span class="s0">// if scrolling after the last snap offset and snapping to the</span>
    <span class="s0">// end of the list is disabled, then we allow free scrolling</span>
    <span class="s2">int </span><span class="s1">currentOffset = getScrollX()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(layoutDirection == LAYOUT_DIRECTION_RTL) {</span>
      <span class="s1">currentOffset = maximumOffset - currentOffset</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!mSnapToEnd &amp;&amp; targetOffset &gt;= lastOffset) {</span>
      <span class="s2">if </span><span class="s1">(currentOffset &gt;= lastOffset) {</span>
        <span class="s0">// free scrolling</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// snap to end</span>
        <span class="s1">targetOffset = lastOffset</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!mSnapToStart &amp;&amp; targetOffset &lt;= firstOffset) {</span>
      <span class="s2">if </span><span class="s1">(currentOffset &lt;= firstOffset) {</span>
        <span class="s0">// free scrolling</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// snap to beginning</span>
        <span class="s1">targetOffset = firstOffset</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(velocityX &gt; </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(!hasCustomizedFlingAnimator) {</span>
        <span class="s0">// The default animator requires boost on initial velocity as when snapping velocity can</span>
        <span class="s0">// feel sluggish for slow swipes</span>
        <span class="s1">velocityX += (</span><span class="s2">int</span><span class="s1">) ((largerOffset - targetOffset) * </span><span class="s5">10.0</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">targetOffset = largerOffset</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(velocityX &lt; </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(!hasCustomizedFlingAnimator) {</span>
        <span class="s0">// The default animator requires boost on initial velocity as when snapping velocity can</span>
        <span class="s0">// feel sluggish for slow swipes</span>
        <span class="s1">velocityX -= (</span><span class="s2">int</span><span class="s1">) ((targetOffset - smallerOffset) * </span><span class="s5">10.0</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">targetOffset = smallerOffset</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">targetOffset = nearestOffset</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Make sure the new offset isn't out of bounds</span>
    <span class="s1">targetOffset = Math.min(Math.max(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">targetOffset)</span><span class="s2">, </span><span class="s1">maximumOffset)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(layoutDirection == LAYOUT_DIRECTION_RTL) {</span>
      <span class="s1">targetOffset = maximumOffset - targetOffset</span><span class="s2">;</span>
      <span class="s1">velocityX = -velocityX</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(hasCustomizedFlingAnimator || mScroller == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">reactSmoothScrollTo(targetOffset</span><span class="s2">, </span><span class="s1">getScrollY())</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// smoothScrollTo will always scroll over 250ms which is often *waaay*</span>
      <span class="s0">// too short and will cause the scrolling to feel almost instant</span>
      <span class="s0">// try to manually interact with OverScroller instead</span>
      <span class="s0">// if velocity is 0 however, fling() won't work, so we want to use smoothScrollTo</span>
      <span class="s1">mActivelyScrolling = </span><span class="s2">true;</span>

      <span class="s1">mScroller.fling(</span>
          <span class="s1">getScrollX()</span><span class="s2">, </span><span class="s0">// startX</span>
          <span class="s1">getScrollY()</span><span class="s2">, </span><span class="s0">// startY</span>
          <span class="s0">// velocity = 0 doesn't work with fling() so we pretend there's a reasonable</span>
          <span class="s0">// initial velocity going on when a touch is released without any movement</span>
          <span class="s1">velocityX != </span><span class="s5">0 </span><span class="s1">? velocityX : targetOffset - getScrollX()</span><span class="s2">, </span><span class="s0">// velocityX</span>
          <span class="s5">0</span><span class="s2">, </span><span class="s0">// velocityY</span>
          <span class="s0">// setting both minX and maxX to the same value will guarantee that we scroll to it</span>
          <span class="s0">// but using the standard fling-style easing rather than smoothScrollTo's 250ms animation</span>
          <span class="s1">targetOffset</span><span class="s2">, </span><span class="s0">// minX</span>
          <span class="s1">targetOffset</span><span class="s2">, </span><span class="s0">// maxX</span>
          <span class="s5">0</span><span class="s2">, </span><span class="s0">// minY</span>
          <span class="s5">0</span><span class="s2">, </span><span class="s0">// maxY</span>
          <span class="s0">// we only want to allow overscrolling if the final offset is at the very edge of the view</span>
          <span class="s1">(targetOffset == </span><span class="s5">0 </span><span class="s1">|| targetOffset == maximumOffset) ? width / </span><span class="s5">2 </span><span class="s1">: </span><span class="s5">0</span><span class="s2">, </span><span class="s0">// overX</span>
          <span class="s5">0 </span><span class="s0">// overY</span>
          <span class="s1">)</span><span class="s2">;</span>

      <span class="s1">postInvalidateOnAnimation()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private int </span><span class="s1">getItemStartOffset(</span>
      <span class="s2">int </span><span class="s1">snapToAlignment</span><span class="s2">, int </span><span class="s1">itemStartPosition</span><span class="s2">, int </span><span class="s1">itemWidth</span><span class="s2">, int </span><span class="s1">viewPortWidth) {</span>
    <span class="s2">int </span><span class="s1">itemStartOffset</span><span class="s2">;</span>
    <span class="s2">switch </span><span class="s1">(snapToAlignment) {</span>
      <span class="s2">case </span><span class="s1">SNAP_ALIGNMENT_CENTER:</span>
        <span class="s1">itemStartOffset = itemStartPosition - (viewPortWidth - itemWidth) / </span><span class="s5">2</span><span class="s2">;</span>
        <span class="s2">break;</span>
      <span class="s2">case </span><span class="s1">SNAP_ALIGNMENT_START:</span>
        <span class="s1">itemStartOffset = itemStartPosition</span><span class="s2">;</span>
        <span class="s2">break;</span>
      <span class="s2">case </span><span class="s1">SNAP_ALIGNMENT_END:</span>
        <span class="s1">itemStartOffset = itemStartPosition - (viewPortWidth - itemWidth)</span><span class="s2">;</span>
        <span class="s2">break;</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">throw new </span><span class="s1">IllegalStateException(</span><span class="s6">&quot;Invalid SnapToAlignment value: &quot; </span><span class="s1">+ mSnapToAlignment)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">itemStartOffset</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">smoothScrollToNextPage(</span><span class="s2">int </span><span class="s1">direction) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.i(TAG</span><span class="s2">, </span><span class="s6">&quot;smoothScrollToNextPage[%d] direction %d&quot;</span><span class="s2">, </span><span class="s1">getId()</span><span class="s2">, </span><span class="s1">direction)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">int </span><span class="s1">width = getWidth()</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">currentX = getScrollX()</span><span class="s2">;</span>

    <span class="s2">int </span><span class="s1">page = currentX / width</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(currentX % width != </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s1">page++</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(direction == View.FOCUS_LEFT) {</span>
      <span class="s1">page = page - </span><span class="s5">1</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">page = page + </span><span class="s5">1</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(page &lt; </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s1">page = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">reactSmoothScrollTo(page * width</span><span class="s2">, </span><span class="s1">getScrollY())</span><span class="s2">;</span>
    <span class="s1">handlePostTouchScrolling(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setBackgroundColor(</span><span class="s2">int </span><span class="s1">color) {</span>
    <span class="s1">mReactBackgroundManager.setBackgroundColor(color)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderWidth(</span><span class="s2">int </span><span class="s1">position</span><span class="s2">, float </span><span class="s1">width) {</span>
    <span class="s1">mReactBackgroundManager.setBorderWidth(position</span><span class="s2">, </span><span class="s1">width)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderColor(</span><span class="s2">int </span><span class="s1">position</span><span class="s2">, float </span><span class="s1">color</span><span class="s2">, float </span><span class="s1">alpha) {</span>
    <span class="s1">mReactBackgroundManager.setBorderColor(position</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">alpha)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderRadius(</span><span class="s2">float </span><span class="s1">borderRadius) {</span>
    <span class="s1">mReactBackgroundManager.setBorderRadius(borderRadius)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderRadius(</span><span class="s2">float </span><span class="s1">borderRadius</span><span class="s2">, int </span><span class="s1">position) {</span>
    <span class="s1">mReactBackgroundManager.setBorderRadius(borderRadius</span><span class="s2">, </span><span class="s1">position)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderStyle(@Nullable String style) {</span>
    <span class="s1">mReactBackgroundManager.setBorderStyle(style)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Calls `smoothScrollTo` and updates state.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s7">&lt;p&gt;</span><span class="s3">`smoothScrollTo` changes `contentOffset` and we need to keep `contentOffset` in sync between</span>
   <span class="s3">* scroll view and state. Calling raw `smoothScrollTo` doesn't update state.</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">reactSmoothScrollTo(</span><span class="s2">int </span><span class="s1">x</span><span class="s2">, int </span><span class="s1">y) {</span>
    <span class="s1">ReactScrollViewHelper.smoothScrollTo(</span><span class="s2">this, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span>
    <span class="s1">setPendingContentOffsets(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Calls `super.scrollTo` and updates state.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s7">&lt;p&gt;</span><span class="s3">`super.scrollTo` changes `contentOffset` and we need to keep `contentOffset` in sync between</span>
   <span class="s3">* scroll view and state.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s7">&lt;p&gt;</span><span class="s3">Note that while we can override scrollTo, we *cannot* override `smoothScrollTo` because it</span>
   <span class="s3">* is final. See `reactSmoothScrollTo`.</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">scrollTo(</span><span class="s2">int </span><span class="s1">x</span><span class="s2">, int </span><span class="s1">y) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.i(TAG</span><span class="s2">, </span><span class="s6">&quot;scrollTo[%d] x %d y %d&quot;</span><span class="s2">, </span><span class="s1">getId()</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">super</span><span class="s1">.scrollTo(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span>
    <span class="s1">ReactScrollViewHelper.updateFabricScrollState(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">setPendingContentOffsets(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private boolean </span><span class="s1">isContentReady() {</span>
    <span class="s1">View child = getContentView()</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">child != </span><span class="s2">null </span><span class="s1">&amp;&amp; child.getWidth() != </span><span class="s5">0 </span><span class="s1">&amp;&amp; child.getHeight() != </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* If contentOffset is set before the View has been laid out, store the values and set them when</span>
   <span class="s3">* `onLayout` is called.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">x</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">y</span>
   <span class="s3">*/</span>
  <span class="s2">private void </span><span class="s1">setPendingContentOffsets(</span><span class="s2">int </span><span class="s1">x</span><span class="s2">, int </span><span class="s1">y) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.i(TAG</span><span class="s2">, </span><span class="s6">&quot;setPendingContentOffsets[%d] x %d y %d&quot;</span><span class="s2">, </span><span class="s1">getId()</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(isContentReady()) {</span>
      <span class="s1">pendingContentOffsetX = UNSET_CONTENT_OFFSET</span><span class="s2">;</span>
      <span class="s1">pendingContentOffsetY = UNSET_CONTENT_OFFSET</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">pendingContentOffsetX = x</span><span class="s2">;</span>
      <span class="s1">pendingContentOffsetY = y</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onLayoutChange(</span>
      <span class="s1">View v</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">left</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">top</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">right</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">bottom</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">oldLeft</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">oldTop</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">oldRight</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">oldBottom) {</span>
    <span class="s2">if </span><span class="s1">(mContentView == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mMaintainVisibleContentPositionHelper != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mMaintainVisibleContentPositionHelper.updateScrollPosition()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">FabricViewStateManager getFabricViewStateManager() {</span>
    <span class="s2">return </span><span class="s1">mFabricViewStateManager</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">ReactScrollViewScrollState getReactScrollViewScrollState() {</span>
    <span class="s2">return </span><span class="s1">mReactScrollViewScrollState</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">startFlingAnimator(</span><span class="s2">int </span><span class="s1">start</span><span class="s2">, int </span><span class="s1">end) {</span>
    <span class="s0">// Always cancel existing animator before starting the new one. `smoothScrollTo` contains some</span>
    <span class="s0">// logic that, if called multiple times in a short amount of time, will treat all calls as part</span>
    <span class="s0">// of the same animation and will not lengthen the duration of the animation. This means that,</span>
    <span class="s0">// for example, if the user is scrolling rapidly, multiple pages could be considered part of one</span>
    <span class="s0">// animation, causing some page animations to be animated very rapidly - looking like they're</span>
    <span class="s0">// not animated at all.</span>
    <span class="s1">DEFAULT_FLING_ANIMATOR.cancel()</span><span class="s2">;</span>

    <span class="s0">// Update the fling animator with new values</span>
    <span class="s1">DEFAULT_FLING_ANIMATOR</span>
        <span class="s1">.setDuration(ReactScrollViewHelper.getDefaultScrollAnimationDuration(getContext()))</span>
        <span class="s1">.setIntValues(start</span><span class="s2">, </span><span class="s1">end)</span><span class="s2">;</span>

    <span class="s0">// Start the animator</span>
    <span class="s1">DEFAULT_FLING_ANIMATOR.start()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">ValueAnimator getFlingAnimator() {</span>
    <span class="s2">return </span><span class="s1">DEFAULT_FLING_ANIMATOR</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public int </span><span class="s1">getFlingExtrapolatedDistance(</span><span class="s2">int </span><span class="s1">velocityX) {</span>
    <span class="s0">// The DEFAULT_FLING_ANIMATOR uses AccelerateDecelerateInterpolator, which is not depending on</span>
    <span class="s0">// the init velocity. We use the overscroller to decide the fling distance.</span>
    <span class="s2">return </span><span class="s1">ReactScrollViewHelper.predictFinalScrollPosition(</span>
            <span class="s2">this, </span><span class="s1">velocityX</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">Math.max(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">computeHorizontalScrollRange() - getWidth())</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">.x</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setPointerEvents(PointerEvents pointerEvents) {</span>
    <span class="s1">mPointerEvents = pointerEvents</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">PointerEvents getPointerEvents() {</span>
    <span class="s2">return </span><span class="s1">mPointerEvents</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setScrollEventThrottle(</span><span class="s2">int </span><span class="s1">scrollEventThrottle) {</span>
    <span class="s1">mScrollEventThrottle = scrollEventThrottle</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public int </span><span class="s1">getScrollEventThrottle() {</span>
    <span class="s2">return </span><span class="s1">mScrollEventThrottle</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setLastScrollDispatchTime(</span><span class="s2">long </span><span class="s1">lastScrollDispatchTime) {</span>
    <span class="s1">mLastScrollDispatchTime = lastScrollDispatchTime</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public long </span><span class="s1">getLastScrollDispatchTime() {</span>
    <span class="s2">return </span><span class="s1">mLastScrollDispatchTime</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
<html>
<head>
<title>RNSScreenStack.mm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bbb529;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RNSScreenStack.mm</font>
</center></td></tr></table>
<pre><span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTMountingTransactionObserving.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTSurfaceTouchHandler.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/UIView+React.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;react/renderer/components/rnscreens/ComponentDescriptors.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;react/renderer/components/rnscreens/EventEmitters.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;react/renderer/components/rnscreens/Props.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;react/renderer/components/rnscreens/RCTComponentViewHelpers.h&gt;</span>

<span class="s0">#import </span><span class="s2">&lt;React/RCTFabricComponentsPlugins.h&gt;</span>

<span class="s0">#else</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTBridge.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTRootContentView.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTShadowView.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTTouchHandler.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTUIManager.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTUIManagerUtils.h&gt;</span>
<span class="s0">#endif </span><span class="s3">// RCT_NEW_ARCH_ENABLED</span>

<span class="s0">#import </span><span class="s2">&quot;RNSScreen.h&quot;</span>
<span class="s0">#import </span><span class="s2">&quot;RNSScreenStack.h&quot;</span>
<span class="s0">#import </span><span class="s2">&quot;RNSScreenStackAnimator.h&quot;</span>
<span class="s0">#import </span><span class="s2">&quot;RNSScreenStackHeaderConfig.h&quot;</span>
<span class="s0">#import </span><span class="s2">&quot;RNSScreenWindowTraits.h&quot;</span>

<span class="s4">@interface </span><span class="s1">RNSScreenStackView () &lt;</span>
    <span class="s1">UINavigationControllerDelegate</span><span class="s4">,</span>
    <span class="s1">UIAdaptivePresentationControllerDelegate</span><span class="s4">,</span>
    <span class="s1">UIGestureRecognizerDelegate</span><span class="s4">,</span>
    <span class="s1">UIViewControllerTransitioningDelegate</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
    <span class="s4">,</span>
    <span class="s1">RCTMountingTransactionObserving</span>
<span class="s0">#endif</span>
    <span class="s1">&gt;</span>

<span class="s4">@property </span><span class="s1">(nonatomic) NSMutableArray&lt;UIViewController *&gt; *presentedModals</span><span class="s4">;</span>
<span class="s4">@property </span><span class="s1">(nonatomic) BOOL updatingModals</span><span class="s4">;</span>
<span class="s4">@property </span><span class="s1">(nonatomic) BOOL scheduleModalsUpdate</span><span class="s4">;</span>

<span class="s4">@end</span>

<span class="s4">@implementation </span><span class="s1">RNScreensNavigationController</span>

<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
<span class="s1">- (UIViewController *)childViewControllerForStatusBarStyle</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">[self topViewController]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (UIStatusBarAnimation)preferredStatusBarUpdateAnimation</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">[self topViewController].preferredStatusBarUpdateAnimation</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (UIViewController *)childViewControllerForStatusBarHidden</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">[self topViewController]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (UIInterfaceOrientationMask)supportedInterfaceOrientations</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">[self topViewController].supportedInterfaceOrientations</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (UIViewController *)childViewControllerForHomeIndicatorAutoHidden</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">[self topViewController]</span><span class="s4">;</span>
<span class="s1">}</span>
<span class="s0">#endif</span>

<span class="s4">@end</span>

<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
<span class="s4">@interface </span><span class="s1">RNSScreenEdgeGestureRecognizer : UIScreenEdgePanGestureRecognizer</span>
<span class="s4">@end</span>

<span class="s4">@implementation </span><span class="s1">RNSScreenEdgeGestureRecognizer</span>
<span class="s4">@end</span>

<span class="s4">@interface </span><span class="s1">RNSPanGestureRecognizer : UIPanGestureRecognizer</span>
<span class="s4">@end</span>

<span class="s4">@implementation </span><span class="s1">RNSPanGestureRecognizer</span>
<span class="s4">@end</span>
<span class="s0">#endif</span>

<span class="s4">@implementation </span><span class="s1">RNSScreenStackView {</span>
  <span class="s1">UINavigationController *_controller</span><span class="s4">;</span>
  <span class="s1">NSMutableArray&lt;RNSScreenView *&gt; *_reactSubviews</span><span class="s4">;</span>
  <span class="s1">BOOL _invalidated</span><span class="s4">;</span>
  <span class="s1">BOOL _isFullWidthSwiping</span><span class="s4">;</span>
  <span class="s1">UIPercentDrivenInteractiveTransition *_interactionController</span><span class="s4">;</span>
  <span class="s1">BOOL _hasLayout</span><span class="s4">;</span>
  <span class="s4">__weak </span><span class="s1">RNSScreenStackManager *_manager</span><span class="s4">;</span>
  <span class="s1">BOOL _updateScheduled</span><span class="s4">;</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s1">UIView *_snapshot</span><span class="s4">;</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s1">- (instancetype)initWithFrame:(CGRect)frame</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(self = [super initWithFrame:frame]) {</span>
    <span class="s4">static const auto </span><span class="s1">defaultProps = std::make_shared&lt;</span><span class="s4">const </span><span class="s1">facebook::react::RNSScreenStackProps&gt;()</span><span class="s4">;</span>
    <span class="s1">_props = defaultProps</span><span class="s4">;</span>
    <span class="s1">[self initCommonProps]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">self</span><span class="s4">;</span>
<span class="s1">}</span>
<span class="s0">#endif </span><span class="s3">// RCT_NEW_ARCH_ENABLED</span>

<span class="s1">- (instancetype)initWithManager:(RNSScreenStackManager *)manager</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(self = [super init]) {</span>
    <span class="s1">_hasLayout = NO</span><span class="s4">;</span>
    <span class="s1">_invalidated = NO</span><span class="s4">;</span>
    <span class="s1">_manager = manager</span><span class="s4">;</span>
    <span class="s1">[self initCommonProps]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">self</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)initCommonProps</span>
<span class="s1">{</span>
  <span class="s1">_reactSubviews = [NSMutableArray </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s1">_presentedModals = [NSMutableArray </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s1">_controller = [RNScreensNavigationController </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s1">_controller.delegate = self</span><span class="s4">;</span>
<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
  <span class="s1">[self setupGestureHandlers]</span><span class="s4">;</span>
<span class="s0">#endif</span>
  <span class="s3">// we have to initialize viewControllers with a non empty array for</span>
  <span class="s3">// largeTitle header to render in the opened state. If it is empty</span>
  <span class="s3">// the header will render in collapsed state which is perhaps a bug</span>
  <span class="s3">// in UIKit but ¯\_(ツ)_/¯</span>
  <span class="s1">[_controller setViewControllers:</span><span class="s4">@</span><span class="s1">[ [UIViewController </span><span class="s4">new</span><span class="s1">] ]]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">#pragma </span><span class="s1">mark - helper methods</span>

<span class="s1">- (BOOL)shouldCancelDismissFromView:(RNSScreenView *)fromView toView:(RNSScreenView *)toView</span>
<span class="s1">{</span>
  <span class="s4">int </span><span class="s1">fromIndex = (</span><span class="s4">int</span><span class="s1">)[_reactSubviews indexOfObject:fromView]</span><span class="s4">;</span>
  <span class="s4">int </span><span class="s1">toIndex = (</span><span class="s4">int</span><span class="s1">)[_reactSubviews indexOfObject:toView]</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(</span><span class="s4">int </span><span class="s1">i = fromIndex</span><span class="s4">; </span><span class="s1">i &gt; toIndex</span><span class="s4">; </span><span class="s1">i--) {</span>
    <span class="s4">if </span><span class="s1">(_reactSubviews[i].preventNativeDismiss) {</span>
      <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">#pragma </span><span class="s1">mark - Common</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)emitOnFinishTransitioningEvent</span>
<span class="s1">{</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s4">if </span><span class="s1">(_eventEmitter != </span><span class="s4">nullptr</span><span class="s1">) {</span>
    <span class="s1">std::dynamic_pointer_cast&lt;</span><span class="s4">const </span><span class="s1">facebook::react::RNSScreenStackEventEmitter&gt;(_eventEmitter)</span>
        <span class="s1">-&gt;onFinishTransitioning(facebook::react::RNSScreenStackEventEmitter::OnFinishTransitioning{})</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s0">#else</span>
  <span class="s4">if </span><span class="s1">(self.onFinishTransitioning) {</span>
    <span class="s1">self.onFinishTransitioning(nil)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)navigationController:(UINavigationController *)navigationController</span>
      <span class="s1">willShowViewController:(UIViewController *)viewController</span>
                    <span class="s1">animated:(BOOL)animated</span>
<span class="s1">{</span>
  <span class="s1">UIView *view = viewController.view</span><span class="s4">;</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s4">if </span><span class="s1">(![view isKindOfClass:[RNSScreenView </span><span class="s4">class</span><span class="s1">]]) {</span>
    <span class="s3">// if the current view is a snapshot, config was already removed so we don't trigger the method</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
<span class="s0">#endif</span>
  <span class="s1">RNSScreenStackHeaderConfig *config = nil</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(UIView *subview in view.reactSubviews) {</span>
    <span class="s4">if </span><span class="s1">([subview isKindOfClass:[RNSScreenStackHeaderConfig </span><span class="s4">class</span><span class="s1">]]) {</span>
      <span class="s1">config = (RNSScreenStackHeaderConfig *)subview</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">[RNSScreenStackHeaderConfig willShowViewController:viewController animated:animated withConfig:config]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)presentationControllerDidDismiss:(UIPresentationController *)presentationController</span>
<span class="s1">{</span>
  <span class="s3">// We don't directly set presentation delegate but instead rely on the ScreenView's delegate to</span>
  <span class="s3">// forward certain calls to the container (Stack).</span>
  <span class="s4">if </span><span class="s1">([presentationController.presentedViewController isKindOfClass:[RNSScreen </span><span class="s4">class</span><span class="s1">]]) {</span>
    <span class="s3">// we trigger the update of status bar's appearance here because there is no other lifecycle method</span>
    <span class="s3">// that can handle it when dismissing a modal, the same for orientation</span>
    <span class="s1">[RNSScreenWindowTraits updateWindowTraits]</span><span class="s4">;</span>
    <span class="s1">[_presentedModals removeObject:presentationController.presentedViewController]</span><span class="s4">;</span>

    <span class="s1">_updatingModals = NO</span><span class="s4">;</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
    <span class="s1">[self emitOnFinishTransitioningEvent]</span><span class="s4">;</span>
<span class="s0">#else</span>
    <span class="s3">// we double check if there are no new controllers pending to be presented since someone could</span>
    <span class="s3">// have tried to push another one during the transition.</span>
    <span class="s3">// We don't do it on Fabric since update of container will be triggered from &quot;unmount&quot; method afterwards</span>
    <span class="s1">[self updateContainer]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(self.onFinishTransitioning) {</span>
      <span class="s3">// instead of directly triggering onFinishTransitioning this time we enqueue the event on the</span>
      <span class="s3">// main queue. We do that because onDismiss event is also enqueued and we want for the transition</span>
      <span class="s3">// finish event to arrive later than onDismiss (see RNSScreen#notifyDismiss)</span>
      <span class="s1">dispatch_async(dispatch_get_main_queue()</span><span class="s4">, </span><span class="s1">^{</span>
        <span class="s1">[self emitOnFinishTransitioningEvent]</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>
    <span class="s1">}</span>
<span class="s0">#endif</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (NSArray&lt;UIView *&gt; *)reactSubviews</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">_reactSubviews</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)didMoveToWindow</span>
<span class="s1">{</span>
  <span class="s1">[super didMoveToWindow]</span><span class="s4">;</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s3">// for handling nested stacks</span>
  <span class="s1">[self maybeAddToParentAndUpdateContainer]</span><span class="s4">;</span>
<span class="s0">#else</span>
  <span class="s4">if </span><span class="s1">(!_invalidated) {</span>
    <span class="s3">// We check whether the view has been invalidated before running side-effects in didMoveToWindow</span>
    <span class="s3">// This is needed because when LayoutAnimations are used it is possible for view to be re-attached</span>
    <span class="s3">// to a window despite the fact it has been removed from the React Native view hierarchy.</span>
    <span class="s1">[self maybeAddToParentAndUpdateContainer]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)maybeAddToParentAndUpdateContainer</span>
<span class="s1">{</span>
  <span class="s1">BOOL wasScreenMounted = _controller.parentViewController != nil</span><span class="s4">;</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s1">BOOL isScreenReadyForShowing = self.window</span><span class="s4">;</span>
<span class="s0">#else</span>
  <span class="s1">BOOL isScreenReadyForShowing = self.window &amp;&amp; _hasLayout</span><span class="s4">;</span>
<span class="s0">#endif</span>
  <span class="s4">if </span><span class="s1">(!isScreenReadyForShowing &amp;&amp; !wasScreenMounted) {</span>
    <span class="s3">// We wait with adding to parent controller until the stack is mounted and has its initial</span>
    <span class="s3">// layout done.</span>
    <span class="s3">// If we add it before layout, some of the items (specifically items from the navigation bar),</span>
    <span class="s3">// won't be able to position properly. Also the position and size of such items, even if it</span>
    <span class="s3">// happens to change, won't be properly updated (this is perhaps some internal issue of UIKit).</span>
    <span class="s3">// If we add it when window is not attached, some of the view transitions will be bloced (i.e.</span>
    <span class="s3">// modal transitions) and the internal view controler's state will get out of sync with what's</span>
    <span class="s3">// on screen without us knowing.</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
  <span class="s1">[self updateContainer]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!wasScreenMounted) {</span>
    <span class="s3">// when stack hasn't been added to parent VC yet we do two things:</span>
    <span class="s3">// 1) we run updateContainer (the one above) – we do this because we want push view controllers to</span>
    <span class="s3">// be installed before the VC is mounted. If we do that after it is added to parent the push</span>
    <span class="s3">// updates operations are going to be blocked by UIKit.</span>
    <span class="s3">// 2) we add navigation VS to parent – this is needed for the VC lifecycle events to be dispatched</span>
    <span class="s3">// properly</span>
    <span class="s3">// 3) we again call updateContainer – this time we do this to open modal controllers. Modals</span>
    <span class="s3">// won't open in (1) because they require navigator to be added to parent. We handle that case</span>
    <span class="s3">// gracefully in setModalViewControllers and can retry opening at any point.</span>
    <span class="s1">[self reactAddControllerToClosestParent:_controller]</span><span class="s4">;</span>
    <span class="s1">[self updateContainer]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)reactAddControllerToClosestParent:(UIViewController *)controller</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!controller.parentViewController) {</span>
    <span class="s1">UIView *parentView = (UIView *)self.reactSuperview</span><span class="s4">;</span>
    <span class="s4">while </span><span class="s1">(parentView) {</span>
      <span class="s4">if </span><span class="s1">(parentView.reactViewController) {</span>
        <span class="s1">[parentView.reactViewController addChildViewController:controller]</span><span class="s4">;</span>
        <span class="s1">[self addSubview:controller.view]</span><span class="s4">;</span>
<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
        <span class="s1">_controller.interactivePopGestureRecognizer.delegate = self</span><span class="s4">;</span>
<span class="s0">#endif</span>
        <span class="s1">[controller didMoveToParentViewController:parentView.reactViewController]</span><span class="s4">;</span>
        <span class="s3">// On iOS pre 12 we observed that `willShowViewController` delegate method does not always</span>
        <span class="s3">// get triggered when the navigation controller is instantiated. As the only thing we do in</span>
        <span class="s3">// that delegate method is ask nav header to update to the current state it does not hurt to</span>
        <span class="s3">// trigger that logic from here too such that we can be sure the header is properly updated.</span>
        <span class="s1">[self navigationController:_controller willShowViewController:_controller.topViewController animated:NO]</span><span class="s4">;</span>
        <span class="s4">break;</span>
      <span class="s1">}</span>
      <span class="s1">parentView = (UIView *)parentView.reactSuperview</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setModalViewControllers:(NSArray&lt;UIViewController *&gt; *)controllers</span>
<span class="s1">{</span>
  <span class="s3">// prevent re-entry</span>
  <span class="s4">if </span><span class="s1">(_updatingModals) {</span>
    <span class="s1">_scheduleModalsUpdate = YES</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s3">// when there is no change we return immediately. This check is important because sometime we may</span>
  <span class="s3">// accidently trigger modal dismiss if we don't verify to run the below code only when an actual</span>
  <span class="s3">// change in the list of presented modal was made.</span>
  <span class="s4">if </span><span class="s1">([_presentedModals isEqualToArray:controllers]) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s3">// if view controller is not yet attached to window we skip updates now and run them when view</span>
  <span class="s3">// is attached</span>
  <span class="s4">if </span><span class="s1">(self.window == nil &amp;&amp; _presentedModals.lastObject.view.window == nil) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">_updatingModals = YES</span><span class="s4">;</span>

  <span class="s1">NSMutableArray&lt;UIViewController *&gt; *newControllers = [NSMutableArray arrayWithArray:controllers]</span><span class="s4">;</span>
  <span class="s1">[newControllers removeObjectsInArray:_presentedModals]</span><span class="s4">;</span>

  <span class="s3">// find bottom-most controller that should stay on the stack for the duration of transition</span>
  <span class="s1">NSUInteger changeRootIndex = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s1">UIViewController *changeRootController = _controller</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(NSUInteger i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; MIN(_presentedModals.count</span><span class="s4">, </span><span class="s1">controllers.count)</span><span class="s4">; </span><span class="s1">i++) {</span>
    <span class="s4">if </span><span class="s1">(_presentedModals[i] == controllers[i]) {</span>
      <span class="s1">changeRootController = controllers[i]</span><span class="s4">;</span>
      <span class="s1">changeRootIndex = i + </span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s4">break;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">// we verify that controllers added on top of changeRootIndex are all new. Unfortunately modal</span>
  <span class="s3">// VCs cannot be reshuffled (there are some visual glitches when we try to dismiss then show as</span>
  <span class="s3">// even non-animated dismissal has delay and updates the screen several times)</span>
  <span class="s4">for </span><span class="s1">(NSUInteger i = changeRootIndex</span><span class="s4">; </span><span class="s1">i &lt; controllers.count</span><span class="s4">; </span><span class="s1">i++) {</span>
    <span class="s4">if </span><span class="s1">([_presentedModals containsObject:controllers[i]]) {</span>
      <span class="s1">RCTAssert(</span><span class="s4">false, @</span><span class="s2">&quot;Modally presented controllers are being reshuffled, this is not allowed&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">__weak </span><span class="s1">RNSScreenStackView *weakSelf = self</span><span class="s4">;</span>

  <span class="s4">void </span><span class="s1">(^afterTransitions)(</span><span class="s4">void</span><span class="s1">) = ^{</span>
    <span class="s1">[weakSelf emitOnFinishTransitioningEvent]</span><span class="s4">;</span>
    <span class="s1">weakSelf.updatingModals = NO</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(weakSelf.scheduleModalsUpdate) {</span>
      <span class="s3">// if modals update was requested during setModalViewControllers we set scheduleModalsUpdate</span>
      <span class="s3">// flag in order to perform updates at a later point. Here we are done with all modals</span>
      <span class="s3">// transitions and check this flag again. If it was set, we reset the flag and execute updates.</span>
      <span class="s1">weakSelf.scheduleModalsUpdate = NO</span><span class="s4">;</span>
      <span class="s1">[weakSelf updateContainer]</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s3">// we trigger the update of orientation here because, when dismissing the modal from JS,</span>
    <span class="s3">// neither `viewWillAppear` nor `presentationControllerDidDismiss` are called, same for status bar.</span>
    <span class="s1">[RNSScreenWindowTraits updateWindowTraits]</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">void </span><span class="s1">(^finish)(</span><span class="s4">void</span><span class="s1">) = ^{</span>
    <span class="s1">NSUInteger oldCount = weakSelf.presentedModals.count</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(changeRootIndex &lt; oldCount) {</span>
      <span class="s1">[weakSelf.presentedModals removeObjectsInRange:NSMakeRange(changeRootIndex</span><span class="s4">, </span><span class="s1">oldCount - changeRootIndex)]</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s1">BOOL isAttached =</span>
        <span class="s1">changeRootController.parentViewController != nil || changeRootController.presentingViewController != nil</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(!isAttached || changeRootIndex &gt;= controllers.count) {</span>
      <span class="s3">// if change controller view is not attached, presenting modals will silently fail on iOS.</span>
      <span class="s3">// In such a case we trigger controllers update from didMoveToWindow.</span>
      <span class="s3">// We also don't run any present transitions if changeRootIndex is greater or equal to the size</span>
      <span class="s3">// of new controllers array. This means that no new controllers should be presented.</span>
      <span class="s1">afterTransitions()</span><span class="s4">;</span>
      <span class="s4">return;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s1">UIViewController *previous = changeRootController</span><span class="s4">;</span>
      <span class="s4">for </span><span class="s1">(NSUInteger i = changeRootIndex</span><span class="s4">; </span><span class="s1">i &lt; controllers.count</span><span class="s4">; </span><span class="s1">i++) {</span>
        <span class="s1">UIViewController *next = controllers[i]</span><span class="s4">;</span>
        <span class="s1">BOOL lastModal = (i == controllers.count - </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

<span class="s0">#if </span><span class="s1">defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; defined(__IPHONE_13_0) &amp;&amp; \ 
    __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_13_0</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">13.0</span><span class="s4">, </span><span class="s1">tvOS </span><span class="s5">13.0</span><span class="s4">, </span><span class="s1">*)) {</span>
          <span class="s3">// Inherit UI style from its parent - solves an issue with incorrect style being applied to some UIKit views</span>
          <span class="s3">// like date picker or segmented control.</span>
          <span class="s1">next.overrideUserInterfaceStyle = self-&gt;_controller.overrideUserInterfaceStyle</span><span class="s4">;</span>
        <span class="s1">}</span>
<span class="s0">#endif</span>

        <span class="s1">BOOL shouldAnimate = lastModal &amp;&amp; [next isKindOfClass:[RNSScreen </span><span class="s4">class</span><span class="s1">]] &amp;&amp;</span>
            <span class="s1">((RNSScreen *)next).screenView.stackAnimation != RNSScreenStackAnimationNone</span><span class="s4">;</span>

        <span class="s3">// if you want to present another modal quick enough after dismissing the previous one,</span>
        <span class="s3">// it will result in wrong changeRootController, see repro in</span>
        <span class="s3">// https://github.com/software-mansion/react-native-screens/issues/1299 We call `updateContainer` again in</span>
        <span class="s3">// `presentationControllerDidDismiss` to cover this case and present new controller</span>
        <span class="s4">if </span><span class="s1">(previous.beingDismissed) {</span>
          <span class="s4">return;</span>
        <span class="s1">}</span>

        <span class="s1">[previous presentViewController:next</span>
                               <span class="s1">animated:shouldAnimate</span>
                             <span class="s1">completion:^{</span>
                               <span class="s1">[weakSelf.presentedModals addObject:next]</span><span class="s4">;</span>
                               <span class="s4">if </span><span class="s1">(lastModal) {</span>
                                 <span class="s1">afterTransitions()</span><span class="s4">;</span>
                               <span class="s1">}</span><span class="s4">;</span>
                             <span class="s1">}]</span><span class="s4">;</span>
        <span class="s1">previous = next</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(changeRootController.presentedViewController != nil &amp;&amp;</span>
      <span class="s1">[_presentedModals containsObject:changeRootController.presentedViewController]) {</span>
    <span class="s1">BOOL shouldAnimate = changeRootIndex == controllers.count &amp;&amp;</span>
        <span class="s1">[changeRootController.presentedViewController isKindOfClass:[RNSScreen </span><span class="s4">class</span><span class="s1">]] &amp;&amp;</span>
        <span class="s1">((RNSScreen *)changeRootController.presentedViewController).screenView.stackAnimation !=</span>
            <span class="s1">RNSScreenStackAnimationNone</span><span class="s4">;</span>
    <span class="s1">[changeRootController dismissViewControllerAnimated:shouldAnimate completion:finish]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">finish()</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setPushViewControllers:(NSArray&lt;UIViewController *&gt; *)controllers</span>
<span class="s1">{</span>
  <span class="s3">// when there is no change we return immediately</span>
  <span class="s4">if </span><span class="s1">([_controller.viewControllers isEqualToArray:controllers]) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s3">// if view controller is not yet attached to window we skip updates now and run them when view</span>
  <span class="s3">// is attached</span>
  <span class="s4">if </span><span class="s1">(self.window == nil) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
  <span class="s3">// when transition is ongoing, any updates made to the controller will not be reflected until the</span>
  <span class="s3">// transition is complete. In particular, when we push/pop view controllers we expect viewControllers</span>
  <span class="s3">// property to be updated immediately. Based on that property we then calculate future updates.</span>
  <span class="s3">// When the transition is ongoing the property won't be updated immediatly. We therefore avoid</span>
  <span class="s3">// making any updated when transition is ongoing and schedule updates for when the transition</span>
  <span class="s3">// is complete.</span>
  <span class="s4">if </span><span class="s1">(_controller.transitionCoordinator != nil) {</span>
    <span class="s4">if </span><span class="s1">(!_updateScheduled) {</span>
      <span class="s1">_updateScheduled = YES</span><span class="s4">;</span>
      <span class="s4">__weak </span><span class="s1">RNSScreenStackView *weakSelf = self</span><span class="s4">;</span>
      <span class="s1">[_controller.transitionCoordinator</span>
          <span class="s1">animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; </span><span class="s4">_Nonnull </span><span class="s1">context) {</span>
            <span class="s3">// do nothing here, we only want to be notified when transition is complete</span>
          <span class="s1">}</span>
          <span class="s1">completion:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; </span><span class="s4">_Nonnull </span><span class="s1">context) {</span>
            <span class="s1">self-&gt;_updateScheduled = NO</span><span class="s4">;</span>
            <span class="s1">[weakSelf updateContainer]</span><span class="s4">;</span>
          <span class="s1">}]</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">UIViewController *top = controllers.lastObject</span><span class="s4">;</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s1">UIViewController *previousTop = _controller.topViewController</span><span class="s4">;</span>
<span class="s0">#else</span>
  <span class="s1">UIViewController *previousTop = _controller.viewControllers.lastObject</span><span class="s4">;</span>
<span class="s0">#endif</span>

  <span class="s3">// At the start we set viewControllers to contain a single UIViewController</span>
  <span class="s3">// instance. This is a workaround for header height adjustment bug (see comment</span>
  <span class="s3">// in the init function). Here, we need to detect if the initial empty</span>
  <span class="s3">// controller is still there</span>
  <span class="s1">BOOL firstTimePush = ![previousTop isKindOfClass:[RNSScreen </span><span class="s4">class</span><span class="s1">]]</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(firstTimePush) {</span>
    <span class="s3">// nothing pushed yet</span>
    <span class="s1">[_controller setViewControllers:controllers animated:NO]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(top != previousTop) {</span>
    <span class="s4">if </span><span class="s1">(![controllers containsObject:previousTop]) {</span>
      <span class="s3">// if the previous top screen does not exist anymore and the new top was not on the stack before, probably replace</span>
      <span class="s3">// was called, so we check the animation</span>
      <span class="s4">if </span><span class="s1">(![_controller.viewControllers containsObject:top] &amp;&amp;</span>
          <span class="s1">((RNSScreenView *)top.view).replaceAnimation == RNSScreenReplaceAnimationPush) {</span>
        <span class="s3">// setting new controllers with animation does `push` animation by default</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
        <span class="s4">auto </span><span class="s1">screenController = (RNSScreen *)top</span><span class="s4">;</span>
        <span class="s1">[screenController resetViewToScreen]</span><span class="s4">;</span>
<span class="s0">#endif</span>
        <span class="s1">[_controller setViewControllers:controllers animated:YES]</span><span class="s4">;</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s3">// last top controller is no longer on stack</span>
        <span class="s3">// in this case we set the controllers stack to the new list with</span>
        <span class="s3">// added the last top element to it and perform (animated) pop</span>
        <span class="s1">NSMutableArray *newControllers = [NSMutableArray arrayWithArray:controllers]</span><span class="s4">;</span>
        <span class="s1">[newControllers addObject:previousTop]</span><span class="s4">;</span>
        <span class="s1">[_controller setViewControllers:newControllers animated:NO]</span><span class="s4">;</span>
        <span class="s1">[_controller popViewControllerAnimated:YES]</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(![_controller.viewControllers containsObject:top]) {</span>
      <span class="s3">// new top controller is not on the stack</span>
      <span class="s3">// in such case we update the stack except from the last element with</span>
      <span class="s3">// no animation and do animated push of the last item</span>
      <span class="s1">NSMutableArray *newControllers = [NSMutableArray arrayWithArray:controllers]</span><span class="s4">;</span>
      <span class="s1">[newControllers removeLastObject]</span><span class="s4">;</span>
      <span class="s1">[_controller setViewControllers:newControllers animated:NO]</span><span class="s4">;</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
      <span class="s4">auto </span><span class="s1">screenController = (RNSScreen *)top</span><span class="s4">;</span>
      <span class="s1">[screenController resetViewToScreen]</span><span class="s4">;</span>
<span class="s0">#endif</span>
      <span class="s1">[_controller pushViewController:top animated:YES]</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s3">// don't really know what this case could be, but may need to handle it</span>
      <span class="s3">// somehow</span>
      <span class="s1">[_controller setViewControllers:controllers animated:NO]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s3">// change wasn't on the top of the stack. We don't need animation.</span>
    <span class="s1">[_controller setViewControllers:controllers animated:NO]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)updateContainer</span>
<span class="s1">{</span>
  <span class="s1">NSMutableArray&lt;UIViewController *&gt; *pushControllers = [NSMutableArray </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s1">NSMutableArray&lt;UIViewController *&gt; *modalControllers = [NSMutableArray </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(RNSScreenView *screen in _reactSubviews) {</span>
    <span class="s4">if </span><span class="s1">(!screen.dismissed &amp;&amp; screen.controller != nil) {</span>
      <span class="s4">if </span><span class="s1">(pushControllers.count == </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s3">// first screen on the list needs to be places as &quot;push controller&quot;</span>
        <span class="s1">[pushControllers addObject:screen.controller]</span><span class="s4">;</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s4">if </span><span class="s1">(screen.stackPresentation == RNSScreenStackPresentationPush) {</span>
          <span class="s1">[pushControllers addObject:screen.controller]</span><span class="s4">;</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
          <span class="s1">[modalControllers addObject:screen.controller]</span><span class="s4">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">[self setPushViewControllers:pushControllers]</span><span class="s4">;</span>
  <span class="s1">[self setModalViewControllers:modalControllers]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)layoutSubviews</span>
<span class="s1">{</span>
  <span class="s1">[super layoutSubviews]</span><span class="s4">;</span>
  <span class="s1">_controller.view.frame = self.bounds</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)dismissOnReload</span>
<span class="s1">{</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s4">if </span><span class="s1">([_controller.visibleViewController isKindOfClass:[RNSScreen </span><span class="s4">class</span><span class="s1">]]) {</span>
    <span class="s1">[(RNSScreen *)_controller.visibleViewController resetViewToScreen]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s0">#else</span>
  <span class="s1">dispatch_async(dispatch_get_main_queue()</span><span class="s4">, </span><span class="s1">^{</span>
    <span class="s1">[self invalidate]</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s0">#pragma </span><span class="s1">mark methods connected to transitioning</span>

<span class="s1">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</span>
                                  <span class="s1">animationControllerForOperation:(UINavigationControllerOperation)operation</span>
                                               <span class="s1">fromViewController:(UIViewController *)fromVC</span>
                                                 <span class="s1">toViewController:(UIViewController *)toVC</span>
<span class="s1">{</span>
  <span class="s1">RNSScreenView *screen</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(operation == UINavigationControllerOperationPush) {</span>
    <span class="s1">screen = ((RNSScreen *)toVC).screenView</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(operation == UINavigationControllerOperationPop) {</span>
    <span class="s1">screen = ((RNSScreen *)fromVC).screenView</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">BOOL shouldCancelDismiss = [self shouldCancelDismissFromView:(RNSScreenView *)fromVC.view</span>
                                                        <span class="s1">toView:(RNSScreenView *)toVC.view]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(screen != nil &amp;&amp;</span>
      <span class="s3">// when preventing the native dismiss with back button, we have to return the animator.</span>
      <span class="s3">// Also, we need to return the animator when full width swiping even if the animation is not custom,</span>
      <span class="s3">// otherwise the screen will be just popped immediately due to no animation</span>
      <span class="s1">((operation == UINavigationControllerOperationPop &amp;&amp; shouldCancelDismiss) || _isFullWidthSwiping ||</span>
       <span class="s1">[RNSScreenStackAnimator isCustomAnimation:screen.stackAnimation])) {</span>
    <span class="s4">return </span><span class="s1">[[RNSScreenStackAnimator alloc] initWithOperation:operation]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)cancelTouchesInParent</span>
<span class="s1">{</span>
  <span class="s3">// cancel touches in parent, this is needed to cancel RN touch events. For example when Touchable</span>
  <span class="s3">// item is close to an edge and we start pulling from edge we want the Touchable to be cancelled.</span>
  <span class="s3">// Without the below code the Touchable will remain active (highlighted) for the duration of back</span>
  <span class="s3">// gesture and onPress may fire when we release the finger.</span>
  <span class="s1">UIView *parent = _controller.view</span><span class="s4">;</span>
  <span class="s4">while </span><span class="s1">(parent != nil &amp;&amp; ![parent respondsToSelector:</span><span class="s4">@selector</span><span class="s1">(touchHandler)])</span>
    <span class="s1">parent = parent.superview</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(parent != nil) {</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
    <span class="s1">RCTSurfaceTouchHandler *touchHandler = [parent performSelector:</span><span class="s4">@selector</span><span class="s1">(touchHandler)]</span><span class="s4">;</span>
<span class="s0">#else</span>
    <span class="s1">RCTTouchHandler *touchHandler = [parent performSelector:</span><span class="s4">@selector</span><span class="s1">(touchHandler)]</span><span class="s4">;</span>
<span class="s0">#endif</span>
    <span class="s1">[touchHandler setEnabled:NO]</span><span class="s4">;</span>
    <span class="s1">[touchHandler setEnabled:YES]</span><span class="s4">;</span>
    <span class="s1">[touchHandler reset]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer</span>
<span class="s1">{</span>
  <span class="s1">RNSScreenView *topScreen = _reactSubviews.lastObject</span><span class="s4">;</span>

<span class="s0">#if </span><span class="s1">TARGET_OS_TV</span>
  <span class="s1">[self cancelTouchesInParent]</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
<span class="s0">#else</span>
  <span class="s3">// RNSPanGestureRecognizer will receive events iff topScreen.fullScreenSwipeEnabled == YES;</span>
  <span class="s3">// Events are filtered in gestureRecognizer:shouldReceivePressOrTouchEvent: method</span>
  <span class="s4">if </span><span class="s1">([gestureRecognizer isKindOfClass:[RNSPanGestureRecognizer </span><span class="s4">class</span><span class="s1">]]) {</span>
    <span class="s4">if </span><span class="s1">([self isInGestureResponseDistance:gestureRecognizer topScreen:topScreen]) {</span>
      <span class="s1">_isFullWidthSwiping = YES</span><span class="s4">;</span>
      <span class="s1">[self cancelTouchesInParent]</span><span class="s4">;</span>
      <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s3">// Now we're dealing with RNSScreenEdgeGestureRecognizer (or _UIParallaxTransitionPanGestureRecognizer)</span>
  <span class="s4">if </span><span class="s1">(topScreen.customAnimationOnSwipe &amp;&amp; [RNSScreenStackAnimator isCustomAnimation:topScreen.stackAnimation]) {</span>
    <span class="s4">if </span><span class="s1">([gestureRecognizer isKindOfClass:[RNSScreenEdgeGestureRecognizer </span><span class="s4">class</span><span class="s1">]]) {</span>
      <span class="s3">// if we do not set any explicit `semanticContentAttribute`, it is `UISemanticContentAttributeUnspecified` instead</span>
      <span class="s3">// of `UISemanticContentAttributeForceLeftToRight`, so we just check if it is RTL or not</span>
      <span class="s1">BOOL isCorrectEdge = (_controller.view.semanticContentAttribute == UISemanticContentAttributeForceRightToLeft &amp;&amp;</span>
                            <span class="s1">((RNSScreenEdgeGestureRecognizer *)gestureRecognizer).edges == UIRectEdgeRight) ||</span>
          <span class="s1">(_controller.view.semanticContentAttribute != UISemanticContentAttributeForceRightToLeft &amp;&amp;</span>
           <span class="s1">((RNSScreenEdgeGestureRecognizer *)gestureRecognizer).edges == UIRectEdgeLeft)</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(isCorrectEdge) {</span>
        <span class="s1">[self cancelTouchesInParent]</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">if </span><span class="s1">([gestureRecognizer isKindOfClass:[RNSScreenEdgeGestureRecognizer </span><span class="s4">class</span><span class="s1">]]) {</span>
      <span class="s3">// it should only recognize with `customAnimationOnSwipe` set</span>
      <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s3">// _UIParallaxTransitionPanGestureRecognizer (other...)</span>
    <span class="s1">[self cancelTouchesInParent]</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
  <span class="s1">}</span>

<span class="s0">#endif </span><span class="s3">// TARGET_OS_TV</span>
<span class="s1">}</span>

<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setupGestureHandlers</span>
<span class="s1">{</span>
  <span class="s3">// gesture recognizers for custom stack animations</span>
  <span class="s1">RNSScreenEdgeGestureRecognizer *leftEdgeSwipeGestureRecognizer =</span>
      <span class="s1">[[RNSScreenEdgeGestureRecognizer alloc] initWithTarget:self action:</span><span class="s4">@selector</span><span class="s1">(handleSwipe:)]</span><span class="s4">;</span>
  <span class="s1">leftEdgeSwipeGestureRecognizer.edges = UIRectEdgeLeft</span><span class="s4">;</span>
  <span class="s1">leftEdgeSwipeGestureRecognizer.delegate = self</span><span class="s4">;</span>
  <span class="s1">[self addGestureRecognizer:leftEdgeSwipeGestureRecognizer]</span><span class="s4">;</span>

  <span class="s1">RNSScreenEdgeGestureRecognizer *rightEdgeSwipeGestureRecognizer =</span>
      <span class="s1">[[RNSScreenEdgeGestureRecognizer alloc] initWithTarget:self action:</span><span class="s4">@selector</span><span class="s1">(handleSwipe:)]</span><span class="s4">;</span>
  <span class="s1">rightEdgeSwipeGestureRecognizer.edges = UIRectEdgeRight</span><span class="s4">;</span>
  <span class="s1">rightEdgeSwipeGestureRecognizer.delegate = self</span><span class="s4">;</span>
  <span class="s1">[self addGestureRecognizer:rightEdgeSwipeGestureRecognizer]</span><span class="s4">;</span>

  <span class="s3">// gesture recognizer for full width swipe gesture</span>
  <span class="s1">RNSPanGestureRecognizer *panRecognizer = [[RNSPanGestureRecognizer alloc] initWithTarget:self</span>
                                                                                    <span class="s1">action:</span><span class="s4">@selector</span><span class="s1">(handleSwipe:)]</span><span class="s4">;</span>
  <span class="s1">panRecognizer.delegate = self</span><span class="s4">;</span>
  <span class="s1">[self addGestureRecognizer:panRecognizer]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)handleSwipe:(UIPanGestureRecognizer *)gestureRecognizer</span>
<span class="s1">{</span>
  <span class="s1">RNSScreenView *topScreen = _reactSubviews.lastObject</span><span class="s4">;</span>
  <span class="s4">float </span><span class="s1">translation</span><span class="s4">;</span>
  <span class="s4">float </span><span class="s1">velocity</span><span class="s4">;</span>
  <span class="s4">float </span><span class="s1">distance</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(topScreen.swipeDirection == RNSScreenSwipeDirectionVertical) {</span>
    <span class="s1">translation = [gestureRecognizer translationInView:gestureRecognizer.view].y</span><span class="s4">;</span>
    <span class="s1">velocity = [gestureRecognizer velocityInView:gestureRecognizer.view].y</span><span class="s4">;</span>
    <span class="s1">distance = gestureRecognizer.view.bounds.size.height</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">translation = [gestureRecognizer translationInView:gestureRecognizer.view].x</span><span class="s4">;</span>
    <span class="s1">velocity = [gestureRecognizer velocityInView:gestureRecognizer.view].x</span><span class="s4">;</span>
    <span class="s1">distance = gestureRecognizer.view.bounds.size.width</span><span class="s4">;</span>
    <span class="s1">BOOL isRTL = _controller.view.semanticContentAttribute == UISemanticContentAttributeForceRightToLeft</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(isRTL) {</span>
      <span class="s1">translation = -translation</span><span class="s4">;</span>
      <span class="s1">velocity = -velocity</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">float </span><span class="s1">transitionProgress = (translation / distance)</span><span class="s4">;</span>

  <span class="s4">switch </span><span class="s1">(gestureRecognizer.state) {</span>
    <span class="s4">case </span><span class="s1">UIGestureRecognizerStateBegan: {</span>
      <span class="s1">_interactionController = [UIPercentDrivenInteractiveTransition </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
      <span class="s1">[_controller popViewControllerAnimated:YES]</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s1">}</span>

    <span class="s4">case </span><span class="s1">UIGestureRecognizerStateChanged: {</span>
      <span class="s1">[_interactionController updateInteractiveTransition:transitionProgress]</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s1">}</span>

    <span class="s4">case </span><span class="s1">UIGestureRecognizerStateCancelled: {</span>
      <span class="s1">[_interactionController cancelInteractiveTransition]</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s1">}</span>

    <span class="s4">case </span><span class="s1">UIGestureRecognizerStateEnded: {</span>
      <span class="s3">// values taken from</span>
      <span class="s3">// https://github.com/react-navigation/react-navigation/blob/54739828598d7072c1bf7b369659e3682db3edc5/packages/stack/src/views/Stack/Card.tsx#L316</span>
      <span class="s1">BOOL shouldFinishTransition = (translation + velocity * </span><span class="s5">0.3</span><span class="s1">) &gt; (distance / </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(shouldFinishTransition) {</span>
        <span class="s1">[_interactionController finishInteractiveTransition]</span><span class="s4">;</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s1">[_interactionController cancelInteractiveTransition]</span><span class="s4">;</span>
      <span class="s1">}</span>
      <span class="s1">_interactionController = nil</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">default</span><span class="s1">: {</span>
      <span class="s4">break;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (id&lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController</span>
                         <span class="s1">interactionControllerForAnimationController:</span>
                             <span class="s1">(id&lt;UIViewControllerAnimatedTransitioning&gt;)animationController</span>
<span class="s1">{</span>
  <span class="s1">RNSScreenView *fromView = [_controller.transitionCoordinator viewForKey:UITransitionContextFromViewKey]</span><span class="s4">;</span>
  <span class="s1">RNSScreenView *toView = [_controller.transitionCoordinator viewForKey:UITransitionContextToViewKey]</span><span class="s4">;</span>
  <span class="s3">// we can intercept clicking back button here, we check reactSuperview since this method also fires when</span>
  <span class="s3">// navigating back from JS</span>
  <span class="s4">if </span><span class="s1">(_interactionController == nil &amp;&amp; fromView.reactSuperview) {</span>
    <span class="s1">BOOL shouldCancelDismiss = [self shouldCancelDismissFromView:fromView toView:toView]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(shouldCancelDismiss) {</span>
      <span class="s1">_interactionController = [UIPercentDrivenInteractiveTransition </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
      <span class="s1">dispatch_after(dispatch_time(DISPATCH_TIME_NOW</span><span class="s4">, </span><span class="s1">(int64_t)(</span><span class="s5">0.01 </span><span class="s1">* NSEC_PER_SEC))</span><span class="s4">, </span><span class="s1">dispatch_get_main_queue()</span><span class="s4">, </span><span class="s1">^{</span>
        <span class="s1">[self-&gt;_interactionController cancelInteractiveTransition]</span><span class="s4">;</span>
        <span class="s1">self-&gt;_interactionController = nil</span><span class="s4">;</span>
        <span class="s4">int </span><span class="s1">fromIndex = (</span><span class="s4">int</span><span class="s1">)[self-&gt;_reactSubviews indexOfObject:fromView]</span><span class="s4">;</span>
        <span class="s4">int </span><span class="s1">toIndex = (</span><span class="s4">int</span><span class="s1">)[self-&gt;_reactSubviews indexOfObject:toView]</span><span class="s4">;</span>
        <span class="s4">int </span><span class="s1">indexDiff = fromIndex - toIndex</span><span class="s4">;</span>
        <span class="s4">int </span><span class="s1">dismissCount = indexDiff &gt; </span><span class="s5">0 </span><span class="s1">? indexDiff : </span><span class="s5">1</span><span class="s4">;</span>
        <span class="s1">[self updateContainer]</span><span class="s4">;</span>
        <span class="s1">[fromView notifyDismissCancelledWithDismissCount:dismissCount]</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">_interactionController</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (id&lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:</span>
    <span class="s1">(id&lt;UIViewControllerAnimatedTransitioning&gt;)animator</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">_interactionController</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)navigationController:(UINavigationController *)navigationController</span>
       <span class="s1">didShowViewController:(UIViewController *)viewController</span>
                    <span class="s1">animated:(BOOL)animated</span>
<span class="s1">{</span>
  <span class="s1">[self emitOnFinishTransitioningEvent]</span><span class="s4">;</span>
  <span class="s1">[RNSScreenWindowTraits updateWindowTraits]</span><span class="s4">;</span>
<span class="s1">}</span>
<span class="s0">#endif</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)markChildUpdated</span>
<span class="s1">{</span>
  <span class="s3">// do nothing</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)didUpdateChildren</span>
<span class="s1">{</span>
  <span class="s3">// do nothing</span>
<span class="s1">}</span>

<span class="s1">- (UIViewController *)reactViewController</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">_controller</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)isInGestureResponseDistance:(UIGestureRecognizer *)gestureRecognizer topScreen:(RNSScreenView *)topScreen</span>
<span class="s1">{</span>
  <span class="s1">NSDictionary *gestureResponseDistanceValues = topScreen.gestureResponseDistance</span><span class="s4">;</span>
  <span class="s4">float </span><span class="s1">x = [gestureRecognizer locationInView:gestureRecognizer.view].x</span><span class="s4">;</span>
  <span class="s4">float </span><span class="s1">y = [gestureRecognizer locationInView:gestureRecognizer.view].y</span><span class="s4">;</span>
  <span class="s1">BOOL isRTL = _controller.view.semanticContentAttribute == UISemanticContentAttributeForceRightToLeft</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(isRTL) {</span>
    <span class="s1">x = _controller.view.frame.size.width - x</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s3">// see:</span>
  <span class="s3">// https://github.com/software-mansion/react-native-screens/pull/1442/commits/74d4bae321875d8305ad021b3d448ebf713e7d56</span>
  <span class="s3">// this prop is always default initialized so we do not expect any nils</span>
  <span class="s4">float </span><span class="s1">start = [gestureResponseDistanceValues[</span><span class="s4">@</span><span class="s2">&quot;start&quot;</span><span class="s1">] floatValue]</span><span class="s4">;</span>
  <span class="s4">float end </span><span class="s1">= [gestureResponseDistanceValues[</span><span class="s4">@</span><span class="s2">&quot;end&quot;</span><span class="s1">] floatValue]</span><span class="s4">;</span>
  <span class="s4">float </span><span class="s1">top = [gestureResponseDistanceValues[</span><span class="s4">@</span><span class="s2">&quot;top&quot;</span><span class="s1">] floatValue]</span><span class="s4">;</span>
  <span class="s4">float </span><span class="s1">bottom = [gestureResponseDistanceValues[</span><span class="s4">@</span><span class="s2">&quot;bottom&quot;</span><span class="s1">] floatValue]</span><span class="s4">;</span>

  <span class="s3">// we check if any of the constraints are violated and return NO if so</span>
  <span class="s4">return </span><span class="s1">!(</span>
      <span class="s1">(start != -</span><span class="s5">1 </span><span class="s1">&amp;&amp; x &lt; start) || (</span><span class="s4">end </span><span class="s1">!= -</span><span class="s5">1 </span><span class="s1">&amp;&amp; x &gt; </span><span class="s4">end</span><span class="s1">) || (top != -</span><span class="s5">1 </span><span class="s1">&amp;&amp; y &lt; top) || (bottom != -</span><span class="s5">1 </span><span class="s1">&amp;&amp; y &gt; bottom))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s3">// By default, the header buttons that are not inside the native hit area</span>
<span class="s3">// cannot be clicked, so we check it by ourselves</span>
<span class="s1">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(CGRectContainsPoint(_controller.navigationBar.frame</span><span class="s4">, </span><span class="s1">point)) {</span>
    <span class="s3">// headerConfig should be the first subview of the topmost screen</span>
    <span class="s1">UIView *headerConfig = [[_reactSubviews.lastObject reactSubviews] firstObject]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">([headerConfig isKindOfClass:[RNSScreenStackHeaderConfig </span><span class="s4">class</span><span class="s1">]]) {</span>
      <span class="s1">UIView *headerHitTestResult = [headerConfig hitTest:point withEvent:event]</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(headerHitTestResult != nil) {</span>
        <span class="s4">return </span><span class="s1">headerHitTestResult</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">[super hitTest:point withEvent:event]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>

<span class="s1">- (BOOL)isScrollViewPanGestureRecognizer:(UIGestureRecognizer *)gestureRecognizer</span>
<span class="s1">{</span>
  <span class="s3">// NOTE: This hack is required to restore native behavior of edge swipe (interactive pop gesture)</span>
  <span class="s3">// without this, on a screen with a scroll view, it's only possible to pop view by panning horizontally</span>
  <span class="s3">// if even slightly diagonal (or if in motion), scroll view will scroll, and edge swipe will be cancelled</span>
  <span class="s4">if </span><span class="s1">(![[gestureRecognizer view] isKindOfClass:[UIScrollView </span><span class="s4">class</span><span class="s1">]]) {</span>
    <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">UIScrollView *scrollView = (UIScrollView *)gestureRecognizer.view</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">scrollView.panGestureRecognizer == gestureRecognizer</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s3">// Custom method for compatibility with iOS &lt; 13.4</span>
<span class="s3">// RNSScreenStackView is a UIGestureRecognizerDelegate for three types of gesture recognizers:</span>
<span class="s3">// RNSPanGestureRecognizer, RNSScreenEdgeGestureRecognizer, _UIParallaxTransitionPanGestureRecognizer</span>
<span class="s3">// Be careful when adding another type of gesture recognizer.</span>
<span class="s1">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceivePressOrTouchEvent:(NSObject *)event</span>
<span class="s1">{</span>
  <span class="s1">RNSScreenView *topScreen = _reactSubviews.lastObject</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(![topScreen isKindOfClass:[RNSScreenView </span><span class="s4">class</span><span class="s1">]] || !topScreen.gestureEnabled ||</span>
      <span class="s1">_controller.viewControllers.count &lt; </span><span class="s5">2 </span><span class="s1">|| [topScreen isModal]) {</span>
    <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s3">// We want to pass events to RNSPanGestureRecognizer iff full screen swipe is enabled.</span>
  <span class="s4">if </span><span class="s1">([gestureRecognizer isKindOfClass:[RNSPanGestureRecognizer </span><span class="s4">class</span><span class="s1">]]) {</span>
    <span class="s4">return </span><span class="s1">topScreen.fullScreenSwipeEnabled</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s3">// RNSScreenEdgeGestureRecognizer || _UIParallaxTransitionPanGestureRecognizer</span>
  <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceivePress:(UIPress *)press</span><span class="s4">;</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">[self gestureRecognizer:gestureRecognizer shouldReceivePressOrTouchEvent:press]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch</span><span class="s4">;</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">[self gestureRecognizer:gestureRecognizer shouldReceivePressOrTouchEvent:touch]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer</span>
    <span class="s1">shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">([gestureRecognizer isKindOfClass:[RNSPanGestureRecognizer </span><span class="s4">class</span><span class="s1">]] &amp;&amp;</span>
      <span class="s1">[self isScrollViewPanGestureRecognizer:otherGestureRecognizer]) {</span>
    <span class="s1">RNSPanGestureRecognizer *panGestureRecognizer = (RNSPanGestureRecognizer *)gestureRecognizer</span><span class="s4">;</span>
    <span class="s1">BOOL isBackGesture = [panGestureRecognizer translationInView:panGestureRecognizer.view].x &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp;</span>
        <span class="s1">_controller.viewControllers.count &gt; </span><span class="s5">1</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(gestureRecognizer.state == UIGestureRecognizerStateBegan || isBackGesture) {</span>
      <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer</span>
    <span class="s1">shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">(</span>
      <span class="s1">[gestureRecognizer isKindOfClass:[UIScreenEdgePanGestureRecognizer </span><span class="s4">class</span><span class="s1">]] &amp;&amp;</span>
      <span class="s1">[self isScrollViewPanGestureRecognizer:otherGestureRecognizer])</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">#endif </span><span class="s3">// !TARGET_OS_TV</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)insertReactSubview:(RNSScreenView *)subview atIndex:(NSInteger)atIndex</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(![subview isKindOfClass:[RNSScreenView </span><span class="s4">class</span><span class="s1">]]) {</span>
    <span class="s1">RCTLogError(</span><span class="s4">@</span><span class="s2">&quot;ScreenStack only accepts children of type Screen&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
  <span class="s1">subview.reactSuperview = self</span><span class="s4">;</span>
  <span class="s1">[_reactSubviews insertObject:subview atIndex:atIndex]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)removeReactSubview:(RNSScreenView *)subview</span>
<span class="s1">{</span>
  <span class="s1">subview.reactSuperview = nil</span><span class="s4">;</span>
  <span class="s1">[_reactSubviews removeObject:subview]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)didUpdateReactSubviews</span>
<span class="s1">{</span>
  <span class="s3">// we need to wait until children have their layout set. At this point they don't have the layout</span>
  <span class="s3">// set yet, however the layout call is already enqueued on ui thread. Enqueuing update call on the</span>
  <span class="s3">// ui queue will guarantee that the update will run after layout.</span>
  <span class="s1">dispatch_async(dispatch_get_main_queue()</span><span class="s4">, </span><span class="s1">^{</span>
    <span class="s1">self-&gt;_hasLayout = YES</span><span class="s4">;</span>
    <span class="s1">[self maybeAddToParentAndUpdateContainer]</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s0">#pragma </span><span class="s1">mark - Fabric specific</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)mountChildComponentView:(UIView&lt;RCTComponentViewProtocol&gt; *)childComponentView index:(NSInteger)index</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(![childComponentView isKindOfClass:[RNSScreenView </span><span class="s4">class</span><span class="s1">]]) {</span>
    <span class="s1">RCTLogError(</span><span class="s4">@</span><span class="s2">&quot;ScreenStack only accepts children of type Screen&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">RCTAssert(</span>
      <span class="s1">childComponentView.reactSuperview == nil</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s2">&quot;Attempt to mount already mounted component view. (parent: %@, child: %@, index: %@, existing parent: %@)&quot;</span><span class="s4">,</span>
      <span class="s1">self</span><span class="s4">,</span>
      <span class="s1">childComponentView</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">(index)</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">([childComponentView.superview tag]))</span><span class="s4">;</span>

  <span class="s1">[_reactSubviews insertObject:(RNSScreenView *)childComponentView atIndex:index]</span><span class="s4">;</span>
  <span class="s1">((RNSScreenView *)childComponentView).reactSuperview = self</span><span class="s4">;</span>
  <span class="s1">dispatch_async(dispatch_get_main_queue()</span><span class="s4">, </span><span class="s1">^{</span>
    <span class="s1">[self maybeAddToParentAndUpdateContainer]</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)unmountChildComponentView:(UIView&lt;RCTComponentViewProtocol&gt; *)childComponentView index:(NSInteger)index</span>
<span class="s1">{</span>
  <span class="s1">RNSScreenView *screenChildComponent = (RNSScreenView *)childComponentView</span><span class="s4">;</span>
  <span class="s3">// We should only do a snapshot of a screen that is on the top.</span>
  <span class="s3">// We also check `_presentedModals` since if you push 2 modals, second one is not a &quot;child&quot; of _controller.</span>
  <span class="s3">// Also, when dissmised with a gesture, the screen already is not under the window, so we don't need to apply</span>
  <span class="s3">// snapshot.</span>
  <span class="s4">if </span><span class="s1">(screenChildComponent.window != nil &amp;&amp;</span>
      <span class="s1">((screenChildComponent == _controller.visibleViewController.view &amp;&amp; _presentedModals.count &lt; </span><span class="s5">2</span><span class="s1">) ||</span>
       <span class="s1">screenChildComponent == [_presentedModals.lastObject view])) {</span>
    <span class="s1">[screenChildComponent.controller setViewToSnapshot:_snapshot]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">RCTAssert(</span>
      <span class="s1">screenChildComponent.reactSuperview == self</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s2">&quot;Attempt to unmount a view which is mounted inside different view. (parent: %@, child: %@, index: %@)&quot;</span><span class="s4">,</span>
      <span class="s1">self</span><span class="s4">,</span>
      <span class="s1">screenChildComponent</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">(index))</span><span class="s4">;</span>
  <span class="s1">RCTAssert(</span>
      <span class="s1">(_reactSubviews.count &gt; index) &amp;&amp; [_reactSubviews objectAtIndex:index] == childComponentView</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s2">&quot;Attempt to unmount a view which has a different index. (parent: %@, child: %@, index: %@, actual index: %@, tag at index: %@)&quot;</span><span class="s4">,</span>
      <span class="s1">self</span><span class="s4">,</span>
      <span class="s1">screenChildComponent</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">(index)</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">([_reactSubviews indexOfObject:screenChildComponent])</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">([[_reactSubviews objectAtIndex:index] tag]))</span><span class="s4">;</span>
  <span class="s1">screenChildComponent.reactSuperview = nil</span><span class="s4">;</span>
  <span class="s1">[_reactSubviews removeObject:screenChildComponent]</span><span class="s4">;</span>
  <span class="s1">[screenChildComponent removeFromSuperview]</span><span class="s4">;</span>
  <span class="s1">dispatch_async(dispatch_get_main_queue()</span><span class="s4">, </span><span class="s1">^{</span>
    <span class="s1">[self maybeAddToParentAndUpdateContainer]</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)takeSnapshot</span>
<span class="s1">{</span>
  <span class="s1">_snapshot = [_controller.visibleViewController.view snapshotViewAfterScreenUpdates:NO]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)mountingTransactionWillMount:(facebook::react::MountingTransaction </span><span class="s4">const </span><span class="s1">&amp;)transaction</span>
                <span class="s1">withSurfaceTelemetry:(facebook::react::SurfaceTelemetry </span><span class="s4">const </span><span class="s1">&amp;)surfaceTelemetry</span>
<span class="s1">{</span>
  <span class="s4">for </span><span class="s1">(</span><span class="s4">auto </span><span class="s1">&amp;mutation : transaction.getMutations()) {</span>
    <span class="s4">if </span><span class="s1">(mutation.type == facebook::react::ShadowViewMutation::Type::Remove &amp;&amp;</span>
        <span class="s1">mutation.parentShadowView.componentName != nil &amp;&amp;</span>
        <span class="s1">strcmp(mutation.parentShadowView.componentName</span><span class="s4">, </span><span class="s2">&quot;RNSScreenStack&quot;</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s1">[self takeSnapshot]</span><span class="s4">;</span>
      <span class="s4">return;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)prepareForRecycle</span>
<span class="s1">{</span>
  <span class="s1">[super prepareForRecycle]</span><span class="s4">;</span>
  <span class="s1">_reactSubviews = [NSMutableArray </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>

  <span class="s4">for </span><span class="s1">(UIViewController *controller in _presentedModals) {</span>
    <span class="s1">[controller dismissViewControllerAnimated:NO completion:nil]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">[_presentedModals removeAllObjects]</span><span class="s4">;</span>
  <span class="s1">[self dismissOnReload]</span><span class="s4">;</span>
  <span class="s1">[_controller willMoveToParentViewController:nil]</span><span class="s4">;</span>
  <span class="s1">[_controller removeFromParentViewController]</span><span class="s4">;</span>
  <span class="s1">[_controller setViewControllers:</span><span class="s4">@</span><span class="s1">[ [UIViewController </span><span class="s4">new</span><span class="s1">] ]]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">+ (facebook::react::ComponentDescriptorProvider)componentDescriptorProvider</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">facebook::react::concreteComponentDescriptorProvider&lt;facebook::react::RNSScreenStackComponentDescriptor&gt;()</span><span class="s4">;</span>
<span class="s1">}</span>
<span class="s0">#else</span>
<span class="s0">#pragma </span><span class="s1">mark - Paper specific</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)invalidate</span>
<span class="s1">{</span>
  <span class="s1">_invalidated = YES</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(UIViewController *controller in _presentedModals) {</span>
    <span class="s1">[controller dismissViewControllerAnimated:NO completion:nil]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">[_presentedModals removeAllObjects]</span><span class="s4">;</span>
  <span class="s1">[_controller willMoveToParentViewController:nil]</span><span class="s4">;</span>
  <span class="s1">[_controller removeFromParentViewController]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">#endif </span><span class="s3">// RCT_NEW_ARCH_ENABLED</span>

<span class="s4">@end</span>

<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s1">Class&lt;RCTComponentViewProtocol&gt; RNSScreenStackCls(</span><span class="s4">void</span><span class="s1">)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">RNSScreenStackView.</span><span class="s4">class;</span>
<span class="s1">}</span>
<span class="s0">#endif</span>

<span class="s4">@implementation </span><span class="s1">RNSScreenStackManager {</span>
  <span class="s1">NSPointerArray *_stacks</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_MODULE()</span>

<span class="s1">RCT_EXPORT_VIEW_PROPERTY(onFinishTransitioning</span><span class="s4">, </span><span class="s1">RCTDirectEventBlock)</span><span class="s4">;</span>

<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s0">#else</span>
<span class="s1">- (UIView *)view</span>
<span class="s1">{</span>
  <span class="s1">RNSScreenStackView *view = [[RNSScreenStackView alloc] initWithManager:self]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!_stacks) {</span>
    <span class="s1">_stacks = [NSPointerArray weakObjectsPointerArray]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">[_stacks addPointer:(</span><span class="s4">__bridge void </span><span class="s1">*)view]</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">view</span><span class="s4">;</span>
<span class="s1">}</span>
<span class="s0">#endif </span><span class="s3">// RCT_NEW_ARCH_ENABLED</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)invalidate</span>
<span class="s1">{</span>
  <span class="s4">for </span><span class="s1">(RNSScreenStackView *stack in _stacks) {</span>
    <span class="s1">[stack dismissOnReload]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">_stacks = nil</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">@end</span>
</pre>
</body>
</html>
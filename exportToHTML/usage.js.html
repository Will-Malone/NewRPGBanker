<html>
<head>
<title>usage.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
usage.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.usage = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s4">// this file handles outputting usage instructions,</span>
<span class="s4">// failures, etc. keeps logging in one place.</span>
<span class="s1">const common_types_1 = require(</span><span class="s0">&quot;./common-types&quot;</span><span class="s1">);</span>
<span class="s1">const obj_filter_1 = require(</span><span class="s0">&quot;./obj-filter&quot;</span><span class="s1">);</span>
<span class="s1">const path = require(</span><span class="s0">&quot;path&quot;</span><span class="s1">);</span>
<span class="s1">const yerror_1 = require(</span><span class="s0">&quot;./yerror&quot;</span><span class="s1">);</span>
<span class="s1">const decamelize = require(</span><span class="s0">&quot;decamelize&quot;</span><span class="s1">);</span>
<span class="s1">const setBlocking = require(</span><span class="s0">&quot;set-blocking&quot;</span><span class="s1">);</span>
<span class="s1">const stringWidth = require(</span><span class="s0">&quot;string-width&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">usage(yargs, y18n) {</span>
    <span class="s1">const __ = y18n.__;</span>
    <span class="s1">const self = {};</span>
    <span class="s4">// methods for ouputting/building failure message.</span>
    <span class="s1">const fails = [];</span>
    <span class="s1">self.failFn = </span><span class="s2">function </span><span class="s1">failFn(f) {</span>
        <span class="s1">fails.push(f);</span>
    <span class="s1">};</span>
    <span class="s1">let failMessage = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">let showHelpOnFail = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">self.showHelpOnFail = </span><span class="s2">function </span><span class="s1">showHelpOnFailFn(arg1 = </span><span class="s2">true</span><span class="s1">, arg2) {</span>
        <span class="s2">function </span><span class="s1">parseFunctionArgs() {</span>
            <span class="s2">return typeof </span><span class="s1">arg1 === </span><span class="s0">'string' </span><span class="s1">? [</span><span class="s2">true</span><span class="s1">, arg1] : [arg1, arg2];</span>
        <span class="s1">}</span>
        <span class="s1">const [enabled, message] = parseFunctionArgs();</span>
        <span class="s1">failMessage = message;</span>
        <span class="s1">showHelpOnFail = enabled;</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">let failureOutput = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">self.fail = </span><span class="s2">function </span><span class="s1">fail(msg, err) {</span>
        <span class="s1">const logger = yargs._getLoggerInstance();</span>
        <span class="s2">if </span><span class="s1">(fails.length) {</span>
            <span class="s2">for </span><span class="s1">(let i = fails.length - </span><span class="s3">1</span><span class="s1">; i &gt;= </span><span class="s3">0</span><span class="s1">; --i) {</span>
                <span class="s1">fails[i](msg, err, self);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(yargs.getExitProcess())</span>
                <span class="s1">setBlocking(</span><span class="s2">true</span><span class="s1">);</span>
            <span class="s4">// don't output failure message more than once</span>
            <span class="s2">if </span><span class="s1">(!failureOutput) {</span>
                <span class="s1">failureOutput = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(showHelpOnFail) {</span>
                    <span class="s1">yargs.showHelp(</span><span class="s0">'error'</span><span class="s1">);</span>
                    <span class="s1">logger.error();</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(msg || err)</span>
                    <span class="s1">logger.error(msg || err);</span>
                <span class="s2">if </span><span class="s1">(failMessage) {</span>
                    <span class="s2">if </span><span class="s1">(msg || err)</span>
                        <span class="s1">logger.error(</span><span class="s0">''</span><span class="s1">);</span>
                    <span class="s1">logger.error(failMessage);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">err = err || </span><span class="s2">new </span><span class="s1">yerror_1.YError(msg);</span>
            <span class="s2">if </span><span class="s1">(yargs.getExitProcess()) {</span>
                <span class="s2">return </span><span class="s1">yargs.exit(</span><span class="s3">1</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(yargs._hasParseCallback()) {</span>
                <span class="s2">return </span><span class="s1">yargs.exit(</span><span class="s3">1</span><span class="s1">, err);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s4">// methods for ouputting/building help (usage) message.</span>
    <span class="s1">let usages = [];</span>
    <span class="s1">let usageDisabled = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">self.usage = (msg, description) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(msg === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">usageDisabled = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">usages = [];</span>
            <span class="s2">return </span><span class="s1">self;</span>
        <span class="s1">}</span>
        <span class="s1">usageDisabled = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">usages.push([msg, description || </span><span class="s0">''</span><span class="s1">]);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.getUsage = () =&gt; {</span>
        <span class="s2">return </span><span class="s1">usages;</span>
    <span class="s1">};</span>
    <span class="s1">self.getUsageDisabled = () =&gt; {</span>
        <span class="s2">return </span><span class="s1">usageDisabled;</span>
    <span class="s1">};</span>
    <span class="s1">self.getPositionalGroupName = () =&gt; {</span>
        <span class="s2">return </span><span class="s1">__(</span><span class="s0">'Positionals:'</span><span class="s1">);</span>
    <span class="s1">};</span>
    <span class="s1">let examples = [];</span>
    <span class="s1">self.example = (cmd, description) =&gt; {</span>
        <span class="s1">examples.push([cmd, description || </span><span class="s0">''</span><span class="s1">]);</span>
    <span class="s1">};</span>
    <span class="s1">let commands = [];</span>
    <span class="s1">self.command = </span><span class="s2">function </span><span class="s1">command(cmd, description, isDefault, aliases, deprecated = </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s4">// the last default wins, so cancel out any previously set default</span>
        <span class="s2">if </span><span class="s1">(isDefault) {</span>
            <span class="s1">commands = commands.map((cmdArray) =&gt; {</span>
                <span class="s1">cmdArray[</span><span class="s3">2</span><span class="s1">] = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">return </span><span class="s1">cmdArray;</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">commands.push([cmd, description || </span><span class="s0">''</span><span class="s1">, isDefault, aliases, deprecated]);</span>
    <span class="s1">};</span>
    <span class="s1">self.getCommands = () =&gt; commands;</span>
    <span class="s1">let descriptions = {};</span>
    <span class="s1">self.describe = </span><span class="s2">function </span><span class="s1">describe(keyOrKeys, desc) {</span>
        <span class="s2">if </span><span class="s1">(Array.isArray(keyOrKeys)) {</span>
            <span class="s1">keyOrKeys.forEach((k) =&gt; {</span>
                <span class="s1">self.describe(k, desc);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">keyOrKeys === </span><span class="s0">'object'</span><span class="s1">) {</span>
            <span class="s1">Object.keys(keyOrKeys).forEach((k) =&gt; {</span>
                <span class="s1">self.describe(k, keyOrKeys[k]);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">descriptions[keyOrKeys] = desc;</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s1">self.getDescriptions = () =&gt; descriptions;</span>
    <span class="s1">let epilogs = [];</span>
    <span class="s1">self.epilog = (msg) =&gt; {</span>
        <span class="s1">epilogs.push(msg);</span>
    <span class="s1">};</span>
    <span class="s1">let wrapSet = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">let wrap;</span>
    <span class="s1">self.wrap = (cols) =&gt; {</span>
        <span class="s1">wrapSet = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">wrap = cols;</span>
    <span class="s1">};</span>
    <span class="s2">function </span><span class="s1">getWrap() {</span>
        <span class="s2">if </span><span class="s1">(!wrapSet) {</span>
            <span class="s1">wrap = windowWidth();</span>
            <span class="s1">wrapSet = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">wrap;</span>
    <span class="s1">}</span>
    <span class="s1">const deferY18nLookupPrefix = </span><span class="s0">'__yargsString__:'</span><span class="s1">;</span>
    <span class="s1">self.deferY18nLookup = str =&gt; deferY18nLookupPrefix + str;</span>
    <span class="s1">self.help = </span><span class="s2">function </span><span class="s1">help() {</span>
        <span class="s2">if </span><span class="s1">(cachedHelpMessage)</span>
            <span class="s2">return </span><span class="s1">cachedHelpMessage;</span>
        <span class="s1">normalizeAliases();</span>
        <span class="s4">// handle old demanded API</span>
        <span class="s1">const base$0 = yargs.customScriptName ? yargs.$0 : path.basename(yargs.$0);</span>
        <span class="s1">const demandedOptions = yargs.getDemandedOptions();</span>
        <span class="s1">const demandedCommands = yargs.getDemandedCommands();</span>
        <span class="s1">const deprecatedOptions = yargs.getDeprecatedOptions();</span>
        <span class="s1">const groups = yargs.getGroups();</span>
        <span class="s1">const options = yargs.getOptions();</span>
        <span class="s1">let keys = [];</span>
        <span class="s1">keys = keys.concat(Object.keys(descriptions));</span>
        <span class="s1">keys = keys.concat(Object.keys(demandedOptions));</span>
        <span class="s1">keys = keys.concat(Object.keys(demandedCommands));</span>
        <span class="s1">keys = keys.concat(Object.keys(options.</span><span class="s2">default</span><span class="s1">));</span>
        <span class="s1">keys = keys.filter(filterHiddenOptions);</span>
        <span class="s1">keys = Object.keys(keys.reduce((acc, key) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">'_'</span><span class="s1">)</span>
                <span class="s1">acc[key] = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">return </span><span class="s1">acc;</span>
        <span class="s1">}, {}));</span>
        <span class="s1">const theWrap = getWrap();</span>
        <span class="s1">const ui = require(</span><span class="s0">'cliui'</span><span class="s1">)({</span>
            <span class="s1">width: theWrap,</span>
            <span class="s1">wrap: !!theWrap</span>
        <span class="s1">});</span>
        <span class="s4">// the usage string.</span>
        <span class="s2">if </span><span class="s1">(!usageDisabled) {</span>
            <span class="s2">if </span><span class="s1">(usages.length) {</span>
                <span class="s4">// user-defined usage.</span>
                <span class="s1">usages.forEach((usage) =&gt; {</span>
                    <span class="s1">ui.div(`${usage[</span><span class="s3">0</span><span class="s1">].replace(/\$0/g, base$0)}`);</span>
                    <span class="s2">if </span><span class="s1">(usage[</span><span class="s3">1</span><span class="s1">]) {</span>
                        <span class="s1">ui.div({ text: `${usage[</span><span class="s3">1</span><span class="s1">]}`, padding: [</span><span class="s3">1</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">] });</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s1">ui.div();</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(commands.length) {</span>
                <span class="s1">let u = </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s4">// demonstrate how commands are used.</span>
                <span class="s2">if </span><span class="s1">(demandedCommands._) {</span>
                    <span class="s1">u = `${base$0} &lt;${__(</span><span class="s0">'command'</span><span class="s1">)}&gt;\n`;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">u = `${base$0} [${__(</span><span class="s0">'command'</span><span class="s1">)}]\n`;</span>
                <span class="s1">}</span>
                <span class="s1">ui.div(`${u}`);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">// your application's commands, i.e., non-option</span>
        <span class="s4">// arguments populated in '_'.</span>
        <span class="s2">if </span><span class="s1">(commands.length) {</span>
            <span class="s1">ui.div(__(</span><span class="s0">'Commands:'</span><span class="s1">));</span>
            <span class="s1">const context = yargs.getContext();</span>
            <span class="s1">const parentCommands = context.commands.length ? `${context.commands.join(</span><span class="s0">' '</span><span class="s1">)} ` : </span><span class="s0">''</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(yargs.getParserConfiguration()[</span><span class="s0">'sort-commands'</span><span class="s1">] === </span><span class="s2">true</span><span class="s1">) {</span>
                <span class="s1">commands = commands.sort((a, b) =&gt; a[</span><span class="s3">0</span><span class="s1">].localeCompare(b[</span><span class="s3">0</span><span class="s1">]));</span>
            <span class="s1">}</span>
            <span class="s1">commands.forEach((command) =&gt; {</span>
                <span class="s1">const commandString = `${base$0} ${parentCommands}${command[</span><span class="s3">0</span><span class="s1">].replace(/^\$0 ?/, </span><span class="s0">''</span><span class="s1">)}`; </span><span class="s4">// drop $0 from default commands.</span>
                <span class="s1">ui.span({</span>
                    <span class="s1">text: commandString,</span>
                    <span class="s1">padding: [</span><span class="s3">0</span><span class="s1">, </span><span class="s3">2</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">2</span><span class="s1">],</span>
                    <span class="s1">width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + </span><span class="s3">4</span>
                <span class="s1">}, { text: command[</span><span class="s3">1</span><span class="s1">] });</span>
                <span class="s1">const hints = [];</span>
                <span class="s2">if </span><span class="s1">(command[</span><span class="s3">2</span><span class="s1">])</span>
                    <span class="s1">hints.push(`[${__(</span><span class="s0">'default'</span><span class="s1">)}]`);</span>
                <span class="s2">if </span><span class="s1">(command[</span><span class="s3">3</span><span class="s1">] &amp;&amp; command[</span><span class="s3">3</span><span class="s1">].length) {</span>
                    <span class="s1">hints.push(`[${__(</span><span class="s0">'aliases:'</span><span class="s1">)} ${command[</span><span class="s3">3</span><span class="s1">].join(</span><span class="s0">', '</span><span class="s1">)}]`);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(command[</span><span class="s3">4</span><span class="s1">]) {</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">command[</span><span class="s3">4</span><span class="s1">] === </span><span class="s0">'string'</span><span class="s1">) {</span>
                        <span class="s1">hints.push(`[${__(</span><span class="s0">'deprecated: %s'</span><span class="s1">, command[</span><span class="s3">4</span><span class="s1">])}]`);</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">hints.push(`[${__(</span><span class="s0">'deprecated'</span><span class="s1">)}]`);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(hints.length) {</span>
                    <span class="s1">ui.div({ text: hints.join(</span><span class="s0">' '</span><span class="s1">), padding: [</span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">2</span><span class="s1">], align: </span><span class="s0">'right' </span><span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">ui.div();</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s1">ui.div();</span>
        <span class="s1">}</span>
        <span class="s4">// perform some cleanup on the keys array, making it</span>
        <span class="s4">// only include top-level keys not their aliases.</span>
        <span class="s1">const aliasKeys = (Object.keys(options.alias) || [])</span>
            <span class="s1">.concat(Object.keys(yargs.parsed.newAliases) || []);</span>
        <span class="s1">keys = keys.filter(key =&gt; !yargs.parsed.newAliases[key] &amp;&amp; aliasKeys.every(alias =&gt; (options.alias[alias] || []).indexOf(key) === -</span><span class="s3">1</span><span class="s1">));</span>
        <span class="s4">// populate 'Options:' group with any keys that have not</span>
        <span class="s4">// explicitly had a group set.</span>
        <span class="s1">const defaultGroup = __(</span><span class="s0">'Options:'</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(!groups[defaultGroup])</span>
            <span class="s1">groups[defaultGroup] = [];</span>
        <span class="s1">addUngroupedKeys(keys, options.alias, groups, defaultGroup);</span>
        <span class="s4">// display 'Options:' table along with any custom tables:</span>
        <span class="s1">Object.keys(groups).forEach((groupName) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(!groups[groupName].length)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s4">// if we've grouped the key 'f', but 'f' aliases 'foobar',</span>
            <span class="s4">// normalizedKeys should contain only 'foobar'.</span>
            <span class="s1">const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) =&gt; {</span>
                <span class="s2">if </span><span class="s1">(~aliasKeys.indexOf(key))</span>
                    <span class="s2">return </span><span class="s1">key;</span>
                <span class="s2">for </span><span class="s1">(let i = </span><span class="s3">0</span><span class="s1">, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {</span>
                    <span class="s2">if </span><span class="s1">(~(options.alias[aliasKey] || []).indexOf(key))</span>
                        <span class="s2">return </span><span class="s1">aliasKey;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">key;</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(normalizedKeys.length &lt; </span><span class="s3">1</span><span class="s1">)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">ui.div(groupName);</span>
            <span class="s4">// actually generate the switches string --foo, -f, --bar.</span>
            <span class="s1">const switches = normalizedKeys.reduce((acc, key) =&gt; {</span>
                <span class="s1">acc[key] = [key].concat(options.alias[key] || [])</span>
                    <span class="s1">.map(sw =&gt; {</span>
                    <span class="s4">// for the special positional group don't</span>
                    <span class="s4">// add '--' or '-' prefix.</span>
                    <span class="s2">if </span><span class="s1">(groupName === self.getPositionalGroupName())</span>
                        <span class="s2">return </span><span class="s1">sw;</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s2">return </span><span class="s1">(</span>
                        <span class="s4">// matches yargs-parser logic in which single-digits</span>
                        <span class="s4">// aliases declared with a boolean type are now valid</span>
                        <span class="s1">/^[</span><span class="s3">0</span><span class="s1">-</span><span class="s3">9</span><span class="s1">]$/.test(sw)</span>
                            <span class="s1">? ~options.boolean.indexOf(key) ? </span><span class="s0">'-' </span><span class="s1">: </span><span class="s0">'--'</span>
                            <span class="s1">: sw.length &gt; </span><span class="s3">1 </span><span class="s1">? </span><span class="s0">'--' </span><span class="s1">: </span><span class="s0">'-'</span><span class="s1">) + sw;</span>
                    <span class="s1">}</span>
                <span class="s1">})</span>
                    <span class="s1">.join(</span><span class="s0">', '</span><span class="s1">);</span>
                <span class="s2">return </span><span class="s1">acc;</span>
            <span class="s1">}, {});</span>
            <span class="s1">normalizedKeys.forEach((key) =&gt; {</span>
                <span class="s1">const kswitch = switches[key];</span>
                <span class="s1">let desc = descriptions[key] || </span><span class="s0">''</span><span class="s1">;</span>
                <span class="s1">let type = </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(~desc.lastIndexOf(deferY18nLookupPrefix))</span>
                    <span class="s1">desc = __(desc.substring(deferY18nLookupPrefix.length));</span>
                <span class="s2">if </span><span class="s1">(~options.boolean.indexOf(key))</span>
                    <span class="s1">type = `[${__(</span><span class="s0">'boolean'</span><span class="s1">)}]`;</span>
                <span class="s2">if </span><span class="s1">(~options.count.indexOf(key))</span>
                    <span class="s1">type = `[${__(</span><span class="s0">'count'</span><span class="s1">)}]`;</span>
                <span class="s2">if </span><span class="s1">(~options.string.indexOf(key))</span>
                    <span class="s1">type = `[${__(</span><span class="s0">'string'</span><span class="s1">)}]`;</span>
                <span class="s2">if </span><span class="s1">(~options.normalize.indexOf(key))</span>
                    <span class="s1">type = `[${__(</span><span class="s0">'string'</span><span class="s1">)}]`;</span>
                <span class="s2">if </span><span class="s1">(~options.array.indexOf(key))</span>
                    <span class="s1">type = `[${__(</span><span class="s0">'array'</span><span class="s1">)}]`;</span>
                <span class="s2">if </span><span class="s1">(~options.number.indexOf(key))</span>
                    <span class="s1">type = `[${__(</span><span class="s0">'number'</span><span class="s1">)}]`;</span>
                <span class="s1">const deprecatedExtra = (deprecated) =&gt; </span><span class="s2">typeof </span><span class="s1">deprecated === </span><span class="s0">'string'</span>
                    <span class="s1">? `[${__(</span><span class="s0">'deprecated: %s'</span><span class="s1">, deprecated)}]`</span>
                    <span class="s1">: `[${__(</span><span class="s0">'deprecated'</span><span class="s1">)}]`;</span>
                <span class="s1">const extra = [</span>
                    <span class="s1">(key </span><span class="s2">in </span><span class="s1">deprecatedOptions) ? deprecatedExtra(deprecatedOptions[key]) : </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">type,</span>
                    <span class="s1">(key </span><span class="s2">in </span><span class="s1">demandedOptions) ? `[${__(</span><span class="s0">'required'</span><span class="s1">)}]` : </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">options.choices &amp;&amp; options.choices[key] ? `[${__(</span><span class="s0">'choices:'</span><span class="s1">)} ${self.stringifiedValues(options.choices[key])}]` : </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">defaultString(options.</span><span class="s2">default</span><span class="s1">[key], options.defaultDescription[key])</span>
                <span class="s1">].filter(Boolean).join(</span><span class="s0">' '</span><span class="s1">);</span>
                <span class="s1">ui.span({ text: kswitch, padding: [</span><span class="s3">0</span><span class="s1">, </span><span class="s3">2</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">2</span><span class="s1">], width: maxWidth(switches, theWrap) + </span><span class="s3">4 </span><span class="s1">}, desc);</span>
                <span class="s2">if </span><span class="s1">(extra)</span>
                    <span class="s1">ui.div({ text: extra, padding: [</span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">2</span><span class="s1">], align: </span><span class="s0">'right' </span><span class="s1">});</span>
                <span class="s2">else</span>
                    <span class="s1">ui.div();</span>
            <span class="s1">});</span>
            <span class="s1">ui.div();</span>
        <span class="s1">});</span>
        <span class="s4">// describe some common use-cases for your application.</span>
        <span class="s2">if </span><span class="s1">(examples.length) {</span>
            <span class="s1">ui.div(__(</span><span class="s0">'Examples:'</span><span class="s1">));</span>
            <span class="s1">examples.forEach((example) =&gt; {</span>
                <span class="s1">example[</span><span class="s3">0</span><span class="s1">] = example[</span><span class="s3">0</span><span class="s1">].replace(/\$0/g, base$0);</span>
            <span class="s1">});</span>
            <span class="s1">examples.forEach((example) =&gt; {</span>
                <span class="s2">if </span><span class="s1">(example[</span><span class="s3">1</span><span class="s1">] === </span><span class="s0">''</span><span class="s1">) {</span>
                    <span class="s1">ui.div({</span>
                        <span class="s1">text: example[</span><span class="s3">0</span><span class="s1">],</span>
                        <span class="s1">padding: [</span><span class="s3">0</span><span class="s1">, </span><span class="s3">2</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">2</span><span class="s1">]</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">ui.div({</span>
                        <span class="s1">text: example[</span><span class="s3">0</span><span class="s1">],</span>
                        <span class="s1">padding: [</span><span class="s3">0</span><span class="s1">, </span><span class="s3">2</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">2</span><span class="s1">],</span>
                        <span class="s1">width: maxWidth(examples, theWrap) + </span><span class="s3">4</span>
                    <span class="s1">}, {</span>
                        <span class="s1">text: example[</span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s1">ui.div();</span>
        <span class="s1">}</span>
        <span class="s4">// the usage string.</span>
        <span class="s2">if </span><span class="s1">(epilogs.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s1">const e = epilogs.map(epilog =&gt; epilog.replace(/\$0/g, base$0)).join(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">);</span>
            <span class="s1">ui.div(`${e}\n`);</span>
        <span class="s1">}</span>
        <span class="s4">// Remove the trailing white spaces</span>
        <span class="s2">return </span><span class="s1">ui.toString().replace(/\s*$/, </span><span class="s0">''</span><span class="s1">);</span>
    <span class="s1">};</span>
    <span class="s4">// return the maximum width of a string</span>
    <span class="s4">// in the left-hand column of a table.</span>
    <span class="s2">function </span><span class="s1">maxWidth(table, theWrap, modifier) {</span>
        <span class="s1">let width = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s4">// table might be of the form [leftColumn],</span>
        <span class="s4">// or {key: leftColumn}</span>
        <span class="s2">if </span><span class="s1">(!Array.isArray(table)) {</span>
            <span class="s1">table = Object.values(table).map(v =&gt; [v]);</span>
        <span class="s1">}</span>
        <span class="s1">table.forEach((v) =&gt; {</span>
            <span class="s1">width = Math.max(stringWidth(modifier ? `${modifier} ${v[</span><span class="s3">0</span><span class="s1">]}` : v[</span><span class="s3">0</span><span class="s1">]), width);</span>
        <span class="s1">});</span>
        <span class="s4">// if we've enabled 'wrap' we should limit</span>
        <span class="s4">// the max-width of the left-column.</span>
        <span class="s2">if </span><span class="s1">(theWrap)</span>
            <span class="s1">width = Math.min(width, parseInt((theWrap * </span><span class="s3">0.5</span><span class="s1">).toString(), </span><span class="s3">10</span><span class="s1">));</span>
        <span class="s2">return </span><span class="s1">width;</span>
    <span class="s1">}</span>
    <span class="s4">// make sure any options set for aliases,</span>
    <span class="s4">// are copied to the keys being aliased.</span>
    <span class="s2">function </span><span class="s1">normalizeAliases() {</span>
        <span class="s4">// handle old demanded API</span>
        <span class="s1">const demandedOptions = yargs.getDemandedOptions();</span>
        <span class="s1">const options = yargs.getOptions();</span>
        <span class="s1">(Object.keys(options.alias) || []).forEach((key) =&gt; {</span>
            <span class="s1">options.alias[key].forEach((alias) =&gt; {</span>
                <span class="s4">// copy descriptions.</span>
                <span class="s2">if </span><span class="s1">(descriptions[alias])</span>
                    <span class="s1">self.describe(key, descriptions[alias]);</span>
                <span class="s4">// copy demanded.</span>
                <span class="s2">if </span><span class="s1">(alias </span><span class="s2">in </span><span class="s1">demandedOptions)</span>
                    <span class="s1">yargs.demandOption(key, demandedOptions[alias]);</span>
                <span class="s4">// type messages.</span>
                <span class="s2">if </span><span class="s1">(~options.boolean.indexOf(alias))</span>
                    <span class="s1">yargs.boolean(key);</span>
                <span class="s2">if </span><span class="s1">(~options.count.indexOf(alias))</span>
                    <span class="s1">yargs.count(key);</span>
                <span class="s2">if </span><span class="s1">(~options.string.indexOf(alias))</span>
                    <span class="s1">yargs.string(key);</span>
                <span class="s2">if </span><span class="s1">(~options.normalize.indexOf(alias))</span>
                    <span class="s1">yargs.normalize(key);</span>
                <span class="s2">if </span><span class="s1">(~options.array.indexOf(alias))</span>
                    <span class="s1">yargs.array(key);</span>
                <span class="s2">if </span><span class="s1">(~options.number.indexOf(alias))</span>
                    <span class="s1">yargs.number(key);</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s4">// if yargs is executing an async handler, we take a snapshot of the</span>
    <span class="s4">// help message to display on failure:</span>
    <span class="s1">let cachedHelpMessage;</span>
    <span class="s1">self.cacheHelpMessage = </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">cachedHelpMessage = </span><span class="s2">this</span><span class="s1">.help();</span>
    <span class="s1">};</span>
    <span class="s4">// however this snapshot must be cleared afterwards</span>
    <span class="s4">// not to be be used by next calls to parse</span>
    <span class="s1">self.clearCachedHelpMessage = </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">cachedHelpMessage = undefined;</span>
    <span class="s1">};</span>
    <span class="s4">// given a set of keys, place any keys that are</span>
    <span class="s4">// ungrouped under the 'Options:' grouping.</span>
    <span class="s2">function </span><span class="s1">addUngroupedKeys(keys, aliases, groups, defaultGroup) {</span>
        <span class="s1">let groupedKeys = [];</span>
        <span class="s1">let toCheck = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">Object.keys(groups).forEach((group) =&gt; {</span>
            <span class="s1">groupedKeys = groupedKeys.concat(groups[group]);</span>
        <span class="s1">});</span>
        <span class="s1">keys.forEach((key) =&gt; {</span>
            <span class="s1">toCheck = [key].concat(aliases[key]);</span>
            <span class="s2">if </span><span class="s1">(!toCheck.some(k =&gt; groupedKeys.indexOf(k) !== -</span><span class="s3">1</span><span class="s1">)) {</span>
                <span class="s1">groups[defaultGroup].push(key);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">groupedKeys;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">filterHiddenOptions(key) {</span>
        <span class="s2">return </span><span class="s1">yargs.getOptions().hiddenOptions.indexOf(key) &lt; </span><span class="s3">0 </span><span class="s1">|| yargs.parsed.argv[yargs.getOptions().showHiddenOpt];</span>
    <span class="s1">}</span>
    <span class="s1">self.showHelp = (level) =&gt; {</span>
        <span class="s1">const logger = yargs._getLoggerInstance();</span>
        <span class="s2">if </span><span class="s1">(!level)</span>
            <span class="s1">level = </span><span class="s0">'error'</span><span class="s1">;</span>
        <span class="s1">const emit = </span><span class="s2">typeof </span><span class="s1">level === </span><span class="s0">'function' </span><span class="s1">? level : logger[level];</span>
        <span class="s1">emit(self.help());</span>
    <span class="s1">};</span>
    <span class="s1">self.functionDescription = (fn) =&gt; {</span>
        <span class="s1">const description = fn.name ? decamelize(fn.name, </span><span class="s0">'-'</span><span class="s1">) : __(</span><span class="s0">'generated-value'</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s0">'('</span><span class="s1">, description, </span><span class="s0">')'</span><span class="s1">].join(</span><span class="s0">''</span><span class="s1">);</span>
    <span class="s1">};</span>
    <span class="s1">self.stringifiedValues = </span><span class="s2">function </span><span class="s1">stringifiedValues(values, separator) {</span>
        <span class="s1">let string = </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s1">const sep = separator || </span><span class="s0">', '</span><span class="s1">;</span>
        <span class="s1">const array = [].concat(values);</span>
        <span class="s2">if </span><span class="s1">(!values || !array.length)</span>
            <span class="s2">return </span><span class="s1">string;</span>
        <span class="s1">array.forEach((value) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(string.length)</span>
                <span class="s1">string += sep;</span>
            <span class="s1">string += JSON.stringify(value);</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">string;</span>
    <span class="s1">};</span>
    <span class="s4">// format the default-value-string displayed in</span>
    <span class="s4">// the right-hand column.</span>
    <span class="s2">function </span><span class="s1">defaultString(value, defaultDescription) {</span>
        <span class="s1">let string = `[${__(</span><span class="s0">'default:'</span><span class="s1">)} `;</span>
        <span class="s2">if </span><span class="s1">(value === undefined &amp;&amp; !defaultDescription)</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(defaultDescription) {</span>
            <span class="s1">string += defaultDescription;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">switch </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value) {</span>
                <span class="s2">case </span><span class="s0">'string'</span><span class="s1">:</span>
                    <span class="s1">string += `</span><span class="s0">&quot;${value}&quot;</span><span class="s1">`;</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s0">'object'</span><span class="s1">:</span>
                    <span class="s1">string += JSON.stringify(value);</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s2">default</span><span class="s1">:</span>
                    <span class="s1">string += value;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">`${string}]`;</span>
    <span class="s1">}</span>
    <span class="s4">// guess the width of the console window, max-width 80.</span>
    <span class="s2">function </span><span class="s1">windowWidth() {</span>
        <span class="s1">const maxWidth = </span><span class="s3">80</span><span class="s1">;</span>
        <span class="s4">// CI is not a TTY</span>
        <span class="s4">/* c8 ignore next 2 */</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">process === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; process.stdout &amp;&amp; process.stdout.columns) {</span>
            <span class="s2">return </span><span class="s1">Math.min(maxWidth, process.stdout.columns);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">return </span><span class="s1">maxWidth;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// logic for displaying application version.</span>
    <span class="s1">let version = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">self.version = (ver) =&gt; {</span>
        <span class="s1">version = ver;</span>
    <span class="s1">};</span>
    <span class="s1">self.showVersion = () =&gt; {</span>
        <span class="s1">const logger = yargs._getLoggerInstance();</span>
        <span class="s1">logger.log(version);</span>
    <span class="s1">};</span>
    <span class="s1">self.reset = </span><span class="s2">function </span><span class="s1">reset(localLookup) {</span>
        <span class="s4">// do not reset wrap here</span>
        <span class="s4">// do not reset fails here</span>
        <span class="s1">failMessage = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">failureOutput = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">usages = [];</span>
        <span class="s1">usageDisabled = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">epilogs = [];</span>
        <span class="s1">examples = [];</span>
        <span class="s1">commands = [];</span>
        <span class="s1">descriptions = obj_filter_1.objFilter(descriptions, k =&gt; !localLookup[k]);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">const frozens = [];</span>
    <span class="s1">self.freeze = </span><span class="s2">function </span><span class="s1">freeze() {</span>
        <span class="s1">frozens.push({</span>
            <span class="s1">failMessage,</span>
            <span class="s1">failureOutput,</span>
            <span class="s1">usages,</span>
            <span class="s1">usageDisabled,</span>
            <span class="s1">epilogs,</span>
            <span class="s1">examples,</span>
            <span class="s1">commands,</span>
            <span class="s1">descriptions</span>
        <span class="s1">});</span>
    <span class="s1">};</span>
    <span class="s1">self.unfreeze = </span><span class="s2">function </span><span class="s1">unfreeze() {</span>
        <span class="s1">const frozen = frozens.pop();</span>
        <span class="s1">common_types_1.assertNotStrictEqual(frozen, undefined);</span>
        <span class="s1">({</span>
            <span class="s1">failMessage,</span>
            <span class="s1">failureOutput,</span>
            <span class="s1">usages,</span>
            <span class="s1">usageDisabled,</span>
            <span class="s1">epilogs,</span>
            <span class="s1">examples,</span>
            <span class="s1">commands,</span>
            <span class="s1">descriptions</span>
        <span class="s1">} = frozen);</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">self;</span>
<span class="s1">}</span>
<span class="s1">exports.usage = usage;</span>
</pre>
</body>
</html>
<html>
<head>
<title>prefer-string-starts-ends-with.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
prefer-string-starts-ends-with.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">const regexpp_1 = require(</span><span class="s0">&quot;@eslint-community/regexpp&quot;</span><span class="s1">);</span>
<span class="s1">const utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s1">const util_1 = require(</span><span class="s0">&quot;../util&quot;</span><span class="s1">);</span>
<span class="s1">const EQ_OPERATORS = /^[=!]=/;</span>
<span class="s1">const regexpp = </span><span class="s2">new </span><span class="s1">regexpp_1.RegExpParser();</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= (</span><span class="s3">0</span><span class="s1">, util_1.createRule)({</span>
    <span class="s1">name: </span><span class="s0">'prefer-string-starts-ends-with'</span><span class="s1">,</span>
    <span class="s1">defaultOptions: [],</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s0">'suggestion'</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">'Enforce using `String#startsWith` and `String#endsWith` over other equivalent methods of checking substrings'</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s0">'strict'</span><span class="s1">,</span>
            <span class="s1">requiresTypeChecking: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">messages: {</span>
            <span class="s1">preferStartsWith: </span><span class="s0">&quot;Use 'String#startsWith' method instead.&quot;</span><span class="s1">,</span>
            <span class="s1">preferEndsWith: </span><span class="s0">&quot;Use the 'String#endsWith' method instead.&quot;</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">schema: [],</span>
        <span class="s1">fixable: </span><span class="s0">'code'</span><span class="s1">,</span>
    <span class="s1">},</span>
    <span class="s1">create(context) {</span>
        <span class="s1">const globalScope = context.getScope();</span>
        <span class="s1">const sourceCode = context.getSourceCode();</span>
        <span class="s1">const service = (</span><span class="s3">0</span><span class="s1">, util_1.getParserServices)(context);</span>
        <span class="s1">const typeChecker = service.program.getTypeChecker();</span>
        <span class="s4">/** 
         * Check if a given node is a string. 
         * @param node The node to check. 
         */</span>
        <span class="s2">function </span><span class="s1">isStringType(node) {</span>
            <span class="s1">const objectType = typeChecker.getTypeAtLocation(service.esTreeNodeToTSNodeMap.get(node));</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, util_1.getTypeName)(typeChecker, objectType) === </span><span class="s0">'string'</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Check if a given node is a `Literal` node that is null. 
         * @param node The node to check. 
         */</span>
        <span class="s2">function </span><span class="s1">isNull(node) {</span>
            <span class="s1">const evaluated = (</span><span class="s3">0</span><span class="s1">, util_1.getStaticValue)(node, globalScope);</span>
            <span class="s2">return </span><span class="s1">evaluated != </span><span class="s2">null </span><span class="s1">&amp;&amp; evaluated.value == </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Check if a given node is a `Literal` node that is a given value. 
         * @param node The node to check. 
         * @param value The expected value of the `Literal` node. 
         */</span>
        <span class="s2">function </span><span class="s1">isNumber(node, value) {</span>
            <span class="s1">const evaluated = (</span><span class="s3">0</span><span class="s1">, util_1.getStaticValue)(node, globalScope);</span>
            <span class="s2">return </span><span class="s1">evaluated != </span><span class="s2">null </span><span class="s1">&amp;&amp; evaluated.value === value;</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Check if a given node is a `Literal` node that is a character. 
         * @param node The node to check. 
         * @param kind The method name to get a character. 
         */</span>
        <span class="s2">function </span><span class="s1">isCharacter(node) {</span>
            <span class="s1">const evaluated = (</span><span class="s3">0</span><span class="s1">, util_1.getStaticValue)(node, globalScope);</span>
            <span class="s2">return </span><span class="s1">(evaluated != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
                <span class="s2">typeof </span><span class="s1">evaluated.value === </span><span class="s0">'string' </span><span class="s1">&amp;&amp;</span>
                <span class="s4">// checks if the string is a character long</span>
                <span class="s1">evaluated.value[</span><span class="s3">0</span><span class="s1">] === evaluated.value);</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Check if a given node is `==`, `===`, `!=`, or `!==`. 
         * @param node The node to check. 
         */</span>
        <span class="s2">function </span><span class="s1">isEqualityComparison(node) {</span>
            <span class="s2">return </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.BinaryExpression &amp;&amp;</span>
                <span class="s1">EQ_OPERATORS.test(node.operator));</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Check if two given nodes are the same meaning. 
         * @param node1 A node to compare. 
         * @param node2 Another node to compare. 
         */</span>
        <span class="s2">function </span><span class="s1">isSameTokens(node1, node2) {</span>
            <span class="s1">const tokens1 = sourceCode.getTokens(node1);</span>
            <span class="s1">const tokens2 = sourceCode.getTokens(node2);</span>
            <span class="s2">if </span><span class="s1">(tokens1.length !== tokens2.length) {</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(let i = </span><span class="s3">0</span><span class="s1">; i &lt; tokens1.length; ++i) {</span>
                <span class="s1">const token1 = tokens1[i];</span>
                <span class="s1">const token2 = tokens2[i];</span>
                <span class="s2">if </span><span class="s1">(token1.type !== token2.type || token1.value !== token2.value) {</span>
                    <span class="s2">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Check if a given node is the expression of the length of a string. 
         * 
         * - If `length` property access of `expectedObjectNode`, it's `true`. 
         *   E.g., `foo` → `foo.length` / `&quot;foo&quot;` → `&quot;foo&quot;.length` 
         * - If `expectedObjectNode` is a string literal, `node` can be a number. 
         *   E.g., `&quot;foo&quot;` → `3` 
         * 
         * @param node The node to check. 
         * @param expectedObjectNode The node which is expected as the receiver of `length` property. 
         */</span>
        <span class="s2">function </span><span class="s1">isLengthExpression(node, expectedObjectNode) {</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.MemberExpression) {</span>
                <span class="s2">return </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, util_1.getPropertyName)(node, globalScope) === </span><span class="s0">'length' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">isSameTokens(node.object, expectedObjectNode));</span>
            <span class="s1">}</span>
            <span class="s1">const evaluatedLength = (</span><span class="s3">0</span><span class="s1">, util_1.getStaticValue)(node, globalScope);</span>
            <span class="s1">const evaluatedString = (</span><span class="s3">0</span><span class="s1">, util_1.getStaticValue)(expectedObjectNode, globalScope);</span>
            <span class="s2">return </span><span class="s1">(evaluatedLength != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
                <span class="s1">evaluatedString != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
                <span class="s2">typeof </span><span class="s1">evaluatedLength.value === </span><span class="s0">'number' </span><span class="s1">&amp;&amp;</span>
                <span class="s2">typeof </span><span class="s1">evaluatedString.value === </span><span class="s0">'string' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">evaluatedLength.value === evaluatedString.value.length);</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Check if a given node is a negative index expression 
         * 
         * E.g. `s.slice(- &lt;expr&gt;)`, `s.substring(s.length - &lt;expr&gt;)` 
         * 
         * @param node The node to check. 
         * @param expectedIndexedNode The node which is expected as the receiver of index expression. 
         */</span>
        <span class="s2">function </span><span class="s1">isNegativeIndexExpression(node, expectedIndexedNode) {</span>
            <span class="s2">return </span><span class="s1">((node.type === utils_1.AST_NODE_TYPES.UnaryExpression &amp;&amp;</span>
                <span class="s1">node.operator === </span><span class="s0">'-'</span><span class="s1">) ||</span>
                <span class="s1">(node.type === utils_1.AST_NODE_TYPES.BinaryExpression &amp;&amp;</span>
                    <span class="s1">node.operator === </span><span class="s0">'-' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">isLengthExpression(node.left, expectedIndexedNode)));</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Check if a given node is the expression of the last index. 
         * 
         * E.g. `foo.length - 1` 
         * 
         * @param node The node to check. 
         * @param expectedObjectNode The node which is expected as the receiver of `length` property. 
         */</span>
        <span class="s2">function </span><span class="s1">isLastIndexExpression(node, expectedObjectNode) {</span>
            <span class="s2">return </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.BinaryExpression &amp;&amp;</span>
                <span class="s1">node.operator === </span><span class="s0">'-' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">isLengthExpression(node.left, expectedObjectNode) &amp;&amp;</span>
                <span class="s1">isNumber(node.right, </span><span class="s3">1</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Get the range of the property of a given `MemberExpression` node. 
         * 
         * - `obj[foo]` → the range of `[foo]` 
         * - `obf.foo` → the range of `.foo` 
         * - `(obj).foo` → the range of `.foo` 
         * 
         * @param node The member expression node to get. 
         */</span>
        <span class="s2">function </span><span class="s1">getPropertyRange(node) {</span>
            <span class="s1">const dotOrOpenBracket = sourceCode.getTokenAfter(node.object, util_1.isNotClosingParenToken);</span>
            <span class="s2">return </span><span class="s1">[dotOrOpenBracket.range[</span><span class="s3">0</span><span class="s1">], node.range[</span><span class="s3">1</span><span class="s1">]];</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Parse a given `RegExp` pattern to that string if it's a static string. 
         * @param pattern The RegExp pattern text to parse. 
         * @param uFlag The Unicode flag of the RegExp. 
         */</span>
        <span class="s2">function </span><span class="s1">parseRegExpText(pattern, uFlag) {</span>
            <span class="s4">// Parse it.</span>
            <span class="s1">const ast = regexpp.parsePattern(pattern, undefined, undefined, uFlag);</span>
            <span class="s2">if </span><span class="s1">(ast.alternatives.length !== </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// Drop `^`/`$` assertion.</span>
            <span class="s1">const chars = ast.alternatives[</span><span class="s3">0</span><span class="s1">].elements;</span>
            <span class="s1">const first = chars[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s2">if </span><span class="s1">(first.type === </span><span class="s0">'Assertion' </span><span class="s1">&amp;&amp; first.kind === </span><span class="s0">'start'</span><span class="s1">) {</span>
                <span class="s1">chars.shift();</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">chars.pop();</span>
            <span class="s1">}</span>
            <span class="s4">// Check if it can determine a unique string.</span>
            <span class="s2">if </span><span class="s1">(!chars.every(c =&gt; c.type === </span><span class="s0">'Character'</span><span class="s1">)) {</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// To string.</span>
            <span class="s2">return </span><span class="s1">String.fromCodePoint(...chars.map(c =&gt; c.value));</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Parse a given node if it's a `RegExp` instance. 
         * @param node The node to parse. 
         */</span>
        <span class="s2">function </span><span class="s1">parseRegExp(node) {</span>
            <span class="s1">const evaluated = (</span><span class="s3">0</span><span class="s1">, util_1.getStaticValue)(node, globalScope);</span>
            <span class="s2">if </span><span class="s1">(evaluated == </span><span class="s2">null </span><span class="s1">|| !(evaluated.value </span><span class="s2">instanceof </span><span class="s1">RegExp)) {</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">const { source, flags } = evaluated.value;</span>
            <span class="s1">const isStartsWith = source.startsWith(</span><span class="s0">'^'</span><span class="s1">);</span>
            <span class="s1">const isEndsWith = source.endsWith(</span><span class="s0">'$'</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(isStartsWith === isEndsWith ||</span>
                <span class="s1">flags.includes(</span><span class="s0">'i'</span><span class="s1">) ||</span>
                <span class="s1">flags.includes(</span><span class="s0">'m'</span><span class="s1">)) {</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">const text = parseRegExpText(source, flags.includes(</span><span class="s0">'u'</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(text == </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">{ isEndsWith, isStartsWith, text };</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">getLeftNode(node) {</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.ChainExpression) {</span>
                <span class="s2">return </span><span class="s1">getLeftNode(node.expression);</span>
            <span class="s1">}</span>
            <span class="s1">let leftNode;</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.CallExpression) {</span>
                <span class="s1">leftNode = node.callee;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">leftNode = node;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(leftNode.type !== utils_1.AST_NODE_TYPES.MemberExpression) {</span>
                <span class="s2">throw new </span><span class="s1">Error(`Expected a MemberExpression, got ${leftNode.type}`);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">leftNode;</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Fix code with using the right operand as the search string. 
         * For example: `foo.slice(0, 3) === 'bar'` → `foo.startsWith('bar')` 
         * @param fixer The rule fixer. 
         * @param node The node which was reported. 
         * @param kind The kind of the report. 
         * @param isNegative The flag to fix to negative condition. 
         */</span>
        <span class="s2">function</span><span class="s1">* fixWithRightOperand(fixer, node, kind, isNegative, isOptional) {</span>
            <span class="s4">// left is CallExpression or MemberExpression.</span>
            <span class="s1">const leftNode = getLeftNode(node.left);</span>
            <span class="s1">const propertyRange = getPropertyRange(leftNode);</span>
            <span class="s2">if </span><span class="s1">(isNegative) {</span>
                <span class="s1">yield fixer.insertTextBefore(node, </span><span class="s0">'!'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">yield fixer.replaceTextRange([propertyRange[</span><span class="s3">0</span><span class="s1">], node.right.range[</span><span class="s3">0</span><span class="s1">]], `${isOptional ? </span><span class="s0">'?.' </span><span class="s1">: </span><span class="s0">'.'</span><span class="s1">}${kind}sWith(`);</span>
            <span class="s1">yield fixer.replaceTextRange([node.right.range[</span><span class="s3">1</span><span class="s1">], node.range[</span><span class="s3">1</span><span class="s1">]], </span><span class="s0">')'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Fix code with using the first argument as the search string. 
         * For example: `foo.indexOf('bar') === 0` → `foo.startsWith('bar')` 
         * @param fixer The rule fixer. 
         * @param node The node which was reported. 
         * @param kind The kind of the report. 
         * @param negative The flag to fix to negative condition. 
         */</span>
        <span class="s2">function</span><span class="s1">* fixWithArgument(fixer, node, callNode, calleeNode, kind, negative, isOptional) {</span>
            <span class="s2">if </span><span class="s1">(negative) {</span>
                <span class="s1">yield fixer.insertTextBefore(node, </span><span class="s0">'!'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">yield fixer.replaceTextRange(getPropertyRange(calleeNode), `${isOptional ? </span><span class="s0">'?.' </span><span class="s1">: </span><span class="s0">'.'</span><span class="s1">}${kind}sWith`);</span>
            <span class="s1">yield fixer.removeRange([callNode.range[</span><span class="s3">1</span><span class="s1">], node.range[</span><span class="s3">1</span><span class="s1">]]);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">getParent(node) {</span>
            <span class="s2">var </span><span class="s1">_a;</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(((_a = node.parent) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _a.type) === utils_1.AST_NODE_TYPES.ChainExpression</span>
                <span class="s1">? node.parent.parent</span>
                <span class="s1">: node.parent, util_1.NullThrowsReasons.MissingParent);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s4">// foo[0] === &quot;a&quot;</span>
            <span class="s4">// foo.charAt(0) === &quot;a&quot;</span>
            <span class="s4">// foo[foo.length - 1] === &quot;a&quot;</span>
            <span class="s4">// foo.charAt(foo.length - 1) === &quot;a&quot;</span>
            <span class="s1">[[</span>
                <span class="s0">'BinaryExpression &gt; MemberExpression.left[computed=true]'</span><span class="s1">,</span>
                <span class="s0">'BinaryExpression &gt; CallExpression.left &gt; MemberExpression.callee[property.name=&quot;charAt&quot;][computed=false]'</span><span class="s1">,</span>
                <span class="s0">'BinaryExpression &gt; ChainExpression.left &gt; MemberExpression[computed=true]'</span><span class="s1">,</span>
                <span class="s0">'BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression.callee[property.name=&quot;charAt&quot;][computed=false]'</span><span class="s1">,</span>
            <span class="s1">].join(</span><span class="s0">', '</span><span class="s1">)](node) {</span>
                <span class="s1">let parentNode = getParent(node);</span>
                <span class="s1">let indexNode = </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">((parentNode === </span><span class="s2">null </span><span class="s1">|| parentNode === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: parentNode.type) === utils_1.AST_NODE_TYPES.CallExpression) {</span>
                    <span class="s2">if </span><span class="s1">(parentNode.arguments.length === </span><span class="s3">1</span><span class="s1">) {</span>
                        <span class="s1">indexNode = parentNode.arguments[</span><span class="s3">0</span><span class="s1">];</span>
                    <span class="s1">}</span>
                    <span class="s1">parentNode = getParent(parentNode);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">indexNode = node.property;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(indexNode == </span><span class="s2">null </span><span class="s1">||</span>
                    <span class="s1">!isEqualityComparison(parentNode) ||</span>
                    <span class="s1">!isStringType(node.object)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">const isEndsWith = isLastIndexExpression(indexNode, node.object);</span>
                <span class="s1">const isStartsWith = !isEndsWith &amp;&amp; isNumber(indexNode, </span><span class="s3">0</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(!isStartsWith &amp;&amp; !isEndsWith) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">const eqNode = parentNode;</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node: parentNode,</span>
                    <span class="s1">messageId: isStartsWith ? </span><span class="s0">'preferStartsWith' </span><span class="s1">: </span><span class="s0">'preferEndsWith'</span><span class="s1">,</span>
                    <span class="s1">fix(fixer) {</span>
                        <span class="s4">// Don't fix if it can change the behavior.</span>
                        <span class="s2">if </span><span class="s1">(!isCharacter(eqNode.right)) {</span>
                            <span class="s2">return null</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s2">return </span><span class="s1">fixWithRightOperand(fixer, eqNode, isStartsWith ? </span><span class="s0">'start' </span><span class="s1">: </span><span class="s0">'end'</span><span class="s1">, eqNode.operator.startsWith(</span><span class="s0">'!'</span><span class="s1">), node.optional);</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
            <span class="s4">// foo.indexOf('bar') === 0</span>
            <span class="s1">[[</span>
                <span class="s0">'BinaryExpression &gt; CallExpression.left &gt; MemberExpression.callee[property.name=&quot;indexOf&quot;][computed=false]'</span><span class="s1">,</span>
                <span class="s0">'BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression.callee[property.name=&quot;indexOf&quot;][computed=false]'</span><span class="s1">,</span>
            <span class="s1">].join(</span><span class="s0">', '</span><span class="s1">)](node) {</span>
                <span class="s1">const callNode = getParent(node);</span>
                <span class="s1">const parentNode = getParent(callNode);</span>
                <span class="s2">if </span><span class="s1">(callNode.arguments.length !== </span><span class="s3">1 </span><span class="s1">||</span>
                    <span class="s1">!isEqualityComparison(parentNode) ||</span>
                    <span class="s1">!isNumber(parentNode.right, </span><span class="s3">0</span><span class="s1">) ||</span>
                    <span class="s1">!isStringType(node.object)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node: parentNode,</span>
                    <span class="s1">messageId: </span><span class="s0">'preferStartsWith'</span><span class="s1">,</span>
                    <span class="s1">fix(fixer) {</span>
                        <span class="s2">return </span><span class="s1">fixWithArgument(fixer, parentNode, callNode, node, </span><span class="s0">'start'</span><span class="s1">, parentNode.operator.startsWith(</span><span class="s0">'!'</span><span class="s1">), node.optional);</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
            <span class="s4">// foo.lastIndexOf('bar') === foo.length - 3</span>
            <span class="s4">// foo.lastIndexOf(bar) === foo.length - bar.length</span>
            <span class="s1">[[</span>
                <span class="s0">'BinaryExpression &gt; CallExpression.left &gt; MemberExpression.callee[property.name=&quot;lastIndexOf&quot;][computed=false]'</span><span class="s1">,</span>
                <span class="s0">'BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression.callee[property.name=&quot;lastIndexOf&quot;][computed=false]'</span><span class="s1">,</span>
            <span class="s1">].join(</span><span class="s0">', '</span><span class="s1">)](node) {</span>
                <span class="s1">const callNode = getParent(node);</span>
                <span class="s1">const parentNode = getParent(callNode);</span>
                <span class="s2">if </span><span class="s1">(callNode.arguments.length !== </span><span class="s3">1 </span><span class="s1">||</span>
                    <span class="s1">!isEqualityComparison(parentNode) ||</span>
                    <span class="s1">parentNode.right.type !== utils_1.AST_NODE_TYPES.BinaryExpression ||</span>
                    <span class="s1">parentNode.right.operator !== </span><span class="s0">'-' </span><span class="s1">||</span>
                    <span class="s1">!isLengthExpression(parentNode.right.left, node.object) ||</span>
                    <span class="s1">!isLengthExpression(parentNode.right.right, callNode.arguments[</span><span class="s3">0</span><span class="s1">]) ||</span>
                    <span class="s1">!isStringType(node.object)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node: parentNode,</span>
                    <span class="s1">messageId: </span><span class="s0">'preferEndsWith'</span><span class="s1">,</span>
                    <span class="s1">fix(fixer) {</span>
                        <span class="s2">return </span><span class="s1">fixWithArgument(fixer, parentNode, callNode, node, </span><span class="s0">'end'</span><span class="s1">, parentNode.operator.startsWith(</span><span class="s0">'!'</span><span class="s1">), node.optional);</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
            <span class="s4">// foo.match(/^bar/) === null</span>
            <span class="s4">// foo.match(/bar$/) === null</span>
            <span class="s1">[[</span>
                <span class="s0">'BinaryExpression &gt; CallExpression.left &gt; MemberExpression.callee[property.name=&quot;match&quot;][computed=false]'</span><span class="s1">,</span>
                <span class="s0">'BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression.callee[property.name=&quot;match&quot;][computed=false]'</span><span class="s1">,</span>
            <span class="s1">].join(</span><span class="s0">', '</span><span class="s1">)](node) {</span>
                <span class="s1">const callNode = getParent(node);</span>
                <span class="s1">const parentNode = getParent(callNode);</span>
                <span class="s2">if </span><span class="s1">(!isEqualityComparison(parentNode) ||</span>
                    <span class="s1">!isNull(parentNode.right) ||</span>
                    <span class="s1">!isStringType(node.object)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">const parsed = callNode.arguments.length === </span><span class="s3">1</span>
                    <span class="s1">? parseRegExp(callNode.arguments[</span><span class="s3">0</span><span class="s1">])</span>
                    <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(parsed == </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">const { isStartsWith, text } = parsed;</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node: callNode,</span>
                    <span class="s1">messageId: isStartsWith ? </span><span class="s0">'preferStartsWith' </span><span class="s1">: </span><span class="s0">'preferEndsWith'</span><span class="s1">,</span>
                    <span class="s1">*fix(fixer) {</span>
                        <span class="s2">if </span><span class="s1">(!parentNode.operator.startsWith(</span><span class="s0">'!'</span><span class="s1">)) {</span>
                            <span class="s1">yield fixer.insertTextBefore(parentNode, </span><span class="s0">'!'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s1">yield fixer.replaceTextRange(getPropertyRange(node), `${node.optional ? </span><span class="s0">'?.' </span><span class="s1">: </span><span class="s0">'.'</span><span class="s1">}${isStartsWith ? </span><span class="s0">'start' </span><span class="s1">: </span><span class="s0">'end'</span><span class="s1">}sWith`);</span>
                        <span class="s1">yield fixer.replaceText(callNode.arguments[</span><span class="s3">0</span><span class="s1">], JSON.stringify(text));</span>
                        <span class="s1">yield fixer.removeRange([callNode.range[</span><span class="s3">1</span><span class="s1">], parentNode.range[</span><span class="s3">1</span><span class="s1">]]);</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
            <span class="s4">// foo.slice(0, 3) === 'bar'</span>
            <span class="s4">// foo.slice(-3) === 'bar'</span>
            <span class="s4">// foo.slice(-3, foo.length) === 'bar'</span>
            <span class="s4">// foo.substring(0, 3) === 'bar'</span>
            <span class="s4">// foo.substring(foo.length - 3) === 'bar'</span>
            <span class="s4">// foo.substring(foo.length - 3, foo.length) === 'bar'</span>
            <span class="s1">[[</span>
                <span class="s0">'BinaryExpression &gt; CallExpression.left &gt; MemberExpression.callee[property.name=&quot;slice&quot;][computed=false]'</span><span class="s1">,</span>
                <span class="s0">'BinaryExpression &gt; CallExpression.left &gt; MemberExpression.callee[property.name=&quot;substring&quot;][computed=false]'</span><span class="s1">,</span>
                <span class="s0">'BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression.callee[property.name=&quot;slice&quot;][computed=false]'</span><span class="s1">,</span>
                <span class="s0">'BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression.callee[property.name=&quot;substring&quot;][computed=false]'</span><span class="s1">,</span>
            <span class="s1">].join(</span><span class="s0">', '</span><span class="s1">)](node) {</span>
                <span class="s1">const callNode = getParent(node);</span>
                <span class="s1">const parentNode = getParent(callNode);</span>
                <span class="s2">if </span><span class="s1">(!isEqualityComparison(parentNode) || !isStringType(node.object)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">const isEndsWith = (callNode.arguments.length === </span><span class="s3">1 </span><span class="s1">||</span>
                    <span class="s1">(callNode.arguments.length === </span><span class="s3">2 </span><span class="s1">&amp;&amp;</span>
                        <span class="s1">isLengthExpression(callNode.arguments[</span><span class="s3">1</span><span class="s1">], node.object))) &amp;&amp;</span>
                    <span class="s1">isNegativeIndexExpression(callNode.arguments[</span><span class="s3">0</span><span class="s1">], node.object);</span>
                <span class="s1">const isStartsWith = !isEndsWith &amp;&amp;</span>
                    <span class="s1">callNode.arguments.length === </span><span class="s3">2 </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">isNumber(callNode.arguments[</span><span class="s3">0</span><span class="s1">], </span><span class="s3">0</span><span class="s1">) &amp;&amp;</span>
                    <span class="s1">!isNegativeIndexExpression(callNode.arguments[</span><span class="s3">1</span><span class="s1">], node.object);</span>
                <span class="s2">if </span><span class="s1">(!isStartsWith &amp;&amp; !isEndsWith) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">const eqNode = parentNode;</span>
                <span class="s1">const negativeIndexSupported = node.property.name === </span><span class="s0">'slice'</span><span class="s1">;</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node: parentNode,</span>
                    <span class="s1">messageId: isStartsWith ? </span><span class="s0">'preferStartsWith' </span><span class="s1">: </span><span class="s0">'preferEndsWith'</span><span class="s1">,</span>
                    <span class="s1">fix(fixer) {</span>
                        <span class="s4">// Don't fix if it can change the behavior.</span>
                        <span class="s2">if </span><span class="s1">(eqNode.operator.length === </span><span class="s3">2 </span><span class="s1">&amp;&amp;</span>
                            <span class="s1">(eqNode.right.type !== utils_1.AST_NODE_TYPES.Literal ||</span>
                                <span class="s2">typeof </span><span class="s1">eqNode.right.value !== </span><span class="s0">'string'</span><span class="s1">)) {</span>
                            <span class="s2">return null</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s4">// code being checked is likely mistake:</span>
                        <span class="s4">// unequal length of strings being checked for equality</span>
                        <span class="s4">// or reliant on behavior of substring (negative indices interpreted as 0)</span>
                        <span class="s2">if </span><span class="s1">(isStartsWith) {</span>
                            <span class="s2">if </span><span class="s1">(!isLengthExpression(callNode.arguments[</span><span class="s3">1</span><span class="s1">], eqNode.right)) {</span>
                                <span class="s2">return null</span><span class="s1">;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">const posNode = callNode.arguments[</span><span class="s3">0</span><span class="s1">];</span>
                            <span class="s1">const posNodeIsAbsolutelyValid = (posNode.type === utils_1.AST_NODE_TYPES.BinaryExpression &amp;&amp;</span>
                                <span class="s1">posNode.operator === </span><span class="s0">'-' </span><span class="s1">&amp;&amp;</span>
                                <span class="s1">isLengthExpression(posNode.left, node.object) &amp;&amp;</span>
                                <span class="s1">isLengthExpression(posNode.right, eqNode.right)) ||</span>
                                <span class="s1">(negativeIndexSupported &amp;&amp;</span>
                                    <span class="s1">posNode.type === utils_1.AST_NODE_TYPES.UnaryExpression &amp;&amp;</span>
                                    <span class="s1">posNode.operator === </span><span class="s0">'-' </span><span class="s1">&amp;&amp;</span>
                                    <span class="s1">isLengthExpression(posNode.argument, eqNode.right));</span>
                            <span class="s2">if </span><span class="s1">(!posNodeIsAbsolutelyValid) {</span>
                                <span class="s2">return null</span><span class="s1">;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s2">return </span><span class="s1">fixWithRightOperand(fixer, parentNode, isStartsWith ? </span><span class="s0">'start' </span><span class="s1">: </span><span class="s0">'end'</span><span class="s1">, parentNode.operator.startsWith(</span><span class="s0">'!'</span><span class="s1">), node.optional);</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
            <span class="s4">// /^bar/.test(foo)</span>
            <span class="s4">// /bar$/.test(foo)</span>
            <span class="s0">'CallExpression &gt; MemberExpression.callee[property.name=&quot;test&quot;][computed=false]'</span><span class="s1">(node) {</span>
                <span class="s1">const callNode = getParent(node);</span>
                <span class="s1">const parsed = callNode.arguments.length === </span><span class="s3">1 </span><span class="s1">? parseRegExp(node.object) : </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(parsed == </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">const { isStartsWith, text } = parsed;</span>
                <span class="s1">const messageId = isStartsWith ? </span><span class="s0">'preferStartsWith' </span><span class="s1">: </span><span class="s0">'preferEndsWith'</span><span class="s1">;</span>
                <span class="s1">const methodName = isStartsWith ? </span><span class="s0">'startsWith' </span><span class="s1">: </span><span class="s0">'endsWith'</span><span class="s1">;</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node: callNode,</span>
                    <span class="s1">messageId,</span>
                    <span class="s1">*fix(fixer) {</span>
                        <span class="s1">const argNode = callNode.arguments[</span><span class="s3">0</span><span class="s1">];</span>
                        <span class="s1">const needsParen = argNode.type !== utils_1.AST_NODE_TYPES.Literal &amp;&amp;</span>
                            <span class="s1">argNode.type !== utils_1.AST_NODE_TYPES.TemplateLiteral &amp;&amp;</span>
                            <span class="s1">argNode.type !== utils_1.AST_NODE_TYPES.Identifier &amp;&amp;</span>
                            <span class="s1">argNode.type !== utils_1.AST_NODE_TYPES.MemberExpression &amp;&amp;</span>
                            <span class="s1">argNode.type !== utils_1.AST_NODE_TYPES.CallExpression;</span>
                        <span class="s1">yield fixer.removeRange([callNode.range[</span><span class="s3">0</span><span class="s1">], argNode.range[</span><span class="s3">0</span><span class="s1">]]);</span>
                        <span class="s2">if </span><span class="s1">(needsParen) {</span>
                            <span class="s1">yield fixer.insertTextBefore(argNode, </span><span class="s0">'('</span><span class="s1">);</span>
                            <span class="s1">yield fixer.insertTextAfter(argNode, </span><span class="s0">')'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s1">yield fixer.insertTextAfter(argNode, `${node.optional ? </span><span class="s0">'?.' </span><span class="s1">: </span><span class="s0">'.'</span><span class="s1">}${methodName}(${JSON.stringify(text)}`);</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
        <span class="s1">};</span>
    <span class="s1">},</span>
<span class="s1">});</span>
<span class="s4">//# sourceMappingURL=prefer-string-starts-ends-with.js.map</span></pre>
</body>
</html>
<html>
<head>
<title>config-array-factory.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
config-array-factory.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @fileoverview The factory of `ConfigArray` objects. 
 * 
 * This class provides methods to create `ConfigArray` instance. 
 * 
 * - `create(configData, options)` 
 *     Create a `ConfigArray` instance from a config data. This is to handle CLI 
 *     options except `--config`. 
 * - `loadFile(filePath, options)` 
 *     Create a `ConfigArray` instance from a config file. This is to handle 
 *     `--config` option. If the file was not found, throws the following error: 
 *      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error. 
 *      - If the filename was `package.json`, an IO error or an 
 *        `ESLINT_CONFIG_FIELD_NOT_FOUND` error. 
 *      - Otherwise, an IO error such as `ENOENT`. 
 * - `loadInDirectory(directoryPath, options)` 
 *     Create a `ConfigArray` instance from a config file which is on a given 
 *     directory. This tries to load `.eslintrc.*` or `package.json`. If not 
 *     found, returns an empty `ConfigArray`. 
 * - `loadESLintIgnore(filePath)` 
 *     Create a `ConfigArray` instance from a config file that is `.eslintignore` 
 *     format. This is to handle `--ignore-path` option. 
 * - `loadDefaultESLintIgnore()` 
 *     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in 
 *     the current working directory. 
 * 
 * `ConfigArrayFactory` class has the responsibility that loads configuration 
 * files, including loading `extends`, `parser`, and `plugins`. The created 
 * `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`. 
 * 
 * But this class doesn't handle cascading. `CascadingConfigArrayFactory` class 
 * handles cascading and hierarchy. 
 * 
 * @author Toru Nagashima &lt;https://github.com/mysticatea&gt; 
 */</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s1">import debugOrig from </span><span class="s2">&quot;debug&quot;</span><span class="s1">;</span>
<span class="s1">import fs from </span><span class="s2">&quot;fs&quot;</span><span class="s1">;</span>
<span class="s1">import importFresh from </span><span class="s2">&quot;import-fresh&quot;</span><span class="s1">;</span>
<span class="s1">import { createRequire } from </span><span class="s2">&quot;module&quot;</span><span class="s1">;</span>
<span class="s1">import path from </span><span class="s2">&quot;path&quot;</span><span class="s1">;</span>
<span class="s1">import stripComments from </span><span class="s2">&quot;strip-json-comments&quot;</span><span class="s1">;</span>

<span class="s1">import {</span>
    <span class="s1">ConfigArray,</span>
    <span class="s1">ConfigDependency,</span>
    <span class="s1">IgnorePattern,</span>
    <span class="s1">OverrideTester</span>
<span class="s1">} from </span><span class="s2">&quot;./config-array/index.js&quot;</span><span class="s1">;</span>
<span class="s1">import ConfigValidator from </span><span class="s2">&quot;./shared/config-validator.js&quot;</span><span class="s1">;</span>
<span class="s1">import * as naming from </span><span class="s2">&quot;./shared/naming.js&quot;</span><span class="s1">;</span>
<span class="s1">import * as ModuleResolver from </span><span class="s2">&quot;./shared/relative-module-resolver.js&quot;</span><span class="s1">;</span>

<span class="s1">const require = createRequire(import.meta.url);</span>

<span class="s1">const debug = debugOrig(</span><span class="s2">&quot;eslintrc:config-array-factory&quot;</span><span class="s1">);</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Helpers</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s1">const configFilenames = [</span>
    <span class="s2">&quot;.eslintrc.js&quot;</span><span class="s1">,</span>
    <span class="s2">&quot;.eslintrc.cjs&quot;</span><span class="s1">,</span>
    <span class="s2">&quot;.eslintrc.yaml&quot;</span><span class="s1">,</span>
    <span class="s2">&quot;.eslintrc.yml&quot;</span><span class="s1">,</span>
    <span class="s2">&quot;.eslintrc.json&quot;</span><span class="s1">,</span>
    <span class="s2">&quot;.eslintrc&quot;</span><span class="s1">,</span>
    <span class="s2">&quot;package.json&quot;</span>
<span class="s1">];</span>

<span class="s0">// Define types for VSCode IntelliSense.</span>
<span class="s0">/** @typedef {import(&quot;./shared/types&quot;).ConfigData} ConfigData */</span>
<span class="s0">/** @typedef {import(&quot;./shared/types&quot;).OverrideConfigData} OverrideConfigData */</span>
<span class="s0">/** @typedef {import(&quot;./shared/types&quot;).Parser} Parser */</span>
<span class="s0">/** @typedef {import(&quot;./shared/types&quot;).Plugin} Plugin */</span>
<span class="s0">/** @typedef {import(&quot;./shared/types&quot;).Rule} Rule */</span>
<span class="s0">/** @typedef {import(&quot;./config-array/config-dependency&quot;).DependentParser} DependentParser */</span>
<span class="s0">/** @typedef {import(&quot;./config-array/config-dependency&quot;).DependentPlugin} DependentPlugin */</span>
<span class="s0">/** @typedef {ConfigArray[0]} ConfigArrayElement */</span>

<span class="s0">/** 
 * @typedef {Object} ConfigArrayFactoryOptions 
 * @property {Map&lt;string,Plugin&gt;} [additionalPluginPool] The map for additional plugins. 
 * @property {string} [cwd] The path to the current working directory. 
 * @property {string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`. 
 * @property {Map&lt;string,Rule&gt;} builtInRules The rules that are built in to ESLint. 
 * @property {Object} [resolver=ModuleResolver] The module resolver object. 
 * @property {string} eslintAllPath The path to the definitions for eslint:all. 
 * @property {Function} getEslintAllConfig Returns the config data for eslint:all. 
 * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended. 
 * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended. 
 */</span>

<span class="s0">/** 
 * @typedef {Object} ConfigArrayFactoryInternalSlots 
 * @property {Map&lt;string,Plugin&gt;} additionalPluginPool The map for additional plugins. 
 * @property {string} cwd The path to the current working directory. 
 * @property {string | undefined} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from. 
 * @property {Map&lt;string,Rule&gt;} builtInRules The rules that are built in to ESLint. 
 * @property {Object} [resolver=ModuleResolver] The module resolver object. 
 * @property {string} eslintAllPath The path to the definitions for eslint:all. 
 * @property {Function} getEslintAllConfig Returns the config data for eslint:all. 
 * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended. 
 * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended. 
 */</span>

<span class="s0">/** 
 * @typedef {Object} ConfigArrayFactoryLoadingContext 
 * @property {string} filePath The path to the current configuration. 
 * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`. 
 * @property {string} name The name of the current configuration. 
 * @property {string} pluginBasePath The base path to resolve plugins. 
 * @property {&quot;config&quot; | &quot;ignore&quot; | &quot;implicit-processor&quot;} type The type of the current configuration. This is `&quot;config&quot;` in normal. This is `&quot;ignore&quot;` if it came from `.eslintignore`. This is `&quot;implicit-processor&quot;` if it came from legacy file-extension processors. 
 */</span>

<span class="s0">/** 
 * @typedef {Object} ConfigArrayFactoryLoadingContext 
 * @property {string} filePath The path to the current configuration. 
 * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`. 
 * @property {string} name The name of the current configuration. 
 * @property {&quot;config&quot; | &quot;ignore&quot; | &quot;implicit-processor&quot;} type The type of the current configuration. This is `&quot;config&quot;` in normal. This is `&quot;ignore&quot;` if it came from `.eslintignore`. This is `&quot;implicit-processor&quot;` if it came from legacy file-extension processors. 
 */</span>

<span class="s0">/** @type {WeakMap&lt;ConfigArrayFactory, ConfigArrayFactoryInternalSlots&gt;} */</span>
<span class="s1">const internalSlotsMap = </span><span class="s3">new </span><span class="s1">WeakMap();</span>

<span class="s0">/** @type {WeakMap&lt;object, Plugin&gt;} */</span>
<span class="s1">const normalizedPlugins = </span><span class="s3">new </span><span class="s1">WeakMap();</span>

<span class="s0">/** 
 * Check if a given string is a file path. 
 * @param {string} nameOrPath A module name or file path. 
 * @returns {boolean} `true` if the `nameOrPath` is a file path. 
 */</span>
<span class="s3">function </span><span class="s1">isFilePath(nameOrPath) {</span>
    <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">/^\.{</span><span class="s4">1</span><span class="s1">,</span><span class="s4">2</span><span class="s1">}[/\\]/u.test(nameOrPath) ||</span>
        <span class="s1">path.isAbsolute(nameOrPath)</span>
    <span class="s1">);</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Convenience wrapper for synchronously reading file contents. 
 * @param {string} filePath The filename to read. 
 * @returns {string} The file contents, with the BOM removed. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">readFile(filePath) {</span>
    <span class="s3">return </span><span class="s1">fs.readFileSync(filePath, </span><span class="s2">&quot;utf8&quot;</span><span class="s1">).replace(/^\ufeff/u, </span><span class="s2">&quot;&quot;</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Loads a YAML configuration from a file. 
 * @param {string} filePath The filename to load. 
 * @returns {ConfigData} The configuration object from the file. 
 * @throws {Error} If the file cannot be read. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">loadYAMLConfigFile(filePath) {</span>
    <span class="s1">debug(`Loading YAML config file: ${filePath}`);</span>

    <span class="s0">// lazy load YAML to improve performance when not used</span>
    <span class="s1">const yaml = require(</span><span class="s2">&quot;js-yaml&quot;</span><span class="s1">);</span>

    <span class="s3">try </span><span class="s1">{</span>

        <span class="s0">// empty YAML file can be null, so always use</span>
        <span class="s3">return </span><span class="s1">yaml.load(readFile(filePath)) || {};</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
        <span class="s1">debug(`Error reading YAML file: ${filePath}`);</span>
        <span class="s1">e.message = `Cannot read config file: ${filePath}\nError: ${e.message}`;</span>
        <span class="s3">throw </span><span class="s1">e;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Loads a JSON configuration from a file. 
 * @param {string} filePath The filename to load. 
 * @returns {ConfigData} The configuration object from the file. 
 * @throws {Error} If the file cannot be read. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">loadJSONConfigFile(filePath) {</span>
    <span class="s1">debug(`Loading JSON config file: ${filePath}`);</span>

    <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">JSON.parse(stripComments(readFile(filePath)));</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
        <span class="s1">debug(`Error reading JSON file: ${filePath}`);</span>
        <span class="s1">e.message = `Cannot read config file: ${filePath}\nError: ${e.message}`;</span>
        <span class="s1">e.messageTemplate = </span><span class="s2">&quot;failed-to-read-json&quot;</span><span class="s1">;</span>
        <span class="s1">e.messageData = {</span>
            <span class="s1">path: filePath,</span>
            <span class="s1">message: e.message</span>
        <span class="s1">};</span>
        <span class="s3">throw </span><span class="s1">e;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Loads a legacy (.eslintrc) configuration from a file. 
 * @param {string} filePath The filename to load. 
 * @returns {ConfigData} The configuration object from the file. 
 * @throws {Error} If the file cannot be read. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">loadLegacyConfigFile(filePath) {</span>
    <span class="s1">debug(`Loading legacy config file: ${filePath}`);</span>

    <span class="s0">// lazy load YAML to improve performance when not used</span>
    <span class="s1">const yaml = require(</span><span class="s2">&quot;js-yaml&quot;</span><span class="s1">);</span>

    <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">yaml.load(stripComments(readFile(filePath))) || </span><span class="s0">/* istanbul ignore next */ </span><span class="s1">{};</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
        <span class="s1">debug(</span><span class="s2">&quot;Error reading YAML file: %s</span><span class="s5">\n</span><span class="s2">%o&quot;</span><span class="s1">, filePath, e);</span>
        <span class="s1">e.message = `Cannot read config file: ${filePath}\nError: ${e.message}`;</span>
        <span class="s3">throw </span><span class="s1">e;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Loads a JavaScript configuration from a file. 
 * @param {string} filePath The filename to load. 
 * @returns {ConfigData} The configuration object from the file. 
 * @throws {Error} If the file cannot be read. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">loadJSConfigFile(filePath) {</span>
    <span class="s1">debug(`Loading JS config file: ${filePath}`);</span>
    <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">importFresh(filePath);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
        <span class="s1">debug(`Error reading JavaScript file: ${filePath}`);</span>
        <span class="s1">e.message = `Cannot read config file: ${filePath}\nError: ${e.message}`;</span>
        <span class="s3">throw </span><span class="s1">e;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Loads a configuration from a package.json file. 
 * @param {string} filePath The filename to load. 
 * @returns {ConfigData} The configuration object from the file. 
 * @throws {Error} If the file cannot be read. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">loadPackageJSONConfigFile(filePath) {</span>
    <span class="s1">debug(`Loading package.json config file: ${filePath}`);</span>
    <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">const packageData = loadJSONConfigFile(filePath);</span>

        <span class="s3">if </span><span class="s1">(!Object.hasOwnProperty.call(packageData, </span><span class="s2">&quot;eslintConfig&quot;</span><span class="s1">)) {</span>
            <span class="s3">throw </span><span class="s1">Object.assign(</span>
                <span class="s3">new </span><span class="s1">Error(</span><span class="s2">&quot;package.json file doesn't have 'eslintConfig' field.&quot;</span><span class="s1">),</span>
                <span class="s1">{ code: </span><span class="s2">&quot;ESLINT_CONFIG_FIELD_NOT_FOUND&quot; </span><span class="s1">}</span>
            <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">packageData.eslintConfig;</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
        <span class="s1">debug(`Error reading package.json file: ${filePath}`);</span>
        <span class="s1">e.message = `Cannot read config file: ${filePath}\nError: ${e.message}`;</span>
        <span class="s3">throw </span><span class="s1">e;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Loads a `.eslintignore` from a file. 
 * @param {string} filePath The filename to load. 
 * @returns {string[]} The ignore patterns from the file. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">loadESLintIgnoreFile(filePath) {</span>
    <span class="s1">debug(`Loading .eslintignore file: ${filePath}`);</span>

    <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">readFile(filePath)</span>
            <span class="s1">.split(/\r?\n/gu)</span>
            <span class="s1">.filter(line =&gt; line.trim() !== </span><span class="s2">&quot;&quot; </span><span class="s1">&amp;&amp; !line.startsWith(</span><span class="s2">&quot;#&quot;</span><span class="s1">));</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
        <span class="s1">debug(`Error reading .eslintignore file: ${filePath}`);</span>
        <span class="s1">e.message = `Cannot read .eslintignore file: ${filePath}\nError: ${e.message}`;</span>
        <span class="s3">throw </span><span class="s1">e;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Creates an error to notify about a missing config to extend from. 
 * @param {string} configName The name of the missing config. 
 * @param {string} importerName The name of the config that imported the missing config 
 * @param {string} messageTemplate The text template to source error strings from. 
 * @returns {Error} The error object to throw 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">configInvalidError(configName, importerName, messageTemplate) {</span>
    <span class="s3">return </span><span class="s1">Object.assign(</span>
        <span class="s3">new </span><span class="s1">Error(`Failed to load config </span><span class="s2">&quot;${configName}&quot; </span><span class="s1">to extend from.`),</span>
        <span class="s1">{</span>
            <span class="s1">messageTemplate,</span>
            <span class="s1">messageData: { configName, importerName }</span>
        <span class="s1">}</span>
    <span class="s1">);</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Loads a configuration file regardless of the source. Inspects the file path 
 * to determine the correctly way to load the config file. 
 * @param {string} filePath The path to the configuration. 
 * @returns {ConfigData|null} The configuration information. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">loadConfigFile(filePath) {</span>
    <span class="s3">switch </span><span class="s1">(path.extname(filePath)) {</span>
        <span class="s3">case </span><span class="s2">&quot;.js&quot;</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">&quot;.cjs&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">loadJSConfigFile(filePath);</span>

        <span class="s3">case </span><span class="s2">&quot;.json&quot;</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">(path.basename(filePath) === </span><span class="s2">&quot;package.json&quot;</span><span class="s1">) {</span>
                <span class="s3">return </span><span class="s1">loadPackageJSONConfigFile(filePath);</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">loadJSONConfigFile(filePath);</span>

        <span class="s3">case </span><span class="s2">&quot;.yaml&quot;</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">&quot;.yml&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">loadYAMLConfigFile(filePath);</span>

        <span class="s3">default</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">loadLegacyConfigFile(filePath);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Write debug log. 
 * @param {string} request The requested module name. 
 * @param {string} relativeTo The file path to resolve the request relative to. 
 * @param {string} filePath The resolved file path. 
 * @returns {void} 
 */</span>
<span class="s3">function </span><span class="s1">writeDebugLogForLoading(request, relativeTo, filePath) {</span>
    <span class="s0">/* istanbul ignore next */</span>
    <span class="s3">if </span><span class="s1">(debug.enabled) {</span>
        <span class="s1">let nameAndVersion = </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">const packageJsonPath = ModuleResolver.resolve(</span>
                <span class="s1">`${request}/package.json`,</span>
                <span class="s1">relativeTo</span>
            <span class="s1">);</span>
            <span class="s1">const { version = </span><span class="s2">&quot;unknown&quot; </span><span class="s1">} = require(packageJsonPath);</span>

            <span class="s1">nameAndVersion = `${request}@${version}`;</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
            <span class="s1">debug(</span><span class="s2">&quot;package.json was not found:&quot;</span><span class="s1">, error.message);</span>
            <span class="s1">nameAndVersion = request;</span>
        <span class="s1">}</span>

        <span class="s1">debug(</span><span class="s2">&quot;Loaded: %s (%s)&quot;</span><span class="s1">, nameAndVersion, filePath);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Create a new context with default values. 
 * @param {ConfigArrayFactoryInternalSlots} slots The internal slots. 
 * @param {&quot;config&quot; | &quot;ignore&quot; | &quot;implicit-processor&quot; | undefined} providedType The type of the current configuration. Default is `&quot;config&quot;`. 
 * @param {string | undefined} providedName The name of the current configuration. Default is the relative path from `cwd` to `filePath`. 
 * @param {string | undefined} providedFilePath The path to the current configuration. Default is empty string. 
 * @param {string | undefined} providedMatchBasePath The type of the current configuration. Default is the directory of `filePath` or `cwd`. 
 * @returns {ConfigArrayFactoryLoadingContext} The created context. 
 */</span>
<span class="s3">function </span><span class="s1">createContext(</span>
    <span class="s1">{ cwd, resolvePluginsRelativeTo },</span>
    <span class="s1">providedType,</span>
    <span class="s1">providedName,</span>
    <span class="s1">providedFilePath,</span>
    <span class="s1">providedMatchBasePath</span>
<span class="s1">) {</span>
    <span class="s1">const filePath = providedFilePath</span>
        <span class="s1">? path.resolve(cwd, providedFilePath)</span>
        <span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
    <span class="s1">const matchBasePath =</span>
        <span class="s1">(providedMatchBasePath &amp;&amp; path.resolve(cwd, providedMatchBasePath)) ||</span>
        <span class="s1">(filePath &amp;&amp; path.dirname(filePath)) ||</span>
        <span class="s1">cwd;</span>
    <span class="s1">const name =</span>
        <span class="s1">providedName ||</span>
        <span class="s1">(filePath &amp;&amp; path.relative(cwd, filePath)) ||</span>
        <span class="s2">&quot;&quot;</span><span class="s1">;</span>
    <span class="s1">const pluginBasePath =</span>
        <span class="s1">resolvePluginsRelativeTo ||</span>
        <span class="s1">(filePath &amp;&amp; path.dirname(filePath)) ||</span>
        <span class="s1">cwd;</span>
    <span class="s1">const type = providedType || </span><span class="s2">&quot;config&quot;</span><span class="s1">;</span>

    <span class="s3">return </span><span class="s1">{ filePath, matchBasePath, name, pluginBasePath, type };</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Normalize a given plugin. 
 * - Ensure the object to have four properties: configs, environments, processors, and rules. 
 * - Ensure the object to not have other properties. 
 * @param {Plugin} plugin The plugin to normalize. 
 * @returns {Plugin} The normalized plugin. 
 */</span>
<span class="s3">function </span><span class="s1">normalizePlugin(plugin) {</span>

    <span class="s0">// first check the cache</span>
    <span class="s1">let normalizedPlugin = normalizedPlugins.get(plugin);</span>

    <span class="s3">if </span><span class="s1">(normalizedPlugin) {</span>
        <span class="s3">return </span><span class="s1">normalizedPlugin;</span>
    <span class="s1">}</span>

    <span class="s1">normalizedPlugin = {</span>
        <span class="s1">configs: plugin.configs || {},</span>
        <span class="s1">environments: plugin.environments || {},</span>
        <span class="s1">processors: plugin.processors || {},</span>
        <span class="s1">rules: plugin.rules || {}</span>
    <span class="s1">};</span>

    <span class="s0">// save the reference for later</span>
    <span class="s1">normalizedPlugins.set(plugin, normalizedPlugin);</span>

    <span class="s3">return </span><span class="s1">normalizedPlugin;</span>
<span class="s1">}</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Public Interface</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/** 
 * The factory of `ConfigArray` objects. 
 */</span>
<span class="s1">class ConfigArrayFactory {</span>

    <span class="s0">/** 
     * Initialize this instance. 
     * @param {ConfigArrayFactoryOptions} [options] The map for additional plugins. 
     */</span>
    <span class="s1">constructor({</span>
        <span class="s1">additionalPluginPool = </span><span class="s3">new </span><span class="s1">Map(),</span>
        <span class="s1">cwd = process.cwd(),</span>
        <span class="s1">resolvePluginsRelativeTo,</span>
        <span class="s1">builtInRules,</span>
        <span class="s1">resolver = ModuleResolver,</span>
        <span class="s1">eslintAllPath,</span>
        <span class="s1">getEslintAllConfig,</span>
        <span class="s1">eslintRecommendedPath,</span>
        <span class="s1">getEslintRecommendedConfig</span>
    <span class="s1">} = {}) {</span>
        <span class="s1">internalSlotsMap.set(</span><span class="s3">this</span><span class="s1">, {</span>
            <span class="s1">additionalPluginPool,</span>
            <span class="s1">cwd,</span>
            <span class="s1">resolvePluginsRelativeTo:</span>
                <span class="s1">resolvePluginsRelativeTo &amp;&amp;</span>
                <span class="s1">path.resolve(cwd, resolvePluginsRelativeTo),</span>
            <span class="s1">builtInRules,</span>
            <span class="s1">resolver,</span>
            <span class="s1">eslintAllPath,</span>
            <span class="s1">getEslintAllConfig,</span>
            <span class="s1">eslintRecommendedPath,</span>
            <span class="s1">getEslintRecommendedConfig</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Create `ConfigArray` instance from a config data. 
     * @param {ConfigData|null} configData The config data to create. 
     * @param {Object} [options] The options. 
     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`. 
     * @param {string} [options.filePath] The path to this config data. 
     * @param {string} [options.name] The config name. 
     * @returns {ConfigArray} Loaded config. 
     */</span>
    <span class="s1">create(configData, { basePath, filePath, name } = {}) {</span>
        <span class="s3">if </span><span class="s1">(!configData) {</span>
            <span class="s3">return new </span><span class="s1">ConfigArray();</span>
        <span class="s1">}</span>

        <span class="s1">const slots = internalSlotsMap.get(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">const ctx = createContext(slots, </span><span class="s2">&quot;config&quot;</span><span class="s1">, name, filePath, basePath);</span>
        <span class="s1">const elements = </span><span class="s3">this</span><span class="s1">._normalizeConfigData(configData, ctx);</span>

        <span class="s3">return new </span><span class="s1">ConfigArray(...elements);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Load a config file. 
     * @param {string} filePath The path to a config file. 
     * @param {Object} [options] The options. 
     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`. 
     * @param {string} [options.name] The config name. 
     * @returns {ConfigArray} Loaded config. 
     */</span>
    <span class="s1">loadFile(filePath, { basePath, name } = {}) {</span>
        <span class="s1">const slots = internalSlotsMap.get(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">const ctx = createContext(slots, </span><span class="s2">&quot;config&quot;</span><span class="s1">, name, filePath, basePath);</span>

        <span class="s3">return new </span><span class="s1">ConfigArray(...</span><span class="s3">this</span><span class="s1">._loadConfigData(ctx));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Load the config file on a given directory if exists. 
     * @param {string} directoryPath The path to a directory. 
     * @param {Object} [options] The options. 
     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`. 
     * @param {string} [options.name] The config name. 
     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist. 
     */</span>
    <span class="s1">loadInDirectory(directoryPath, { basePath, name } = {}) {</span>
        <span class="s1">const slots = internalSlotsMap.get(</span><span class="s3">this</span><span class="s1">);</span>

        <span class="s3">for </span><span class="s1">(const filename of configFilenames) {</span>
            <span class="s1">const ctx = createContext(</span>
                <span class="s1">slots,</span>
                <span class="s2">&quot;config&quot;</span><span class="s1">,</span>
                <span class="s1">name,</span>
                <span class="s1">path.join(directoryPath, filename),</span>
                <span class="s1">basePath</span>
            <span class="s1">);</span>

            <span class="s3">if </span><span class="s1">(fs.existsSync(ctx.filePath) &amp;&amp; fs.statSync(ctx.filePath).isFile()) {</span>
                <span class="s1">let configData;</span>

                <span class="s3">try </span><span class="s1">{</span>
                    <span class="s1">configData = loadConfigFile(ctx.filePath);</span>
                <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
                    <span class="s3">if </span><span class="s1">(!error || error.code !== </span><span class="s2">&quot;ESLINT_CONFIG_FIELD_NOT_FOUND&quot;</span><span class="s1">) {</span>
                        <span class="s3">throw </span><span class="s1">error;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>

                <span class="s3">if </span><span class="s1">(configData) {</span>
                    <span class="s1">debug(`Config file found: ${ctx.filePath}`);</span>
                    <span class="s3">return new </span><span class="s1">ConfigArray(</span>
                        <span class="s1">...</span><span class="s3">this</span><span class="s1">._normalizeConfigData(configData, ctx)</span>
                    <span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">debug(`Config file not found on ${directoryPath}`);</span>
        <span class="s3">return new </span><span class="s1">ConfigArray();</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Check if a config file on a given directory exists or not. 
     * @param {string} directoryPath The path to a directory. 
     * @returns {string | null} The path to the found config file. If not found then null. 
     */</span>
    <span class="s1">static getPathToConfigFileInDirectory(directoryPath) {</span>
        <span class="s3">for </span><span class="s1">(const filename of configFilenames) {</span>
            <span class="s1">const filePath = path.join(directoryPath, filename);</span>

            <span class="s3">if </span><span class="s1">(fs.existsSync(filePath)) {</span>
                <span class="s3">if </span><span class="s1">(filename === </span><span class="s2">&quot;package.json&quot;</span><span class="s1">) {</span>
                    <span class="s3">try </span><span class="s1">{</span>
                        <span class="s1">loadPackageJSONConfigFile(filePath);</span>
                        <span class="s3">return </span><span class="s1">filePath;</span>
                    <span class="s1">} </span><span class="s3">catch </span><span class="s1">{ </span><span class="s0">/* ignore */ </span><span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">return </span><span class="s1">filePath;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Load `.eslintignore` file. 
     * @param {string} filePath The path to a `.eslintignore` file to load. 
     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist. 
     */</span>
    <span class="s1">loadESLintIgnore(filePath) {</span>
        <span class="s1">const slots = internalSlotsMap.get(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">const ctx = createContext(</span>
            <span class="s1">slots,</span>
            <span class="s2">&quot;ignore&quot;</span><span class="s1">,</span>
            <span class="s3">void </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s1">filePath,</span>
            <span class="s1">slots.cwd</span>
        <span class="s1">);</span>
        <span class="s1">const ignorePatterns = loadESLintIgnoreFile(ctx.filePath);</span>

        <span class="s3">return new </span><span class="s1">ConfigArray(</span>
            <span class="s1">...</span><span class="s3">this</span><span class="s1">._normalizeESLintIgnoreData(ignorePatterns, ctx)</span>
        <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Load `.eslintignore` file in the current working directory. 
     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist. 
     */</span>
    <span class="s1">loadDefaultESLintIgnore() {</span>
        <span class="s1">const slots = internalSlotsMap.get(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">const eslintIgnorePath = path.resolve(slots.cwd, </span><span class="s2">&quot;.eslintignore&quot;</span><span class="s1">);</span>
        <span class="s1">const packageJsonPath = path.resolve(slots.cwd, </span><span class="s2">&quot;package.json&quot;</span><span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(fs.existsSync(eslintIgnorePath)) {</span>
            <span class="s3">return this</span><span class="s1">.loadESLintIgnore(eslintIgnorePath);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(fs.existsSync(packageJsonPath)) {</span>
            <span class="s1">const data = loadJSONConfigFile(packageJsonPath);</span>

            <span class="s3">if </span><span class="s1">(Object.hasOwnProperty.call(data, </span><span class="s2">&quot;eslintIgnore&quot;</span><span class="s1">)) {</span>
                <span class="s3">if </span><span class="s1">(!Array.isArray(data.eslintIgnore)) {</span>
                    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Package.json eslintIgnore property requires an array of paths&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s1">const ctx = createContext(</span>
                    <span class="s1">slots,</span>
                    <span class="s2">&quot;ignore&quot;</span><span class="s1">,</span>
                    <span class="s2">&quot;eslintIgnore in package.json&quot;</span><span class="s1">,</span>
                    <span class="s1">packageJsonPath,</span>
                    <span class="s1">slots.cwd</span>
                <span class="s1">);</span>

                <span class="s3">return new </span><span class="s1">ConfigArray(</span>
                    <span class="s1">...</span><span class="s3">this</span><span class="s1">._normalizeESLintIgnoreData(data.eslintIgnore, ctx)</span>
                <span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">return new </span><span class="s1">ConfigArray();</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Load a given config file. 
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context. 
     * @returns {IterableIterator&lt;ConfigArrayElement&gt;} Loaded config. 
     * @private 
     */</span>
    <span class="s1">_loadConfigData(ctx) {</span>
        <span class="s3">return this</span><span class="s1">._normalizeConfigData(loadConfigFile(ctx.filePath), ctx);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Normalize a given `.eslintignore` data to config array elements. 
     * @param {string[]} ignorePatterns The patterns to ignore files. 
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context. 
     * @returns {IterableIterator&lt;ConfigArrayElement&gt;} The normalized config. 
     * @private 
     */</span>
    <span class="s1">*_normalizeESLintIgnoreData(ignorePatterns, ctx) {</span>
        <span class="s1">const elements = </span><span class="s3">this</span><span class="s1">._normalizeObjectConfigData(</span>
            <span class="s1">{ ignorePatterns },</span>
            <span class="s1">ctx</span>
        <span class="s1">);</span>

        <span class="s0">// Set `ignorePattern.loose` flag for backward compatibility.</span>
        <span class="s3">for </span><span class="s1">(const element of elements) {</span>
            <span class="s3">if </span><span class="s1">(element.ignorePattern) {</span>
                <span class="s1">element.ignorePattern.loose = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">yield element;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Normalize a given config to an array. 
     * @param {ConfigData} configData The config data to normalize. 
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context. 
     * @returns {IterableIterator&lt;ConfigArrayElement&gt;} The normalized config. 
     * @private 
     */</span>
    <span class="s1">_normalizeConfigData(configData, ctx) {</span>
        <span class="s1">const validator = </span><span class="s3">new </span><span class="s1">ConfigValidator();</span>

        <span class="s1">validator.validateConfigSchema(configData, ctx.name || ctx.filePath);</span>
        <span class="s3">return this</span><span class="s1">._normalizeObjectConfigData(configData, ctx);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Normalize a given config to an array. 
     * @param {ConfigData|OverrideConfigData} configData The config data to normalize. 
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context. 
     * @returns {IterableIterator&lt;ConfigArrayElement&gt;} The normalized config. 
     * @private 
     */</span>
    <span class="s1">*_normalizeObjectConfigData(configData, ctx) {</span>
        <span class="s1">const { files, excludedFiles, ...configBody } = configData;</span>
        <span class="s1">const criteria = OverrideTester.create(</span>
            <span class="s1">files,</span>
            <span class="s1">excludedFiles,</span>
            <span class="s1">ctx.matchBasePath</span>
        <span class="s1">);</span>
        <span class="s1">const elements = </span><span class="s3">this</span><span class="s1">._normalizeObjectConfigDataBody(configBody, ctx);</span>

        <span class="s0">// Apply the criteria to every element.</span>
        <span class="s3">for </span><span class="s1">(const element of elements) {</span>

            <span class="s0">/* 
             * Merge the criteria. 
             * This is for the `overrides` entries that came from the 
             * configurations of `overrides[].extends`. 
             */</span>
            <span class="s1">element.criteria = OverrideTester.and(criteria, element.criteria);</span>

            <span class="s0">/* 
             * Remove `root` property to ignore `root` settings which came from 
             * `extends` in `overrides`. 
             */</span>
            <span class="s3">if </span><span class="s1">(element.criteria) {</span>
                <span class="s1">element.root = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">yield element;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Normalize a given config to an array. 
     * @param {ConfigData} configData The config data to normalize. 
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context. 
     * @returns {IterableIterator&lt;ConfigArrayElement&gt;} The normalized config. 
     * @private 
     */</span>
    <span class="s1">*_normalizeObjectConfigDataBody(</span>
        <span class="s1">{</span>
            <span class="s1">env,</span>
            <span class="s1">extends: extend,</span>
            <span class="s1">globals,</span>
            <span class="s1">ignorePatterns,</span>
            <span class="s1">noInlineConfig,</span>
            <span class="s1">parser: parserName,</span>
            <span class="s1">parserOptions,</span>
            <span class="s1">plugins: pluginList,</span>
            <span class="s1">processor,</span>
            <span class="s1">reportUnusedDisableDirectives,</span>
            <span class="s1">root,</span>
            <span class="s1">rules,</span>
            <span class="s1">settings,</span>
            <span class="s1">overrides: overrideList = []</span>
        <span class="s1">},</span>
        <span class="s1">ctx</span>
    <span class="s1">) {</span>
        <span class="s1">const extendList = Array.isArray(extend) ? extend : [extend];</span>
        <span class="s1">const ignorePattern = ignorePatterns &amp;&amp; </span><span class="s3">new </span><span class="s1">IgnorePattern(</span>
            <span class="s1">Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns],</span>
            <span class="s1">ctx.matchBasePath</span>
        <span class="s1">);</span>

        <span class="s0">// Flatten `extends`.</span>
        <span class="s3">for </span><span class="s1">(const extendName of extendList.filter(Boolean)) {</span>
            <span class="s1">yield* </span><span class="s3">this</span><span class="s1">._loadExtends(extendName, ctx);</span>
        <span class="s1">}</span>

        <span class="s0">// Load parser &amp; plugins.</span>
        <span class="s1">const parser = parserName &amp;&amp; </span><span class="s3">this</span><span class="s1">._loadParser(parserName, ctx);</span>
        <span class="s1">const plugins = pluginList &amp;&amp; </span><span class="s3">this</span><span class="s1">._loadPlugins(pluginList, ctx);</span>

        <span class="s0">// Yield pseudo config data for file extension processors.</span>
        <span class="s3">if </span><span class="s1">(plugins) {</span>
            <span class="s1">yield* </span><span class="s3">this</span><span class="s1">._takeFileExtensionProcessors(plugins, ctx);</span>
        <span class="s1">}</span>

        <span class="s0">// Yield the config data except `extends` and `overrides`.</span>
        <span class="s1">yield {</span>

            <span class="s0">// Debug information.</span>
            <span class="s1">type: ctx.type,</span>
            <span class="s1">name: ctx.name,</span>
            <span class="s1">filePath: ctx.filePath,</span>

            <span class="s0">// Config data.</span>
            <span class="s1">criteria: </span><span class="s3">null</span><span class="s1">,</span>
            <span class="s1">env,</span>
            <span class="s1">globals,</span>
            <span class="s1">ignorePattern,</span>
            <span class="s1">noInlineConfig,</span>
            <span class="s1">parser,</span>
            <span class="s1">parserOptions,</span>
            <span class="s1">plugins,</span>
            <span class="s1">processor,</span>
            <span class="s1">reportUnusedDisableDirectives,</span>
            <span class="s1">root,</span>
            <span class="s1">rules,</span>
            <span class="s1">settings</span>
        <span class="s1">};</span>

        <span class="s0">// Flatten `overries`.</span>
        <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; overrideList.length; ++i) {</span>
            <span class="s1">yield* </span><span class="s3">this</span><span class="s1">._normalizeObjectConfigData(</span>
                <span class="s1">overrideList[i],</span>
                <span class="s1">{ ...ctx, name: `${ctx.name}#overrides[${i}]` }</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Load configs of an element in `extends`. 
     * @param {string} extendName The name of a base config. 
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context. 
     * @returns {IterableIterator&lt;ConfigArrayElement&gt;} The normalized config. 
     * @private 
     */</span>
    <span class="s1">_loadExtends(extendName, ctx) {</span>
        <span class="s1">debug(</span><span class="s2">&quot;Loading {extends:%j} relative to %s&quot;</span><span class="s1">, extendName, ctx.filePath);</span>
        <span class="s3">try </span><span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(extendName.startsWith(</span><span class="s2">&quot;eslint:&quot;</span><span class="s1">)) {</span>
                <span class="s3">return this</span><span class="s1">._loadExtendedBuiltInConfig(extendName, ctx);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(extendName.startsWith(</span><span class="s2">&quot;plugin:&quot;</span><span class="s1">)) {</span>
                <span class="s3">return this</span><span class="s1">._loadExtendedPluginConfig(extendName, ctx);</span>
            <span class="s1">}</span>
            <span class="s3">return this</span><span class="s1">._loadExtendedShareableConfig(extendName, ctx);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
            <span class="s1">error.message += `\nReferenced from: ${ctx.filePath || ctx.name}`;</span>
            <span class="s3">throw </span><span class="s1">error;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Load configs of an element in `extends`. 
     * @param {string} extendName The name of a base config. 
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context. 
     * @returns {IterableIterator&lt;ConfigArrayElement&gt;} The normalized config. 
     * @private 
     */</span>
    <span class="s1">_loadExtendedBuiltInConfig(extendName, ctx) {</span>
        <span class="s1">const {</span>
            <span class="s1">eslintAllPath,</span>
            <span class="s1">getEslintAllConfig,</span>
            <span class="s1">eslintRecommendedPath,</span>
            <span class="s1">getEslintRecommendedConfig</span>
        <span class="s1">} = internalSlotsMap.get(</span><span class="s3">this</span><span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(extendName === </span><span class="s2">&quot;eslint:recommended&quot;</span><span class="s1">) {</span>
            <span class="s1">const name = `${ctx.name} » ${extendName}`;</span>

            <span class="s3">if </span><span class="s1">(getEslintRecommendedConfig) {</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">getEslintRecommendedConfig !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
                    <span class="s3">throw new </span><span class="s1">Error(`getEslintRecommendedConfig must be a </span><span class="s3">function </span><span class="s1">instead of </span><span class="s2">'${getEslintRecommendedConfig}'</span><span class="s1">`);</span>
                <span class="s1">}</span>
                <span class="s3">return this</span><span class="s1">._normalizeConfigData(getEslintRecommendedConfig(), { ...ctx, name, filePath: </span><span class="s2">&quot;&quot; </span><span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s3">return this</span><span class="s1">._loadConfigData({</span>
                <span class="s1">...ctx,</span>
                <span class="s1">name,</span>
                <span class="s1">filePath: eslintRecommendedPath</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(extendName === </span><span class="s2">&quot;eslint:all&quot;</span><span class="s1">) {</span>
            <span class="s1">const name = `${ctx.name} » ${extendName}`;</span>

            <span class="s3">if </span><span class="s1">(getEslintAllConfig) {</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">getEslintAllConfig !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
                    <span class="s3">throw new </span><span class="s1">Error(`getEslintAllConfig must be a </span><span class="s3">function </span><span class="s1">instead of </span><span class="s2">'${getEslintAllConfig}'</span><span class="s1">`);</span>
                <span class="s1">}</span>
                <span class="s3">return this</span><span class="s1">._normalizeConfigData(getEslintAllConfig(), { ...ctx, name, filePath: </span><span class="s2">&quot;&quot; </span><span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s3">return this</span><span class="s1">._loadConfigData({</span>
                <span class="s1">...ctx,</span>
                <span class="s1">name,</span>
                <span class="s1">filePath: eslintAllPath</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s3">throw </span><span class="s1">configInvalidError(extendName, ctx.name, </span><span class="s2">&quot;extend-config-missing&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Load configs of an element in `extends`. 
     * @param {string} extendName The name of a base config. 
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context. 
     * @returns {IterableIterator&lt;ConfigArrayElement&gt;} The normalized config. 
     * @private 
     */</span>
    <span class="s1">_loadExtendedPluginConfig(extendName, ctx) {</span>
        <span class="s1">const slashIndex = extendName.lastIndexOf(</span><span class="s2">&quot;/&quot;</span><span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(slashIndex === -</span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s3">throw </span><span class="s1">configInvalidError(extendName, ctx.filePath, </span><span class="s2">&quot;plugin-invalid&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">const pluginName = extendName.slice(</span><span class="s2">&quot;plugin:&quot;</span><span class="s1">.length, slashIndex);</span>
        <span class="s1">const configName = extendName.slice(slashIndex + </span><span class="s4">1</span><span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(isFilePath(pluginName)) {</span>
            <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;'extends' cannot use a file path for plugins.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">const plugin = </span><span class="s3">this</span><span class="s1">._loadPlugin(pluginName, ctx);</span>
        <span class="s1">const configData =</span>
            <span class="s1">plugin.definition &amp;&amp;</span>
            <span class="s1">plugin.definition.configs[configName];</span>

        <span class="s3">if </span><span class="s1">(configData) {</span>
            <span class="s3">return this</span><span class="s1">._normalizeConfigData(configData, {</span>
                <span class="s1">...ctx,</span>
                <span class="s1">filePath: plugin.filePath || ctx.filePath,</span>
                <span class="s1">name: `${ctx.name} » plugin:${plugin.id}/${configName}`</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s3">throw </span><span class="s1">plugin.error || configInvalidError(extendName, ctx.filePath, </span><span class="s2">&quot;extend-config-missing&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Load configs of an element in `extends`. 
     * @param {string} extendName The name of a base config. 
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context. 
     * @returns {IterableIterator&lt;ConfigArrayElement&gt;} The normalized config. 
     * @private 
     */</span>
    <span class="s1">_loadExtendedShareableConfig(extendName, ctx) {</span>
        <span class="s1">const { cwd, resolver } = internalSlotsMap.get(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">const relativeTo = ctx.filePath || path.join(cwd, </span><span class="s2">&quot;__placeholder__.js&quot;</span><span class="s1">);</span>
        <span class="s1">let request;</span>

        <span class="s3">if </span><span class="s1">(isFilePath(extendName)) {</span>
            <span class="s1">request = extendName;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(extendName.startsWith(</span><span class="s2">&quot;.&quot;</span><span class="s1">)) {</span>
            <span class="s1">request = `./${extendName}`; </span><span class="s0">// For backward compatibility. A ton of tests depended on this behavior.</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">request = naming.normalizePackageName(</span>
                <span class="s1">extendName,</span>
                <span class="s2">&quot;eslint-config&quot;</span>
            <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">let filePath;</span>

        <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">filePath = resolver.resolve(request, relativeTo);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
            <span class="s0">/* istanbul ignore else */</span>
            <span class="s3">if </span><span class="s1">(error &amp;&amp; error.code === </span><span class="s2">&quot;MODULE_NOT_FOUND&quot;</span><span class="s1">) {</span>
                <span class="s3">throw </span><span class="s1">configInvalidError(extendName, ctx.filePath, </span><span class="s2">&quot;extend-config-missing&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">throw </span><span class="s1">error;</span>
        <span class="s1">}</span>

        <span class="s1">writeDebugLogForLoading(request, relativeTo, filePath);</span>
        <span class="s3">return this</span><span class="s1">._loadConfigData({</span>
            <span class="s1">...ctx,</span>
            <span class="s1">filePath,</span>
            <span class="s1">name: `${ctx.name} » ${request}`</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Load given plugins. 
     * @param {string[]} names The plugin names to load. 
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context. 
     * @returns {Record&lt;string,DependentPlugin&gt;} The loaded parser. 
     * @private 
     */</span>
    <span class="s1">_loadPlugins(names, ctx) {</span>
        <span class="s3">return </span><span class="s1">names.reduce((map, name) =&gt; {</span>
            <span class="s3">if </span><span class="s1">(isFilePath(name)) {</span>
                <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Plugins array cannot includes file paths.&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">const plugin = </span><span class="s3">this</span><span class="s1">._loadPlugin(name, ctx);</span>

            <span class="s1">map[plugin.id] = plugin;</span>

            <span class="s3">return </span><span class="s1">map;</span>
        <span class="s1">}, {});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Load a given parser. 
     * @param {string} nameOrPath The package name or the path to a parser file. 
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context. 
     * @returns {DependentParser} The loaded parser. 
     */</span>
    <span class="s1">_loadParser(nameOrPath, ctx) {</span>
        <span class="s1">debug(</span><span class="s2">&quot;Loading parser %j from %s&quot;</span><span class="s1">, nameOrPath, ctx.filePath);</span>

        <span class="s1">const { cwd, resolver } = internalSlotsMap.get(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">const relativeTo = ctx.filePath || path.join(cwd, </span><span class="s2">&quot;__placeholder__.js&quot;</span><span class="s1">);</span>

        <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">const filePath = resolver.resolve(nameOrPath, relativeTo);</span>

            <span class="s1">writeDebugLogForLoading(nameOrPath, relativeTo, filePath);</span>

            <span class="s3">return new </span><span class="s1">ConfigDependency({</span>
                <span class="s1">definition: require(filePath),</span>
                <span class="s1">filePath,</span>
                <span class="s1">id: nameOrPath,</span>
                <span class="s1">importerName: ctx.name,</span>
                <span class="s1">importerPath: ctx.filePath</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>

            <span class="s0">// If the parser name is &quot;espree&quot;, load the espree of ESLint.</span>
            <span class="s3">if </span><span class="s1">(nameOrPath === </span><span class="s2">&quot;espree&quot;</span><span class="s1">) {</span>
                <span class="s1">debug(</span><span class="s2">&quot;Fallback espree.&quot;</span><span class="s1">);</span>
                <span class="s3">return new </span><span class="s1">ConfigDependency({</span>
                    <span class="s1">definition: require(</span><span class="s2">&quot;espree&quot;</span><span class="s1">),</span>
                    <span class="s1">filePath: require.resolve(</span><span class="s2">&quot;espree&quot;</span><span class="s1">),</span>
                    <span class="s1">id: nameOrPath,</span>
                    <span class="s1">importerName: ctx.name,</span>
                    <span class="s1">importerPath: ctx.filePath</span>
                <span class="s1">});</span>
            <span class="s1">}</span>

            <span class="s1">debug(</span><span class="s2">&quot;Failed to load parser '%s' declared in '%s'.&quot;</span><span class="s1">, nameOrPath, ctx.name);</span>
            <span class="s1">error.message = `Failed to load parser </span><span class="s2">'${nameOrPath}' </span><span class="s1">declared </span><span class="s3">in </span><span class="s2">'${ctx.name}'</span><span class="s1">: ${error.message}`;</span>

            <span class="s3">return new </span><span class="s1">ConfigDependency({</span>
                <span class="s1">error,</span>
                <span class="s1">id: nameOrPath,</span>
                <span class="s1">importerName: ctx.name,</span>
                <span class="s1">importerPath: ctx.filePath</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Load a given plugin. 
     * @param {string} name The plugin name to load. 
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context. 
     * @returns {DependentPlugin} The loaded plugin. 
     * @private 
     */</span>
    <span class="s1">_loadPlugin(name, ctx) {</span>
        <span class="s1">debug(</span><span class="s2">&quot;Loading plugin %j from %s&quot;</span><span class="s1">, name, ctx.filePath);</span>

        <span class="s1">const { additionalPluginPool, resolver } = internalSlotsMap.get(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">const request = naming.normalizePackageName(name, </span><span class="s2">&quot;eslint-plugin&quot;</span><span class="s1">);</span>
        <span class="s1">const id = naming.getShorthandName(request, </span><span class="s2">&quot;eslint-plugin&quot;</span><span class="s1">);</span>
        <span class="s1">const relativeTo = path.join(ctx.pluginBasePath, </span><span class="s2">&quot;__placeholder__.js&quot;</span><span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(name.match(/\s+/u)) {</span>
            <span class="s1">const error = Object.assign(</span>
                <span class="s3">new </span><span class="s1">Error(`Whitespace found </span><span class="s3">in </span><span class="s1">plugin name </span><span class="s2">'${name}'</span><span class="s1">`),</span>
                <span class="s1">{</span>
                    <span class="s1">messageTemplate: </span><span class="s2">&quot;whitespace-found&quot;</span><span class="s1">,</span>
                    <span class="s1">messageData: { pluginName: request }</span>
                <span class="s1">}</span>
            <span class="s1">);</span>

            <span class="s3">return new </span><span class="s1">ConfigDependency({</span>
                <span class="s1">error,</span>
                <span class="s1">id,</span>
                <span class="s1">importerName: ctx.name,</span>
                <span class="s1">importerPath: ctx.filePath</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s0">// Check for additional pool.</span>
        <span class="s1">const plugin =</span>
            <span class="s1">additionalPluginPool.get(request) ||</span>
            <span class="s1">additionalPluginPool.get(id);</span>

        <span class="s3">if </span><span class="s1">(plugin) {</span>
            <span class="s3">return new </span><span class="s1">ConfigDependency({</span>
                <span class="s1">definition: normalizePlugin(plugin),</span>
                <span class="s1">filePath: </span><span class="s2">&quot;&quot;</span><span class="s1">, </span><span class="s0">// It's unknown where the plugin came from.</span>
                <span class="s1">id,</span>
                <span class="s1">importerName: ctx.name,</span>
                <span class="s1">importerPath: ctx.filePath</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s1">let filePath;</span>
        <span class="s1">let error;</span>

        <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">filePath = resolver.resolve(request, relativeTo);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(resolveError) {</span>
            <span class="s1">error = resolveError;</span>
            <span class="s0">/* istanbul ignore else */</span>
            <span class="s3">if </span><span class="s1">(error &amp;&amp; error.code === </span><span class="s2">&quot;MODULE_NOT_FOUND&quot;</span><span class="s1">) {</span>
                <span class="s1">error.messageTemplate = </span><span class="s2">&quot;plugin-missing&quot;</span><span class="s1">;</span>
                <span class="s1">error.messageData = {</span>
                    <span class="s1">pluginName: request,</span>
                    <span class="s1">resolvePluginsRelativeTo: ctx.pluginBasePath,</span>
                    <span class="s1">importerName: ctx.name</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(filePath) {</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s1">writeDebugLogForLoading(request, relativeTo, filePath);</span>

                <span class="s1">const startTime = Date.now();</span>
                <span class="s1">const pluginDefinition = require(filePath);</span>

                <span class="s1">debug(`Plugin ${filePath} loaded </span><span class="s3">in</span><span class="s1">: ${Date.now() - startTime}ms`);</span>

                <span class="s3">return new </span><span class="s1">ConfigDependency({</span>
                    <span class="s1">definition: normalizePlugin(pluginDefinition),</span>
                    <span class="s1">filePath,</span>
                    <span class="s1">id,</span>
                    <span class="s1">importerName: ctx.name,</span>
                    <span class="s1">importerPath: ctx.filePath</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(loadError) {</span>
                <span class="s1">error = loadError;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">debug(</span><span class="s2">&quot;Failed to load plugin '%s' declared in '%s'.&quot;</span><span class="s1">, name, ctx.name);</span>
        <span class="s1">error.message = `Failed to load plugin </span><span class="s2">'${name}' </span><span class="s1">declared </span><span class="s3">in </span><span class="s2">'${ctx.name}'</span><span class="s1">: ${error.message}`;</span>
        <span class="s3">return new </span><span class="s1">ConfigDependency({</span>
            <span class="s1">error,</span>
            <span class="s1">id,</span>
            <span class="s1">importerName: ctx.name,</span>
            <span class="s1">importerPath: ctx.filePath</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Take file expression processors as config array elements. 
     * @param {Record&lt;string,DependentPlugin&gt;} plugins The plugin definitions. 
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context. 
     * @returns {IterableIterator&lt;ConfigArrayElement&gt;} The config array elements of file expression processors. 
     * @private 
     */</span>
    <span class="s1">*_takeFileExtensionProcessors(plugins, ctx) {</span>
        <span class="s3">for </span><span class="s1">(const pluginId of Object.keys(plugins)) {</span>
            <span class="s1">const processors =</span>
                <span class="s1">plugins[pluginId] &amp;&amp;</span>
                <span class="s1">plugins[pluginId].definition &amp;&amp;</span>
                <span class="s1">plugins[pluginId].definition.processors;</span>

            <span class="s3">if </span><span class="s1">(!processors) {</span>
                <span class="s3">continue</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">for </span><span class="s1">(const processorId of Object.keys(processors)) {</span>
                <span class="s3">if </span><span class="s1">(processorId.startsWith(</span><span class="s2">&quot;.&quot;</span><span class="s1">)) {</span>
                    <span class="s1">yield* </span><span class="s3">this</span><span class="s1">._normalizeObjectConfigData(</span>
                        <span class="s1">{</span>
                            <span class="s1">files: [`*${processorId}`],</span>
                            <span class="s1">processor: `${pluginId}/${processorId}`</span>
                        <span class="s1">},</span>
                        <span class="s1">{</span>
                            <span class="s1">...ctx,</span>
                            <span class="s1">type: </span><span class="s2">&quot;implicit-processor&quot;</span><span class="s1">,</span>
                            <span class="s1">name: `${ctx.name}#processors[</span><span class="s2">&quot;${pluginId}/${processorId}&quot;</span><span class="s1">]`</span>
                        <span class="s1">}</span>
                    <span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">export { ConfigArrayFactory, createContext };</span>
</pre>
</body>
</html>
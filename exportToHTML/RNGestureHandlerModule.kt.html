<html>
<head>
<title>RNGestureHandlerModule.kt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RNGestureHandlerModule.kt</font>
</center></td></tr></table>
<pre><span class="s0">package </span><span class="s1">com.swmansion.gesturehandler.react</span>

<span class="s1">import android.content.Context</span>
<span class="s1">import android.util.Log</span>
<span class="s1">import android.view.MotionEvent</span>
<span class="s1">import com.facebook.react.ReactRootView</span>
<span class="s1">import com.facebook.react.bridge.JSApplicationIllegalArgumentException</span>
<span class="s1">import com.facebook.react.bridge.ReactApplicationContext</span>
<span class="s1">import com.facebook.react.bridge.ReactContextBaseJavaModule</span>
<span class="s1">import com.facebook.react.bridge.ReactMethod</span>
<span class="s1">import com.facebook.react.bridge.ReadableMap</span>
<span class="s1">import com.facebook.react.bridge.ReadableType</span>
<span class="s1">import com.facebook.react.bridge.WritableMap</span>
<span class="s1">import com.facebook.react.module.annotations.ReactModule</span>
<span class="s1">import com.facebook.react.uimanager.PixelUtil</span>
<span class="s1">import com.facebook.react.uimanager.events.Event</span>
<span class="s1">import com.facebook.soloader.SoLoader</span>
<span class="s1">import com.swmansion.common.GestureHandlerStateManager</span>
<span class="s1">import com.swmansion.gesturehandler.BuildConfig</span>
<span class="s1">import com.swmansion.gesturehandler.ReanimatedEventDispatcher</span>
<span class="s1">import com.swmansion.gesturehandler.core.FlingGestureHandler</span>
<span class="s1">import com.swmansion.gesturehandler.core.GestureHandler</span>
<span class="s1">import com.swmansion.gesturehandler.core.LongPressGestureHandler</span>
<span class="s1">import com.swmansion.gesturehandler.core.ManualGestureHandler</span>
<span class="s1">import com.swmansion.gesturehandler.core.NativeViewGestureHandler</span>
<span class="s1">import com.swmansion.gesturehandler.core.OnTouchEventListener</span>
<span class="s1">import com.swmansion.gesturehandler.core.PanGestureHandler</span>
<span class="s1">import com.swmansion.gesturehandler.core.PinchGestureHandler</span>
<span class="s1">import com.swmansion.gesturehandler.core.RotationGestureHandler</span>
<span class="s1">import com.swmansion.gesturehandler.core.TapGestureHandler</span>
<span class="s1">import com.swmansion.gesturehandler.dispatchEvent</span>

<span class="s2">// NativeModule.onCatalystInstanceDestroy() was deprecated in favor of NativeModule.invalidate()</span>
<span class="s2">// ref: https://github.com/facebook/react-native/commit/18c8417290823e67e211bde241ae9dde27b72f17</span>

<span class="s2">// UIManagerModule.resolveRootTagFromReactTag() was deprecated and will be removed in the next RN release</span>
<span class="s2">// ref: https://github.com/facebook/react-native/commit/acbf9e18ea666b07c1224a324602a41d0a66985e</span>
<span class="s1">@Suppress(</span><span class="s3">&quot;DEPRECATION&quot;</span><span class="s1">)</span>
<span class="s1">@ReactModule(name = RNGestureHandlerModule.MODULE_NAME)</span>
<span class="s0">class </span><span class="s1">RNGestureHandlerModule(reactContext: ReactApplicationContext?) :</span>
  <span class="s1">ReactContextBaseJavaModule(reactContext)</span><span class="s0">, </span><span class="s1">GestureHandlerStateManager {</span>
  <span class="s1">private abstract </span><span class="s0">class </span><span class="s1">HandlerFactory&lt;T : GestureHandler&lt;T&gt;&gt; : RNGestureHandlerEventDataExtractor&lt;T&gt; {</span>
    <span class="s1">abstract </span><span class="s0">val </span><span class="s1">type: Class&lt;T&gt;</span>
    <span class="s1">abstract </span><span class="s0">val </span><span class="s1">name: String</span>
    <span class="s1">abstract </span><span class="s0">fun </span><span class="s1">create(context: Context?): T</span>
    <span class="s1">open </span><span class="s0">fun </span><span class="s1">configure(handler: T</span><span class="s0">, </span><span class="s1">config: ReadableMap) {</span>
      <span class="s1">handler.resetConfig()</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_SHOULD_CANCEL_WHEN_OUTSIDE)) {</span>
        <span class="s1">handler.setShouldCancelWhenOutside(config.getBoolean(KEY_SHOULD_CANCEL_WHEN_OUTSIDE))</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_ENABLED)) {</span>
        <span class="s1">handler.setEnabled(config.getBoolean(KEY_ENABLED))</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_HIT_SLOP)) {</span>
        <span class="s1">handleHitSlopProperty(handler</span><span class="s0">, </span><span class="s1">config)</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_NEEDS_POINTER_DATA)) {</span>
        <span class="s1">handler.needsPointerData = config.getBoolean(KEY_NEEDS_POINTER_DATA)</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_MANUAL_ACTIVATION)) {</span>
        <span class="s1">handler.setManualActivation(config.getBoolean(KEY_MANUAL_ACTIVATION))</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">extractEventData(handler: T</span><span class="s0">, </span><span class="s1">eventData: WritableMap) {</span>
      <span class="s1">eventData.putDouble(</span><span class="s3">&quot;numberOfPointers&quot;</span><span class="s0">, </span><span class="s1">handler.numberOfPointers.toDouble())</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">class </span><span class="s1">NativeViewGestureHandlerFactory : HandlerFactory&lt;NativeViewGestureHandler&gt;() {</span>
    <span class="s1">override </span><span class="s0">val </span><span class="s1">type = NativeViewGestureHandler::</span><span class="s0">class</span><span class="s1">.java</span>
    <span class="s1">override </span><span class="s0">val </span><span class="s1">name = </span><span class="s3">&quot;NativeViewGestureHandler&quot;</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">create(context: Context?): NativeViewGestureHandler {</span>
      <span class="s0">return </span><span class="s1">NativeViewGestureHandler()</span>
    <span class="s1">}</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">configure(handler: NativeViewGestureHandler</span><span class="s0">, </span><span class="s1">config: ReadableMap) {</span>
      <span class="s0">super</span><span class="s1">.configure(handler</span><span class="s0">, </span><span class="s1">config)</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_NATIVE_VIEW_SHOULD_ACTIVATE_ON_START)) {</span>
        <span class="s1">handler.setShouldActivateOnStart(</span>
          <span class="s1">config.getBoolean(KEY_NATIVE_VIEW_SHOULD_ACTIVATE_ON_START)</span>
        <span class="s1">)</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_NATIVE_VIEW_DISALLOW_INTERRUPTION)) {</span>
        <span class="s1">handler.setDisallowInterruption(config.getBoolean(KEY_NATIVE_VIEW_DISALLOW_INTERRUPTION))</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">extractEventData(handler: NativeViewGestureHandler</span><span class="s0">, </span><span class="s1">eventData: WritableMap) {</span>
      <span class="s0">super</span><span class="s1">.extractEventData(handler</span><span class="s0">, </span><span class="s1">eventData)</span>
      <span class="s1">eventData.putBoolean(</span><span class="s3">&quot;pointerInside&quot;</span><span class="s0">, </span><span class="s1">handler.isWithinBounds)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">class </span><span class="s1">TapGestureHandlerFactory : HandlerFactory&lt;TapGestureHandler&gt;() {</span>
    <span class="s1">override </span><span class="s0">val </span><span class="s1">type = TapGestureHandler::</span><span class="s0">class</span><span class="s1">.java</span>
    <span class="s1">override </span><span class="s0">val </span><span class="s1">name = </span><span class="s3">&quot;TapGestureHandler&quot;</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">create(context: Context?): TapGestureHandler {</span>
      <span class="s0">return </span><span class="s1">TapGestureHandler()</span>
    <span class="s1">}</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">configure(handler: TapGestureHandler</span><span class="s0">, </span><span class="s1">config: ReadableMap) {</span>
      <span class="s0">super</span><span class="s1">.configure(handler</span><span class="s0">, </span><span class="s1">config)</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_TAP_NUMBER_OF_TAPS)) {</span>
        <span class="s1">handler.setNumberOfTaps(config.getInt(KEY_TAP_NUMBER_OF_TAPS))</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_TAP_MAX_DURATION_MS)) {</span>
        <span class="s1">handler.setMaxDurationMs(config.getInt(KEY_TAP_MAX_DURATION_MS).toLong())</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_TAP_MAX_DELAY_MS)) {</span>
        <span class="s1">handler.setMaxDelayMs(config.getInt(KEY_TAP_MAX_DELAY_MS).toLong())</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_TAP_MAX_DELTA_X)) {</span>
        <span class="s1">handler.setMaxDx(PixelUtil.toPixelFromDIP(config.getDouble(KEY_TAP_MAX_DELTA_X)))</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_TAP_MAX_DELTA_Y)) {</span>
        <span class="s1">handler.setMaxDy(PixelUtil.toPixelFromDIP(config.getDouble(KEY_TAP_MAX_DELTA_Y)))</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_TAP_MAX_DIST)) {</span>
        <span class="s1">handler.setMaxDist(PixelUtil.toPixelFromDIP(config.getDouble(KEY_TAP_MAX_DIST)))</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_TAP_MIN_POINTERS)) {</span>
        <span class="s1">handler.setMinNumberOfPointers(config.getInt(KEY_TAP_MIN_POINTERS))</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">extractEventData(handler: TapGestureHandler</span><span class="s0">, </span><span class="s1">eventData: WritableMap) {</span>
      <span class="s0">super</span><span class="s1">.extractEventData(handler</span><span class="s0">, </span><span class="s1">eventData)</span>
      <span class="s1">with(eventData) {</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;x&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.lastRelativePositionX).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;y&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.lastRelativePositionY).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;absoluteX&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.lastPositionInWindowX).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;absoluteY&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.lastPositionInWindowY).toDouble())</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">class </span><span class="s1">LongPressGestureHandlerFactory : HandlerFactory&lt;LongPressGestureHandler&gt;() {</span>
    <span class="s1">override </span><span class="s0">val </span><span class="s1">type = LongPressGestureHandler::</span><span class="s0">class</span><span class="s1">.java</span>
    <span class="s1">override </span><span class="s0">val </span><span class="s1">name = </span><span class="s3">&quot;LongPressGestureHandler&quot;</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">create(context: Context?): LongPressGestureHandler {</span>
      <span class="s0">return </span><span class="s1">LongPressGestureHandler((context)!!)</span>
    <span class="s1">}</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">configure(handler: LongPressGestureHandler</span><span class="s0">, </span><span class="s1">config: ReadableMap) {</span>
      <span class="s0">super</span><span class="s1">.configure(handler</span><span class="s0">, </span><span class="s1">config)</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_LONG_PRESS_MIN_DURATION_MS)) {</span>
        <span class="s1">handler.minDurationMs = config.getInt(KEY_LONG_PRESS_MIN_DURATION_MS).toLong()</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_LONG_PRESS_MAX_DIST)) {</span>
        <span class="s1">handler.setMaxDist(PixelUtil.toPixelFromDIP(config.getDouble(KEY_LONG_PRESS_MAX_DIST)))</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">extractEventData(handler: LongPressGestureHandler</span><span class="s0">, </span><span class="s1">eventData: WritableMap) {</span>
      <span class="s0">super</span><span class="s1">.extractEventData(handler</span><span class="s0">, </span><span class="s1">eventData)</span>
      <span class="s1">with(eventData) {</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;x&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.lastRelativePositionX).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;y&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.lastRelativePositionY).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;absoluteX&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.lastPositionInWindowX).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;absoluteY&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.lastPositionInWindowY).toDouble())</span>
        <span class="s1">putInt(</span><span class="s3">&quot;duration&quot;</span><span class="s0">, </span><span class="s1">handler.duration)</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">class </span><span class="s1">PanGestureHandlerFactory : HandlerFactory&lt;PanGestureHandler&gt;() {</span>
    <span class="s1">override </span><span class="s0">val </span><span class="s1">type = PanGestureHandler::</span><span class="s0">class</span><span class="s1">.java</span>
    <span class="s1">override </span><span class="s0">val </span><span class="s1">name = </span><span class="s3">&quot;PanGestureHandler&quot;</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">create(context: Context?): PanGestureHandler {</span>
      <span class="s0">return </span><span class="s1">PanGestureHandler(context)</span>
    <span class="s1">}</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">configure(handler: PanGestureHandler</span><span class="s0">, </span><span class="s1">config: ReadableMap) {</span>
      <span class="s0">super</span><span class="s1">.configure(handler</span><span class="s0">, </span><span class="s1">config)</span>
      <span class="s0">var </span><span class="s1">hasCustomActivationCriteria = </span><span class="s0">false</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_PAN_ACTIVE_OFFSET_X_START)) {</span>
        <span class="s1">handler.setActiveOffsetXStart(PixelUtil.toPixelFromDIP(config.getDouble(KEY_PAN_ACTIVE_OFFSET_X_START)))</span>
        <span class="s1">hasCustomActivationCriteria = </span><span class="s0">true</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_PAN_ACTIVE_OFFSET_X_END)) {</span>
        <span class="s1">handler.setActiveOffsetXEnd(PixelUtil.toPixelFromDIP(config.getDouble(KEY_PAN_ACTIVE_OFFSET_X_END)))</span>
        <span class="s1">hasCustomActivationCriteria = </span><span class="s0">true</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_PAN_FAIL_OFFSET_RANGE_X_START)) {</span>
        <span class="s1">handler.setFailOffsetXStart(PixelUtil.toPixelFromDIP(config.getDouble(KEY_PAN_FAIL_OFFSET_RANGE_X_START)))</span>
        <span class="s1">hasCustomActivationCriteria = </span><span class="s0">true</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_PAN_FAIL_OFFSET_RANGE_X_END)) {</span>
        <span class="s1">handler.setFailOffsetXEnd(PixelUtil.toPixelFromDIP(config.getDouble(KEY_PAN_FAIL_OFFSET_RANGE_X_END)))</span>
        <span class="s1">hasCustomActivationCriteria = </span><span class="s0">true</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_PAN_ACTIVE_OFFSET_Y_START)) {</span>
        <span class="s1">handler.setActiveOffsetYStart(PixelUtil.toPixelFromDIP(config.getDouble(KEY_PAN_ACTIVE_OFFSET_Y_START)))</span>
        <span class="s1">hasCustomActivationCriteria = </span><span class="s0">true</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_PAN_ACTIVE_OFFSET_Y_END)) {</span>
        <span class="s1">handler.setActiveOffsetYEnd(PixelUtil.toPixelFromDIP(config.getDouble(KEY_PAN_ACTIVE_OFFSET_Y_END)))</span>
        <span class="s1">hasCustomActivationCriteria = </span><span class="s0">true</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_PAN_FAIL_OFFSET_RANGE_Y_START)) {</span>
        <span class="s1">handler.setFailOffsetYStart(PixelUtil.toPixelFromDIP(config.getDouble(KEY_PAN_FAIL_OFFSET_RANGE_Y_START)))</span>
        <span class="s1">hasCustomActivationCriteria = </span><span class="s0">true</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_PAN_FAIL_OFFSET_RANGE_Y_END)) {</span>
        <span class="s1">handler.setFailOffsetYEnd(PixelUtil.toPixelFromDIP(config.getDouble(KEY_PAN_FAIL_OFFSET_RANGE_Y_END)))</span>
        <span class="s1">hasCustomActivationCriteria = </span><span class="s0">true</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_PAN_MIN_VELOCITY)) {</span>
        <span class="s2">// This value is actually in DPs/ms, but we can use the same function as for converting</span>
        <span class="s2">// from DPs to pixels as the unit we're converting is in the numerator</span>
        <span class="s1">handler.setMinVelocity(PixelUtil.toPixelFromDIP(config.getDouble(KEY_PAN_MIN_VELOCITY)))</span>
        <span class="s1">hasCustomActivationCriteria = </span><span class="s0">true</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_PAN_MIN_VELOCITY_X)) {</span>
        <span class="s1">handler.setMinVelocityX(PixelUtil.toPixelFromDIP(config.getDouble(KEY_PAN_MIN_VELOCITY_X)))</span>
        <span class="s1">hasCustomActivationCriteria = </span><span class="s0">true</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_PAN_MIN_VELOCITY_Y)) {</span>
        <span class="s1">handler.setMinVelocityY(PixelUtil.toPixelFromDIP(config.getDouble(KEY_PAN_MIN_VELOCITY_Y)))</span>
        <span class="s1">hasCustomActivationCriteria = </span><span class="s0">true</span>
      <span class="s1">}</span>

      <span class="s2">// PanGestureHandler sets minDist by default, if there are custom criteria specified we want</span>
      <span class="s2">// to reset that setting and use provided criteria instead.</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_PAN_MIN_DIST)) {</span>
        <span class="s1">handler.setMinDist(PixelUtil.toPixelFromDIP(config.getDouble(KEY_PAN_MIN_DIST)))</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(hasCustomActivationCriteria) {</span>
        <span class="s1">handler.setMinDist(Float.MAX_VALUE)</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_PAN_MIN_POINTERS)) {</span>
        <span class="s1">handler.setMinPointers(config.getInt(KEY_PAN_MIN_POINTERS))</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_PAN_MAX_POINTERS)) {</span>
        <span class="s1">handler.setMaxPointers(config.getInt(KEY_PAN_MAX_POINTERS))</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_PAN_AVG_TOUCHES)) {</span>
        <span class="s1">handler.setAverageTouches(config.getBoolean(KEY_PAN_AVG_TOUCHES))</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_PAN_ACTIVATE_AFTER_LONG_PRESS)) {</span>
        <span class="s1">handler.setActivateAfterLongPress(config.getInt(KEY_PAN_ACTIVATE_AFTER_LONG_PRESS).toLong())</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">extractEventData(handler: PanGestureHandler</span><span class="s0">, </span><span class="s1">eventData: WritableMap) {</span>
      <span class="s0">super</span><span class="s1">.extractEventData(handler</span><span class="s0">, </span><span class="s1">eventData)</span>
      <span class="s1">with(eventData) {</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;x&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.lastRelativePositionX).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;y&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.lastRelativePositionY).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;absoluteX&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.lastPositionInWindowX).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;absoluteY&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.lastPositionInWindowY).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;translationX&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.translationX).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;translationY&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.translationY).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;velocityX&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.velocityX).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;velocityY&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.velocityY).toDouble())</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">class </span><span class="s1">PinchGestureHandlerFactory : HandlerFactory&lt;PinchGestureHandler&gt;() {</span>
    <span class="s1">override </span><span class="s0">val </span><span class="s1">type = PinchGestureHandler::</span><span class="s0">class</span><span class="s1">.java</span>
    <span class="s1">override </span><span class="s0">val </span><span class="s1">name = </span><span class="s3">&quot;PinchGestureHandler&quot;</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">create(context: Context?): PinchGestureHandler {</span>
      <span class="s0">return </span><span class="s1">PinchGestureHandler()</span>
    <span class="s1">}</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">extractEventData(handler: PinchGestureHandler</span><span class="s0">, </span><span class="s1">eventData: WritableMap) {</span>
      <span class="s0">super</span><span class="s1">.extractEventData(handler</span><span class="s0">, </span><span class="s1">eventData)</span>
      <span class="s1">with(eventData) {</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;scale&quot;</span><span class="s0">, </span><span class="s1">handler.scale)</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;focalX&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.focalPointX).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;focalY&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.focalPointY).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;velocity&quot;</span><span class="s0">, </span><span class="s1">handler.velocity)</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">class </span><span class="s1">FlingGestureHandlerFactory : HandlerFactory&lt;FlingGestureHandler&gt;() {</span>
    <span class="s1">override </span><span class="s0">val </span><span class="s1">type = FlingGestureHandler::</span><span class="s0">class</span><span class="s1">.java</span>
    <span class="s1">override </span><span class="s0">val </span><span class="s1">name = </span><span class="s3">&quot;FlingGestureHandler&quot;</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">create(context: Context?): FlingGestureHandler {</span>
      <span class="s0">return </span><span class="s1">FlingGestureHandler()</span>
    <span class="s1">}</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">configure(handler: FlingGestureHandler</span><span class="s0">, </span><span class="s1">config: ReadableMap) {</span>
      <span class="s0">super</span><span class="s1">.configure(handler</span><span class="s0">, </span><span class="s1">config)</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_NUMBER_OF_POINTERS)) {</span>
        <span class="s1">handler.numberOfPointersRequired = config.getInt(KEY_NUMBER_OF_POINTERS)</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(config.hasKey(KEY_DIRECTION)) {</span>
        <span class="s1">handler.direction = config.getInt(KEY_DIRECTION)</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">extractEventData(handler: FlingGestureHandler</span><span class="s0">, </span><span class="s1">eventData: WritableMap) {</span>
      <span class="s0">super</span><span class="s1">.extractEventData(handler</span><span class="s0">, </span><span class="s1">eventData)</span>
      <span class="s1">with(eventData) {</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;x&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.lastRelativePositionX).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;y&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.lastRelativePositionY).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;absoluteX&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.lastPositionInWindowX).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;absoluteY&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.lastPositionInWindowY).toDouble())</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">class </span><span class="s1">RotationGestureHandlerFactory : HandlerFactory&lt;RotationGestureHandler&gt;() {</span>
    <span class="s1">override </span><span class="s0">val </span><span class="s1">type = RotationGestureHandler::</span><span class="s0">class</span><span class="s1">.java</span>
    <span class="s1">override </span><span class="s0">val </span><span class="s1">name = </span><span class="s3">&quot;RotationGestureHandler&quot;</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">create(context: Context?): RotationGestureHandler {</span>
      <span class="s0">return </span><span class="s1">RotationGestureHandler()</span>
    <span class="s1">}</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">extractEventData(handler: RotationGestureHandler</span><span class="s0">, </span><span class="s1">eventData: WritableMap) {</span>
      <span class="s0">super</span><span class="s1">.extractEventData(handler</span><span class="s0">, </span><span class="s1">eventData)</span>
      <span class="s1">with(eventData) {</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;rotation&quot;</span><span class="s0">, </span><span class="s1">handler.rotation)</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;anchorX&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.anchorX).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;anchorY&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(handler.anchorY).toDouble())</span>
        <span class="s1">putDouble(</span><span class="s3">&quot;velocity&quot;</span><span class="s0">, </span><span class="s1">handler.velocity)</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">class </span><span class="s1">ManualGestureHandlerFactory : HandlerFactory&lt;ManualGestureHandler&gt;() {</span>
    <span class="s1">override </span><span class="s0">val </span><span class="s1">type = ManualGestureHandler::</span><span class="s0">class</span><span class="s1">.java</span>
    <span class="s1">override </span><span class="s0">val </span><span class="s1">name = </span><span class="s3">&quot;ManualGestureHandler&quot;</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">create(context: Context?): ManualGestureHandler {</span>
      <span class="s0">return </span><span class="s1">ManualGestureHandler()</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">val </span><span class="s1">eventListener = </span><span class="s0">object </span><span class="s1">: OnTouchEventListener {</span>
    <span class="s1">override </span><span class="s0">fun </span><span class="s1">&lt;T : GestureHandler&lt;T&gt;&gt; onHandlerUpdate(handler: T</span><span class="s0">, </span><span class="s1">event: MotionEvent) {</span>
      <span class="s0">this</span><span class="s1">@RNGestureHandlerModule.onHandlerUpdate(handler)</span>
    <span class="s1">}</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">&lt;T : GestureHandler&lt;T&gt;&gt; onStateChange(handler: T</span><span class="s0">, </span><span class="s1">newState: Int</span><span class="s0">, </span><span class="s1">oldState: Int) {</span>
      <span class="s0">this</span><span class="s1">@RNGestureHandlerModule.onStateChange(handler</span><span class="s0">, </span><span class="s1">newState</span><span class="s0">, </span><span class="s1">oldState)</span>
    <span class="s1">}</span>

    <span class="s1">override </span><span class="s0">fun </span><span class="s1">&lt;T : GestureHandler&lt;T&gt;&gt; onTouchEvent(handler: T) {</span>
      <span class="s0">this</span><span class="s1">@RNGestureHandlerModule.onTouchEvent(handler)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">private </span><span class="s0">val </span><span class="s1">handlerFactories = arrayOf&lt;HandlerFactory&lt;*&gt;&gt;(</span>
    <span class="s1">NativeViewGestureHandlerFactory()</span><span class="s0">,</span>
    <span class="s1">TapGestureHandlerFactory()</span><span class="s0">,</span>
    <span class="s1">LongPressGestureHandlerFactory()</span><span class="s0">,</span>
    <span class="s1">PanGestureHandlerFactory()</span><span class="s0">,</span>
    <span class="s1">PinchGestureHandlerFactory()</span><span class="s0">,</span>
    <span class="s1">RotationGestureHandlerFactory()</span><span class="s0">,</span>
    <span class="s1">FlingGestureHandlerFactory()</span><span class="s0">,</span>
    <span class="s1">ManualGestureHandlerFactory()</span><span class="s0">,</span>
  <span class="s1">)</span>
  <span class="s0">val </span><span class="s1">registry: RNGestureHandlerRegistry = RNGestureHandlerRegistry()</span>
  <span class="s1">private </span><span class="s0">val </span><span class="s1">interactionManager = RNGestureHandlerInteractionManager()</span>
  <span class="s1">private </span><span class="s0">val </span><span class="s1">roots: MutableList&lt;RNGestureHandlerRootHelper&gt; = ArrayList()</span>
  <span class="s1">private </span><span class="s0">val </span><span class="s1">reanimatedEventDispatcher = ReanimatedEventDispatcher()</span>
  <span class="s1">override </span><span class="s0">fun </span><span class="s1">getName() = MODULE_NAME</span>

  <span class="s1">@ReactMethod</span>
  <span class="s1">@Suppress(</span><span class="s3">&quot;UNCHECKED_CAST&quot;</span><span class="s1">)</span>
  <span class="s0">fun </span><span class="s1">&lt;T : GestureHandler&lt;T&gt;&gt; createGestureHandler(</span>
    <span class="s1">handlerName: String</span><span class="s0">,</span>
    <span class="s1">handlerTag: Int</span><span class="s0">,</span>
    <span class="s1">config: ReadableMap</span><span class="s0">,</span>
  <span class="s1">) {</span>
    <span class="s0">for </span><span class="s1">(handlerFactory </span><span class="s0">in </span><span class="s1">handlerFactories </span><span class="s0">as </span><span class="s1">Array&lt;HandlerFactory&lt;T&gt;&gt;) {</span>
      <span class="s0">if </span><span class="s1">(handlerFactory.name == handlerName) {</span>
        <span class="s0">val </span><span class="s1">handler = handlerFactory.create(reactApplicationContext).apply {</span>
          <span class="s1">tag = handlerTag</span>
          <span class="s1">setOnTouchEventListener(eventListener)</span>
        <span class="s1">}</span>
        <span class="s1">registry.registerHandler(handler)</span>
        <span class="s1">interactionManager.configureInteractions(handler</span><span class="s0">, </span><span class="s1">config)</span>
        <span class="s1">handlerFactory.configure(handler</span><span class="s0">, </span><span class="s1">config)</span>
        <span class="s0">return</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">throw </span><span class="s1">JSApplicationIllegalArgumentException(</span><span class="s3">&quot;Invalid handler name </span><span class="s0">$</span><span class="s1">handlerName</span><span class="s3">&quot;</span><span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s1">@ReactMethod</span>
  <span class="s0">fun </span><span class="s1">attachGestureHandler(handlerTag: Int</span><span class="s0">, </span><span class="s1">viewTag: Int</span><span class="s0">, </span><span class="s1">actionType: Int) {</span>
    <span class="s2">// We don't have to handle view flattening in any special way since handlers are stored as</span>
    <span class="s2">// a map: viewTag -&gt; [handler]. If the view with attached handlers was to be flattened</span>
    <span class="s2">// then that viewTag simply wouldn't be visited when traversing the view hierarchy in the</span>
    <span class="s2">// Orchestrator effectively ignoring all handlers attached to flattened views.</span>
    <span class="s0">if </span><span class="s1">(!registry.attachHandlerToView(handlerTag</span><span class="s0">, </span><span class="s1">viewTag</span><span class="s0">, </span><span class="s1">actionType)) {</span>
      <span class="s0">throw </span><span class="s1">JSApplicationIllegalArgumentException(</span><span class="s3">&quot;Handler with tag </span><span class="s0">$</span><span class="s1">handlerTag </span><span class="s3">does not exists&quot;</span><span class="s1">)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ReactMethod</span>
  <span class="s1">@Suppress(</span><span class="s3">&quot;UNCHECKED_CAST&quot;</span><span class="s1">)</span>
  <span class="s0">fun </span><span class="s1">&lt;T : GestureHandler&lt;T&gt;&gt; updateGestureHandler(handlerTag: Int</span><span class="s0">, </span><span class="s1">config: ReadableMap) {</span>
    <span class="s0">val </span><span class="s1">handler = registry.getHandler(handlerTag) </span><span class="s0">as </span><span class="s1">T?</span>
    <span class="s0">if </span><span class="s1">(handler != </span><span class="s0">null</span><span class="s1">) {</span>
      <span class="s0">val </span><span class="s1">factory = findFactoryForHandler(handler)</span>
      <span class="s0">if </span><span class="s1">(factory != </span><span class="s0">null</span><span class="s1">) {</span>
        <span class="s1">interactionManager.dropRelationsForHandlerWithTag(handlerTag)</span>
        <span class="s1">interactionManager.configureInteractions(handler</span><span class="s0">, </span><span class="s1">config)</span>
        <span class="s1">factory.configure(handler</span><span class="s0">, </span><span class="s1">config)</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ReactMethod</span>
  <span class="s0">fun </span><span class="s1">dropGestureHandler(handlerTag: Int) {</span>
    <span class="s1">interactionManager.dropRelationsForHandlerWithTag(handlerTag)</span>
    <span class="s1">registry.dropHandler(handlerTag)</span>
  <span class="s1">}</span>

  <span class="s1">@ReactMethod</span>
  <span class="s0">fun </span><span class="s1">handleSetJSResponder(viewTag: Int</span><span class="s0">, </span><span class="s1">blockNativeResponder: Boolean) {</span>
    <span class="s0">val </span><span class="s1">rootView = findRootHelperForViewAncestor(viewTag)</span>
    <span class="s1">rootView?.handleSetJSResponder(viewTag</span><span class="s0">, </span><span class="s1">blockNativeResponder)</span>
  <span class="s1">}</span>

  <span class="s1">@ReactMethod</span>
  <span class="s0">fun </span><span class="s1">handleClearJSResponder() {</span>
  <span class="s1">}</span>

  <span class="s1">override </span><span class="s0">fun </span><span class="s1">setGestureHandlerState(handlerTag: Int</span><span class="s0">, </span><span class="s1">newState: Int) {</span>
    <span class="s1">registry.getHandler(handlerTag)?.let { handler -&gt;</span>
      <span class="s0">when </span><span class="s1">(newState) {</span>
        <span class="s1">GestureHandler.STATE_ACTIVE -&gt; handler.activate(force = </span><span class="s0">true</span><span class="s1">)</span>
        <span class="s1">GestureHandler.STATE_BEGAN -&gt; handler.begin()</span>
        <span class="s1">GestureHandler.STATE_END -&gt; handler.end()</span>
        <span class="s1">GestureHandler.STATE_FAILED -&gt; handler.fail()</span>
        <span class="s1">GestureHandler.STATE_CANCELLED -&gt; handler.cancel()</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ReactMethod(isBlockingSynchronousMethod = </span><span class="s0">true</span><span class="s1">)</span>
  <span class="s0">fun </span><span class="s1">install(): Boolean {</span>
    <span class="s0">return try </span><span class="s1">{</span>
      <span class="s1">SoLoader.loadLibrary(</span><span class="s3">&quot;gesturehandler&quot;</span><span class="s1">)</span>
      <span class="s0">val </span><span class="s1">jsContext = reactApplicationContext.javaScriptContextHolder</span>
      <span class="s1">decorateRuntime(jsContext.get())</span>
      <span class="s0">true</span>
    <span class="s1">} catch (exception: Exception) {</span>
      <span class="s1">Log.w(</span><span class="s3">&quot;[RNGestureHandler]&quot;</span><span class="s0">, </span><span class="s3">&quot;Could not install JSI bindings.&quot;</span><span class="s1">)</span>
      <span class="s0">false</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private external </span><span class="s0">fun </span><span class="s1">decorateRuntime(jsiPtr: Long)</span>

  <span class="s1">override </span><span class="s0">fun </span><span class="s1">getConstants(): Map&lt;String</span><span class="s0">, </span><span class="s1">Any&gt; {</span>
    <span class="s0">return </span><span class="s1">mapOf(</span>
      <span class="s3">&quot;State&quot; </span><span class="s1">to mapOf(</span>
        <span class="s3">&quot;UNDETERMINED&quot; </span><span class="s1">to GestureHandler.STATE_UNDETERMINED</span><span class="s0">,</span>
        <span class="s3">&quot;BEGAN&quot; </span><span class="s1">to GestureHandler.STATE_BEGAN</span><span class="s0">,</span>
        <span class="s3">&quot;ACTIVE&quot; </span><span class="s1">to GestureHandler.STATE_ACTIVE</span><span class="s0">,</span>
        <span class="s3">&quot;CANCELLED&quot; </span><span class="s1">to GestureHandler.STATE_CANCELLED</span><span class="s0">,</span>
        <span class="s3">&quot;FAILED&quot; </span><span class="s1">to GestureHandler.STATE_FAILED</span><span class="s0">,</span>
        <span class="s3">&quot;END&quot; </span><span class="s1">to GestureHandler.STATE_END</span>
      <span class="s1">)</span><span class="s0">,</span>
      <span class="s3">&quot;Direction&quot; </span><span class="s1">to mapOf(</span>
        <span class="s3">&quot;RIGHT&quot; </span><span class="s1">to GestureHandler.DIRECTION_RIGHT</span><span class="s0">,</span>
        <span class="s3">&quot;LEFT&quot; </span><span class="s1">to GestureHandler.DIRECTION_LEFT</span><span class="s0">,</span>
        <span class="s3">&quot;UP&quot; </span><span class="s1">to GestureHandler.DIRECTION_UP</span><span class="s0">,</span>
        <span class="s3">&quot;DOWN&quot; </span><span class="s1">to GestureHandler.DIRECTION_DOWN</span>
      <span class="s1">)</span>
    <span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s1">override </span><span class="s0">fun </span><span class="s1">onCatalystInstanceDestroy() {</span>
    <span class="s1">registry.dropAllHandlers()</span>
    <span class="s1">interactionManager.reset()</span>
    <span class="s1">synchronized(roots) {</span>
      <span class="s0">while </span><span class="s1">(roots.isNotEmpty()) {</span>
        <span class="s0">val </span><span class="s1">sizeBefore: Int = roots.size</span>
        <span class="s0">val </span><span class="s1">root: RNGestureHandlerRootHelper = roots[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">root.tearDown()</span>
        <span class="s0">if </span><span class="s1">(roots.size &gt;= sizeBefore) {</span>
          <span class="s0">throw </span><span class="s1">IllegalStateException(</span><span class="s3">&quot;Expected root helper to get unregistered while tearing down&quot;</span><span class="s1">)</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">super</span><span class="s1">.onCatalystInstanceDestroy()</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">registerRootHelper(root: RNGestureHandlerRootHelper) {</span>
    <span class="s1">synchronized(roots) {</span>
      <span class="s0">if </span><span class="s1">(root </span><span class="s0">in </span><span class="s1">roots) {</span>
        <span class="s0">throw </span><span class="s1">IllegalStateException(</span><span class="s3">&quot;Root helper</span><span class="s0">$</span><span class="s1">root </span><span class="s3">already registered&quot;</span><span class="s1">)</span>
      <span class="s1">}</span>
      <span class="s1">roots.add(root)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">unregisterRootHelper(root: RNGestureHandlerRootHelper) {</span>
    <span class="s1">synchronized(roots) { roots.remove(root) }</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">findRootHelperForViewAncestor(viewTag: Int): RNGestureHandlerRootHelper? {</span>
    <span class="s2">// TODO: remove resolveRootTagFromReactTag as it's deprecated and unavailable on FabricUIManager</span>
    <span class="s0">val </span><span class="s1">uiManager = reactApplicationContext.UIManager</span>
    <span class="s0">val </span><span class="s1">rootViewTag = uiManager.resolveRootTagFromReactTag(viewTag)</span>
    <span class="s0">if </span><span class="s1">(rootViewTag &lt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s0">return null</span>
    <span class="s1">}</span>
    <span class="s1">synchronized(roots) {</span>
      <span class="s0">return </span><span class="s1">roots.firstOrNull {</span>
        <span class="s1">it.rootView </span><span class="s0">is </span><span class="s1">ReactRootView &amp;&amp; it.rootView.rootViewTag == rootViewTag</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Suppress(</span><span class="s3">&quot;UNCHECKED_CAST&quot;</span><span class="s1">)</span>
  <span class="s1">private </span><span class="s0">fun </span><span class="s1">&lt;T : GestureHandler&lt;T&gt;&gt; findFactoryForHandler(handler: GestureHandler&lt;T&gt;): HandlerFactory&lt;T&gt;? =</span>
    <span class="s1">handlerFactories.firstOrNull { it.type == handler.javaClass } </span><span class="s0">as </span><span class="s1">HandlerFactory&lt;T&gt;?</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">&lt;T : GestureHandler&lt;T&gt;&gt; onHandlerUpdate(handler: T) {</span>
    <span class="s2">// triggers onUpdate and onChange callbacks on the JS side</span>

    <span class="s0">if </span><span class="s1">(handler.tag &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">// root containers use negative tags, we don't need to dispatch events for them to the JS</span>
      <span class="s0">return</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(handler.state == GestureHandler.STATE_ACTIVE) {</span>
      <span class="s0">val </span><span class="s1">handlerFactory = findFactoryForHandler(handler)</span>

      <span class="s0">if </span><span class="s1">(handler.actionType == GestureHandler.ACTION_TYPE_REANIMATED_WORKLET) {</span>
        <span class="s2">// Reanimated worklet</span>
        <span class="s0">val </span><span class="s1">event = RNGestureHandlerEvent.obtain(handler</span><span class="s0">, </span><span class="s1">handlerFactory)</span>
        <span class="s1">sendEventForReanimated(event)</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(handler.actionType == GestureHandler.ACTION_TYPE_NATIVE_ANIMATED_EVENT) {</span>
        <span class="s2">// Animated with useNativeDriver: true</span>
        <span class="s0">val </span><span class="s1">event = RNGestureHandlerEvent.obtain(</span>
          <span class="s1">handler</span><span class="s0">,</span>
          <span class="s1">handlerFactory</span><span class="s0">,</span>
          <span class="s1">useTopPrefixedName = BuildConfig.REACT_NATIVE_MINOR_VERSION &gt;= </span><span class="s4">71</span>
        <span class="s1">)</span>
        <span class="s1">sendEventForNativeAnimatedEvent(event)</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(handler.actionType == GestureHandler.ACTION_TYPE_JS_FUNCTION_OLD_API) {</span>
        <span class="s2">// JS function, Animated.event with useNativeDriver: false using old API</span>
        <span class="s0">if </span><span class="s1">(BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {</span>
          <span class="s0">val </span><span class="s1">data = RNGestureHandlerEvent.createEventData(handler</span><span class="s0">, </span><span class="s1">handlerFactory)</span>
          <span class="s1">sendEventForDeviceEvent(RNGestureHandlerEvent.EVENT_NAME</span><span class="s0">, </span><span class="s1">data)</span>
        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
          <span class="s0">val </span><span class="s1">event = RNGestureHandlerEvent.obtain(handler</span><span class="s0">, </span><span class="s1">handlerFactory)</span>
          <span class="s1">sendEventForDirectEvent(event)</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(handler.actionType == GestureHandler.ACTION_TYPE_JS_FUNCTION_NEW_API) {</span>
        <span class="s2">// JS function, Animated.event with useNativeDriver: false using new API</span>
        <span class="s0">val </span><span class="s1">data = RNGestureHandlerEvent.createEventData(handler</span><span class="s0">, </span><span class="s1">handlerFactory)</span>
        <span class="s1">sendEventForDeviceEvent(RNGestureHandlerEvent.EVENT_NAME</span><span class="s0">, </span><span class="s1">data)</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">&lt;T : GestureHandler&lt;T&gt;&gt; onStateChange(handler: T</span><span class="s0">, </span><span class="s1">newState: Int</span><span class="s0">, </span><span class="s1">oldState: Int) {</span>
    <span class="s2">// triggers onBegin, onStart, onEnd, onFinalize callbacks on the JS side</span>

    <span class="s0">if </span><span class="s1">(handler.tag &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">// root containers use negative tags, we don't need to dispatch events for them to the JS</span>
      <span class="s0">return</span>
    <span class="s1">}</span>
    <span class="s0">val </span><span class="s1">handlerFactory = findFactoryForHandler(handler)</span>

    <span class="s0">if </span><span class="s1">(handler.actionType == GestureHandler.ACTION_TYPE_REANIMATED_WORKLET) {</span>
      <span class="s2">// Reanimated worklet</span>
      <span class="s0">val </span><span class="s1">event = RNGestureHandlerStateChangeEvent.obtain(handler</span><span class="s0">, </span><span class="s1">newState</span><span class="s0">, </span><span class="s1">oldState</span><span class="s0">, </span><span class="s1">handlerFactory)</span>
      <span class="s1">sendEventForReanimated(event)</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(handler.actionType == GestureHandler.ACTION_TYPE_NATIVE_ANIMATED_EVENT ||</span>
      <span class="s1">handler.actionType == GestureHandler.ACTION_TYPE_JS_FUNCTION_OLD_API</span>
    <span class="s1">) {</span>
      <span class="s2">// JS function or Animated.event with useNativeDriver: false with old API</span>
      <span class="s0">if </span><span class="s1">(BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {</span>
        <span class="s0">val </span><span class="s1">data = RNGestureHandlerStateChangeEvent.createEventData(handler</span><span class="s0">, </span><span class="s1">handlerFactory</span><span class="s0">, </span><span class="s1">newState</span><span class="s0">, </span><span class="s1">oldState)</span>
        <span class="s1">sendEventForDeviceEvent(RNGestureHandlerStateChangeEvent.EVENT_NAME</span><span class="s0">, </span><span class="s1">data)</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s0">val </span><span class="s1">event = RNGestureHandlerStateChangeEvent.obtain(handler</span><span class="s0">, </span><span class="s1">newState</span><span class="s0">, </span><span class="s1">oldState</span><span class="s0">, </span><span class="s1">handlerFactory)</span>
        <span class="s1">sendEventForDirectEvent(event)</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(handler.actionType == GestureHandler.ACTION_TYPE_JS_FUNCTION_NEW_API) {</span>
      <span class="s2">// JS function or Animated.event with useNativeDriver: false with new API</span>
      <span class="s0">val </span><span class="s1">data = RNGestureHandlerStateChangeEvent.createEventData(handler</span><span class="s0">, </span><span class="s1">handlerFactory</span><span class="s0">, </span><span class="s1">newState</span><span class="s0">, </span><span class="s1">oldState)</span>
      <span class="s1">sendEventForDeviceEvent(RNGestureHandlerStateChangeEvent.EVENT_NAME</span><span class="s0">, </span><span class="s1">data)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">&lt;T : GestureHandler&lt;T&gt;&gt; onTouchEvent(handler: T) {</span>
    <span class="s2">// triggers onTouchesDown, onTouchesMove, onTouchesUp, onTouchesCancelled callbacks on the JS side</span>

    <span class="s0">if </span><span class="s1">(handler.tag &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">// root containers use negative tags, we don't need to dispatch events for them to the JS</span>
      <span class="s0">return</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(handler.state == GestureHandler.STATE_BEGAN || handler.state == GestureHandler.STATE_ACTIVE ||</span>
      <span class="s1">handler.state == GestureHandler.STATE_UNDETERMINED || handler.view != </span><span class="s0">null</span>
    <span class="s1">) {</span>
      <span class="s0">if </span><span class="s1">(handler.actionType == GestureHandler.ACTION_TYPE_REANIMATED_WORKLET) {</span>
        <span class="s2">// Reanimated worklet</span>
        <span class="s0">val </span><span class="s1">event = RNGestureHandlerTouchEvent.obtain(handler)</span>
        <span class="s1">sendEventForReanimated(event)</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(handler.actionType == GestureHandler.ACTION_TYPE_JS_FUNCTION_NEW_API) {</span>
        <span class="s2">// JS function, Animated.event with useNativeDriver: false with new API</span>
        <span class="s0">val </span><span class="s1">data = RNGestureHandlerTouchEvent.createEventData(handler)</span>
        <span class="s1">sendEventForDeviceEvent(RNGestureHandlerEvent.EVENT_NAME</span><span class="s0">, </span><span class="s1">data)</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">&lt;T : Event&lt;T&gt;&gt;sendEventForReanimated(event: T) {</span>
    <span class="s2">// Delivers the event to Reanimated.</span>
    <span class="s0">if </span><span class="s1">(BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {</span>
      <span class="s2">// Send event directly to Reanimated</span>
      <span class="s1">reanimatedEventDispatcher.sendEvent(event</span><span class="s0">, </span><span class="s1">reactApplicationContext)</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s2">// In the old architecture, Reanimated subscribes for specific direct events.</span>
      <span class="s1">sendEventForDirectEvent(event)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">sendEventForNativeAnimatedEvent(event: RNGestureHandlerEvent) {</span>
    <span class="s2">// Delivers the event to NativeAnimatedModule.</span>
    <span class="s2">// TODO: send event directly to NativeAnimated[Turbo]Module</span>
    <span class="s2">// ReactContext.dispatchEvent is an extension function, depending on the architecture it will</span>
    <span class="s2">// dispatch event using UIManagerModule or FabricUIManager.</span>
    <span class="s1">reactApplicationContext.dispatchEvent(event)</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">&lt;T : Event&lt;T&gt;&gt;sendEventForDirectEvent(event: T) {</span>
    <span class="s2">// Delivers the event to JS as a direct event. This method is called only on Paper.</span>
    <span class="s1">reactApplicationContext.dispatchEvent(event)</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">sendEventForDeviceEvent(eventName: String</span><span class="s0">, </span><span class="s1">data: WritableMap) {</span>
    <span class="s2">// Delivers the event to JS as a device event.</span>
    <span class="s1">reactApplicationContext.deviceEventEmitter.emit(eventName</span><span class="s0">, </span><span class="s1">data)</span>
  <span class="s1">}</span>

  <span class="s1">companion </span><span class="s0">object </span><span class="s1">{</span>
    <span class="s1">const </span><span class="s0">val </span><span class="s1">MODULE_NAME = </span><span class="s3">&quot;RNGestureHandlerModule&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_SHOULD_CANCEL_WHEN_OUTSIDE = </span><span class="s3">&quot;shouldCancelWhenOutside&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_ENABLED = </span><span class="s3">&quot;enabled&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_NEEDS_POINTER_DATA = </span><span class="s3">&quot;needsPointerData&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_MANUAL_ACTIVATION = </span><span class="s3">&quot;manualActivation&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_HIT_SLOP = </span><span class="s3">&quot;hitSlop&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_HIT_SLOP_LEFT = </span><span class="s3">&quot;left&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_HIT_SLOP_TOP = </span><span class="s3">&quot;top&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_HIT_SLOP_RIGHT = </span><span class="s3">&quot;right&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_HIT_SLOP_BOTTOM = </span><span class="s3">&quot;bottom&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_HIT_SLOP_VERTICAL = </span><span class="s3">&quot;vertical&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_HIT_SLOP_HORIZONTAL = </span><span class="s3">&quot;horizontal&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_HIT_SLOP_WIDTH = </span><span class="s3">&quot;width&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_HIT_SLOP_HEIGHT = </span><span class="s3">&quot;height&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_NATIVE_VIEW_SHOULD_ACTIVATE_ON_START = </span><span class="s3">&quot;shouldActivateOnStart&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_NATIVE_VIEW_DISALLOW_INTERRUPTION = </span><span class="s3">&quot;disallowInterruption&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_TAP_NUMBER_OF_TAPS = </span><span class="s3">&quot;numberOfTaps&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_TAP_MAX_DURATION_MS = </span><span class="s3">&quot;maxDurationMs&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_TAP_MAX_DELAY_MS = </span><span class="s3">&quot;maxDelayMs&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_TAP_MAX_DELTA_X = </span><span class="s3">&quot;maxDeltaX&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_TAP_MAX_DELTA_Y = </span><span class="s3">&quot;maxDeltaY&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_TAP_MAX_DIST = </span><span class="s3">&quot;maxDist&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_TAP_MIN_POINTERS = </span><span class="s3">&quot;minPointers&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_LONG_PRESS_MIN_DURATION_MS = </span><span class="s3">&quot;minDurationMs&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_LONG_PRESS_MAX_DIST = </span><span class="s3">&quot;maxDist&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_PAN_ACTIVE_OFFSET_X_START = </span><span class="s3">&quot;activeOffsetXStart&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_PAN_ACTIVE_OFFSET_X_END = </span><span class="s3">&quot;activeOffsetXEnd&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_PAN_FAIL_OFFSET_RANGE_X_START = </span><span class="s3">&quot;failOffsetXStart&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_PAN_FAIL_OFFSET_RANGE_X_END = </span><span class="s3">&quot;failOffsetXEnd&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_PAN_ACTIVE_OFFSET_Y_START = </span><span class="s3">&quot;activeOffsetYStart&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_PAN_ACTIVE_OFFSET_Y_END = </span><span class="s3">&quot;activeOffsetYEnd&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_PAN_FAIL_OFFSET_RANGE_Y_START = </span><span class="s3">&quot;failOffsetYStart&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_PAN_FAIL_OFFSET_RANGE_Y_END = </span><span class="s3">&quot;failOffsetYEnd&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_PAN_MIN_DIST = </span><span class="s3">&quot;minDist&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_PAN_MIN_VELOCITY = </span><span class="s3">&quot;minVelocity&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_PAN_MIN_VELOCITY_X = </span><span class="s3">&quot;minVelocityX&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_PAN_MIN_VELOCITY_Y = </span><span class="s3">&quot;minVelocityY&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_PAN_MIN_POINTERS = </span><span class="s3">&quot;minPointers&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_PAN_MAX_POINTERS = </span><span class="s3">&quot;maxPointers&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_PAN_AVG_TOUCHES = </span><span class="s3">&quot;avgTouches&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_PAN_ACTIVATE_AFTER_LONG_PRESS = </span><span class="s3">&quot;activateAfterLongPress&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_NUMBER_OF_POINTERS = </span><span class="s3">&quot;numberOfPointers&quot;</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">KEY_DIRECTION = </span><span class="s3">&quot;direction&quot;</span>

    <span class="s1">private </span><span class="s0">fun </span><span class="s1">handleHitSlopProperty(handler: GestureHandler&lt;*&gt;</span><span class="s0">, </span><span class="s1">config: ReadableMap) {</span>
      <span class="s0">if </span><span class="s1">(config.getType(KEY_HIT_SLOP) == ReadableType.Number) {</span>
        <span class="s0">val </span><span class="s1">hitSlop = PixelUtil.toPixelFromDIP(config.getDouble(KEY_HIT_SLOP))</span>
        <span class="s1">handler.setHitSlop(hitSlop</span><span class="s0">, </span><span class="s1">hitSlop</span><span class="s0">, </span><span class="s1">hitSlop</span><span class="s0">, </span><span class="s1">hitSlop</span><span class="s0">, </span><span class="s1">GestureHandler.HIT_SLOP_NONE</span><span class="s0">, </span><span class="s1">GestureHandler.HIT_SLOP_NONE)</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s0">val </span><span class="s1">hitSlop = config.getMap(KEY_HIT_SLOP)!!</span>
        <span class="s0">var </span><span class="s1">left = GestureHandler.HIT_SLOP_NONE</span>
        <span class="s0">var </span><span class="s1">top = GestureHandler.HIT_SLOP_NONE</span>
        <span class="s0">var </span><span class="s1">right = GestureHandler.HIT_SLOP_NONE</span>
        <span class="s0">var </span><span class="s1">bottom = GestureHandler.HIT_SLOP_NONE</span>
        <span class="s0">var </span><span class="s1">width = GestureHandler.HIT_SLOP_NONE</span>
        <span class="s0">var </span><span class="s1">height = GestureHandler.HIT_SLOP_NONE</span>
        <span class="s0">if </span><span class="s1">(hitSlop.hasKey(KEY_HIT_SLOP_HORIZONTAL)) {</span>
          <span class="s0">val </span><span class="s1">horizontalPad = PixelUtil.toPixelFromDIP(hitSlop.getDouble(KEY_HIT_SLOP_HORIZONTAL))</span>
          <span class="s1">right = horizontalPad</span>
          <span class="s1">left = right</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(hitSlop.hasKey(KEY_HIT_SLOP_VERTICAL)) {</span>
          <span class="s0">val </span><span class="s1">verticalPad = PixelUtil.toPixelFromDIP(hitSlop.getDouble(KEY_HIT_SLOP_VERTICAL))</span>
          <span class="s1">bottom = verticalPad</span>
          <span class="s1">top = bottom</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(hitSlop.hasKey(KEY_HIT_SLOP_LEFT)) {</span>
          <span class="s1">left = PixelUtil.toPixelFromDIP(hitSlop.getDouble(KEY_HIT_SLOP_LEFT))</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(hitSlop.hasKey(KEY_HIT_SLOP_TOP)) {</span>
          <span class="s1">top = PixelUtil.toPixelFromDIP(hitSlop.getDouble(KEY_HIT_SLOP_TOP))</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(hitSlop.hasKey(KEY_HIT_SLOP_RIGHT)) {</span>
          <span class="s1">right = PixelUtil.toPixelFromDIP(hitSlop.getDouble(KEY_HIT_SLOP_RIGHT))</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(hitSlop.hasKey(KEY_HIT_SLOP_BOTTOM)) {</span>
          <span class="s1">bottom = PixelUtil.toPixelFromDIP(hitSlop.getDouble(KEY_HIT_SLOP_BOTTOM))</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(hitSlop.hasKey(KEY_HIT_SLOP_WIDTH)) {</span>
          <span class="s1">width = PixelUtil.toPixelFromDIP(hitSlop.getDouble(KEY_HIT_SLOP_WIDTH))</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(hitSlop.hasKey(KEY_HIT_SLOP_HEIGHT)) {</span>
          <span class="s1">height = PixelUtil.toPixelFromDIP(hitSlop.getDouble(KEY_HIT_SLOP_HEIGHT))</span>
        <span class="s1">}</span>
        <span class="s1">handler.setHitSlop(left</span><span class="s0">, </span><span class="s1">top</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">bottom</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height)</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
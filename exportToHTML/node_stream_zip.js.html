<html>
<head>
<title>node_stream_zip.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #cc7832;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
node_stream_zip.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @license node-stream-zip | (c) 2020 Antelle | https://github.com/antelle/node-stream-zip/blob/master/LICENSE 
 * Portions copyright https://github.com/cthackers/adm-zip | https://raw.githubusercontent.com/cthackers/adm-zip/master/LICENSE 
 */</span>

<span class="s1">let fs = require(</span><span class="s2">'fs'</span><span class="s1">);</span>
<span class="s1">const util = require(</span><span class="s2">'util'</span><span class="s1">);</span>
<span class="s1">const path = require(</span><span class="s2">'path'</span><span class="s1">);</span>
<span class="s1">const events = require(</span><span class="s2">'events'</span><span class="s1">);</span>
<span class="s1">const zlib = require(</span><span class="s2">'zlib'</span><span class="s1">);</span>
<span class="s1">const stream = require(</span><span class="s2">'stream'</span><span class="s1">);</span>

<span class="s1">const consts = {</span>
    <span class="s0">/* The local file header */</span>
    <span class="s1">LOCHDR: </span><span class="s3">30</span><span class="s1">, </span><span class="s0">// LOC header size</span>
    <span class="s1">LOCSIG: </span><span class="s3">0</span><span class="s1">x04034b50, </span><span class="s0">// &quot;PK\003\004&quot;</span>
    <span class="s1">LOCVER: </span><span class="s3">4</span><span class="s1">, </span><span class="s0">// version needed to extract</span>
    <span class="s1">LOCFLG: </span><span class="s3">6</span><span class="s1">, </span><span class="s0">// general purpose bit flag</span>
    <span class="s1">LOCHOW: </span><span class="s3">8</span><span class="s1">, </span><span class="s0">// compression method</span>
    <span class="s1">LOCTIM: </span><span class="s3">10</span><span class="s1">, </span><span class="s0">// modification time (2 bytes time, 2 bytes date)</span>
    <span class="s1">LOCCRC: </span><span class="s3">14</span><span class="s1">, </span><span class="s0">// uncompressed file crc-32 value</span>
    <span class="s1">LOCSIZ: </span><span class="s3">18</span><span class="s1">, </span><span class="s0">// compressed size</span>
    <span class="s1">LOCLEN: </span><span class="s3">22</span><span class="s1">, </span><span class="s0">// uncompressed size</span>
    <span class="s1">LOCNAM: </span><span class="s3">26</span><span class="s1">, </span><span class="s0">// filename length</span>
    <span class="s1">LOCEXT: </span><span class="s3">28</span><span class="s1">, </span><span class="s0">// extra field length</span>

    <span class="s0">/* The Data descriptor */</span>
    <span class="s1">EXTSIG: </span><span class="s3">0</span><span class="s1">x08074b50, </span><span class="s0">// &quot;PK\007\008&quot;</span>
    <span class="s1">EXTHDR: </span><span class="s3">16</span><span class="s1">, </span><span class="s0">// EXT header size</span>
    <span class="s1">EXTCRC: </span><span class="s3">4</span><span class="s1">, </span><span class="s0">// uncompressed file crc-32 value</span>
    <span class="s1">EXTSIZ: </span><span class="s3">8</span><span class="s1">, </span><span class="s0">// compressed size</span>
    <span class="s1">EXTLEN: </span><span class="s3">12</span><span class="s1">, </span><span class="s0">// uncompressed size</span>

    <span class="s0">/* The central directory file header */</span>
    <span class="s1">CENHDR: </span><span class="s3">46</span><span class="s1">, </span><span class="s0">// CEN header size</span>
    <span class="s1">CENSIG: </span><span class="s3">0</span><span class="s1">x02014b50, </span><span class="s0">// &quot;PK\001\002&quot;</span>
    <span class="s1">CENVEM: </span><span class="s3">4</span><span class="s1">, </span><span class="s0">// version made by</span>
    <span class="s1">CENVER: </span><span class="s3">6</span><span class="s1">, </span><span class="s0">// version needed to extract</span>
    <span class="s1">CENFLG: </span><span class="s3">8</span><span class="s1">, </span><span class="s0">// encrypt, decrypt flags</span>
    <span class="s1">CENHOW: </span><span class="s3">10</span><span class="s1">, </span><span class="s0">// compression method</span>
    <span class="s1">CENTIM: </span><span class="s3">12</span><span class="s1">, </span><span class="s0">// modification time (2 bytes time, 2 bytes date)</span>
    <span class="s1">CENCRC: </span><span class="s3">16</span><span class="s1">, </span><span class="s0">// uncompressed file crc-32 value</span>
    <span class="s1">CENSIZ: </span><span class="s3">20</span><span class="s1">, </span><span class="s0">// compressed size</span>
    <span class="s1">CENLEN: </span><span class="s3">24</span><span class="s1">, </span><span class="s0">// uncompressed size</span>
    <span class="s1">CENNAM: </span><span class="s3">28</span><span class="s1">, </span><span class="s0">// filename length</span>
    <span class="s1">CENEXT: </span><span class="s3">30</span><span class="s1">, </span><span class="s0">// extra field length</span>
    <span class="s1">CENCOM: </span><span class="s3">32</span><span class="s1">, </span><span class="s0">// file comment length</span>
    <span class="s1">CENDSK: </span><span class="s3">34</span><span class="s1">, </span><span class="s0">// volume number start</span>
    <span class="s1">CENATT: </span><span class="s3">36</span><span class="s1">, </span><span class="s0">// internal file attributes</span>
    <span class="s1">CENATX: </span><span class="s3">38</span><span class="s1">, </span><span class="s0">// external file attributes (host system dependent)</span>
    <span class="s1">CENOFF: </span><span class="s3">42</span><span class="s1">, </span><span class="s0">// LOC header offset</span>

    <span class="s0">/* The entries in the end of central directory */</span>
    <span class="s1">ENDHDR: </span><span class="s3">22</span><span class="s1">, </span><span class="s0">// END header size</span>
    <span class="s1">ENDSIG: </span><span class="s3">0</span><span class="s1">x06054b50, </span><span class="s0">// &quot;PK\005\006&quot;</span>
    <span class="s1">ENDSIGFIRST: </span><span class="s3">0</span><span class="s1">x50,</span>
    <span class="s1">ENDSUB: </span><span class="s3">8</span><span class="s1">, </span><span class="s0">// number of entries on this disk</span>
    <span class="s1">ENDTOT: </span><span class="s3">10</span><span class="s1">, </span><span class="s0">// total number of entries</span>
    <span class="s1">ENDSIZ: </span><span class="s3">12</span><span class="s1">, </span><span class="s0">// central directory size in bytes</span>
    <span class="s1">ENDOFF: </span><span class="s3">16</span><span class="s1">, </span><span class="s0">// offset of first CEN header</span>
    <span class="s1">ENDCOM: </span><span class="s3">20</span><span class="s1">, </span><span class="s0">// zip file comment length</span>
    <span class="s1">MAXFILECOMMENT: </span><span class="s3">0</span><span class="s1">xffff,</span>

    <span class="s0">/* The entries in the end of ZIP64 central directory locator */</span>
    <span class="s1">ENDL64HDR: </span><span class="s3">20</span><span class="s1">, </span><span class="s0">// ZIP64 end of central directory locator header size</span>
    <span class="s1">ENDL64SIG: </span><span class="s3">0</span><span class="s1">x07064b50, </span><span class="s0">// ZIP64 end of central directory locator signature</span>
    <span class="s1">ENDL64SIGFIRST: </span><span class="s3">0</span><span class="s1">x50,</span>
    <span class="s1">ENDL64OFS: </span><span class="s3">8</span><span class="s1">, </span><span class="s0">// ZIP64 end of central directory offset</span>

    <span class="s0">/* The entries in the end of ZIP64 central directory */</span>
    <span class="s1">END64HDR: </span><span class="s3">56</span><span class="s1">, </span><span class="s0">// ZIP64 end of central directory header size</span>
    <span class="s1">END64SIG: </span><span class="s3">0</span><span class="s1">x06064b50, </span><span class="s0">// ZIP64 end of central directory signature</span>
    <span class="s1">END64SIGFIRST: </span><span class="s3">0</span><span class="s1">x50,</span>
    <span class="s1">END64SUB: </span><span class="s3">24</span><span class="s1">, </span><span class="s0">// number of entries on this disk</span>
    <span class="s1">END64TOT: </span><span class="s3">32</span><span class="s1">, </span><span class="s0">// total number of entries</span>
    <span class="s1">END64SIZ: </span><span class="s3">40</span><span class="s1">,</span>
    <span class="s1">END64OFF: </span><span class="s3">48</span><span class="s1">,</span>

    <span class="s0">/* Compression methods */</span>
    <span class="s1">STORED: </span><span class="s3">0</span><span class="s1">, </span><span class="s0">// no compression</span>
    <span class="s1">SHRUNK: </span><span class="s3">1</span><span class="s1">, </span><span class="s0">// shrunk</span>
    <span class="s1">REDUCED1: </span><span class="s3">2</span><span class="s1">, </span><span class="s0">// reduced with compression factor 1</span>
    <span class="s1">REDUCED2: </span><span class="s3">3</span><span class="s1">, </span><span class="s0">// reduced with compression factor 2</span>
    <span class="s1">REDUCED3: </span><span class="s3">4</span><span class="s1">, </span><span class="s0">// reduced with compression factor 3</span>
    <span class="s1">REDUCED4: </span><span class="s3">5</span><span class="s1">, </span><span class="s0">// reduced with compression factor 4</span>
    <span class="s1">IMPLODED: </span><span class="s3">6</span><span class="s1">, </span><span class="s0">// imploded</span>
    <span class="s0">// 7 reserved</span>
    <span class="s1">DEFLATED: </span><span class="s3">8</span><span class="s1">, </span><span class="s0">// deflated</span>
    <span class="s1">ENHANCED_DEFLATED: </span><span class="s3">9</span><span class="s1">, </span><span class="s0">// deflate64</span>
    <span class="s1">PKWARE: </span><span class="s3">10</span><span class="s1">, </span><span class="s0">// PKWare DCL imploded</span>
    <span class="s0">// 11 reserved</span>
    <span class="s1">BZIP2: </span><span class="s3">12</span><span class="s1">, </span><span class="s0">//  compressed using BZIP2</span>
    <span class="s0">// 13 reserved</span>
    <span class="s1">LZMA: </span><span class="s3">14</span><span class="s1">, </span><span class="s0">// LZMA</span>
    <span class="s0">// 15-17 reserved</span>
    <span class="s1">IBM_TERSE: </span><span class="s3">18</span><span class="s1">, </span><span class="s0">// compressed using IBM TERSE</span>
    <span class="s1">IBM_LZ77: </span><span class="s3">19</span><span class="s1">, </span><span class="s0">//IBM LZ77 z</span>

    <span class="s0">/* General purpose bit flag */</span>
    <span class="s1">FLG_ENC: </span><span class="s3">0</span><span class="s1">, </span><span class="s0">// encrypted file</span>
    <span class="s1">FLG_COMP1: </span><span class="s3">1</span><span class="s1">, </span><span class="s0">// compression option</span>
    <span class="s1">FLG_COMP2: </span><span class="s3">2</span><span class="s1">, </span><span class="s0">// compression option</span>
    <span class="s1">FLG_DESC: </span><span class="s3">4</span><span class="s1">, </span><span class="s0">// data descriptor</span>
    <span class="s1">FLG_ENH: </span><span class="s3">8</span><span class="s1">, </span><span class="s0">// enhanced deflation</span>
    <span class="s1">FLG_STR: </span><span class="s3">16</span><span class="s1">, </span><span class="s0">// strong encryption</span>
    <span class="s1">FLG_LNG: </span><span class="s3">1024</span><span class="s1">, </span><span class="s0">// language encoding</span>
    <span class="s1">FLG_MSK: </span><span class="s3">4096</span><span class="s1">, </span><span class="s0">// mask header values</span>
    <span class="s1">FLG_ENTRY_ENC: </span><span class="s3">1</span><span class="s1">,</span>

    <span class="s0">/* 4.5 Extensible data fields */</span>
    <span class="s1">EF_ID: </span><span class="s3">0</span><span class="s1">,</span>
    <span class="s1">EF_SIZE: </span><span class="s3">2</span><span class="s1">,</span>

    <span class="s0">/* Header IDs */</span>
    <span class="s1">ID_ZIP64: </span><span class="s3">0</span><span class="s1">x0001,</span>
    <span class="s1">ID_AVINFO: </span><span class="s3">0</span><span class="s1">x0007,</span>
    <span class="s1">ID_PFS: </span><span class="s3">0</span><span class="s1">x0008,</span>
    <span class="s1">ID_OS2: </span><span class="s3">0</span><span class="s1">x0009,</span>
    <span class="s1">ID_NTFS: </span><span class="s3">0</span><span class="s1">x000a,</span>
    <span class="s1">ID_OPENVMS: </span><span class="s3">0</span><span class="s1">x000c,</span>
    <span class="s1">ID_UNIX: </span><span class="s3">0</span><span class="s1">x000d,</span>
    <span class="s1">ID_FORK: </span><span class="s3">0</span><span class="s1">x000e,</span>
    <span class="s1">ID_PATCH: </span><span class="s3">0</span><span class="s1">x000f,</span>
    <span class="s1">ID_X509_PKCS7: </span><span class="s3">0</span><span class="s1">x0014,</span>
    <span class="s1">ID_X509_CERTID_F: </span><span class="s3">0</span><span class="s1">x0015,</span>
    <span class="s1">ID_X509_CERTID_C: </span><span class="s3">0</span><span class="s1">x0016,</span>
    <span class="s1">ID_STRONGENC: </span><span class="s3">0</span><span class="s1">x0017,</span>
    <span class="s1">ID_RECORD_MGT: </span><span class="s3">0</span><span class="s1">x0018,</span>
    <span class="s1">ID_X509_PKCS7_RL: </span><span class="s3">0</span><span class="s1">x0019,</span>
    <span class="s1">ID_IBM1: </span><span class="s3">0</span><span class="s1">x0065,</span>
    <span class="s1">ID_IBM2: </span><span class="s3">0</span><span class="s1">x0066,</span>
    <span class="s1">ID_POSZIP: </span><span class="s3">0</span><span class="s1">x4690,</span>

    <span class="s1">EF_ZIP64_OR_32: </span><span class="s3">0</span><span class="s1">xffffffff,</span>
    <span class="s1">EF_ZIP64_OR_16: </span><span class="s3">0</span><span class="s1">xffff,</span>
<span class="s1">};</span>

<span class="s1">const StreamZip = </span><span class="s4">function </span><span class="s1">(config) {</span>
    <span class="s1">let fd, fileSize, chunkSize, op, centralDirectory, closed;</span>
    <span class="s1">const ready = </span><span class="s4">false</span><span class="s1">,</span>
        <span class="s1">that = </span><span class="s4">this</span><span class="s1">,</span>
        <span class="s1">entries = config.storeEntries !== </span><span class="s4">false </span><span class="s1">? {} : </span><span class="s4">null</span><span class="s1">,</span>
        <span class="s1">fileName = config.file,</span>
        <span class="s1">textDecoder = config.nameEncoding ? </span><span class="s4">new </span><span class="s1">TextDecoder(config.nameEncoding) : </span><span class="s4">null</span><span class="s1">;</span>

    <span class="s1">open();</span>

    <span class="s4">function </span><span class="s1">open() {</span>
        <span class="s4">if </span><span class="s1">(config.fd) {</span>
            <span class="s1">fd = config.fd;</span>
            <span class="s1">readFile();</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
            <span class="s1">fs.open(fileName, </span><span class="s2">'r'</span><span class="s1">, (err, f) =&gt; {</span>
                <span class="s4">if </span><span class="s1">(err) {</span>
                    <span class="s4">return </span><span class="s1">that.emit(</span><span class="s2">'error'</span><span class="s1">, err);</span>
                <span class="s1">}</span>
                <span class="s1">fd = f;</span>
                <span class="s1">readFile();</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">function </span><span class="s1">readFile() {</span>
        <span class="s1">fs.fstat(fd, (err, stat) =&gt; {</span>
            <span class="s4">if </span><span class="s1">(err) {</span>
                <span class="s4">return </span><span class="s1">that.emit(</span><span class="s2">'error'</span><span class="s1">, err);</span>
            <span class="s1">}</span>
            <span class="s1">fileSize = stat.size;</span>
            <span class="s1">chunkSize = config.chunkSize || Math.round(fileSize / </span><span class="s3">1000</span><span class="s1">);</span>
            <span class="s1">chunkSize = Math.max(</span>
                <span class="s1">Math.min(chunkSize, Math.min(</span><span class="s3">128 </span><span class="s1">* </span><span class="s3">1024</span><span class="s1">, fileSize)),</span>
                <span class="s1">Math.min(</span><span class="s3">1024</span><span class="s1">, fileSize)</span>
            <span class="s1">);</span>
            <span class="s1">readCentralDirectory();</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s4">function </span><span class="s1">readUntilFoundCallback(err, bytesRead) {</span>
        <span class="s4">if </span><span class="s1">(err || !bytesRead) {</span>
            <span class="s4">return </span><span class="s1">that.emit(</span><span class="s2">'error'</span><span class="s1">, err || </span><span class="s4">new </span><span class="s1">Error(</span><span class="s2">'Archive read error'</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s1">let pos = op.lastPos;</span>
        <span class="s1">let bufferPosition = pos - op.win.position;</span>
        <span class="s1">const buffer = op.win.buffer;</span>
        <span class="s1">const minPos = op.minPos;</span>
        <span class="s4">while </span><span class="s1">(--pos &gt;= minPos &amp;&amp; --bufferPosition &gt;= </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s4">if </span><span class="s1">(buffer.length - bufferPosition &gt;= </span><span class="s3">4 </span><span class="s1">&amp;&amp; buffer[bufferPosition] === op.firstByte) {</span>
                <span class="s0">// quick check first signature byte</span>
                <span class="s4">if </span><span class="s1">(buffer.readUInt32LE(bufferPosition) === op.sig) {</span>
                    <span class="s1">op.lastBufferPosition = bufferPosition;</span>
                    <span class="s1">op.lastBytesRead = bytesRead;</span>
                    <span class="s1">op.complete();</span>
                    <span class="s4">return</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">if </span><span class="s1">(pos === minPos) {</span>
            <span class="s4">return </span><span class="s1">that.emit(</span><span class="s2">'error'</span><span class="s1">, </span><span class="s4">new </span><span class="s1">Error(</span><span class="s2">'Bad archive'</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s1">op.lastPos = pos + </span><span class="s3">1</span><span class="s1">;</span>
        <span class="s1">op.chunkSize *= </span><span class="s3">2</span><span class="s1">;</span>
        <span class="s4">if </span><span class="s1">(pos &lt;= minPos) {</span>
            <span class="s4">return </span><span class="s1">that.emit(</span><span class="s2">'error'</span><span class="s1">, </span><span class="s4">new </span><span class="s1">Error(</span><span class="s2">'Bad archive'</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s1">const expandLength = Math.min(op.chunkSize, pos - minPos);</span>
        <span class="s1">op.win.expandLeft(expandLength, readUntilFoundCallback);</span>
    <span class="s1">}</span>

    <span class="s4">function </span><span class="s1">readCentralDirectory() {</span>
        <span class="s1">const totalReadLength = Math.min(consts.ENDHDR + consts.MAXFILECOMMENT, fileSize);</span>
        <span class="s1">op = {</span>
            <span class="s1">win: </span><span class="s4">new </span><span class="s1">FileWindowBuffer(fd),</span>
            <span class="s1">totalReadLength,</span>
            <span class="s1">minPos: fileSize - totalReadLength,</span>
            <span class="s1">lastPos: fileSize,</span>
            <span class="s1">chunkSize: Math.min(</span><span class="s3">1024</span><span class="s1">, chunkSize),</span>
            <span class="s1">firstByte: consts.ENDSIGFIRST,</span>
            <span class="s1">sig: consts.ENDSIG,</span>
            <span class="s1">complete: readCentralDirectoryComplete,</span>
        <span class="s1">};</span>
        <span class="s1">op.win.read(fileSize - op.chunkSize, op.chunkSize, readUntilFoundCallback);</span>
    <span class="s1">}</span>

    <span class="s4">function </span><span class="s1">readCentralDirectoryComplete() {</span>
        <span class="s1">const buffer = op.win.buffer;</span>
        <span class="s1">const pos = op.lastBufferPosition;</span>
        <span class="s4">try </span><span class="s1">{</span>
            <span class="s1">centralDirectory = </span><span class="s4">new </span><span class="s1">CentralDirectoryHeader();</span>
            <span class="s1">centralDirectory.read(buffer.slice(pos, pos + consts.ENDHDR));</span>
            <span class="s1">centralDirectory.headerOffset = op.win.position + pos;</span>
            <span class="s4">if </span><span class="s1">(centralDirectory.commentLength) {</span>
                <span class="s1">that.comment = buffer</span>
                    <span class="s1">.slice(</span>
                        <span class="s1">pos + consts.ENDHDR,</span>
                        <span class="s1">pos + consts.ENDHDR + centralDirectory.commentLength</span>
                    <span class="s1">)</span>
                    <span class="s1">.toString();</span>
            <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
                <span class="s1">that.comment = </span><span class="s4">null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">that.entriesCount = centralDirectory.volumeEntries;</span>
            <span class="s1">that.centralDirectory = centralDirectory;</span>
            <span class="s4">if </span><span class="s1">(</span>
                <span class="s1">(centralDirectory.volumeEntries === consts.EF_ZIP64_OR_16 &amp;&amp;</span>
                    <span class="s1">centralDirectory.totalEntries === consts.EF_ZIP64_OR_16) ||</span>
                <span class="s1">centralDirectory.size === consts.EF_ZIP64_OR_32 ||</span>
                <span class="s1">centralDirectory.offset === consts.EF_ZIP64_OR_32</span>
            <span class="s1">) {</span>
                <span class="s1">readZip64CentralDirectoryLocator();</span>
            <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
                <span class="s1">op = {};</span>
                <span class="s1">readEntries();</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s4">catch </span><span class="s1">(err) {</span>
            <span class="s1">that.emit(</span><span class="s2">'error'</span><span class="s1">, err);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">function </span><span class="s1">readZip64CentralDirectoryLocator() {</span>
        <span class="s1">const length = consts.ENDL64HDR;</span>
        <span class="s4">if </span><span class="s1">(op.lastBufferPosition &gt; length) {</span>
            <span class="s1">op.lastBufferPosition -= length;</span>
            <span class="s1">readZip64CentralDirectoryLocatorComplete();</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
            <span class="s1">op = {</span>
                <span class="s1">win: op.win,</span>
                <span class="s1">totalReadLength: length,</span>
                <span class="s1">minPos: op.win.position - length,</span>
                <span class="s1">lastPos: op.win.position,</span>
                <span class="s1">chunkSize: op.chunkSize,</span>
                <span class="s1">firstByte: consts.ENDL64SIGFIRST,</span>
                <span class="s1">sig: consts.ENDL64SIG,</span>
                <span class="s1">complete: readZip64CentralDirectoryLocatorComplete,</span>
            <span class="s1">};</span>
            <span class="s1">op.win.read(op.lastPos - op.chunkSize, op.chunkSize, readUntilFoundCallback);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">function </span><span class="s1">readZip64CentralDirectoryLocatorComplete() {</span>
        <span class="s1">const buffer = op.win.buffer;</span>
        <span class="s1">const locHeader = </span><span class="s4">new </span><span class="s1">CentralDirectoryLoc64Header();</span>
        <span class="s1">locHeader.read(</span>
            <span class="s1">buffer.slice(op.lastBufferPosition, op.lastBufferPosition + consts.ENDL64HDR)</span>
        <span class="s1">);</span>
        <span class="s1">const readLength = fileSize - locHeader.headerOffset;</span>
        <span class="s1">op = {</span>
            <span class="s1">win: op.win,</span>
            <span class="s1">totalReadLength: readLength,</span>
            <span class="s1">minPos: locHeader.headerOffset,</span>
            <span class="s1">lastPos: op.lastPos,</span>
            <span class="s1">chunkSize: op.chunkSize,</span>
            <span class="s1">firstByte: consts.END64SIGFIRST,</span>
            <span class="s1">sig: consts.END64SIG,</span>
            <span class="s1">complete: readZip64CentralDirectoryComplete,</span>
        <span class="s1">};</span>
        <span class="s1">op.win.read(fileSize - op.chunkSize, op.chunkSize, readUntilFoundCallback);</span>
    <span class="s1">}</span>

    <span class="s4">function </span><span class="s1">readZip64CentralDirectoryComplete() {</span>
        <span class="s1">const buffer = op.win.buffer;</span>
        <span class="s1">const zip64cd = </span><span class="s4">new </span><span class="s1">CentralDirectoryZip64Header();</span>
        <span class="s1">zip64cd.read(buffer.slice(op.lastBufferPosition, op.lastBufferPosition + consts.END64HDR));</span>
        <span class="s1">that.centralDirectory.volumeEntries = zip64cd.volumeEntries;</span>
        <span class="s1">that.centralDirectory.totalEntries = zip64cd.totalEntries;</span>
        <span class="s1">that.centralDirectory.size = zip64cd.size;</span>
        <span class="s1">that.centralDirectory.offset = zip64cd.offset;</span>
        <span class="s1">that.entriesCount = zip64cd.volumeEntries;</span>
        <span class="s1">op = {};</span>
        <span class="s1">readEntries();</span>
    <span class="s1">}</span>

    <span class="s4">function </span><span class="s1">readEntries() {</span>
        <span class="s1">op = {</span>
            <span class="s1">win: </span><span class="s4">new </span><span class="s1">FileWindowBuffer(fd),</span>
            <span class="s1">pos: centralDirectory.offset,</span>
            <span class="s1">chunkSize,</span>
            <span class="s1">entriesLeft: centralDirectory.volumeEntries,</span>
        <span class="s1">};</span>
        <span class="s1">op.win.read(op.pos, Math.min(chunkSize, fileSize - op.pos), readEntriesCallback);</span>
    <span class="s1">}</span>

    <span class="s4">function </span><span class="s1">readEntriesCallback(err, bytesRead) {</span>
        <span class="s4">if </span><span class="s1">(err || !bytesRead) {</span>
            <span class="s4">return </span><span class="s1">that.emit(</span><span class="s2">'error'</span><span class="s1">, err || </span><span class="s4">new </span><span class="s1">Error(</span><span class="s2">'Entries read error'</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s1">let bufferPos = op.pos - op.win.position;</span>
        <span class="s1">let entry = op.entry;</span>
        <span class="s1">const buffer = op.win.buffer;</span>
        <span class="s1">const bufferLength = buffer.length;</span>
        <span class="s4">try </span><span class="s1">{</span>
            <span class="s4">while </span><span class="s1">(op.entriesLeft &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s4">if </span><span class="s1">(!entry) {</span>
                    <span class="s1">entry = </span><span class="s4">new </span><span class="s1">ZipEntry();</span>
                    <span class="s1">entry.readHeader(buffer, bufferPos);</span>
                    <span class="s1">entry.headerOffset = op.win.position + bufferPos;</span>
                    <span class="s1">op.entry = entry;</span>
                    <span class="s1">op.pos += consts.CENHDR;</span>
                    <span class="s1">bufferPos += consts.CENHDR;</span>
                <span class="s1">}</span>
                <span class="s1">const entryHeaderSize = entry.fnameLen + entry.extraLen + entry.comLen;</span>
                <span class="s1">const advanceBytes = entryHeaderSize + (op.entriesLeft &gt; </span><span class="s3">1 </span><span class="s1">? consts.CENHDR : </span><span class="s3">0</span><span class="s1">);</span>
                <span class="s4">if </span><span class="s1">(bufferLength - bufferPos &lt; advanceBytes) {</span>
                    <span class="s1">op.win.moveRight(chunkSize, readEntriesCallback, bufferPos);</span>
                    <span class="s1">op.move = </span><span class="s4">true</span><span class="s1">;</span>
                    <span class="s4">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">entry.read(buffer, bufferPos, textDecoder);</span>
                <span class="s4">if </span><span class="s1">(!config.skipEntryNameValidation) {</span>
                    <span class="s1">entry.validateName();</span>
                <span class="s1">}</span>
                <span class="s4">if </span><span class="s1">(entries) {</span>
                    <span class="s1">entries[entry.name] = entry;</span>
                <span class="s1">}</span>
                <span class="s1">that.emit(</span><span class="s2">'entry'</span><span class="s1">, entry);</span>
                <span class="s1">op.entry = entry = </span><span class="s4">null</span><span class="s1">;</span>
                <span class="s1">op.entriesLeft--;</span>
                <span class="s1">op.pos += entryHeaderSize;</span>
                <span class="s1">bufferPos += entryHeaderSize;</span>
            <span class="s1">}</span>
            <span class="s1">that.emit(</span><span class="s2">'ready'</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s4">catch </span><span class="s1">(err) {</span>
            <span class="s1">that.emit(</span><span class="s2">'error'</span><span class="s1">, err);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">function </span><span class="s1">checkEntriesExist() {</span>
        <span class="s4">if </span><span class="s1">(!entries) {</span>
            <span class="s4">throw new </span><span class="s1">Error(</span><span class="s2">'storeEntries disabled'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">Object.defineProperty(</span><span class="s4">this</span><span class="s1">, </span><span class="s2">'ready'</span><span class="s1">, {</span>
        <span class="s1">get() {</span>
            <span class="s4">return </span><span class="s1">ready;</span>
        <span class="s1">},</span>
    <span class="s1">});</span>

    <span class="s4">this</span><span class="s1">.entry = </span><span class="s4">function </span><span class="s1">(name) {</span>
        <span class="s1">checkEntriesExist();</span>
        <span class="s4">return </span><span class="s1">entries[name];</span>
    <span class="s1">};</span>

    <span class="s4">this</span><span class="s1">.entries = </span><span class="s4">function </span><span class="s1">() {</span>
        <span class="s1">checkEntriesExist();</span>
        <span class="s4">return </span><span class="s1">entries;</span>
    <span class="s1">};</span>

    <span class="s4">this</span><span class="s1">.stream = </span><span class="s4">function </span><span class="s1">(entry, callback) {</span>
        <span class="s4">return this</span><span class="s1">.openEntry(</span>
            <span class="s1">entry,</span>
            <span class="s1">(err, entry) =&gt; {</span>
                <span class="s4">if </span><span class="s1">(err) {</span>
                    <span class="s4">return </span><span class="s1">callback(err);</span>
                <span class="s1">}</span>
                <span class="s1">const offset = dataOffset(entry);</span>
                <span class="s1">let entryStream = </span><span class="s4">new </span><span class="s1">EntryDataReaderStream(fd, offset, entry.compressedSize);</span>
                <span class="s4">if </span><span class="s1">(entry.method === consts.STORED) {</span>
                    <span class="s0">// nothing to do</span>
                <span class="s1">} </span><span class="s4">else if </span><span class="s1">(entry.method === consts.DEFLATED) {</span>
                    <span class="s1">entryStream = entryStream.pipe(zlib.createInflateRaw());</span>
                <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
                    <span class="s4">return </span><span class="s1">callback(</span><span class="s4">new </span><span class="s1">Error(</span><span class="s2">'Unknown compression method: ' </span><span class="s1">+ entry.method));</span>
                <span class="s1">}</span>
                <span class="s4">if </span><span class="s1">(canVerifyCrc(entry)) {</span>
                    <span class="s1">entryStream = entryStream.pipe(</span>
                        <span class="s4">new </span><span class="s1">EntryVerifyStream(entryStream, entry.crc, entry.size)</span>
                    <span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s1">callback(</span><span class="s4">null</span><span class="s1">, entryStream);</span>
            <span class="s1">},</span>
            <span class="s4">false</span>
        <span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s4">this</span><span class="s1">.entryDataSync = </span><span class="s4">function </span><span class="s1">(entry) {</span>
        <span class="s1">let err = </span><span class="s4">null</span><span class="s1">;</span>
        <span class="s4">this</span><span class="s1">.openEntry(</span>
            <span class="s1">entry,</span>
            <span class="s1">(e, en) =&gt; {</span>
                <span class="s1">err = e;</span>
                <span class="s1">entry = en;</span>
            <span class="s1">},</span>
            <span class="s4">true</span>
        <span class="s1">);</span>
        <span class="s4">if </span><span class="s1">(err) {</span>
            <span class="s4">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s1">let data = Buffer.alloc(entry.compressedSize);</span>
        <span class="s4">new </span><span class="s1">FsRead(fd, data, </span><span class="s3">0</span><span class="s1">, entry.compressedSize, dataOffset(entry), (e) =&gt; {</span>
            <span class="s1">err = e;</span>
        <span class="s1">}).read(</span><span class="s4">true</span><span class="s1">);</span>
        <span class="s4">if </span><span class="s1">(err) {</span>
            <span class="s4">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s4">if </span><span class="s1">(entry.method === consts.STORED) {</span>
            <span class="s0">// nothing to do</span>
        <span class="s1">} </span><span class="s4">else if </span><span class="s1">(entry.method === consts.DEFLATED || entry.method === consts.ENHANCED_DEFLATED) {</span>
            <span class="s1">data = zlib.inflateRawSync(data);</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
            <span class="s4">throw new </span><span class="s1">Error(</span><span class="s2">'Unknown compression method: ' </span><span class="s1">+ entry.method);</span>
        <span class="s1">}</span>
        <span class="s4">if </span><span class="s1">(data.length !== entry.size) {</span>
            <span class="s4">throw new </span><span class="s1">Error(</span><span class="s2">'Invalid size'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s4">if </span><span class="s1">(canVerifyCrc(entry)) {</span>
            <span class="s1">const verify = </span><span class="s4">new </span><span class="s1">CrcVerify(entry.crc, entry.size);</span>
            <span class="s1">verify.data(data);</span>
        <span class="s1">}</span>
        <span class="s4">return </span><span class="s1">data;</span>
    <span class="s1">};</span>

    <span class="s4">this</span><span class="s1">.openEntry = </span><span class="s4">function </span><span class="s1">(entry, callback, sync) {</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s1">entry === </span><span class="s2">'string'</span><span class="s1">) {</span>
            <span class="s1">checkEntriesExist();</span>
            <span class="s1">entry = entries[entry];</span>
            <span class="s4">if </span><span class="s1">(!entry) {</span>
                <span class="s4">return </span><span class="s1">callback(</span><span class="s4">new </span><span class="s1">Error(</span><span class="s2">'Entry not found'</span><span class="s1">));</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">if </span><span class="s1">(!entry.isFile) {</span>
            <span class="s4">return </span><span class="s1">callback(</span><span class="s4">new </span><span class="s1">Error(</span><span class="s2">'Entry is not file'</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s4">if </span><span class="s1">(!fd) {</span>
            <span class="s4">return </span><span class="s1">callback(</span><span class="s4">new </span><span class="s1">Error(</span><span class="s2">'Archive closed'</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s1">const buffer = Buffer.alloc(consts.LOCHDR);</span>
        <span class="s4">new </span><span class="s1">FsRead(fd, buffer, </span><span class="s3">0</span><span class="s1">, buffer.length, entry.offset, (err) =&gt; {</span>
            <span class="s4">if </span><span class="s1">(err) {</span>
                <span class="s4">return </span><span class="s1">callback(err);</span>
            <span class="s1">}</span>
            <span class="s1">let readEx;</span>
            <span class="s4">try </span><span class="s1">{</span>
                <span class="s1">entry.readDataHeader(buffer);</span>
                <span class="s4">if </span><span class="s1">(entry.encrypted) {</span>
                    <span class="s1">readEx = </span><span class="s4">new </span><span class="s1">Error(</span><span class="s2">'Entry encrypted'</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s4">catch </span><span class="s1">(ex) {</span>
                <span class="s1">readEx = ex;</span>
            <span class="s1">}</span>
            <span class="s1">callback(readEx, entry);</span>
        <span class="s1">}).read(sync);</span>
    <span class="s1">};</span>

    <span class="s4">function </span><span class="s1">dataOffset(entry) {</span>
        <span class="s4">return </span><span class="s1">entry.offset + consts.LOCHDR + entry.fnameLen + entry.extraLen;</span>
    <span class="s1">}</span>

    <span class="s4">function </span><span class="s1">canVerifyCrc(entry) {</span>
        <span class="s0">// if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written</span>
        <span class="s4">return </span><span class="s1">(entry.flags &amp; </span><span class="s3">0</span><span class="s1">x8) !== </span><span class="s3">0</span><span class="s1">x8;</span>
    <span class="s1">}</span>

    <span class="s4">function </span><span class="s1">extract(entry, outPath, callback) {</span>
        <span class="s1">that.stream(entry, (err, stm) =&gt; {</span>
            <span class="s4">if </span><span class="s1">(err) {</span>
                <span class="s1">callback(err);</span>
            <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
                <span class="s1">let fsStm, errThrown;</span>
                <span class="s1">stm.on(</span><span class="s2">'error'</span><span class="s1">, (err) =&gt; {</span>
                    <span class="s1">errThrown = err;</span>
                    <span class="s4">if </span><span class="s1">(fsStm) {</span>
                        <span class="s1">stm.unpipe(fsStm);</span>
                        <span class="s1">fsStm.close(() =&gt; {</span>
                            <span class="s1">callback(err);</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s1">fs.open(outPath, </span><span class="s2">'w'</span><span class="s1">, (err, fdFile) =&gt; {</span>
                    <span class="s4">if </span><span class="s1">(err) {</span>
                        <span class="s4">return </span><span class="s1">callback(err);</span>
                    <span class="s1">}</span>
                    <span class="s4">if </span><span class="s1">(errThrown) {</span>
                        <span class="s1">fs.close(fd, () =&gt; {</span>
                            <span class="s1">callback(errThrown);</span>
                        <span class="s1">});</span>
                        <span class="s4">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s1">fsStm = fs.createWriteStream(outPath, { fd: fdFile });</span>
                    <span class="s1">fsStm.on(</span><span class="s2">'finish'</span><span class="s1">, () =&gt; {</span>
                        <span class="s1">that.emit(</span><span class="s2">'extract'</span><span class="s1">, entry, outPath);</span>
                        <span class="s4">if </span><span class="s1">(!errThrown) {</span>
                            <span class="s1">callback();</span>
                        <span class="s1">}</span>
                    <span class="s1">});</span>
                    <span class="s1">stm.pipe(fsStm);</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s4">function </span><span class="s1">createDirectories(baseDir, dirs, callback) {</span>
        <span class="s4">if </span><span class="s1">(!dirs.length) {</span>
            <span class="s4">return </span><span class="s1">callback();</span>
        <span class="s1">}</span>
        <span class="s1">let dir = dirs.shift();</span>
        <span class="s1">dir = path.join(baseDir, path.join(...dir));</span>
        <span class="s1">fs.mkdir(dir, { recursive: </span><span class="s4">true </span><span class="s1">}, (err) =&gt; {</span>
            <span class="s4">if </span><span class="s1">(err &amp;&amp; err.code !== </span><span class="s2">'EEXIST'</span><span class="s1">) {</span>
                <span class="s4">return </span><span class="s1">callback(err);</span>
            <span class="s1">}</span>
            <span class="s1">createDirectories(baseDir, dirs, callback);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s4">function </span><span class="s1">extractFiles(baseDir, baseRelPath, files, callback, extractedCount) {</span>
        <span class="s4">if </span><span class="s1">(!files.length) {</span>
            <span class="s4">return </span><span class="s1">callback(</span><span class="s4">null</span><span class="s1">, extractedCount);</span>
        <span class="s1">}</span>
        <span class="s1">const file = files.shift();</span>
        <span class="s1">const targetPath = path.join(baseDir, file.name.replace(baseRelPath, </span><span class="s2">''</span><span class="s1">));</span>
        <span class="s1">extract(file, targetPath, (err) =&gt; {</span>
            <span class="s4">if </span><span class="s1">(err) {</span>
                <span class="s4">return </span><span class="s1">callback(err, extractedCount);</span>
            <span class="s1">}</span>
            <span class="s1">extractFiles(baseDir, baseRelPath, files, callback, extractedCount + </span><span class="s3">1</span><span class="s1">);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s4">this</span><span class="s1">.extract = </span><span class="s4">function </span><span class="s1">(entry, outPath, callback) {</span>
        <span class="s1">let entryName = entry || </span><span class="s2">''</span><span class="s1">;</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s1">entry === </span><span class="s2">'string'</span><span class="s1">) {</span>
            <span class="s1">entry = </span><span class="s4">this</span><span class="s1">.entry(entry);</span>
            <span class="s4">if </span><span class="s1">(entry) {</span>
                <span class="s1">entryName = entry.name;</span>
            <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
                <span class="s4">if </span><span class="s1">(entryName.length &amp;&amp; entryName[entryName.length - </span><span class="s3">1</span><span class="s1">] !== </span><span class="s2">'/'</span><span class="s1">) {</span>
                    <span class="s1">entryName += </span><span class="s2">'/'</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">if </span><span class="s1">(!entry || entry.isDirectory) {</span>
            <span class="s1">const files = [],</span>
                <span class="s1">dirs = [],</span>
                <span class="s1">allDirs = {};</span>
            <span class="s4">for </span><span class="s1">(const e </span><span class="s4">in </span><span class="s1">entries) {</span>
                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">Object.prototype.hasOwnProperty.call(entries, e) &amp;&amp;</span>
                    <span class="s1">e.lastIndexOf(entryName, </span><span class="s3">0</span><span class="s1">) === </span><span class="s3">0</span>
                <span class="s1">) {</span>
                    <span class="s1">let relPath = e.replace(entryName, </span><span class="s2">''</span><span class="s1">);</span>
                    <span class="s1">const childEntry = entries[e];</span>
                    <span class="s4">if </span><span class="s1">(childEntry.isFile) {</span>
                        <span class="s1">files.push(childEntry);</span>
                        <span class="s1">relPath = path.dirname(relPath);</span>
                    <span class="s1">}</span>
                    <span class="s4">if </span><span class="s1">(relPath &amp;&amp; !allDirs[relPath] &amp;&amp; relPath !== </span><span class="s2">'.'</span><span class="s1">) {</span>
                        <span class="s1">allDirs[relPath] = </span><span class="s4">true</span><span class="s1">;</span>
                        <span class="s1">let parts = relPath.split(</span><span class="s2">'/'</span><span class="s1">).filter((f) =&gt; {</span>
                            <span class="s4">return </span><span class="s1">f;</span>
                        <span class="s1">});</span>
                        <span class="s4">if </span><span class="s1">(parts.length) {</span>
                            <span class="s1">dirs.push(parts);</span>
                        <span class="s1">}</span>
                        <span class="s4">while </span><span class="s1">(parts.length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
                            <span class="s1">parts = parts.slice(</span><span class="s3">0</span><span class="s1">, parts.length - </span><span class="s3">1</span><span class="s1">);</span>
                            <span class="s1">const partsPath = parts.join(</span><span class="s2">'/'</span><span class="s1">);</span>
                            <span class="s4">if </span><span class="s1">(allDirs[partsPath] || partsPath === </span><span class="s2">'.'</span><span class="s1">) {</span>
                                <span class="s4">break</span><span class="s1">;</span>
                            <span class="s1">}</span>
                            <span class="s1">allDirs[partsPath] = </span><span class="s4">true</span><span class="s1">;</span>
                            <span class="s1">dirs.push(parts);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">dirs.sort((x, y) =&gt; {</span>
                <span class="s4">return </span><span class="s1">x.length - y.length;</span>
            <span class="s1">});</span>
            <span class="s4">if </span><span class="s1">(dirs.length) {</span>
                <span class="s1">createDirectories(outPath, dirs, (err) =&gt; {</span>
                    <span class="s4">if </span><span class="s1">(err) {</span>
                        <span class="s1">callback(err);</span>
                    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
                        <span class="s1">extractFiles(outPath, entryName, files, callback, </span><span class="s3">0</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
                <span class="s1">extractFiles(outPath, entryName, files, callback, </span><span class="s3">0</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
            <span class="s1">fs.stat(outPath, (err, stat) =&gt; {</span>
                <span class="s4">if </span><span class="s1">(stat &amp;&amp; stat.isDirectory()) {</span>
                    <span class="s1">extract(entry, path.join(outPath, path.basename(entry.name)), callback);</span>
                <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
                    <span class="s1">extract(entry, outPath, callback);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s4">this</span><span class="s1">.close = </span><span class="s4">function </span><span class="s1">(callback) {</span>
        <span class="s4">if </span><span class="s1">(closed || !fd) {</span>
            <span class="s1">closed = </span><span class="s4">true</span><span class="s1">;</span>
            <span class="s4">if </span><span class="s1">(callback) {</span>
                <span class="s1">callback();</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
            <span class="s1">closed = </span><span class="s4">true</span><span class="s1">;</span>
            <span class="s1">fs.close(fd, (err) =&gt; {</span>
                <span class="s1">fd = </span><span class="s4">null</span><span class="s1">;</span>
                <span class="s4">if </span><span class="s1">(callback) {</span>
                    <span class="s1">callback(err);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">const originalEmit = events.EventEmitter.prototype.emit;</span>
    <span class="s4">this</span><span class="s1">.emit = </span><span class="s4">function </span><span class="s1">(...args) {</span>
        <span class="s4">if </span><span class="s1">(!closed) {</span>
            <span class="s4">return </span><span class="s1">originalEmit.call(</span><span class="s4">this</span><span class="s1">, ...args);</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
<span class="s1">};</span>

<span class="s1">StreamZip.setFs = </span><span class="s4">function </span><span class="s1">(customFs) {</span>
    <span class="s1">fs = customFs;</span>
<span class="s1">};</span>

<span class="s1">StreamZip.debugLog = (...args) =&gt; {</span>
    <span class="s4">if </span><span class="s1">(StreamZip.debug) {</span>
        <span class="s0">// eslint-disable-next-line no-console</span>
        <span class="s1">console.log(...args);</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">util.inherits(StreamZip, events.EventEmitter);</span>

<span class="s1">const propZip = Symbol(</span><span class="s2">'zip'</span><span class="s1">);</span>

<span class="s1">StreamZip.async = class StreamZipAsync extends events.EventEmitter {</span>
    <span class="s1">constructor(config) {</span>
        <span class="s1">super();</span>

        <span class="s1">const zip = </span><span class="s4">new </span><span class="s1">StreamZip(config);</span>

        <span class="s1">zip.on(</span><span class="s2">'entry'</span><span class="s1">, (entry) =&gt; </span><span class="s4">this</span><span class="s1">.emit(</span><span class="s2">'entry'</span><span class="s1">, entry));</span>
        <span class="s1">zip.on(</span><span class="s2">'extract'</span><span class="s1">, (entry, outPath) =&gt; </span><span class="s4">this</span><span class="s1">.emit(</span><span class="s2">'extract'</span><span class="s1">, entry, outPath));</span>

        <span class="s4">this</span><span class="s1">[propZip] = </span><span class="s4">new </span><span class="s1">Promise((resolve, reject) =&gt; {</span>
            <span class="s1">zip.on(</span><span class="s2">'ready'</span><span class="s1">, () =&gt; {</span>
                <span class="s1">zip.removeListener(</span><span class="s2">'error'</span><span class="s1">, reject);</span>
                <span class="s1">resolve(zip);</span>
            <span class="s1">});</span>
            <span class="s1">zip.on(</span><span class="s2">'error'</span><span class="s1">, reject);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s1">get entriesCount() {</span>
        <span class="s4">return this</span><span class="s1">[propZip].then((zip) =&gt; zip.entriesCount);</span>
    <span class="s1">}</span>

    <span class="s1">get comment() {</span>
        <span class="s4">return this</span><span class="s1">[propZip].then((zip) =&gt; zip.comment);</span>
    <span class="s1">}</span>

    <span class="s1">async entry(name) {</span>
        <span class="s1">const zip = await </span><span class="s4">this</span><span class="s1">[propZip];</span>
        <span class="s4">return </span><span class="s1">zip.entry(name);</span>
    <span class="s1">}</span>

    <span class="s1">async entries() {</span>
        <span class="s1">const zip = await </span><span class="s4">this</span><span class="s1">[propZip];</span>
        <span class="s4">return </span><span class="s1">zip.entries();</span>
    <span class="s1">}</span>

    <span class="s1">async stream(entry) {</span>
        <span class="s1">const zip = await </span><span class="s4">this</span><span class="s1">[propZip];</span>
        <span class="s4">return new </span><span class="s1">Promise((resolve, reject) =&gt; {</span>
            <span class="s1">zip.stream(entry, (err, stm) =&gt; {</span>
                <span class="s4">if </span><span class="s1">(err) {</span>
                    <span class="s1">reject(err);</span>
                <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
                    <span class="s1">resolve(stm);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s1">async entryData(entry) {</span>
        <span class="s1">const stm = await </span><span class="s4">this</span><span class="s1">.stream(entry);</span>
        <span class="s4">return new </span><span class="s1">Promise((resolve, reject) =&gt; {</span>
            <span class="s1">const data = [];</span>
            <span class="s1">stm.on(</span><span class="s2">'data'</span><span class="s1">, (chunk) =&gt; data.push(chunk));</span>
            <span class="s1">stm.on(</span><span class="s2">'end'</span><span class="s1">, () =&gt; {</span>
                <span class="s1">resolve(Buffer.concat(data));</span>
            <span class="s1">});</span>
            <span class="s1">stm.on(</span><span class="s2">'error'</span><span class="s1">, (err) =&gt; {</span>
                <span class="s1">stm.removeAllListeners(</span><span class="s2">'end'</span><span class="s1">);</span>
                <span class="s1">reject(err);</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s1">async extract(entry, outPath) {</span>
        <span class="s1">const zip = await </span><span class="s4">this</span><span class="s1">[propZip];</span>
        <span class="s4">return new </span><span class="s1">Promise((resolve, reject) =&gt; {</span>
            <span class="s1">zip.extract(entry, outPath, (err, res) =&gt; {</span>
                <span class="s4">if </span><span class="s1">(err) {</span>
                    <span class="s1">reject(err);</span>
                <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
                    <span class="s1">resolve(res);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s1">async close() {</span>
        <span class="s1">const zip = await </span><span class="s4">this</span><span class="s1">[propZip];</span>
        <span class="s4">return new </span><span class="s1">Promise((resolve, reject) =&gt; {</span>
            <span class="s1">zip.close((err) =&gt; {</span>
                <span class="s4">if </span><span class="s1">(err) {</span>
                    <span class="s1">reject(err);</span>
                <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
                    <span class="s1">resolve();</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">class CentralDirectoryHeader {</span>
    <span class="s1">read(data) {</span>
        <span class="s4">if </span><span class="s1">(data.length !== consts.ENDHDR || data.readUInt32LE(</span><span class="s3">0</span><span class="s1">) !== consts.ENDSIG) {</span>
            <span class="s4">throw new </span><span class="s1">Error(</span><span class="s2">'Invalid central directory'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">// number of entries on this volume</span>
        <span class="s4">this</span><span class="s1">.volumeEntries = data.readUInt16LE(consts.ENDSUB);</span>
        <span class="s0">// total number of entries</span>
        <span class="s4">this</span><span class="s1">.totalEntries = data.readUInt16LE(consts.ENDTOT);</span>
        <span class="s0">// central directory size in bytes</span>
        <span class="s4">this</span><span class="s1">.size = data.readUInt32LE(consts.ENDSIZ);</span>
        <span class="s0">// offset of first CEN header</span>
        <span class="s4">this</span><span class="s1">.offset = data.readUInt32LE(consts.ENDOFF);</span>
        <span class="s0">// zip file comment length</span>
        <span class="s4">this</span><span class="s1">.commentLength = data.readUInt16LE(consts.ENDCOM);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">class CentralDirectoryLoc64Header {</span>
    <span class="s1">read(data) {</span>
        <span class="s4">if </span><span class="s1">(data.length !== consts.ENDL64HDR || data.readUInt32LE(</span><span class="s3">0</span><span class="s1">) !== consts.ENDL64SIG) {</span>
            <span class="s4">throw new </span><span class="s1">Error(</span><span class="s2">'Invalid zip64 central directory locator'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">// ZIP64 EOCD header offset</span>
        <span class="s4">this</span><span class="s1">.headerOffset = readUInt64LE(data, consts.ENDSUB);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">class CentralDirectoryZip64Header {</span>
    <span class="s1">read(data) {</span>
        <span class="s4">if </span><span class="s1">(data.length !== consts.END64HDR || data.readUInt32LE(</span><span class="s3">0</span><span class="s1">) !== consts.END64SIG) {</span>
            <span class="s4">throw new </span><span class="s1">Error(</span><span class="s2">'Invalid central directory'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">// number of entries on this volume</span>
        <span class="s4">this</span><span class="s1">.volumeEntries = readUInt64LE(data, consts.END64SUB);</span>
        <span class="s0">// total number of entries</span>
        <span class="s4">this</span><span class="s1">.totalEntries = readUInt64LE(data, consts.END64TOT);</span>
        <span class="s0">// central directory size in bytes</span>
        <span class="s4">this</span><span class="s1">.size = readUInt64LE(data, consts.END64SIZ);</span>
        <span class="s0">// offset of first CEN header</span>
        <span class="s4">this</span><span class="s1">.offset = readUInt64LE(data, consts.END64OFF);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">class ZipEntry {</span>
    <span class="s1">readHeader(data, offset) {</span>
        <span class="s0">// data should be 46 bytes and start with &quot;PK 01 02&quot;</span>
        <span class="s4">if </span><span class="s1">(data.length &lt; offset + consts.CENHDR || data.readUInt32LE(offset) !== consts.CENSIG) {</span>
            <span class="s4">throw new </span><span class="s1">Error(</span><span class="s2">'Invalid entry header'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">// version made by</span>
        <span class="s4">this</span><span class="s1">.verMade = data.readUInt16LE(offset + consts.CENVEM);</span>
        <span class="s0">// version needed to extract</span>
        <span class="s4">this</span><span class="s1">.version = data.readUInt16LE(offset + consts.CENVER);</span>
        <span class="s0">// encrypt, decrypt flags</span>
        <span class="s4">this</span><span class="s1">.flags = data.readUInt16LE(offset + consts.CENFLG);</span>
        <span class="s0">// compression method</span>
        <span class="s4">this</span><span class="s1">.method = data.readUInt16LE(offset + consts.CENHOW);</span>
        <span class="s0">// modification time (2 bytes time, 2 bytes date)</span>
        <span class="s1">const timebytes = data.readUInt16LE(offset + consts.CENTIM);</span>
        <span class="s1">const datebytes = data.readUInt16LE(offset + consts.CENTIM + </span><span class="s3">2</span><span class="s1">);</span>
        <span class="s4">this</span><span class="s1">.time = parseZipTime(timebytes, datebytes);</span>

        <span class="s0">// uncompressed file crc-32 value</span>
        <span class="s4">this</span><span class="s1">.crc = data.readUInt32LE(offset + consts.CENCRC);</span>
        <span class="s0">// compressed size</span>
        <span class="s4">this</span><span class="s1">.compressedSize = data.readUInt32LE(offset + consts.CENSIZ);</span>
        <span class="s0">// uncompressed size</span>
        <span class="s4">this</span><span class="s1">.size = data.readUInt32LE(offset + consts.CENLEN);</span>
        <span class="s0">// filename length</span>
        <span class="s4">this</span><span class="s1">.fnameLen = data.readUInt16LE(offset + consts.CENNAM);</span>
        <span class="s0">// extra field length</span>
        <span class="s4">this</span><span class="s1">.extraLen = data.readUInt16LE(offset + consts.CENEXT);</span>
        <span class="s0">// file comment length</span>
        <span class="s4">this</span><span class="s1">.comLen = data.readUInt16LE(offset + consts.CENCOM);</span>
        <span class="s0">// volume number start</span>
        <span class="s4">this</span><span class="s1">.diskStart = data.readUInt16LE(offset + consts.CENDSK);</span>
        <span class="s0">// internal file attributes</span>
        <span class="s4">this</span><span class="s1">.inattr = data.readUInt16LE(offset + consts.CENATT);</span>
        <span class="s0">// external file attributes</span>
        <span class="s4">this</span><span class="s1">.attr = data.readUInt32LE(offset + consts.CENATX);</span>
        <span class="s0">// LOC header offset</span>
        <span class="s4">this</span><span class="s1">.offset = data.readUInt32LE(offset + consts.CENOFF);</span>
    <span class="s1">}</span>

    <span class="s1">readDataHeader(data) {</span>
        <span class="s0">// 30 bytes and should start with &quot;PK\003\004&quot;</span>
        <span class="s4">if </span><span class="s1">(data.readUInt32LE(</span><span class="s3">0</span><span class="s1">) !== consts.LOCSIG) {</span>
            <span class="s4">throw new </span><span class="s1">Error(</span><span class="s2">'Invalid local header'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">// version needed to extract</span>
        <span class="s4">this</span><span class="s1">.version = data.readUInt16LE(consts.LOCVER);</span>
        <span class="s0">// general purpose bit flag</span>
        <span class="s4">this</span><span class="s1">.flags = data.readUInt16LE(consts.LOCFLG);</span>
        <span class="s0">// compression method</span>
        <span class="s4">this</span><span class="s1">.method = data.readUInt16LE(consts.LOCHOW);</span>
        <span class="s0">// modification time (2 bytes time ; 2 bytes date)</span>
        <span class="s1">const timebytes = data.readUInt16LE(consts.LOCTIM);</span>
        <span class="s1">const datebytes = data.readUInt16LE(consts.LOCTIM + </span><span class="s3">2</span><span class="s1">);</span>
        <span class="s4">this</span><span class="s1">.time = parseZipTime(timebytes, datebytes);</span>

        <span class="s0">// uncompressed file crc-32 value</span>
        <span class="s4">this</span><span class="s1">.crc = data.readUInt32LE(consts.LOCCRC) || </span><span class="s4">this</span><span class="s1">.crc;</span>
        <span class="s0">// compressed size</span>
        <span class="s1">const compressedSize = data.readUInt32LE(consts.LOCSIZ);</span>
        <span class="s4">if </span><span class="s1">(compressedSize &amp;&amp; compressedSize !== consts.EF_ZIP64_OR_32) {</span>
            <span class="s4">this</span><span class="s1">.compressedSize = compressedSize;</span>
        <span class="s1">}</span>
        <span class="s0">// uncompressed size</span>
        <span class="s1">const size = data.readUInt32LE(consts.LOCLEN);</span>
        <span class="s4">if </span><span class="s1">(size &amp;&amp; size !== consts.EF_ZIP64_OR_32) {</span>
            <span class="s4">this</span><span class="s1">.size = size;</span>
        <span class="s1">}</span>
        <span class="s0">// filename length</span>
        <span class="s4">this</span><span class="s1">.fnameLen = data.readUInt16LE(consts.LOCNAM);</span>
        <span class="s0">// extra field length</span>
        <span class="s4">this</span><span class="s1">.extraLen = data.readUInt16LE(consts.LOCEXT);</span>
    <span class="s1">}</span>

    <span class="s1">read(data, offset, textDecoder) {</span>
        <span class="s1">const nameData = data.slice(offset, (offset += </span><span class="s4">this</span><span class="s1">.fnameLen));</span>
        <span class="s4">this</span><span class="s1">.name = textDecoder</span>
            <span class="s1">? textDecoder.decode(</span><span class="s4">new </span><span class="s1">Uint8Array(nameData))</span>
            <span class="s1">: nameData.toString(</span><span class="s2">'utf8'</span><span class="s1">);</span>
        <span class="s1">const lastChar = data[offset - </span><span class="s3">1</span><span class="s1">];</span>
        <span class="s4">this</span><span class="s1">.isDirectory = lastChar === </span><span class="s3">47 </span><span class="s1">|| lastChar === </span><span class="s3">92</span><span class="s1">;</span>

        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.extraLen) {</span>
            <span class="s4">this</span><span class="s1">.readExtra(data, offset);</span>
            <span class="s1">offset += </span><span class="s4">this</span><span class="s1">.extraLen;</span>
        <span class="s1">}</span>
        <span class="s4">this</span><span class="s1">.comment = </span><span class="s4">this</span><span class="s1">.comLen ? data.slice(offset, offset + </span><span class="s4">this</span><span class="s1">.comLen).toString() : </span><span class="s4">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">validateName() {</span>
        <span class="s4">if </span><span class="s1">(/\\|^\w+:|^\/|(^|\/)\.\.(\/|$)/.test(</span><span class="s4">this</span><span class="s1">.name)) {</span>
            <span class="s4">throw new </span><span class="s1">Error(</span><span class="s2">'Malicious entry: ' </span><span class="s1">+ </span><span class="s4">this</span><span class="s1">.name);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">readExtra(data, offset) {</span>
        <span class="s1">let signature, size;</span>
        <span class="s1">const maxPos = offset + </span><span class="s4">this</span><span class="s1">.extraLen;</span>
        <span class="s4">while </span><span class="s1">(offset &lt; maxPos) {</span>
            <span class="s1">signature = data.readUInt16LE(offset);</span>
            <span class="s1">offset += </span><span class="s3">2</span><span class="s1">;</span>
            <span class="s1">size = data.readUInt16LE(offset);</span>
            <span class="s1">offset += </span><span class="s3">2</span><span class="s1">;</span>
            <span class="s4">if </span><span class="s1">(consts.ID_ZIP64 === signature) {</span>
                <span class="s4">this</span><span class="s1">.parseZip64Extra(data, offset, size);</span>
            <span class="s1">}</span>
            <span class="s1">offset += size;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">parseZip64Extra(data, offset, length) {</span>
        <span class="s4">if </span><span class="s1">(length &gt;= </span><span class="s3">8 </span><span class="s1">&amp;&amp; </span><span class="s4">this</span><span class="s1">.size === consts.EF_ZIP64_OR_32) {</span>
            <span class="s4">this</span><span class="s1">.size = readUInt64LE(data, offset);</span>
            <span class="s1">offset += </span><span class="s3">8</span><span class="s1">;</span>
            <span class="s1">length -= </span><span class="s3">8</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">if </span><span class="s1">(length &gt;= </span><span class="s3">8 </span><span class="s1">&amp;&amp; </span><span class="s4">this</span><span class="s1">.compressedSize === consts.EF_ZIP64_OR_32) {</span>
            <span class="s4">this</span><span class="s1">.compressedSize = readUInt64LE(data, offset);</span>
            <span class="s1">offset += </span><span class="s3">8</span><span class="s1">;</span>
            <span class="s1">length -= </span><span class="s3">8</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">if </span><span class="s1">(length &gt;= </span><span class="s3">8 </span><span class="s1">&amp;&amp; </span><span class="s4">this</span><span class="s1">.offset === consts.EF_ZIP64_OR_32) {</span>
            <span class="s4">this</span><span class="s1">.offset = readUInt64LE(data, offset);</span>
            <span class="s1">offset += </span><span class="s3">8</span><span class="s1">;</span>
            <span class="s1">length -= </span><span class="s3">8</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">if </span><span class="s1">(length &gt;= </span><span class="s3">4 </span><span class="s1">&amp;&amp; </span><span class="s4">this</span><span class="s1">.diskStart === consts.EF_ZIP64_OR_16) {</span>
            <span class="s4">this</span><span class="s1">.diskStart = data.readUInt32LE(offset);</span>
            <span class="s0">// offset += 4; length -= 4;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">get encrypted() {</span>
        <span class="s4">return </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.flags &amp; consts.FLG_ENTRY_ENC) === consts.FLG_ENTRY_ENC;</span>
    <span class="s1">}</span>

    <span class="s1">get isFile() {</span>
        <span class="s4">return </span><span class="s1">!</span><span class="s4">this</span><span class="s1">.isDirectory;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">class FsRead {</span>
    <span class="s1">constructor(fd, buffer, offset, length, position, callback) {</span>
        <span class="s4">this</span><span class="s1">.fd = fd;</span>
        <span class="s4">this</span><span class="s1">.buffer = buffer;</span>
        <span class="s4">this</span><span class="s1">.offset = offset;</span>
        <span class="s4">this</span><span class="s1">.length = length;</span>
        <span class="s4">this</span><span class="s1">.position = position;</span>
        <span class="s4">this</span><span class="s1">.callback = callback;</span>
        <span class="s4">this</span><span class="s1">.bytesRead = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s4">this</span><span class="s1">.waiting = </span><span class="s4">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">read(sync) {</span>
        <span class="s1">StreamZip.debugLog(</span><span class="s2">'read'</span><span class="s1">, </span><span class="s4">this</span><span class="s1">.position, </span><span class="s4">this</span><span class="s1">.bytesRead, </span><span class="s4">this</span><span class="s1">.length, </span><span class="s4">this</span><span class="s1">.offset);</span>
        <span class="s4">this</span><span class="s1">.waiting = </span><span class="s4">true</span><span class="s1">;</span>
        <span class="s1">let err;</span>
        <span class="s4">if </span><span class="s1">(sync) {</span>
            <span class="s1">let bytesRead = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s4">try </span><span class="s1">{</span>
                <span class="s1">bytesRead = fs.readSync(</span>
                    <span class="s4">this</span><span class="s1">.fd,</span>
                    <span class="s4">this</span><span class="s1">.buffer,</span>
                    <span class="s4">this</span><span class="s1">.offset + </span><span class="s4">this</span><span class="s1">.bytesRead,</span>
                    <span class="s4">this</span><span class="s1">.length - </span><span class="s4">this</span><span class="s1">.bytesRead,</span>
                    <span class="s4">this</span><span class="s1">.position + </span><span class="s4">this</span><span class="s1">.bytesRead</span>
                <span class="s1">);</span>
            <span class="s1">} </span><span class="s4">catch </span><span class="s1">(e) {</span>
                <span class="s1">err = e;</span>
            <span class="s1">}</span>
            <span class="s4">this</span><span class="s1">.readCallback(sync, err, err ? bytesRead : </span><span class="s4">null</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
            <span class="s1">fs.read(</span>
                <span class="s4">this</span><span class="s1">.fd,</span>
                <span class="s4">this</span><span class="s1">.buffer,</span>
                <span class="s4">this</span><span class="s1">.offset + </span><span class="s4">this</span><span class="s1">.bytesRead,</span>
                <span class="s4">this</span><span class="s1">.length - </span><span class="s4">this</span><span class="s1">.bytesRead,</span>
                <span class="s4">this</span><span class="s1">.position + </span><span class="s4">this</span><span class="s1">.bytesRead,</span>
                <span class="s4">this</span><span class="s1">.readCallback.bind(</span><span class="s4">this</span><span class="s1">, sync)</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">readCallback(sync, err, bytesRead) {</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s1">bytesRead === </span><span class="s2">'number'</span><span class="s1">) {</span>
            <span class="s4">this</span><span class="s1">.bytesRead += bytesRead;</span>
        <span class="s1">}</span>
        <span class="s4">if </span><span class="s1">(err || !bytesRead || </span><span class="s4">this</span><span class="s1">.bytesRead === </span><span class="s4">this</span><span class="s1">.length) {</span>
            <span class="s4">this</span><span class="s1">.waiting = </span><span class="s4">false</span><span class="s1">;</span>
            <span class="s4">return this</span><span class="s1">.callback(err, </span><span class="s4">this</span><span class="s1">.bytesRead);</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
            <span class="s4">this</span><span class="s1">.read(sync);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">class FileWindowBuffer {</span>
    <span class="s1">constructor(fd) {</span>
        <span class="s4">this</span><span class="s1">.position = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s4">this</span><span class="s1">.buffer = Buffer.alloc(</span><span class="s3">0</span><span class="s1">);</span>
        <span class="s4">this</span><span class="s1">.fd = fd;</span>
        <span class="s4">this</span><span class="s1">.fsOp = </span><span class="s4">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">checkOp() {</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.fsOp &amp;&amp; </span><span class="s4">this</span><span class="s1">.fsOp.waiting) {</span>
            <span class="s4">throw new </span><span class="s1">Error(</span><span class="s2">'Operation in progress'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">read(pos, length, callback) {</span>
        <span class="s4">this</span><span class="s1">.checkOp();</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.buffer.length &lt; length) {</span>
            <span class="s4">this</span><span class="s1">.buffer = Buffer.alloc(length);</span>
        <span class="s1">}</span>
        <span class="s4">this</span><span class="s1">.position = pos;</span>
        <span class="s4">this</span><span class="s1">.fsOp = </span><span class="s4">new </span><span class="s1">FsRead(</span><span class="s4">this</span><span class="s1">.fd, </span><span class="s4">this</span><span class="s1">.buffer, </span><span class="s3">0</span><span class="s1">, length, </span><span class="s4">this</span><span class="s1">.position, callback).read();</span>
    <span class="s1">}</span>

    <span class="s1">expandLeft(length, callback) {</span>
        <span class="s4">this</span><span class="s1">.checkOp();</span>
        <span class="s4">this</span><span class="s1">.buffer = Buffer.concat([Buffer.alloc(length), </span><span class="s4">this</span><span class="s1">.buffer]);</span>
        <span class="s4">this</span><span class="s1">.position -= length;</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.position &lt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s4">this</span><span class="s1">.position = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">this</span><span class="s1">.fsOp = </span><span class="s4">new </span><span class="s1">FsRead(</span><span class="s4">this</span><span class="s1">.fd, </span><span class="s4">this</span><span class="s1">.buffer, </span><span class="s3">0</span><span class="s1">, length, </span><span class="s4">this</span><span class="s1">.position, callback).read();</span>
    <span class="s1">}</span>

    <span class="s1">expandRight(length, callback) {</span>
        <span class="s4">this</span><span class="s1">.checkOp();</span>
        <span class="s1">const offset = </span><span class="s4">this</span><span class="s1">.buffer.length;</span>
        <span class="s4">this</span><span class="s1">.buffer = Buffer.concat([</span><span class="s4">this</span><span class="s1">.buffer, Buffer.alloc(length)]);</span>
        <span class="s4">this</span><span class="s1">.fsOp = </span><span class="s4">new </span><span class="s1">FsRead(</span>
            <span class="s4">this</span><span class="s1">.fd,</span>
            <span class="s4">this</span><span class="s1">.buffer,</span>
            <span class="s1">offset,</span>
            <span class="s1">length,</span>
            <span class="s4">this</span><span class="s1">.position + offset,</span>
            <span class="s1">callback</span>
        <span class="s1">).read();</span>
    <span class="s1">}</span>

    <span class="s1">moveRight(length, callback, shift) {</span>
        <span class="s4">this</span><span class="s1">.checkOp();</span>
        <span class="s4">if </span><span class="s1">(shift) {</span>
            <span class="s4">this</span><span class="s1">.buffer.copy(</span><span class="s4">this</span><span class="s1">.buffer, </span><span class="s3">0</span><span class="s1">, shift);</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
            <span class="s1">shift = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">this</span><span class="s1">.position += shift;</span>
        <span class="s4">this</span><span class="s1">.fsOp = </span><span class="s4">new </span><span class="s1">FsRead(</span>
            <span class="s4">this</span><span class="s1">.fd,</span>
            <span class="s4">this</span><span class="s1">.buffer,</span>
            <span class="s4">this</span><span class="s1">.buffer.length - shift,</span>
            <span class="s1">shift,</span>
            <span class="s4">this</span><span class="s1">.position + </span><span class="s4">this</span><span class="s1">.buffer.length - shift,</span>
            <span class="s1">callback</span>
        <span class="s1">).read();</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">class EntryDataReaderStream extends stream.Readable {</span>
    <span class="s1">constructor(fd, offset, length) {</span>
        <span class="s1">super();</span>
        <span class="s4">this</span><span class="s1">.fd = fd;</span>
        <span class="s4">this</span><span class="s1">.offset = offset;</span>
        <span class="s4">this</span><span class="s1">.length = length;</span>
        <span class="s4">this</span><span class="s1">.pos = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s4">this</span><span class="s1">.readCallback = </span><span class="s4">this</span><span class="s1">.readCallback.bind(</span><span class="s4">this</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">_read(n) {</span>
        <span class="s1">const buffer = Buffer.alloc(Math.min(n, </span><span class="s4">this</span><span class="s1">.length - </span><span class="s4">this</span><span class="s1">.pos));</span>
        <span class="s4">if </span><span class="s1">(buffer.length) {</span>
            <span class="s1">fs.read(</span><span class="s4">this</span><span class="s1">.fd, buffer, </span><span class="s3">0</span><span class="s1">, buffer.length, </span><span class="s4">this</span><span class="s1">.offset + </span><span class="s4">this</span><span class="s1">.pos, </span><span class="s4">this</span><span class="s1">.readCallback);</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
            <span class="s4">this</span><span class="s1">.push(</span><span class="s4">null</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">readCallback(err, bytesRead, buffer) {</span>
        <span class="s4">this</span><span class="s1">.pos += bytesRead;</span>
        <span class="s4">if </span><span class="s1">(err) {</span>
            <span class="s4">this</span><span class="s1">.emit(</span><span class="s2">'error'</span><span class="s1">, err);</span>
            <span class="s4">this</span><span class="s1">.push(</span><span class="s4">null</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s4">else if </span><span class="s1">(!bytesRead) {</span>
            <span class="s4">this</span><span class="s1">.push(</span><span class="s4">null</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
            <span class="s4">if </span><span class="s1">(bytesRead !== buffer.length) {</span>
                <span class="s1">buffer = buffer.slice(</span><span class="s3">0</span><span class="s1">, bytesRead);</span>
            <span class="s1">}</span>
            <span class="s4">this</span><span class="s1">.push(buffer);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">class EntryVerifyStream extends stream.Transform {</span>
    <span class="s1">constructor(baseStm, crc, size) {</span>
        <span class="s1">super();</span>
        <span class="s4">this</span><span class="s1">.verify = </span><span class="s4">new </span><span class="s1">CrcVerify(crc, size);</span>
        <span class="s1">baseStm.on(</span><span class="s2">'error'</span><span class="s1">, (e) =&gt; {</span>
            <span class="s4">this</span><span class="s1">.emit(</span><span class="s2">'error'</span><span class="s1">, e);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s1">_transform(data, encoding, callback) {</span>
        <span class="s1">let err;</span>
        <span class="s4">try </span><span class="s1">{</span>
            <span class="s4">this</span><span class="s1">.verify.data(data);</span>
        <span class="s1">} </span><span class="s4">catch </span><span class="s1">(e) {</span>
            <span class="s1">err = e;</span>
        <span class="s1">}</span>
        <span class="s1">callback(err, data);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">class CrcVerify {</span>
    <span class="s1">constructor(crc, size) {</span>
        <span class="s4">this</span><span class="s1">.crc = crc;</span>
        <span class="s4">this</span><span class="s1">.size = size;</span>
        <span class="s4">this</span><span class="s1">.state = {</span>
            <span class="s1">crc: ~</span><span class="s3">0</span><span class="s1">,</span>
            <span class="s1">size: </span><span class="s3">0</span><span class="s1">,</span>
        <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s1">data(data) {</span>
        <span class="s1">const crcTable = CrcVerify.getCrcTable();</span>
        <span class="s1">let crc = </span><span class="s4">this</span><span class="s1">.state.crc;</span>
        <span class="s1">let off = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s1">let len = data.length;</span>
        <span class="s4">while </span><span class="s1">(--len &gt;= </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s1">crc = crcTable[(crc ^ data[off++]) &amp; </span><span class="s3">0</span><span class="s1">xff] ^ (crc &gt;&gt;&gt; </span><span class="s3">8</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s4">this</span><span class="s1">.state.crc = crc;</span>
        <span class="s4">this</span><span class="s1">.state.size += data.length;</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.state.size &gt;= </span><span class="s4">this</span><span class="s1">.size) {</span>
            <span class="s1">const buf = Buffer.alloc(</span><span class="s3">4</span><span class="s1">);</span>
            <span class="s1">buf.writeInt32LE(~</span><span class="s4">this</span><span class="s1">.state.crc &amp; </span><span class="s3">0</span><span class="s1">xffffffff, </span><span class="s3">0</span><span class="s1">);</span>
            <span class="s1">crc = buf.readUInt32LE(</span><span class="s3">0</span><span class="s1">);</span>
            <span class="s4">if </span><span class="s1">(crc !== </span><span class="s4">this</span><span class="s1">.crc) {</span>
                <span class="s4">throw new </span><span class="s1">Error(</span><span class="s2">'Invalid CRC'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.state.size !== </span><span class="s4">this</span><span class="s1">.size) {</span>
                <span class="s4">throw new </span><span class="s1">Error(</span><span class="s2">'Invalid size'</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">static getCrcTable() {</span>
        <span class="s1">let crcTable = CrcVerify.crcTable;</span>
        <span class="s4">if </span><span class="s1">(!crcTable) {</span>
            <span class="s1">CrcVerify.crcTable = crcTable = [];</span>
            <span class="s1">const b = Buffer.alloc(</span><span class="s3">4</span><span class="s1">);</span>
            <span class="s4">for </span><span class="s1">(let n = </span><span class="s3">0</span><span class="s1">; n &lt; </span><span class="s3">256</span><span class="s1">; n++) {</span>
                <span class="s1">let c = n;</span>
                <span class="s4">for </span><span class="s1">(let k = </span><span class="s3">8</span><span class="s1">; --k &gt;= </span><span class="s3">0</span><span class="s1">; ) {</span>
                    <span class="s4">if </span><span class="s1">((c &amp; </span><span class="s3">1</span><span class="s1">) !== </span><span class="s3">0</span><span class="s1">) {</span>
                        <span class="s1">c = </span><span class="s3">0</span><span class="s1">xedb88320 ^ (c &gt;&gt;&gt; </span><span class="s3">1</span><span class="s1">);</span>
                    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
                        <span class="s1">c = c &gt;&gt;&gt; </span><span class="s3">1</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s4">if </span><span class="s1">(c &lt; </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s1">b.writeInt32LE(c, </span><span class="s3">0</span><span class="s1">);</span>
                    <span class="s1">c = b.readUInt32LE(</span><span class="s3">0</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s1">crcTable[n] = c;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">return </span><span class="s1">crcTable;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">function </span><span class="s1">parseZipTime(timebytes, datebytes) {</span>
    <span class="s1">const timebits = toBits(timebytes, </span><span class="s3">16</span><span class="s1">);</span>
    <span class="s1">const datebits = toBits(datebytes, </span><span class="s3">16</span><span class="s1">);</span>

    <span class="s1">const mt = {</span>
        <span class="s1">h: parseInt(timebits.slice(</span><span class="s3">0</span><span class="s1">, </span><span class="s3">5</span><span class="s1">).join(</span><span class="s2">''</span><span class="s1">), </span><span class="s3">2</span><span class="s1">),</span>
        <span class="s1">m: parseInt(timebits.slice(</span><span class="s3">5</span><span class="s1">, </span><span class="s3">11</span><span class="s1">).join(</span><span class="s2">''</span><span class="s1">), </span><span class="s3">2</span><span class="s1">),</span>
        <span class="s1">s: parseInt(timebits.slice(</span><span class="s3">11</span><span class="s1">, </span><span class="s3">16</span><span class="s1">).join(</span><span class="s2">''</span><span class="s1">), </span><span class="s3">2</span><span class="s1">) * </span><span class="s3">2</span><span class="s1">,</span>
        <span class="s1">Y: parseInt(datebits.slice(</span><span class="s3">0</span><span class="s1">, </span><span class="s3">7</span><span class="s1">).join(</span><span class="s2">''</span><span class="s1">), </span><span class="s3">2</span><span class="s1">) + </span><span class="s3">1980</span><span class="s1">,</span>
        <span class="s1">M: parseInt(datebits.slice(</span><span class="s3">7</span><span class="s1">, </span><span class="s3">11</span><span class="s1">).join(</span><span class="s2">''</span><span class="s1">), </span><span class="s3">2</span><span class="s1">),</span>
        <span class="s1">D: parseInt(datebits.slice(</span><span class="s3">11</span><span class="s1">, </span><span class="s3">16</span><span class="s1">).join(</span><span class="s2">''</span><span class="s1">), </span><span class="s3">2</span><span class="s1">),</span>
    <span class="s1">};</span>
    <span class="s1">const dt_str = [mt.Y, mt.M, mt.D].join(</span><span class="s2">'-'</span><span class="s1">) + </span><span class="s2">' ' </span><span class="s1">+ [mt.h, mt.m, mt.s].join(</span><span class="s2">':'</span><span class="s1">) + </span><span class="s2">' GMT+0'</span><span class="s1">;</span>
    <span class="s4">return new </span><span class="s1">Date(dt_str).getTime();</span>
<span class="s1">}</span>

<span class="s4">function </span><span class="s1">toBits(dec, size) {</span>
    <span class="s1">let b = (dec &gt;&gt;&gt; </span><span class="s3">0</span><span class="s1">).toString(</span><span class="s3">2</span><span class="s1">);</span>
    <span class="s4">while </span><span class="s1">(b.length &lt; size) {</span>
        <span class="s1">b = </span><span class="s2">'0' </span><span class="s1">+ b;</span>
    <span class="s1">}</span>
    <span class="s4">return </span><span class="s1">b.split(</span><span class="s2">''</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s4">function </span><span class="s1">readUInt64LE(buffer, offset) {</span>
    <span class="s4">return </span><span class="s1">buffer.readUInt32LE(offset + </span><span class="s3">4</span><span class="s1">) * </span><span class="s3">0</span><span class="s1">x0000000100000000 + buffer.readUInt32LE(offset);</span>
<span class="s1">}</span>

<span class="s1">module.exports = StreamZip;</span>
</pre>
</body>
</html>
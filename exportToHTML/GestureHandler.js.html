<html>
<head>
<title>GestureHandler.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
GestureHandler.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">_hammerjs = _interopRequireDefault(require(</span><span class="s0">&quot;@egjs/hammerjs&quot;</span><span class="s1">));</span>

<span class="s2">var </span><span class="s1">_reactNative = require(</span><span class="s0">&quot;react-native&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_State = require(</span><span class="s0">&quot;../State&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_constants = require(</span><span class="s0">&quot;./constants&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">NodeManager = _interopRequireWildcard(require(</span><span class="s0">&quot;./NodeManager&quot;</span><span class="s1">));</span>

<span class="s2">function </span><span class="s1">_getRequireWildcardCache() { </span><span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">; </span><span class="s2">var </span><span class="s1">cache = </span><span class="s2">new </span><span class="s1">WeakMap(); _getRequireWildcardCache = </span><span class="s2">function </span><span class="s1">() { </span><span class="s2">return </span><span class="s1">cache; }; </span><span class="s2">return </span><span class="s1">cache; }</span>

<span class="s2">function </span><span class="s1">_interopRequireWildcard(obj) { </span><span class="s2">if </span><span class="s1">(obj &amp;&amp; obj.__esModule) { </span><span class="s2">return </span><span class="s1">obj; } </span><span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">{ </span><span class="s2">default</span><span class="s1">: obj }; } </span><span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(); </span><span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) { </span><span class="s2">return </span><span class="s1">cache.get(obj); } </span><span class="s2">var </span><span class="s1">newObj = {}; </span><span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor; </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj) { </span><span class="s2">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(obj, key)) { </span><span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">; </span><span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } </span><span class="s2">else </span><span class="s1">{ newObj[key] = obj[key]; } } } newObj.</span><span class="s2">default </span><span class="s1">= obj; </span><span class="s2">if </span><span class="s1">(cache) { cache.set(obj, newObj); } </span><span class="s2">return </span><span class="s1">newObj; }</span>

<span class="s2">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">default</span><span class="s1">: obj }; }</span>

<span class="s2">function </span><span class="s1">_defineProperty(obj, key, value) { </span><span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">obj) { Object.defineProperty(obj, key, { value: value, enumerable: </span><span class="s2">true</span><span class="s1">, configurable: </span><span class="s2">true</span><span class="s1">, writable: </span><span class="s2">true </span><span class="s1">}); } </span><span class="s2">else </span><span class="s1">{ obj[key] = value; } </span><span class="s2">return </span><span class="s1">obj; }</span>

<span class="s1">let gestureInstances = </span><span class="s3">0</span><span class="s1">;</span>

<span class="s1">class GestureHandler {</span>
  <span class="s1">get id() {</span>
    <span class="s2">return </span><span class="s1">`${</span><span class="s2">this</span><span class="s1">.name}${</span><span class="s2">this</span><span class="s1">.gestureInstance}`;</span>
  <span class="s1">} </span><span class="s4">// a simple way to check if GestureHandler is NativeViewGestureHandler, since importing it</span>
  <span class="s4">// here to use instanceof would cause import cycle</span>


  <span class="s1">get isNative() {</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">get isDiscrete() {</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">get shouldEnableGestureOnSetup() {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'Must override GestureHandler.shouldEnableGestureOnSetup'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">constructor() {</span>
    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;handlerTag&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s3">0</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;isGestureRunning&quot;</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;view&quot;</span><span class="s1">, </span><span class="s2">null</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;hasCustomActivationCriteria&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s3">0</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;hasGestureFailed&quot;</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;hammer&quot;</span><span class="s1">, </span><span class="s2">null</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;initialRotation&quot;</span><span class="s1">, </span><span class="s2">null</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;__initialX&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s3">0</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;__initialY&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s3">0</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;config&quot;</span><span class="s1">, {});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;previousState&quot;</span><span class="s1">, _State.State.UNDETERMINED);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;pendingGestures&quot;</span><span class="s1">, {});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;oldState&quot;</span><span class="s1">, _State.State.UNDETERMINED);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;lastSentState&quot;</span><span class="s1">, </span><span class="s2">null</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;gestureInstance&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s3">0</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;_stillWaiting&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s3">0</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;propsRef&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s3">0</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;ref&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s3">0</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;clearSelfAsPending&quot;</span><span class="s1">, () =&gt; {</span>
      <span class="s2">if </span><span class="s1">(Array.isArray(</span><span class="s2">this</span><span class="s1">.config.waitFor)) {</span>
        <span class="s2">for </span><span class="s1">(const gesture of </span><span class="s2">this</span><span class="s1">.config.waitFor) {</span>
          <span class="s1">gesture.removePendingGesture(</span><span class="s2">this</span><span class="s1">.id);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;destroy&quot;</span><span class="s1">, () =&gt; {</span>
      <span class="s2">this</span><span class="s1">.clearSelfAsPending();</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hammer) {</span>
        <span class="s2">this</span><span class="s1">.hammer.stop(</span><span class="s2">false</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.hammer.destroy();</span>
      <span class="s1">}</span>

      <span class="s2">this</span><span class="s1">.hammer = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;isPointInView&quot;</span><span class="s1">, ({</span>
      <span class="s1">x,</span>
      <span class="s1">y</span>
    <span class="s1">}) =&gt; {</span>
      <span class="s4">// @ts-ignore FIXME(TS)</span>
      <span class="s1">const rect = </span><span class="s2">this</span><span class="s1">.view.getBoundingClientRect();</span>
      <span class="s1">const pointerInside = x &gt;= rect.left &amp;&amp; x &lt;= rect.right &amp;&amp; y &gt;= rect.top &amp;&amp; y &lt;= rect.bottom;</span>
      <span class="s2">return </span><span class="s1">pointerInside;</span>
    <span class="s1">});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;sendEvent&quot;</span><span class="s1">, nativeEvent =&gt; {</span>
      <span class="s1">const {</span>
        <span class="s1">onGestureHandlerEvent,</span>
        <span class="s1">onGestureHandlerStateChange</span>
      <span class="s1">} = </span><span class="s2">this</span><span class="s1">.propsRef.current;</span>
      <span class="s1">const event = </span><span class="s2">this</span><span class="s1">.transformEventData(nativeEvent);</span>
      <span class="s1">invokeNullableMethod(onGestureHandlerEvent, event);</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.lastSentState !== event.nativeEvent.state) {</span>
        <span class="s2">this</span><span class="s1">.lastSentState = event.nativeEvent.state;</span>
        <span class="s1">invokeNullableMethod(onGestureHandlerStateChange, event);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;sync&quot;</span><span class="s1">, () =&gt; {</span>
      <span class="s1">const gesture = </span><span class="s2">this</span><span class="s1">.hammer.get(</span><span class="s2">this</span><span class="s1">.name);</span>
      <span class="s2">if </span><span class="s1">(!gesture) </span><span class="s2">return</span><span class="s1">;</span>

      <span class="s1">const enable = (recognizer, inputData) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.config.enabled) {</span>
          <span class="s2">this</span><span class="s1">.isGestureRunning = </span><span class="s2">false</span><span class="s1">;</span>
          <span class="s2">this</span><span class="s1">.hasGestureFailed = </span><span class="s2">false</span><span class="s1">;</span>
          <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s4">// Prevent events before the system is ready.</span>


        <span class="s2">if </span><span class="s1">(!inputData || !recognizer.options || </span><span class="s2">typeof </span><span class="s1">inputData.maxPointers === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
          <span class="s2">return this</span><span class="s1">.shouldEnableGestureOnSetup;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasGestureFailed) {</span>
          <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isDiscrete) {</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isGestureRunning) {</span>
            <span class="s2">return true</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s4">// The built-in hammer.js &quot;waitFor&quot; doesn't work across multiple views.</span>
          <span class="s4">// Only process if there are views to wait for.</span>


          <span class="s2">this</span><span class="s1">._stillWaiting = </span><span class="s2">this</span><span class="s1">._getPendingGestures(); </span><span class="s4">// This gesture should continue waiting.</span>

          <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._stillWaiting.length) {</span>
            <span class="s4">// Check to see if one of the gestures you're waiting for has started.</span>
            <span class="s4">// If it has then the gesture should fail.</span>
            <span class="s2">for </span><span class="s1">(const gesture of </span><span class="s2">this</span><span class="s1">._stillWaiting) {</span>
              <span class="s4">// When the target gesture has started, this gesture must force fail.</span>
              <span class="s2">if </span><span class="s1">(!gesture.isDiscrete &amp;&amp; gesture.isGestureRunning) {</span>
                <span class="s2">this</span><span class="s1">.hasGestureFailed = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">this</span><span class="s1">.isGestureRunning = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">return false</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s4">// This gesture shouldn't start until the others have finished.</span>


            <span class="s2">return false</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s4">// Use default behaviour</span>


        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.hasCustomActivationCriteria) {</span>
          <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">const deltaRotation = </span><span class="s2">this</span><span class="s1">.initialRotation == </span><span class="s2">null </span><span class="s1">? </span><span class="s3">0 </span><span class="s1">: inputData.rotation - </span><span class="s2">this</span><span class="s1">.initialRotation; </span><span class="s4">// @ts-ignore FIXME(TS)</span>

        <span class="s1">const {</span>
          <span class="s1">success,</span>
          <span class="s1">failed</span>
        <span class="s1">} = </span><span class="s2">this</span><span class="s1">.isGestureEnabledForEvent(</span><span class="s2">this</span><span class="s1">.getConfig(), recognizer, { ...inputData,</span>
          <span class="s1">deltaRotation</span>
        <span class="s1">});</span>

        <span class="s2">if </span><span class="s1">(failed) {</span>
          <span class="s2">this</span><span class="s1">.simulateCancelEvent(inputData);</span>
          <span class="s2">this</span><span class="s1">.hasGestureFailed = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">success;</span>
      <span class="s1">};</span>

      <span class="s1">const params = </span><span class="s2">this</span><span class="s1">.getHammerConfig(); </span><span class="s4">// @ts-ignore FIXME(TS)</span>

      <span class="s1">gesture.set({ ...params,</span>
        <span class="s1">enable</span>
      <span class="s1">});</span>
    <span class="s1">});</span>

    <span class="s2">this</span><span class="s1">.gestureInstance = gestureInstances++;</span>
    <span class="s2">this</span><span class="s1">.hasCustomActivationCriteria = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">getConfig() {</span>
    <span class="s2">return this</span><span class="s1">.config;</span>
  <span class="s1">}</span>

  <span class="s1">onWaitingEnded(_gesture) {}</span>

  <span class="s1">removePendingGesture(id) {</span>
    <span class="s2">delete this</span><span class="s1">.pendingGestures[id];</span>
  <span class="s1">}</span>

  <span class="s1">addPendingGesture(gesture) {</span>
    <span class="s2">this</span><span class="s1">.pendingGestures[gesture.id] = gesture;</span>
  <span class="s1">}</span>

  <span class="s1">isGestureEnabledForEvent(_config, _recognizer, _event) {</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">success: </span><span class="s2">true</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s1">get NativeGestureClass() {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'Must override GestureHandler.NativeGestureClass'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">updateHasCustomActivationCriteria(_config) {</span>
    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">updateGestureConfig({</span>
    <span class="s1">enabled = </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">...props</span>
  <span class="s1">}) {</span>
    <span class="s2">this</span><span class="s1">.clearSelfAsPending();</span>
    <span class="s2">this</span><span class="s1">.config = </span><span class="s2">this</span><span class="s1">.ensureConfig({</span>
      <span class="s1">enabled,</span>
      <span class="s1">...props</span>
    <span class="s1">});</span>
    <span class="s2">this</span><span class="s1">.hasCustomActivationCriteria = </span><span class="s2">this</span><span class="s1">.updateHasCustomActivationCriteria(</span><span class="s2">this</span><span class="s1">.config);</span>

    <span class="s2">if </span><span class="s1">(Array.isArray(</span><span class="s2">this</span><span class="s1">.config.waitFor)) {</span>
      <span class="s2">for </span><span class="s1">(const gesture of </span><span class="s2">this</span><span class="s1">.config.waitFor) {</span>
        <span class="s1">gesture.addPendingGesture(</span><span class="s2">this</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hammer) {</span>
      <span class="s2">this</span><span class="s1">.sync();</span>
    <span class="s1">}</span>

    <span class="s2">return this</span><span class="s1">.config;</span>
  <span class="s1">}</span>

  <span class="s1">getState(type) {</span>
    <span class="s4">// @ts-ignore TODO(TS) check if this is needed</span>
    <span class="s2">if </span><span class="s1">(type == </span><span class="s3">0</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">_constants.EventMap[type];</span>
  <span class="s1">}</span>

  <span class="s1">transformEventData(event) {</span>
    <span class="s1">const {</span>
      <span class="s1">eventType,</span>
      <span class="s1">maxPointers: numberOfPointers</span>
    <span class="s1">} = event; </span><span class="s4">// const direction = DirectionMap[ev.direction];</span>

    <span class="s1">const changedTouch = event.changedPointers[</span><span class="s3">0</span><span class="s1">];</span>
    <span class="s1">const pointerInside = </span><span class="s2">this</span><span class="s1">.isPointInView({</span>
      <span class="s1">x: changedTouch.clientX,</span>
      <span class="s1">y: changedTouch.clientY</span>
    <span class="s1">}); </span><span class="s4">// TODO(TS) Remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50966 is merged.</span>

    <span class="s1">const state = </span><span class="s2">this</span><span class="s1">.getState(eventType);</span>

    <span class="s2">if </span><span class="s1">(state !== </span><span class="s2">this</span><span class="s1">.previousState) {</span>
      <span class="s2">this</span><span class="s1">.oldState = </span><span class="s2">this</span><span class="s1">.previousState;</span>
      <span class="s2">this</span><span class="s1">.previousState = state;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">nativeEvent: {</span>
        <span class="s1">numberOfPointers,</span>
        <span class="s1">state,</span>
        <span class="s1">pointerInside,</span>
        <span class="s1">...</span><span class="s2">this</span><span class="s1">.transformNativeEvent(event),</span>
        <span class="s4">// onHandlerStateChange only</span>
        <span class="s1">handlerTag: </span><span class="s2">this</span><span class="s1">.handlerTag,</span>
        <span class="s1">target: </span><span class="s2">this</span><span class="s1">.ref,</span>
        <span class="s4">// send oldState only when the state was changed, or is different than ACTIVE</span>
        <span class="s4">// GestureDetector relies on the presence of `oldState` to differentiate between</span>
        <span class="s4">// update events and state change events</span>
        <span class="s1">oldState: state !== </span><span class="s2">this</span><span class="s1">.previousState || state != </span><span class="s3">4 </span><span class="s1">? </span><span class="s2">this</span><span class="s1">.oldState : undefined</span>
      <span class="s1">},</span>
      <span class="s1">timeStamp: Date.now()</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s1">transformNativeEvent(_event) {</span>
    <span class="s2">return </span><span class="s1">{};</span>
  <span class="s1">}</span>

  <span class="s1">cancelPendingGestures(event) {</span>
    <span class="s2">for </span><span class="s1">(const gesture of Object.values(</span><span class="s2">this</span><span class="s1">.pendingGestures)) {</span>
      <span class="s2">if </span><span class="s1">(gesture &amp;&amp; gesture.isGestureRunning) {</span>
        <span class="s1">gesture.hasGestureFailed = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">gesture.cancelEvent(event);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">notifyPendingGestures() {</span>
    <span class="s2">for </span><span class="s1">(const gesture of Object.values(</span><span class="s2">this</span><span class="s1">.pendingGestures)) {</span>
      <span class="s2">if </span><span class="s1">(gesture) {</span>
        <span class="s1">gesture.onWaitingEnded(</span><span class="s2">this</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s4">// FIXME event is undefined in runtime when firstly invoked (see Draggable example), check other functions taking event as input</span>


  <span class="s1">onGestureEnded(event) {</span>
    <span class="s2">this</span><span class="s1">.isGestureRunning = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.cancelPendingGestures(event);</span>
  <span class="s1">}</span>

  <span class="s1">forceInvalidate(event) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isGestureRunning) {</span>
      <span class="s2">this</span><span class="s1">.hasGestureFailed = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.cancelEvent(event);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">cancelEvent(event) {</span>
    <span class="s2">this</span><span class="s1">.notifyPendingGestures();</span>
    <span class="s2">this</span><span class="s1">.sendEvent({ ...event,</span>
      <span class="s1">eventType: _hammerjs.</span><span class="s2">default</span><span class="s1">.INPUT_CANCEL,</span>
      <span class="s1">isFinal: </span><span class="s2">true</span>
    <span class="s1">});</span>
    <span class="s2">this</span><span class="s1">.onGestureEnded(event);</span>
  <span class="s1">}</span>

  <span class="s1">onRawEvent({</span>
    <span class="s1">isFirst</span>
  <span class="s1">}) {</span>
    <span class="s2">if </span><span class="s1">(isFirst) {</span>
      <span class="s2">this</span><span class="s1">.hasGestureFailed = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">shouldUseTouchEvents(config) {</span>
    <span class="s2">var </span><span class="s1">_config$simultaneousH, _config$simultaneousH2;</span>

    <span class="s2">return </span><span class="s1">(_config$simultaneousH = (_config$simultaneousH2 = config.simultaneousHandlers) === </span><span class="s2">null </span><span class="s1">|| _config$simultaneousH2 === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _config$simultaneousH2.some(handler =&gt; handler.isNative)) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _config$simultaneousH !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _config$simultaneousH : </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">setView(ref, propsRef) {</span>
    <span class="s2">if </span><span class="s1">(ref == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.destroy();</span>
      <span class="s2">this</span><span class="s1">.view = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s4">// @ts-ignore window doesn't exist on global type as we don't want to use Node types</span>


    <span class="s1">const SUPPORTS_TOUCH = (</span><span class="s0">'ontouchstart' </span><span class="s2">in </span><span class="s1">window);</span>
    <span class="s2">this</span><span class="s1">.propsRef = propsRef;</span>
    <span class="s2">this</span><span class="s1">.ref = ref;</span>
    <span class="s2">this</span><span class="s1">.view = (</span><span class="s3">0</span><span class="s1">, _reactNative.findNodeHandle)(ref); </span><span class="s4">// When the browser starts handling the gesture (e.g. scrolling), it sends a pointercancel event and stops</span>
    <span class="s4">// sending additional pointer events. This is not the case with touch events, so if the gesture is simultaneous</span>
    <span class="s4">// with a NativeGestureHandler, we need to check if touch events are supported and use them if possible.</span>

    <span class="s2">this</span><span class="s1">.hammer = SUPPORTS_TOUCH &amp;&amp; </span><span class="s2">this</span><span class="s1">.shouldUseTouchEvents(</span><span class="s2">this</span><span class="s1">.config) ? </span><span class="s2">new </span><span class="s1">_hammerjs.</span><span class="s2">default</span><span class="s1">.Manager(</span><span class="s2">this</span><span class="s1">.view, {</span>
      <span class="s1">inputClass: _hammerjs.</span><span class="s2">default</span><span class="s1">.TouchInput</span>
    <span class="s1">}) : </span><span class="s2">new </span><span class="s1">_hammerjs.</span><span class="s2">default</span><span class="s1">.Manager(</span><span class="s2">this</span><span class="s1">.view);</span>
    <span class="s2">this</span><span class="s1">.oldState = _State.State.UNDETERMINED;</span>
    <span class="s2">this</span><span class="s1">.previousState = _State.State.UNDETERMINED;</span>
    <span class="s2">this</span><span class="s1">.lastSentState = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">const {</span>
      <span class="s1">NativeGestureClass</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">; </span><span class="s4">// @ts-ignore TODO(TS)</span>

    <span class="s1">const gesture = </span><span class="s2">new </span><span class="s1">NativeGestureClass(</span><span class="s2">this</span><span class="s1">.getHammerConfig());</span>
    <span class="s2">this</span><span class="s1">.hammer.add(gesture);</span>
    <span class="s2">this</span><span class="s1">.hammer.on(</span><span class="s0">'hammer.input'</span><span class="s1">, ev =&gt; {</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.config.enabled) {</span>
        <span class="s2">this</span><span class="s1">.hasGestureFailed = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.isGestureRunning = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">this</span><span class="s1">.onRawEvent(ev); </span><span class="s4">// TODO: Bacon: Check against something other than null</span>
      <span class="s4">// The isFirst value is not called when the first rotation is calculated.</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.initialRotation === </span><span class="s2">null </span><span class="s1">&amp;&amp; ev.rotation !== </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.initialRotation = ev.rotation;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(ev.isFinal) {</span>
        <span class="s4">// in favor of a willFail otherwise the last frame of the gesture will be captured.</span>
        <span class="s1">setTimeout(() =&gt; {</span>
          <span class="s2">this</span><span class="s1">.initialRotation = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s2">this</span><span class="s1">.hasGestureFailed = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">this</span><span class="s1">.setupEvents();</span>
    <span class="s2">this</span><span class="s1">.sync();</span>
  <span class="s1">}</span>

  <span class="s1">setupEvents() {</span>
    <span class="s4">// TODO(TS) Hammer types aren't exactly that what we get in runtime</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isDiscrete) {</span>
      <span class="s2">this</span><span class="s1">.hammer.on(`${</span><span class="s2">this</span><span class="s1">.name}start`, event =&gt; </span><span class="s2">this</span><span class="s1">.onStart(event));</span>
      <span class="s2">this</span><span class="s1">.hammer.on(`${</span><span class="s2">this</span><span class="s1">.name}end ${</span><span class="s2">this</span><span class="s1">.name}cancel`, event =&gt; {</span>
        <span class="s2">this</span><span class="s1">.onGestureEnded(event);</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s2">this</span><span class="s1">.hammer.on(</span><span class="s2">this</span><span class="s1">.name, ev =&gt; </span><span class="s2">this</span><span class="s1">.onGestureActivated(ev)); </span><span class="s4">// TODO(TS) remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438 is merged</span>
  <span class="s1">}</span>

  <span class="s1">onStart({</span>
    <span class="s1">deltaX,</span>
    <span class="s1">deltaY,</span>
    <span class="s1">rotation</span>
  <span class="s1">}) {</span>
    <span class="s4">// Reset the state for the next gesture</span>
    <span class="s2">this</span><span class="s1">.oldState = _State.State.UNDETERMINED;</span>
    <span class="s2">this</span><span class="s1">.previousState = _State.State.UNDETERMINED;</span>
    <span class="s2">this</span><span class="s1">.lastSentState = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.isGestureRunning = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.__initialX = deltaX;</span>
    <span class="s2">this</span><span class="s1">.__initialY = deltaY;</span>
    <span class="s2">this</span><span class="s1">.initialRotation = rotation;</span>
  <span class="s1">}</span>

  <span class="s1">onGestureActivated(ev) {</span>
    <span class="s2">this</span><span class="s1">.sendEvent(ev);</span>
  <span class="s1">}</span>

  <span class="s1">onSuccess() {}</span>

  <span class="s1">_getPendingGestures() {</span>
    <span class="s2">if </span><span class="s1">(Array.isArray(</span><span class="s2">this</span><span class="s1">.config.waitFor) &amp;&amp; </span><span class="s2">this</span><span class="s1">.config.waitFor.length) {</span>
      <span class="s4">// Get the list of gestures that this gesture is still waiting for.</span>
      <span class="s4">// Use `=== false` in case a ref that isn't a gesture handler is used.</span>
      <span class="s1">const stillWaiting = </span><span class="s2">this</span><span class="s1">.config.waitFor.filter(({</span>
        <span class="s1">hasGestureFailed</span>
      <span class="s1">}) =&gt; hasGestureFailed === </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s2">return </span><span class="s1">stillWaiting;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">[];</span>
  <span class="s1">}</span>

  <span class="s1">getHammerConfig() {</span>
    <span class="s1">const pointers = </span><span class="s2">this</span><span class="s1">.config.minPointers === </span><span class="s2">this</span><span class="s1">.config.maxPointers ? </span><span class="s2">this</span><span class="s1">.config.minPointers : </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">pointers</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s1">simulateCancelEvent(_inputData) {} </span><span class="s4">// Validate the props</span>


  <span class="s1">ensureConfig(config) {</span>
    <span class="s1">const props = { ...config</span>
    <span class="s1">}; </span><span class="s4">// TODO(TS) We use ! to assert that if property is present then value is not empty (null, undefined)</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s0">'minDist' </span><span class="s2">in </span><span class="s1">config) {</span>
      <span class="s1">props.minDist = config.minDist;</span>
      <span class="s1">props.minDistSq = props.minDist * props.minDist;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s0">'minVelocity' </span><span class="s2">in </span><span class="s1">config) {</span>
      <span class="s1">props.minVelocity = config.minVelocity;</span>
      <span class="s1">props.minVelocitySq = props.minVelocity * props.minVelocity;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s0">'maxDist' </span><span class="s2">in </span><span class="s1">config) {</span>
      <span class="s1">props.maxDist = config.maxDist;</span>
      <span class="s1">props.maxDistSq = config.maxDist * config.maxDist;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s0">'waitFor' </span><span class="s2">in </span><span class="s1">config) {</span>
      <span class="s1">props.waitFor = asArray(config.waitFor).map(({</span>
        <span class="s1">handlerTag</span>
      <span class="s1">}) =&gt; NodeManager.getHandler(handlerTag)).filter(v =&gt; v);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">props.waitFor = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s0">'simultaneousHandlers' </span><span class="s2">in </span><span class="s1">config) {</span>
      <span class="s1">const shouldUseTouchEvents = </span><span class="s2">this</span><span class="s1">.shouldUseTouchEvents(</span><span class="s2">this</span><span class="s1">.config);</span>
      <span class="s1">props.simultaneousHandlers = asArray(config.simultaneousHandlers).map(handler =&gt; {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">handler === </span><span class="s0">'number'</span><span class="s1">) {</span>
          <span class="s2">return </span><span class="s1">NodeManager.getHandler(handler);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">NodeManager.getHandler(handler.handlerTag);</span>
        <span class="s1">}</span>
      <span class="s1">}).filter(v =&gt; v);</span>

      <span class="s2">if </span><span class="s1">(shouldUseTouchEvents !== </span><span class="s2">this</span><span class="s1">.shouldUseTouchEvents(props)) {</span>
        <span class="s1">queueMicrotask(() =&gt; {</span>
          <span class="s4">// if the undelying event API needs to be changed, we need to unmount and mount</span>
          <span class="s4">// the hammer instance again.</span>
          <span class="s2">this</span><span class="s1">.destroy();</span>
          <span class="s2">this</span><span class="s1">.setView(</span><span class="s2">this</span><span class="s1">.ref, </span><span class="s2">this</span><span class="s1">.propsRef);</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">props.simultaneousHandlers = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">const configProps = [</span><span class="s0">'minPointers'</span><span class="s1">, </span><span class="s0">'maxPointers'</span><span class="s1">, </span><span class="s0">'minDist'</span><span class="s1">, </span><span class="s0">'maxDist'</span><span class="s1">, </span><span class="s0">'maxDistSq'</span><span class="s1">, </span><span class="s0">'minVelocitySq'</span><span class="s1">, </span><span class="s0">'minDistSq'</span><span class="s1">, </span><span class="s0">'minVelocity'</span><span class="s1">, </span><span class="s0">'failOffsetXStart'</span><span class="s1">, </span><span class="s0">'failOffsetYStart'</span><span class="s1">, </span><span class="s0">'failOffsetXEnd'</span><span class="s1">, </span><span class="s0">'failOffsetYEnd'</span><span class="s1">, </span><span class="s0">'activeOffsetXStart'</span><span class="s1">, </span><span class="s0">'activeOffsetXEnd'</span><span class="s1">, </span><span class="s0">'activeOffsetYStart'</span><span class="s1">, </span><span class="s0">'activeOffsetYEnd'</span><span class="s1">];</span>
    <span class="s1">configProps.forEach(prop =&gt; {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">props[prop] === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
        <span class="s1">props[prop] = Number.NaN;</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">props; </span><span class="s4">// TODO(TS) how to convince TS that props are filled?</span>
  <span class="s1">}</span>

<span class="s1">} </span><span class="s4">// TODO(TS) investigate this method</span>
<span class="s4">// Used for sending data to a callback or AnimatedEvent</span>


<span class="s2">function </span><span class="s1">invokeNullableMethod(method, event) {</span>
  <span class="s2">if </span><span class="s1">(method) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">method === </span><span class="s0">'function'</span><span class="s1">) {</span>
      <span class="s1">method(event);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s4">// For use with reanimated's AnimatedEvent</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s0">'__getHandler' </span><span class="s2">in </span><span class="s1">method &amp;&amp; </span><span class="s2">typeof </span><span class="s1">method.__getHandler === </span><span class="s0">'function'</span><span class="s1">) {</span>
        <span class="s1">const handler = method.__getHandler();</span>

        <span class="s1">invokeNullableMethod(handler, event);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">'__nodeConfig' </span><span class="s2">in </span><span class="s1">method) {</span>
          <span class="s1">const {</span>
            <span class="s1">argMapping</span>
          <span class="s1">} = method.__nodeConfig;</span>

          <span class="s2">if </span><span class="s1">(Array.isArray(argMapping)) {</span>
            <span class="s2">for </span><span class="s1">(const [index, [key, value]] of argMapping.entries()) {</span>
              <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">event.nativeEvent) {</span>
                <span class="s4">// @ts-ignore fix method type</span>
                <span class="s1">const nativeValue = event.nativeEvent[key];</span>

                <span class="s2">if </span><span class="s1">(value &amp;&amp; value.setValue) {</span>
                  <span class="s4">// Reanimated API</span>
                  <span class="s1">value.setValue(nativeValue);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                  <span class="s4">// RN Animated API</span>
                  <span class="s1">method.__nodeConfig.argMapping[index] = [key, nativeValue];</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">asArray(value) {</span>
  <span class="s4">// TODO(TS) use config.waitFor type</span>
  <span class="s2">return </span><span class="s1">value == </span><span class="s2">null </span><span class="s1">? [] : Array.isArray(value) ? value : [value];</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">_default = GestureHandler;</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= _default;</span>
<span class="s4">//# sourceMappingURL=GestureHandler.js.map</span></pre>
</body>
</html>
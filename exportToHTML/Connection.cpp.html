<html>
<head>
<title>Connection.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Connection.cpp</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#include </span><span class="s3">&quot;Connection.h&quot;</span>

<span class="s2">#include </span><span class="s3">&lt;cstdlib&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;mutex&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;sstream&gt;</span>

<span class="s2">#include </span><span class="s3">&lt;folly/Conv.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;folly/Executor.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;folly/Function.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;folly/json.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;glog/logging.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;hermes/inspector/Inspector.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;hermes/inspector/chrome/MessageConverters.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;hermes/inspector/chrome/RemoteObjectsTable.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;hermes/inspector/detail/CallbackOStream.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;hermes/inspector/detail/SerialExecutor.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;hermes/inspector/detail/Thread.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;jsi/instrumentation.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;optional&gt;</span>

<span class="s4">namespace </span><span class="s1">facebook {</span>
<span class="s4">namespace </span><span class="s1">hermes {</span>
<span class="s4">namespace </span><span class="s1">inspector {</span>
<span class="s4">namespace </span><span class="s1">chrome {</span>

<span class="s4">using </span><span class="s1">::facebook::react::ILocalConnection</span><span class="s4">;</span>
<span class="s4">using </span><span class="s1">::facebook::react::IRemoteConnection</span><span class="s4">;</span>
<span class="s4">using </span><span class="s1">::folly::Unit</span><span class="s4">;</span>

<span class="s4">namespace </span><span class="s1">debugger = ::facebook::hermes::debugger</span><span class="s4">;</span>
<span class="s4">namespace </span><span class="s1">inspector = ::facebook::hermes::inspector</span><span class="s4">;</span>
<span class="s4">namespace </span><span class="s1">m = ::facebook::hermes::inspector::chrome::message</span><span class="s4">;</span>

<span class="s4">static const char </span><span class="s1">*</span><span class="s4">const </span><span class="s1">kVirtualBreakpointPrefix = </span><span class="s3">&quot;virtualbreakpoint-&quot;</span><span class="s4">;</span>
<span class="s4">static const char </span><span class="s1">*</span><span class="s4">const </span><span class="s1">kBeforeScriptWithSourceMapExecution =</span>
    <span class="s3">&quot;beforeScriptWithSourceMapExecution&quot;</span><span class="s4">;</span>
<span class="s4">static const char </span><span class="s1">*</span><span class="s4">const </span><span class="s1">kUserEnteredScriptPrefix = </span><span class="s3">&quot;userScript&quot;</span><span class="s4">;</span>

<span class="s0">/* 
 * Connection::Impl 
 */</span>

<span class="s4">class </span><span class="s1">Connection::Impl : </span><span class="s4">public </span><span class="s1">inspector::InspectorObserver</span><span class="s4">,</span>
                         <span class="s4">public </span><span class="s1">message::RequestHandler {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s1">Impl(</span>
      <span class="s1">std::unique_ptr&lt;RuntimeAdapter&gt; adapter</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">std::string &amp;title</span><span class="s4">,</span>
      <span class="s4">bool </span><span class="s1">waitForDebugger)</span><span class="s4">;</span>
  <span class="s1">~Impl()</span><span class="s4">;</span>

  <span class="s1">HermesRuntime &amp;getRuntime()</span><span class="s4">;</span>
  <span class="s1">std::string getTitle() </span><span class="s4">const;</span>

  <span class="s4">bool </span><span class="s1">connect(std::unique_ptr&lt;IRemoteConnection&gt; remoteConn)</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">disconnect()</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">sendMessage(std::string str)</span><span class="s4">;</span>

  <span class="s0">/* InspectorObserver overrides */</span>
  <span class="s4">void </span><span class="s1">onBreakpointResolved(</span>
      <span class="s1">Inspector &amp;inspector</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">debugger::BreakpointInfo &amp;info) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">onContextCreated(Inspector &amp;inspector) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">onPause(Inspector &amp;inspector</span><span class="s4">, const </span><span class="s1">debugger::ProgramState &amp;state)</span>
      <span class="s1">override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">onResume(Inspector &amp;inspector) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">onScriptParsed(Inspector &amp;inspector</span><span class="s4">, const </span><span class="s1">ScriptInfo &amp;info) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">onMessageAdded(Inspector &amp;inspector</span><span class="s4">, const </span><span class="s1">ConsoleMessageInfo &amp;info)</span>
      <span class="s1">override</span><span class="s4">;</span>

  <span class="s0">/* RequestHandler overrides */</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::UnknownRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::debugger::DisableRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::debugger::EnableRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::debugger::EvaluateOnCallFrameRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::debugger::PauseRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::debugger::RemoveBreakpointRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::debugger::ResumeRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::debugger::SetBreakpointRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::debugger::SetBreakpointByUrlRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::debugger::SetBreakpointsActiveRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span>
      <span class="s4">const </span><span class="s1">m::debugger::SetInstrumentationBreakpointRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::debugger::SetPauseOnExceptionsRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::debugger::StepIntoRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::debugger::StepOutRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::debugger::StepOverRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::heapProfiler::TakeHeapSnapshotRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span>
      <span class="s4">const </span><span class="s1">m::heapProfiler::StartTrackingHeapObjectsRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span>
      <span class="s4">const </span><span class="s1">m::heapProfiler::StopTrackingHeapObjectsRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::heapProfiler::StartSamplingRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::heapProfiler::StopSamplingRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::heapProfiler::CollectGarbageRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span>
      <span class="s4">const </span><span class="s1">m::heapProfiler::GetObjectByHeapObjectIdRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::heapProfiler::GetHeapObjectIdRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::profiler::StartRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::profiler::StopRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::runtime::CallFunctionOnRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::runtime::CompileScriptRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::runtime::EvaluateRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::runtime::GetHeapUsageRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::runtime::GetPropertiesRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::runtime::GlobalLexicalScopeNamesRequest &amp;req) override</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">handle(</span><span class="s4">const </span><span class="s1">m::runtime::RunIfWaitingForDebuggerRequest &amp;req) override</span><span class="s4">;</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s0">// The execution context id reported back by the ExecutionContextCreated</span>
  <span class="s0">// notification. We only ever expect this execution context id.</span>
  <span class="s4">static constexpr </span><span class="s1">int32_t kHermesExecutionContextId = </span><span class="s5">1</span><span class="s4">;</span>
  <span class="s1">std::vector&lt;m::runtime::PropertyDescriptor&gt; makePropsFromScope(</span>
      <span class="s1">std::pair&lt;uint32_t</span><span class="s4">, </span><span class="s1">uint32_t&gt; frameAndScopeIndex</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">std::string &amp;objectGroup</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">debugger::ProgramState &amp;state)</span><span class="s4">;</span>
  <span class="s1">std::vector&lt;m::runtime::PropertyDescriptor&gt; makePropsFromValue(</span>
      <span class="s4">const </span><span class="s1">jsi::Value &amp;value</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">std::string &amp;objectGroup</span><span class="s4">,</span>
      <span class="s4">bool </span><span class="s1">onlyOwnProperties)</span><span class="s4">;</span>

  <span class="s4">void </span><span class="s1">sendSnapshot(</span>
      <span class="s4">int </span><span class="s1">reqId</span><span class="s4">,</span>
      <span class="s1">std::string message</span><span class="s4">,</span>
      <span class="s4">bool </span><span class="s1">reportProgress</span><span class="s4">,</span>
      <span class="s4">bool </span><span class="s1">stopStackTraceCapture)</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">sendToClient(</span><span class="s4">const </span><span class="s1">std::string &amp;str)</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">sendResponseToClient(</span><span class="s4">const </span><span class="s1">m::Response &amp;resp)</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">sendNotificationToClient(</span><span class="s4">const </span><span class="s1">m::Notification &amp;resp)</span><span class="s4">;</span>
  <span class="s1">folly::Function&lt;</span><span class="s4">void</span><span class="s1">(</span><span class="s4">const </span><span class="s1">std::exception &amp;)&gt; sendErrorToClient(</span><span class="s4">int </span><span class="s1">id)</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">sendResponseToClientViaExecutor(</span><span class="s4">int </span><span class="s1">id)</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">sendResponseToClientViaExecutor(folly::Future&lt;Unit&gt; future</span><span class="s4">, int </span><span class="s1">id)</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">sendResponseToClientViaExecutor(</span><span class="s4">const </span><span class="s1">m::Response &amp;resp)</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">sendNotificationToClientViaExecutor(</span><span class="s4">const </span><span class="s1">m::Notification &amp;note)</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">sendErrorToClientViaExecutor(</span><span class="s4">int </span><span class="s1">id</span><span class="s4">, const </span><span class="s1">std::string &amp;error)</span><span class="s4">;</span>

  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">C&gt;</span>
  <span class="s4">void </span><span class="s1">runInExecutor(</span><span class="s4">int </span><span class="s1">id</span><span class="s4">, </span><span class="s1">C callback) {</span>
    <span class="s1">executor_-&gt;add([cb = std::move(callback)]() { cb()</span><span class="s4">; </span><span class="s1">})</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">std::shared_ptr&lt;RuntimeAdapter&gt; runtimeAdapter_</span><span class="s4">;</span>
  <span class="s1">std::string title_</span><span class="s4">;</span>

  <span class="s0">// connected_ is protected by connectionMutex_.</span>
  <span class="s1">std::mutex connectionMutex_</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">connected_</span><span class="s4">;</span>

  <span class="s0">// parsedScripts_ list stores file names of all scripts that have been</span>
  <span class="s0">// parsed so that we could find script's file name by regex.</span>
  <span class="s0">// This is similar to Inspector's loadedScripts_ map but we want to</span>
  <span class="s0">// store this info here because searching file name that matches</span>
  <span class="s0">// given regex (on setBreakpointByUrl command) is more related to Chrome</span>
  <span class="s0">// protocol than to Hermes inspector.</span>
  <span class="s0">// Access is protected by parsedScriptsMutex_.</span>
  <span class="s1">std::mutex parsedScriptsMutex_</span><span class="s4">;</span>
  <span class="s1">std::vector&lt;std::string&gt; parsedScripts_</span><span class="s4">;</span>

  <span class="s0">// preparedScripts_ stores user-entered scripts that have been prepared for</span>
  <span class="s0">// execution, and may be invoked by a later command.</span>
  <span class="s1">std::vector&lt;std::shared_ptr&lt;</span><span class="s4">const </span><span class="s1">jsi::PreparedJavaScript&gt;&gt; preparedScripts_</span><span class="s4">;</span>

  <span class="s0">// Some events are represented as a mode in Hermes but a breakpoint in CDP,</span>
  <span class="s0">// e.g. &quot;beforeScriptExecution&quot; and &quot;beforeScriptWithSourceMapExecution&quot;.</span>
  <span class="s0">// Keep track of these separately. The caller should lock the</span>
  <span class="s0">// virtualBreakpointMutex_.</span>
  <span class="s1">std::mutex virtualBreakpointMutex_</span><span class="s4">;</span>
  <span class="s1">uint32_t nextVirtualBreakpoint_ = </span><span class="s5">1</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">std::string &amp;createVirtualBreakpoint(</span><span class="s4">const </span><span class="s1">std::string &amp;category)</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">isVirtualBreakpointId(</span><span class="s4">const </span><span class="s1">std::string &amp;id)</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">hasVirtualBreakpoint(</span><span class="s4">const </span><span class="s1">std::string &amp;category)</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">removeVirtualBreakpoint(</span><span class="s4">const </span><span class="s1">std::string &amp;id)</span><span class="s4">;</span>
  <span class="s1">std::unordered_map&lt;std::string</span><span class="s4">, </span><span class="s1">std::unordered_set&lt;std::string&gt;&gt;</span>
      <span class="s1">virtualBreakpoints_</span><span class="s4">;</span>

  <span class="s0">// The rest of these member variables are only accessed via executor_.</span>
  <span class="s1">std::unique_ptr&lt;folly::Executor&gt; executor_</span><span class="s4">;</span>
  <span class="s1">std::unique_ptr&lt;IRemoteConnection&gt; remoteConn_</span><span class="s4">;</span>
  <span class="s1">std::shared_ptr&lt;inspector::Inspector&gt; inspector_</span><span class="s4">;</span>

  <span class="s0">// objTable_ is protected by the inspector lock. It should only be accessed</span>
  <span class="s0">// when the VM is paused, e.g. in an InspectorObserver callback or in an</span>
  <span class="s0">// executeIfEnabled callback.</span>
  <span class="s1">RemoteObjectsTable objTable_</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s1">Connection::Impl::Impl(</span>
    <span class="s1">std::unique_ptr&lt;RuntimeAdapter&gt; adapter</span><span class="s4">,</span>
    <span class="s4">const </span><span class="s1">std::string &amp;title</span><span class="s4">,</span>
    <span class="s4">bool </span><span class="s1">waitForDebugger)</span>
    <span class="s1">: runtimeAdapter_(std::move(adapter))</span><span class="s4">,</span>
      <span class="s1">title_(title)</span><span class="s4">,</span>
      <span class="s1">connected_(</span><span class="s4">false</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s1">executor_(std::make_unique&lt;inspector::detail::SerialExecutor&gt;(</span>
          <span class="s3">&quot;hermes-chrome-inspector-conn&quot;</span><span class="s1">))</span><span class="s4">,</span>
      <span class="s1">remoteConn_(</span><span class="s4">nullptr</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s1">inspector_(std::make_shared&lt;inspector::Inspector&gt;(</span>
          <span class="s1">runtimeAdapter_</span><span class="s4">,</span>
          <span class="s1">*</span><span class="s4">this,</span>
          <span class="s1">waitForDebugger)) {</span>
  <span class="s1">inspector_-&gt;installLogHandler()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">Connection::Impl::~Impl() = </span><span class="s4">default;</span>

<span class="s1">HermesRuntime &amp;Connection::Impl::getRuntime() {</span>
  <span class="s4">return </span><span class="s1">runtimeAdapter_-&gt;getRuntime()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">std::string Connection::Impl::getTitle() </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">return </span><span class="s1">title_</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">bool </span><span class="s1">Connection::Impl::connect(std::unique_ptr&lt;IRemoteConnection&gt; remoteConn) {</span>
  <span class="s1">assert(remoteConn)</span><span class="s4">;</span>
  <span class="s1">std::lock_guard&lt;std::mutex&gt; lock(connectionMutex_)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(connected_) {</span>
    <span class="s4">return false;</span>
  <span class="s1">}</span>

  <span class="s1">connected_ = </span><span class="s4">true;</span>
  <span class="s1">executor_-&gt;add([</span><span class="s4">this, </span><span class="s1">remoteConn = std::move(remoteConn)]() </span><span class="s4">mutable </span><span class="s1">{</span>
    <span class="s1">remoteConn_ = std::move(remoteConn)</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s4">return true;</span>
<span class="s1">}</span>

<span class="s4">bool </span><span class="s1">Connection::Impl::disconnect() {</span>
  <span class="s1">std::lock_guard&lt;std::mutex&gt; lock(connectionMutex_)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(!connected_) {</span>
    <span class="s4">return false;</span>
  <span class="s1">}</span>

  <span class="s1">connected_ = </span><span class="s4">false;</span>

  <span class="s1">inspector_-&gt;disable().via(executor_.get()).thenValue([</span><span class="s4">this</span><span class="s1">](</span><span class="s4">auto </span><span class="s1">&amp;&amp;) {</span>
    <span class="s0">// HACK:  We purposely call RemoteConnection::onDisconnect on a *different*</span>
    <span class="s0">// thread, rather than on this thread (the executor thread). This is to</span>
    <span class="s0">// prevent this scenario:</span>
    <span class="s0">//</span>
    <span class="s0">// 1. RemoteConnection::onDisconnect runs on the executor thread</span>
    <span class="s0">// 2. onDisconnect through a long chain of calls causes the Connection</span>
    <span class="s0">//    destructor to run</span>
    <span class="s0">// 3. The Connection destructor causes the SerialExecutor destructor to run.</span>
    <span class="s0">// 4. The SerialExecutor destructor waits for all outstanding work items to</span>
    <span class="s0">//    finish via a call to join().</span>
    <span class="s0">// 5. join() fails, since the executor thread is trying to join against</span>
    <span class="s0">//    itself.</span>
    <span class="s0">//</span>
    <span class="s0">// To prevent this chain of events, we always call onDisconnect on a</span>
    <span class="s0">// different thread.</span>
    <span class="s0">//</span>
    <span class="s0">// See P59135203 for an example stack trace.</span>
    <span class="s0">//</span>
    <span class="s0">// One more hack: we use release() and delete instead of unique_ptr because</span>
    <span class="s0">// detail::Thread expects a std::function, and std::function cannot capture</span>
    <span class="s0">// move-only types like unique_ptr.</span>
    <span class="s4">auto </span><span class="s1">conn = remoteConn_.release()</span><span class="s4">;</span>
    <span class="s1">inspector::detail::Thread disconnectLaterThread{</span>
        <span class="s3">&quot;hermes-chrome-inspector-conn-disconnect&quot;</span><span class="s4">, </span><span class="s1">[conn] {</span>
          <span class="s1">conn-&gt;onDisconnect()</span><span class="s4">;</span>
          <span class="s4">delete </span><span class="s1">conn</span><span class="s4">;</span>
        <span class="s1">}}</span><span class="s4">;</span>
    <span class="s1">disconnectLaterThread.detach()</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s4">return true;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::sendMessage(std::string str) {</span>
  <span class="s1">executor_-&gt;add([</span><span class="s4">this, </span><span class="s1">str = std::move(str)]() </span><span class="s4">mutable </span><span class="s1">{</span>
    <span class="s1">folly::Try&lt;std::unique_ptr&lt;m::Request&gt;&gt; maybeReq =</span>
        <span class="s1">m::Request::fromJson(str)</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(maybeReq.hasException()) {</span>
      <span class="s1">LOG(ERROR) &lt;&lt; </span><span class="s3">&quot;Invalid request `&quot; </span><span class="s1">&lt;&lt; str</span>
                 <span class="s1">&lt;&lt; </span><span class="s3">&quot;`: &quot; </span><span class="s1">&lt;&lt; maybeReq.exception().what()</span><span class="s4">;</span>
      <span class="s4">return;</span>
    <span class="s1">}</span>

    <span class="s4">auto </span><span class="s1">&amp;req = maybeReq.value()</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(req) {</span>
      <span class="s1">req-&gt;accept(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/* 
 * InspectorObserver overrides 
 */</span>

<span class="s4">void </span><span class="s1">Connection::Impl::onBreakpointResolved(</span>
    <span class="s1">Inspector &amp;inspector</span><span class="s4">,</span>
    <span class="s4">const </span><span class="s1">debugger::BreakpointInfo &amp;info) {</span>
  <span class="s1">m::debugger::BreakpointResolvedNotification note</span><span class="s4">;</span>
  <span class="s1">note.breakpointId = folly::to&lt;std::string&gt;(info.id)</span><span class="s4">;</span>
  <span class="s1">note.location = m::debugger::makeLocation(info.resolvedLocation)</span><span class="s4">;</span>
  <span class="s1">sendNotificationToClientViaExecutor(note)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::onContextCreated(Inspector &amp;inspector) {</span>
  <span class="s0">// Right now, Hermes only has the notion of one JS context per VM instance,</span>
  <span class="s0">// so we just always name the single JS context with id=1 and name=hermes.</span>
  <span class="s1">m::runtime::ExecutionContextCreatedNotification note</span><span class="s4">;</span>
  <span class="s1">note.context.id = kHermesExecutionContextId</span><span class="s4">;</span>
  <span class="s1">note.context.name = </span><span class="s3">&quot;hermes&quot;</span><span class="s4">;</span>

  <span class="s1">sendNotificationToClientViaExecutor(note)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::onPause(</span>
    <span class="s1">Inspector &amp;inspector</span><span class="s4">,</span>
    <span class="s4">const </span><span class="s1">debugger::ProgramState &amp;state) {</span>
  <span class="s4">bool </span><span class="s1">sendNotification = </span><span class="s4">true;</span>
  <span class="s1">m::debugger::PausedNotification note</span><span class="s4">;</span>
  <span class="s1">note.callFrames = m::debugger::makeCallFrames(state</span><span class="s4">, </span><span class="s1">objTable_</span><span class="s4">, </span><span class="s1">getRuntime())</span><span class="s4">;</span>

  <span class="s4">switch </span><span class="s1">(state.getPauseReason()) {</span>
    <span class="s4">case </span><span class="s1">debugger::PauseReason::Breakpoint:</span>
      <span class="s0">// use other, chrome protocol has no reason specifically for breakpoints</span>
      <span class="s1">note.reason = </span><span class="s3">&quot;other&quot;</span><span class="s4">;</span>

<span class="s0">// TODO: hermes hasn't implemented ProgramState::getBreakpoint yet</span>
<span class="s2">#if </span><span class="s1">HERMES_SUPPORTS_STATE_GET_BREAKPOINT</span>
      <span class="s1">note.hitBreakpoints = std::vector&lt;m::debugger::BreakpointId&gt;()</span><span class="s4">;</span>
      <span class="s1">note.hitBreakpoints-&gt;emplace_back(</span>
          <span class="s1">folly::to&lt;std::string&gt;(state.getBreakpoint()))</span><span class="s4">;</span>
<span class="s2">#endif</span>

      <span class="s4">break;</span>
    <span class="s4">case </span><span class="s1">debugger::PauseReason::Exception:</span>
      <span class="s1">note.reason = </span><span class="s3">&quot;exception&quot;</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s4">case </span><span class="s1">debugger::PauseReason::ScriptLoaded: {</span>
      <span class="s0">// This case covers both wait-for-debugger and instrumentation</span>
      <span class="s0">// breakpoints, since both are implemented as pauses on script load.</span>

      <span class="s1">note.reason = </span><span class="s3">&quot;other&quot;</span><span class="s4">;</span>
      <span class="s1">note.hitBreakpoints = std::vector&lt;m::debugger::BreakpointId&gt;()</span><span class="s4">;</span>

      <span class="s1">std::lock_guard&lt;std::mutex&gt; lock(virtualBreakpointMutex_)</span><span class="s4">;</span>
      <span class="s4">for </span><span class="s1">(</span><span class="s4">auto </span><span class="s1">&amp;bp :</span>
           <span class="s1">virtualBreakpoints_[kBeforeScriptWithSourceMapExecution]) {</span>
        <span class="s1">note.hitBreakpoints-&gt;emplace_back(bp)</span><span class="s4">;</span>
      <span class="s1">}</span>

      <span class="s0">// Debuggers don't tend to ever remove these kinds of breakpoints, but</span>
      <span class="s0">// in the extremely unlikely event that it did *and* did it exactly</span>
      <span class="s0">// between us 1. checking that we should stop, and 2. adding the stop</span>
      <span class="s0">// reason here, then just resume and skip sending a pause notification.</span>
      <span class="s4">if </span><span class="s1">(!inspector_-&gt;isAwaitingDebuggerOnStart() &amp;&amp;</span>
          <span class="s1">note.hitBreakpoints-&gt;empty()) {</span>
        <span class="s1">sendNotification = </span><span class="s4">false;</span>
        <span class="s1">inspector_-&gt;resume()</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s4">;</span>
      <span class="s0">// This will be toggled back on in the next onScriptParsed if applicable</span>
      <span class="s0">// Locking is handled by didPause in the inspector</span>
      <span class="s1">inspector_-&gt;setPauseOnLoads(PauseOnLoadMode::None)</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s4">default</span><span class="s1">:</span>
      <span class="s1">note.reason = </span><span class="s3">&quot;other&quot;</span><span class="s4">;</span>
      <span class="s4">break;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(sendNotification) {</span>
    <span class="s1">sendNotificationToClientViaExecutor(note)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::onResume(Inspector &amp;inspector) {</span>
  <span class="s1">objTable_.releaseObjectGroup(BacktraceObjectGroup)</span><span class="s4">;</span>

  <span class="s1">m::debugger::ResumedNotification note</span><span class="s4">;</span>
  <span class="s1">sendNotificationToClientViaExecutor(note)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::onScriptParsed(</span>
    <span class="s1">Inspector &amp;inspector</span><span class="s4">,</span>
    <span class="s4">const </span><span class="s1">ScriptInfo &amp;info) {</span>
  <span class="s1">m::debugger::ScriptParsedNotification note</span><span class="s4">;</span>
  <span class="s1">note.scriptId = folly::to&lt;std::string&gt;(info.fileId)</span><span class="s4">;</span>
  <span class="s1">note.url = info.fileName</span><span class="s4">;</span>
  <span class="s1">note.executionContextId = kHermesExecutionContextId</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(!info.sourceMappingUrl.empty()) {</span>
    <span class="s1">note.sourceMapURL = info.sourceMappingUrl</span><span class="s4">;</span>

    <span class="s1">std::lock_guard&lt;std::mutex&gt; lock(virtualBreakpointMutex_)</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(hasVirtualBreakpoint(kBeforeScriptWithSourceMapExecution)) {</span>
      <span class="s0">// We are precariously relying on the fact that onScriptParsed</span>
      <span class="s0">// is invoked immediately before the pause load mode is checked.</span>
      <span class="s0">// That means that we can check for breakpoints and toggle the</span>
      <span class="s0">// mode here, and then immediately turn it off in onPause.</span>
      <span class="s1">inspector_-&gt;setPauseOnLoads(PauseOnLoadMode::All)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s1">std::lock_guard&lt;std::mutex&gt; lock(parsedScriptsMutex_)</span><span class="s4">;</span>
    <span class="s1">parsedScripts_.push_back(info.fileName)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">sendNotificationToClientViaExecutor(note)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::onMessageAdded(</span>
    <span class="s1">facebook::hermes::inspector::Inspector &amp;inspector</span><span class="s4">,</span>
    <span class="s4">const </span><span class="s1">ConsoleMessageInfo &amp;info) {</span>
  <span class="s1">m::runtime::ConsoleAPICalledNotification apiCalledNote</span><span class="s4">;</span>
  <span class="s1">apiCalledNote.type = info.level</span><span class="s4">;</span>
  <span class="s0">// TODO(jpporto): fix test cases sending invalid context id.</span>
  <span class="s0">// apiCalledNote.executionContextId = kHermesExecutionContextId;</span>

  <span class="s1">size_t argsSize = info.args.size(getRuntime())</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(size_t index = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">index &lt; argsSize</span><span class="s4">; </span><span class="s1">++index) {</span>
    <span class="s1">apiCalledNote.args.push_back(m::runtime::makeRemoteObject(</span>
        <span class="s1">getRuntime()</span><span class="s4">,</span>
        <span class="s1">info.args.getValueAtIndex(getRuntime()</span><span class="s4">, </span><span class="s1">index)</span><span class="s4">,</span>
        <span class="s1">objTable_</span><span class="s4">,</span>
        <span class="s3">&quot;ConsoleObjectGroup&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">sendNotificationToClientViaExecutor(apiCalledNote)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/* 
 * RequestHandler overrides 
 */</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::UnknownRequest &amp;req) {</span>
  <span class="s1">LOG(INFO) &lt;&lt; </span><span class="s3">&quot;responding ok to unknown request: &quot; </span><span class="s1">&lt;&lt; req.toDynamic()</span><span class="s4">;</span>
  <span class="s1">sendResponseToClientViaExecutor(req.id)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::debugger::DisableRequest &amp;req) {</span>
  <span class="s1">sendResponseToClientViaExecutor(inspector_-&gt;disable()</span><span class="s4">, </span><span class="s1">req.id)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::debugger::EnableRequest &amp;req) {</span>
  <span class="s1">sendResponseToClientViaExecutor(inspector_-&gt;enable()</span><span class="s4">, </span><span class="s1">req.id)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span>
    <span class="s4">const </span><span class="s1">m::debugger::EvaluateOnCallFrameRequest &amp;req) {</span>
  <span class="s4">auto </span><span class="s1">remoteObjPtr = std::make_shared&lt;m::runtime::RemoteObject&gt;()</span><span class="s4">;</span>

  <span class="s1">inspector_</span>
      <span class="s1">-&gt;evaluate(</span>
          <span class="s1">atoi(req.callFrameId.c_str())</span><span class="s4">,</span>
          <span class="s1">req.expression</span><span class="s4">,</span>
          <span class="s1">[</span><span class="s4">this,</span>
           <span class="s1">remoteObjPtr</span><span class="s4">,</span>
           <span class="s1">objectGroup = req.objectGroup</span><span class="s4">,</span>
           <span class="s1">byValue = req.returnByValue.value_or(</span><span class="s4">false</span><span class="s1">)](</span>
              <span class="s4">const </span><span class="s1">facebook::hermes::debugger::EvalResult</span>
                  <span class="s1">&amp;evalResult) </span><span class="s4">mutable </span><span class="s1">{</span>
            <span class="s1">*remoteObjPtr = m::runtime::makeRemoteObject(</span>
                <span class="s1">getRuntime()</span><span class="s4">,</span>
                <span class="s1">evalResult.value</span><span class="s4">,</span>
                <span class="s1">objTable_</span><span class="s4">,</span>
                <span class="s1">objectGroup.value_or(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s4">,</span>
                <span class="s1">byValue)</span><span class="s4">;</span>
          <span class="s1">})</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue(</span>
          <span class="s1">[</span><span class="s4">this, </span><span class="s1">id = req.id</span><span class="s4">, </span><span class="s1">remoteObjPtr](debugger::EvalResult result) {</span>
            <span class="s1">m::debugger::EvaluateOnCallFrameResponse resp</span><span class="s4">;</span>
            <span class="s1">resp.id = id</span><span class="s4">;</span>

            <span class="s4">if </span><span class="s1">(result.isException) {</span>
              <span class="s1">resp.exceptionDetails =</span>
                  <span class="s1">m::runtime::makeExceptionDetails(result.exceptionDetails)</span><span class="s4">;</span>
            <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
              <span class="s1">resp.result = *remoteObjPtr</span><span class="s4">;</span>
            <span class="s1">}</span>

            <span class="s1">sendResponseToClient(resp)</span><span class="s4">;</span>
          <span class="s1">})</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(req.id))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::sendSnapshot(</span>
    <span class="s4">int </span><span class="s1">reqId</span><span class="s4">,</span>
    <span class="s1">std::string message</span><span class="s4">,</span>
    <span class="s4">bool </span><span class="s1">reportProgress</span><span class="s4">,</span>
    <span class="s4">bool </span><span class="s1">stopStackTraceCapture) {</span>
  <span class="s1">inspector_</span>
      <span class="s1">-&gt;executeIfEnabled(</span>
          <span class="s1">message</span><span class="s4">,</span>
          <span class="s1">[</span><span class="s4">this, </span><span class="s1">reportProgress</span><span class="s4">, </span><span class="s1">stopStackTraceCapture](</span>
              <span class="s4">const </span><span class="s1">debugger::ProgramState &amp;) {</span>
            <span class="s0">// Stop taking any new traces before sending out the heap snapshot.</span>
            <span class="s4">if </span><span class="s1">(stopStackTraceCapture) {</span>
              <span class="s1">getRuntime()</span>
                  <span class="s1">.instrumentation()</span>
                  <span class="s1">.stopTrackingHeapObjectStackTraces()</span><span class="s4">;</span>
            <span class="s1">}</span>

            <span class="s4">if </span><span class="s1">(reportProgress) {</span>
              <span class="s0">// A progress notification with finished = true indicates the</span>
              <span class="s0">// snapshot has been captured and is ready to be sent.  Our</span>
              <span class="s0">// implementation streams the snapshot as it is being captured, so</span>
              <span class="s0">// we must send this notification first.</span>
              <span class="s1">m::heapProfiler::ReportHeapSnapshotProgressNotification note</span><span class="s4">;</span>
              <span class="s1">note.done = </span><span class="s5">1</span><span class="s4">;</span>
              <span class="s1">note.total = </span><span class="s5">1</span><span class="s4">;</span>
              <span class="s1">note.finished = </span><span class="s4">true;</span>
              <span class="s1">sendNotificationToClient(note)</span><span class="s4">;</span>
            <span class="s1">}</span>

            <span class="s0">// Size picked to conform to Chrome's own implementation, at the</span>
            <span class="s0">// time of writing.</span>
            <span class="s1">inspector::detail::CallbackOStream cos(</span>
                <span class="s0">/* sz */ </span><span class="s5">100 </span><span class="s1">&lt;&lt; </span><span class="s5">10</span><span class="s4">, </span><span class="s1">[</span><span class="s4">this</span><span class="s1">](std::string s) {</span>
                  <span class="s1">m::heapProfiler::AddHeapSnapshotChunkNotification note</span><span class="s4">;</span>
                  <span class="s1">note.chunk = std::move(s)</span><span class="s4">;</span>
                  <span class="s1">sendNotificationToClient(note)</span><span class="s4">;</span>
                  <span class="s4">return true;</span>
                <span class="s1">})</span><span class="s4">;</span>

            <span class="s1">getRuntime().instrumentation().createSnapshotToStream(cos)</span><span class="s4">;</span>
          <span class="s1">})</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue([</span><span class="s4">this, </span><span class="s1">reqId](</span><span class="s4">auto </span><span class="s1">&amp;&amp;) {</span>
        <span class="s1">sendResponseToClient(m::makeOkResponse(reqId))</span><span class="s4">;</span>
      <span class="s1">})</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(reqId))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span>
    <span class="s4">const </span><span class="s1">m::heapProfiler::TakeHeapSnapshotRequest &amp;req) {</span>
  <span class="s1">sendSnapshot(</span>
      <span class="s1">req.id</span><span class="s4">,</span>
      <span class="s3">&quot;HeapSnapshot.takeHeapSnapshot&quot;</span><span class="s4">,</span>
      <span class="s1">req.reportProgress &amp;&amp; *req.reportProgress</span><span class="s4">,</span>
      <span class="s0">/* stopStackTraceCapture */ </span><span class="s4">false</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span>
    <span class="s4">const </span><span class="s1">m::heapProfiler::StartTrackingHeapObjectsRequest &amp;req) {</span>
  <span class="s4">const auto </span><span class="s1">id = req.id</span><span class="s4">;</span>

  <span class="s1">inspector_</span>
      <span class="s1">-&gt;executeIfEnabled(</span>
          <span class="s3">&quot;HeapProfiler.startTrackingHeapObjects&quot;</span><span class="s4">,</span>
          <span class="s1">[</span><span class="s4">this</span><span class="s1">](</span><span class="s4">const </span><span class="s1">debugger::ProgramState &amp;) {</span>
            <span class="s1">getRuntime().instrumentation().startTrackingHeapObjectStackTraces(</span>
                <span class="s1">[</span><span class="s4">this</span><span class="s1">](</span>
                    <span class="s1">uint64_t lastSeenObjectId</span><span class="s4">,</span>
                    <span class="s1">std::chrono::microseconds timestamp</span><span class="s4">,</span>
                    <span class="s1">std::vector&lt;jsi::Instrumentation::HeapStatsUpdate&gt; stats) {</span>
                  <span class="s0">// Send the last object ID notification first.</span>
                  <span class="s1">m::heapProfiler::LastSeenObjectIdNotification note</span><span class="s4">;</span>
                  <span class="s1">note.lastSeenObjectId = lastSeenObjectId</span><span class="s4">;</span>
                  <span class="s0">// The protocol uses milliseconds with a fraction for</span>
                  <span class="s0">// microseconds.</span>
                  <span class="s1">note.timestamp =</span>
                      <span class="s4">static_cast</span><span class="s1">&lt;</span><span class="s4">double</span><span class="s1">&gt;(timestamp.count()) / </span><span class="s5">1000</span><span class="s4">;</span>
                  <span class="s1">sendNotificationToClient(note)</span><span class="s4">;</span>

                  <span class="s1">m::heapProfiler::HeapStatsUpdateNotification heapStatsNote</span><span class="s4">;</span>
                  <span class="s0">// Flatten the HeapStatsUpdate list.</span>
                  <span class="s1">heapStatsNote.statsUpdate.reserve(stats.size() * </span><span class="s5">3</span><span class="s1">)</span><span class="s4">;</span>
                  <span class="s4">for </span><span class="s1">(</span><span class="s4">const </span><span class="s1">jsi::Instrumentation::HeapStatsUpdate &amp;fragment :</span>
                       <span class="s1">stats) {</span>
                    <span class="s0">// Each triplet is the fragment number, the total count of</span>
                    <span class="s0">// objects for the fragment, and the total size of objects</span>
                    <span class="s0">// for the fragment.</span>
                    <span class="s1">heapStatsNote.statsUpdate.push_back(</span>
                        <span class="s4">static_cast</span><span class="s1">&lt;</span><span class="s4">int</span><span class="s1">&gt;(std::get&lt;</span><span class="s5">0</span><span class="s1">&gt;(fragment)))</span><span class="s4">;</span>
                    <span class="s1">heapStatsNote.statsUpdate.push_back(</span>
                        <span class="s4">static_cast</span><span class="s1">&lt;</span><span class="s4">int</span><span class="s1">&gt;(std::get&lt;</span><span class="s5">1</span><span class="s1">&gt;(fragment)))</span><span class="s4">;</span>
                    <span class="s1">heapStatsNote.statsUpdate.push_back(</span>
                        <span class="s4">static_cast</span><span class="s1">&lt;</span><span class="s4">int</span><span class="s1">&gt;(std::get&lt;</span><span class="s5">2</span><span class="s1">&gt;(fragment)))</span><span class="s4">;</span>
                  <span class="s1">}</span>
                  <span class="s1">assert(</span>
                      <span class="s1">heapStatsNote.statsUpdate.size() == stats.size() * </span><span class="s5">3 </span><span class="s1">&amp;&amp;</span>
                      <span class="s3">&quot;Should be exactly 3x the stats vector&quot;</span><span class="s1">)</span><span class="s4">;</span>
                  <span class="s0">// TODO: Chunk this if there are too many fragments to update.</span>
                  <span class="s0">// Unlikely to be a problem in practice unless there's a huge</span>
                  <span class="s0">// amount of allocation and freeing.</span>
                  <span class="s1">sendNotificationToClient(heapStatsNote)</span><span class="s4">;</span>
                <span class="s1">})</span><span class="s4">;</span>
            <span class="s0">// At this point we need the equivalent of a setInterval, where each</span>
            <span class="s0">// interval samples the existing</span>
          <span class="s1">})</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue(</span>
          <span class="s1">[</span><span class="s4">this, </span><span class="s1">id](</span><span class="s4">auto </span><span class="s1">&amp;&amp;) { sendResponseToClient(m::makeOkResponse(id))</span><span class="s4">; </span><span class="s1">})</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(req.id))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span>
    <span class="s4">const </span><span class="s1">m::heapProfiler::StopTrackingHeapObjectsRequest &amp;req) {</span>
  <span class="s1">sendSnapshot(</span>
      <span class="s1">req.id</span><span class="s4">,</span>
      <span class="s3">&quot;HeapSnapshot.stopTrackingHeapObjects&quot;</span><span class="s4">,</span>
      <span class="s1">req.reportProgress &amp;&amp; *req.reportProgress</span><span class="s4">,</span>
      <span class="s0">/* stopStackTraceCapture */ </span><span class="s4">true</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span>
    <span class="s4">const </span><span class="s1">m::heapProfiler::StartSamplingRequest &amp;req) {</span>
  <span class="s4">const auto </span><span class="s1">id = req.id</span><span class="s4">;</span>
  <span class="s0">// This is the same default sampling interval that Chrome uses.</span>
  <span class="s0">// https://chromedevtools.github.io/devtools-protocol/tot/HeapProfiler/#method-startSampling</span>
  <span class="s4">constexpr </span><span class="s1">size_t kDefaultSamplingInterval = </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">15</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">size_t samplingInterval =</span>
      <span class="s1">req.samplingInterval.value_or(kDefaultSamplingInterval)</span><span class="s4">;</span>

  <span class="s1">inspector_</span>
      <span class="s1">-&gt;executeIfEnabled(</span>
          <span class="s3">&quot;HeapProfiler.startSampling&quot;</span><span class="s4">,</span>
          <span class="s1">[</span><span class="s4">this, </span><span class="s1">samplingInterval](</span><span class="s4">const </span><span class="s1">debugger::ProgramState &amp;) {</span>
            <span class="s1">getRuntime().instrumentation().startHeapSampling(samplingInterval)</span><span class="s4">;</span>
          <span class="s1">})</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue(</span>
          <span class="s1">[</span><span class="s4">this, </span><span class="s1">id](</span><span class="s4">auto </span><span class="s1">&amp;&amp;) { sendResponseToClient(m::makeOkResponse(id))</span><span class="s4">; </span><span class="s1">})</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(req.id))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::heapProfiler::StopSamplingRequest &amp;req) {</span>
  <span class="s1">inspector_</span>
      <span class="s1">-&gt;executeIfEnabled(</span>
          <span class="s3">&quot;HeapProfiler.stopSampling&quot;</span><span class="s4">,</span>
          <span class="s1">[</span><span class="s4">this, </span><span class="s1">id = req.id](</span><span class="s4">const </span><span class="s1">debugger::ProgramState &amp;) {</span>
            <span class="s1">std::ostringstream stream</span><span class="s4">;</span>
            <span class="s1">getRuntime().instrumentation().stopHeapSampling(stream)</span><span class="s4">;</span>
            <span class="s1">folly::dynamic json = folly::parseJson(stream.str())</span><span class="s4">;</span>
            <span class="s1">m::heapProfiler::StopSamplingResponse resp</span><span class="s4">;</span>
            <span class="s1">resp.id = id</span><span class="s4">;</span>
            <span class="s1">m::heapProfiler::SamplingHeapProfile profile{json}</span><span class="s4">;</span>
            <span class="s1">resp.profile = profile</span><span class="s4">;</span>
            <span class="s1">sendResponseToClient(resp)</span><span class="s4">;</span>
          <span class="s1">})</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(req.id))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span>
    <span class="s4">const </span><span class="s1">m::heapProfiler::CollectGarbageRequest &amp;req) {</span>
  <span class="s4">const auto </span><span class="s1">id = req.id</span><span class="s4">;</span>

  <span class="s1">inspector_</span>
      <span class="s1">-&gt;executeIfEnabled(</span>
          <span class="s3">&quot;HeapProfiler.collectGarbage&quot;</span><span class="s4">,</span>
          <span class="s1">[</span><span class="s4">this</span><span class="s1">](</span><span class="s4">const </span><span class="s1">debugger::ProgramState &amp;) {</span>
            <span class="s1">getRuntime().instrumentation().collectGarbage(</span><span class="s3">&quot;inspector&quot;</span><span class="s1">)</span><span class="s4">;</span>
          <span class="s1">})</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue(</span>
          <span class="s1">[</span><span class="s4">this, </span><span class="s1">id](</span><span class="s4">auto </span><span class="s1">&amp;&amp;) { sendResponseToClient(m::makeOkResponse(id))</span><span class="s4">; </span><span class="s1">})</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(req.id))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span>
    <span class="s4">const </span><span class="s1">m::heapProfiler::GetObjectByHeapObjectIdRequest &amp;req) {</span>
  <span class="s1">uint64_t objID = atoi(req.objectId.c_str())</span><span class="s4">;</span>
  <span class="s1">std::optional&lt;std::string&gt; group = req.objectGroup</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">remoteObjPtr = std::make_shared&lt;m::runtime::RemoteObject&gt;()</span><span class="s4">;</span>

  <span class="s1">inspector_</span>
      <span class="s1">-&gt;executeIfEnabled(</span>
          <span class="s3">&quot;HeapProfiler.getObjectByHeapObjectId&quot;</span><span class="s4">,</span>
          <span class="s1">[</span><span class="s4">this, </span><span class="s1">remoteObjPtr</span><span class="s4">, </span><span class="s1">objID</span><span class="s4">, </span><span class="s1">group](</span><span class="s4">const </span><span class="s1">debugger::ProgramState &amp;) {</span>
            <span class="s1">jsi::Runtime *rt = &amp;getRuntime()</span><span class="s4">;</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s4">auto </span><span class="s1">*hermesRT = </span><span class="s4">dynamic_cast</span><span class="s1">&lt;HermesRuntime *&gt;(rt)) {</span>
              <span class="s1">jsi::Value val = hermesRT-&gt;getObjectForID(objID)</span><span class="s4">;</span>
              <span class="s4">if </span><span class="s1">(val.isNull()) {</span>
                <span class="s4">return;</span>
              <span class="s1">}</span>
              <span class="s1">*remoteObjPtr = m::runtime::makeRemoteObject(</span>
                  <span class="s1">getRuntime()</span><span class="s4">, </span><span class="s1">val</span><span class="s4">, </span><span class="s1">objTable_</span><span class="s4">, </span><span class="s1">group.value_or(</span><span class="s3">&quot;&quot;</span><span class="s1">))</span><span class="s4">;</span>
            <span class="s1">}</span>
          <span class="s1">})</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue([</span><span class="s4">this, </span><span class="s1">id = req.id</span><span class="s4">, </span><span class="s1">remoteObjPtr](</span><span class="s4">auto </span><span class="s1">&amp;&amp;) {</span>
        <span class="s4">if </span><span class="s1">(!remoteObjPtr-&gt;type.empty()) {</span>
          <span class="s1">m::heapProfiler::GetObjectByHeapObjectIdResponse resp</span><span class="s4">;</span>
          <span class="s1">resp.id = id</span><span class="s4">;</span>
          <span class="s1">resp.result = *remoteObjPtr</span><span class="s4">;</span>
          <span class="s1">sendResponseToClient(resp)</span><span class="s4">;</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
          <span class="s1">sendResponseToClient(m::makeErrorResponse(</span>
              <span class="s1">id</span><span class="s4">, </span><span class="s1">m::ErrorCode::ServerError</span><span class="s4">, </span><span class="s3">&quot;Object is not available&quot;</span><span class="s1">))</span><span class="s4">;</span>
        <span class="s1">}</span>
      <span class="s1">})</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(req.id))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span>
    <span class="s4">const </span><span class="s1">m::heapProfiler::GetHeapObjectIdRequest &amp;req) {</span>
  <span class="s0">// Use a shared_ptr because the stack frame will go away.</span>
  <span class="s1">std::shared_ptr&lt;uint64_t&gt; snapshotID = std::make_shared&lt;uint64_t&gt;(</span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">inspector_</span>
      <span class="s1">-&gt;executeIfEnabled(</span>
          <span class="s3">&quot;HeapProfiler.getHeapObjectId&quot;</span><span class="s4">,</span>
          <span class="s1">[</span><span class="s4">this, </span><span class="s1">req</span><span class="s4">, </span><span class="s1">snapshotID](</span><span class="s4">const </span><span class="s1">debugger::ProgramState &amp;) {</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s4">const </span><span class="s1">jsi::Value *valuePtr = objTable_.getValue(req.objectId)) {</span>
              <span class="s1">jsi::Runtime *rt = &amp;getRuntime()</span><span class="s4">;</span>
              <span class="s4">if </span><span class="s1">(</span><span class="s4">auto </span><span class="s1">*hermesRT = </span><span class="s4">dynamic_cast</span><span class="s1">&lt;HermesRuntime *&gt;(rt)) {</span>
                <span class="s1">*snapshotID = hermesRT-&gt;getUniqueID(*valuePtr)</span><span class="s4">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">})</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue([</span><span class="s4">this, </span><span class="s1">id = req.id</span><span class="s4">, </span><span class="s1">snapshotID](</span><span class="s4">auto </span><span class="s1">&amp;&amp;) {</span>
        <span class="s4">if </span><span class="s1">(*snapshotID) {</span>
          <span class="s1">m::heapProfiler::GetHeapObjectIdResponse resp</span><span class="s4">;</span>
          <span class="s1">resp.id = id</span><span class="s4">;</span>
          <span class="s0">// std::to_string is not available on Android, use a std::ostream</span>
          <span class="s0">// instead.</span>
          <span class="s1">std::ostringstream stream</span><span class="s4">;</span>
          <span class="s1">stream &lt;&lt; *snapshotID</span><span class="s4">;</span>
          <span class="s1">resp.heapSnapshotObjectId = stream.str()</span><span class="s4">;</span>
          <span class="s1">sendResponseToClient(resp)</span><span class="s4">;</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
          <span class="s1">sendResponseToClient(m::makeErrorResponse(</span>
              <span class="s1">id</span><span class="s4">, </span><span class="s1">m::ErrorCode::ServerError</span><span class="s4">, </span><span class="s3">&quot;Object is not available&quot;</span><span class="s1">))</span><span class="s4">;</span>
        <span class="s1">}</span>
      <span class="s1">})</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(req.id))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::profiler::StartRequest &amp;req) {</span>
  <span class="s1">runInExecutor(req.id</span><span class="s4">, </span><span class="s1">[</span><span class="s4">this, </span><span class="s1">id = req.id]() {</span>
    <span class="s1">HermesRuntime::enableSamplingProfiler()</span><span class="s4">;</span>
    <span class="s1">sendResponseToClient(m::makeOkResponse(id))</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::profiler::StopRequest &amp;req) {</span>
  <span class="s1">HermesRuntime *hermesRT = &amp;getRuntime()</span><span class="s4">;</span>

  <span class="s1">runInExecutor(req.id</span><span class="s4">, </span><span class="s1">[</span><span class="s4">this, </span><span class="s1">id = req.id</span><span class="s4">, </span><span class="s1">hermesRT]() {</span>
    <span class="s1">HermesRuntime::disableSamplingProfiler()</span><span class="s4">;</span>

    <span class="s1">std::ostringstream profileStream</span><span class="s4">;</span>
    <span class="s0">// HermesRuntime instance methods are usually unsafe to be called with a</span>
    <span class="s0">// running VM, but sampledTraceToStreamInDevToolsFormat is an exception to</span>
    <span class="s0">// that rule -- it synchronizes access to shared resources so it can be</span>
    <span class="s0">// safely invoked with a running VM.</span>
    <span class="s1">hermesRT-&gt;sampledTraceToStreamInDevToolsFormat(profileStream)</span><span class="s4">;</span>

    <span class="s0">// Hermes can emit the proper format directly, but it still needs to</span>
    <span class="s0">// be parsed into a dynamic.</span>
    <span class="s4">try </span><span class="s1">{</span>
      <span class="s1">m::profiler::StopResponse resp</span><span class="s4">;</span>
      <span class="s1">resp.id = id</span><span class="s4">;</span>
      <span class="s0">// parseJson throws on errors, so make sure we don't crash the app</span>
      <span class="s0">// if somehow the sampling profiler output is borked.</span>
      <span class="s1">resp.profile = m::profiler::Profile(</span>
          <span class="s1">folly::parseJson(std::move(profileStream).str()))</span><span class="s4">;</span>
      <span class="s1">sendResponseToClient(resp)</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">catch </span><span class="s1">(</span><span class="s4">const </span><span class="s1">std::exception &amp;) {</span>
      <span class="s1">LOG(ERROR) &lt;&lt; </span><span class="s3">&quot;Failed to parse Sampling Profiler output&quot;</span><span class="s4">;</span>
      <span class="s1">sendResponseToClient(m::makeErrorResponse(</span>
          <span class="s1">id</span><span class="s4">,</span>
          <span class="s1">m::ErrorCode::InternalError</span><span class="s4">,</span>
          <span class="s3">&quot;Hermes profile output could not be parsed.&quot;</span><span class="s1">))</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">namespace </span><span class="s1">{</span>
<span class="s0">/// Runtime.CallArguments can have their values specified &quot;inline&quot;, or they can</span>
<span class="s0">/// have remote references. The inline values are eval'd together with the</span>
<span class="s0">/// Runtime.CallFunctionOn.functionDeclaration (see CallFunctionOnBuilder</span>
<span class="s0">/// below), while remote object Ids need to be resolved outside of the VM.</span>
<span class="s4">class </span><span class="s1">CallFunctionOnArgument {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">explicit </span><span class="s1">CallFunctionOnArgument(</span>
      <span class="s1">std::optional&lt;m::runtime::RemoteObjectId&gt; maybeObjectId)</span>
      <span class="s1">: maybeObjectId_(std::move(maybeObjectId)) {}</span>

  <span class="s0">/// Computes the real value for this argument, which can be an object</span>
  <span class="s0">/// referenced by maybeObjectId_, or the given evaldValue. Throws if</span>
  <span class="s0">/// maybeObjectId_ is not empty but references an unknown object.</span>
  <span class="s1">jsi::Value value(</span>
      <span class="s1">jsi::Runtime &amp;rt</span><span class="s4">,</span>
      <span class="s1">RemoteObjectsTable &amp;objTable</span><span class="s4">,</span>
      <span class="s1">jsi::Value evaldValue) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">if </span><span class="s1">(maybeObjectId_) {</span>
      <span class="s1">assert(evaldValue.isUndefined() &amp;&amp; </span><span class="s3">&quot;expected undefined placeholder&quot;</span><span class="s1">)</span><span class="s4">;</span>
      <span class="s4">return </span><span class="s1">getValueFromId(rt</span><span class="s4">, </span><span class="s1">objTable</span><span class="s4">, </span><span class="s1">*maybeObjectId_)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">return </span><span class="s1">evaldValue</span><span class="s4">;</span>
  <span class="s1">}</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s0">/// Returns the jsi::Object for the given objId. Throws if such object can't</span>
  <span class="s0">/// be found.</span>
  <span class="s4">static </span><span class="s1">jsi::Value getValueFromId(</span>
      <span class="s1">jsi::Runtime &amp;rt</span><span class="s4">,</span>
      <span class="s1">RemoteObjectsTable &amp;objTable</span><span class="s4">,</span>
      <span class="s1">m::runtime::RemoteObjectId objId) {</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s4">const </span><span class="s1">jsi::Value *ptr = objTable.getValue(objId)) {</span>
      <span class="s4">return </span><span class="s1">jsi::Value(rt</span><span class="s4">, </span><span class="s1">*ptr)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">throw </span><span class="s1">std::runtime_error(</span><span class="s3">&quot;unknown object id &quot; </span><span class="s1">+ objId)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">std::optional&lt;m::runtime::RemoteObjectId&gt; maybeObjectId_</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// Functor that should be used to run the result of eval-ing a CallFunctionOn</span>
<span class="s0">/// request.</span>
<span class="s4">class </span><span class="s1">CallFunctionOnRunner {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">static constexpr </span><span class="s1">size_t kJsThisIndex = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">static constexpr </span><span class="s1">size_t kFirstArgIndex = </span><span class="s5">1</span><span class="s4">;</span>

  <span class="s0">// N.B.: constexpr char[] broke react-native-oss-android.</span>
  <span class="s4">static const char </span><span class="s1">*kJsThisArgPlaceholder</span><span class="s4">;</span>

  <span class="s1">CallFunctionOnRunner() = </span><span class="s4">default;</span>
  <span class="s1">CallFunctionOnRunner(CallFunctionOnRunner &amp;&amp;) = </span><span class="s4">default;</span>
  <span class="s1">CallFunctionOnRunner &amp;</span><span class="s4">operator</span><span class="s1">=(CallFunctionOnRunner &amp;&amp;) = </span><span class="s4">default;</span>

  <span class="s0">/// Performs the actual Runtime.CallFunctionOn request. It assumes.</span>
  <span class="s0">/// \p evalResult is the result of invoking the Inspector's evaluate() method</span>
  <span class="s0">/// on the expression built by the CallFunctionOnBuilder below.</span>
  <span class="s1">jsi::Value </span><span class="s4">operator</span><span class="s1">()(</span>
      <span class="s1">jsi::Runtime &amp;rt</span><span class="s4">,</span>
      <span class="s1">RemoteObjectsTable &amp;objTable</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">facebook::hermes::debugger::EvalResult &amp;evalResult) {</span>
    <span class="s0">// The eval result is an array [a0, a1, ..., an, func] (see</span>
    <span class="s0">// CallFunctionOnBuilder below).</span>
    <span class="s4">auto </span><span class="s1">argsAndFunc = evalResult.value.getObject(rt).getArray(rt)</span><span class="s4">;</span>
    <span class="s1">assert(</span>
        <span class="s1">argsAndFunc.length(rt) == thisAndArguments_.size() + </span><span class="s5">1 </span><span class="s1">&amp;&amp;</span>
        <span class="s3">&quot;Unexpected result size&quot;</span><span class="s1">)</span><span class="s4">;</span>

    <span class="s0">// now resolve the arguments to the call, including &quot;this&quot;.</span>
    <span class="s1">std::vector&lt;jsi::Value&gt; arguments(thisAndArguments_.size() - </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

    <span class="s1">jsi::Object jsThis =</span>
        <span class="s1">getJsThis(rt</span><span class="s4">, </span><span class="s1">objTable</span><span class="s4">, </span><span class="s1">argsAndFunc.getValueAtIndex(rt</span><span class="s4">, </span><span class="s1">kJsThisIndex))</span><span class="s4">;</span>

    <span class="s4">int </span><span class="s1">i = kFirstArgIndex</span><span class="s4">;</span>
    <span class="s4">for </span><span class="s1">(</span><span class="s0">/*i points to the first param*/</span><span class="s4">; </span><span class="s1">i &lt; thisAndArguments_.size()</span><span class="s4">; </span><span class="s1">++i) {</span>
      <span class="s1">arguments[i - kFirstArgIndex] = thisAndArguments_[i].value(</span>
          <span class="s1">rt</span><span class="s4">, </span><span class="s1">objTable</span><span class="s4">, </span><span class="s1">argsAndFunc.getValueAtIndex(rt</span><span class="s4">, </span><span class="s1">i))</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s0">// i is now func's index.</span>
    <span class="s1">jsi::Function func =</span>
        <span class="s1">argsAndFunc.getValueAtIndex(rt</span><span class="s4">, </span><span class="s1">i).getObject(rt).getFunction(rt)</span><span class="s4">;</span>

    <span class="s4">return </span><span class="s1">func.callWithThis(</span>
        <span class="s1">rt</span><span class="s4">,</span>
        <span class="s1">std::move(jsThis)</span><span class="s4">,</span>
        <span class="s4">static_cast</span><span class="s1">&lt;</span><span class="s4">const </span><span class="s1">jsi::Value *&gt;(arguments.data())</span><span class="s4">,</span>
        <span class="s1">arguments.size())</span><span class="s4">;</span>
  <span class="s1">}</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s4">friend class </span><span class="s1">CallFunctionOnBuilder</span><span class="s4">;</span>

  <span class="s1">CallFunctionOnRunner(</span><span class="s4">const </span><span class="s1">CallFunctionOnRunner &amp;) = </span><span class="s4">delete;</span>
  <span class="s1">CallFunctionOnRunner &amp;</span><span class="s4">operator</span><span class="s1">=(</span><span class="s4">const </span><span class="s1">CallFunctionOnRunner &amp;) = </span><span class="s4">delete;</span>

  <span class="s1">CallFunctionOnRunner(</span>
      <span class="s1">std::vector&lt;CallFunctionOnArgument&gt; thisAndArguments</span><span class="s4">,</span>
      <span class="s1">std::optional&lt;m::runtime::ExecutionContextId&gt; executionContextId)</span>
      <span class="s1">: thisAndArguments_(std::move(thisAndArguments))</span><span class="s4">,</span>
        <span class="s1">executionContextId_(std::move(executionContextId)) {}</span>

  <span class="s0">/// Resolves the js &quot;this&quot; for the request, which lives in</span>
  <span class="s0">/// thisAndArguments_[kJsThisIndex]. \p evaldThis should either be undefined,</span>
  <span class="s0">/// or the placeholder indicating that globalThis should be used.</span>
  <span class="s1">jsi::Object getJsThis(</span>
      <span class="s1">jsi::Runtime &amp;rt</span><span class="s4">,</span>
      <span class="s1">RemoteObjectsTable &amp;objTable</span><span class="s4">,</span>
      <span class="s1">jsi::Value evaldThis) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s0">// In the future we may support multiple execution context ids; for now,</span>
    <span class="s0">// there's only one.</span>
    <span class="s1">(</span><span class="s4">void</span><span class="s1">)executionContextId_</span><span class="s4">;</span>

    <span class="s0">// Either evaldThis is undefined (because the request had an object id</span>
    <span class="s0">// specifying &quot;this&quot;), or it should be a string (i.e., the placeholder</span>
    <span class="s0">// kJsThisArgPlaceholder).</span>
    <span class="s1">assert(</span>
        <span class="s1">(evaldThis.isUndefined() ||</span>
         <span class="s1">(evaldThis.isString() &amp;&amp;</span>
          <span class="s1">evaldThis.getString(rt).utf8(rt) == kJsThisArgPlaceholder)) &amp;&amp;</span>
        <span class="s3">&quot;unexpected value for jsThis argument placeholder&quot;</span><span class="s1">)</span><span class="s4">;</span>

    <span class="s0">// Need to save this information because of the std::move() below.</span>
    <span class="s4">const bool </span><span class="s1">useGlobalThis = evaldThis.isString()</span><span class="s4">;</span>
    <span class="s1">jsi::Value value = thisAndArguments_[kJsThisIndex].value(</span>
        <span class="s1">rt</span><span class="s4">, </span><span class="s1">objTable</span><span class="s4">, </span><span class="s1">std::move(evaldThis))</span><span class="s4">;</span>

    <span class="s4">return </span><span class="s1">useGlobalThis ? rt.global() : value.getObject(rt)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">std::vector&lt;CallFunctionOnArgument&gt; thisAndArguments_</span><span class="s4">;</span>
  <span class="s1">std::optional&lt;m::runtime::ExecutionContextId&gt; executionContextId_</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/*static*/ </span><span class="s4">const char </span><span class="s1">*CallFunctionOnRunner::kJsThisArgPlaceholder =</span>
    <span class="s3">&quot;jsThis is Execution Context&quot;</span><span class="s4">;</span>

<span class="s0">/// Returns true if \p str is a number-like string value (e.g., Infinity),</span>
<span class="s0">/// and false otherwise.</span>
<span class="s4">bool </span><span class="s1">unserializableValueLooksLikeNumber(</span><span class="s4">const </span><span class="s1">std::string &amp;str) {</span>
  <span class="s4">return </span><span class="s1">str == </span><span class="s3">&quot;Infinity&quot; </span><span class="s1">|| str == </span><span class="s3">&quot;-Infinity&quot; </span><span class="s1">|| str == </span><span class="s3">&quot;NaN&quot;</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/// Helper class that processes a Runtime.CallFunctionOn request, and</span>
<span class="s0">/// builds an expression string that, once eval()d, yields an Array with the</span>
<span class="s0">/// CallArguments as well as the function to run. The generated array is</span>
<span class="s0">///</span>
<span class="s0">/// [JsThis, P0, P1, P2, P3, Pn, F]</span>
<span class="s0">///</span>
<span class="s0">/// where:</span>
<span class="s0">///   * F is the functionDeclaration in the request</span>
<span class="s0">///   * JsThis is either:</span>
<span class="s0">///      * undefined (if the request has an object ID); or</span>
<span class="s0">///      * the placeholder kJsThisArgPlaceholder</span>
<span class="s0">///   * Pi is either:</span>
<span class="s0">///      * the string in CallArgument[i].unserializableValue; or</span>
<span class="s0">///      * the string in CallArgument[i].value; or</span>
<span class="s0">///      * arguments[j] (i.e., the j-th argument passed to the newly built</span>
<span class="s0">///        function), j being the j-th CallArgument with an ObjectId. This is</span>
<span class="s0">///        needed because there's no easy way to express the objects referred</span>
<span class="s0">///        to by object ids by name.</span>
<span class="s4">class </span><span class="s1">CallFunctionOnBuilder {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">explicit </span><span class="s1">CallFunctionOnBuilder(</span><span class="s4">const </span><span class="s1">m::runtime::CallFunctionOnRequest &amp;req)</span>
      <span class="s1">: executionContextId_(req.executionContextId) {</span>
    <span class="s1">out_ &lt;&lt; </span><span class="s3">&quot;[&quot;</span><span class="s4">;</span>
    <span class="s1">thisAndArguments_.emplace_back(CallFunctionOnArgument(req.objectId))</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(req.objectId) {</span>
      <span class="s1">out_ &lt;&lt; </span><span class="s3">&quot;undefined, &quot;</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s1">out_ &lt;&lt; </span><span class="s3">'</span><span class="s4">\'</span><span class="s3">' </span><span class="s1">&lt;&lt; CallFunctionOnRunner::kJsThisArgPlaceholder &lt;&lt; </span><span class="s3">&quot;', &quot;</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">addParams(req.arguments)</span><span class="s4">;</span>
    <span class="s1">out_ &lt;&lt; req.functionDeclaration</span><span class="s4">;</span>
    <span class="s1">out_ &lt;&lt; </span><span class="s3">&quot;]&quot;</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s0">/// Extracts the functions that handles the CallFunctionOn requests, as well</span>
  <span class="s0">/// as the list of object ids that must be passed when calling it.</span>
  <span class="s1">std::pair&lt;std::string</span><span class="s4">, </span><span class="s1">CallFunctionOnRunner&gt; expressionAndRunner() &amp;&amp; {</span>
    <span class="s4">return </span><span class="s1">std::make_pair(</span>
        <span class="s1">std::move(out_).str()</span><span class="s4">,</span>
        <span class="s1">CallFunctionOnRunner(</span>
            <span class="s1">std::move(thisAndArguments_)</span><span class="s4">, </span><span class="s1">std::move(executionContextId_)))</span><span class="s4">;</span>
  <span class="s1">}</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s4">void </span><span class="s1">addParams(</span><span class="s4">const </span><span class="s1">std::optional&lt;std::vector&lt;m::runtime::CallArgument&gt;&gt;</span>
                     <span class="s1">&amp;maybeArguments) {</span>
    <span class="s4">if </span><span class="s1">(maybeArguments) {</span>
      <span class="s4">for </span><span class="s1">(</span><span class="s4">const auto </span><span class="s1">&amp;ca : *maybeArguments) {</span>
        <span class="s1">addParam(ca)</span><span class="s4">;</span>
        <span class="s1">thisAndArguments_.emplace_back(CallFunctionOnArgument(ca.objectId))</span><span class="s4">;</span>
        <span class="s1">out_ &lt;&lt; </span><span class="s3">&quot;, &quot;</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">void </span><span class="s1">addParam(</span><span class="s4">const </span><span class="s1">m::runtime::CallArgument &amp;ca) {</span>
    <span class="s4">if </span><span class="s1">(ca.objectId) {</span>
      <span class="s1">out_ &lt;&lt; </span><span class="s3">&quot;undefined&quot;</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(ca.value) {</span>
      <span class="s0">// TODO: this may throw if ca.value is a CBOR (see RFC 8949), but the</span>
      <span class="s0">// chrome debugger doesn't seem to send those.</span>
      <span class="s1">out_ &lt;&lt; </span><span class="s3">&quot;(&quot; </span><span class="s1">&lt;&lt; folly::toJson(*ca.value) &lt;&lt; </span><span class="s3">&quot;)&quot;</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(ca.unserializableValue) {</span>
      <span class="s4">if </span><span class="s1">(unserializableValueLooksLikeNumber(*ca.unserializableValue)) {</span>
        <span class="s1">out_ &lt;&lt; </span><span class="s3">&quot;+(&quot; </span><span class="s1">&lt;&lt; *ca.unserializableValue &lt;&lt; </span><span class="s3">&quot;)&quot;</span><span class="s4">;</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s1">out_ &lt;&lt; *ca.unserializableValue</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s4">throw </span><span class="s1">std::runtime_error(</span><span class="s3">&quot;unknown payload for CallParam&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">std::ostringstream out_</span><span class="s4">;</span>

  <span class="s1">std::vector&lt;CallFunctionOnArgument&gt; thisAndArguments_</span><span class="s4">;</span>
  <span class="s1">std::optional&lt;m::runtime::ExecutionContextId&gt; executionContextId_</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s1">} </span><span class="s0">// namespace</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::runtime::CallFunctionOnRequest &amp;req) {</span>
  <span class="s1">std::string expression</span><span class="s4">;</span>
  <span class="s1">CallFunctionOnRunner runner</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">validateAndParseRequest =</span>
      <span class="s1">[&amp;expression</span><span class="s4">, </span><span class="s1">&amp;runner](</span><span class="s4">const </span><span class="s1">m::runtime::CallFunctionOnRequest &amp;req)</span>
      <span class="s1">-&gt; std::optional&lt;std::string&gt; {</span>
    <span class="s4">if </span><span class="s1">(req.objectId.has_value() == req.executionContextId.has_value()) {</span>
      <span class="s4">return </span><span class="s1">std::string(</span>
          <span class="s3">&quot;The request must specify either object id or execution context id.&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(!req.objectId) {</span>
      <span class="s1">assert(</span>
          <span class="s1">req.executionContextId &amp;&amp;</span>
          <span class="s3">&quot;should not be here if both object id and execution context id are missing&quot;</span><span class="s1">)</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(*req.executionContextId != kHermesExecutionContextId) {</span>
        <span class="s4">return </span><span class="s3">&quot;unknown execution context id &quot; </span><span class="s1">+</span>
            <span class="s1">std::to_string(*req.executionContextId)</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">try </span><span class="s1">{</span>
      <span class="s1">std::tie(expression</span><span class="s4">, </span><span class="s1">runner) =</span>
          <span class="s1">CallFunctionOnBuilder(req).expressionAndRunner()</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">catch </span><span class="s1">(</span><span class="s4">const </span><span class="s1">std::exception &amp;e) {</span>
      <span class="s4">return </span><span class="s1">std::string(e.what())</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">return </span><span class="s1">{}</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(</span><span class="s4">auto </span><span class="s1">errMsg = validateAndParseRequest(req)) {</span>
    <span class="s1">sendErrorToClientViaExecutor(req.id</span><span class="s4">, </span><span class="s1">*errMsg)</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s4">auto </span><span class="s1">remoteObjPtr = std::make_shared&lt;m::runtime::RemoteObject&gt;()</span><span class="s4">;</span>
  <span class="s1">inspector_</span>
      <span class="s1">-&gt;evaluate(</span>
          <span class="s5">0</span><span class="s4">, </span><span class="s0">// Top of the stackframe</span>
          <span class="s1">expression</span><span class="s4">,</span>
          <span class="s1">[</span><span class="s4">this,</span>
           <span class="s1">remoteObjPtr</span><span class="s4">,</span>
           <span class="s1">objectGroup = req.objectGroup</span><span class="s4">,</span>
           <span class="s1">jsThisId = req.objectId</span><span class="s4">,</span>
           <span class="s1">byValue = req.returnByValue.value_or(</span><span class="s4">false</span><span class="s1">)</span><span class="s4">,</span>
           <span class="s1">runner =</span>
               <span class="s1">std::move(runner)](</span><span class="s4">const </span><span class="s1">facebook::hermes::debugger::EvalResult</span>
                                      <span class="s1">&amp;evalResult) </span><span class="s4">mutable </span><span class="s1">{</span>
            <span class="s4">if </span><span class="s1">(evalResult.isException) {</span>
              <span class="s4">return;</span>
            <span class="s1">}</span>

            <span class="s1">*remoteObjPtr = m::runtime::makeRemoteObject(</span>
                <span class="s1">getRuntime()</span><span class="s4">,</span>
                <span class="s1">runner(getRuntime()</span><span class="s4">, </span><span class="s1">objTable_</span><span class="s4">, </span><span class="s1">evalResult)</span><span class="s4">,</span>
                <span class="s1">objTable_</span><span class="s4">,</span>
                <span class="s1">objectGroup.value_or(</span><span class="s3">&quot;ConsoleObjectGroup&quot;</span><span class="s1">)</span><span class="s4">,</span>
                <span class="s1">byValue)</span><span class="s4">;</span>
          <span class="s1">})</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue(</span>
          <span class="s1">[</span><span class="s4">this, </span><span class="s1">id = req.id</span><span class="s4">, </span><span class="s1">remoteObjPtr](debugger::EvalResult result) {</span>
            <span class="s1">m::debugger::EvaluateOnCallFrameResponse resp</span><span class="s4">;</span>
            <span class="s1">resp.id = id</span><span class="s4">;</span>

            <span class="s4">if </span><span class="s1">(result.isException) {</span>
              <span class="s1">resp.exceptionDetails =</span>
                  <span class="s1">m::runtime::makeExceptionDetails(result.exceptionDetails)</span><span class="s4">;</span>
            <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
              <span class="s1">resp.result = *remoteObjPtr</span><span class="s4">;</span>
            <span class="s1">}</span>

            <span class="s1">sendResponseToClient(resp)</span><span class="s4">;</span>
          <span class="s1">})</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(req.id))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::runtime::CompileScriptRequest &amp;req) {</span>
  <span class="s4">auto </span><span class="s1">resp = std::make_shared&lt;m::runtime::CompileScriptResponse&gt;()</span><span class="s4">;</span>
  <span class="s1">resp-&gt;id = req.id</span><span class="s4">;</span>

  <span class="s1">inspector_</span>
      <span class="s1">-&gt;executeIfEnabled(</span>
          <span class="s3">&quot;Runtime.compileScriptRequest&quot;</span><span class="s4">,</span>
          <span class="s1">[</span><span class="s4">this, </span><span class="s1">req</span><span class="s4">, </span><span class="s1">resp](</span><span class="s4">const </span><span class="s1">debugger::ProgramState &amp;state) {</span>
            <span class="s4">if </span><span class="s1">(req.executionContextId.has_value() &amp;&amp;</span>
                <span class="s1">req.executionContextId.value() != kHermesExecutionContextId) {</span>
              <span class="s4">throw </span><span class="s1">std::invalid_argument(</span><span class="s3">&quot;Invalid execution context&quot;</span><span class="s1">)</span><span class="s4">;</span>
            <span class="s1">}</span>

            <span class="s4">auto </span><span class="s1">source = std::make_shared&lt;jsi::StringBuffer&gt;(req.expression)</span><span class="s4">;</span>
            <span class="s1">std::shared_ptr&lt;</span><span class="s4">const </span><span class="s1">jsi::PreparedJavaScript&gt; preparedScript</span><span class="s4">;</span>
            <span class="s4">try </span><span class="s1">{</span>
              <span class="s1">preparedScript =</span>
                  <span class="s1">getRuntime().prepareJavaScript(source</span><span class="s4">, </span><span class="s1">req.sourceURL)</span><span class="s4">;</span>
            <span class="s1">} </span><span class="s4">catch </span><span class="s1">(</span><span class="s4">const </span><span class="s1">facebook::jsi::JSIException &amp;err) {</span>
              <span class="s1">resp-&gt;exceptionDetails = m::runtime::ExceptionDetails()</span><span class="s4">;</span>
              <span class="s1">resp-&gt;exceptionDetails-&gt;text = err.what()</span><span class="s4">;</span>
              <span class="s4">return;</span>
            <span class="s1">}</span>

            <span class="s4">if </span><span class="s1">(req.persistScript) {</span>
              <span class="s4">auto </span><span class="s1">scriptId = folly::to&lt;std::string&gt;(</span>
                  <span class="s1">kUserEnteredScriptPrefix</span><span class="s4">, </span><span class="s1">preparedScripts_.size())</span><span class="s4">;</span>
              <span class="s1">preparedScripts_.push_back(std::move(preparedScript))</span><span class="s4">;</span>
              <span class="s1">resp-&gt;scriptId = scriptId</span><span class="s4">;</span>
            <span class="s1">}</span>
          <span class="s1">})</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue([</span><span class="s4">this, </span><span class="s1">resp](</span><span class="s4">auto </span><span class="s1">&amp;&amp;) { sendResponseToClient(*resp)</span><span class="s4">; </span><span class="s1">})</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(req.id))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::runtime::EvaluateRequest &amp;req) {</span>
  <span class="s4">auto </span><span class="s1">remoteObjPtr = std::make_shared&lt;m::runtime::RemoteObject&gt;()</span><span class="s4">;</span>

  <span class="s1">inspector_</span>
      <span class="s1">-&gt;evaluate(</span>
          <span class="s5">0</span><span class="s4">, </span><span class="s0">// Top of the stackframe</span>
          <span class="s1">req.expression</span><span class="s4">,</span>
          <span class="s1">[</span><span class="s4">this,</span>
           <span class="s1">remoteObjPtr</span><span class="s4">,</span>
           <span class="s1">objectGroup = req.objectGroup</span><span class="s4">,</span>
           <span class="s1">byValue = req.returnByValue.value_or(</span><span class="s4">false</span><span class="s1">)](</span>
              <span class="s4">const </span><span class="s1">facebook::hermes::debugger::EvalResult</span>
                  <span class="s1">&amp;evalResult) </span><span class="s4">mutable </span><span class="s1">{</span>
            <span class="s1">*remoteObjPtr = m::runtime::makeRemoteObject(</span>
                <span class="s1">getRuntime()</span><span class="s4">,</span>
                <span class="s1">evalResult.value</span><span class="s4">,</span>
                <span class="s1">objTable_</span><span class="s4">,</span>
                <span class="s1">objectGroup.value_or(</span><span class="s3">&quot;ConsoleObjectGroup&quot;</span><span class="s1">)</span><span class="s4">,</span>
                <span class="s1">byValue)</span><span class="s4">;</span>
          <span class="s1">})</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue(</span>
          <span class="s1">[</span><span class="s4">this, </span><span class="s1">id = req.id</span><span class="s4">, </span><span class="s1">remoteObjPtr](debugger::EvalResult result) {</span>
            <span class="s1">m::debugger::EvaluateOnCallFrameResponse resp</span><span class="s4">;</span>
            <span class="s1">resp.id = id</span><span class="s4">;</span>

            <span class="s4">if </span><span class="s1">(result.isException) {</span>
              <span class="s1">resp.exceptionDetails =</span>
                  <span class="s1">m::runtime::makeExceptionDetails(result.exceptionDetails)</span><span class="s4">;</span>
            <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
              <span class="s1">resp.result = *remoteObjPtr</span><span class="s4">;</span>
            <span class="s1">}</span>

            <span class="s1">sendResponseToClient(resp)</span><span class="s4">;</span>
          <span class="s1">})</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(req.id))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::debugger::PauseRequest &amp;req) {</span>
  <span class="s1">sendResponseToClientViaExecutor(inspector_-&gt;pause()</span><span class="s4">, </span><span class="s1">req.id)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::debugger::RemoveBreakpointRequest &amp;req) {</span>
  <span class="s4">if </span><span class="s1">(isVirtualBreakpointId(req.breakpointId)) {</span>
    <span class="s1">std::lock_guard&lt;std::mutex&gt; lock(virtualBreakpointMutex_)</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(!removeVirtualBreakpoint(req.breakpointId)) {</span>
      <span class="s1">sendErrorToClientViaExecutor(</span>
          <span class="s1">req.id</span><span class="s4">, </span><span class="s3">&quot;Unknown breakpoint ID: &quot; </span><span class="s1">+ req.breakpointId)</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s1">sendResponseToClientViaExecutor(req.id)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">auto </span><span class="s1">breakpointId = folly::to&lt;debugger::BreakpointID&gt;(req.breakpointId)</span><span class="s4">;</span>
    <span class="s1">sendResponseToClientViaExecutor(</span>
        <span class="s1">inspector_-&gt;removeBreakpoint(breakpointId)</span><span class="s4">, </span><span class="s1">req.id)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::debugger::ResumeRequest &amp;req) {</span>
  <span class="s1">sendResponseToClientViaExecutor(inspector_-&gt;resume()</span><span class="s4">, </span><span class="s1">req.id)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::debugger::SetBreakpointRequest &amp;req) {</span>
  <span class="s1">debugger::SourceLocation loc</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">scriptId = folly::tryTo&lt;</span><span class="s4">unsigned int</span><span class="s1">&gt;(req.location.scriptId)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!scriptId) {</span>
    <span class="s1">sendErrorToClientViaExecutor(</span>
        <span class="s1">req.id</span><span class="s4">, </span><span class="s3">&quot;Expected integer scriptId: &quot; </span><span class="s1">+ req.location.scriptId)</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">loc.fileId = scriptId.value()</span><span class="s4">;</span>
  <span class="s0">// CDP Locations are 0-based, Hermes lines/columns are 1-based</span>
  <span class="s1">loc.line = req.location.lineNumber + </span><span class="s5">1</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(req.location.columnNumber) {</span>
    <span class="s1">loc.column = req.location.columnNumber.value() + </span><span class="s5">1</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">inspector_-&gt;setBreakpoint(loc</span><span class="s4">, </span><span class="s1">req.condition)</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue([</span><span class="s4">this, </span><span class="s1">id = req.id](debugger::BreakpointInfo info) {</span>
        <span class="s1">m::debugger::SetBreakpointResponse resp</span><span class="s4">;</span>
        <span class="s1">resp.id = id</span><span class="s4">;</span>
        <span class="s1">resp.breakpointId = folly::to&lt;std::string&gt;(info.id)</span><span class="s4">;</span>

        <span class="s4">if </span><span class="s1">(info.resolved) {</span>
          <span class="s1">resp.actualLocation =</span>
              <span class="s1">m::debugger::makeLocation(info.resolvedLocation)</span><span class="s4">;</span>
        <span class="s1">}</span>

        <span class="s1">sendResponseToClient(resp)</span><span class="s4">;</span>
      <span class="s1">})</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(req.id))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span>
    <span class="s4">const </span><span class="s1">m::debugger::SetBreakpointByUrlRequest &amp;req) {</span>
  <span class="s1">debugger::SourceLocation loc</span><span class="s4">;</span>

  <span class="s1">{</span>
    <span class="s1">std::lock_guard&lt;std::mutex&gt; lock(parsedScriptsMutex_)</span><span class="s4">;</span>
    <span class="s1">setHermesLocation(loc</span><span class="s4">, </span><span class="s1">req</span><span class="s4">, </span><span class="s1">parsedScripts_)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">inspector_-&gt;setBreakpoint(loc</span><span class="s4">, </span><span class="s1">req.condition)</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue([</span><span class="s4">this, </span><span class="s1">id = req.id](debugger::BreakpointInfo info) {</span>
        <span class="s1">m::debugger::SetBreakpointByUrlResponse resp</span><span class="s4">;</span>
        <span class="s1">resp.id = id</span><span class="s4">;</span>
        <span class="s1">resp.breakpointId = folly::to&lt;std::string&gt;(info.id)</span><span class="s4">;</span>

        <span class="s4">if </span><span class="s1">(info.resolved) {</span>
          <span class="s1">resp.locations.emplace_back(</span>
              <span class="s1">m::debugger::makeLocation(info.resolvedLocation))</span><span class="s4">;</span>
        <span class="s1">}</span>

        <span class="s1">sendResponseToClient(resp)</span><span class="s4">;</span>
      <span class="s1">})</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(req.id))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span>
    <span class="s4">const </span><span class="s1">m::debugger::SetBreakpointsActiveRequest &amp;req) {</span>
  <span class="s1">inspector_-&gt;setBreakpointsActive(req.active)</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue([</span><span class="s4">this, </span><span class="s1">id = req.id](</span><span class="s4">const </span><span class="s1">Unit &amp;unit) {</span>
        <span class="s1">sendResponseToClient(m::makeOkResponse(id))</span><span class="s4">;</span>
      <span class="s1">})</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(req.id))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">bool </span><span class="s1">Connection::Impl::isVirtualBreakpointId(</span><span class="s4">const </span><span class="s1">std::string &amp;id) {</span>
  <span class="s4">return </span><span class="s1">id.rfind(kVirtualBreakpointPrefix</span><span class="s4">, </span><span class="s5">0</span><span class="s1">) == </span><span class="s5">0</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">const </span><span class="s1">std::string &amp;Connection::Impl::createVirtualBreakpoint(</span>
    <span class="s4">const </span><span class="s1">std::string &amp;category) {</span>
  <span class="s4">auto </span><span class="s1">ret = virtualBreakpoints_[category].insert(folly::to&lt;std::string&gt;(</span>
      <span class="s1">kVirtualBreakpointPrefix</span><span class="s4">, </span><span class="s1">nextVirtualBreakpoint_++))</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">*ret.first</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">bool </span><span class="s1">Connection::Impl::hasVirtualBreakpoint(</span><span class="s4">const </span><span class="s1">std::string &amp;category) {</span>
  <span class="s4">auto </span><span class="s1">pos = virtualBreakpoints_.find(category)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(pos == virtualBreakpoints_.end())</span>
    <span class="s4">return false;</span>
  <span class="s4">return </span><span class="s1">!pos-&gt;second.empty()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">bool </span><span class="s1">Connection::Impl::removeVirtualBreakpoint(</span><span class="s4">const </span><span class="s1">std::string &amp;id) {</span>
  <span class="s0">// We expect roughly 1 category, so just iterate over all the sets</span>
  <span class="s4">for </span><span class="s1">(</span><span class="s4">auto </span><span class="s1">&amp;kv : virtualBreakpoints_) {</span>
    <span class="s4">if </span><span class="s1">(kv.second.erase(id) &gt; </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s4">return true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s4">return false;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span>
    <span class="s4">const </span><span class="s1">m::debugger::SetInstrumentationBreakpointRequest &amp;req) {</span>
  <span class="s4">if </span><span class="s1">(req.instrumentation != kBeforeScriptWithSourceMapExecution) {</span>
    <span class="s1">sendErrorToClientViaExecutor(</span>
        <span class="s1">req.id</span><span class="s4">, </span><span class="s3">&quot;Unknown instrumentation breakpoint: &quot; </span><span class="s1">+ req.instrumentation)</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s0">// The act of creating and registering the breakpoint ID is enough</span>
  <span class="s0">// to &quot;set&quot; it. We merely check for the existence of them later.</span>
  <span class="s1">std::lock_guard&lt;std::mutex&gt; lock(virtualBreakpointMutex_)</span><span class="s4">;</span>
  <span class="s1">m::debugger::SetInstrumentationBreakpointResponse resp</span><span class="s4">;</span>
  <span class="s1">resp.id = req.id</span><span class="s4">;</span>
  <span class="s1">resp.breakpointId = createVirtualBreakpoint(req.instrumentation)</span><span class="s4">;</span>
  <span class="s1">sendResponseToClientViaExecutor(resp)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span>
    <span class="s4">const </span><span class="s1">m::debugger::SetPauseOnExceptionsRequest &amp;req) {</span>
  <span class="s1">debugger::PauseOnThrowMode mode = debugger::PauseOnThrowMode::None</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(req.state == </span><span class="s3">&quot;none&quot;</span><span class="s1">) {</span>
    <span class="s1">mode = debugger::PauseOnThrowMode::None</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(req.state == </span><span class="s3">&quot;all&quot;</span><span class="s1">) {</span>
    <span class="s1">mode = debugger::PauseOnThrowMode::All</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(req.state == </span><span class="s3">&quot;uncaught&quot;</span><span class="s1">) {</span>
    <span class="s1">mode = debugger::PauseOnThrowMode::Uncaught</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">sendErrorToClientViaExecutor(</span>
        <span class="s1">req.id</span><span class="s4">, </span><span class="s3">&quot;Unknown pause-on-exception state: &quot; </span><span class="s1">+ req.state)</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">sendResponseToClientViaExecutor(</span>
      <span class="s1">inspector_-&gt;setPauseOnExceptions(mode)</span><span class="s4">, </span><span class="s1">req.id)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::debugger::StepIntoRequest &amp;req) {</span>
  <span class="s1">sendResponseToClientViaExecutor(inspector_-&gt;stepIn()</span><span class="s4">, </span><span class="s1">req.id)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::debugger::StepOutRequest &amp;req) {</span>
  <span class="s1">sendResponseToClientViaExecutor(inspector_-&gt;stepOut()</span><span class="s4">, </span><span class="s1">req.id)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::debugger::StepOverRequest &amp;req) {</span>
  <span class="s1">sendResponseToClientViaExecutor(inspector_-&gt;stepOver()</span><span class="s4">, </span><span class="s1">req.id)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">std::vector&lt;m::runtime::PropertyDescriptor&gt;</span>
<span class="s1">Connection::Impl::makePropsFromScope(</span>
    <span class="s1">std::pair&lt;uint32_t</span><span class="s4">, </span><span class="s1">uint32_t&gt; frameAndScopeIndex</span><span class="s4">,</span>
    <span class="s4">const </span><span class="s1">std::string &amp;objectGroup</span><span class="s4">,</span>
    <span class="s4">const </span><span class="s1">debugger::ProgramState &amp;state) {</span>
  <span class="s0">// Chrome represents variables in a scope as properties on a dummy object.</span>
  <span class="s0">// We don't instantiate such dummy objects, we just pretended to have one.</span>
  <span class="s0">// Chrome has now asked for its properties, so it's time to synthesize</span>
  <span class="s0">// descriptions of the properties that the dummy object would have had.</span>
  <span class="s1">std::vector&lt;m::runtime::PropertyDescriptor&gt; result</span><span class="s4">;</span>

  <span class="s1">uint32_t frameIndex = frameAndScopeIndex.first</span><span class="s4">;</span>
  <span class="s1">uint32_t scopeIndex = frameAndScopeIndex.second</span><span class="s4">;</span>
  <span class="s1">debugger::LexicalInfo lexicalInfo = state.getLexicalInfo(frameIndex)</span><span class="s4">;</span>
  <span class="s1">uint32_t varCount = lexicalInfo.getVariablesCountInScope(scopeIndex)</span><span class="s4">;</span>

  <span class="s0">// If this is the frame's local scope, include 'this'.</span>
  <span class="s4">if </span><span class="s1">(scopeIndex == </span><span class="s5">0</span><span class="s1">) {</span>
    <span class="s4">auto </span><span class="s1">varInfo = state.getVariableInfoForThis(frameIndex)</span><span class="s4">;</span>
    <span class="s1">m::runtime::PropertyDescriptor desc</span><span class="s4">;</span>
    <span class="s1">desc.name = varInfo.name</span><span class="s4">;</span>
    <span class="s1">desc.value = m::runtime::makeRemoteObject(</span>
        <span class="s1">getRuntime()</span><span class="s4">, </span><span class="s1">varInfo.value</span><span class="s4">, </span><span class="s1">objTable_</span><span class="s4">, </span><span class="s1">objectGroup)</span><span class="s4">;</span>
    <span class="s0">// Chrome only shows enumerable properties.</span>
    <span class="s1">desc.enumerable = </span><span class="s4">true;</span>
    <span class="s1">result.emplace_back(std::move(desc))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// Then add each of the variables in this lexical scope.</span>
  <span class="s4">for </span><span class="s1">(uint32_t varIndex = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">varIndex &lt; varCount</span><span class="s4">; </span><span class="s1">varIndex++) {</span>
    <span class="s1">debugger::VariableInfo varInfo =</span>
        <span class="s1">state.getVariableInfo(frameIndex</span><span class="s4">, </span><span class="s1">scopeIndex</span><span class="s4">, </span><span class="s1">varIndex)</span><span class="s4">;</span>

    <span class="s1">m::runtime::PropertyDescriptor desc</span><span class="s4">;</span>
    <span class="s1">desc.name = varInfo.name</span><span class="s4">;</span>
    <span class="s1">desc.value = m::runtime::makeRemoteObject(</span>
        <span class="s1">getRuntime()</span><span class="s4">, </span><span class="s1">varInfo.value</span><span class="s4">, </span><span class="s1">objTable_</span><span class="s4">, </span><span class="s1">objectGroup)</span><span class="s4">;</span>
    <span class="s1">desc.enumerable = </span><span class="s4">true;</span>

    <span class="s1">result.emplace_back(std::move(desc))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">result</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">std::vector&lt;m::runtime::PropertyDescriptor&gt;</span>
<span class="s1">Connection::Impl::makePropsFromValue(</span>
    <span class="s4">const </span><span class="s1">jsi::Value &amp;value</span><span class="s4">,</span>
    <span class="s4">const </span><span class="s1">std::string &amp;objectGroup</span><span class="s4">,</span>
    <span class="s4">bool </span><span class="s1">onlyOwnProperties) {</span>
  <span class="s1">std::vector&lt;m::runtime::PropertyDescriptor&gt; result</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(value.isObject()) {</span>
    <span class="s1">jsi::Runtime &amp;runtime = getRuntime()</span><span class="s4">;</span>
    <span class="s1">jsi::Object obj = value.getObject(runtime)</span><span class="s4">;</span>

    <span class="s0">// TODO(hypuk): obj.getPropertyNames only returns enumerable properties.</span>
    <span class="s1">jsi::Array propNames = onlyOwnProperties</span>
        <span class="s1">? runtime.global()</span>
              <span class="s1">.getPropertyAsObject(runtime</span><span class="s4">, </span><span class="s3">&quot;Object&quot;</span><span class="s1">)</span>
              <span class="s1">.getPropertyAsFunction(runtime</span><span class="s4">, </span><span class="s3">&quot;getOwnPropertyNames&quot;</span><span class="s1">)</span>
              <span class="s1">.call(runtime</span><span class="s4">, </span><span class="s1">obj)</span>
              <span class="s1">.getObject(runtime)</span>
              <span class="s1">.getArray(runtime)</span>
        <span class="s1">: obj.getPropertyNames(runtime)</span><span class="s4">;</span>

    <span class="s1">size_t propCount = propNames.length(runtime)</span><span class="s4">;</span>
    <span class="s4">for </span><span class="s1">(size_t i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; propCount</span><span class="s4">; </span><span class="s1">i++) {</span>
      <span class="s1">jsi::String propName =</span>
          <span class="s1">propNames.getValueAtIndex(runtime</span><span class="s4">, </span><span class="s1">i).getString(runtime)</span><span class="s4">;</span>

      <span class="s1">m::runtime::PropertyDescriptor desc</span><span class="s4">;</span>
      <span class="s1">desc.name = propName.utf8(runtime)</span><span class="s4">;</span>

      <span class="s4">try </span><span class="s1">{</span>
        <span class="s0">// Currently, we fetch the property even if it runs code.</span>
        <span class="s0">// Chrome instead detects getters and makes you click to invoke.</span>
        <span class="s1">jsi::Value propValue = obj.getProperty(runtime</span><span class="s4">, </span><span class="s1">propName)</span><span class="s4">;</span>
        <span class="s1">desc.value = m::runtime::makeRemoteObject(</span>
            <span class="s1">runtime</span><span class="s4">, </span><span class="s1">propValue</span><span class="s4">, </span><span class="s1">objTable_</span><span class="s4">, </span><span class="s1">objectGroup)</span><span class="s4">;</span>
      <span class="s1">} </span><span class="s4">catch </span><span class="s1">(</span><span class="s4">const </span><span class="s1">jsi::JSError &amp;err) {</span>
        <span class="s0">// We fetched a property with a getter that threw. Show a placeholder.</span>
        <span class="s0">// We could have added additional info, but the UI quickly gets messy.</span>
        <span class="s1">desc.value = m::runtime::makeRemoteObject(</span>
            <span class="s1">runtime</span><span class="s4">,</span>
            <span class="s1">jsi::String::createFromUtf8(runtime</span><span class="s4">, </span><span class="s3">&quot;(Exception)&quot;</span><span class="s1">)</span><span class="s4">,</span>
            <span class="s1">objTable_</span><span class="s4">,</span>
            <span class="s1">objectGroup)</span><span class="s4">;</span>
      <span class="s1">}</span>

      <span class="s1">result.emplace_back(std::move(desc))</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(onlyOwnProperties) {</span>
      <span class="s1">jsi::Value proto = runtime.global()</span>
                             <span class="s1">.getPropertyAsObject(runtime</span><span class="s4">, </span><span class="s3">&quot;Object&quot;</span><span class="s1">)</span>
                             <span class="s1">.getPropertyAsFunction(runtime</span><span class="s4">, </span><span class="s3">&quot;getPrototypeOf&quot;</span><span class="s1">)</span>
                             <span class="s1">.call(runtime</span><span class="s4">, </span><span class="s1">obj)</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(!proto.isNull()) {</span>
        <span class="s1">m::runtime::PropertyDescriptor desc</span><span class="s4">;</span>
        <span class="s1">desc.name = </span><span class="s3">&quot;__proto__&quot;</span><span class="s4">;</span>
        <span class="s1">desc.value = m::runtime::makeRemoteObject(</span>
            <span class="s1">runtime</span><span class="s4">, </span><span class="s1">proto</span><span class="s4">, </span><span class="s1">objTable_</span><span class="s4">, </span><span class="s1">objectGroup)</span><span class="s4">;</span>
        <span class="s1">result.emplace_back(std::move(desc))</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">result</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::runtime::GetHeapUsageRequest &amp;req) {</span>
  <span class="s1">runInExecutor(req.id</span><span class="s4">, </span><span class="s1">[</span><span class="s4">this, </span><span class="s1">req]() {</span>
    <span class="s4">auto </span><span class="s1">heapInfo = getRuntime().instrumentation().getHeapInfo(</span><span class="s4">false</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s4">auto </span><span class="s1">resp = std::make_shared&lt;m::runtime::GetHeapUsageResponse&gt;()</span><span class="s4">;</span>
    <span class="s1">resp-&gt;id = req.id</span><span class="s4">;</span>
    <span class="s1">resp-&gt;usedSize = heapInfo[</span><span class="s3">&quot;hermes_allocatedBytes&quot;</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s1">resp-&gt;totalSize = heapInfo[</span><span class="s3">&quot;hermes_heapSize&quot;</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s1">sendResponseToClient(*resp)</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span><span class="s4">const </span><span class="s1">m::runtime::GetPropertiesRequest &amp;req) {</span>
  <span class="s4">auto </span><span class="s1">resp = std::make_shared&lt;m::runtime::GetPropertiesResponse&gt;()</span><span class="s4">;</span>
  <span class="s1">resp-&gt;id = req.id</span><span class="s4">;</span>

  <span class="s1">inspector_</span>
      <span class="s1">-&gt;executeIfEnabled(</span>
          <span class="s3">&quot;Runtime.getProperties&quot;</span><span class="s4">,</span>
          <span class="s1">[</span><span class="s4">this, </span><span class="s1">req</span><span class="s4">, </span><span class="s1">resp](</span><span class="s4">const </span><span class="s1">debugger::ProgramState &amp;state) {</span>
            <span class="s1">std::string objGroup = objTable_.getObjectGroup(req.objectId)</span><span class="s4">;</span>
            <span class="s4">auto </span><span class="s1">scopePtr = objTable_.getScope(req.objectId)</span><span class="s4">;</span>
            <span class="s4">auto </span><span class="s1">valuePtr = objTable_.getValue(req.objectId)</span><span class="s4">;</span>

            <span class="s4">if </span><span class="s1">(scopePtr != </span><span class="s4">nullptr</span><span class="s1">) {</span>
              <span class="s1">resp-&gt;result = makePropsFromScope(*scopePtr</span><span class="s4">, </span><span class="s1">objGroup</span><span class="s4">, </span><span class="s1">state)</span><span class="s4">;</span>
            <span class="s1">} </span><span class="s4">else if </span><span class="s1">(valuePtr != </span><span class="s4">nullptr</span><span class="s1">) {</span>
              <span class="s1">resp-&gt;result = makePropsFromValue(</span>
                  <span class="s1">*valuePtr</span><span class="s4">, </span><span class="s1">objGroup</span><span class="s4">, </span><span class="s1">req.ownProperties.value_or(</span><span class="s4">true</span><span class="s1">))</span><span class="s4">;</span>
            <span class="s1">}</span>
          <span class="s1">})</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue([</span><span class="s4">this, </span><span class="s1">resp](</span><span class="s4">auto </span><span class="s1">&amp;&amp;) { sendResponseToClient(*resp)</span><span class="s4">; </span><span class="s1">})</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(req.id))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span>
    <span class="s4">const </span><span class="s1">m::runtime::GlobalLexicalScopeNamesRequest &amp;req) {</span>
  <span class="s4">auto </span><span class="s1">resp = std::make_shared&lt;m::runtime::GlobalLexicalScopeNamesResponse&gt;()</span><span class="s4">;</span>
  <span class="s1">resp-&gt;id = req.id</span><span class="s4">;</span>

  <span class="s1">inspector_</span>
      <span class="s1">-&gt;executeIfEnabled(</span>
          <span class="s3">&quot;Runtime.globalLexicalScopeNames&quot;</span><span class="s4">,</span>
          <span class="s1">[req</span><span class="s4">, </span><span class="s1">resp](</span><span class="s4">const </span><span class="s1">debugger::ProgramState &amp;state) {</span>
            <span class="s4">if </span><span class="s1">(req.executionContextId.has_value() &amp;&amp;</span>
                <span class="s1">req.executionContextId.value() != kHermesExecutionContextId) {</span>
              <span class="s4">throw </span><span class="s1">std::invalid_argument(</span><span class="s3">&quot;Invalid execution context&quot;</span><span class="s1">)</span><span class="s4">;</span>
            <span class="s1">}</span>

            <span class="s4">const </span><span class="s1">debugger::LexicalInfo &amp;lexicalInfo = state.getLexicalInfo(</span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
            <span class="s1">debugger::ScopeDepth scopeCount = lexicalInfo.getScopesCount()</span><span class="s4">;</span>
            <span class="s4">if </span><span class="s1">(scopeCount == </span><span class="s5">0</span><span class="s1">) {</span>
              <span class="s4">return;</span>
            <span class="s1">}</span>

            <span class="s4">const </span><span class="s1">debugger::ScopeDepth globalScopeIndex = scopeCount - </span><span class="s5">1</span><span class="s4">;</span>
            <span class="s1">uint32_t variableCount =</span>
                <span class="s1">lexicalInfo.getVariablesCountInScope(globalScopeIndex)</span><span class="s4">;</span>
            <span class="s1">resp-&gt;names.reserve(variableCount)</span><span class="s4">;</span>
            <span class="s4">for </span><span class="s1">(uint32_t i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; variableCount</span><span class="s4">; </span><span class="s1">i++) {</span>
              <span class="s1">debugger::String name =</span>
                  <span class="s1">state.getVariableInfo(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">globalScopeIndex</span><span class="s4">, </span><span class="s1">i).name</span><span class="s4">;</span>
              <span class="s0">// The global scope has some entries prefixed with '?', which are</span>
              <span class="s0">// not valid identifiers.</span>
              <span class="s4">if </span><span class="s1">(!name.empty() &amp;&amp; name.front() != </span><span class="s3">'?'</span><span class="s1">) {</span>
                <span class="s1">resp-&gt;names.push_back(name)</span><span class="s4">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">})</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue([</span><span class="s4">this, </span><span class="s1">resp](</span><span class="s4">auto </span><span class="s1">&amp;&amp;) { sendResponseToClient(*resp)</span><span class="s4">; </span><span class="s1">})</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(req.id))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::handle(</span>
    <span class="s4">const </span><span class="s1">m::runtime::RunIfWaitingForDebuggerRequest &amp;req) {</span>
  <span class="s4">if </span><span class="s1">(inspector_-&gt;isAwaitingDebuggerOnStart()) {</span>
    <span class="s1">sendResponseToClientViaExecutor(inspector_-&gt;resume()</span><span class="s4">, </span><span class="s1">req.id)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s0">// We weren't awaiting a debugger. Just send an 'ok'.</span>
    <span class="s1">sendResponseToClientViaExecutor(req.id)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/* 
 * Send-to-client methods 
 */</span>

<span class="s4">void </span><span class="s1">Connection::Impl::sendToClient(</span><span class="s4">const </span><span class="s1">std::string &amp;str) {</span>
  <span class="s4">if </span><span class="s1">(remoteConn_) {</span>
    <span class="s1">remoteConn_-&gt;onMessage(str)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::sendResponseToClient(</span><span class="s4">const </span><span class="s1">m::Response &amp;resp) {</span>
  <span class="s1">sendToClient(resp.toJson())</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::sendNotificationToClient(</span><span class="s4">const </span><span class="s1">m::Notification &amp;note) {</span>
  <span class="s1">sendToClient(note.toJson())</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">folly::Function&lt;</span><span class="s4">void</span><span class="s1">(</span><span class="s4">const </span><span class="s1">std::exception &amp;)&gt;</span>
<span class="s1">Connection::Impl::sendErrorToClient(</span><span class="s4">int </span><span class="s1">id) {</span>
  <span class="s4">return </span><span class="s1">[</span><span class="s4">this, </span><span class="s1">id](</span><span class="s4">const </span><span class="s1">std::exception &amp;e) {</span>
    <span class="s1">sendResponseToClient(</span>
        <span class="s1">m::makeErrorResponse(id</span><span class="s4">, </span><span class="s1">m::ErrorCode::ServerError</span><span class="s4">, </span><span class="s1">e.what()))</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::sendResponseToClientViaExecutor(</span><span class="s4">int </span><span class="s1">id) {</span>
  <span class="s1">sendResponseToClientViaExecutor(folly::makeFuture()</span><span class="s4">, </span><span class="s1">id)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::sendResponseToClientViaExecutor(</span>
    <span class="s4">const </span><span class="s1">m::Response &amp;resp) {</span>
  <span class="s1">std::string json = resp.toJson()</span><span class="s4">;</span>

  <span class="s1">folly::makeFuture()</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue([</span><span class="s4">this, </span><span class="s1">json](</span><span class="s4">const </span><span class="s1">Unit &amp;unit) { sendToClient(json)</span><span class="s4">; </span><span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::sendResponseToClientViaExecutor(</span>
    <span class="s1">folly::Future&lt;Unit&gt; future</span><span class="s4">,</span>
    <span class="s4">int </span><span class="s1">id) {</span>
  <span class="s1">future.via(executor_.get())</span>
      <span class="s1">.thenValue([</span><span class="s4">this, </span><span class="s1">id](</span><span class="s4">const </span><span class="s1">Unit &amp;unit) {</span>
        <span class="s1">sendResponseToClient(m::makeOkResponse(id))</span><span class="s4">;</span>
      <span class="s1">})</span>
      <span class="s1">.thenError&lt;std::exception&gt;(sendErrorToClient(id))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::sendErrorToClientViaExecutor(</span>
    <span class="s4">int </span><span class="s1">id</span><span class="s4">,</span>
    <span class="s4">const </span><span class="s1">std::string &amp;error) {</span>
  <span class="s1">folly::makeFuture()</span>
      <span class="s1">.via(executor_.get())</span>
      <span class="s1">.thenValue([</span><span class="s4">this, </span><span class="s1">id</span><span class="s4">, </span><span class="s1">error](</span><span class="s4">const </span><span class="s1">Unit &amp;unit) {</span>
        <span class="s1">sendResponseToClient(</span>
            <span class="s1">makeErrorResponse(id</span><span class="s4">, </span><span class="s1">m::ErrorCode::ServerError</span><span class="s4">, </span><span class="s1">error))</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::Impl::sendNotificationToClientViaExecutor(</span>
    <span class="s4">const </span><span class="s1">m::Notification &amp;note) {</span>
  <span class="s1">executor_-&gt;add(</span>
      <span class="s1">[</span><span class="s4">this, </span><span class="s1">noteJson = note.toJson()]() { sendToClient(noteJson)</span><span class="s4">; </span><span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/* 
 * Connection 
 */</span>
<span class="s1">Connection::Connection(</span>
    <span class="s1">std::unique_ptr&lt;RuntimeAdapter&gt; adapter</span><span class="s4">,</span>
    <span class="s4">const </span><span class="s1">std::string &amp;title</span><span class="s4">,</span>
    <span class="s4">bool </span><span class="s1">waitForDebugger)</span>
    <span class="s1">: impl_(</span>
          <span class="s1">std::make_unique&lt;Impl&gt;(std::move(adapter)</span><span class="s4">, </span><span class="s1">title</span><span class="s4">, </span><span class="s1">waitForDebugger)) {}</span>

<span class="s1">Connection::~Connection() = </span><span class="s4">default;</span>

<span class="s1">HermesRuntime &amp;Connection::getRuntime() {</span>
  <span class="s4">return </span><span class="s1">impl_-&gt;getRuntime()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">std::string Connection::getTitle() </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">return </span><span class="s1">impl_-&gt;getTitle()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">bool </span><span class="s1">Connection::connect(std::unique_ptr&lt;IRemoteConnection&gt; remoteConn) {</span>
  <span class="s4">return </span><span class="s1">impl_-&gt;connect(std::move(remoteConn))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">bool </span><span class="s1">Connection::disconnect() {</span>
  <span class="s4">return </span><span class="s1">impl_-&gt;disconnect()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Connection::sendMessage(std::string str) {</span>
  <span class="s1">impl_-&gt;sendMessage(std::move(str))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">} </span><span class="s0">// namespace chrome</span>
<span class="s1">} </span><span class="s0">// namespace inspector</span>
<span class="s1">} </span><span class="s0">// namespace hermes</span>
<span class="s1">} </span><span class="s0">// namespace facebook</span>
</pre>
</body>
</html>
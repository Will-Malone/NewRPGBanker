<html>
<head>
<title>useNavigationBuilder.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
useNavigationBuilder.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= useNavigationBuilder;</span>
<span class="s2">var </span><span class="s1">_routers = require(</span><span class="s0">&quot;@react-navigation/routers&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">React = _interopRequireWildcard(require(</span><span class="s0">&quot;react&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_reactIs = require(</span><span class="s0">&quot;react-is&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_Group = _interopRequireDefault(require(</span><span class="s0">&quot;./Group&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_isArrayEqual = _interopRequireDefault(require(</span><span class="s0">&quot;./isArrayEqual&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_isRecordEqual = _interopRequireDefault(require(</span><span class="s0">&quot;./isRecordEqual&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_NavigationHelpersContext = _interopRequireDefault(require(</span><span class="s0">&quot;./NavigationHelpersContext&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_NavigationRouteContext = _interopRequireDefault(require(</span><span class="s0">&quot;./NavigationRouteContext&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_NavigationStateContext = _interopRequireDefault(require(</span><span class="s0">&quot;./NavigationStateContext&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_PreventRemoveProvider = _interopRequireDefault(require(</span><span class="s0">&quot;./PreventRemoveProvider&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_Screen = _interopRequireDefault(require(</span><span class="s0">&quot;./Screen&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_types = require(</span><span class="s0">&quot;./types&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_useChildListeners = _interopRequireDefault(require(</span><span class="s0">&quot;./useChildListeners&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_useComponent = _interopRequireDefault(require(</span><span class="s0">&quot;./useComponent&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_useCurrentRender = _interopRequireDefault(require(</span><span class="s0">&quot;./useCurrentRender&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_useDescriptors = _interopRequireDefault(require(</span><span class="s0">&quot;./useDescriptors&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_useEventEmitter = _interopRequireDefault(require(</span><span class="s0">&quot;./useEventEmitter&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_useFocusedListenersChildrenAdapter = _interopRequireDefault(require(</span><span class="s0">&quot;./useFocusedListenersChildrenAdapter&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_useFocusEvents = _interopRequireDefault(require(</span><span class="s0">&quot;./useFocusEvents&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_useKeyedChildListeners = _interopRequireDefault(require(</span><span class="s0">&quot;./useKeyedChildListeners&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_useNavigationHelpers = _interopRequireDefault(require(</span><span class="s0">&quot;./useNavigationHelpers&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_useOnAction = _interopRequireDefault(require(</span><span class="s0">&quot;./useOnAction&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_useOnGetState = _interopRequireDefault(require(</span><span class="s0">&quot;./useOnGetState&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_useOnRouteFocus = _interopRequireDefault(require(</span><span class="s0">&quot;./useOnRouteFocus&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_useRegisterNavigator = _interopRequireDefault(require(</span><span class="s0">&quot;./useRegisterNavigator&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_useScheduleUpdate = _interopRequireDefault(require(</span><span class="s0">&quot;./useScheduleUpdate&quot;</span><span class="s1">));</span>
<span class="s2">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">default</span><span class="s1">: obj }; }</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) { </span><span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">; </span><span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap(); </span><span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap(); </span><span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function </span><span class="s1">(nodeInterop) { </span><span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }</span>
<span class="s2">function </span><span class="s1">_interopRequireWildcard(obj, nodeInterop) { </span><span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) { </span><span class="s2">return </span><span class="s1">obj; } </span><span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">{ </span><span class="s2">default</span><span class="s1">: obj }; } </span><span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop); </span><span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) { </span><span class="s2">return </span><span class="s1">cache.get(obj); } </span><span class="s2">var </span><span class="s1">newObj = {}; </span><span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor; </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj) { </span><span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) { </span><span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">; </span><span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } </span><span class="s2">else </span><span class="s1">{ newObj[key] = obj[key]; } } } newObj.</span><span class="s2">default </span><span class="s1">= obj; </span><span class="s2">if </span><span class="s1">(cache) { cache.set(obj, newObj); } </span><span class="s2">return </span><span class="s1">newObj; }</span>
<span class="s3">// This is to make TypeScript compiler happy</span>
<span class="s3">// eslint-disable-next-line babel/no-unused-expressions</span>
<span class="s1">_types.PrivateValueStore;</span>
<span class="s1">const isValidKey = key =&gt; key === undefined || </span><span class="s2">typeof </span><span class="s1">key === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; key !== </span><span class="s0">''</span><span class="s1">;</span>

<span class="s3">/** 
 * Extract route config object from React children elements. 
 * 
 * @param children React Elements to extract the config from. 
 */</span>
<span class="s1">const getRouteConfigsFromChildren = (children, groupKey, groupOptions) =&gt; {</span>
  <span class="s1">const configs = React.Children.toArray(children).reduce((acc, child) =&gt; {</span>
    <span class="s2">var </span><span class="s1">_child$type, _child$props;</span>
    <span class="s2">if </span><span class="s1">( </span><span class="s3">/*#__PURE__*/</span><span class="s1">React.isValidElement(child)) {</span>
      <span class="s2">if </span><span class="s1">(child.type === _Screen.</span><span class="s2">default</span><span class="s1">) {</span>
        <span class="s3">// We can only extract the config from `Screen` elements</span>
        <span class="s3">// If something else was rendered, it's probably a bug</span>

        <span class="s2">if </span><span class="s1">(!isValidKey(child.props.navigationKey)) {</span>
          <span class="s2">throw new </span><span class="s1">Error(`Got an invalid </span><span class="s0">'navigationKey' </span><span class="s1">prop (${JSON.stringify(child.props.navigationKey)}) </span><span class="s2">for </span><span class="s1">the screen </span><span class="s0">'${child.props.name}'</span><span class="s1">. It must be a non-empty string or </span><span class="s0">'undefined'</span><span class="s1">.`);</span>
        <span class="s1">}</span>
        <span class="s1">acc.push({</span>
          <span class="s1">keys: [groupKey, child.props.navigationKey],</span>
          <span class="s1">options: groupOptions,</span>
          <span class="s1">props: child.props</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">acc;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(child.type === React.Fragment || child.type === _Group.</span><span class="s2">default</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(!isValidKey(child.props.navigationKey)) {</span>
          <span class="s2">throw new </span><span class="s1">Error(`Got an invalid </span><span class="s0">'navigationKey' </span><span class="s1">prop (${JSON.stringify(child.props.navigationKey)}) </span><span class="s2">for </span><span class="s1">the group. It must be a non-empty string or </span><span class="s0">'undefined'</span><span class="s1">.`);</span>
        <span class="s1">}</span>

        <span class="s3">// When we encounter a fragment or group, we need to dive into its children to extract the configs</span>
        <span class="s3">// This is handy to conditionally define a group of screens</span>
        <span class="s1">acc.push(...getRouteConfigsFromChildren(child.props.children, child.props.navigationKey, child.type !== _Group.</span><span class="s2">default </span><span class="s1">? groupOptions : groupOptions != </span><span class="s2">null </span><span class="s1">? [...groupOptions, child.props.screenOptions] : [child.props.screenOptions]));</span>
        <span class="s2">return </span><span class="s1">acc;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">throw new </span><span class="s1">Error(`A navigator can only contain </span><span class="s0">'Screen'</span><span class="s1">, </span><span class="s0">'Group' </span><span class="s1">or </span><span class="s0">'React.Fragment' </span><span class="s1">as its direct children (found ${</span><span class="s3">/*#__PURE__*/</span><span class="s1">React.isValidElement(child) ? `</span><span class="s0">'${typeof child.type === '</span><span class="s1">string</span><span class="s0">' ? child.type : (_child$type = child.type) === null || _child$type === void 0 ? void 0 : _child$type.name}'</span><span class="s1">${child.props != </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">child.props === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; </span><span class="s0">'name' </span><span class="s2">in </span><span class="s1">child.props &amp;&amp; (_child$props = child.props) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _child$props !== </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">&amp;&amp; _child$props.name ? ` </span><span class="s2">for </span><span class="s1">the screen </span><span class="s0">'${child.props.name}'</span><span class="s1">` : </span><span class="s0">''</span><span class="s1">}` : </span><span class="s2">typeof </span><span class="s1">child === </span><span class="s0">'object' </span><span class="s1">? JSON.stringify(child) : `</span><span class="s0">'${String(child)}'</span><span class="s1">`}). To render </span><span class="s2">this </span><span class="s1">component </span><span class="s2">in </span><span class="s1">the navigator, pass it </span><span class="s2">in </span><span class="s1">the </span><span class="s0">'component' </span><span class="s1">prop to </span><span class="s0">'Screen'</span><span class="s1">.`);</span>
  <span class="s1">}, []);</span>
  <span class="s2">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s0">'production'</span><span class="s1">) {</span>
    <span class="s1">configs.forEach(config =&gt; {</span>
      <span class="s1">const {</span>
        <span class="s1">name,</span>
        <span class="s1">children,</span>
        <span class="s1">component,</span>
        <span class="s1">getComponent</span>
      <span class="s1">} = config.props;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">name !== </span><span class="s0">'string' </span><span class="s1">|| !name) {</span>
        <span class="s2">throw new </span><span class="s1">Error(`Got an invalid name (${JSON.stringify(name)}) </span><span class="s2">for </span><span class="s1">the screen. It must be a non-empty string.`);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(children != </span><span class="s2">null </span><span class="s1">|| component !== undefined || getComponent !== undefined) {</span>
        <span class="s2">if </span><span class="s1">(children != </span><span class="s2">null </span><span class="s1">&amp;&amp; component !== undefined) {</span>
          <span class="s2">throw new </span><span class="s1">Error(`Got both </span><span class="s0">'component' </span><span class="s1">and </span><span class="s0">'children' </span><span class="s1">props </span><span class="s2">for </span><span class="s1">the screen </span><span class="s0">'${name}'</span><span class="s1">. You must pass only one of them.`);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(children != </span><span class="s2">null </span><span class="s1">&amp;&amp; getComponent !== undefined) {</span>
          <span class="s2">throw new </span><span class="s1">Error(`Got both </span><span class="s0">'getComponent' </span><span class="s1">and </span><span class="s0">'children' </span><span class="s1">props </span><span class="s2">for </span><span class="s1">the screen </span><span class="s0">'${name}'</span><span class="s1">. You must pass only one of them.`);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(component !== undefined &amp;&amp; getComponent !== undefined) {</span>
          <span class="s2">throw new </span><span class="s1">Error(`Got both </span><span class="s0">'component' </span><span class="s1">and </span><span class="s0">'getComponent' </span><span class="s1">props </span><span class="s2">for </span><span class="s1">the screen </span><span class="s0">'${name}'</span><span class="s1">. You must pass only one of them.`);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(children != </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">children !== </span><span class="s0">'function'</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">Error(`Got an invalid value </span><span class="s2">for </span><span class="s0">'children' </span><span class="s1">prop </span><span class="s2">for </span><span class="s1">the screen </span><span class="s0">'${name}'</span><span class="s1">. It must be a </span><span class="s2">function </span><span class="s1">returning a React Element.`);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(component !== undefined &amp;&amp; !(</span><span class="s4">0</span><span class="s1">, _reactIs.isValidElementType)(component)) {</span>
          <span class="s2">throw new </span><span class="s1">Error(`Got an invalid value </span><span class="s2">for </span><span class="s0">'component' </span><span class="s1">prop </span><span class="s2">for </span><span class="s1">the screen </span><span class="s0">'${name}'</span><span class="s1">. It must be a valid React Component.`);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(getComponent !== undefined &amp;&amp; </span><span class="s2">typeof </span><span class="s1">getComponent !== </span><span class="s0">'function'</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">Error(`Got an invalid value </span><span class="s2">for </span><span class="s0">'getComponent' </span><span class="s1">prop </span><span class="s2">for </span><span class="s1">the screen </span><span class="s0">'${name}'</span><span class="s1">. It must be a </span><span class="s2">function </span><span class="s1">returning a React Component.`);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">component === </span><span class="s0">'function'</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(component.name === </span><span class="s0">'component'</span><span class="s1">) {</span>
            <span class="s3">// Inline anonymous functions passed in the `component` prop will have the name of the prop</span>
            <span class="s3">// It's relatively safe to assume that it's not a component since it should also have PascalCase name</span>
            <span class="s3">// We won't catch all scenarios here, but this should catch a good chunk of incorrect use.</span>
            <span class="s1">console.warn(`Looks like you</span><span class="s0">'re passing an inline function for '</span><span class="s1">component</span><span class="s0">' prop for the screen '</span><span class="s1">${name}</span><span class="s0">' (e.g. component={() =&gt; &lt;SomeComponent /&gt;}). Passing an inline function will cause the component state to be lost on re-render and cause perf issues since it'</span><span class="s1">s re-created every render. You can pass the </span><span class="s2">function </span><span class="s1">as children to </span><span class="s0">'Screen' </span><span class="s1">instead to achieve the desired behaviour.`);</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(/^[a-z]/.test(component.name)) {</span>
            <span class="s1">console.warn(`Got a component </span><span class="s2">with </span><span class="s1">the name </span><span class="s0">'${component.name}' </span><span class="s2">for </span><span class="s1">the screen </span><span class="s0">'${name}'</span><span class="s1">. React Components must start </span><span class="s2">with </span><span class="s1">an uppercase letter. If you</span><span class="s0">'re passing a regular function and not a component, pass it as children to '</span><span class="s1">Screen</span><span class="s0">' instead. Otherwise capitalize your component'</span><span class="s1">s name.`);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">throw new </span><span class="s1">Error(`Couldn</span><span class="s0">'t find a '</span><span class="s1">component</span><span class="s0">', '</span><span class="s1">getComponent</span><span class="s0">' or '</span><span class="s1">children</span><span class="s0">' prop for the screen '</span><span class="s1">${name}</span><span class="s0">'. This can happen if you passed '</span><span class="s1">undefined</span><span class="s0">'. You likely forgot to export your component from the file it'</span><span class="s1">s defined </span><span class="s2">in</span><span class="s1">, or mixed up </span><span class="s2">default </span><span class="s1">import and named import when importing.`);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">configs;</span>
<span class="s1">};</span>

<span class="s3">/** 
 * Hook for building navigators. 
 * 
 * @param createRouter Factory method which returns router object. 
 * @param options Options object containing `children` and additional options for the router. 
 * @returns An object containing `state`, `navigation`, `descriptors` objects. 
 */</span>
<span class="s2">function </span><span class="s1">useNavigationBuilder(createRouter, options) {</span>
  <span class="s1">const navigatorKey = (</span><span class="s4">0</span><span class="s1">, _useRegisterNavigator.</span><span class="s2">default</span><span class="s1">)();</span>
  <span class="s1">const route = React.useContext(_NavigationRouteContext.</span><span class="s2">default</span><span class="s1">);</span>
  <span class="s1">const {</span>
    <span class="s1">children,</span>
    <span class="s1">screenListeners,</span>
    <span class="s1">...rest</span>
  <span class="s1">} = options;</span>
  <span class="s1">const {</span>
    <span class="s1">current: router</span>
  <span class="s1">} = React.useRef(createRouter({</span>
    <span class="s1">...rest,</span>
    <span class="s1">...(route !== </span><span class="s2">null </span><span class="s1">&amp;&amp; route !== </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">&amp;&amp; route.params &amp;&amp; route.params.state == </span><span class="s2">null </span><span class="s1">&amp;&amp; route.params.initial !== </span><span class="s2">false </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">route.params.screen === </span><span class="s0">'string' </span><span class="s1">? {</span>
      <span class="s1">initialRouteName: route.params.screen</span>
    <span class="s1">} : </span><span class="s2">null</span><span class="s1">)</span>
  <span class="s1">}));</span>
  <span class="s1">const routeConfigs = getRouteConfigsFromChildren(children);</span>
  <span class="s1">const screens = routeConfigs.reduce((acc, config) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(config.props.name </span><span class="s2">in </span><span class="s1">acc) {</span>
      <span class="s2">throw new </span><span class="s1">Error(`A navigator cannot contain multiple </span><span class="s0">'Screen' </span><span class="s1">components </span><span class="s2">with </span><span class="s1">the same name (found duplicate screen named </span><span class="s0">'${config.props.name}'</span><span class="s1">)`);</span>
    <span class="s1">}</span>
    <span class="s1">acc[config.props.name] = config;</span>
    <span class="s2">return </span><span class="s1">acc;</span>
  <span class="s1">}, {});</span>
  <span class="s1">const routeNames = routeConfigs.map(config =&gt; config.props.name);</span>
  <span class="s1">const routeKeyList = routeNames.reduce((acc, curr) =&gt; {</span>
    <span class="s1">acc[curr] = screens[curr].keys.map(key =&gt; key ?? </span><span class="s0">''</span><span class="s1">).join(</span><span class="s0">':'</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">acc;</span>
  <span class="s1">}, {});</span>
  <span class="s1">const routeParamList = routeNames.reduce((acc, curr) =&gt; {</span>
    <span class="s1">const {</span>
      <span class="s1">initialParams</span>
    <span class="s1">} = screens[curr].props;</span>
    <span class="s1">acc[curr] = initialParams;</span>
    <span class="s2">return </span><span class="s1">acc;</span>
  <span class="s1">}, {});</span>
  <span class="s1">const routeGetIdList = routeNames.reduce((acc, curr) =&gt; Object.assign(acc, {</span>
    <span class="s1">[curr]: screens[curr].props.getId</span>
  <span class="s1">}), {});</span>
  <span class="s2">if </span><span class="s1">(!routeNames.length) {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;Couldn't find any screens for the navigator. Have you defined any screens as its children?&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">const isStateValid = React.useCallback(state =&gt; state.type === undefined || state.type === router.type, [router.type]);</span>
  <span class="s1">const isStateInitialized = React.useCallback(state =&gt; state !== undefined &amp;&amp; state.stale === </span><span class="s2">false </span><span class="s1">&amp;&amp; isStateValid(state), [isStateValid]);</span>
  <span class="s1">const {</span>
    <span class="s1">state: currentState,</span>
    <span class="s1">getState: getCurrentState,</span>
    <span class="s1">setState: setCurrentState,</span>
    <span class="s1">setKey,</span>
    <span class="s1">getKey,</span>
    <span class="s1">getIsInitial</span>
  <span class="s1">} = React.useContext(_NavigationStateContext.</span><span class="s2">default</span><span class="s1">);</span>
  <span class="s1">const stateCleanedUp = React.useRef(</span><span class="s2">false</span><span class="s1">);</span>
  <span class="s1">const cleanUpState = React.useCallback(() =&gt; {</span>
    <span class="s1">setCurrentState(undefined);</span>
    <span class="s1">stateCleanedUp.current = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s1">}, [setCurrentState]);</span>
  <span class="s1">const setState = React.useCallback(state =&gt; {</span>
    <span class="s2">if </span><span class="s1">(stateCleanedUp.current) {</span>
      <span class="s3">// State might have been already cleaned up due to unmount</span>
      <span class="s3">// We do not want to expose API allowing to override this</span>
      <span class="s3">// This would lead to old data preservation on main navigator unmount</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">setCurrentState(state);</span>
  <span class="s1">}, [setCurrentState]);</span>
  <span class="s1">const [initializedState, isFirstStateInitialization] = React.useMemo(() =&gt; {</span>
    <span class="s2">var </span><span class="s1">_route$params4;</span>
    <span class="s1">const initialRouteParamList = routeNames.reduce((acc, curr) =&gt; {</span>
      <span class="s2">var </span><span class="s1">_route$params, _route$params2, _route$params3;</span>
      <span class="s1">const {</span>
        <span class="s1">initialParams</span>
      <span class="s1">} = screens[curr].props;</span>
      <span class="s1">const initialParamsFromParams = (route === </span><span class="s2">null </span><span class="s1">|| route === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: (_route$params = route.params) === </span><span class="s2">null </span><span class="s1">|| _route$params === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _route$params.state) == </span><span class="s2">null </span><span class="s1">&amp;&amp; (route === </span><span class="s2">null </span><span class="s1">|| route === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: (_route$params2 = route.params) === </span><span class="s2">null </span><span class="s1">|| _route$params2 === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _route$params2.initial) !== </span><span class="s2">false </span><span class="s1">&amp;&amp; (route === </span><span class="s2">null </span><span class="s1">|| route === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: (_route$params3 = route.params) === </span><span class="s2">null </span><span class="s1">|| _route$params3 === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _route$params3.screen) === curr ? route.params.params : undefined;</span>
      <span class="s1">acc[curr] = initialParams !== undefined || initialParamsFromParams !== undefined ? {</span>
        <span class="s1">...initialParams,</span>
        <span class="s1">...initialParamsFromParams</span>
      <span class="s1">} : undefined;</span>
      <span class="s2">return </span><span class="s1">acc;</span>
    <span class="s1">}, {});</span>

    <span class="s3">// If the current state isn't initialized on first render, we initialize it</span>
    <span class="s3">// We also need to re-initialize it if the state passed from parent was changed (maybe due to reset)</span>
    <span class="s3">// Otherwise assume that the state was provided as initial state</span>
    <span class="s3">// So we need to rehydrate it to make it usable</span>
    <span class="s2">if </span><span class="s1">((currentState === undefined || !isStateValid(currentState)) &amp;&amp; (route === </span><span class="s2">null </span><span class="s1">|| route === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: (_route$params4 = route.params) === </span><span class="s2">null </span><span class="s1">|| _route$params4 === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _route$params4.state) == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">[router.getInitialState({</span>
        <span class="s1">routeNames,</span>
        <span class="s1">routeParamList: initialRouteParamList,</span>
        <span class="s1">routeGetIdList</span>
      <span class="s1">}), </span><span class="s2">true</span><span class="s1">];</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">_route$params5;</span>
      <span class="s2">return </span><span class="s1">[router.getRehydratedState((route === </span><span class="s2">null </span><span class="s1">|| route === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: (_route$params5 = route.params) === </span><span class="s2">null </span><span class="s1">|| _route$params5 === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _route$params5.state) ?? currentState, {</span>
        <span class="s1">routeNames,</span>
        <span class="s1">routeParamList: initialRouteParamList,</span>
        <span class="s1">routeGetIdList</span>
      <span class="s1">}), </span><span class="s2">false</span><span class="s1">];</span>
    <span class="s1">}</span>
    <span class="s3">// We explicitly don't include routeNames, route.params etc. in the dep list</span>
    <span class="s3">// below. We want to avoid forcing a new state to be calculated in those cases</span>
    <span class="s3">// Instead, we handle changes to these in the nextState code below. Note</span>
    <span class="s3">// that some changes to routeConfigs are explicitly ignored, such as changes</span>
    <span class="s3">// to initialParams</span>
    <span class="s3">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  <span class="s1">}, [currentState, router, isStateValid]);</span>
  <span class="s1">const previousRouteKeyListRef = React.useRef(routeKeyList);</span>
  <span class="s1">React.useEffect(() =&gt; {</span>
    <span class="s1">previousRouteKeyListRef.current = routeKeyList;</span>
  <span class="s1">});</span>
  <span class="s1">const previousRouteKeyList = previousRouteKeyListRef.current;</span>
  <span class="s1">let state =</span>
  <span class="s3">// If the state isn't initialized, or stale, use the state we initialized instead</span>
  <span class="s3">// The state won't update until there's a change needed in the state we have initalized locally</span>
  <span class="s3">// So it'll be `undefined` or stale until the first navigation event happens</span>
  <span class="s1">isStateInitialized(currentState) ? currentState : initializedState;</span>
  <span class="s1">let nextState = state;</span>
  <span class="s2">if </span><span class="s1">(!(</span><span class="s4">0</span><span class="s1">, _isArrayEqual.</span><span class="s2">default</span><span class="s1">)(state.routeNames, routeNames) || !(</span><span class="s4">0</span><span class="s1">, _isRecordEqual.</span><span class="s2">default</span><span class="s1">)(routeKeyList, previousRouteKeyList)) {</span>
    <span class="s3">// When the list of route names change, the router should handle it to remove invalid routes</span>
    <span class="s1">nextState = router.getStateForRouteNamesChange(state, {</span>
      <span class="s1">routeNames,</span>
      <span class="s1">routeParamList,</span>
      <span class="s1">routeGetIdList,</span>
      <span class="s1">routeKeyChanges: Object.keys(routeKeyList).filter(name =&gt; previousRouteKeyList.hasOwnProperty(name) &amp;&amp; routeKeyList[name] !== previousRouteKeyList[name])</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
  <span class="s1">const previousNestedParamsRef = React.useRef(route === </span><span class="s2">null </span><span class="s1">|| route === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: route.params);</span>
  <span class="s1">React.useEffect(() =&gt; {</span>
    <span class="s1">previousNestedParamsRef.current = route === </span><span class="s2">null </span><span class="s1">|| route === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: route.params;</span>
  <span class="s1">}, [route === </span><span class="s2">null </span><span class="s1">|| route === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: route.params]);</span>
  <span class="s2">if </span><span class="s1">(route !== </span><span class="s2">null </span><span class="s1">&amp;&amp; route !== </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">&amp;&amp; route.params) {</span>
    <span class="s1">const previousParams = previousNestedParamsRef.current;</span>
    <span class="s1">let action;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">route.params.state === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; route.params.state != </span><span class="s2">null </span><span class="s1">&amp;&amp; route.params !== previousParams) {</span>
      <span class="s3">// If the route was updated with new state, we should reset to it</span>
      <span class="s1">action = _routers.CommonActions.reset(route.params.state);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">route.params.screen === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; (route.params.initial === </span><span class="s2">false </span><span class="s1">&amp;&amp; isFirstStateInitialization || route.params !== previousParams)) {</span>
      <span class="s3">// If the route was updated with new screen name and/or params, we should navigate there</span>
      <span class="s1">action = _routers.CommonActions.navigate({</span>
        <span class="s1">name: route.params.screen,</span>
        <span class="s1">params: route.params.params,</span>
        <span class="s1">path: route.params.path</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">// The update should be limited to current navigator only, so we call the router manually</span>
    <span class="s1">const updatedState = action ? router.getStateForAction(nextState, action, {</span>
      <span class="s1">routeNames,</span>
      <span class="s1">routeParamList,</span>
      <span class="s1">routeGetIdList</span>
    <span class="s1">}) : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">nextState = updatedState !== </span><span class="s2">null </span><span class="s1">? router.getRehydratedState(updatedState, {</span>
      <span class="s1">routeNames,</span>
      <span class="s1">routeParamList,</span>
      <span class="s1">routeGetIdList</span>
    <span class="s1">}) : nextState;</span>
  <span class="s1">}</span>
  <span class="s1">const shouldUpdate = state !== nextState;</span>
  <span class="s1">(</span><span class="s4">0</span><span class="s1">, _useScheduleUpdate.</span><span class="s2">default</span><span class="s1">)(() =&gt; {</span>
    <span class="s2">if </span><span class="s1">(shouldUpdate) {</span>
      <span class="s3">// If the state needs to be updated, we'll schedule an update</span>
      <span class="s1">setState(nextState);</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s3">// The up-to-date state will come in next render, but we don't need to wait for it</span>
  <span class="s3">// We can't use the outdated state since the screens have changed, which will cause error due to mismatched config</span>
  <span class="s3">// So we override the state object we return to use the latest state as soon as possible</span>
  <span class="s1">state = nextState;</span>
  <span class="s1">React.useEffect(() =&gt; {</span>
    <span class="s1">setKey(navigatorKey);</span>
    <span class="s2">if </span><span class="s1">(!getIsInitial()) {</span>
      <span class="s3">// If it's not initial render, we need to update the state</span>
      <span class="s3">// This will make sure that our container gets notifier of state changes due to new mounts</span>
      <span class="s3">// This is necessary for proper screen tracking, URL updates etc.</span>
      <span class="s1">setState(nextState);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">() =&gt; {</span>
      <span class="s3">// We need to clean up state for this navigator on unmount</span>
      <span class="s3">// We do it in a timeout because we need to detect if another navigator mounted in the meantime</span>
      <span class="s3">// For example, if another navigator has started rendering, we should skip cleanup</span>
      <span class="s3">// Otherwise, our cleanup step will cleanup state for the other navigator and re-initialize it</span>
      <span class="s1">setTimeout(() =&gt; {</span>
        <span class="s2">if </span><span class="s1">(getCurrentState() !== undefined &amp;&amp; getKey() === navigatorKey) {</span>
          <span class="s1">cleanUpState();</span>
        <span class="s1">}</span>
      <span class="s1">}, </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">};</span>
    <span class="s3">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  <span class="s1">}, []);</span>

  <span class="s3">// We initialize this ref here to avoid a new getState getting initialized</span>
  <span class="s3">// whenever initializedState changes. We want getState to have access to the</span>
  <span class="s3">// latest initializedState, but don't need it to change when that happens</span>
  <span class="s1">const initializedStateRef = React.useRef();</span>
  <span class="s1">initializedStateRef.current = initializedState;</span>
  <span class="s1">const getState = React.useCallback(() =&gt; {</span>
    <span class="s1">const currentState = getCurrentState();</span>
    <span class="s2">return </span><span class="s1">isStateInitialized(currentState) ? currentState : initializedStateRef.current;</span>
  <span class="s1">}, [getCurrentState, isStateInitialized]);</span>
  <span class="s1">const emitter = (</span><span class="s4">0</span><span class="s1">, _useEventEmitter.</span><span class="s2">default</span><span class="s1">)(e =&gt; {</span>
    <span class="s1">let routeNames = [];</span>
    <span class="s1">let route;</span>
    <span class="s2">if </span><span class="s1">(e.target) {</span>
      <span class="s2">var </span><span class="s1">_route;</span>
      <span class="s1">route = state.routes.find(route =&gt; route.key === e.target);</span>
      <span class="s2">if </span><span class="s1">((_route = route) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _route !== </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">&amp;&amp; _route.name) {</span>
        <span class="s1">routeNames.push(route.name);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">route = state.routes[state.index];</span>
      <span class="s1">routeNames.push(...Object.keys(screens).filter(name =&gt; {</span>
        <span class="s2">var </span><span class="s1">_route2;</span>
        <span class="s2">return </span><span class="s1">((_route2 = route) === </span><span class="s2">null </span><span class="s1">|| _route2 === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _route2.name) === name;</span>
      <span class="s1">}));</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(route == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const navigation = descriptors[route.key].navigation;</span>
    <span class="s1">const listeners = [].concat(</span>
    <span class="s3">// Get an array of listeners for all screens + common listeners on navigator</span>
    <span class="s1">...[screenListeners, ...routeNames.map(name =&gt; {</span>
      <span class="s1">const {</span>
        <span class="s1">listeners</span>
      <span class="s1">} = screens[name].props;</span>
      <span class="s2">return </span><span class="s1">listeners;</span>
    <span class="s1">})].map(listeners =&gt; {</span>
      <span class="s1">const map = </span><span class="s2">typeof </span><span class="s1">listeners === </span><span class="s0">'function' </span><span class="s1">? listeners({</span>
        <span class="s1">route: route,</span>
        <span class="s1">navigation</span>
      <span class="s1">}) : listeners;</span>
      <span class="s2">return </span><span class="s1">map ? Object.keys(map).filter(type =&gt; type === e.type).map(type =&gt; map === </span><span class="s2">null </span><span class="s1">|| map === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: map[type]) : undefined;</span>
    <span class="s1">}))</span>
    <span class="s3">// We don't want same listener to be called multiple times for same event</span>
    <span class="s3">// So we remove any duplicate functions from the array</span>
    <span class="s1">.filter((cb, i, self) =&gt; cb &amp;&amp; self.lastIndexOf(cb) === i);</span>
    <span class="s1">listeners.forEach(listener =&gt; listener === </span><span class="s2">null </span><span class="s1">|| listener === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: listener(e));</span>
  <span class="s1">});</span>
  <span class="s1">(</span><span class="s4">0</span><span class="s1">, _useFocusEvents.</span><span class="s2">default</span><span class="s1">)({</span>
    <span class="s1">state,</span>
    <span class="s1">emitter</span>
  <span class="s1">});</span>
  <span class="s1">React.useEffect(() =&gt; {</span>
    <span class="s1">emitter.emit({</span>
      <span class="s1">type: </span><span class="s0">'state'</span><span class="s1">,</span>
      <span class="s1">data: {</span>
        <span class="s1">state</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s1">}, [emitter, state]);</span>
  <span class="s1">const {</span>
    <span class="s1">listeners: childListeners,</span>
    <span class="s1">addListener</span>
  <span class="s1">} = (</span><span class="s4">0</span><span class="s1">, _useChildListeners.</span><span class="s2">default</span><span class="s1">)();</span>
  <span class="s1">const {</span>
    <span class="s1">keyedListeners,</span>
    <span class="s1">addKeyedListener</span>
  <span class="s1">} = (</span><span class="s4">0</span><span class="s1">, _useKeyedChildListeners.</span><span class="s2">default</span><span class="s1">)();</span>
  <span class="s1">const onAction = (</span><span class="s4">0</span><span class="s1">, _useOnAction.</span><span class="s2">default</span><span class="s1">)({</span>
    <span class="s1">router,</span>
    <span class="s1">getState,</span>
    <span class="s1">setState,</span>
    <span class="s1">key: route === </span><span class="s2">null </span><span class="s1">|| route === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: route.key,</span>
    <span class="s1">actionListeners: childListeners.action,</span>
    <span class="s1">beforeRemoveListeners: keyedListeners.beforeRemove,</span>
    <span class="s1">routerConfigOptions: {</span>
      <span class="s1">routeNames,</span>
      <span class="s1">routeParamList,</span>
      <span class="s1">routeGetIdList</span>
    <span class="s1">},</span>
    <span class="s1">emitter</span>
  <span class="s1">});</span>
  <span class="s1">const onRouteFocus = (</span><span class="s4">0</span><span class="s1">, _useOnRouteFocus.</span><span class="s2">default</span><span class="s1">)({</span>
    <span class="s1">router,</span>
    <span class="s1">key: route === </span><span class="s2">null </span><span class="s1">|| route === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: route.key,</span>
    <span class="s1">getState,</span>
    <span class="s1">setState</span>
  <span class="s1">});</span>
  <span class="s1">const navigation = (</span><span class="s4">0</span><span class="s1">, _useNavigationHelpers.</span><span class="s2">default</span><span class="s1">)({</span>
    <span class="s1">id: options.id,</span>
    <span class="s1">onAction,</span>
    <span class="s1">getState,</span>
    <span class="s1">emitter,</span>
    <span class="s1">router</span>
  <span class="s1">});</span>
  <span class="s1">(</span><span class="s4">0</span><span class="s1">, _useFocusedListenersChildrenAdapter.</span><span class="s2">default</span><span class="s1">)({</span>
    <span class="s1">navigation,</span>
    <span class="s1">focusedListeners: childListeners.focus</span>
  <span class="s1">});</span>
  <span class="s1">(</span><span class="s4">0</span><span class="s1">, _useOnGetState.</span><span class="s2">default</span><span class="s1">)({</span>
    <span class="s1">getState,</span>
    <span class="s1">getStateListeners: keyedListeners.getState</span>
  <span class="s1">});</span>
  <span class="s1">const descriptors = (</span><span class="s4">0</span><span class="s1">, _useDescriptors.</span><span class="s2">default</span><span class="s1">)({</span>
    <span class="s1">state,</span>
    <span class="s1">screens,</span>
    <span class="s1">navigation,</span>
    <span class="s1">screenOptions: options.screenOptions,</span>
    <span class="s1">defaultScreenOptions: options.defaultScreenOptions,</span>
    <span class="s1">onAction,</span>
    <span class="s1">getState,</span>
    <span class="s1">setState,</span>
    <span class="s1">onRouteFocus,</span>
    <span class="s1">addListener,</span>
    <span class="s1">addKeyedListener,</span>
    <span class="s1">router,</span>
    <span class="s3">// @ts-expect-error: this should have both core and custom events, but too much work right now</span>
    <span class="s1">emitter</span>
  <span class="s1">});</span>
  <span class="s1">(</span><span class="s4">0</span><span class="s1">, _useCurrentRender.</span><span class="s2">default</span><span class="s1">)({</span>
    <span class="s1">state,</span>
    <span class="s1">navigation,</span>
    <span class="s1">descriptors</span>
  <span class="s1">});</span>
  <span class="s1">const NavigationContent = (</span><span class="s4">0</span><span class="s1">, _useComponent.</span><span class="s2">default</span><span class="s1">)(children =&gt; </span><span class="s3">/*#__PURE__*/</span><span class="s1">React.createElement(_NavigationHelpersContext.</span><span class="s2">default</span><span class="s1">.Provider, {</span>
    <span class="s1">value: navigation</span>
  <span class="s1">}, </span><span class="s3">/*#__PURE__*/</span><span class="s1">React.createElement(_PreventRemoveProvider.</span><span class="s2">default</span><span class="s1">, </span><span class="s2">null</span><span class="s1">, children)));</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">state,</span>
    <span class="s1">navigation,</span>
    <span class="s1">descriptors,</span>
    <span class="s1">NavigationContent</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">//# sourceMappingURL=useNavigationBuilder.js.map</span></pre>
</body>
</html>
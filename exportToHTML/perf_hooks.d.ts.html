<html>
<head>
<title>perf_hooks.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #cc7832;}
.s2 { color: #a9b7c6;}
.s3 { color: #a9b7c6;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb; font-style: italic;}
.s6 { color: #9876aa; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
perf_hooks.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* This module provides an implementation of a subset of the W3C [Web Performance APIs](https://w3c.github.io/perf-timing-primer/) as well as additional APIs for 
 * Node.js-specific performance measurements. 
 * 
 * Node.js supports the following [Web Performance APIs](https://w3c.github.io/perf-timing-primer/): 
 * 
 * * [High Resolution Time](https://www.w3.org/TR/hr-time-2) 
 * * [Performance Timeline](https://w3c.github.io/performance-timeline/) 
 * * [User Timing](https://www.w3.org/TR/user-timing/) 
 * * [Resource Timing](https://www.w3.org/TR/resource-timing-2/) 
 * 
 * ```js 
 * const { PerformanceObserver, performance } = require('node:perf_hooks'); 
 * 
 * const obs = new PerformanceObserver((items) =&gt; { 
 *   console.log(items.getEntries()[0].duration); 
 *   performance.clearMarks(); 
 * }); 
 * obs.observe({ type: 'measure' }); 
 * performance.measure('Start to Now'); 
 * 
 * performance.mark('A'); 
 * doSomeLongRunningProcess(() =&gt; { 
 *   performance.measure('A to Now', 'A'); 
 * 
 *   performance.mark('B'); 
 *   performance.measure('A to B', 'A', 'B'); 
 * }); 
 * ``` 
 * </span><span class="s1">@see </span><span class="s2">[source](https:</span><span class="s0">//github.com/nodejs/node/blob/v20.2.0/lib/perf_hooks.js) 
 */</span>
<span class="s1">declare module </span><span class="s4">'perf_hooks' </span><span class="s3">{</span>
    <span class="s1">import </span><span class="s3">{ </span><span class="s2">AsyncResource </span><span class="s3">} </span><span class="s1">from </span><span class="s4">'node:async_hooks'</span><span class="s3">;</span>
    <span class="s1">type </span><span class="s2">EntryType </span><span class="s1">= </span><span class="s4">'node' </span><span class="s1">| </span><span class="s4">'mark' </span><span class="s1">| </span><span class="s4">'measure' </span><span class="s1">| </span><span class="s4">'gc' </span><span class="s1">| </span><span class="s4">'function' </span><span class="s1">| </span><span class="s4">'http2' </span><span class="s1">| </span><span class="s4">'http'</span><span class="s3">;</span>
    <span class="s1">interface </span><span class="s2">NodeGCPerformanceDetail </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* When `performanceEntry.entryType` is equal to 'gc', `the performance.kind` property identifies 
         * the type of garbage collection operation that occurred. 
         * See perf_hooks.constants for valid values. 
         */</span>
        <span class="s1">readonly </span><span class="s3">kind</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* When `performanceEntry.entryType` is equal to 'gc', the `performance.flags` 
         * property contains additional information about garbage collection operation. 
         * See perf_hooks.constants for valid values. 
         */</span>
        <span class="s1">readonly </span><span class="s3">flags</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The constructor of this class is not exposed to users directly. 
     * </span><span class="s1">@since </span><span class="s0">v8.5.0 
     */</span>
    <span class="s1">class </span><span class="s2">PerformanceEntry </span><span class="s3">{</span>
        <span class="s1">protected constructor</span><span class="s3">();</span>
        <span class="s0">/**</span>
         <span class="s0">* The total number of milliseconds elapsed for this entry. This value will not 
         * be meaningful for all Performance Entry types. 
         * </span><span class="s1">@since </span><span class="s0">v8.5.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">duration</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The name of the performance entry. 
         * </span><span class="s1">@since </span><span class="s0">v8.5.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">name</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The high resolution millisecond timestamp marking the starting time of the 
         * Performance Entry. 
         * </span><span class="s1">@since </span><span class="s0">v8.5.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">startTime</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The type of the performance entry. It may be one of: 
         * 
         * * `'node'` (Node.js only) 
         * * `'mark'` (available on the Web) 
         * * `'measure'` (available on the Web) 
         * * `'gc'` (Node.js only) 
         * * `'function'` (Node.js only) 
         * * `'http2'` (Node.js only) 
         * * `'http'` (Node.js only) 
         * </span><span class="s1">@since </span><span class="s0">v8.5.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">entryType</span><span class="s1">: </span><span class="s2">EntryType</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Additional detail specific to the `entryType`. 
         * </span><span class="s1">@since </span><span class="s0">v16.0.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">detail</span><span class="s1">?: </span><span class="s2">NodeGCPerformanceDetail </span><span class="s1">| </span><span class="s2">unknown </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">; </span><span class="s0">// TODO: Narrow this based on entry type.</span>
        <span class="s3">toJSON()</span><span class="s1">: </span><span class="s2">any</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Exposes marks created via the `Performance.mark()` method. 
     * </span><span class="s1">@since </span><span class="s0">v18.2.0, v16.17.0 
     */</span>
    <span class="s1">class </span><span class="s2">PerformanceMark </span><span class="s1">extends </span><span class="s2">PerformanceEntry </span><span class="s3">{</span>
        <span class="s1">readonly </span><span class="s3">duration</span><span class="s1">: </span><span class="s5">0</span><span class="s3">;</span>
        <span class="s1">readonly </span><span class="s3">entryType</span><span class="s1">: </span><span class="s4">'mark'</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Exposes measures created via the `Performance.measure()` method. 
     * 
     * The constructor of this class is not exposed to users directly. 
     * </span><span class="s1">@since </span><span class="s0">v18.2.0, v16.17.0 
     */</span>
    <span class="s1">class </span><span class="s2">PerformanceMeasure </span><span class="s1">extends </span><span class="s2">PerformanceEntry </span><span class="s3">{</span>
        <span class="s1">readonly </span><span class="s3">entryType</span><span class="s1">: </span><span class="s4">'measure'</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* _This property is an extension by Node.js. It is not available in Web browsers._ 
     * 
     * Provides timing details for Node.js itself. The constructor of this class 
     * is not exposed to users. 
     * </span><span class="s1">@since </span><span class="s0">v8.5.0 
     */</span>
    <span class="s1">class </span><span class="s2">PerformanceNodeTiming </span><span class="s1">extends </span><span class="s2">PerformanceEntry </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The high resolution millisecond timestamp at which the Node.js process 
         * completed bootstrapping. If bootstrapping has not yet finished, the property 
         * has the value of -1. 
         * </span><span class="s1">@since </span><span class="s0">v8.5.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">bootstrapComplete</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The high resolution millisecond timestamp at which the Node.js environment was 
         * initialized. 
         * </span><span class="s1">@since </span><span class="s0">v8.5.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">environment</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The high resolution millisecond timestamp of the amount of time the event loop 
         * has been idle within the event loop's event provider (e.g. `epoll_wait`). This 
         * does not take CPU usage into consideration. If the event loop has not yet 
         * started (e.g., in the first tick of the main script), the property has the 
         * value of 0. 
         * </span><span class="s1">@since </span><span class="s0">v14.10.0, v12.19.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">idleTime</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The high resolution millisecond timestamp at which the Node.js event loop 
         * exited. If the event loop has not yet exited, the property has the value of -1\. 
         * It can only have a value of not -1 in a handler of the `'exit'` event. 
         * </span><span class="s1">@since </span><span class="s0">v8.5.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">loopExit</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The high resolution millisecond timestamp at which the Node.js event loop 
         * started. If the event loop has not yet started (e.g., in the first tick of the 
         * main script), the property has the value of -1. 
         * </span><span class="s1">@since </span><span class="s0">v8.5.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">loopStart</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The high resolution millisecond timestamp at which the V8 platform was 
         * initialized. 
         * </span><span class="s1">@since </span><span class="s0">v8.5.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">v8Start</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">EventLoopUtilization </span><span class="s3">{</span>
        <span class="s3">idle</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">active</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">utilization</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s2">util1 </span><span class="s0">The result of a previous call to eventLoopUtilization() 
     * </span><span class="s1">@param </span><span class="s2">util2 </span><span class="s0">The result of a previous call to eventLoopUtilization() prior to util1 
     */</span>
    <span class="s1">type </span><span class="s2">EventLoopUtilityFunction </span><span class="s1">= </span><span class="s3">(</span><span class="s2">util1</span><span class="s1">?: </span><span class="s2">EventLoopUtilization</span><span class="s3">, </span><span class="s2">util2</span><span class="s1">?: </span><span class="s2">EventLoopUtilization</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">EventLoopUtilization</span><span class="s3">;</span>
    <span class="s1">interface </span><span class="s2">MarkOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Additional optional detail to include with the mark. 
         */</span>
        <span class="s3">detail</span><span class="s1">?: </span><span class="s2">unknown </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An optional timestamp to be used as the mark time. 
         * </span><span class="s1">@default </span><span class="s2">`performance.now()`.</span>
         <span class="s0">*/</span>
        <span class="s3">startTime</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">MeasureOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Additional optional detail to include with the mark. 
         */</span>
        <span class="s3">detail</span><span class="s1">?: </span><span class="s2">unknown </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Duration between start and end times. 
         */</span>
        <span class="s3">duration</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Timestamp to be used as the end time, or a string identifying a previously recorded mark. 
         */</span>
        <span class="s3">end</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Timestamp to be used as the start time, or a string identifying a previously recorded mark. 
         */</span>
        <span class="s3">start</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">TimerifyOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* A histogram object created using 
         * `perf_hooks.createHistogram()` that will record runtime durations in 
         * nanoseconds. 
         */</span>
        <span class="s3">histogram</span><span class="s1">?: </span><span class="s2">RecordableHistogram </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">Performance </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* If name is not provided, removes all PerformanceMark objects from the Performance Timeline. 
         * If name is provided, removes only the named mark. 
         * </span><span class="s1">@param </span><span class="s2">name</span>
         <span class="s0">*/</span>
        <span class="s3">clearMarks(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If name is not provided, removes all PerformanceMeasure objects from the Performance Timeline. 
         * If name is provided, removes only the named measure. 
         * </span><span class="s1">@param </span><span class="s2">name</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v16.7.0 
         */</span>
        <span class="s3">clearMeasures(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a list of `PerformanceEntry` objects in chronological order with respect to `performanceEntry.startTime`. 
         * If you are only interested in performance entries of certain types or that have certain names, see 
         * `performance.getEntriesByType()` and `performance.getEntriesByName()`. 
         * </span><span class="s1">@since </span><span class="s0">v16.7.0 
         */</span>
        <span class="s3">getEntries()</span><span class="s1">: </span><span class="s2">PerformanceEntry</span><span class="s3">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a list of `PerformanceEntry` objects in chronological order with respect to `performanceEntry.startTime` 
         * whose `performanceEntry.name` is equal to `name`, and optionally, whose `performanceEntry.entryType` is equal to `type`. 
         * </span><span class="s1">@param </span><span class="s2">name</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s2">type</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v16.7.0 
         */</span>
        <span class="s3">getEntriesByName(</span><span class="s2">name</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">type</span><span class="s1">?: </span><span class="s2">EntryType</span><span class="s3">)</span><span class="s1">: </span><span class="s2">PerformanceEntry</span><span class="s3">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a list of `PerformanceEntry` objects in chronological order with respect to `performanceEntry.startTime` 
         * whose `performanceEntry.entryType` is equal to `type`. 
         * </span><span class="s1">@param </span><span class="s2">type</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v16.7.0 
         */</span>
        <span class="s3">getEntriesByType(</span><span class="s2">type</span><span class="s1">: </span><span class="s2">EntryType</span><span class="s3">)</span><span class="s1">: </span><span class="s2">PerformanceEntry</span><span class="s3">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Creates a new PerformanceMark entry in the Performance Timeline. 
         * A PerformanceMark is a subclass of PerformanceEntry whose performanceEntry.entryType is always 'mark', 
         * and whose performanceEntry.duration is always 0. 
         * Performance marks are used to mark specific significant moments in the Performance Timeline. 
         * </span><span class="s1">@param </span><span class="s2">name</span>
         <span class="s0">* </span><span class="s1">@return </span><span class="s0">The PerformanceMark entry that was created 
         */</span>
        <span class="s3">mark(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">MarkOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">PerformanceMark</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Creates a new PerformanceMeasure entry in the Performance Timeline. 
         * A PerformanceMeasure is a subclass of PerformanceEntry whose performanceEntry.entryType is always 'measure', 
         * and whose performanceEntry.duration measures the number of milliseconds elapsed since startMark and endMark. 
         * 
         * The startMark argument may identify any existing PerformanceMark in the the Performance Timeline, or may identify 
         * any of the timestamp properties provided by the PerformanceNodeTiming class. If the named startMark does not exist, 
         * then startMark is set to timeOrigin by default. 
         * 
         * The endMark argument must identify any existing PerformanceMark in the the Performance Timeline or any of the timestamp 
         * properties provided by the PerformanceNodeTiming class. If the named endMark does not exist, an error will be thrown. 
         * </span><span class="s1">@param </span><span class="s2">name</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s2">startMark</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s2">endMark</span>
         <span class="s0">* </span><span class="s1">@return </span><span class="s0">The PerformanceMeasure entry that was created 
         */</span>
        <span class="s3">measure(</span><span class="s2">name</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">startMark</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">endMark</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">PerformanceMeasure</span><span class="s3">;</span>
        <span class="s3">measure(</span><span class="s2">name</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">: </span><span class="s2">MeasureOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">PerformanceMeasure</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An instance of the PerformanceNodeTiming class that provides performance metrics for specific Node.js operational milestones. 
         */</span>
        <span class="s1">readonly </span><span class="s3">nodeTiming</span><span class="s1">: </span><span class="s2">PerformanceNodeTiming</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s1">@return </span><span class="s0">the current high resolution millisecond timestamp 
         */</span>
        <span class="s3">now()</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The timeOrigin specifies the high resolution millisecond timestamp from which all performance metric durations are measured. 
         */</span>
        <span class="s1">readonly </span><span class="s3">timeOrigin</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Wraps a function within a new function that measures the running time of the wrapped function. 
         * A PerformanceObserver must be subscribed to the 'function' event type in order for the timing details to be accessed. 
         * </span><span class="s1">@param </span><span class="s2">fn</span>
         <span class="s0">*/</span>
        <span class="s3">timerify&lt;</span><span class="s2">T </span><span class="s1">extends </span><span class="s3">(</span><span class="s1">...</span><span class="s2">params</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">any</span><span class="s3">&gt;(</span><span class="s2">fn</span><span class="s1">: </span><span class="s2">T</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TimerifyOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">T</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* eventLoopUtilization is similar to CPU utilization except that it is calculated using high precision wall-clock time. 
         * It represents the percentage of time the event loop has spent outside the event loop's event provider (e.g. epoll_wait). 
         * No other CPU idle time is taken into consideration. 
         */</span>
        <span class="s3">eventLoopUtilization</span><span class="s1">: </span><span class="s2">EventLoopUtilityFunction</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">PerformanceObserverEntryList </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a list of `PerformanceEntry` objects in chronological order 
         * with respect to `performanceEntry.startTime`. 
         * 
         * ```js 
         * const { 
         *   performance, 
         *   PerformanceObserver, 
         * } = require('node:perf_hooks'); 
         * 
         * const obs = new PerformanceObserver((perfObserverList, observer) =&gt; { 
         *   console.log(perfObserverList.getEntries()); 
         * 
         *    * [ 
         *    *   PerformanceEntry { 
         *    *     name: 'test', 
         *    *     entryType: 'mark', 
         *    *     startTime: 81.465639, 
         *    *     duration: 0 
         *    *   }, 
         *    *   PerformanceEntry { 
         *    *     name: 'meow', 
         *    *     entryType: 'mark', 
         *    *     startTime: 81.860064, 
         *    *     duration: 0 
         *    *   } 
         *    * ] 
         * 
         * 
         *   performance.clearMarks(); 
         *   performance.clearMeasures(); 
         *   observer.disconnect(); 
         * }); 
         * obs.observe({ type: 'mark' }); 
         * 
         * performance.mark('test'); 
         * performance.mark('meow'); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v8.5.0 
         */</span>
        <span class="s3">getEntries()</span><span class="s1">: </span><span class="s2">PerformanceEntry</span><span class="s3">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a list of `PerformanceEntry` objects in chronological order 
         * with respect to `performanceEntry.startTime` whose `performanceEntry.name` is 
         * equal to `name`, and optionally, whose `performanceEntry.entryType` is equal to`type`. 
         * 
         * ```js 
         * const { 
         *   performance, 
         *   PerformanceObserver, 
         * } = require('node:perf_hooks'); 
         * 
         * const obs = new PerformanceObserver((perfObserverList, observer) =&gt; { 
         *   console.log(perfObserverList.getEntriesByName('meow')); 
         * 
         *    * [ 
         *    *   PerformanceEntry { 
         *    *     name: 'meow', 
         *    *     entryType: 'mark', 
         *    *     startTime: 98.545991, 
         *    *     duration: 0 
         *    *   } 
         *    * ] 
         * 
         *   console.log(perfObserverList.getEntriesByName('nope')); // [] 
         * 
         *   console.log(perfObserverList.getEntriesByName('test', 'mark')); 
         * 
         *    * [ 
         *    *   PerformanceEntry { 
         *    *     name: 'test', 
         *    *     entryType: 'mark', 
         *    *     startTime: 63.518931, 
         *    *     duration: 0 
         *    *   } 
         *    * ] 
         * 
         *   console.log(perfObserverList.getEntriesByName('test', 'measure')); // [] 
         * 
         *   performance.clearMarks(); 
         *   performance.clearMeasures(); 
         *   observer.disconnect(); 
         * }); 
         * obs.observe({ entryTypes: ['mark', 'measure'] }); 
         * 
         * performance.mark('test'); 
         * performance.mark('meow'); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v8.5.0 
         */</span>
        <span class="s3">getEntriesByName(</span><span class="s2">name</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">type</span><span class="s1">?: </span><span class="s2">EntryType</span><span class="s3">)</span><span class="s1">: </span><span class="s2">PerformanceEntry</span><span class="s3">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a list of `PerformanceEntry` objects in chronological order 
         * with respect to `performanceEntry.startTime` whose `performanceEntry.entryType`is equal to `type`. 
         * 
         * ```js 
         * const { 
         *   performance, 
         *   PerformanceObserver, 
         * } = require('node:perf_hooks'); 
         * 
         * const obs = new PerformanceObserver((perfObserverList, observer) =&gt; { 
         *   console.log(perfObserverList.getEntriesByType('mark')); 
         * 
         *    * [ 
         *    *   PerformanceEntry { 
         *    *     name: 'test', 
         *    *     entryType: 'mark', 
         *    *     startTime: 55.897834, 
         *    *     duration: 0 
         *    *   }, 
         *    *   PerformanceEntry { 
         *    *     name: 'meow', 
         *    *     entryType: 'mark', 
         *    *     startTime: 56.350146, 
         *    *     duration: 0 
         *    *   } 
         *    * ] 
         * 
         *   performance.clearMarks(); 
         *   performance.clearMeasures(); 
         *   observer.disconnect(); 
         * }); 
         * obs.observe({ type: 'mark' }); 
         * 
         * performance.mark('test'); 
         * performance.mark('meow'); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v8.5.0 
         */</span>
        <span class="s3">getEntriesByType(</span><span class="s2">type</span><span class="s1">: </span><span class="s2">EntryType</span><span class="s3">)</span><span class="s1">: </span><span class="s2">PerformanceEntry</span><span class="s3">[];</span>
    <span class="s3">}</span>
    <span class="s1">type </span><span class="s2">PerformanceObserverCallback </span><span class="s1">= </span><span class="s3">(</span><span class="s2">list</span><span class="s1">: </span><span class="s2">PerformanceObserverEntryList</span><span class="s3">, </span><span class="s2">observer</span><span class="s1">: </span><span class="s2">PerformanceObserver</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.5.0 
     */</span>
    <span class="s1">class </span><span class="s2">PerformanceObserver </span><span class="s1">extends </span><span class="s2">AsyncResource </span><span class="s3">{</span>
        <span class="s1">constructor</span><span class="s3">(</span><span class="s2">callback</span><span class="s1">: </span><span class="s2">PerformanceObserverCallback</span><span class="s3">);</span>
        <span class="s0">/**</span>
         <span class="s0">* Disconnects the `PerformanceObserver` instance from all notifications. 
         * </span><span class="s1">@since </span><span class="s0">v8.5.0 
         */</span>
        <span class="s3">disconnect()</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Subscribes the `PerformanceObserver` instance to notifications of new `PerformanceEntry` instances identified either by `options.entryTypes`or `options.type`: 
         * 
         * ```js 
         * const { 
         *   performance, 
         *   PerformanceObserver, 
         * } = require('node:perf_hooks'); 
         * 
         * const obs = new PerformanceObserver((list, observer) =&gt; { 
         *   // Called once asynchronously. `list` contains three items. 
         * }); 
         * obs.observe({ type: 'mark' }); 
         * 
         * for (let n = 0; n &lt; 3; n++) 
         *   performance.mark(`test${n}`); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v8.5.0 
         */</span>
        <span class="s3">observe(</span>
            <span class="s2">options</span><span class="s1">:</span>
                <span class="s1">| </span><span class="s3">{</span>
                      <span class="s3">entryTypes</span><span class="s1">: </span><span class="s2">ReadonlyArray</span><span class="s3">&lt;</span><span class="s2">EntryType</span><span class="s3">&gt;;</span>
                      <span class="s3">buffered</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
                  <span class="s3">}</span>
                <span class="s1">| </span><span class="s3">{</span>
                      <span class="s3">type</span><span class="s1">: </span><span class="s2">EntryType</span><span class="s3">;</span>
                      <span class="s3">buffered</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
                  <span class="s3">}</span>
        <span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">namespace </span><span class="s2">constants </span><span class="s3">{</span>
        <span class="s1">const </span><span class="s3">NODE_PERFORMANCE_GC_MAJOR</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s1">const </span><span class="s3">NODE_PERFORMANCE_GC_MINOR</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s1">const </span><span class="s3">NODE_PERFORMANCE_GC_INCREMENTAL</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s1">const </span><span class="s3">NODE_PERFORMANCE_GC_WEAKCB</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s1">const </span><span class="s3">NODE_PERFORMANCE_GC_FLAGS_NO</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s1">const </span><span class="s3">NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s1">const </span><span class="s3">NODE_PERFORMANCE_GC_FLAGS_FORCED</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s1">const </span><span class="s3">NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s1">const </span><span class="s3">NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s1">const </span><span class="s3">NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s1">const </span><span class="s3">NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">const </span><span class="s3">performance</span><span class="s1">: </span><span class="s2">Performance</span><span class="s3">;</span>
    <span class="s1">interface </span><span class="s2">EventLoopMonitorOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The sampling rate in milliseconds. 
         * Must be greater than zero. 
         * </span><span class="s1">@default </span><span class="s2">10</span>
         <span class="s0">*/</span>
        <span class="s3">resolution</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">Histogram </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a `Map` object detailing the accumulated percentile distribution. 
         * </span><span class="s1">@since </span><span class="s0">v11.10.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">percentiles</span><span class="s1">: </span><span class="s2">Map</span><span class="s3">&lt;</span><span class="s2">number</span><span class="s3">, </span><span class="s2">number</span><span class="s3">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* The number of times the event loop delay exceeded the maximum 1 hour event 
         * loop delay threshold. 
         * </span><span class="s1">@since </span><span class="s0">v11.10.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">exceeds</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The minimum recorded event loop delay. 
         * </span><span class="s1">@since </span><span class="s0">v11.10.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">min</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The maximum recorded event loop delay. 
         * </span><span class="s1">@since </span><span class="s0">v11.10.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">max</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The mean of the recorded event loop delays. 
         * </span><span class="s1">@since </span><span class="s0">v11.10.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">mean</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The standard deviation of the recorded event loop delays. 
         * </span><span class="s1">@since </span><span class="s0">v11.10.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">stddev</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Resets the collected histogram data. 
         * </span><span class="s1">@since </span><span class="s0">v11.10.0 
         */</span>
        <span class="s3">reset()</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns the value at the given percentile. 
         * </span><span class="s1">@since </span><span class="s0">v11.10.0 
         * </span><span class="s1">@param </span><span class="s2">percentile </span><span class="s0">A percentile value in the range (0, 100]. 
         */</span>
        <span class="s3">percentile(</span><span class="s2">percentile</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">IntervalHistogram </span><span class="s1">extends </span><span class="s2">Histogram </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables the update interval timer. Returns `true` if the timer was 
         * started, `false` if it was already started. 
         * </span><span class="s1">@since </span><span class="s0">v11.10.0 
         */</span>
        <span class="s3">enable()</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Disables the update interval timer. Returns `true` if the timer was 
         * stopped, `false` if it was already stopped. 
         * </span><span class="s1">@since </span><span class="s0">v11.10.0 
         */</span>
        <span class="s3">disable()</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">RecordableHistogram </span><span class="s1">extends </span><span class="s2">Histogram </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v15.9.0, v14.18.0 
         * </span><span class="s1">@param </span><span class="s2">val </span><span class="s0">The amount to record in the histogram. 
         */</span>
        <span class="s3">record(</span><span class="s2">val</span><span class="s1">: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">bigint</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Calculates the amount of time (in nanoseconds) that has passed since the 
         * previous call to `recordDelta()` and records that amount in the histogram. 
         * 
         * ## Examples 
         * </span><span class="s1">@since </span><span class="s0">v15.9.0, v14.18.0 
         */</span>
        <span class="s3">recordDelta()</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Adds the values from `other` to this histogram. 
         * </span><span class="s1">@since </span><span class="s0">v17.4.0, v16.14.0 
         */</span>
        <span class="s3">add(</span><span class="s2">other</span><span class="s1">: </span><span class="s2">RecordableHistogram</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* _This property is an extension by Node.js. It is not available in Web browsers._ 
     * 
     * Creates an `IntervalHistogram` object that samples and reports the event loop 
     * delay over time. The delays will be reported in nanoseconds. 
     * 
     * Using a timer to detect approximate event loop delay works because the 
     * execution of timers is tied specifically to the lifecycle of the libuv 
     * event loop. That is, a delay in the loop will cause a delay in the execution 
     * of the timer, and those delays are specifically what this API is intended to 
     * detect. 
     * 
     * ```js 
     * const { monitorEventLoopDelay } = require('node:perf_hooks'); 
     * const h = monitorEventLoopDelay({ resolution: 20 }); 
     * h.enable(); 
     * // Do something. 
     * h.disable(); 
     * console.log(h.min); 
     * console.log(h.max); 
     * console.log(h.mean); 
     * console.log(h.stddev); 
     * console.log(h.percentiles); 
     * console.log(h.percentile(50)); 
     * console.log(h.percentile(99)); 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v11.10.0 
     */</span>
    <span class="s1">function </span><span class="s3">monitorEventLoopDelay(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">EventLoopMonitorOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">IntervalHistogram</span><span class="s3">;</span>
    <span class="s1">interface </span><span class="s2">CreateHistogramOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The minimum recordable value. Must be an integer value greater than 0. 
         * </span><span class="s1">@default </span><span class="s2">1</span>
         <span class="s0">*/</span>
        <span class="s3">min</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">bigint </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The maximum recordable value. Must be an integer value greater than min. 
         * </span><span class="s1">@default </span><span class="s2">Number.MAX_SAFE_INTEGER</span>
         <span class="s0">*/</span>
        <span class="s3">max</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">bigint </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The number of accuracy digits. Must be a number between 1 and 5. 
         * </span><span class="s1">@default </span><span class="s2">3</span>
         <span class="s0">*/</span>
        <span class="s3">figures</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns a `RecordableHistogram`. 
     * </span><span class="s1">@since </span><span class="s0">v15.9.0, v14.18.0 
     */</span>
    <span class="s1">function </span><span class="s3">createHistogram(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">CreateHistogramOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">RecordableHistogram</span><span class="s3">;</span>
    <span class="s1">import </span><span class="s3">{ </span><span class="s2">performance </span><span class="s1">as </span><span class="s2">_performance </span><span class="s3">} </span><span class="s1">from </span><span class="s4">'perf_hooks'</span><span class="s3">;</span>
    <span class="s2">global </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* `performance` is a global reference for `require('perf_hooks').performance` 
         * https://nodejs.org/api/globals.html#performance 
         * </span><span class="s1">@since </span><span class="s0">v16.0.0 
         */</span>
        <span class="s1">var </span><span class="s3">performance</span><span class="s1">: typeof </span><span class="s2">globalThis extends </span><span class="s3">{</span>
            <span class="s3">onmessage</span><span class="s1">: </span><span class="s2">any</span><span class="s3">;</span>
            <span class="s3">performance</span><span class="s1">: infer </span><span class="s2">T</span><span class="s3">;</span>
        <span class="s3">}</span>
            <span class="s1">? </span><span class="s2">T</span>
            <span class="s1">: typeof </span><span class="s2">_performance</span><span class="s3">;</span>
    <span class="s3">}</span>
<span class="s3">}</span>
<span class="s1">declare module </span><span class="s4">'node:perf_hooks' </span><span class="s3">{</span>
    <span class="s1">export </span><span class="s6">* </span><span class="s1">from </span><span class="s4">'perf_hooks'</span><span class="s3">;</span>
<span class="s3">}</span>
</pre>
</body>
</html>
<html>
<head>
<title>RCTBaseTextInputView.m</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RCTBaseTextInputView.m</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#import </span><span class="s3">&lt;React/RCTBaseTextInputView.h&gt;</span>

<span class="s2">#import </span><span class="s3">&lt;React/RCTBridge.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTConvert.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTEventDispatcherProtocol.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTUIManager.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTUtils.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/UIView+React.h&gt;</span>

<span class="s2">#import </span><span class="s3">&lt;React/RCTInputAccessoryView.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTInputAccessoryViewContent.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTTextAttributes.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTTextSelection.h&gt;</span>

<span class="s4">@implementation </span><span class="s1">RCTBaseTextInputView {</span>
  <span class="s4">__weak </span><span class="s1">RCTBridge *_bridge</span><span class="s4">;</span>
  <span class="s4">__weak </span><span class="s1">id&lt;RCTEventDispatcherProtocol&gt; _eventDispatcher</span><span class="s4">;</span>
  <span class="s1">BOOL _hasInputAccessoryView</span><span class="s4">;</span>
  <span class="s1">NSString *</span><span class="s4">_Nullable </span><span class="s1">_predictedText</span><span class="s4">;</span>
  <span class="s1">BOOL _didMoveToWindow</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (instancetype)initWithBridge:(RCTBridge *)bridge</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertParam(bridge)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(self = [super initWithFrame:CGRectZero]) {</span>
    <span class="s1">_bridge = bridge</span><span class="s4">;</span>
    <span class="s1">_eventDispatcher = bridge.eventDispatcher</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">self</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_NOT_IMPLEMENTED(-(instancetype)init)</span>
<span class="s1">RCT_NOT_IMPLEMENTED(-(instancetype)initWithCoder : (NSCoder *)decoder)</span>
<span class="s1">RCT_NOT_IMPLEMENTED(-(instancetype)initWithFrame : (CGRect)frame)</span>

<span class="s1">- (UIView&lt;RCTBackedTextInputViewProtocol&gt; *)backedTextInputView</span>
<span class="s1">{</span>
  <span class="s1">RCTAssert(NO</span><span class="s4">, @</span><span class="s3">&quot;-[RCTBaseTextInputView backedTextInputView] must be implemented in subclass.&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - RCTComponent</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)didUpdateReactSubviews</span>
<span class="s1">{</span>
  <span class="s0">// Do nothing.</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Properties</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setTextAttributes:(RCTTextAttributes *)textAttributes</span>
<span class="s1">{</span>
  <span class="s1">_textAttributes = textAttributes</span><span class="s4">;</span>
  <span class="s1">[self enforceTextAttributesIfNeeded]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)enforceTextAttributesIfNeeded</span>
<span class="s1">{</span>
  <span class="s1">id&lt;RCTBackedTextInputViewProtocol&gt; backedTextInputView = self.backedTextInputView</span><span class="s4">;</span>

  <span class="s1">NSDictionary&lt;NSAttributedStringKey</span><span class="s4">, </span><span class="s1">id&gt; *textAttributes = [[_textAttributes effectiveTextAttributes] mutableCopy]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">([textAttributes valueForKey:NSForegroundColorAttributeName] == nil) {</span>
    <span class="s1">[textAttributes setValue:[UIColor blackColor] forKey:NSForegroundColorAttributeName]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">backedTextInputView.defaultTextAttributes = textAttributes</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setReactPaddingInsets:(UIEdgeInsets)reactPaddingInsets</span>
<span class="s1">{</span>
  <span class="s1">_reactPaddingInsets = reactPaddingInsets</span><span class="s4">;</span>
  <span class="s0">// We apply `paddingInsets` as `backedTextInputView`'s `textContainerInset`.</span>
  <span class="s1">self.backedTextInputView.textContainerInset = reactPaddingInsets</span><span class="s4">;</span>
  <span class="s1">[self setNeedsLayout]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setReactBorderInsets:(UIEdgeInsets)reactBorderInsets</span>
<span class="s1">{</span>
  <span class="s1">_reactBorderInsets = reactBorderInsets</span><span class="s4">;</span>
  <span class="s0">// We apply `borderInsets` as `backedTextInputView` layout offset.</span>
  <span class="s1">self.backedTextInputView.frame = UIEdgeInsetsInsetRect(self.bounds</span><span class="s4">, </span><span class="s1">reactBorderInsets)</span><span class="s4">;</span>
  <span class="s1">[self setNeedsLayout]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSAttributedString *)attributedText</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">self.backedTextInputView.attributedText</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)textOf:(NSAttributedString *)newText equals:(NSAttributedString *)oldText</span>
<span class="s1">{</span>
  <span class="s0">// When the dictation is running we can't update the attributed text on the backed up text view</span>
  <span class="s0">// because setting the attributed string will kill the dictation. This means that we can't impose</span>
  <span class="s0">// the settings on a dictation.</span>
  <span class="s0">// Similarly, when the user is in the middle of inputting some text in Japanese/Chinese, there will be styling on the</span>
  <span class="s0">// text that we should disregard. See</span>
  <span class="s0">// https://developer.apple.com/documentation/uikit/uitextinput/1614489-markedtextrange?language=objc for more info.</span>
  <span class="s0">// Also, updating the attributed text while inputting Korean language will break input mechanism.</span>
  <span class="s0">// If the user added an emoji, the system adds a font attribute for the emoji and stores the original font in</span>
  <span class="s0">// NSOriginalFont. Lastly, when entering a password, etc., there will be additional styling on the field as the native</span>
  <span class="s0">// text view handles showing the last character for a split second.</span>
  <span class="s1">__block BOOL fontHasBeenUpdatedBySystem = false</span><span class="s4">;</span>
  <span class="s1">[oldText enumerateAttribute:</span><span class="s4">@</span><span class="s3">&quot;NSOriginalFont&quot;</span>
                      <span class="s1">inRange:NSMakeRange(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">oldText.length)</span>
                      <span class="s1">options:</span><span class="s5">0</span>
                   <span class="s1">usingBlock:^(id value</span><span class="s4">, </span><span class="s1">NSRange range</span><span class="s4">, </span><span class="s1">BOOL *stop) {</span>
                     <span class="s4">if </span><span class="s1">(value) {</span>
                       <span class="s1">fontHasBeenUpdatedBySystem = true</span><span class="s4">;</span>
                     <span class="s1">}</span>
                   <span class="s1">}]</span><span class="s4">;</span>

  <span class="s1">BOOL shouldFallbackToBareTextComparison =</span>
      <span class="s1">[self.backedTextInputView.textInputMode.primaryLanguage isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;dictation&quot;</span><span class="s1">] ||</span>
      <span class="s1">[self.backedTextInputView.textInputMode.primaryLanguage isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;ko-KR&quot;</span><span class="s1">] ||</span>
      <span class="s1">self.backedTextInputView.markedTextRange || self.backedTextInputView.isSecureTextEntry ||</span>
      <span class="s1">fontHasBeenUpdatedBySystem</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(shouldFallbackToBareTextComparison) {</span>
    <span class="s4">return </span><span class="s1">([newText.string isEqualToString:oldText.string])</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">([newText isEqualToAttributedString:oldText])</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setAttributedText:(NSAttributedString *)attributedText</span>
<span class="s1">{</span>
  <span class="s1">NSInteger eventLag = _nativeEventCount - _mostRecentEventCount</span><span class="s4">;</span>
  <span class="s1">BOOL textNeedsUpdate = NO</span><span class="s4">;</span>
  <span class="s0">// Remove tag attribute to ensure correct attributed string comparison.</span>
  <span class="s1">NSMutableAttributedString *</span><span class="s4">const </span><span class="s1">backedTextInputViewTextCopy = [self.backedTextInputView.attributedText mutableCopy]</span><span class="s4">;</span>
  <span class="s1">NSMutableAttributedString *</span><span class="s4">const </span><span class="s1">attributedTextCopy = [attributedText mutableCopy]</span><span class="s4">;</span>

  <span class="s1">[backedTextInputViewTextCopy removeAttribute:RCTTextAttributesTagAttributeName</span>
                                         <span class="s1">range:NSMakeRange(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">backedTextInputViewTextCopy.length)]</span><span class="s4">;</span>

  <span class="s1">[attributedTextCopy removeAttribute:RCTTextAttributesTagAttributeName</span>
                                <span class="s1">range:NSMakeRange(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">attributedTextCopy.length)]</span><span class="s4">;</span>

  <span class="s1">textNeedsUpdate = ([self textOf:attributedTextCopy equals:backedTextInputViewTextCopy] == NO)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(eventLag == </span><span class="s5">0 </span><span class="s1">&amp;&amp; textNeedsUpdate) {</span>
    <span class="s1">UITextRange *selection = self.backedTextInputView.selectedTextRange</span><span class="s4">;</span>
    <span class="s1">NSInteger oldTextLength = self.backedTextInputView.attributedText.string.length</span><span class="s4">;</span>

    <span class="s1">self.backedTextInputView.attributedText = attributedText</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(selection.empty) {</span>
      <span class="s0">// Maintaining a cursor position relative to the end of the old text.</span>
      <span class="s1">NSInteger offsetStart = [self.backedTextInputView offsetFromPosition:self.backedTextInputView.beginningOfDocument</span>
                                                                <span class="s1">toPosition:selection.start]</span><span class="s4">;</span>
      <span class="s1">NSInteger offsetFromEnd = oldTextLength - offsetStart</span><span class="s4">;</span>
      <span class="s1">NSInteger newOffset = attributedText.string.length - offsetFromEnd</span><span class="s4">;</span>
      <span class="s1">UITextPosition *position =</span>
          <span class="s1">[self.backedTextInputView positionFromPosition:self.backedTextInputView.beginningOfDocument offset:newOffset]</span><span class="s4">;</span>
      <span class="s1">[self.backedTextInputView setSelectedTextRange:[self.backedTextInputView textRangeFromPosition:position</span>
                                                                                          <span class="s1">toPosition:position]</span>
                                      <span class="s1">notifyDelegate:YES]</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">[self updateLocalData]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(eventLag &gt; RCTTextUpdateLagWarningThreshold) {</span>
    <span class="s1">RCTLog(</span>
        <span class="s4">@</span><span class="s3">&quot;Native TextInput(%@) is %lld events ahead of JS - try to make your JS faster.&quot;</span><span class="s4">,</span>
        <span class="s1">self.backedTextInputView.attributedText.string</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s4">long long</span><span class="s1">)eventLag)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (RCTTextSelection *)selection</span>
<span class="s1">{</span>
  <span class="s1">id&lt;RCTBackedTextInputViewProtocol&gt; backedTextInputView = self.backedTextInputView</span><span class="s4">;</span>
  <span class="s1">UITextRange *selectedTextRange = backedTextInputView.selectedTextRange</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">[[RCTTextSelection new]</span>
      <span class="s1">initWithStart:[backedTextInputView offsetFromPosition:backedTextInputView.beginningOfDocument</span>
                                                 <span class="s1">toPosition:selectedTextRange.start]</span>
                <span class="s4">end</span><span class="s1">:[backedTextInputView offsetFromPosition:backedTextInputView.beginningOfDocument</span>
                                                 <span class="s1">toPosition:selectedTextRange.</span><span class="s4">end</span><span class="s1">]]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setSelection:(RCTTextSelection *)selection</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!selection) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">id&lt;RCTBackedTextInputViewProtocol&gt; backedTextInputView = self.backedTextInputView</span><span class="s4">;</span>

  <span class="s1">UITextRange *previousSelectedTextRange = backedTextInputView.selectedTextRange</span><span class="s4">;</span>
  <span class="s1">UITextPosition *start = [backedTextInputView positionFromPosition:backedTextInputView.beginningOfDocument</span>
                                                             <span class="s1">offset:selection.start]</span><span class="s4">;</span>
  <span class="s1">UITextPosition *</span><span class="s4">end </span><span class="s1">= [backedTextInputView positionFromPosition:backedTextInputView.beginningOfDocument</span>
                                                           <span class="s1">offset:selection.</span><span class="s4">end</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s1">UITextRange *selectedTextRange = [backedTextInputView textRangeFromPosition:start toPosition:</span><span class="s4">end</span><span class="s1">]</span><span class="s4">;</span>

  <span class="s1">NSInteger eventLag = _nativeEventCount - _mostRecentEventCount</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(eventLag == </span><span class="s5">0 </span><span class="s1">&amp;&amp; ![previousSelectedTextRange isEqual:selectedTextRange]) {</span>
    <span class="s1">[backedTextInputView setSelectedTextRange:selectedTextRange notifyDelegate:NO]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(eventLag &gt; RCTTextUpdateLagWarningThreshold) {</span>
    <span class="s1">RCTLog(</span>
        <span class="s4">@</span><span class="s3">&quot;Native TextInput(%@) is %lld events ahead of JS - try to make your JS faster.&quot;</span><span class="s4">,</span>
        <span class="s1">backedTextInputView.attributedText.string</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s4">long long</span><span class="s1">)eventLag)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setSelectionStart:(NSInteger)start selectionEnd:(NSInteger)</span><span class="s4">end</span>
<span class="s1">{</span>
  <span class="s1">UITextPosition *startPosition =</span>
      <span class="s1">[self.backedTextInputView positionFromPosition:self.backedTextInputView.beginningOfDocument offset:start]</span><span class="s4">;</span>
  <span class="s1">UITextPosition *endPosition =</span>
      <span class="s1">[self.backedTextInputView positionFromPosition:self.backedTextInputView.beginningOfDocument offset:</span><span class="s4">end</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(startPosition &amp;&amp; endPosition) {</span>
    <span class="s1">UITextRange *range = [self.backedTextInputView textRangeFromPosition:startPosition toPosition:endPosition]</span><span class="s4">;</span>
    <span class="s1">[self.backedTextInputView setSelectedTextRange:range notifyDelegate:NO]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setTextContentType:(NSString *)type</span>
<span class="s1">{</span>
<span class="s2">#if </span><span class="s1">defined(__IPHONE_OS_VERSION_MAX_ALLOWED)</span>
  <span class="s4">static </span><span class="s1">dispatch_once_t onceToken</span><span class="s4">;</span>
  <span class="s4">static </span><span class="s1">NSDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">NSString *&gt; *contentTypeMap</span><span class="s4">;</span>

  <span class="s1">dispatch_once(&amp;onceToken</span><span class="s4">, </span><span class="s1">^{</span>
    <span class="s1">contentTypeMap = </span><span class="s4">@</span><span class="s1">{</span>
      <span class="s4">@</span><span class="s3">&quot;none&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;&quot;</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;URL&quot; </span><span class="s1">: UITextContentTypeURL</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;addressCity&quot; </span><span class="s1">: UITextContentTypeAddressCity</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;addressCityAndState&quot; </span><span class="s1">: UITextContentTypeAddressCityAndState</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;addressState&quot; </span><span class="s1">: UITextContentTypeAddressState</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;countryName&quot; </span><span class="s1">: UITextContentTypeCountryName</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;creditCardNumber&quot; </span><span class="s1">: UITextContentTypeCreditCardNumber</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;emailAddress&quot; </span><span class="s1">: UITextContentTypeEmailAddress</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;familyName&quot; </span><span class="s1">: UITextContentTypeFamilyName</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;fullStreetAddress&quot; </span><span class="s1">: UITextContentTypeFullStreetAddress</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;givenName&quot; </span><span class="s1">: UITextContentTypeGivenName</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;jobTitle&quot; </span><span class="s1">: UITextContentTypeJobTitle</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;location&quot; </span><span class="s1">: UITextContentTypeLocation</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;middleName&quot; </span><span class="s1">: UITextContentTypeMiddleName</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;name&quot; </span><span class="s1">: UITextContentTypeName</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;namePrefix&quot; </span><span class="s1">: UITextContentTypeNamePrefix</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;nameSuffix&quot; </span><span class="s1">: UITextContentTypeNameSuffix</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;nickname&quot; </span><span class="s1">: UITextContentTypeNickname</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;organizationName&quot; </span><span class="s1">: UITextContentTypeOrganizationName</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;postalCode&quot; </span><span class="s1">: UITextContentTypePostalCode</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;streetAddressLine1&quot; </span><span class="s1">: UITextContentTypeStreetAddressLine1</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;streetAddressLine2&quot; </span><span class="s1">: UITextContentTypeStreetAddressLine2</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;sublocality&quot; </span><span class="s1">: UITextContentTypeSublocality</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;telephoneNumber&quot; </span><span class="s1">: UITextContentTypeTelephoneNumber</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;username&quot; </span><span class="s1">: UITextContentTypeUsername</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;password&quot; </span><span class="s1">: UITextContentTypePassword</span><span class="s4">,</span>
    <span class="s1">}</span><span class="s4">;</span>

<span class="s2">#if </span><span class="s1">__IPHONE_OS_VERSION_MAX_ALLOWED &gt;= </span><span class="s5">120000 </span><span class="s0">/* __IPHONE_12_0 */</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">12.0</span><span class="s4">, </span><span class="s1">*)) {</span>
      <span class="s1">NSDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">NSString *&gt; *iOS12extras =</span>
          <span class="s4">@</span><span class="s1">{</span><span class="s4">@</span><span class="s3">&quot;newPassword&quot; </span><span class="s1">: UITextContentTypeNewPassword</span><span class="s4">, @</span><span class="s3">&quot;oneTimeCode&quot; </span><span class="s1">: UITextContentTypeOneTimeCode}</span><span class="s4">;</span>

      <span class="s1">NSMutableDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">NSString *&gt; *iOS12baseMap = [contentTypeMap mutableCopy]</span><span class="s4">;</span>
      <span class="s1">[iOS12baseMap addEntriesFromDictionary:iOS12extras]</span><span class="s4">;</span>

      <span class="s1">contentTypeMap = [iOS12baseMap copy]</span><span class="s4">;</span>
    <span class="s1">}</span>
<span class="s2">#endif</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s0">// Setting textContentType to an empty string will disable any</span>
  <span class="s0">// default behaviour, like the autofill bar for password inputs</span>
  <span class="s1">self.backedTextInputView.textContentType = contentTypeMap[type] ?: type</span><span class="s4">;</span>
<span class="s2">#endif</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setPasswordRules:(NSString *)descriptor</span>
<span class="s1">{</span>
<span class="s2">#if </span><span class="s1">defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_12_0</span>
  <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">12.0</span><span class="s4">, </span><span class="s1">*)) {</span>
    <span class="s1">self.backedTextInputView.passwordRules = [UITextInputPasswordRules passwordRulesWithDescriptor:descriptor]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s2">#endif</span>
<span class="s1">}</span>

<span class="s1">- (UIKeyboardType)keyboardType</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">self.backedTextInputView.keyboardType</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setKeyboardType:(UIKeyboardType)keyboardType</span>
<span class="s1">{</span>
  <span class="s1">UIView&lt;RCTBackedTextInputViewProtocol&gt; *textInputView = self.backedTextInputView</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(textInputView.keyboardType != keyboardType) {</span>
    <span class="s1">textInputView.keyboardType = keyboardType</span><span class="s4">;</span>
    <span class="s0">// Without the call to reloadInputViews, the keyboard will not change until the textview field (the first responder)</span>
    <span class="s0">// loses and regains focus.</span>
    <span class="s4">if </span><span class="s1">(textInputView.isFirstResponder) {</span>
      <span class="s1">[textInputView reloadInputViews]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setShowSoftInputOnFocus:(BOOL)showSoftInputOnFocus</span>
<span class="s1">{</span>
  <span class="s1">(</span><span class="s4">void</span><span class="s1">)_showSoftInputOnFocus</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(showSoftInputOnFocus) {</span>
    <span class="s0">// Resets to default keyboard.</span>
    <span class="s1">self.backedTextInputView.inputView = nil</span><span class="s4">;</span>

    <span class="s0">// Without the call to reloadInputViews, the keyboard will not change until the textInput field (the first</span>
    <span class="s0">// responder) loses and regains focus.</span>
    <span class="s4">if </span><span class="s1">(self.backedTextInputView.isFirstResponder) {</span>
      <span class="s1">[self.backedTextInputView reloadInputViews]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s0">// Hides keyboard, but keeps blinking cursor.</span>
    <span class="s1">self.backedTextInputView.inputView = [UIView new]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - RCTBackedTextInputDelegate</span>

<span class="s1">- (BOOL)textInputShouldBeginEditing</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)textInputDidBeginEditing</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_clearTextOnFocus) {</span>
    <span class="s1">self.backedTextInputView.attributedText = [NSAttributedString new]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(_selectTextOnFocus) {</span>
    <span class="s1">[self.backedTextInputView selectAll:nil]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">[_eventDispatcher sendTextEventWithType:RCTTextEventTypeFocus</span>
                                 <span class="s1">reactTag:self.reactTag</span>
                                     <span class="s1">text:[self.backedTextInputView.attributedText.string copy]</span>
                                      <span class="s1">key:nil</span>
                               <span class="s1">eventCount:_nativeEventCount]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)textInputShouldEndEditing</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)textInputDidEndEditing</span>
<span class="s1">{</span>
  <span class="s1">[_eventDispatcher sendTextEventWithType:RCTTextEventTypeEnd</span>
                                 <span class="s1">reactTag:self.reactTag</span>
                                     <span class="s1">text:[self.backedTextInputView.attributedText.string copy]</span>
                                      <span class="s1">key:nil</span>
                               <span class="s1">eventCount:_nativeEventCount]</span><span class="s4">;</span>

  <span class="s1">[_eventDispatcher sendTextEventWithType:RCTTextEventTypeBlur</span>
                                 <span class="s1">reactTag:self.reactTag</span>
                                     <span class="s1">text:[self.backedTextInputView.attributedText.string copy]</span>
                                      <span class="s1">key:nil</span>
                               <span class="s1">eventCount:_nativeEventCount]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)textInputShouldSubmitOnReturn</span>
<span class="s1">{</span>
  <span class="s4">const </span><span class="s1">BOOL shouldSubmit =</span>
      <span class="s1">[_submitBehavior isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;blurAndSubmit&quot;</span><span class="s1">] || [_submitBehavior isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;submit&quot;</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(shouldSubmit) {</span>
    <span class="s0">// We send `submit` event here, in `textInputShouldSubmit`</span>
    <span class="s0">// (not in `textInputDidReturn)`, because of semantic of the event:</span>
    <span class="s0">// `onSubmitEditing` is called when &quot;Submit&quot; button</span>
    <span class="s0">// (the blue key on onscreen keyboard) did pressed</span>
    <span class="s0">// (no connection to any specific &quot;submitting&quot; process).</span>
    <span class="s1">[_eventDispatcher sendTextEventWithType:RCTTextEventTypeSubmit</span>
                                   <span class="s1">reactTag:self.reactTag</span>
                                       <span class="s1">text:[self.backedTextInputView.attributedText.string copy]</span>
                                        <span class="s1">key:nil</span>
                                 <span class="s1">eventCount:_nativeEventCount]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">shouldSubmit</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)textInputShouldReturn</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">[_submitBehavior isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;blurAndSubmit&quot;</span><span class="s1">]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)textInputDidReturn</span>
<span class="s1">{</span>
  <span class="s0">// Does nothing.</span>
<span class="s1">}</span>

<span class="s1">- (NSString *)textInputShouldChangeText:(NSString *)text inRange:(NSRange)range</span>
<span class="s1">{</span>
  <span class="s1">id&lt;RCTBackedTextInputViewProtocol&gt; backedTextInputView = self.backedTextInputView</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(!backedTextInputView.textWasPasted) {</span>
    <span class="s1">[_eventDispatcher sendTextEventWithType:RCTTextEventTypeKeyPress</span>
                                   <span class="s1">reactTag:self.reactTag</span>
                                       <span class="s1">text:nil</span>
                                        <span class="s1">key:text</span>
                                 <span class="s1">eventCount:_nativeEventCount]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(_maxLength) {</span>
    <span class="s1">NSInteger allowedLength = MAX(</span>
        <span class="s1">_maxLength.integerValue - (NSInteger)backedTextInputView.attributedText.string.length + (NSInteger)range.length</span><span class="s4">,</span>
        <span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(text.length &gt; allowedLength) {</span>
      <span class="s0">// If we typed/pasted more than one character, limit the text inputted.</span>
      <span class="s4">if </span><span class="s1">(text.length &gt; </span><span class="s5">1</span><span class="s1">) {</span>
        <span class="s4">if </span><span class="s1">(allowedLength &gt; </span><span class="s5">0</span><span class="s1">) {</span>
          <span class="s0">// make sure unicode characters that are longer than 16 bits (such as emojis) are not cut off</span>
          <span class="s1">NSRange cutOffCharacterRange = [text rangeOfComposedCharacterSequenceAtIndex:allowedLength - </span><span class="s5">1</span><span class="s1">]</span><span class="s4">;</span>
          <span class="s4">if </span><span class="s1">(cutOffCharacterRange.location + cutOffCharacterRange.length &gt; allowedLength) {</span>
            <span class="s0">// the character at the length limit takes more than 16bits, truncation should end at the character before</span>
            <span class="s1">allowedLength = cutOffCharacterRange.location</span><span class="s4">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">// Truncate the input string so the result is exactly maxLength</span>
        <span class="s1">NSString *limitedString = [text substringToIndex:allowedLength]</span><span class="s4">;</span>
        <span class="s1">NSMutableAttributedString *newAttributedText = [backedTextInputView.attributedText mutableCopy]</span><span class="s4">;</span>
        <span class="s0">// Apply text attributes if original input view doesn't have text.</span>
        <span class="s4">if </span><span class="s1">(backedTextInputView.attributedText.length == </span><span class="s5">0</span><span class="s1">) {</span>
          <span class="s1">newAttributedText = [[NSMutableAttributedString alloc]</span>
              <span class="s1">initWithString:[self.textAttributes applyTextAttributesToText:limitedString]</span>
                  <span class="s1">attributes:self.textAttributes.effectiveTextAttributes]</span><span class="s4">;</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
          <span class="s1">[newAttributedText replaceCharactersInRange:range withString:limitedString]</span><span class="s4">;</span>
        <span class="s1">}</span>
        <span class="s1">backedTextInputView.attributedText = newAttributedText</span><span class="s4">;</span>
        <span class="s1">_predictedText = newAttributedText.string</span><span class="s4">;</span>

        <span class="s0">// Collapse selection at end of insert to match normal paste behavior.</span>
        <span class="s1">UITextPosition *insertEnd = [backedTextInputView positionFromPosition:backedTextInputView.beginningOfDocument</span>
                                                                       <span class="s1">offset:(range.location + allowedLength)]</span><span class="s4">;</span>
        <span class="s1">[backedTextInputView setSelectedTextRange:[backedTextInputView textRangeFromPosition:insertEnd</span>
                                                                                  <span class="s1">toPosition:insertEnd]</span>
                                   <span class="s1">notifyDelegate:YES]</span><span class="s4">;</span>

        <span class="s1">[self textInputDidChange]</span><span class="s4">;</span>
      <span class="s1">}</span>

      <span class="s4">return </span><span class="s1">nil</span><span class="s4">; </span><span class="s0">// Rejecting the change.</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">NSString *previousText = [backedTextInputView.attributedText.string copy] ?: </span><span class="s4">@</span><span class="s3">&quot;&quot;</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(range.location + range.length &gt; backedTextInputView.attributedText.string.length) {</span>
    <span class="s1">_predictedText = backedTextInputView.attributedText.string</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(text != nil) {</span>
    <span class="s1">_predictedText = [backedTextInputView.attributedText.string stringByReplacingCharactersInRange:range</span>
                                                                                        <span class="s1">withString:text]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(_onTextInput) {</span>
    <span class="s1">_onTextInput(</span><span class="s4">@</span><span class="s1">{</span>
      <span class="s0">// We copy the string here because if it's a mutable string it may get released before we stop using it on a</span>
      <span class="s0">// different thread, causing a crash.</span>
      <span class="s4">@</span><span class="s3">&quot;text&quot; </span><span class="s1">: [text copy]</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;previousText&quot; </span><span class="s1">: previousText</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;range&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">{</span><span class="s4">@</span><span class="s3">&quot;start&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">(range.location)</span><span class="s4">, @</span><span class="s3">&quot;end&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">(range.location + range.length)}</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;eventCount&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">(_nativeEventCount)</span><span class="s4">,</span>
    <span class="s1">})</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">text</span><span class="s4">; </span><span class="s0">// Accepting the change.</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)textInputDidChange</span>
<span class="s1">{</span>
  <span class="s1">[self updateLocalData]</span><span class="s4">;</span>

  <span class="s1">id&lt;RCTBackedTextInputViewProtocol&gt; backedTextInputView = self.backedTextInputView</span><span class="s4">;</span>

  <span class="s0">// Detect when `backedTextInputView` updates happened that didn't invoke `shouldChangeTextInRange`</span>
  <span class="s0">// (e.g. typing simplified Chinese in pinyin will insert and remove spaces without</span>
  <span class="s0">// calling shouldChangeTextInRange).  This will cause JS to get out of sync so we</span>
  <span class="s0">// update the mismatched range.</span>
  <span class="s1">NSRange currentRange</span><span class="s4">;</span>
  <span class="s1">NSRange predictionRange</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(findMismatch(backedTextInputView.attributedText.string</span><span class="s4">, </span><span class="s1">_predictedText</span><span class="s4">, </span><span class="s1">&amp;currentRange</span><span class="s4">, </span><span class="s1">&amp;predictionRange)) {</span>
    <span class="s1">NSString *replacement = [backedTextInputView.attributedText.string substringWithRange:currentRange]</span><span class="s4">;</span>
    <span class="s1">[self textInputShouldChangeText:replacement inRange:predictionRange]</span><span class="s4">;</span>
    <span class="s0">// JS will assume the selection changed based on the location of our shouldChangeTextInRange, so reset it.</span>
    <span class="s1">[self textInputDidChangeSelection]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">_nativeEventCount++</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(_onChange) {</span>
    <span class="s1">_onChange(</span><span class="s4">@</span><span class="s1">{</span>
      <span class="s4">@</span><span class="s3">&quot;text&quot; </span><span class="s1">: [self.attributedText.string copy]</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;target&quot; </span><span class="s1">: self.reactTag</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;eventCount&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">(_nativeEventCount)</span><span class="s4">,</span>
    <span class="s1">})</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)textInputDidChangeSelection</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!_onSelectionChange) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">RCTTextSelection *selection = self.selection</span><span class="s4">;</span>

  <span class="s1">_onSelectionChange(</span><span class="s4">@</span><span class="s1">{</span>
    <span class="s4">@</span><span class="s3">&quot;selection&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">{</span>
      <span class="s4">@</span><span class="s3">&quot;start&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">(selection.start)</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;end&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">(selection.</span><span class="s4">end</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">}</span><span class="s4">,</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)updateLocalData</span>
<span class="s1">{</span>
  <span class="s1">[self enforceTextAttributesIfNeeded]</span><span class="s4">;</span>

  <span class="s1">[_bridge.uiManager setLocalData:[self.backedTextInputView.attributedText copy] forView:self]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Layout (in UIKit terms</span><span class="s4">, </span><span class="s1">with all insets)</span>

<span class="s1">- (CGSize)intrinsicContentSize</span>
<span class="s1">{</span>
  <span class="s1">CGSize size = self.backedTextInputView.intrinsicContentSize</span><span class="s4">;</span>
  <span class="s1">size.width += _reactBorderInsets.left + _reactBorderInsets.right</span><span class="s4">;</span>
  <span class="s1">size.height += _reactBorderInsets.top + _reactBorderInsets.bottom</span><span class="s4">;</span>
  <span class="s0">// Returning value DOES include border and padding insets.</span>
  <span class="s4">return </span><span class="s1">size</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (CGSize)sizeThatFits:(CGSize)size</span>
<span class="s1">{</span>
  <span class="s1">CGFloat compoundHorizontalBorderInset = _reactBorderInsets.left + _reactBorderInsets.right</span><span class="s4">;</span>
  <span class="s1">CGFloat compoundVerticalBorderInset = _reactBorderInsets.top + _reactBorderInsets.bottom</span><span class="s4">;</span>

  <span class="s1">size.width -= compoundHorizontalBorderInset</span><span class="s4">;</span>
  <span class="s1">size.height -= compoundVerticalBorderInset</span><span class="s4">;</span>

  <span class="s0">// Note: `paddingInsets` was already included in `backedTextInputView` size</span>
  <span class="s0">// because it was applied as `textContainerInset`.</span>
  <span class="s1">CGSize fittingSize = [self.backedTextInputView sizeThatFits:size]</span><span class="s4">;</span>

  <span class="s1">fittingSize.width += compoundHorizontalBorderInset</span><span class="s4">;</span>
  <span class="s1">fittingSize.height += compoundVerticalBorderInset</span><span class="s4">;</span>

  <span class="s0">// Returning value DOES include border and padding insets.</span>
  <span class="s4">return </span><span class="s1">fittingSize</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Accessibility</span>

<span class="s1">- (UIView *)reactAccessibilityElement</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">self.backedTextInputView</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Focus Control</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)reactFocus</span>
<span class="s1">{</span>
  <span class="s1">[self.backedTextInputView reactFocus]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)reactBlur</span>
<span class="s1">{</span>
  <span class="s1">[self.backedTextInputView reactBlur]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)didMoveToWindow</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(self.autoFocus &amp;&amp; !_didMoveToWindow) {</span>
    <span class="s1">[self.backedTextInputView reactFocus]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">[self.backedTextInputView reactFocusIfNeeded]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">_didMoveToWindow = YES</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Custom Input Accessory View</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)didSetProps:(NSArray&lt;NSString *&gt; *)changedProps</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">([changedProps containsObject:</span><span class="s4">@</span><span class="s3">&quot;inputAccessoryViewID&quot;</span><span class="s1">] &amp;&amp; self.inputAccessoryViewID) {</span>
    <span class="s1">[self setCustomInputAccessoryViewWithNativeID:self.inputAccessoryViewID]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(!self.inputAccessoryViewID) {</span>
    <span class="s1">[self setDefaultInputAccessoryView]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setCustomInputAccessoryViewWithNativeID:(NSString *)nativeID</span>
<span class="s1">{</span>
  <span class="s4">__weak </span><span class="s1">RCTBaseTextInputView *weakSelf = self</span><span class="s4">;</span>
  <span class="s1">[_bridge.uiManager rootViewForReactTag:self.reactTag</span>
                          <span class="s1">withCompletion:^(UIView *rootView) {</span>
                            <span class="s1">RCTBaseTextInputView *strongSelf = weakSelf</span><span class="s4">;</span>
                            <span class="s4">if </span><span class="s1">(rootView) {</span>
                              <span class="s1">UIView *accessoryView = [strongSelf-&gt;_bridge.uiManager viewForNativeID:nativeID</span>
                                                                                         <span class="s1">withRootTag:rootView.reactTag]</span><span class="s4">;</span>
                              <span class="s4">if </span><span class="s1">(accessoryView &amp;&amp; [accessoryView isKindOfClass:[RCTInputAccessoryView </span><span class="s4">class</span><span class="s1">]]) {</span>
                                <span class="s1">strongSelf.backedTextInputView.inputAccessoryView =</span>
                                    <span class="s1">((RCTInputAccessoryView *)accessoryView).inputAccessoryView</span><span class="s4">;</span>
                                <span class="s1">[strongSelf reloadInputViewsIfNecessary]</span><span class="s4">;</span>
                              <span class="s1">}</span>
                            <span class="s1">}</span>
                          <span class="s1">}]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setDefaultInputAccessoryView</span>
<span class="s1">{</span>
  <span class="s1">UIView&lt;RCTBackedTextInputViewProtocol&gt; *textInputView = self.backedTextInputView</span><span class="s4">;</span>
  <span class="s1">UIKeyboardType keyboardType = textInputView.keyboardType</span><span class="s4">;</span>

  <span class="s0">// These keyboard types (all are number pads) don't have a &quot;Done&quot; button by default,</span>
  <span class="s0">// so we create an `inputAccessoryView` with this button for them.</span>
  <span class="s1">BOOL shouldHaveInputAccessoryView =</span>
      <span class="s1">(keyboardType == UIKeyboardTypeNumberPad || keyboardType == UIKeyboardTypePhonePad ||</span>
       <span class="s1">keyboardType == UIKeyboardTypeDecimalPad || keyboardType == UIKeyboardTypeASCIICapableNumberPad) &amp;&amp;</span>
      <span class="s1">textInputView.returnKeyType == UIReturnKeyDone</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(_hasInputAccessoryView == shouldHaveInputAccessoryView) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">_hasInputAccessoryView = shouldHaveInputAccessoryView</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(shouldHaveInputAccessoryView) {</span>
    <span class="s1">UIToolbar *toolbarView = [UIToolbar new]</span><span class="s4">;</span>
    <span class="s1">[toolbarView sizeToFit]</span><span class="s4">;</span>
    <span class="s1">UIBarButtonItem *flexibleSpace =</span>
        <span class="s1">[[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil]</span><span class="s4">;</span>
    <span class="s1">UIBarButtonItem *doneButton =</span>
        <span class="s1">[[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemDone</span>
                                                      <span class="s1">target:self</span>
                                                      <span class="s1">action:</span><span class="s4">@selector</span><span class="s1">(handleInputAccessoryDoneButton)]</span><span class="s4">;</span>
    <span class="s1">toolbarView.items = </span><span class="s4">@</span><span class="s1">[ flexibleSpace</span><span class="s4">, </span><span class="s1">doneButton ]</span><span class="s4">;</span>
    <span class="s1">textInputView.inputAccessoryView = toolbarView</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">textInputView.inputAccessoryView = nil</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">[self reloadInputViewsIfNecessary]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)reloadInputViewsIfNecessary</span>
<span class="s1">{</span>
  <span class="s0">// We have to call `reloadInputViews` for focused text inputs to update an accessory view.</span>
  <span class="s4">if </span><span class="s1">(self.backedTextInputView.isFirstResponder) {</span>
    <span class="s1">[self.backedTextInputView reloadInputViews]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)handleInputAccessoryDoneButton</span>
<span class="s1">{</span>
  <span class="s0">// Ignore the value of whether we submitted; just make sure the submit event is called if necessary.</span>
  <span class="s1">[self textInputShouldSubmitOnReturn]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">([self textInputShouldReturn]) {</span>
    <span class="s1">[self.backedTextInputView endEditing:YES]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Helpers</span>

<span class="s4">static </span><span class="s1">BOOL findMismatch(NSString *first</span><span class="s4">, </span><span class="s1">NSString *second</span><span class="s4">, </span><span class="s1">NSRange *firstRange</span><span class="s4">, </span><span class="s1">NSRange *secondRange)</span>
<span class="s1">{</span>
  <span class="s1">NSInteger firstMismatch = -</span><span class="s5">1</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(NSUInteger ii = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">ii &lt; MAX(first.length</span><span class="s4">, </span><span class="s1">second.length)</span><span class="s4">; </span><span class="s1">ii++) {</span>
    <span class="s4">if </span><span class="s1">(ii &gt;= first.length || ii &gt;= second.length || [first characterAtIndex:ii] != [second characterAtIndex:ii]) {</span>
      <span class="s1">firstMismatch = ii</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(firstMismatch == -</span><span class="s5">1</span><span class="s1">) {</span>
    <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">NSUInteger ii = second.length</span><span class="s4">;</span>
  <span class="s1">NSUInteger lastMismatch = first.length</span><span class="s4">;</span>
  <span class="s4">while </span><span class="s1">(ii &gt; firstMismatch &amp;&amp; lastMismatch &gt; firstMismatch) {</span>
    <span class="s4">if </span><span class="s1">([first characterAtIndex:(lastMismatch - </span><span class="s5">1</span><span class="s1">)] != [second characterAtIndex:(ii - </span><span class="s5">1</span><span class="s1">)]) {</span>
      <span class="s4">break;</span>
    <span class="s1">}</span>
    <span class="s1">ii--</span><span class="s4">;</span>
    <span class="s1">lastMismatch--</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">*firstRange = NSMakeRange(firstMismatch</span><span class="s4">, </span><span class="s1">lastMismatch - firstMismatch)</span><span class="s4">;</span>
  <span class="s1">*secondRange = NSMakeRange(firstMismatch</span><span class="s4">, </span><span class="s1">ii - firstMismatch)</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">@end</span>
</pre>
</body>
</html>
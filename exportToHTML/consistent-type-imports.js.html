<html>
<head>
<title>consistent-type-imports.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
consistent-type-imports.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || </span><span class="s2">function </span><span class="s1">(mod) {</span>
    <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
    <span class="s2">var </span><span class="s1">result = {};</span>
    <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">mod) </span><span class="s2">if </span><span class="s1">(k !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);</span>
    <span class="s1">__setModuleDefault(result, mod);</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">};</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">const utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s1">const util = __importStar(require(</span><span class="s0">&quot;../util&quot;</span><span class="s1">));</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= util.createRule({</span>
    <span class="s1">name: </span><span class="s0">'consistent-type-imports'</span><span class="s1">,</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s0">'suggestion'</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">'Enforce consistent usage of type imports'</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">messages: {</span>
            <span class="s1">typeOverValue: </span><span class="s0">'All imports in the declaration are only used as types. Use `import type`.'</span><span class="s1">,</span>
            <span class="s1">someImportsAreOnlyTypes: </span><span class="s0">'Imports {{typeImports}} are only used as types.'</span><span class="s1">,</span>
            <span class="s1">aImportIsOnlyTypes: </span><span class="s0">'Import {{typeImports}} is only used as types.'</span><span class="s1">,</span>
            <span class="s1">someImportsInDecoMeta: </span><span class="s0">'Type imports {{typeImports}} are used by decorator metadata.'</span><span class="s1">,</span>
            <span class="s1">aImportInDecoMeta: </span><span class="s0">'Type import {{typeImports}} is used by decorator metadata.'</span><span class="s1">,</span>
            <span class="s1">valueOverType: </span><span class="s0">'Use an `import` instead of an `import type`.'</span><span class="s1">,</span>
            <span class="s1">noImportTypeAnnotations: </span><span class="s0">'`import()` type annotations are forbidden.'</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">schema: [</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'object'</span><span class="s1">,</span>
                <span class="s1">properties: {</span>
                    <span class="s1">prefer: {</span>
                        <span class="s1">enum: [</span><span class="s0">'type-imports'</span><span class="s1">, </span><span class="s0">'no-type-imports'</span><span class="s1">],</span>
                    <span class="s1">},</span>
                    <span class="s1">disallowTypeAnnotations: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">fixStyle: {</span>
                        <span class="s1">enum: [</span><span class="s0">'separate-type-imports'</span><span class="s1">, </span><span class="s0">'inline-type-imports'</span><span class="s1">],</span>
                    <span class="s1">},</span>
                <span class="s1">},</span>
                <span class="s1">additionalProperties: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">},</span>
        <span class="s1">],</span>
        <span class="s1">fixable: </span><span class="s0">'code'</span><span class="s1">,</span>
    <span class="s1">},</span>
    <span class="s1">defaultOptions: [</span>
        <span class="s1">{</span>
            <span class="s1">prefer: </span><span class="s0">'type-imports'</span><span class="s1">,</span>
            <span class="s1">disallowTypeAnnotations: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">fixStyle: </span><span class="s0">'separate-type-imports'</span><span class="s1">,</span>
        <span class="s1">},</span>
    <span class="s1">],</span>
    <span class="s1">create(context, [option]) {</span>
        <span class="s2">var </span><span class="s1">_a, _b;</span>
        <span class="s1">const prefer = (_a = option.prefer) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _a : </span><span class="s0">'type-imports'</span><span class="s1">;</span>
        <span class="s1">const disallowTypeAnnotations = option.disallowTypeAnnotations !== </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">const fixStyle = (_b = option.fixStyle) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _b !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _b : </span><span class="s0">'separate-type-imports'</span><span class="s1">;</span>
        <span class="s1">const sourceCode = context.getSourceCode();</span>
        <span class="s1">const sourceImportsMap = {};</span>
        <span class="s2">return </span><span class="s1">Object.assign(Object.assign({}, (prefer === </span><span class="s0">'type-imports'</span>
            <span class="s1">? {</span>
                <span class="s4">// prefer type imports</span>
                <span class="s1">ImportDeclaration(node) {</span>
                    <span class="s2">var </span><span class="s1">_a;</span>
                    <span class="s1">const source = node.source.value;</span>
                    <span class="s4">// sourceImports is the object containing all the specifics for a particular import source, type or value</span>
                    <span class="s1">const sourceImports = (_a = sourceImportsMap[source]) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _a : (sourceImportsMap[source] = {</span>
                        <span class="s1">source,</span>
                        <span class="s1">reportValueImports: [],</span>
                        <span class="s1">typeOnlyNamedImport: </span><span class="s2">null</span><span class="s1">,</span>
                        <span class="s1">valueOnlyNamedImport: </span><span class="s2">null</span><span class="s1">,</span>
                        <span class="s1">valueImport: </span><span class="s2">null</span><span class="s1">, </span><span class="s4">// if only value imports</span>
                    <span class="s1">});</span>
                    <span class="s2">if </span><span class="s1">(node.importKind === </span><span class="s0">'type'</span><span class="s1">) {</span>
                        <span class="s2">if </span><span class="s1">(!sourceImports.typeOnlyNamedImport &amp;&amp;</span>
                            <span class="s1">node.specifiers.every(specifier =&gt; specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier)) {</span>
                            <span class="s4">// definitely import type { TypeX }</span>
                            <span class="s1">sourceImports.typeOnlyNamedImport = node;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s2">if </span><span class="s1">(!sourceImports.valueOnlyNamedImport &amp;&amp;</span>
                            <span class="s1">node.specifiers.every(specifier =&gt; specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier)) {</span>
                            <span class="s1">sourceImports.valueOnlyNamedImport = node;</span>
                            <span class="s1">sourceImports.valueImport = node;</span>
                        <span class="s1">}</span>
                        <span class="s2">else if </span><span class="s1">(!sourceImports.valueImport &amp;&amp;</span>
                            <span class="s1">node.specifiers.some(specifier =&gt; specifier.type === utils_1.AST_NODE_TYPES.ImportDefaultSpecifier)) {</span>
                            <span class="s1">sourceImports.valueImport = node;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s1">const typeSpecifiers = [];</span>
                    <span class="s1">const inlineTypeSpecifiers = [];</span>
                    <span class="s1">const valueSpecifiers = [];</span>
                    <span class="s1">const unusedSpecifiers = [];</span>
                    <span class="s2">for </span><span class="s1">(const specifier of node.specifiers) {</span>
                        <span class="s2">if </span><span class="s1">(specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier &amp;&amp;</span>
                            <span class="s1">specifier.importKind === </span><span class="s0">'type'</span><span class="s1">) {</span>
                            <span class="s1">inlineTypeSpecifiers.push(specifier);</span>
                            <span class="s2">continue</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s1">const [variable] = context.getDeclaredVariables(specifier);</span>
                        <span class="s2">if </span><span class="s1">(variable.references.length === </span><span class="s3">0</span><span class="s1">) {</span>
                            <span class="s1">unusedSpecifiers.push(specifier);</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">const onlyHasTypeReferences = variable.references.every(ref =&gt; {</span>
                                <span class="s2">var </span><span class="s1">_a, _b;</span>
                                <span class="s4">/** 
                                 * keep origin import kind when export 
                                 * export { Type } 
                                 * export default Type; 
                                 */</span>
                                <span class="s2">if </span><span class="s1">(((_a = ref.identifier.parent) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _a.type) ===</span>
                                    <span class="s1">utils_1.AST_NODE_TYPES.ExportSpecifier ||</span>
                                    <span class="s1">((_b = ref.identifier.parent) === </span><span class="s2">null </span><span class="s1">|| _b === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _b.type) ===</span>
                                        <span class="s1">utils_1.AST_NODE_TYPES.ExportDefaultDeclaration) {</span>
                                    <span class="s2">if </span><span class="s1">(ref.isValueReference &amp;&amp; ref.isTypeReference) {</span>
                                        <span class="s2">return </span><span class="s1">node.importKind === </span><span class="s0">'type'</span><span class="s1">;</span>
                                    <span class="s1">}</span>
                                <span class="s1">}</span>
                                <span class="s2">if </span><span class="s1">(ref.isValueReference) {</span>
                                    <span class="s1">let parent = ref.identifier.parent;</span>
                                    <span class="s1">let child = ref.identifier;</span>
                                    <span class="s2">while </span><span class="s1">(parent) {</span>
                                        <span class="s2">switch </span><span class="s1">(parent.type) {</span>
                                            <span class="s4">// CASE 1:</span>
                                            <span class="s4">// `type T = typeof foo` will create a value reference because &quot;foo&quot; must be a value type</span>
                                            <span class="s4">// however this value reference is safe to use with type-only imports</span>
                                            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSTypeQuery:</span>
                                                <span class="s2">return true</span><span class="s1">;</span>
                                            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSQualifiedName:</span>
                                                <span class="s4">// TSTypeQuery must have a TSESTree.EntityName as its child, so we can filter here and break early</span>
                                                <span class="s2">if </span><span class="s1">(parent.left !== child) {</span>
                                                    <span class="s2">return false</span><span class="s1">;</span>
                                                <span class="s1">}</span>
                                                <span class="s1">child = parent;</span>
                                                <span class="s1">parent = parent.parent;</span>
                                                <span class="s2">continue</span><span class="s1">;</span>
                                            <span class="s4">// END CASE 1</span>
                                            <span class="s4">//////////////</span>
                                            <span class="s4">// CASE 2:</span>
                                            <span class="s4">// `type T = { [foo]: string }` will create a value reference because &quot;foo&quot; must be a value type</span>
                                            <span class="s4">// however this value reference is safe to use with type-only imports.</span>
                                            <span class="s4">// Also this is represented as a non-type AST - hence it uses MemberExpression</span>
                                            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSPropertySignature:</span>
                                                <span class="s2">return </span><span class="s1">parent.key === child;</span>
                                            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.MemberExpression:</span>
                                                <span class="s2">if </span><span class="s1">(parent.object !== child) {</span>
                                                    <span class="s2">return false</span><span class="s1">;</span>
                                                <span class="s1">}</span>
                                                <span class="s1">child = parent;</span>
                                                <span class="s1">parent = parent.parent;</span>
                                                <span class="s2">continue</span><span class="s1">;</span>
                                            <span class="s4">// END CASE 2</span>
                                            <span class="s2">default</span><span class="s1">:</span>
                                                <span class="s2">return false</span><span class="s1">;</span>
                                        <span class="s1">}</span>
                                    <span class="s1">}</span>
                                <span class="s1">}</span>
                                <span class="s2">return </span><span class="s1">ref.isTypeReference;</span>
                            <span class="s1">});</span>
                            <span class="s2">if </span><span class="s1">(onlyHasTypeReferences) {</span>
                                <span class="s1">typeSpecifiers.push(specifier);</span>
                            <span class="s1">}</span>
                            <span class="s2">else </span><span class="s1">{</span>
                                <span class="s1">valueSpecifiers.push(specifier);</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">((node.importKind === </span><span class="s0">'value' </span><span class="s1">&amp;&amp; typeSpecifiers.length) ||</span>
                        <span class="s1">(node.importKind === </span><span class="s0">'type' </span><span class="s1">&amp;&amp; valueSpecifiers.length)) {</span>
                        <span class="s1">sourceImports.reportValueImports.push({</span>
                            <span class="s1">node,</span>
                            <span class="s1">typeSpecifiers,</span>
                            <span class="s1">valueSpecifiers,</span>
                            <span class="s1">unusedSpecifiers,</span>
                            <span class="s1">inlineTypeSpecifiers,</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">},</span>
                <span class="s0">'Program:exit'</span><span class="s1">() {</span>
                    <span class="s2">for </span><span class="s1">(const sourceImports of Object.values(sourceImportsMap)) {</span>
                        <span class="s2">if </span><span class="s1">(sourceImports.reportValueImports.length === </span><span class="s3">0</span><span class="s1">) {</span>
                            <span class="s4">// nothing to fix. value specifiers and type specifiers are correctly written</span>
                            <span class="s2">continue</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s2">for </span><span class="s1">(const report of sourceImports.reportValueImports) {</span>
                            <span class="s2">if </span><span class="s1">(report.valueSpecifiers.length === </span><span class="s3">0 </span><span class="s1">&amp;&amp;</span>
                                <span class="s1">report.unusedSpecifiers.length === </span><span class="s3">0 </span><span class="s1">&amp;&amp;</span>
                                <span class="s1">report.node.importKind !== </span><span class="s0">'type'</span><span class="s1">) {</span>
                                <span class="s1">context.report({</span>
                                    <span class="s1">node: report.node,</span>
                                    <span class="s1">messageId: </span><span class="s0">'typeOverValue'</span><span class="s1">,</span>
                                    <span class="s1">*fix(fixer) {</span>
                                        <span class="s1">yield* fixToTypeImportDeclaration(fixer, report, sourceImports);</span>
                                    <span class="s1">},</span>
                                <span class="s1">});</span>
                            <span class="s1">}</span>
                            <span class="s2">else </span><span class="s1">{</span>
                                <span class="s1">const isTypeImport = report.node.importKind === </span><span class="s0">'type'</span><span class="s1">;</span>
                                <span class="s4">// we have a mixed type/value import or just value imports, so we need to split them out into multiple imports if separate-type-imports is configured</span>
                                <span class="s1">const importNames = (isTypeImport</span>
                                    <span class="s1">? report.valueSpecifiers </span><span class="s4">// import type { A } from 'roo'; // WHERE A is used in value position</span>
                                    <span class="s1">: report.typeSpecifiers) </span><span class="s4">// import { A, B } from 'roo'; // WHERE A is used in type position and B is in value position</span>
                                    <span class="s1">.map(specifier =&gt; `</span><span class="s0">&quot;${specifier.local.name}&quot;</span><span class="s1">`);</span>
                                <span class="s1">const message = (() =&gt; {</span>
                                    <span class="s1">const typeImports = util.formatWordList(importNames);</span>
                                    <span class="s2">if </span><span class="s1">(importNames.length === </span><span class="s3">1</span><span class="s1">) {</span>
                                        <span class="s2">if </span><span class="s1">(isTypeImport) {</span>
                                            <span class="s2">return </span><span class="s1">{</span>
                                                <span class="s1">messageId: </span><span class="s0">'aImportInDecoMeta'</span><span class="s1">,</span>
                                                <span class="s1">data: { typeImports },</span>
                                            <span class="s1">};</span>
                                        <span class="s1">}</span>
                                        <span class="s2">else </span><span class="s1">{</span>
                                            <span class="s2">return </span><span class="s1">{</span>
                                                <span class="s1">messageId: </span><span class="s0">'aImportIsOnlyTypes'</span><span class="s1">,</span>
                                                <span class="s1">data: { typeImports },</span>
                                            <span class="s1">};</span>
                                        <span class="s1">}</span>
                                    <span class="s1">}</span>
                                    <span class="s2">else </span><span class="s1">{</span>
                                        <span class="s2">if </span><span class="s1">(isTypeImport) {</span>
                                            <span class="s2">return </span><span class="s1">{</span>
                                                <span class="s1">messageId: </span><span class="s0">'someImportsInDecoMeta'</span><span class="s1">,</span>
                                                <span class="s1">data: { typeImports }, </span><span class="s4">// typeImports are all the value specifiers that are in the type position</span>
                                            <span class="s1">};</span>
                                        <span class="s1">}</span>
                                        <span class="s2">else </span><span class="s1">{</span>
                                            <span class="s2">return </span><span class="s1">{</span>
                                                <span class="s1">messageId: </span><span class="s0">'someImportsAreOnlyTypes'</span><span class="s1">,</span>
                                                <span class="s1">data: { typeImports }, </span><span class="s4">// typeImports are all the type specifiers in the value position</span>
                                            <span class="s1">};</span>
                                        <span class="s1">}</span>
                                    <span class="s1">}</span>
                                <span class="s1">})();</span>
                                <span class="s1">context.report(Object.assign(Object.assign({ node: report.node }, message), { *fix(fixer) {</span>
                                        <span class="s2">if </span><span class="s1">(isTypeImport) {</span>
                                            <span class="s4">// take all the valueSpecifiers and put them on a new line</span>
                                            <span class="s1">yield* fixToValueImportDeclaration(fixer, report, sourceImports);</span>
                                        <span class="s1">}</span>
                                        <span class="s2">else </span><span class="s1">{</span>
                                            <span class="s4">// take all the typeSpecifiers and put them on a new line</span>
                                            <span class="s1">yield* fixToTypeImportDeclaration(fixer, report, sourceImports);</span>
                                        <span class="s1">}</span>
                                    <span class="s1">} }));</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">},</span>
            <span class="s1">}</span>
            <span class="s1">: {</span>
                <span class="s4">// prefer no type imports</span>
                <span class="s0">'ImportDeclaration[importKind = &quot;type&quot;]'</span><span class="s1">(node) {</span>
                    <span class="s1">context.report({</span>
                        <span class="s1">node,</span>
                        <span class="s1">messageId: </span><span class="s0">'valueOverType'</span><span class="s1">,</span>
                        <span class="s1">fix(fixer) {</span>
                            <span class="s2">return </span><span class="s1">fixRemoveTypeSpecifierFromImportDeclaration(fixer, node);</span>
                        <span class="s1">},</span>
                    <span class="s1">});</span>
                <span class="s1">},</span>
                <span class="s0">'ImportSpecifier[importKind = &quot;type&quot;]'</span><span class="s1">(node) {</span>
                    <span class="s1">context.report({</span>
                        <span class="s1">node,</span>
                        <span class="s1">messageId: </span><span class="s0">'valueOverType'</span><span class="s1">,</span>
                        <span class="s1">fix(fixer) {</span>
                            <span class="s2">return </span><span class="s1">fixRemoveTypeSpecifierFromImportSpecifier(fixer, node);</span>
                        <span class="s1">},</span>
                    <span class="s1">});</span>
                <span class="s1">},</span>
            <span class="s1">})), (disallowTypeAnnotations</span>
            <span class="s1">? {</span>
                <span class="s4">// disallow `import()` type</span>
                <span class="s1">TSImportType(node) {</span>
                    <span class="s1">context.report({</span>
                        <span class="s1">node,</span>
                        <span class="s1">messageId: </span><span class="s0">'noImportTypeAnnotations'</span><span class="s1">,</span>
                    <span class="s1">});</span>
                <span class="s1">},</span>
            <span class="s1">}</span>
            <span class="s1">: {}));</span>
        <span class="s2">function </span><span class="s1">classifySpecifier(node) {</span>
            <span class="s2">var </span><span class="s1">_a;</span>
            <span class="s1">const defaultSpecifier = node.specifiers[</span><span class="s3">0</span><span class="s1">].type === utils_1.AST_NODE_TYPES.ImportDefaultSpecifier</span>
                <span class="s1">? node.specifiers[</span><span class="s3">0</span><span class="s1">]</span>
                <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s1">const namespaceSpecifier = (_a = node.specifiers.find((specifier) =&gt; specifier.type === utils_1.AST_NODE_TYPES.ImportNamespaceSpecifier)) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _a : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s1">const namedSpecifiers = node.specifiers.filter((specifier) =&gt; specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier);</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">defaultSpecifier,</span>
                <span class="s1">namespaceSpecifier,</span>
                <span class="s1">namedSpecifiers,</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Returns information for fixing named specifiers, type or value 
         */</span>
        <span class="s2">function </span><span class="s1">getFixesNamedSpecifiers(fixer, node, subsetNamedSpecifiers, allNamedSpecifiers) {</span>
            <span class="s2">if </span><span class="s1">(allNamedSpecifiers.length === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">typeNamedSpecifiersText: </span><span class="s0">''</span><span class="s1">,</span>
                    <span class="s1">removeTypeNamedSpecifiers: [],</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s1">const typeNamedSpecifiersTexts = [];</span>
            <span class="s1">const removeTypeNamedSpecifiers = [];</span>
            <span class="s2">if </span><span class="s1">(subsetNamedSpecifiers.length === allNamedSpecifiers.length) {</span>
                <span class="s4">// import Foo, {Type1, Type2} from 'foo'</span>
                <span class="s4">// import DefType, {Type1, Type2} from 'foo'</span>
                <span class="s1">const openingBraceToken = util.nullThrows(sourceCode.getTokenBefore(subsetNamedSpecifiers[</span><span class="s3">0</span><span class="s1">], util.isOpeningBraceToken), util.NullThrowsReasons.MissingToken(</span><span class="s0">'{'</span><span class="s1">, node.type));</span>
                <span class="s1">const commaToken = util.nullThrows(sourceCode.getTokenBefore(openingBraceToken, util.isCommaToken), util.NullThrowsReasons.MissingToken(</span><span class="s0">','</span><span class="s1">, node.type));</span>
                <span class="s1">const closingBraceToken = util.nullThrows(sourceCode.getFirstTokenBetween(openingBraceToken, node.source, util.isClosingBraceToken), util.NullThrowsReasons.MissingToken(</span><span class="s0">'}'</span><span class="s1">, node.type));</span>
                <span class="s4">// import DefType, {...} from 'foo'</span>
                <span class="s4">//               ^^^^^^^ remove</span>
                <span class="s1">removeTypeNamedSpecifiers.push(fixer.removeRange([commaToken.range[</span><span class="s3">0</span><span class="s1">], closingBraceToken.range[</span><span class="s3">1</span><span class="s1">]]));</span>
                <span class="s1">typeNamedSpecifiersTexts.push(sourceCode.text.slice(openingBraceToken.range[</span><span class="s3">1</span><span class="s1">], closingBraceToken.range[</span><span class="s3">0</span><span class="s1">]));</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">const namedSpecifierGroups = [];</span>
                <span class="s1">let group = [];</span>
                <span class="s2">for </span><span class="s1">(const namedSpecifier of allNamedSpecifiers) {</span>
                    <span class="s2">if </span><span class="s1">(subsetNamedSpecifiers.includes(namedSpecifier)) {</span>
                        <span class="s1">group.push(namedSpecifier);</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(group.length) {</span>
                        <span class="s1">namedSpecifierGroups.push(group);</span>
                        <span class="s1">group = [];</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(group.length) {</span>
                    <span class="s1">namedSpecifierGroups.push(group);</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(const namedSpecifiers of namedSpecifierGroups) {</span>
                    <span class="s1">const { removeRange, textRange } = getNamedSpecifierRanges(namedSpecifiers, allNamedSpecifiers);</span>
                    <span class="s1">removeTypeNamedSpecifiers.push(fixer.removeRange(removeRange));</span>
                    <span class="s1">typeNamedSpecifiersTexts.push(sourceCode.text.slice(...textRange));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">typeNamedSpecifiersText: typeNamedSpecifiersTexts.join(</span><span class="s0">','</span><span class="s1">),</span>
                <span class="s1">removeTypeNamedSpecifiers,</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Returns ranges for fixing named specifier. 
         */</span>
        <span class="s2">function </span><span class="s1">getNamedSpecifierRanges(namedSpecifierGroup, allNamedSpecifiers) {</span>
            <span class="s1">const first = namedSpecifierGroup[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s1">const last = namedSpecifierGroup[namedSpecifierGroup.length - </span><span class="s3">1</span><span class="s1">];</span>
            <span class="s1">const removeRange = [first.range[</span><span class="s3">0</span><span class="s1">], last.range[</span><span class="s3">1</span><span class="s1">]];</span>
            <span class="s1">const textRange = [...removeRange];</span>
            <span class="s1">const before = sourceCode.getTokenBefore(first);</span>
            <span class="s1">textRange[</span><span class="s3">0</span><span class="s1">] = before.range[</span><span class="s3">1</span><span class="s1">];</span>
            <span class="s2">if </span><span class="s1">(util.isCommaToken(before)) {</span>
                <span class="s1">removeRange[</span><span class="s3">0</span><span class="s1">] = before.range[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">removeRange[</span><span class="s3">0</span><span class="s1">] = before.range[</span><span class="s3">1</span><span class="s1">];</span>
            <span class="s1">}</span>
            <span class="s1">const isFirst = allNamedSpecifiers[</span><span class="s3">0</span><span class="s1">] === first;</span>
            <span class="s1">const isLast = allNamedSpecifiers[allNamedSpecifiers.length - </span><span class="s3">1</span><span class="s1">] === last;</span>
            <span class="s1">const after = sourceCode.getTokenAfter(last);</span>
            <span class="s1">textRange[</span><span class="s3">1</span><span class="s1">] = after.range[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s2">if </span><span class="s1">(isFirst || isLast) {</span>
                <span class="s2">if </span><span class="s1">(util.isCommaToken(after)) {</span>
                    <span class="s1">removeRange[</span><span class="s3">1</span><span class="s1">] = after.range[</span><span class="s3">1</span><span class="s1">];</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">textRange,</span>
                <span class="s1">removeRange,</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * insert specifiers to named import node. 
         * e.g. 
         * import type { Already, Type1, Type2 } from 'foo' 
         *                        ^^^^^^^^^^^^^ insert 
         */</span>
        <span class="s2">function </span><span class="s1">fixInsertNamedSpecifiersInNamedSpecifierList(fixer, target, insertText) {</span>
            <span class="s1">const closingBraceToken = util.nullThrows(sourceCode.getFirstTokenBetween(sourceCode.getFirstToken(target), target.source, util.isClosingBraceToken), util.NullThrowsReasons.MissingToken(</span><span class="s0">'}'</span><span class="s1">, target.type));</span>
            <span class="s1">const before = sourceCode.getTokenBefore(closingBraceToken);</span>
            <span class="s2">if </span><span class="s1">(!util.isCommaToken(before) &amp;&amp; !util.isOpeningBraceToken(before)) {</span>
                <span class="s1">insertText = `,${insertText}`;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">fixer.insertTextBefore(closingBraceToken, insertText);</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * insert type keyword to named import node. 
         * e.g. 
         * import ADefault, { Already, type Type1, type Type2 } from 'foo' 
         *                             ^^^^ insert 
         */</span>
        <span class="s2">function</span><span class="s1">* fixInsertTypeKeywordInNamedSpecifierList(fixer, typeSpecifiers) {</span>
            <span class="s2">for </span><span class="s1">(const spec of typeSpecifiers) {</span>
                <span class="s1">const insertText = sourceCode.text.slice(...spec.range);</span>
                <span class="s1">yield fixer.replaceTextRange(spec.range, `type ${insertText}`);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">function</span><span class="s1">* fixInlineTypeImportDeclaration(fixer, report, sourceImports) {</span>
            <span class="s1">const { node } = report;</span>
            <span class="s4">// For a value import, will only add an inline type to named specifiers</span>
            <span class="s1">const { namedSpecifiers } = classifySpecifier(node);</span>
            <span class="s1">const typeNamedSpecifiers = namedSpecifiers.filter(specifier =&gt; report.typeSpecifiers.includes(specifier));</span>
            <span class="s2">if </span><span class="s1">(sourceImports.valueImport) {</span>
                <span class="s4">// add import named type specifiers to its value import</span>
                <span class="s4">// import ValueA, { type A }</span>
                <span class="s4">//                  ^^^^ insert</span>
                <span class="s1">const { namedSpecifiers: valueImportNamedSpecifiers } = classifySpecifier(sourceImports.valueImport);</span>
                <span class="s2">if </span><span class="s1">(sourceImports.valueOnlyNamedImport ||</span>
                    <span class="s1">valueImportNamedSpecifiers.length) {</span>
                    <span class="s1">yield* fixInsertTypeKeywordInNamedSpecifierList(fixer, typeNamedSpecifiers);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">function</span><span class="s1">* fixToTypeImportDeclaration(fixer, report, sourceImports) {</span>
            <span class="s1">const { node } = report;</span>
            <span class="s1">const { defaultSpecifier, namespaceSpecifier, namedSpecifiers } = classifySpecifier(node);</span>
            <span class="s2">if </span><span class="s1">(namespaceSpecifier &amp;&amp; !defaultSpecifier) {</span>
                <span class="s4">// import * as types from 'foo'</span>
                <span class="s1">yield* fixInsertTypeSpecifierForImportDeclaration(fixer, node, </span><span class="s2">false</span><span class="s1">);</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(defaultSpecifier) {</span>
                <span class="s2">if </span><span class="s1">(report.typeSpecifiers.includes(defaultSpecifier) &amp;&amp;</span>
                    <span class="s1">namedSpecifiers.length === </span><span class="s3">0 </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">!namespaceSpecifier) {</span>
                    <span class="s4">// import Type from 'foo'</span>
                    <span class="s1">yield* fixInsertTypeSpecifierForImportDeclaration(fixer, node, </span><span class="s2">true</span><span class="s1">);</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(fixStyle === </span><span class="s0">'inline-type-imports' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">!report.typeSpecifiers.includes(defaultSpecifier) &amp;&amp;</span>
                    <span class="s1">namedSpecifiers.length &gt; </span><span class="s3">0 </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">!namespaceSpecifier) {</span>
                    <span class="s4">// if there is a default specifier but it isn't a type specifier, then just add the inline type modifier to the named specifiers</span>
                    <span class="s4">// import AValue, {BValue, Type1, Type2} from 'foo'</span>
                    <span class="s1">yield* fixInlineTypeImportDeclaration(fixer, report, sourceImports);</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!namespaceSpecifier) {</span>
                <span class="s2">if </span><span class="s1">(fixStyle === </span><span class="s0">'inline-type-imports' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">namedSpecifiers.some(specifier =&gt; report.typeSpecifiers.includes(specifier))) {</span>
                    <span class="s4">// import {AValue, Type1, Type2} from 'foo'</span>
                    <span class="s1">yield* fixInlineTypeImportDeclaration(fixer, report, sourceImports);</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(namedSpecifiers.every(specifier =&gt; report.typeSpecifiers.includes(specifier))) {</span>
                    <span class="s4">// import {Type1, Type2} from 'foo'</span>
                    <span class="s1">yield* fixInsertTypeSpecifierForImportDeclaration(fixer, node, </span><span class="s2">false</span><span class="s1">);</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">const typeNamedSpecifiers = namedSpecifiers.filter(specifier =&gt; report.typeSpecifiers.includes(specifier));</span>
            <span class="s1">const fixesNamedSpecifiers = getFixesNamedSpecifiers(fixer, node, typeNamedSpecifiers, namedSpecifiers);</span>
            <span class="s1">const afterFixes = [];</span>
            <span class="s2">if </span><span class="s1">(typeNamedSpecifiers.length) {</span>
                <span class="s2">if </span><span class="s1">(sourceImports.typeOnlyNamedImport) {</span>
                    <span class="s1">const insertTypeNamedSpecifiers = fixInsertNamedSpecifiersInNamedSpecifierList(fixer, sourceImports.typeOnlyNamedImport, fixesNamedSpecifiers.typeNamedSpecifiersText);</span>
                    <span class="s2">if </span><span class="s1">(sourceImports.typeOnlyNamedImport.range[</span><span class="s3">1</span><span class="s1">] &lt;= node.range[</span><span class="s3">0</span><span class="s1">]) {</span>
                        <span class="s1">yield insertTypeNamedSpecifiers;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">afterFixes.push(insertTypeNamedSpecifiers);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// The import is both default and named.  Insert named on new line because can't mix default type import and named type imports</span>
                    <span class="s2">if </span><span class="s1">(fixStyle === </span><span class="s0">'inline-type-imports'</span><span class="s1">) {</span>
                        <span class="s1">yield fixer.insertTextBefore(node, `import {${typeNamedSpecifiers</span>
                            <span class="s1">.map(spec =&gt; {</span>
                            <span class="s1">const insertText = sourceCode.text.slice(...spec.range);</span>
                            <span class="s2">return </span><span class="s1">`type ${insertText}`;</span>
                        <span class="s1">})</span>
                            <span class="s1">.join(</span><span class="s0">', '</span><span class="s1">)}} from ${sourceCode.getText(node.source)};\n`);</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">yield fixer.insertTextBefore(node, `import type {${fixesNamedSpecifiers.typeNamedSpecifiersText}} from ${sourceCode.getText(node.source)};\n`);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">const fixesRemoveTypeNamespaceSpecifier = [];</span>
            <span class="s2">if </span><span class="s1">(namespaceSpecifier &amp;&amp;</span>
                <span class="s1">report.typeSpecifiers.includes(namespaceSpecifier)) {</span>
                <span class="s4">// import Foo, * as Type from 'foo'</span>
                <span class="s4">// import DefType, * as Type from 'foo'</span>
                <span class="s4">// import DefType, * as Type from 'foo'</span>
                <span class="s1">const commaToken = util.nullThrows(sourceCode.getTokenBefore(namespaceSpecifier, util.isCommaToken), util.NullThrowsReasons.MissingToken(</span><span class="s0">','</span><span class="s1">, node.type));</span>
                <span class="s4">// import Def, * as Ns from 'foo'</span>
                <span class="s4">//           ^^^^^^^^^ remove</span>
                <span class="s1">fixesRemoveTypeNamespaceSpecifier.push(fixer.removeRange([commaToken.range[</span><span class="s3">0</span><span class="s1">], namespaceSpecifier.range[</span><span class="s3">1</span><span class="s1">]]));</span>
                <span class="s4">// import type * as Ns from 'foo'</span>
                <span class="s4">// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ insert</span>
                <span class="s1">yield fixer.insertTextBefore(node, `import type ${sourceCode.getText(namespaceSpecifier)} from ${sourceCode.getText(node.source)};\n`);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(defaultSpecifier &amp;&amp;</span>
                <span class="s1">report.typeSpecifiers.includes(defaultSpecifier)) {</span>
                <span class="s2">if </span><span class="s1">(report.typeSpecifiers.length === node.specifiers.length) {</span>
                    <span class="s1">const importToken = util.nullThrows(sourceCode.getFirstToken(node, util.isImportKeyword), util.NullThrowsReasons.MissingToken(</span><span class="s0">'import'</span><span class="s1">, node.type));</span>
                    <span class="s4">// import type Type from 'foo'</span>
                    <span class="s4">//        ^^^^ insert</span>
                    <span class="s1">yield fixer.insertTextAfter(importToken, </span><span class="s0">' type'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">const commaToken = util.nullThrows(sourceCode.getTokenAfter(defaultSpecifier, util.isCommaToken), util.NullThrowsReasons.MissingToken(</span><span class="s0">','</span><span class="s1">, defaultSpecifier.type));</span>
                    <span class="s4">// import Type , {...} from 'foo'</span>
                    <span class="s4">//        ^^^^^ pick</span>
                    <span class="s1">const defaultText = sourceCode.text</span>
                        <span class="s1">.slice(defaultSpecifier.range[</span><span class="s3">0</span><span class="s1">], commaToken.range[</span><span class="s3">0</span><span class="s1">])</span>
                        <span class="s1">.trim();</span>
                    <span class="s1">yield fixer.insertTextBefore(node, `import type ${defaultText} from ${sourceCode.getText(node.source)};\n`);</span>
                    <span class="s1">const afterToken = util.nullThrows(sourceCode.getTokenAfter(commaToken, { includeComments: </span><span class="s2">true </span><span class="s1">}), util.NullThrowsReasons.MissingToken(</span><span class="s0">'any token'</span><span class="s1">, node.type));</span>
                    <span class="s4">// import Type , {...} from 'foo'</span>
                    <span class="s4">//        ^^^^^^^ remove</span>
                    <span class="s1">yield fixer.removeRange([</span>
                        <span class="s1">defaultSpecifier.range[</span><span class="s3">0</span><span class="s1">],</span>
                        <span class="s1">afterToken.range[</span><span class="s3">0</span><span class="s1">],</span>
                    <span class="s1">]);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">yield* fixesNamedSpecifiers.removeTypeNamedSpecifiers;</span>
            <span class="s1">yield* fixesRemoveTypeNamespaceSpecifier;</span>
            <span class="s1">yield* afterFixes;</span>
        <span class="s1">}</span>
        <span class="s2">function</span><span class="s1">* fixInsertTypeSpecifierForImportDeclaration(fixer, node, isDefaultImport) {</span>
            <span class="s4">// import type Foo from 'foo'</span>
            <span class="s4">//       ^^^^^ insert</span>
            <span class="s1">const importToken = util.nullThrows(sourceCode.getFirstToken(node, util.isImportKeyword), util.NullThrowsReasons.MissingToken(</span><span class="s0">'import'</span><span class="s1">, node.type));</span>
            <span class="s1">yield fixer.insertTextAfter(importToken, </span><span class="s0">' type'</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(isDefaultImport) {</span>
                <span class="s4">// Has default import</span>
                <span class="s1">const openingBraceToken = sourceCode.getFirstTokenBetween(importToken, node.source, util.isOpeningBraceToken);</span>
                <span class="s2">if </span><span class="s1">(openingBraceToken) {</span>
                    <span class="s4">// Only braces. e.g. import Foo, {} from 'foo'</span>
                    <span class="s1">const commaToken = util.nullThrows(sourceCode.getTokenBefore(openingBraceToken, util.isCommaToken), util.NullThrowsReasons.MissingToken(</span><span class="s0">','</span><span class="s1">, node.type));</span>
                    <span class="s1">const closingBraceToken = util.nullThrows(sourceCode.getFirstTokenBetween(openingBraceToken, node.source, util.isClosingBraceToken), util.NullThrowsReasons.MissingToken(</span><span class="s0">'}'</span><span class="s1">, node.type));</span>
                    <span class="s4">// import type Foo, {} from 'foo'</span>
                    <span class="s4">//                  ^^ remove</span>
                    <span class="s1">yield fixer.removeRange([</span>
                        <span class="s1">commaToken.range[</span><span class="s3">0</span><span class="s1">],</span>
                        <span class="s1">closingBraceToken.range[</span><span class="s3">1</span><span class="s1">],</span>
                    <span class="s1">]);</span>
                    <span class="s1">const specifiersText = sourceCode.text.slice(commaToken.range[</span><span class="s3">1</span><span class="s1">], closingBraceToken.range[</span><span class="s3">1</span><span class="s1">]);</span>
                    <span class="s2">if </span><span class="s1">(node.specifiers.length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
                        <span class="s1">yield fixer.insertTextAfter(node, `\nimport type${specifiersText} from ${sourceCode.getText(node.source)};`);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s4">// make sure we don't do anything like `import type {type T} from 'foo';`</span>
            <span class="s2">for </span><span class="s1">(const specifier of node.specifiers) {</span>
                <span class="s2">if </span><span class="s1">(specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier &amp;&amp;</span>
                    <span class="s1">specifier.importKind === </span><span class="s0">'type'</span><span class="s1">) {</span>
                    <span class="s1">yield* fixRemoveTypeSpecifierFromImportSpecifier(fixer, specifier);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">function</span><span class="s1">* fixToValueImportDeclaration(fixer, report, sourceImports) {</span>
            <span class="s1">const { node } = report;</span>
            <span class="s1">const { defaultSpecifier, namespaceSpecifier, namedSpecifiers } = classifySpecifier(node);</span>
            <span class="s2">if </span><span class="s1">(namespaceSpecifier) {</span>
                <span class="s4">// import type * as types from 'foo'</span>
                <span class="s1">yield* fixRemoveTypeSpecifierFromImportDeclaration(fixer, node);</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(defaultSpecifier) {</span>
                <span class="s2">if </span><span class="s1">(report.valueSpecifiers.includes(defaultSpecifier) &amp;&amp;</span>
                    <span class="s1">namedSpecifiers.length === </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s4">// import type Type from 'foo'</span>
                    <span class="s1">yield* fixRemoveTypeSpecifierFromImportDeclaration(fixer, node);</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(namedSpecifiers.every(specifier =&gt; report.valueSpecifiers.includes(specifier))) {</span>
                    <span class="s4">// import type {Type1, Type2} from 'foo'</span>
                    <span class="s1">yield* fixRemoveTypeSpecifierFromImportDeclaration(fixer, node);</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s4">// we have some valueSpecifiers intermixed in types that need to be put on their own line</span>
            <span class="s4">// import type { Type1, A } from 'foo'</span>
            <span class="s4">// import type { A } from 'foo'</span>
            <span class="s1">const valueNamedSpecifiers = namedSpecifiers.filter(specifier =&gt; report.valueSpecifiers.includes(specifier));</span>
            <span class="s1">const fixesNamedSpecifiers = getFixesNamedSpecifiers(fixer, node, valueNamedSpecifiers, namedSpecifiers);</span>
            <span class="s1">const afterFixes = [];</span>
            <span class="s2">if </span><span class="s1">(valueNamedSpecifiers.length) {</span>
                <span class="s2">if </span><span class="s1">(sourceImports.valueOnlyNamedImport) {</span>
                    <span class="s1">const insertTypeNamedSpecifiers = fixInsertNamedSpecifiersInNamedSpecifierList(fixer, sourceImports.valueOnlyNamedImport, fixesNamedSpecifiers.typeNamedSpecifiersText);</span>
                    <span class="s2">if </span><span class="s1">(sourceImports.valueOnlyNamedImport.range[</span><span class="s3">1</span><span class="s1">] &lt;= node.range[</span><span class="s3">0</span><span class="s1">]) {</span>
                        <span class="s1">yield insertTypeNamedSpecifiers;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">afterFixes.push(insertTypeNamedSpecifiers);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// some are types.</span>
                    <span class="s4">// Add new value import and later remove those value specifiers from import type</span>
                    <span class="s1">yield fixer.insertTextBefore(node, `import {${fixesNamedSpecifiers.typeNamedSpecifiersText}} from ${sourceCode.getText(node.source)};\n`);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">yield* fixesNamedSpecifiers.removeTypeNamedSpecifiers;</span>
            <span class="s1">yield* afterFixes;</span>
        <span class="s1">}</span>
        <span class="s2">function</span><span class="s1">* fixRemoveTypeSpecifierFromImportDeclaration(fixer, node) {</span>
            <span class="s2">var </span><span class="s1">_a, _b;</span>
            <span class="s4">// import type Foo from 'foo'</span>
            <span class="s4">//        ^^^^ remove</span>
            <span class="s1">const importToken = util.nullThrows(sourceCode.getFirstToken(node, util.isImportKeyword), util.NullThrowsReasons.MissingToken(</span><span class="s0">'import'</span><span class="s1">, node.type));</span>
            <span class="s1">const typeToken = util.nullThrows(sourceCode.getFirstTokenBetween(importToken, (_b = (_a = node.specifiers[</span><span class="s3">0</span><span class="s1">]) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _a.local) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _b !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _b : node.source, util.isTypeKeyword), util.NullThrowsReasons.MissingToken(</span><span class="s0">'type'</span><span class="s1">, node.type));</span>
            <span class="s1">const afterToken = util.nullThrows(sourceCode.getTokenAfter(typeToken, { includeComments: </span><span class="s2">true </span><span class="s1">}), util.NullThrowsReasons.MissingToken(</span><span class="s0">'any token'</span><span class="s1">, node.type));</span>
            <span class="s1">yield fixer.removeRange([typeToken.range[</span><span class="s3">0</span><span class="s1">], afterToken.range[</span><span class="s3">0</span><span class="s1">]]);</span>
        <span class="s1">}</span>
        <span class="s2">function</span><span class="s1">* fixRemoveTypeSpecifierFromImportSpecifier(fixer, node) {</span>
            <span class="s4">// import { type Foo } from 'foo'</span>
            <span class="s4">//          ^^^^ remove</span>
            <span class="s1">const typeToken = util.nullThrows(sourceCode.getFirstToken(node, util.isTypeKeyword), util.NullThrowsReasons.MissingToken(</span><span class="s0">'type'</span><span class="s1">, node.type));</span>
            <span class="s1">const afterToken = util.nullThrows(sourceCode.getTokenAfter(typeToken, { includeComments: </span><span class="s2">true </span><span class="s1">}), util.NullThrowsReasons.MissingToken(</span><span class="s0">'any token'</span><span class="s1">, node.type));</span>
            <span class="s1">yield fixer.removeRange([typeToken.range[</span><span class="s3">0</span><span class="s1">], afterToken.range[</span><span class="s3">0</span><span class="s1">]]);</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
<span class="s1">});</span>
<span class="s4">//# sourceMappingURL=consistent-type-imports.js.map</span></pre>
</body>
</html>
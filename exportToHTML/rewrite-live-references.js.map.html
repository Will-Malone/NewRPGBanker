<html>
<head>
<title>rewrite-live-references.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
rewrite-live-references.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_assert&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperSimpleAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;getOuterBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;numericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;isInType&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;exportKind&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteLiveReferences&quot;</span><span class="s0">,</span><span class="s1">&quot;programPath&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;imported&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;exported&quot;</span><span class="s0">,</span><span class="s1">&quot;requeueInParent&quot;</span><span class="s0">,</span><span class="s1">&quot;requeue&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;localName&quot;</span><span class="s0">,</span><span class="s1">&quot;importName&quot;</span><span class="s0">,</span><span class="s1">&quot;imports&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;importsNamespace&quot;</span><span class="s0">,</span><span class="s1">&quot;local&quot;</span><span class="s0">,</span><span class="s1">&quot;exportMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteBindingInitVisitorState&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteBindingInitVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingNames&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;simplifyAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteReferencesVisitorState&quot;</span><span class="s0">,</span><span class="s1">&quot;seen&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakSet&quot;</span><span class="s0">,</span><span class="s1">&quot;buildImportReference&quot;</span><span class="s0">,</span><span class="s1">&quot;identNode&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;referenced&quot;</span><span class="s0">,</span><span class="s1">&quot;lazy&quot;</span><span class="s0">,</span><span class="s1">&quot;namespace&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;interop&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;stringSpecifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteReferencesVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;Scope&quot;</span><span class="s0">,</span><span class="s1">&quot;skip&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;exportNames&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;buildBindingExportAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_blockHoist&quot;</span><span class="s0">,</span><span class="s1">&quot;insertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;VariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;localExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;exportsObjectName&quot;</span><span class="s0">,</span><span class="s1">&quot;exportName&quot;</span><span class="s0">,</span><span class="s1">&quot;currentScope&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;rename&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;expr&quot;</span><span class="s0">,</span><span class="s1">&quot;buildImportThrow&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;importData&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;localBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;rootBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptionalCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isTaggedTemplateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;UpdateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;exportedNames&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDeclaredUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;AssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;assert&quot;</span><span class="s0">,</span><span class="s1">&quot;assignment&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;ids&quot;</span><span class="s0">,</span><span class="s1">&quot;programScopeIds&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;items&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;ForOfStatement|ForInStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;programScope&quot;</span><span class="s0">,</span><span class="s1">&quot;didTransformExport&quot;</span><span class="s0">,</span><span class="s1">&quot;importConstViolationName&quot;</span><span class="s0">,</span><span class="s1">&quot;loopBodyScope&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyPath&quot;</span><span class="s0">,</span><span class="s1">&quot;newLoopId&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifierBasedOnNode&quot;</span><span class="s0">,</span><span class="s1">&quot;registerDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;unshiftContainer&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/rewrite-live-references.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import assert from </span><span class="s3">\&quot;</span><span class="s1">assert</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { template, types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath, Visitor, Scope } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import simplifyAccess from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-simple-access</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import type { ModuleMetadata } from </span><span class="s3">\&quot;</span><span class="s1">./normalize-and-load-metadata</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const {</span><span class="s3">\n  </span><span class="s1">assignmentExpression,</span><span class="s3">\n  </span><span class="s1">callExpression,</span><span class="s3">\n  </span><span class="s1">cloneNode,</span><span class="s3">\n  </span><span class="s1">expressionStatement,</span><span class="s3">\n  </span><span class="s1">getOuterBindingIdentifiers,</span><span class="s3">\n  </span><span class="s1">identifier,</span><span class="s3">\n  </span><span class="s1">isMemberExpression,</span><span class="s3">\n  </span><span class="s1">isVariableDeclaration,</span><span class="s3">\n  </span><span class="s1">jsxIdentifier,</span><span class="s3">\n  </span><span class="s1">jsxMemberExpression,</span><span class="s3">\n  </span><span class="s1">memberExpression,</span><span class="s3">\n  </span><span class="s1">numericLiteral,</span><span class="s3">\n  </span><span class="s1">sequenceExpression,</span><span class="s3">\n  </span><span class="s1">stringLiteral,</span><span class="s3">\n  </span><span class="s1">variableDeclaration,</span><span class="s3">\n  </span><span class="s1">variableDeclarator,</span><span class="s3">\n</span><span class="s1">} = t;</span><span class="s3">\n\n</span><span class="s1">interface RewriteReferencesVisitorState {</span><span class="s3">\n  </span><span class="s1">exported: Map&lt;any, any&gt;;</span><span class="s3">\n  </span><span class="s1">metadata: ModuleMetadata;</span><span class="s3">\n  </span><span class="s1">requeueInParent: (path: NodePath) =&gt; void;</span><span class="s3">\n  </span><span class="s1">scope: Scope;</span><span class="s3">\n  </span><span class="s1">imported: Map&lt;any, any&gt;;</span><span class="s3">\n  </span><span class="s1">buildImportReference: (</span><span class="s3">\n    </span><span class="s1">[source, importName, localName]: readonly [string, string, string],</span><span class="s3">\n    </span><span class="s1">identNode: t.Identifier | t.CallExpression | t.JSXIdentifier,</span><span class="s3">\n  </span><span class="s1">) =&gt; any;</span><span class="s3">\n  </span><span class="s1">seen: WeakSet&lt;object&gt;;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface RewriteBindingInitVisitorState {</span><span class="s3">\n  </span><span class="s1">exported: Map&lt;any, any&gt;;</span><span class="s3">\n  </span><span class="s1">metadata: ModuleMetadata;</span><span class="s3">\n  </span><span class="s1">requeueInParent: (path: NodePath) =&gt; void;</span><span class="s3">\n  </span><span class="s1">scope: Scope;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isInType(path: NodePath) {</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">switch (path.parent.type) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSTypeAliasDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSTypeReference</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TypeAlias</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ExportSpecifier</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">(</span><span class="s3">\n            </span><span class="s1">path.parentPath.parent as</span><span class="s3">\n              </span><span class="s1">| t.ExportDefaultDeclaration</span><span class="s3">\n              </span><span class="s1">| t.ExportNamedDeclaration</span><span class="s3">\n          </span><span class="s1">).exportKind === </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">if (path.parentPath.isStatement() || path.parentPath.isExpression()) {</span><span class="s3">\n          </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} while ((path = path.parentPath));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default function rewriteLiveReferences(</span><span class="s3">\n  </span><span class="s1">programPath: NodePath&lt;t.Program&gt;,</span><span class="s3">\n  </span><span class="s1">metadata: ModuleMetadata,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const imported = new Map();</span><span class="s3">\n  </span><span class="s1">const exported = new Map();</span><span class="s3">\n  </span><span class="s1">const requeueInParent = (path: NodePath) =&gt; {</span><span class="s3">\n    </span><span class="s1">// Manually re-queue `exports.default =` expressions so that the ES3</span><span class="s3">\n    </span><span class="s1">// transform has an opportunity to convert them. Ideally this would</span><span class="s3">\n    </span><span class="s1">// happen automatically from the replaceWith above. See #4140 for</span><span class="s3">\n    </span><span class="s1">// more info.</span><span class="s3">\n    </span><span class="s1">programPath.requeue(path);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">for (const [source, data] of metadata.source) {</span><span class="s3">\n    </span><span class="s1">for (const [localName, importName] of data.imports) {</span><span class="s3">\n      </span><span class="s1">imported.set(localName, [source, importName, null]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (const localName of data.importsNamespace) {</span><span class="s3">\n      </span><span class="s1">imported.set(localName, [source, null, localName]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const [local, data] of metadata.local) {</span><span class="s3">\n    </span><span class="s1">let exportMeta = exported.get(local);</span><span class="s3">\n    </span><span class="s1">if (!exportMeta) {</span><span class="s3">\n      </span><span class="s1">exportMeta = [];</span><span class="s3">\n      </span><span class="s1">exported.set(local, exportMeta);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">exportMeta.push(...data.names);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Rewrite initialization of bindings to update exports.</span><span class="s3">\n  </span><span class="s1">const rewriteBindingInitVisitorState: RewriteBindingInitVisitorState = {</span><span class="s3">\n    </span><span class="s1">metadata,</span><span class="s3">\n    </span><span class="s1">requeueInParent,</span><span class="s3">\n    </span><span class="s1">scope: programPath.scope,</span><span class="s3">\n    </span><span class="s1">exported, // local name =&gt; exported name list</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">programPath.traverse(</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n    </span><span class="s1">rewriteBindingInitVisitor,</span><span class="s3">\n    </span><span class="s1">rewriteBindingInitVisitorState,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">// NOTE(logan): The 'Array.from' calls are to make this code with in loose mode.</span><span class="s3">\n  </span><span class="s1">const bindingNames = new Set([</span><span class="s3">\n    </span><span class="s1">...Array.from(imported.keys()),</span><span class="s3">\n    </span><span class="s1">...Array.from(exported.keys()),</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n  </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">simplifyAccess(programPath, bindingNames);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) The third param has been removed in Babel 8.</span><span class="s3">\n    </span><span class="s1">simplifyAccess(programPath, bindingNames, false);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Rewrite reads/writes from imports and exports to have the correct behavior.</span><span class="s3">\n  </span><span class="s1">const rewriteReferencesVisitorState: RewriteReferencesVisitorState = {</span><span class="s3">\n    </span><span class="s1">seen: new WeakSet(),</span><span class="s3">\n    </span><span class="s1">metadata,</span><span class="s3">\n    </span><span class="s1">requeueInParent,</span><span class="s3">\n    </span><span class="s1">scope: programPath.scope,</span><span class="s3">\n    </span><span class="s1">imported, // local / import</span><span class="s3">\n    </span><span class="s1">exported, // local name =&gt; exported name list</span><span class="s3">\n    </span><span class="s1">buildImportReference: ([source, importName, localName], identNode) =&gt; {</span><span class="s3">\n      </span><span class="s1">const meta = metadata.source.get(source);</span><span class="s3">\n      </span><span class="s1">meta.referenced = true;</span><span class="s3">\n\n      </span><span class="s1">if (localName) {</span><span class="s3">\n        </span><span class="s1">if (meta.lazy) {</span><span class="s3">\n          </span><span class="s1">identNode = callExpression(</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error Fixme: we should handle the case when identNode is a JSXIdentifier</span><span class="s3">\n            </span><span class="s1">identNode,</span><span class="s3">\n            </span><span class="s1">[],</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return identNode;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let namespace: t.Expression = identifier(meta.name);</span><span class="s3">\n      </span><span class="s1">if (meta.lazy) namespace = callExpression(namespace, []);</span><span class="s3">\n\n      </span><span class="s1">if (importName === </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; meta.interop === </span><span class="s3">\&quot;</span><span class="s1">node-default</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return namespace;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const computed = metadata.stringSpecifiers.has(importName);</span><span class="s3">\n\n      </span><span class="s1">return memberExpression(</span><span class="s3">\n        </span><span class="s1">namespace,</span><span class="s3">\n        </span><span class="s1">computed ? stringLiteral(importName) : identifier(importName),</span><span class="s3">\n        </span><span class="s1">computed,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n  </span><span class="s1">programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A visitor to inject export update statements during binding initialization.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const rewriteBindingInitVisitor: Visitor&lt;RewriteBindingInitVisitorState&gt; = {</span><span class="s3">\n  </span><span class="s1">Scope(path) {</span><span class="s3">\n    </span><span class="s1">path.skip();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">ClassDeclaration(path) {</span><span class="s3">\n    </span><span class="s1">const { requeueInParent, exported, metadata } = this;</span><span class="s3">\n\n    </span><span class="s1">const { id } = path.node;</span><span class="s3">\n    </span><span class="s1">if (!id) throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Expected class to have a name</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const localName = id.name;</span><span class="s3">\n\n    </span><span class="s1">const exportNames = exported.get(localName) || [];</span><span class="s3">\n    </span><span class="s1">if (exportNames.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">const statement = expressionStatement(</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n        </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n          </span><span class="s1">metadata,</span><span class="s3">\n          </span><span class="s1">exportNames,</span><span class="s3">\n          </span><span class="s1">identifier(localName),</span><span class="s3">\n          </span><span class="s1">path.scope,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): avoid mutations</span><span class="s3">\n      </span><span class="s1">statement._blockHoist = path.node._blockHoist;</span><span class="s3">\n\n      </span><span class="s1">requeueInParent(path.insertAfter(statement)[0]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">VariableDeclaration(path) {</span><span class="s3">\n    </span><span class="s1">const { requeueInParent, exported, metadata } = this;</span><span class="s3">\n\n    </span><span class="s1">Object.keys(path.getOuterBindingIdentifiers()).forEach(localName =&gt; {</span><span class="s3">\n      </span><span class="s1">const exportNames = exported.get(localName) || [];</span><span class="s3">\n\n      </span><span class="s1">if (exportNames.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">const statement = expressionStatement(</span><span class="s3">\n          </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n          </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n            </span><span class="s1">metadata,</span><span class="s3">\n            </span><span class="s1">exportNames,</span><span class="s3">\n            </span><span class="s1">identifier(localName),</span><span class="s3">\n            </span><span class="s1">path.scope,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): avoid mutations</span><span class="s3">\n        </span><span class="s1">statement._blockHoist = path.node._blockHoist;</span><span class="s3">\n\n        </span><span class="s1">requeueInParent(path.insertAfter(statement)[0]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const buildBindingExportAssignmentExpression = (</span><span class="s3">\n  </span><span class="s1">metadata: ModuleMetadata,</span><span class="s3">\n  </span><span class="s1">exportNames: string[],</span><span class="s3">\n  </span><span class="s1">localExpr: t.Expression,</span><span class="s3">\n  </span><span class="s1">scope: Scope,</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">const exportsObjectName = metadata.exportName;</span><span class="s3">\n  </span><span class="s1">for (</span><span class="s3">\n    </span><span class="s1">let currentScope = scope;</span><span class="s3">\n    </span><span class="s1">currentScope != null;</span><span class="s3">\n    </span><span class="s1">currentScope = currentScope.parent</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (currentScope.hasOwnBinding(exportsObjectName)) {</span><span class="s3">\n      </span><span class="s1">currentScope.rename(exportsObjectName);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return (exportNames || []).reduce((expr, exportName) =&gt; {</span><span class="s3">\n    </span><span class="s1">// class Foo {} export { Foo, Foo as Bar };</span><span class="s3">\n    </span><span class="s1">// as</span><span class="s3">\n    </span><span class="s1">// class Foo {} exports.Foo = exports.Bar = Foo;</span><span class="s3">\n    </span><span class="s1">const { stringSpecifiers } = metadata;</span><span class="s3">\n    </span><span class="s1">const computed = stringSpecifiers.has(exportName);</span><span class="s3">\n    </span><span class="s1">return assignmentExpression(</span><span class="s3">\n      \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">memberExpression(</span><span class="s3">\n        </span><span class="s1">identifier(exportsObjectName),</span><span class="s3">\n        </span><span class="s1">computed ? stringLiteral(exportName) : identifier(exportName),</span><span class="s3">\n        </span><span class="s1">/* computed */ computed,</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">expr,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}, localExpr);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const buildImportThrow = (localName: string) =&gt; {</span><span class="s3">\n  </span><span class="s1">return template.expression.ast`</span><span class="s3">\n    </span><span class="s1">(function() {</span><span class="s3">\n      </span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">' + '${localName}' + '</span><span class="s3">\&quot; </span><span class="s1">is read-only.');</span><span class="s3">\n    </span><span class="s1">})()</span><span class="s3">\n  </span><span class="s1">`;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const rewriteReferencesVisitor: Visitor&lt;RewriteReferencesVisitorState&gt; = {</span><span class="s3">\n  </span><span class="s1">ReferencedIdentifier(path) {</span><span class="s3">\n    </span><span class="s1">const { seen, buildImportReference, scope, imported, requeueInParent } =</span><span class="s3">\n      </span><span class="s1">this;</span><span class="s3">\n    </span><span class="s1">if (seen.has(path.node)) return;</span><span class="s3">\n    </span><span class="s1">seen.add(path.node);</span><span class="s3">\n\n    </span><span class="s1">const localName = path.node.name;</span><span class="s3">\n\n    </span><span class="s1">const importData = imported.get(localName);</span><span class="s3">\n    </span><span class="s1">if (importData) {</span><span class="s3">\n      </span><span class="s1">if (isInType(path)) {</span><span class="s3">\n        </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n          </span><span class="s1">`Cannot transform the imported binding </span><span class="s3">\&quot;</span><span class="s1">${localName}</span><span class="s3">\&quot; </span><span class="s1">since it's also used in a type annotation. ` +</span><span class="s3">\n            </span><span class="s1">`Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const localBinding = path.scope.getBinding(localName);</span><span class="s3">\n      </span><span class="s1">const rootBinding = scope.getBinding(localName);</span><span class="s3">\n\n      </span><span class="s1">// redeclared in this scope</span><span class="s3">\n      </span><span class="s1">if (rootBinding !== localBinding) return;</span><span class="s3">\n\n      </span><span class="s1">const ref = buildImportReference(importData, path.node);</span><span class="s3">\n\n      </span><span class="s1">// Preserve the binding location so that sourcemaps are nicer.</span><span class="s3">\n      </span><span class="s1">ref.loc = path.node.loc;</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(path.parentPath.isCallExpression({ callee: path.node }) ||</span><span class="s3">\n          </span><span class="s1">path.parentPath.isOptionalCallExpression({ callee: path.node }) ||</span><span class="s3">\n          </span><span class="s1">path.parentPath.isTaggedTemplateExpression({ tag: path.node })) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isMemberExpression(ref)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">path.replaceWith(sequenceExpression([numericLiteral(0), ref]));</span><span class="s3">\n      </span><span class="s1">} else if (path.isJSXIdentifier() &amp;&amp; isMemberExpression(ref)) {</span><span class="s3">\n        </span><span class="s1">const { object, property } = ref;</span><span class="s3">\n        </span><span class="s1">path.replaceWith(</span><span class="s3">\n          </span><span class="s1">jsxMemberExpression(</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): possible bug `object` might not have a name</span><span class="s3">\n            </span><span class="s1">jsxIdentifier(object.name),</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): possible bug `property` might not have a name</span><span class="s3">\n            </span><span class="s1">jsxIdentifier(property.name),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">path.replaceWith(ref);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">requeueInParent(path);</span><span class="s3">\n\n      </span><span class="s1">// The path could have been replaced with an identifier that would</span><span class="s3">\n      </span><span class="s1">// otherwise be re-visited, so we skip processing its children.</span><span class="s3">\n      </span><span class="s1">path.skip();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">UpdateExpression(path) {</span><span class="s3">\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">scope,</span><span class="s3">\n      </span><span class="s1">seen,</span><span class="s3">\n      </span><span class="s1">imported,</span><span class="s3">\n      </span><span class="s1">exported,</span><span class="s3">\n      </span><span class="s1">requeueInParent,</span><span class="s3">\n      </span><span class="s1">buildImportReference,</span><span class="s3">\n    </span><span class="s1">} = this;</span><span class="s3">\n\n    </span><span class="s1">if (seen.has(path.node)) return;</span><span class="s3">\n\n    </span><span class="s1">seen.add(path.node);</span><span class="s3">\n\n    </span><span class="s1">const arg = path.get(</span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">// No change needed</span><span class="s3">\n    </span><span class="s1">if (arg.isMemberExpression()) return;</span><span class="s3">\n\n    </span><span class="s1">const update = path.node;</span><span class="s3">\n\n    </span><span class="s1">if (arg.isIdentifier()) {</span><span class="s3">\n      </span><span class="s1">const localName = arg.node.name;</span><span class="s3">\n\n      </span><span class="s1">// redeclared in this scope</span><span class="s3">\n      </span><span class="s1">if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const exportedNames = exported.get(localName);</span><span class="s3">\n      </span><span class="s1">const importData = imported.get(localName);</span><span class="s3">\n\n      </span><span class="s1">if (exportedNames?.length &gt; 0 || importData) {</span><span class="s3">\n        </span><span class="s1">if (importData) {</span><span class="s3">\n          </span><span class="s1">path.replaceWith(</span><span class="s3">\n            </span><span class="s1">assignmentExpression(</span><span class="s3">\n              </span><span class="s1">update.operator[0] + </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n              </span><span class="s1">buildImportReference(importData, arg.node),</span><span class="s3">\n              </span><span class="s1">buildImportThrow(localName),</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else if (update.prefix) {</span><span class="s3">\n          </span><span class="s1">// ++foo</span><span class="s3">\n          </span><span class="s1">// =&gt;   exports.foo = ++foo</span><span class="s3">\n          </span><span class="s1">path.replaceWith(</span><span class="s3">\n            </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n              </span><span class="s1">this.metadata,</span><span class="s3">\n              </span><span class="s1">exportedNames,</span><span class="s3">\n              </span><span class="s1">cloneNode(update),</span><span class="s3">\n              </span><span class="s1">path.scope,</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// foo++</span><span class="s3">\n          </span><span class="s1">// =&gt;   (ref = i++, exports.i = i, ref)</span><span class="s3">\n          </span><span class="s1">const ref = scope.generateDeclaredUidIdentifier(localName);</span><span class="s3">\n\n          </span><span class="s1">path.replaceWith(</span><span class="s3">\n            </span><span class="s1">sequenceExpression([</span><span class="s3">\n              </span><span class="s1">assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, cloneNode(ref), cloneNode(update)),</span><span class="s3">\n              </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n                </span><span class="s1">this.metadata,</span><span class="s3">\n                </span><span class="s1">exportedNames,</span><span class="s3">\n                </span><span class="s1">identifier(localName),</span><span class="s3">\n                </span><span class="s1">path.scope,</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">cloneNode(ref),</span><span class="s3">\n            </span><span class="s1">]),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">requeueInParent(path);</span><span class="s3">\n    </span><span class="s1">path.skip();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">AssignmentExpression: {</span><span class="s3">\n    </span><span class="s1">exit(path) {</span><span class="s3">\n      </span><span class="s1">const {</span><span class="s3">\n        </span><span class="s1">scope,</span><span class="s3">\n        </span><span class="s1">seen,</span><span class="s3">\n        </span><span class="s1">imported,</span><span class="s3">\n        </span><span class="s1">exported,</span><span class="s3">\n        </span><span class="s1">requeueInParent,</span><span class="s3">\n        </span><span class="s1">buildImportReference,</span><span class="s3">\n      </span><span class="s1">} = this;</span><span class="s3">\n\n      </span><span class="s1">if (seen.has(path.node)) return;</span><span class="s3">\n      </span><span class="s1">seen.add(path.node);</span><span class="s3">\n\n      </span><span class="s1">const left = path.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">// No change needed</span><span class="s3">\n      </span><span class="s1">if (left.isMemberExpression()) return;</span><span class="s3">\n\n      </span><span class="s1">if (left.isIdentifier()) {</span><span class="s3">\n        </span><span class="s1">// Simple update-assign foo += 1; export { foo };</span><span class="s3">\n        </span><span class="s1">// =&gt;   exports.foo =  (foo += 1);</span><span class="s3">\n        </span><span class="s1">const localName = left.node.name;</span><span class="s3">\n\n        </span><span class="s1">// redeclared in this scope</span><span class="s3">\n        </span><span class="s1">if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const exportedNames = exported.get(localName);</span><span class="s3">\n        </span><span class="s1">const importData = imported.get(localName);</span><span class="s3">\n        </span><span class="s1">if (exportedNames?.length &gt; 0 || importData) {</span><span class="s3">\n          </span><span class="s1">assert(path.node.operator === </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">Path was not simplified</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n          </span><span class="s1">const assignment = path.node;</span><span class="s3">\n\n          </span><span class="s1">if (importData) {</span><span class="s3">\n            </span><span class="s1">assignment.left = buildImportReference(importData, left.node);</span><span class="s3">\n\n            </span><span class="s1">assignment.right = sequenceExpression([</span><span class="s3">\n              </span><span class="s1">assignment.right,</span><span class="s3">\n              </span><span class="s1">buildImportThrow(localName),</span><span class="s3">\n            </span><span class="s1">]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">path.replaceWith(</span><span class="s3">\n            </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n              </span><span class="s1">this.metadata,</span><span class="s3">\n              </span><span class="s1">exportedNames,</span><span class="s3">\n              </span><span class="s1">assignment,</span><span class="s3">\n              </span><span class="s1">path.scope,</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">requeueInParent(path);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">const ids = left.getOuterBindingIdentifiers();</span><span class="s3">\n        </span><span class="s1">const programScopeIds = Object.keys(ids).filter(</span><span class="s3">\n          </span><span class="s1">localName =&gt;</span><span class="s3">\n            </span><span class="s1">scope.getBinding(localName) === path.scope.getBinding(localName),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const id = programScopeIds.find(localName =&gt; imported.has(localName));</span><span class="s3">\n\n        </span><span class="s1">if (id) {</span><span class="s3">\n          </span><span class="s1">path.node.right = sequenceExpression([</span><span class="s3">\n            </span><span class="s1">path.node.right,</span><span class="s3">\n            </span><span class="s1">buildImportThrow(id),</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Complex ({a, b, c} = {}); export { a, c };</span><span class="s3">\n        </span><span class="s1">// =&gt;   ({a, b, c} = {}), (exports.a = a, exports.c = c);</span><span class="s3">\n        </span><span class="s1">const items: t.Expression[] = [];</span><span class="s3">\n        </span><span class="s1">programScopeIds.forEach(localName =&gt; {</span><span class="s3">\n          </span><span class="s1">const exportedNames = exported.get(localName) || [];</span><span class="s3">\n          </span><span class="s1">if (exportedNames.length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">items.push(</span><span class="s3">\n              </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n                </span><span class="s1">this.metadata,</span><span class="s3">\n                </span><span class="s1">exportedNames,</span><span class="s3">\n                </span><span class="s1">identifier(localName),</span><span class="s3">\n                </span><span class="s1">path.scope,</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n\n        </span><span class="s1">if (items.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">let node: t.Node = sequenceExpression(items);</span><span class="s3">\n          </span><span class="s1">if (path.parentPath.isExpressionStatement()) {</span><span class="s3">\n            </span><span class="s1">node = expressionStatement(node);</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): avoid mutations</span><span class="s3">\n            </span><span class="s1">node._blockHoist = path.parentPath.node._blockHoist;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const statement = path.insertAfter(node)[0];</span><span class="s3">\n          </span><span class="s1">requeueInParent(statement);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  \&quot;</span><span class="s1">ForOfStatement|ForInStatement</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;t.ForOfStatement | t.ForInStatement&gt;,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const { scope, node } = path;</span><span class="s3">\n    </span><span class="s1">const { left } = node;</span><span class="s3">\n    </span><span class="s1">const { exported, imported, scope: programScope } = this;</span><span class="s3">\n\n    </span><span class="s1">if (!isVariableDeclaration(left)) {</span><span class="s3">\n      </span><span class="s1">let didTransformExport = false,</span><span class="s3">\n        </span><span class="s1">importConstViolationName;</span><span class="s3">\n      </span><span class="s1">const loopBodyScope = path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).scope;</span><span class="s3">\n      </span><span class="s1">for (const name of Object.keys(getOuterBindingIdentifiers(left))) {</span><span class="s3">\n        </span><span class="s1">if (programScope.getBinding(name) === scope.getBinding(name)) {</span><span class="s3">\n          </span><span class="s1">if (exported.has(name)) {</span><span class="s3">\n            </span><span class="s1">didTransformExport = true;</span><span class="s3">\n            </span><span class="s1">if (loopBodyScope.hasOwnBinding(name)) {</span><span class="s3">\n              </span><span class="s1">loopBodyScope.rename(name);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (imported.has(name) &amp;&amp; !importConstViolationName) {</span><span class="s3">\n            </span><span class="s1">importConstViolationName = name;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!didTransformExport &amp;&amp; !importConstViolationName) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">path.ensureBlock();</span><span class="s3">\n      </span><span class="s1">const bodyPath = path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">const newLoopId = scope.generateUidIdentifierBasedOnNode(left);</span><span class="s3">\n      </span><span class="s1">path</span><span class="s3">\n        </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replaceWith(</span><span class="s3">\n          </span><span class="s1">variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n            </span><span class="s1">variableDeclarator(cloneNode(newLoopId)),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">scope.registerDeclaration(path.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n\n      </span><span class="s1">if (didTransformExport) {</span><span class="s3">\n        </span><span class="s1">bodyPath.unshiftContainer(</span><span class="s3">\n          \&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">expressionStatement(assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, left, newLoopId)),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (importConstViolationName) {</span><span class="s3">\n        </span><span class="s1">bodyPath.unshiftContainer(</span><span class="s3">\n          \&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">expressionStatement(buildImportThrow(importConstViolationName)),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;}</span></pre>
</body>
</html>
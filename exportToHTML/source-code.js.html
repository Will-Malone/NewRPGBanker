<html>
<head>
<title>source-code.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
source-code.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @fileoverview Abstraction of JavaScript source code. 
 * @author Nicholas C. Zakas 
 */</span>
<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s1">const</span>
    <span class="s1">{ isCommentToken } = require(</span><span class="s2">&quot;@eslint-community/eslint-utils&quot;</span><span class="s1">),</span>
    <span class="s1">TokenStore = require(</span><span class="s2">&quot;./token-store&quot;</span><span class="s1">),</span>
    <span class="s1">astUtils = require(</span><span class="s2">&quot;../shared/ast-utils&quot;</span><span class="s1">),</span>
    <span class="s1">Traverser = require(</span><span class="s2">&quot;../shared/traverser&quot;</span><span class="s1">);</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Type Definitions</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/** @typedef {import(&quot;eslint-scope&quot;).Variable} Variable */</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Private</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/** 
 * Validates that the given AST has the required information. 
 * @param {ASTNode} ast The Program node of the AST to check. 
 * @throws {Error} If the AST doesn't contain the correct information. 
 * @returns {void} 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">validate(ast) {</span>
    <span class="s3">if </span><span class="s1">(!ast.tokens) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;AST is missing the tokens array.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!ast.comments) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;AST is missing the comments array.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!ast.loc) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;AST is missing location information.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!ast.range) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;AST is missing range information&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Check to see if its a ES6 export declaration. 
 * @param {ASTNode} astNode An AST node. 
 * @returns {boolean} whether the given node represents an export declaration. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">looksLikeExport(astNode) {</span>
    <span class="s3">return </span><span class="s1">astNode.type === </span><span class="s2">&quot;ExportDefaultDeclaration&quot; </span><span class="s1">|| astNode.type === </span><span class="s2">&quot;ExportNamedDeclaration&quot; </span><span class="s1">||</span>
        <span class="s1">astNode.type === </span><span class="s2">&quot;ExportAllDeclaration&quot; </span><span class="s1">|| astNode.type === </span><span class="s2">&quot;ExportSpecifier&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Merges two sorted lists into a larger sorted list in O(n) time. 
 * @param {Token[]} tokens The list of tokens. 
 * @param {Token[]} comments The list of comments. 
 * @returns {Token[]} A sorted list of tokens and comments. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">sortedMerge(tokens, comments) {</span>
    <span class="s1">const result = [];</span>
    <span class="s1">let tokenIndex = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">let commentIndex = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s1">(tokenIndex &lt; tokens.length || commentIndex &lt; comments.length) {</span>
        <span class="s3">if </span><span class="s1">(commentIndex &gt;= comments.length || tokenIndex &lt; tokens.length &amp;&amp; tokens[tokenIndex].range[</span><span class="s4">0</span><span class="s1">] &lt; comments[commentIndex].range[</span><span class="s4">0</span><span class="s1">]) {</span>
            <span class="s1">result.push(tokens[tokenIndex++]);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">result.push(comments[commentIndex++]);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Determines if two nodes or tokens overlap. 
 * @param {ASTNode|Token} first The first node or token to check. 
 * @param {ASTNode|Token} second The second node or token to check. 
 * @returns {boolean} True if the two nodes or tokens overlap. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">nodesOrTokensOverlap(first, second) {</span>
    <span class="s3">return </span><span class="s1">(first.range[</span><span class="s4">0</span><span class="s1">] &lt;= second.range[</span><span class="s4">0</span><span class="s1">] &amp;&amp; first.range[</span><span class="s4">1</span><span class="s1">] &gt;= second.range[</span><span class="s4">0</span><span class="s1">]) ||</span>
        <span class="s1">(second.range[</span><span class="s4">0</span><span class="s1">] &lt;= first.range[</span><span class="s4">0</span><span class="s1">] &amp;&amp; second.range[</span><span class="s4">1</span><span class="s1">] &gt;= first.range[</span><span class="s4">0</span><span class="s1">]);</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Determines if two nodes or tokens have at least one whitespace character 
 * between them. Order does not matter. Returns false if the given nodes or 
 * tokens overlap. 
 * @param {SourceCode} sourceCode The source code object. 
 * @param {ASTNode|Token} first The first node or token to check between. 
 * @param {ASTNode|Token} second The second node or token to check between. 
 * @param {boolean} checkInsideOfJSXText If `true` is present, check inside of JSXText tokens for backward compatibility. 
 * @returns {boolean} True if there is a whitespace character between 
 * any of the tokens found between the two given nodes or tokens. 
 * @public 
 */</span>
<span class="s3">function </span><span class="s1">isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {</span>
    <span class="s3">if </span><span class="s1">(nodesOrTokensOverlap(first, second)) {</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">const [startingNodeOrToken, endingNodeOrToken] = first.range[</span><span class="s4">1</span><span class="s1">] &lt;= second.range[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">? [first, second]</span>
        <span class="s1">: [second, first];</span>
    <span class="s1">const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;</span>
    <span class="s1">const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;</span>
    <span class="s1">let currentToken = firstToken;</span>

    <span class="s3">while </span><span class="s1">(currentToken !== finalToken) {</span>
        <span class="s1">const nextToken = sourceCode.getTokenAfter(currentToken, { includeComments: </span><span class="s3">true </span><span class="s1">});</span>

        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">currentToken.range[</span><span class="s4">1</span><span class="s1">] !== nextToken.range[</span><span class="s4">0</span><span class="s1">] ||</span>

                <span class="s0">/* 
                 * For backward compatibility, check spaces in JSXText. 
                 * https://github.com/eslint/eslint/issues/12614 
                 */</span>
                <span class="s1">(</span>
                    <span class="s1">checkInsideOfJSXText &amp;&amp;</span>
                    <span class="s1">nextToken !== finalToken &amp;&amp;</span>
                    <span class="s1">nextToken.type === </span><span class="s2">&quot;JSXText&quot; </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">/\s/u.test(nextToken.value)</span>
                <span class="s1">)</span>
        <span class="s1">) {</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">currentToken = nextToken;</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Public Interface</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s1">const caches = Symbol(</span><span class="s2">&quot;caches&quot;</span><span class="s1">);</span>

<span class="s0">/** 
 * Represents parsed source code. 
 */</span>
<span class="s1">class SourceCode extends TokenStore {</span>

    <span class="s0">/** 
     * @param {string|Object} textOrConfig The source code text or config object. 
     * @param {string} textOrConfig.text The source code text. 
     * @param {ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped. 
     * @param {Object|null} textOrConfig.parserServices The parser services. 
     * @param {ScopeManager|null} textOrConfig.scopeManager The scope of this source code. 
     * @param {Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST. 
     * @param {ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped. 
     */</span>
    <span class="s1">constructor(textOrConfig, astIfNoConfig) {</span>
        <span class="s1">let text, ast, parserServices, scopeManager, visitorKeys;</span>

        <span class="s0">// Process overloading.</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">textOrConfig === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
            <span class="s1">text = textOrConfig;</span>
            <span class="s1">ast = astIfNoConfig;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">textOrConfig === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; textOrConfig !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">text = textOrConfig.text;</span>
            <span class="s1">ast = textOrConfig.ast;</span>
            <span class="s1">parserServices = textOrConfig.parserServices;</span>
            <span class="s1">scopeManager = textOrConfig.scopeManager;</span>
            <span class="s1">visitorKeys = textOrConfig.visitorKeys;</span>
        <span class="s1">}</span>

        <span class="s1">validate(ast);</span>
        <span class="s1">super(ast.tokens, ast.comments);</span>

        <span class="s0">/** 
         * General purpose caching for the class. 
         */</span>
        <span class="s3">this</span><span class="s1">[caches] = </span><span class="s3">new </span><span class="s1">Map([</span>
            <span class="s1">[</span><span class="s2">&quot;scopes&quot;</span><span class="s1">, </span><span class="s3">new </span><span class="s1">WeakMap()]</span>
        <span class="s1">]);</span>

        <span class="s0">/** 
         * The flag to indicate that the source code has Unicode BOM. 
         * @type {boolean} 
         */</span>
        <span class="s3">this</span><span class="s1">.hasBOM = (text.charCodeAt(</span><span class="s4">0</span><span class="s1">) === </span><span class="s4">0</span><span class="s1">xFEFF);</span>

        <span class="s0">/** 
         * The original text source code. 
         * BOM was stripped from this text. 
         * @type {string} 
         */</span>
        <span class="s3">this</span><span class="s1">.text = (</span><span class="s3">this</span><span class="s1">.hasBOM ? text.slice(</span><span class="s4">1</span><span class="s1">) : text);</span>

        <span class="s0">/** 
         * The parsed AST for the source code. 
         * @type {ASTNode} 
         */</span>
        <span class="s3">this</span><span class="s1">.ast = ast;</span>

        <span class="s0">/** 
         * The parser services of this source code. 
         * @type {Object} 
         */</span>
        <span class="s3">this</span><span class="s1">.parserServices = parserServices || {};</span>

        <span class="s0">/** 
         * The scope of this source code. 
         * @type {ScopeManager|null} 
         */</span>
        <span class="s3">this</span><span class="s1">.scopeManager = scopeManager || </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s0">/** 
         * The visitor keys to traverse AST. 
         * @type {Object} 
         */</span>
        <span class="s3">this</span><span class="s1">.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;</span>

        <span class="s0">// Check the source text for the presence of a shebang since it is parsed as a standard line comment.</span>
        <span class="s1">const shebangMatched = </span><span class="s3">this</span><span class="s1">.text.match(astUtils.shebangPattern);</span>
        <span class="s1">const hasShebang = shebangMatched &amp;&amp; ast.comments.length &amp;&amp; ast.comments[</span><span class="s4">0</span><span class="s1">].value === shebangMatched[</span><span class="s4">1</span><span class="s1">];</span>

        <span class="s3">if </span><span class="s1">(hasShebang) {</span>
            <span class="s1">ast.comments[</span><span class="s4">0</span><span class="s1">].type = </span><span class="s2">&quot;Shebang&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">this</span><span class="s1">.tokensAndComments = sortedMerge(ast.tokens, ast.comments);</span>

        <span class="s0">/** 
         * The source code split into lines according to ECMA-262 specification. 
         * This is done to avoid each rule needing to do so separately. 
         * @type {string[]} 
         */</span>
        <span class="s3">this</span><span class="s1">.lines = [];</span>
        <span class="s3">this</span><span class="s1">.lineStartIndices = [</span><span class="s4">0</span><span class="s1">];</span>

        <span class="s1">const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();</span>
        <span class="s1">let match;</span>

        <span class="s0">/* 
         * Previously, this was implemented using a regex that 
         * matched a sequence of non-linebreak characters followed by a 
         * linebreak, then adding the lengths of the matches. However, 
         * this caused a catastrophic backtracking issue when the end 
         * of a file contained a large number of non-newline characters. 
         * To avoid this, the current implementation just matches newlines 
         * and uses match.index to get the correct line start indices. 
         */</span>
        <span class="s3">while </span><span class="s1">((match = lineEndingPattern.exec(</span><span class="s3">this</span><span class="s1">.text))) {</span>
            <span class="s3">this</span><span class="s1">.lines.push(</span><span class="s3">this</span><span class="s1">.text.slice(</span><span class="s3">this</span><span class="s1">.lineStartIndices[</span><span class="s3">this</span><span class="s1">.lineStartIndices.length - </span><span class="s4">1</span><span class="s1">], match.index));</span>
            <span class="s3">this</span><span class="s1">.lineStartIndices.push(match.index + match[</span><span class="s4">0</span><span class="s1">].length);</span>
        <span class="s1">}</span>
        <span class="s3">this</span><span class="s1">.lines.push(</span><span class="s3">this</span><span class="s1">.text.slice(</span><span class="s3">this</span><span class="s1">.lineStartIndices[</span><span class="s3">this</span><span class="s1">.lineStartIndices.length - </span><span class="s4">1</span><span class="s1">]));</span>

        <span class="s0">// Cache for comments found using getComments().</span>
        <span class="s3">this</span><span class="s1">._commentCache = </span><span class="s3">new </span><span class="s1">WeakMap();</span>

        <span class="s0">// don't allow modification of this object</span>
        <span class="s1">Object.freeze(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">Object.freeze(</span><span class="s3">this</span><span class="s1">.lines);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Split the source code into multiple lines based on the line delimiters. 
     * @param {string} text Source code as a string. 
     * @returns {string[]} Array of source code lines. 
     * @public 
     */</span>
    <span class="s1">static splitLines(text) {</span>
        <span class="s3">return </span><span class="s1">text.split(astUtils.createGlobalLinebreakMatcher());</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the source code for the given node. 
     * @param {ASTNode} [node] The AST node to get the text for. 
     * @param {int} [beforeCount] The number of characters before the node to retrieve. 
     * @param {int} [afterCount] The number of characters after the node to retrieve. 
     * @returns {string} The text representing the AST node. 
     * @public 
     */</span>
    <span class="s1">getText(node, beforeCount, afterCount) {</span>
        <span class="s3">if </span><span class="s1">(node) {</span>
            <span class="s3">return this</span><span class="s1">.text.slice(Math.max(node.range[</span><span class="s4">0</span><span class="s1">] - (beforeCount || </span><span class="s4">0</span><span class="s1">), </span><span class="s4">0</span><span class="s1">),</span>
                <span class="s1">node.range[</span><span class="s4">1</span><span class="s1">] + (afterCount || </span><span class="s4">0</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s3">return this</span><span class="s1">.text;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the entire source text split into an array of lines. 
     * @returns {Array} The source text as an array of lines. 
     * @public 
     */</span>
    <span class="s1">getLines() {</span>
        <span class="s3">return this</span><span class="s1">.lines;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Retrieves an array containing all comments in the source code. 
     * @returns {ASTNode[]} An array of comment nodes. 
     * @public 
     */</span>
    <span class="s1">getAllComments() {</span>
        <span class="s3">return this</span><span class="s1">.ast.comments;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets all comments for the given node. 
     * @param {ASTNode} node The AST node to get the comments for. 
     * @returns {Object} An object containing a leading and trailing array 
     *      of comments indexed by their position. 
     * @public 
     * @deprecated replaced by getCommentsBefore(), getCommentsAfter(), and getCommentsInside(). 
     */</span>
    <span class="s1">getComments(node) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._commentCache.has(node)) {</span>
            <span class="s3">return this</span><span class="s1">._commentCache.get(node);</span>
        <span class="s1">}</span>

        <span class="s1">const comments = {</span>
            <span class="s1">leading: [],</span>
            <span class="s1">trailing: []</span>
        <span class="s1">};</span>

        <span class="s0">/* 
         * Return all comments as leading comments of the Program node when 
         * there is no executable code. 
         */</span>
        <span class="s3">if </span><span class="s1">(node.type === </span><span class="s2">&quot;Program&quot;</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(node.body.length === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">comments.leading = node.comments;</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>

            <span class="s0">/* 
             * Return comments as trailing comments of nodes that only contain 
             * comments (to mimic the comment attachment behavior present in Espree). 
             */</span>
            <span class="s3">if </span><span class="s1">((node.type === </span><span class="s2">&quot;BlockStatement&quot; </span><span class="s1">|| node.type === </span><span class="s2">&quot;ClassBody&quot;</span><span class="s1">) &amp;&amp; node.body.length === </span><span class="s4">0 </span><span class="s1">||</span>
                <span class="s1">node.type === </span><span class="s2">&quot;ObjectExpression&quot; </span><span class="s1">&amp;&amp; node.properties.length === </span><span class="s4">0 </span><span class="s1">||</span>
                <span class="s1">node.type === </span><span class="s2">&quot;ArrayExpression&quot; </span><span class="s1">&amp;&amp; node.elements.length === </span><span class="s4">0 </span><span class="s1">||</span>
                <span class="s1">node.type === </span><span class="s2">&quot;SwitchStatement&quot; </span><span class="s1">&amp;&amp; node.cases.length === </span><span class="s4">0</span>
            <span class="s1">) {</span>
                <span class="s1">comments.trailing = </span><span class="s3">this</span><span class="s1">.getTokens(node, {</span>
                    <span class="s1">includeComments: </span><span class="s3">true</span><span class="s1">,</span>
                    <span class="s1">filter: isCommentToken</span>
                <span class="s1">});</span>
            <span class="s1">}</span>

            <span class="s0">/* 
             * Iterate over tokens before and after node and collect comment tokens. 
             * Do not include comments that exist outside of the parent node 
             * to avoid duplication. 
             */</span>
            <span class="s1">let currentToken = </span><span class="s3">this</span><span class="s1">.getTokenBefore(node, { includeComments: </span><span class="s3">true </span><span class="s1">});</span>

            <span class="s3">while </span><span class="s1">(currentToken &amp;&amp; isCommentToken(currentToken)) {</span>
                <span class="s3">if </span><span class="s1">(node.parent &amp;&amp; node.parent.type !== </span><span class="s2">&quot;Program&quot; </span><span class="s1">&amp;&amp; (currentToken.start &lt; node.parent.start)) {</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">comments.leading.push(currentToken);</span>
                <span class="s1">currentToken = </span><span class="s3">this</span><span class="s1">.getTokenBefore(currentToken, { includeComments: </span><span class="s3">true </span><span class="s1">});</span>
            <span class="s1">}</span>

            <span class="s1">comments.leading.reverse();</span>

            <span class="s1">currentToken = </span><span class="s3">this</span><span class="s1">.getTokenAfter(node, { includeComments: </span><span class="s3">true </span><span class="s1">});</span>

            <span class="s3">while </span><span class="s1">(currentToken &amp;&amp; isCommentToken(currentToken)) {</span>
                <span class="s3">if </span><span class="s1">(node.parent &amp;&amp; node.parent.type !== </span><span class="s2">&quot;Program&quot; </span><span class="s1">&amp;&amp; (currentToken.end &gt; node.parent.end)) {</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">comments.trailing.push(currentToken);</span>
                <span class="s1">currentToken = </span><span class="s3">this</span><span class="s1">.getTokenAfter(currentToken, { includeComments: </span><span class="s3">true </span><span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">this</span><span class="s1">._commentCache.set(node, comments);</span>
        <span class="s3">return </span><span class="s1">comments;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Retrieves the JSDoc comment for a given node. 
     * @param {ASTNode} node The AST node to get the comment for. 
     * @returns {Token|null} The Block comment token containing the JSDoc comment 
     *      for the given node or null if not found. 
     * @public 
     * @deprecated 
     */</span>
    <span class="s1">getJSDocComment(node) {</span>

        <span class="s0">/** 
         * Checks for the presence of a JSDoc comment for the given node and returns it. 
         * @param {ASTNode} astNode The AST node to get the comment for. 
         * @returns {Token|null} The Block comment token containing the JSDoc comment 
         *      for the given node or null if not found. 
         * @private 
         */</span>
        <span class="s1">const findJSDocComment = astNode =&gt; {</span>
            <span class="s1">const tokenBefore = </span><span class="s3">this</span><span class="s1">.getTokenBefore(astNode, { includeComments: </span><span class="s3">true </span><span class="s1">});</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">tokenBefore &amp;&amp;</span>
                <span class="s1">isCommentToken(tokenBefore) &amp;&amp;</span>
                <span class="s1">tokenBefore.type === </span><span class="s2">&quot;Block&quot; </span><span class="s1">&amp;&amp;</span>
                <span class="s1">tokenBefore.value.charAt(</span><span class="s4">0</span><span class="s1">) === </span><span class="s2">&quot;*&quot; </span><span class="s1">&amp;&amp;</span>
                <span class="s1">astNode.loc.start.line - tokenBefore.loc.end.line &lt;= </span><span class="s4">1</span>
            <span class="s1">) {</span>
                <span class="s3">return </span><span class="s1">tokenBefore;</span>
            <span class="s1">}</span>

            <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">};</span>
        <span class="s1">let parent = node.parent;</span>

        <span class="s3">switch </span><span class="s1">(node.type) {</span>
            <span class="s3">case </span><span class="s2">&quot;ClassDeclaration&quot;</span><span class="s1">:</span>
            <span class="s3">case </span><span class="s2">&quot;FunctionDeclaration&quot;</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">findJSDocComment(looksLikeExport(parent) ? parent : node);</span>

            <span class="s3">case </span><span class="s2">&quot;ClassExpression&quot;</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">findJSDocComment(parent.parent);</span>

            <span class="s3">case </span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s1">:</span>
            <span class="s3">case </span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(parent.type !== </span><span class="s2">&quot;CallExpression&quot; </span><span class="s1">&amp;&amp; parent.type !== </span><span class="s2">&quot;NewExpression&quot;</span><span class="s1">) {</span>
                    <span class="s3">while </span><span class="s1">(</span>
                        <span class="s1">!</span><span class="s3">this</span><span class="s1">.getCommentsBefore(parent).length &amp;&amp;</span>
                        <span class="s1">!/Function/u.test(parent.type) &amp;&amp;</span>
                        <span class="s1">parent.type !== </span><span class="s2">&quot;MethodDefinition&quot; </span><span class="s1">&amp;&amp;</span>
                        <span class="s1">parent.type !== </span><span class="s2">&quot;Property&quot;</span>
                    <span class="s1">) {</span>
                        <span class="s1">parent = parent.parent;</span>

                        <span class="s3">if </span><span class="s1">(!parent) {</span>
                            <span class="s3">break</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>

                    <span class="s3">if </span><span class="s1">(parent &amp;&amp; parent.type !== </span><span class="s2">&quot;FunctionDeclaration&quot; </span><span class="s1">&amp;&amp; parent.type !== </span><span class="s2">&quot;Program&quot;</span><span class="s1">) {</span>
                        <span class="s3">return </span><span class="s1">findJSDocComment(parent);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>

                <span class="s3">return </span><span class="s1">findJSDocComment(node);</span>

            <span class="s0">// falls through</span>
            <span class="s3">default</span><span class="s1">:</span>
                <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the deepest node containing a range index. 
     * @param {int} index Range index of the desired node. 
     * @returns {ASTNode} The node if found or null if not found. 
     * @public 
     */</span>
    <span class="s1">getNodeByRangeIndex(index) {</span>
        <span class="s1">let result = </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s1">Traverser.traverse(</span><span class="s3">this</span><span class="s1">.ast, {</span>
            <span class="s1">visitorKeys: </span><span class="s3">this</span><span class="s1">.visitorKeys,</span>
            <span class="s1">enter(node) {</span>
                <span class="s3">if </span><span class="s1">(node.range[</span><span class="s4">0</span><span class="s1">] &lt;= index &amp;&amp; index &lt; node.range[</span><span class="s4">1</span><span class="s1">]) {</span>
                    <span class="s1">result = node;</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">this</span><span class="s1">.skip();</span>
                <span class="s1">}</span>
            <span class="s1">},</span>
            <span class="s1">leave(node) {</span>
                <span class="s3">if </span><span class="s1">(node === result) {</span>
                    <span class="s3">this</span><span class="s1">.</span><span class="s3">break</span><span class="s1">();</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">});</span>

        <span class="s3">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Determines if two nodes or tokens have at least one whitespace character 
     * between them. Order does not matter. Returns false if the given nodes or 
     * tokens overlap. 
     * @param {ASTNode|Token} first The first node or token to check between. 
     * @param {ASTNode|Token} second The second node or token to check between. 
     * @returns {boolean} True if there is a whitespace character between 
     * any of the tokens found between the two given nodes or tokens. 
     * @public 
     */</span>
    <span class="s1">isSpaceBetween(first, second) {</span>
        <span class="s3">return </span><span class="s1">isSpaceBetween(</span><span class="s3">this</span><span class="s1">, first, second, </span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Determines if two nodes or tokens have at least one whitespace character 
     * between them. Order does not matter. Returns false if the given nodes or 
     * tokens overlap. 
     * For backward compatibility, this method returns true if there are 
     * `JSXText` tokens that contain whitespaces between the two. 
     * @param {ASTNode|Token} first The first node or token to check between. 
     * @param {ASTNode|Token} second The second node or token to check between. 
     * @returns {boolean} True if there is a whitespace character between 
     * any of the tokens found between the two given nodes or tokens. 
     * @deprecated in favor of isSpaceBetween(). 
     * @public 
     */</span>
    <span class="s1">isSpaceBetweenTokens(first, second) {</span>
        <span class="s3">return </span><span class="s1">isSpaceBetween(</span><span class="s3">this</span><span class="s1">, first, second, </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts a source text index into a (line, column) pair. 
     * @param {number} index The index of a character in a file 
     * @throws {TypeError} If non-numeric index or index out of range. 
     * @returns {Object} A {line, column} location object with a 0-indexed column 
     * @public 
     */</span>
    <span class="s1">getLocFromIndex(index) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">index !== </span><span class="s2">&quot;number&quot;</span><span class="s1">) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;Expected `index` to be a number.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(index &lt; </span><span class="s4">0 </span><span class="s1">|| index &gt; </span><span class="s3">this</span><span class="s1">.text.length) {</span>
            <span class="s3">throw new </span><span class="s1">RangeError(`Index out of range (requested index ${index}, but source text has length ${</span><span class="s3">this</span><span class="s1">.text.length}).`);</span>
        <span class="s1">}</span>

        <span class="s0">/* 
         * For an argument of this.text.length, return the location one &quot;spot&quot; past the last character 
         * of the file. If the last character is a linebreak, the location will be column 0 of the next 
         * line; otherwise, the location will be in the next column on the same line. 
         * 
         * See getIndexFromLoc for the motivation for this special case. 
         */</span>
        <span class="s3">if </span><span class="s1">(index === </span><span class="s3">this</span><span class="s1">.text.length) {</span>
            <span class="s3">return </span><span class="s1">{ line: </span><span class="s3">this</span><span class="s1">.lines.length, column: </span><span class="s3">this</span><span class="s1">.lines[</span><span class="s3">this</span><span class="s1">.lines.length - </span><span class="s4">1</span><span class="s1">].length };</span>
        <span class="s1">}</span>

        <span class="s0">/* 
         * To figure out which line index is on, determine the last place at which index could 
         * be inserted into lineStartIndices to keep the list sorted. 
         */</span>
        <span class="s1">const lineNumber = index &gt;= </span><span class="s3">this</span><span class="s1">.lineStartIndices[</span><span class="s3">this</span><span class="s1">.lineStartIndices.length - </span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">? </span><span class="s3">this</span><span class="s1">.lineStartIndices.length</span>
            <span class="s1">: </span><span class="s3">this</span><span class="s1">.lineStartIndices.findIndex(el =&gt; index &lt; el);</span>

        <span class="s3">return </span><span class="s1">{ line: lineNumber, column: index - </span><span class="s3">this</span><span class="s1">.lineStartIndices[lineNumber - </span><span class="s4">1</span><span class="s1">] };</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts a (line, column) pair into a range index. 
     * @param {Object} loc A line/column location 
     * @param {number} loc.line The line number of the location (1-indexed) 
     * @param {number} loc.column The column number of the location (0-indexed) 
     * @throws {TypeError|RangeError} If `loc` is not an object with a numeric 
     *   `line` and `column`, if the `line` is less than or equal to zero or 
     *   the line or column is out of the expected range. 
     * @returns {number} The range index of the location in the file. 
     * @public 
     */</span>
    <span class="s1">getIndexFromLoc(loc) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">loc !== </span><span class="s2">&quot;object&quot; </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">loc.line !== </span><span class="s2">&quot;number&quot; </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">loc.column !== </span><span class="s2">&quot;number&quot;</span><span class="s1">) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;Expected `loc` to be an object with numeric `line` and `column` properties.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(loc.line &lt;= </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">throw new </span><span class="s1">RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be </span><span class="s4">1</span><span class="s1">-based.`);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(loc.line &gt; </span><span class="s3">this</span><span class="s1">.lineStartIndices.length) {</span>
            <span class="s3">throw new </span><span class="s1">RangeError(`Line number out of range (line ${loc.line} requested, but only ${</span><span class="s3">this</span><span class="s1">.lineStartIndices.length} lines present).`);</span>
        <span class="s1">}</span>

        <span class="s1">const lineStartIndex = </span><span class="s3">this</span><span class="s1">.lineStartIndices[loc.line - </span><span class="s4">1</span><span class="s1">];</span>
        <span class="s1">const lineEndIndex = loc.line === </span><span class="s3">this</span><span class="s1">.lineStartIndices.length ? </span><span class="s3">this</span><span class="s1">.text.length : </span><span class="s3">this</span><span class="s1">.lineStartIndices[loc.line];</span>
        <span class="s1">const positionIndex = lineStartIndex + loc.column;</span>

        <span class="s0">/* 
         * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of 
         * the given line, provided that the line number is valid element of this.lines. Since the 
         * last element of this.lines is an empty string for files with trailing newlines, add a 
         * special case where getting the index for the first location after the end of the file 
         * will return the length of the file, rather than throwing an error. This allows rules to 
         * use getIndexFromLoc consistently without worrying about edge cases at the end of a file. 
         */</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">loc.line === </span><span class="s3">this</span><span class="s1">.lineStartIndices.length &amp;&amp; positionIndex &gt; lineEndIndex ||</span>
            <span class="s1">loc.line &lt; </span><span class="s3">this</span><span class="s1">.lineStartIndices.length &amp;&amp; positionIndex &gt;= lineEndIndex</span>
        <span class="s1">) {</span>
            <span class="s3">throw new </span><span class="s1">RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">positionIndex;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the scope for the given node 
     * @param {ASTNode} currentNode The node to get the scope of 
     * @returns {eslint-scope.Scope} The scope information for this node 
     * @throws {TypeError} If the `currentNode` argument is missing. 
     */</span>
    <span class="s1">getScope(currentNode) {</span>

        <span class="s3">if </span><span class="s1">(!currentNode) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;Missing required argument: node.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s0">// check cache first</span>
        <span class="s1">const cache = </span><span class="s3">this</span><span class="s1">[caches].get(</span><span class="s2">&quot;scopes&quot;</span><span class="s1">);</span>
        <span class="s1">const cachedScope = cache.get(currentNode);</span>

        <span class="s3">if </span><span class="s1">(cachedScope) {</span>
            <span class="s3">return </span><span class="s1">cachedScope;</span>
        <span class="s1">}</span>

        <span class="s0">// On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.</span>
        <span class="s1">const inner = currentNode.type !== </span><span class="s2">&quot;Program&quot;</span><span class="s1">;</span>

        <span class="s3">for </span><span class="s1">(let node = currentNode; node; node = node.parent) {</span>
            <span class="s1">const scope = </span><span class="s3">this</span><span class="s1">.scopeManager.acquire(node, inner);</span>

            <span class="s3">if </span><span class="s1">(scope) {</span>
                <span class="s3">if </span><span class="s1">(scope.type === </span><span class="s2">&quot;function-expression-name&quot;</span><span class="s1">) {</span>
                    <span class="s1">cache.set(currentNode, scope.childScopes[</span><span class="s4">0</span><span class="s1">]);</span>
                    <span class="s3">return </span><span class="s1">scope.childScopes[</span><span class="s4">0</span><span class="s1">];</span>
                <span class="s1">}</span>

                <span class="s1">cache.set(currentNode, scope);</span>
                <span class="s3">return </span><span class="s1">scope;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">cache.set(currentNode, </span><span class="s3">this</span><span class="s1">.scopeManager.scopes[</span><span class="s4">0</span><span class="s1">]);</span>
        <span class="s3">return this</span><span class="s1">.scopeManager.scopes[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Get the variables that `node` defines. 
     * This is a convenience method that passes through 
     * to the same method on the `scopeManager`. 
     * @param {ASTNode} node The node for which the variables are obtained. 
     * @returns {Array&lt;Variable&gt;} An array of variable nodes representing 
     *      the variables that `node` defines. 
     */</span>
    <span class="s1">getDeclaredVariables(node) {</span>
        <span class="s3">return this</span><span class="s1">.scopeManager.getDeclaredVariables(node);</span>
    <span class="s1">}</span>

    <span class="s0">/* eslint-disable class-methods-use-this -- node is owned by SourceCode */</span>
    <span class="s0">/** 
     * Gets all the ancestors of a given node 
     * @param {ASTNode} node The node 
     * @returns {Array&lt;ASTNode&gt;} All the ancestor nodes in the AST, not including the provided node, starting 
     * from the root node at index 0 and going inwards to the parent node. 
     * @throws {TypeError} When `node` is missing. 
     */</span>
    <span class="s1">getAncestors(node) {</span>

        <span class="s3">if </span><span class="s1">(!node) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;Missing required argument: node.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">const ancestorsStartingAtParent = [];</span>

        <span class="s3">for </span><span class="s1">(let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {</span>
            <span class="s1">ancestorsStartingAtParent.push(ancestor);</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">ancestorsStartingAtParent.reverse();</span>
    <span class="s1">}</span>
    <span class="s0">/* eslint-enable class-methods-use-this -- node is owned by SourceCode */</span>

    <span class="s0">/** 
     * Marks a variable as used in the current scope 
     * @param {string} name The name of the variable to mark as used. 
     * @param {ASTNode} [refNode] The closest node to the variable reference. 
     * @returns {boolean} True if the variable was found and marked as used, false if not. 
     */</span>
    <span class="s1">markVariableAsUsed(name, refNode = </span><span class="s3">this</span><span class="s1">.ast) {</span>

        <span class="s1">const currentScope = </span><span class="s3">this</span><span class="s1">.getScope(refNode);</span>
        <span class="s1">let initialScope = currentScope;</span>

        <span class="s0">/* 
         * When we are in an ESM or CommonJS module, we need to start searching 
         * from the top-level scope, not the global scope. For ESM the top-level 
         * scope is the module scope; for CommonJS the top-level scope is the 
         * outer function scope. 
         * 
         * Without this check, we might miss a variable declared with `var` at 
         * the top-level because it won't exist in the global scope. 
         */</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">currentScope.type === </span><span class="s2">&quot;global&quot; </span><span class="s1">&amp;&amp;</span>
            <span class="s1">currentScope.childScopes.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>

            <span class="s0">// top-level scopes refer to a `Program` node</span>
            <span class="s1">currentScope.childScopes[</span><span class="s4">0</span><span class="s1">].block === </span><span class="s3">this</span><span class="s1">.ast</span>
        <span class="s1">) {</span>
            <span class="s1">initialScope = currentScope.childScopes[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s1">}</span>

        <span class="s3">for </span><span class="s1">(let scope = initialScope; scope; scope = scope.upper) {</span>
            <span class="s1">const variable = scope.variables.find(scopeVar =&gt; scopeVar.name === name);</span>

            <span class="s3">if </span><span class="s1">(variable) {</span>
                <span class="s1">variable.eslintUsed = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>


<span class="s1">}</span>

<span class="s1">module.exports = SourceCode;</span>
</pre>
</body>
</html>
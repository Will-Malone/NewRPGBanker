<html>
<head>
<title>HermesParser.js.flow</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
HermesParser.js.flow</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Copyright (c) Meta Platforms, Inc. and affiliates.</span>
 <span class="s0">*</span>
 <span class="s0">* This source code is licensed under the MIT license found in the</span>
 <span class="s0">* LICENSE file in the root directory of this source tree.</span>
 <span class="s0">*</span>
 <span class="s0">* @flow strict</span>
 <span class="s0">* @format</span>
 <span class="s0">*/</span>

<span class="s0">'use strict';</span>

<span class="s0">import type {HermesNode} from './HermesAST';</span>
<span class="s0">import type {ParserOptions} from './ParserOptions';</span>

<span class="s0">import HermesParserDeserializer from './HermesParserDeserializer';</span>
<span class="s0">import HermesParserWASMModule from './HermesParserWASM';</span>

<span class="s0">let HermesParserWASM;</span>
<span class="s0">let hermesParse;</span>
<span class="s0">let hermesParseResult_free;</span>
<span class="s0">let hermesParseResult_getError;</span>
<span class="s0">let hermesParseResult_getErrorLine;</span>
<span class="s0">let hermesParseResult_getErrorColumn;</span>
<span class="s0">let hermesParseResult_getProgramBuffer;</span>
<span class="s0">let hermesParseResult_getPositionBuffer;</span>
<span class="s0">let hermesParseResult_getPositionBufferSize;</span>

<span class="s0">/**</span>
 <span class="s0">* Init the WASM wrapper code generated by `emscripten` to preparse the</span>
 <span class="s0">* HermesParser WASM code.</span>
 <span class="s0">*/</span>
<span class="s0">function initHermesParserWASM() {</span>
  <span class="s0">if (HermesParserWASM != null) {</span>
    <span class="s0">return;</span>
  <span class="s0">}</span>

  <span class="s0">HermesParserWASM = HermesParserWASMModule({</span>
    <span class="s0">/**</span>
     <span class="s0">* The emscripten version of `quit` unconditionally assigns the `status` to</span>
     <span class="s0">* `process.exitCode` which overrides any pre-existing code that has been</span>
     <span class="s0">* set, even if it is non zero. For our use case we never want an</span>
     <span class="s0">* `exitCode` to be set so this override removes that functionality.</span>
     <span class="s0">*/</span>
    <span class="s0">quit(_status: number, toThrow: Error) {</span>
      <span class="s0">throw toThrow;</span>
    <span class="s0">},</span>
  <span class="s0">});</span>

  <span class="s0">hermesParse = HermesParserWASM.cwrap('hermesParse', 'number', [</span>
    <span class="s0">'number',</span>
    <span class="s0">'number',</span>
    <span class="s0">'number',</span>
    <span class="s0">'number',</span>
    <span class="s0">'number',</span>
    <span class="s0">'number',</span>
  <span class="s0">]);</span>

  <span class="s0">hermesParseResult_free = HermesParserWASM.cwrap(</span>
    <span class="s0">'hermesParseResult_free',</span>
    <span class="s0">'void',</span>
    <span class="s0">['number'],</span>
  <span class="s0">);</span>

  <span class="s0">hermesParseResult_getError = HermesParserWASM.cwrap(</span>
    <span class="s0">'hermesParseResult_getError',</span>
    <span class="s0">'string',</span>
    <span class="s0">['number'],</span>
  <span class="s0">);</span>

  <span class="s0">hermesParseResult_getErrorLine = HermesParserWASM.cwrap(</span>
    <span class="s0">'hermesParseResult_getErrorLine',</span>
    <span class="s0">'number',</span>
    <span class="s0">['number'],</span>
  <span class="s0">);</span>

  <span class="s0">hermesParseResult_getErrorColumn = HermesParserWASM.cwrap(</span>
    <span class="s0">'hermesParseResult_getErrorColumn',</span>
    <span class="s0">'number',</span>
    <span class="s0">['number'],</span>
  <span class="s0">);</span>

  <span class="s0">hermesParseResult_getProgramBuffer = HermesParserWASM.cwrap(</span>
    <span class="s0">'hermesParseResult_getProgramBuffer',</span>
    <span class="s0">'number',</span>
    <span class="s0">['number'],</span>
  <span class="s0">);</span>

  <span class="s0">hermesParseResult_getPositionBuffer = HermesParserWASM.cwrap(</span>
    <span class="s0">'hermesParseResult_getPositionBuffer',</span>
    <span class="s0">'number',</span>
    <span class="s0">['number'],</span>
  <span class="s0">);</span>

  <span class="s0">hermesParseResult_getPositionBufferSize = HermesParserWASM.cwrap(</span>
    <span class="s0">'hermesParseResult_getPositionBufferSize',</span>
    <span class="s0">'number',</span>
    <span class="s0">['number'],</span>
  <span class="s0">);</span>
<span class="s0">}</span>

<span class="s0">// Copy a string into the WASM heap and null-terminate</span>
<span class="s0">function copyToHeap(buffer: Buffer, addr: number) {</span>
  <span class="s0">HermesParserWASM.HEAP8.set(buffer, addr);</span>
  <span class="s0">HermesParserWASM.HEAP8[addr + buffer.length] = 0;</span>
<span class="s0">}</span>

<span class="s0">export function parse(source: string, options: ParserOptions): HermesNode {</span>
  <span class="s0">initHermesParserWASM();</span>

  <span class="s0">// Allocate space on heap for source text</span>
  <span class="s0">const sourceBuffer = Buffer.from(source, 'utf8');</span>
  <span class="s0">const sourceAddr = HermesParserWASM._malloc(sourceBuffer.length + 1);</span>
  <span class="s0">if (!sourceAddr) {</span>
    <span class="s0">throw new Error('Parser out of memory');</span>
  <span class="s0">}</span>

  <span class="s0">try {</span>
    <span class="s0">// Copy source text onto WASM heap</span>
    <span class="s0">copyToHeap(sourceBuffer, sourceAddr);</span>

    <span class="s0">const parseResult = hermesParse(</span>
      <span class="s0">sourceAddr,</span>
      <span class="s0">sourceBuffer.length + 1,</span>
      <span class="s0">options.flow === 'detect',</span>
      <span class="s0">options.enableExperimentalComponentSyntax,</span>
      <span class="s0">options.tokens,</span>
      <span class="s0">options.allowReturnOutsideFunction,</span>
    <span class="s0">);</span>

    <span class="s0">try {</span>
      <span class="s0">// Extract and throw error from parse result if parsing failed</span>
      <span class="s0">const err = hermesParseResult_getError(parseResult);</span>
      <span class="s0">if (err) {</span>
        <span class="s0">const syntaxError = new SyntaxError(err);</span>
        <span class="s0">// $FlowExpectedError[prop-missing]</span>
        <span class="s0">syntaxError.loc = {</span>
          <span class="s0">line: hermesParseResult_getErrorLine(parseResult),</span>
          <span class="s0">column: hermesParseResult_getErrorColumn(parseResult),</span>
        <span class="s0">};</span>

        <span class="s0">throw syntaxError;</span>
      <span class="s0">}</span>

      <span class="s0">const deserializer = new HermesParserDeserializer(</span>
        <span class="s0">hermesParseResult_getProgramBuffer(parseResult),</span>
        <span class="s0">hermesParseResult_getPositionBuffer(parseResult),</span>
        <span class="s0">hermesParseResult_getPositionBufferSize(parseResult),</span>
        <span class="s0">HermesParserWASM,</span>
        <span class="s0">options,</span>
      <span class="s0">);</span>
      <span class="s0">return deserializer.deserialize();</span>
    <span class="s0">} finally {</span>
      <span class="s0">hermesParseResult_free(parseResult);</span>
    <span class="s0">}</span>
  <span class="s0">} finally {</span>
    <span class="s0">HermesParserWASM._free(sourceAddr);</span>
  <span class="s0">}</span>
<span class="s0">}</span>
</pre>
</body>
</html>
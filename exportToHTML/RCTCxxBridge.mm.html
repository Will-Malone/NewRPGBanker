<html>
<head>
<title>RCTCxxBridge.mm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #cc7832;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RCTCxxBridge.mm</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#include </span><span class="s3">&lt;atomic&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;future&gt;</span>

<span class="s2">#import </span><span class="s3">&lt;React/RCTAssert.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTBridge+Private.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTBridge.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTBridgeMethod.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTBridgeModule.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTBridgeModuleDecorator.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTConstants.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTConvert.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTCxxBridgeDelegate.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTCxxModule.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTCxxUtils.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTDevSettings.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTDisplayLink.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTFollyConvert.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTJavaScriptLoader.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTLog.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTModuleData.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTPerformanceLogger.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTProfile.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTRedBox.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTReloadCommand.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTTurboModuleRegistry.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTUtils.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;cxxreact/CxxNativeModule.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;cxxreact/Instance.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;cxxreact/JSBundleType.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;cxxreact/JSIndexedRAMBundle.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;cxxreact/ModuleRegistry.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;cxxreact/RAMBundleRegistry.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;cxxreact/ReactMarker.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;jsireact/JSIExecutor.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;reactperflogger/BridgeNativeModulePerfLogger.h&gt;</span>

<span class="s2">#ifndef </span><span class="s1">RCT_USE_HERMES</span>
<span class="s2">#if </span><span class="s1">__has_include(&lt;reacthermes/HermesExecutorFactory.h&gt;)</span>
<span class="s2">#define </span><span class="s1">RCT_USE_HERMES </span><span class="s4">1</span>
<span class="s2">#else</span>
<span class="s2">#define </span><span class="s1">RCT_USE_HERMES </span><span class="s4">0</span>
<span class="s2">#endif</span>
<span class="s2">#endif</span>

<span class="s2">#if </span><span class="s1">RCT_USE_HERMES</span>
<span class="s2">#import </span><span class="s3">&lt;reacthermes/HermesExecutorFactory.h&gt;</span>
<span class="s2">#else</span>
<span class="s2">#import </span><span class="s3">&quot;JSCExecutorFactory.h&quot;</span>
<span class="s2">#endif</span>
<span class="s2">#import </span><span class="s3">&quot;RCTJSIExecutorRuntimeInstaller.h&quot;</span>

<span class="s2">#import </span><span class="s3">&quot;NSDataBigString.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTMessageThread.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTObjcExecutor.h&quot;</span>

<span class="s2">#ifdef </span><span class="s1">WITH_FBSYSTRACE</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTFBSystrace.h&gt;</span>
<span class="s2">#endif</span>

<span class="s2">#if </span><span class="s1">(RCT_DEV | RCT_ENABLE_LOADING_VIEW) &amp;&amp; __has_include(&lt;React/RCTDevLoadingViewProtocol.h&gt;)</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTDevLoadingViewProtocol.h&gt;</span>
<span class="s2">#endif</span>

<span class="s5">static </span><span class="s1">NSString *</span><span class="s5">const </span><span class="s1">RCTJSThreadName = </span><span class="s5">@</span><span class="s3">&quot;com.facebook.react.JavaScript&quot;</span><span class="s5">;</span>

<span class="s5">typedef void </span><span class="s1">(^RCTPendingCall)()</span><span class="s5">;</span>

<span class="s5">using namespace </span><span class="s1">facebook::jsi</span><span class="s5">;</span>
<span class="s5">using namespace </span><span class="s1">facebook::react</span><span class="s5">;</span>

<span class="s0">/** 
 * Must be kept in sync with `MessageQueue.js`. 
 */</span>
<span class="s5">typedef </span><span class="s1">NS_ENUM(NSInteger</span><span class="s5">, </span><span class="s1">RCTBridgeFields) {</span>
  <span class="s1">RCTBridgeFieldRequestModuleIDs = </span><span class="s4">0</span><span class="s5">,</span>
  <span class="s1">RCTBridgeFieldMethodIDs</span><span class="s5">,</span>
  <span class="s1">RCTBridgeFieldParams</span><span class="s5">,</span>
  <span class="s1">RCTBridgeFieldCallID</span><span class="s5">,</span>
<span class="s1">}</span><span class="s5">;</span>

<span class="s5">namespace </span><span class="s1">{</span>

<span class="s1">int32_t getUniqueId()</span>
<span class="s1">{</span>
  <span class="s5">static </span><span class="s1">std::atomic&lt;int32_t&gt; counter{</span><span class="s4">0</span><span class="s1">}</span><span class="s5">;</span>
  <span class="s5">return </span><span class="s1">counter++</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">class </span><span class="s1">GetDescAdapter : </span><span class="s5">public </span><span class="s1">JSExecutorFactory {</span>
 <span class="s5">public</span><span class="s1">:</span>
  <span class="s1">GetDescAdapter(RCTCxxBridge *bridge</span><span class="s5">, </span><span class="s1">std::shared_ptr&lt;JSExecutorFactory&gt; factory) : bridge_(bridge)</span><span class="s5">, </span><span class="s1">factory_(factory)</span>
  <span class="s1">{</span>
  <span class="s1">}</span>
  <span class="s1">std::unique_ptr&lt;JSExecutor&gt; createJSExecutor(</span>
      <span class="s1">std::shared_ptr&lt;ExecutorDelegate&gt; delegate</span><span class="s5">,</span>
      <span class="s1">std::shared_ptr&lt;MessageQueueThread&gt; jsQueue) override</span>
  <span class="s1">{</span>
    <span class="s5">auto </span><span class="s1">ret = factory_-&gt;createJSExecutor(delegate</span><span class="s5">, </span><span class="s1">jsQueue)</span><span class="s5">;</span>
    <span class="s1">bridge_.bridgeDescription = </span><span class="s5">@</span><span class="s1">(ret-&gt;getDescription().c_str())</span><span class="s5">;</span>
    <span class="s5">return </span><span class="s1">ret</span><span class="s5">;</span>
  <span class="s1">}</span>

 <span class="s5">private</span><span class="s1">:</span>
  <span class="s1">RCTCxxBridge *bridge_</span><span class="s5">;</span>
  <span class="s1">std::shared_ptr&lt;JSExecutorFactory&gt; factory_</span><span class="s5">;</span>
<span class="s1">}</span><span class="s5">;</span>

<span class="s1">}</span>

<span class="s5">static void </span><span class="s1">notifyAboutModuleSetup(RCTPerformanceLogger *performanceLogger</span><span class="s5">, const char </span><span class="s1">*tag)</span>
<span class="s1">{</span>
  <span class="s1">NSString *moduleName = [[NSString alloc] initWithUTF8String:tag]</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(moduleName) {</span>
    <span class="s1">int64_t setupTime = [performanceLogger durationForTag:RCTPLNativeModuleSetup]</span><span class="s5">;</span>
    <span class="s1">[[NSNotificationCenter defaultCenter] postNotificationName:RCTDidSetupModuleNotification</span>
                                                        <span class="s1">object:nil</span>
                                                      <span class="s1">userInfo:</span><span class="s5">@</span><span class="s1">{</span>
                                                        <span class="s1">RCTDidSetupModuleNotificationModuleNameKey : moduleName</span><span class="s5">,</span>
                                                        <span class="s1">RCTDidSetupModuleNotificationSetupTimeKey : </span><span class="s5">@</span><span class="s1">(setupTime)</span>
                                                      <span class="s1">}]</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">static void </span><span class="s1">mapReactMarkerToPerformanceLogger(</span>
    <span class="s5">const </span><span class="s1">ReactMarker::ReactMarkerId markerId</span><span class="s5">,</span>
    <span class="s1">RCTPerformanceLogger *performanceLogger</span><span class="s5">,</span>
    <span class="s5">const char </span><span class="s1">*tag)</span>
<span class="s1">{</span>
  <span class="s5">switch </span><span class="s1">(markerId) {</span>
    <span class="s5">case </span><span class="s1">ReactMarker::RUN_JS_BUNDLE_START:</span>
      <span class="s1">[performanceLogger markStartForTag:RCTPLScriptExecution]</span><span class="s5">;</span>
      <span class="s5">break;</span>
    <span class="s5">case </span><span class="s1">ReactMarker::RUN_JS_BUNDLE_STOP:</span>
      <span class="s1">[performanceLogger markStopForTag:RCTPLScriptExecution]</span><span class="s5">;</span>
      <span class="s5">break;</span>
    <span class="s5">case </span><span class="s1">ReactMarker::NATIVE_REQUIRE_START:</span>
      <span class="s1">[performanceLogger appendStartForTag:RCTPLRAMNativeRequires]</span><span class="s5">;</span>
      <span class="s5">break;</span>
    <span class="s5">case </span><span class="s1">ReactMarker::NATIVE_REQUIRE_STOP:</span>
      <span class="s1">[performanceLogger appendStopForTag:RCTPLRAMNativeRequires]</span><span class="s5">;</span>
      <span class="s1">[performanceLogger addValue:</span><span class="s4">1 </span><span class="s1">forTag:RCTPLRAMNativeRequiresCount]</span><span class="s5">;</span>
      <span class="s5">break;</span>
    <span class="s5">case </span><span class="s1">ReactMarker::NATIVE_MODULE_SETUP_START:</span>
      <span class="s1">[performanceLogger markStartForTag:RCTPLNativeModuleSetup]</span><span class="s5">;</span>
      <span class="s5">break;</span>
    <span class="s5">case </span><span class="s1">ReactMarker::NATIVE_MODULE_SETUP_STOP:</span>
      <span class="s1">[performanceLogger markStopForTag:RCTPLNativeModuleSetup]</span><span class="s5">;</span>
      <span class="s1">notifyAboutModuleSetup(performanceLogger</span><span class="s5">, </span><span class="s1">tag)</span><span class="s5">;</span>
      <span class="s5">break;</span>
      <span class="s0">// Not needed in bridge mode.</span>
    <span class="s5">case </span><span class="s1">ReactMarker::REACT_INSTANCE_INIT_START:</span>
    <span class="s5">case </span><span class="s1">ReactMarker::REACT_INSTANCE_INIT_STOP:</span>
      <span class="s0">// Not used on iOS.</span>
    <span class="s5">case </span><span class="s1">ReactMarker::CREATE_REACT_CONTEXT_STOP:</span>
    <span class="s5">case </span><span class="s1">ReactMarker::JS_BUNDLE_STRING_CONVERT_START:</span>
    <span class="s5">case </span><span class="s1">ReactMarker::JS_BUNDLE_STRING_CONVERT_STOP:</span>
    <span class="s5">case </span><span class="s1">ReactMarker::REGISTER_JS_SEGMENT_START:</span>
    <span class="s5">case </span><span class="s1">ReactMarker::REGISTER_JS_SEGMENT_STOP:</span>
      <span class="s5">break;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">static void </span><span class="s1">registerPerformanceLoggerHooks(RCTPerformanceLogger *performanceLogger)</span>
<span class="s1">{</span>
  <span class="s5">__weak </span><span class="s1">RCTPerformanceLogger *weakPerformanceLogger = performanceLogger</span><span class="s5">;</span>
  <span class="s1">ReactMarker::logTaggedMarkerImpl = [weakPerformanceLogger](</span>
                                         <span class="s5">const </span><span class="s1">ReactMarker::ReactMarkerId markerId</span><span class="s5">, const char </span><span class="s1">*tag) {</span>
    <span class="s1">mapReactMarkerToPerformanceLogger(markerId</span><span class="s5">, </span><span class="s1">weakPerformanceLogger</span><span class="s5">, </span><span class="s1">tag)</span><span class="s5">;</span>
  <span class="s1">}</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">@interface </span><span class="s1">RCTCxxBridge ()</span>

<span class="s5">@property </span><span class="s1">(nonatomic</span><span class="s5">, </span><span class="s1">weak</span><span class="s5">, </span><span class="s1">readonly) RCTBridge *parentBridge</span><span class="s5">;</span>
<span class="s5">@property </span><span class="s1">(nonatomic</span><span class="s5">, </span><span class="s1">assign</span><span class="s5">, </span><span class="s1">readonly) BOOL moduleSetupComplete</span><span class="s5">;</span>

<span class="s1">- (instancetype)initWithParentBridge:(RCTBridge *)bridge</span><span class="s5">;</span>
<span class="s1">- (</span><span class="s5">void</span><span class="s1">)partialBatchDidFlush</span><span class="s5">;</span>
<span class="s1">- (</span><span class="s5">void</span><span class="s1">)batchDidComplete</span><span class="s5">;</span>

<span class="s5">@end</span>

<span class="s5">struct </span><span class="s1">RCTInstanceCallback : </span><span class="s5">public </span><span class="s1">InstanceCallback {</span>
  <span class="s5">__weak </span><span class="s1">RCTCxxBridge *bridge_</span><span class="s5">;</span>
  <span class="s1">RCTInstanceCallback(RCTCxxBridge *bridge) : bridge_(bridge){}</span><span class="s5">;</span>
  <span class="s5">void </span><span class="s1">onBatchComplete() override</span>
  <span class="s1">{</span>
    <span class="s0">// There's no interface to call this per partial batch</span>
    <span class="s1">[bridge_ partialBatchDidFlush]</span><span class="s5">;</span>
    <span class="s1">[bridge_ batchDidComplete]</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s5">;</span>

<span class="s5">@implementation </span><span class="s1">RCTCxxBridge {</span>
  <span class="s1">BOOL _didInvalidate</span><span class="s5">;</span>
  <span class="s1">BOOL _moduleRegistryCreated</span><span class="s5">;</span>

  <span class="s1">NSMutableArray&lt;RCTPendingCall&gt; *_pendingCalls</span><span class="s5">;</span>
  <span class="s1">std::atomic&lt;NSInteger&gt; _pendingCount</span><span class="s5">;</span>

  <span class="s0">// Native modules</span>
  <span class="s1">NSMutableDictionary&lt;NSString *</span><span class="s5">, </span><span class="s1">RCTModuleData *&gt; *_moduleDataByName</span><span class="s5">;</span>
  <span class="s1">NSMutableArray&lt;RCTModuleData *&gt; *_moduleDataByID</span><span class="s5">;</span>
  <span class="s1">NSMutableArray&lt;Class&gt; *_moduleClassesByID</span><span class="s5">;</span>
  <span class="s1">NSUInteger _modulesInitializedOnMainQueue</span><span class="s5">;</span>
  <span class="s1">RCTDisplayLink *_displayLink</span><span class="s5">;</span>

  <span class="s0">// JS thread management</span>
  <span class="s1">NSThread *_jsThread</span><span class="s5">;</span>
  <span class="s1">std::shared_ptr&lt;RCTMessageThread&gt; _jsMessageThread</span><span class="s5">;</span>
  <span class="s1">std::mutex _moduleRegistryLock</span><span class="s5">;</span>

  <span class="s0">// This is uniquely owned, but weak_ptr is used.</span>
  <span class="s1">std::shared_ptr&lt;Instance&gt; _reactInstance</span><span class="s5">;</span>

  <span class="s0">// Necessary for searching in TurboModules in TurboModuleManager</span>
  <span class="s1">id&lt;RCTTurboModuleRegistry&gt; _turboModuleRegistry</span><span class="s5">;</span>

  <span class="s1">RCTModuleRegistry *_objCModuleRegistry</span><span class="s5">;</span>
  <span class="s1">RCTViewRegistry *_viewRegistry_DEPRECATED</span><span class="s5">;</span>
  <span class="s1">RCTBundleManager *_bundleManager</span><span class="s5">;</span>
  <span class="s1">RCTCallableJSModules *_callableJSModules</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">@synthesize </span><span class="s1">bridgeDescription = _bridgeDescription</span><span class="s5">;</span>
<span class="s5">@synthesize </span><span class="s1">loading = _loading</span><span class="s5">;</span>
<span class="s5">@synthesize </span><span class="s1">performanceLogger = _performanceLogger</span><span class="s5">;</span>
<span class="s5">@synthesize </span><span class="s1">valid = _valid</span><span class="s5">;</span>

<span class="s1">- (RCTModuleRegistry *)moduleRegistry</span>
<span class="s1">{</span>
  <span class="s5">return </span><span class="s1">_objCModuleRegistry</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)setRCTTurboModuleRegistry:(id&lt;RCTTurboModuleRegistry&gt;)turboModuleRegistry</span>
<span class="s1">{</span>
  <span class="s1">_turboModuleRegistry = turboModuleRegistry</span><span class="s5">;</span>
  <span class="s1">[_objCModuleRegistry setTurboModuleRegistry:_turboModuleRegistry]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)attachBridgeAPIsToTurboModule:(id&lt;RCTTurboModule&gt;)module</span>
<span class="s1">{</span>
  <span class="s1">RCTBridgeModuleDecorator *bridgeModuleDecorator =</span>
      <span class="s1">[[RCTBridgeModuleDecorator alloc] initWithViewRegistry:_viewRegistry_DEPRECATED</span>
                                              <span class="s1">moduleRegistry:_objCModuleRegistry</span>
                                               <span class="s1">bundleManager:_bundleManager</span>
                                           <span class="s1">callableJSModules:_callableJSModules]</span><span class="s5">;</span>
  <span class="s1">[bridgeModuleDecorator attachInteropAPIsToModule:(id&lt;RCTBridgeModule&gt;)module]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (std::shared_ptr&lt;MessageQueueThread&gt;)jsMessageThread</span>
<span class="s1">{</span>
  <span class="s5">return </span><span class="s1">_jsMessageThread</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)isInspectable</span>
<span class="s1">{</span>
  <span class="s5">return </span><span class="s1">_reactInstance ? _reactInstance-&gt;isInspectable() : NO</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (instancetype)initWithParentBridge:(RCTBridge *)bridge</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertParam(bridge)</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">((self = [super initWithDelegate:bridge.delegate</span>
                            <span class="s1">bundleURL:bridge.bundleURL</span>
                       <span class="s1">moduleProvider:bridge.moduleProvider</span>
                        <span class="s1">launchOptions:bridge.launchOptions])) {</span>
    <span class="s1">_parentBridge = bridge</span><span class="s5">;</span>
    <span class="s1">_performanceLogger = [bridge performanceLogger]</span><span class="s5">;</span>

    <span class="s1">registerPerformanceLoggerHooks(_performanceLogger)</span><span class="s5">;</span>

    <span class="s0">/** 
     * Set Initial State 
     */</span>
    <span class="s1">_valid = YES</span><span class="s5">;</span>
    <span class="s1">_loading = YES</span><span class="s5">;</span>
    <span class="s1">_moduleRegistryCreated = NO</span><span class="s5">;</span>
    <span class="s1">_pendingCalls = [NSMutableArray </span><span class="s5">new</span><span class="s1">]</span><span class="s5">;</span>
    <span class="s1">_displayLink = [RCTDisplayLink </span><span class="s5">new</span><span class="s1">]</span><span class="s5">;</span>
    <span class="s1">_moduleDataByName = [NSMutableDictionary </span><span class="s5">new</span><span class="s1">]</span><span class="s5">;</span>
    <span class="s1">_moduleClassesByID = [NSMutableArray </span><span class="s5">new</span><span class="s1">]</span><span class="s5">;</span>
    <span class="s1">_moduleDataByID = [NSMutableArray </span><span class="s5">new</span><span class="s1">]</span><span class="s5">;</span>
    <span class="s1">_objCModuleRegistry = [RCTModuleRegistry </span><span class="s5">new</span><span class="s1">]</span><span class="s5">;</span>
    <span class="s1">[_objCModuleRegistry setBridge:self]</span><span class="s5">;</span>
    <span class="s1">_bundleManager = [RCTBundleManager </span><span class="s5">new</span><span class="s1">]</span><span class="s5">;</span>
    <span class="s1">[_bundleManager setBridge:self]</span><span class="s5">;</span>
    <span class="s1">_viewRegistry_DEPRECATED = [RCTViewRegistry </span><span class="s5">new</span><span class="s1">]</span><span class="s5">;</span>
    <span class="s1">[_viewRegistry_DEPRECATED setBridge:self]</span><span class="s5">;</span>
    <span class="s1">_callableJSModules = [RCTCallableJSModules </span><span class="s5">new</span><span class="s1">]</span><span class="s5">;</span>
    <span class="s1">[_callableJSModules setBridge:self]</span><span class="s5">;</span>

    <span class="s1">[RCTBridge setCurrentBridge:self]</span><span class="s5">;</span>

    <span class="s1">[[NSNotificationCenter defaultCenter] addObserver:self</span>
                                             <span class="s5">selector</span><span class="s1">:</span><span class="s5">@selector</span><span class="s1">(handleMemoryWarning)</span>
                                                 <span class="s1">name:UIApplicationDidReceiveMemoryWarningNotification</span>
                                               <span class="s1">object:nil]</span><span class="s5">;</span>

    <span class="s1">RCTLogSetBridgeModuleRegistry(_objCModuleRegistry)</span><span class="s5">;</span>
    <span class="s1">RCTLogSetBridgeCallableJSModules(_callableJSModules)</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s5">return </span><span class="s1">self</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)dealloc</span>
<span class="s1">{</span>
  <span class="s1">[[NSNotificationCenter defaultCenter] removeObserver:self]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">+ (</span><span class="s5">void</span><span class="s1">)runRunLoop</span>
<span class="s1">{</span>
  <span class="s5">@autoreleasepool </span><span class="s1">{</span>
    <span class="s1">RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;-[RCTCxxBridge runJSRunLoop] setup&quot;</span><span class="s5">, </span><span class="s1">nil)</span><span class="s5">;</span>

    <span class="s0">// copy thread name to pthread name</span>
    <span class="s1">pthread_setname_np([NSThread currentThread].name.UTF8String)</span><span class="s5">;</span>

    <span class="s0">// Set up a dummy runloop source to avoid spinning</span>
    <span class="s1">CFRunLoopSourceContext noSpinCtx = {</span><span class="s4">0</span><span class="s5">, </span><span class="s1">NULL</span><span class="s5">, </span><span class="s1">NULL</span><span class="s5">, </span><span class="s1">NULL</span><span class="s5">, </span><span class="s1">NULL</span><span class="s5">, </span><span class="s1">NULL</span><span class="s5">, </span><span class="s1">NULL</span><span class="s5">, </span><span class="s1">NULL</span><span class="s5">, </span><span class="s1">NULL</span><span class="s5">, </span><span class="s1">NULL}</span><span class="s5">;</span>
    <span class="s1">CFRunLoopSourceRef noSpinSource = CFRunLoopSourceCreate(NULL</span><span class="s5">, </span><span class="s4">0</span><span class="s5">, </span><span class="s1">&amp;noSpinCtx)</span><span class="s5">;</span>
    <span class="s1">CFRunLoopAddSource(CFRunLoopGetCurrent()</span><span class="s5">, </span><span class="s1">noSpinSource</span><span class="s5">, </span><span class="s1">kCFRunLoopDefaultMode)</span><span class="s5">;</span>
    <span class="s1">CFRelease(noSpinSource)</span><span class="s5">;</span>

    <span class="s1">RCT_PROFILE_END_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s5">;</span>

    <span class="s0">// run the run loop</span>
    <span class="s5">while </span><span class="s1">(kCFRunLoopRunStopped !=</span>
           <span class="s1">CFRunLoopRunInMode(</span>
               <span class="s1">kCFRunLoopDefaultMode</span><span class="s5">, </span><span class="s1">((NSDate *)[NSDate distantFuture]).timeIntervalSinceReferenceDate</span><span class="s5">, </span><span class="s1">NO)) {</span>
      <span class="s1">RCTAssert(NO</span><span class="s5">, @</span><span class="s3">&quot;not reached assertion&quot;</span><span class="s1">)</span><span class="s5">; </span><span class="s0">// runloop spun. that's bad.</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)_tryAndHandleError:(dispatch_block_t)block</span>
<span class="s1">{</span>
  <span class="s1">NSError *error = tryAndReturnError(block)</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(error) {</span>
    <span class="s1">[self handleError:error]</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)handleMemoryWarning</span>
<span class="s1">{</span>
  <span class="s0">// We only want to run garbage collector when the loading is finished</span>
  <span class="s0">// and the instance is valid.</span>
  <span class="s5">if </span><span class="s1">(!_valid || _loading) {</span>
    <span class="s5">return;</span>
  <span class="s1">}</span>

  <span class="s0">// We need to hold a local retaining pointer to react instance</span>
  <span class="s0">// in case if some other tread resets it.</span>
  <span class="s5">auto </span><span class="s1">reactInstance = _reactInstance</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(reactInstance) {</span>
    <span class="s5">int </span><span class="s1">unloadLevel = RCTGetMemoryPressureUnloadLevel()</span><span class="s5">;</span>
    <span class="s1">reactInstance-&gt;handleMemoryPressure(unloadLevel)</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Ensure block is run on the JS thread. If we're already on the JS thread, the block will execute synchronously. 
 * If we're not on the JS thread, the block is dispatched to that thread. Any errors encountered while executing 
 * the block will go through handleError: 
 */</span>
<span class="s1">- (</span><span class="s5">void</span><span class="s1">)ensureOnJavaScriptThread:(dispatch_block_t)block</span>
<span class="s1">{</span>
  <span class="s1">RCTAssert(_jsThread</span><span class="s5">, @</span><span class="s3">&quot;This method must not be called before the JS thread is created&quot;</span><span class="s1">)</span><span class="s5">;</span>

  <span class="s0">// This does not use _jsMessageThread because it may be called early before the runloop reference is captured</span>
  <span class="s0">// and _jsMessageThread is valid. _jsMessageThread also doesn't allow us to shortcut the dispatch if we're</span>
  <span class="s0">// already on the correct thread.</span>

  <span class="s5">if </span><span class="s1">([NSThread currentThread] == _jsThread) {</span>
    <span class="s1">[self _tryAndHandleError:block]</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s1">[self performSelector:</span><span class="s5">@selector</span><span class="s1">(_tryAndHandleError:) onThread:_jsThread withObject:block waitUntilDone:NO]</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)start</span>
<span class="s1">{</span>
  <span class="s1">RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;-[RCTCxxBridge start]&quot;</span><span class="s5">, </span><span class="s1">nil)</span><span class="s5">;</span>

  <span class="s1">[[NSNotificationCenter defaultCenter] postNotificationName:RCTJavaScriptWillStartLoadingNotification</span>
                                                      <span class="s1">object:_parentBridge</span>
                                                    <span class="s1">userInfo:</span><span class="s5">@</span><span class="s1">{</span><span class="s5">@</span><span class="s3">&quot;bridge&quot; </span><span class="s1">: self}]</span><span class="s5">;</span>

  <span class="s0">// Set up the JS thread early</span>
  <span class="s1">_jsThread = [[NSThread alloc] initWithTarget:[self </span><span class="s5">class</span><span class="s1">] </span><span class="s5">selector</span><span class="s1">:</span><span class="s5">@selector</span><span class="s1">(runRunLoop) object:nil]</span><span class="s5">;</span>
  <span class="s1">_jsThread.name = RCTJSThreadName</span><span class="s5">;</span>
  <span class="s1">_jsThread.qualityOfService = NSOperationQualityOfServiceUserInteractive</span><span class="s5">;</span>
<span class="s2">#if </span><span class="s1">RCT_DEBUG</span>
  <span class="s1">_jsThread.stackSize *= </span><span class="s4">2</span><span class="s5">;</span>
<span class="s2">#endif</span>
  <span class="s1">[_jsThread start]</span><span class="s5">;</span>

  <span class="s1">dispatch_group_t prepareBridge = dispatch_group_create()</span><span class="s5">;</span>

  <span class="s1">[_performanceLogger markStartForTag:RCTPLNativeModuleInit]</span><span class="s5">;</span>

  <span class="s1">[self registerExtraModules]</span><span class="s5">;</span>
  <span class="s0">// Initialize all native modules that cannot be loaded lazily</span>
  <span class="s1">(</span><span class="s5">void</span><span class="s1">)[self _initializeModules:RCTGetModuleClasses() withDispatchGroup:prepareBridge lazilyDiscovered:NO]</span><span class="s5">;</span>
  <span class="s1">[self registerExtraLazyModules]</span><span class="s5">;</span>

  <span class="s1">[_performanceLogger markStopForTag:RCTPLNativeModuleInit]</span><span class="s5">;</span>

  <span class="s0">// This doesn't really do anything.  The real work happens in initializeBridge.</span>
  <span class="s1">_reactInstance.reset(</span><span class="s5">new </span><span class="s1">Instance)</span><span class="s5">;</span>

  <span class="s5">__weak </span><span class="s1">RCTCxxBridge *weakSelf = self</span><span class="s5">;</span>

  <span class="s0">// Prepare executor factory (shared_ptr for copy into block)</span>
  <span class="s1">std::shared_ptr&lt;JSExecutorFactory&gt; executorFactory</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(!self.executorClass) {</span>
    <span class="s5">if </span><span class="s1">([self.delegate conformsToProtocol:</span><span class="s5">@protocol</span><span class="s1">(RCTCxxBridgeDelegate)]) {</span>
      <span class="s1">id&lt;RCTCxxBridgeDelegate&gt; cxxDelegate = (id&lt;RCTCxxBridgeDelegate&gt;)self.delegate</span><span class="s5">;</span>
      <span class="s1">executorFactory = [cxxDelegate jsExecutorFactoryForBridge:self]</span><span class="s5">;</span>
    <span class="s1">}</span>
    <span class="s5">if </span><span class="s1">(!executorFactory) {</span>
      <span class="s5">auto </span><span class="s1">installBindings = RCTJSIExecutorRuntimeInstaller(</span><span class="s5">nullptr</span><span class="s1">)</span><span class="s5">;</span>
<span class="s2">#if </span><span class="s1">RCT_USE_HERMES</span>
      <span class="s1">executorFactory = std::make_shared&lt;HermesExecutorFactory&gt;(installBindings)</span><span class="s5">;</span>
<span class="s2">#else</span>
      <span class="s1">executorFactory = std::make_shared&lt;JSCExecutorFactory&gt;(installBindings)</span><span class="s5">;</span>
<span class="s2">#endif</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s1">id&lt;RCTJavaScriptExecutor&gt; objcExecutor = [self moduleForClass:self.executorClass]</span><span class="s5">;</span>
    <span class="s1">executorFactory.reset(</span><span class="s5">new </span><span class="s1">RCTObjcExecutorFactory(objcExecutor</span><span class="s5">, </span><span class="s1">^(NSError *error) {</span>
      <span class="s5">if </span><span class="s1">(error) {</span>
        <span class="s1">[weakSelf handleError:error]</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}))</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * id&lt;RCTCxxBridgeDelegate&gt; jsExecutorFactory may create and assign an id&lt;RCTTurboModuleRegistry&gt; object to 
   * RCTCxxBridge If id&lt;RCTTurboModuleRegistry&gt; is assigned by this time, eagerly initialize all TurboModules 
   */</span>
  <span class="s5">if </span><span class="s1">(_turboModuleRegistry &amp;&amp; RCTTurboModuleEagerInitEnabled()) {</span>
    <span class="s5">for </span><span class="s1">(NSString *moduleName in [_turboModuleRegistry eagerInitModuleNames]) {</span>
      <span class="s1">[_turboModuleRegistry moduleForName:[moduleName UTF8String]]</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s5">for </span><span class="s1">(NSString *moduleName in [_turboModuleRegistry eagerInitMainQueueModuleNames]) {</span>
      <span class="s5">if </span><span class="s1">(RCTIsMainQueue()) {</span>
        <span class="s1">[_turboModuleRegistry moduleForName:[moduleName UTF8String]]</span><span class="s5">;</span>
      <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
        <span class="s1">id&lt;RCTTurboModuleRegistry&gt; turboModuleRegistry = _turboModuleRegistry</span><span class="s5">;</span>
        <span class="s1">dispatch_group_async(prepareBridge</span><span class="s5">, </span><span class="s1">dispatch_get_main_queue()</span><span class="s5">, </span><span class="s1">^{</span>
          <span class="s1">[turboModuleRegistry moduleForName:[moduleName UTF8String]]</span><span class="s5">;</span>
        <span class="s1">})</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Dispatch the instance initialization as soon as the initial module metadata has</span>
  <span class="s0">// been collected (see initModules)</span>
  <span class="s1">dispatch_group_enter(prepareBridge)</span><span class="s5">;</span>
  <span class="s1">[self ensureOnJavaScriptThread:^{</span>
    <span class="s1">[weakSelf _initializeBridge:executorFactory]</span><span class="s5">;</span>
    <span class="s1">dispatch_group_leave(prepareBridge)</span><span class="s5">;</span>
  <span class="s1">}]</span><span class="s5">;</span>

  <span class="s0">// Load the source asynchronously, then store it for later execution.</span>
  <span class="s1">dispatch_group_enter(prepareBridge)</span><span class="s5">;</span>
  <span class="s1">__block NSData *sourceCode</span><span class="s5">;</span>
  <span class="s1">__block NSURL *sourceURL = self.bundleURL</span><span class="s5">;</span>

<span class="s2">#if </span><span class="s1">(RCT_DEV | RCT_ENABLE_LOADING_VIEW) &amp;&amp; __has_include(&lt;React/RCTDevLoadingViewProtocol.h&gt;)</span>
  <span class="s1">{</span>
    <span class="s1">id&lt;RCTDevLoadingViewProtocol&gt; loadingView = [self moduleForName:</span><span class="s5">@</span><span class="s3">&quot;DevLoadingView&quot; </span><span class="s1">lazilyLoadIfNecessary:YES]</span><span class="s5">;</span>
    <span class="s1">[loadingView showWithURL:self.bundleURL]</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s2">#endif</span>

  <span class="s1">[self</span>
      <span class="s1">loadSource:^(NSError *error</span><span class="s5">, </span><span class="s1">RCTSource *source) {</span>
        <span class="s5">if </span><span class="s1">(error) {</span>
          <span class="s1">[weakSelf handleError:error]</span><span class="s5">;</span>
        <span class="s1">}</span>

        <span class="s1">sourceCode = source.data</span><span class="s5">;</span>
        <span class="s5">if </span><span class="s1">(source.url) {</span>
          <span class="s1">sourceURL = source.url</span><span class="s5">;</span>
        <span class="s1">}</span>
        <span class="s1">dispatch_group_leave(prepareBridge)</span><span class="s5">;</span>
      <span class="s1">}</span>
      <span class="s1">onProgress:^(RCTLoadingProgress *progressData) {</span>
<span class="s2">#if </span><span class="s1">(RCT_DEV | RCT_ENABLE_LOADING_VIEW) &amp;&amp; __has_include(&lt;React/RCTDevLoadingViewProtocol.h&gt;)</span>
        <span class="s1">id&lt;RCTDevLoadingViewProtocol&gt; loadingView = [weakSelf moduleForName:</span><span class="s5">@</span><span class="s3">&quot;DevLoadingView&quot;</span>
                                                      <span class="s1">lazilyLoadIfNecessary:YES]</span><span class="s5">;</span>
        <span class="s1">[loadingView updateProgress:progressData]</span><span class="s5">;</span>
<span class="s2">#endif</span>
      <span class="s1">}]</span><span class="s5">;</span>

  <span class="s0">// Wait for both the modules and source code to have finished loading</span>
  <span class="s1">dispatch_group_notify(prepareBridge</span><span class="s5">, </span><span class="s1">dispatch_get_global_queue(QOS_CLASS_USER_INTERACTIVE</span><span class="s5">, </span><span class="s4">0</span><span class="s1">)</span><span class="s5">, </span><span class="s1">^{</span>
    <span class="s1">RCTCxxBridge *strongSelf = weakSelf</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(sourceCode &amp;&amp; strongSelf.loading) {</span>
      <span class="s1">[strongSelf executeSourceCode:sourceCode withSourceURL:sourceURL sync:NO]</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s5">;</span>
  <span class="s1">RCT_PROFILE_END_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)loadSource:(RCTSourceLoadBlock)_onSourceLoad onProgress:(RCTSourceLoadProgressBlock)onProgress</span>
<span class="s1">{</span>
  <span class="s1">NSNotificationCenter *center = [NSNotificationCenter defaultCenter]</span><span class="s5">;</span>
  <span class="s1">[center postNotificationName:RCTBridgeWillDownloadScriptNotification object:_parentBridge]</span><span class="s5">;</span>
  <span class="s1">[_performanceLogger markStartForTag:RCTPLScriptDownload]</span><span class="s5">;</span>
  <span class="s1">NSUInteger cookie = RCTProfileBeginAsyncEvent(</span><span class="s4">0</span><span class="s5">, @</span><span class="s3">&quot;JavaScript download&quot;</span><span class="s5">, </span><span class="s1">nil)</span><span class="s5">;</span>

  <span class="s0">// Suppress a warning if RCTProfileBeginAsyncEvent gets compiled out</span>
  <span class="s1">(</span><span class="s5">void</span><span class="s1">)cookie</span><span class="s5">;</span>

  <span class="s1">RCTPerformanceLogger *performanceLogger = _performanceLogger</span><span class="s5">;</span>
  <span class="s1">RCTSourceLoadBlock onSourceLoad = ^(NSError *error</span><span class="s5">, </span><span class="s1">RCTSource *source) {</span>
    <span class="s1">RCTProfileEndAsyncEvent(</span><span class="s4">0</span><span class="s5">, @</span><span class="s3">&quot;native&quot;</span><span class="s5">, </span><span class="s1">cookie</span><span class="s5">, @</span><span class="s3">&quot;JavaScript download&quot;</span><span class="s5">, @</span><span class="s3">&quot;JS async&quot;</span><span class="s1">)</span><span class="s5">;</span>
    <span class="s1">[performanceLogger markStopForTag:RCTPLScriptDownload]</span><span class="s5">;</span>
    <span class="s1">[performanceLogger setValue:source.length forTag:RCTPLBundleSize]</span><span class="s5">;</span>

    <span class="s1">NSDictionary *userInfo = </span><span class="s5">@</span><span class="s1">{</span>
      <span class="s1">RCTBridgeDidDownloadScriptNotificationSourceKey : source ?: [NSNull null]</span><span class="s5">,</span>
      <span class="s1">RCTBridgeDidDownloadScriptNotificationBridgeDescriptionKey : self-&gt;_bridgeDescription ?: [NSNull null]</span><span class="s5">,</span>
    <span class="s1">}</span><span class="s5">;</span>

    <span class="s1">[center postNotificationName:RCTBridgeDidDownloadScriptNotification object:self-&gt;_parentBridge userInfo:userInfo]</span><span class="s5">;</span>

    <span class="s1">_onSourceLoad(error</span><span class="s5">, </span><span class="s1">source)</span><span class="s5">;</span>
  <span class="s1">}</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">([self.delegate respondsToSelector:</span><span class="s5">@selector</span><span class="s1">(loadSourceForBridge:onProgress:onComplete:)]) {</span>
    <span class="s1">[self.delegate loadSourceForBridge:_parentBridge onProgress:onProgress onComplete:onSourceLoad]</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">([self.delegate respondsToSelector:</span><span class="s5">@selector</span><span class="s1">(loadSourceForBridge:withBlock:)]) {</span>
    <span class="s1">[self.delegate loadSourceForBridge:_parentBridge withBlock:onSourceLoad]</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(!self.bundleURL) {</span>
    <span class="s1">NSError *error = RCTErrorWithMessage(</span>
        <span class="s5">@</span><span class="s3">&quot;No bundle URL present.</span><span class="s5">\n\n</span><span class="s3">Make sure you're running a packager &quot;</span>
         <span class="s3">&quot;server or have included a .jsbundle file in your application bundle.&quot;</span><span class="s1">)</span><span class="s5">;</span>
    <span class="s1">onSourceLoad(error</span><span class="s5">, </span><span class="s1">nil)</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s5">__weak </span><span class="s1">RCTCxxBridge *weakSelf = self</span><span class="s5">;</span>
    <span class="s1">[RCTJavaScriptLoader loadBundleAtURL:self.bundleURL</span>
                              <span class="s1">onProgress:onProgress</span>
                              <span class="s1">onComplete:^(NSError *error</span><span class="s5">, </span><span class="s1">RCTSource *source) {</span>
                                <span class="s5">if </span><span class="s1">(error) {</span>
                                  <span class="s1">[weakSelf handleError:error]</span><span class="s5">;</span>
                                  <span class="s5">return;</span>
                                <span class="s1">}</span>
                                <span class="s1">onSourceLoad(error</span><span class="s5">, </span><span class="s1">source)</span><span class="s5">;</span>
                              <span class="s1">}]</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (NSArray&lt;Class&gt; *)moduleClasses</span>
<span class="s1">{</span>
  <span class="s5">if </span><span class="s1">(RCT_DEBUG &amp;&amp; _valid &amp;&amp; _moduleClassesByID == nil) {</span>
    <span class="s1">RCTLogError(</span>
        <span class="s5">@</span><span class="s3">&quot;Bridge modules have not yet been initialized. You may be &quot;</span>
         <span class="s3">&quot;trying to access a module too early in the startup procedure.&quot;</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s5">return </span><span class="s1">_moduleClassesByID</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Used by RCTUIManager 
 */</span>
<span class="s1">- (RCTModuleData *)moduleDataForName:(NSString *)moduleName</span>
<span class="s1">{</span>
  <span class="s5">return </span><span class="s1">_moduleDataByName[moduleName]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (id)moduleForName:(NSString *)moduleName</span>
<span class="s1">{</span>
  <span class="s5">return </span><span class="s1">[self moduleForName:moduleName lazilyLoadIfNecessary:NO]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (id)moduleForName:(NSString *)moduleName lazilyLoadIfNecessary:(BOOL)lazilyLoad</span>
<span class="s1">{</span>
  <span class="s5">if </span><span class="s1">(RCTTurboModuleEnabled() &amp;&amp; _turboModuleRegistry) {</span>
    <span class="s5">const char </span><span class="s1">*moduleNameCStr = [moduleName UTF8String]</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(lazilyLoad || [_turboModuleRegistry moduleIsInitialized:moduleNameCStr]) {</span>
      <span class="s1">id&lt;RCTTurboModule&gt; module = [_turboModuleRegistry moduleForName:moduleNameCStr warnOnLookupFailure:NO]</span><span class="s5">;</span>
      <span class="s5">if </span><span class="s1">(module != nil) {</span>
        <span class="s5">return </span><span class="s1">module</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s5">if </span><span class="s1">(!lazilyLoad) {</span>
    <span class="s5">return </span><span class="s1">_moduleDataByName[moduleName].instance</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s1">RCTModuleData *moduleData = _moduleDataByName[moduleName]</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(moduleData) {</span>
    <span class="s5">if </span><span class="s1">(![moduleData isKindOfClass:[RCTModuleData </span><span class="s5">class</span><span class="s1">]]) {</span>
      <span class="s0">// There is rare race condition where the data stored in the dictionary</span>
      <span class="s0">// may have been deallocated, which means the module instance is no longer</span>
      <span class="s0">// usable.</span>
      <span class="s5">return </span><span class="s1">nil</span><span class="s5">;</span>
    <span class="s1">}</span>
    <span class="s5">return </span><span class="s1">moduleData.instance</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s0">// Module may not be loaded yet, so attempt to force load it here.</span>
  <span class="s0">// Do this only if the bridge is still valid.</span>
  <span class="s5">if </span><span class="s1">(_didInvalidate) {</span>
    <span class="s5">return </span><span class="s1">nil</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">const </span><span class="s1">BOOL result = [self.delegate respondsToSelector:</span><span class="s5">@selector</span><span class="s1">(bridge:didNotFindModule:)] &amp;&amp;</span>
      <span class="s1">[self.delegate bridge:self didNotFindModule:moduleName]</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(result) {</span>
    <span class="s0">// Try again.</span>
    <span class="s1">moduleData = _moduleDataByName[moduleName]</span><span class="s5">;</span>
<span class="s2">#if </span><span class="s1">RCT_DEV</span>
    <span class="s0">// If the `_moduleDataByName` is nil, it must have been cleared by the reload.</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(_moduleDataByName != nil) {</span>
    <span class="s1">RCTLogError(</span><span class="s5">@</span><span class="s3">&quot;Unable to find module for %@&quot;</span><span class="s5">, </span><span class="s1">moduleName)</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s2">#else</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s1">RCTLogError(</span><span class="s5">@</span><span class="s3">&quot;Unable to find module for %@&quot;</span><span class="s5">, </span><span class="s1">moduleName)</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s2">#endif</span>

  <span class="s5">return </span><span class="s1">moduleData.instance</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)moduleIsInitialized:(Class)moduleClass</span>
<span class="s1">{</span>
  <span class="s1">NSString *moduleName = RCTBridgeModuleNameForClass(moduleClass)</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(_moduleDataByName[moduleName].hasInstance) {</span>
    <span class="s5">return </span><span class="s1">YES</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">if </span><span class="s1">(_turboModuleRegistry) {</span>
    <span class="s5">return </span><span class="s1">[_turboModuleRegistry moduleIsInitialized:[moduleName UTF8String]]</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">return </span><span class="s1">NO</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (id)moduleForClass:(Class)moduleClass</span>
<span class="s1">{</span>
  <span class="s5">return </span><span class="s1">[self moduleForName:RCTBridgeModuleNameForClass(moduleClass) lazilyLoadIfNecessary:YES]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (std::shared_ptr&lt;ModuleRegistry&gt;)_buildModuleRegistryUnlocked</span>
<span class="s1">{</span>
  <span class="s5">if </span><span class="s1">(!self.valid) {</span>
    <span class="s5">return </span><span class="s1">{}</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s1">[_performanceLogger markStartForTag:RCTPLNativeModulePrepareConfig]</span><span class="s5">;</span>
  <span class="s1">RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;-[RCTCxxBridge buildModuleRegistry]&quot;</span><span class="s5">, </span><span class="s1">nil)</span><span class="s5">;</span>

  <span class="s5">__weak __typeof</span><span class="s1">(self) weakSelf = self</span><span class="s5">;</span>
  <span class="s1">ModuleRegistry::ModuleNotFoundCallback moduleNotFoundCallback = ^</span><span class="s5">bool</span><span class="s1">(</span><span class="s5">const </span><span class="s1">std::string &amp;name) {</span>
    <span class="s5">__strong __typeof</span><span class="s1">(weakSelf) strongSelf = weakSelf</span><span class="s5">;</span>
    <span class="s5">return </span><span class="s1">[strongSelf.delegate respondsToSelector:</span><span class="s5">@selector</span><span class="s1">(bridge:didNotFindModule:)] &amp;&amp;</span>
        <span class="s1">[strongSelf.delegate bridge:strongSelf didNotFindModule:</span><span class="s5">@</span><span class="s1">(name.c_str())]</span><span class="s5">;</span>
  <span class="s1">}</span><span class="s5">;</span>

  <span class="s5">auto </span><span class="s1">registry = std::make_shared&lt;ModuleRegistry&gt;(</span>
      <span class="s1">createNativeModules(_moduleDataByID</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">_reactInstance)</span><span class="s5">, </span><span class="s1">moduleNotFoundCallback)</span><span class="s5">;</span>

  <span class="s1">[_performanceLogger markStopForTag:RCTPLNativeModulePrepareConfig]</span><span class="s5">;</span>
  <span class="s1">RCT_PROFILE_END_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s5">;</span>

  <span class="s5">return </span><span class="s1">registry</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)_initializeBridge:(std::shared_ptr&lt;JSExecutorFactory&gt;)executorFactory</span>
<span class="s1">{</span>
  <span class="s5">if </span><span class="s1">(!self.valid) {</span>
    <span class="s5">return;</span>
  <span class="s1">}</span>

  <span class="s5">__weak </span><span class="s1">RCTCxxBridge *weakSelf = self</span><span class="s5">;</span>
  <span class="s1">_jsMessageThread = std::make_shared&lt;RCTMessageThread&gt;([NSRunLoop currentRunLoop]</span><span class="s5">, </span><span class="s1">^(NSError *error) {</span>
    <span class="s5">if </span><span class="s1">(error) {</span>
      <span class="s1">[weakSelf handleError:error]</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s5">;</span>

  <span class="s1">RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;-[RCTCxxBridge initializeBridge:]&quot;</span><span class="s5">, </span><span class="s1">nil)</span><span class="s5">;</span>
  <span class="s0">// This can only be false if the bridge was invalidated before startup completed</span>
  <span class="s5">if </span><span class="s1">(_reactInstance) {</span>
<span class="s2">#if </span><span class="s1">RCT_DEV</span>
    <span class="s1">executorFactory = std::make_shared&lt;GetDescAdapter&gt;(self</span><span class="s5">, </span><span class="s1">executorFactory)</span><span class="s5">;</span>
<span class="s2">#endif</span>

    <span class="s1">[self _initializeBridgeLocked:executorFactory]</span><span class="s5">;</span>

<span class="s2">#if </span><span class="s1">RCT_PROFILE</span>
    <span class="s5">if </span><span class="s1">(RCTProfileIsProfiling()) {</span>
      <span class="s1">_reactInstance-&gt;setGlobalVariable(</span><span class="s3">&quot;__RCTProfileIsProfiling&quot;</span><span class="s5">, </span><span class="s1">std::make_unique&lt;JSBigStdString&gt;(</span><span class="s3">&quot;true&quot;</span><span class="s1">))</span><span class="s5">;</span>
    <span class="s1">}</span>
<span class="s2">#endif</span>
  <span class="s1">}</span>

  <span class="s1">RCT_PROFILE_END_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)_initializeBridgeLocked:(std::shared_ptr&lt;JSExecutorFactory&gt;)executorFactory</span>
<span class="s1">{</span>
  <span class="s1">std::lock_guard&lt;std::mutex&gt; guard(_moduleRegistryLock)</span><span class="s5">;</span>

  <span class="s0">// This is async, but any calls into JS are blocked by the m_syncReady CV in Instance</span>
  <span class="s1">_reactInstance-&gt;initializeBridge(</span>
      <span class="s1">std::make_unique&lt;RCTInstanceCallback&gt;(self)</span><span class="s5">,</span>
      <span class="s1">executorFactory</span><span class="s5">,</span>
      <span class="s1">_jsMessageThread</span><span class="s5">,</span>
      <span class="s1">[self _buildModuleRegistryUnlocked])</span><span class="s5">;</span>
  <span class="s1">_moduleRegistryCreated = YES</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)updateModuleWithInstance:(id&lt;RCTBridgeModule&gt;)instance</span>
<span class="s1">{</span>
  <span class="s1">NSString *</span><span class="s5">const </span><span class="s1">moduleName = RCTBridgeModuleNameForClass([instance </span><span class="s5">class</span><span class="s1">])</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(moduleName) {</span>
    <span class="s1">RCTModuleData *</span><span class="s5">const </span><span class="s1">moduleData = _moduleDataByName[moduleName]</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(moduleData) {</span>
      <span class="s1">moduleData.instance = instance</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (NSArray&lt;RCTModuleData *&gt; *)registerModulesForClasses:(NSArray&lt;Class&gt; *)moduleClasses</span>
<span class="s1">{</span>
  <span class="s5">return </span><span class="s1">[self _registerModulesForClasses:moduleClasses lazilyDiscovered:NO]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (NSArray&lt;RCTModuleData *&gt; *)_registerModulesForClasses:(NSArray&lt;Class&gt; *)moduleClasses</span>
                                        <span class="s1">lazilyDiscovered:(BOOL)lazilyDiscovered</span>
<span class="s1">{</span>
  <span class="s1">RCT_PROFILE_BEGIN_EVENT(</span>
      <span class="s1">RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;-[RCTCxxBridge initModulesWithDispatchGroup:] autoexported moduleData&quot;</span><span class="s5">, </span><span class="s1">nil)</span><span class="s5">;</span>

  <span class="s1">NSArray *moduleClassesCopy = [moduleClasses copy]</span><span class="s5">;</span>
  <span class="s1">NSMutableArray&lt;RCTModuleData *&gt; *moduleDataByID = [NSMutableArray arrayWithCapacity:moduleClassesCopy.count]</span><span class="s5">;</span>
  <span class="s5">for </span><span class="s1">(Class moduleClass in moduleClassesCopy) {</span>
    <span class="s5">if </span><span class="s1">(RCTTurboModuleEnabled() &amp;&amp; [moduleClass conformsToProtocol:</span><span class="s5">@protocol</span><span class="s1">(RCTTurboModule)]) {</span>
      <span class="s5">continue;</span>
    <span class="s1">}</span>
    <span class="s1">NSString *moduleName = RCTBridgeModuleNameForClass(moduleClass)</span><span class="s5">;</span>

    <span class="s0">// Check for module name collisions</span>
    <span class="s1">RCTModuleData *moduleData = _moduleDataByName[moduleName]</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(moduleData) {</span>
      <span class="s5">if </span><span class="s1">(moduleData.hasInstance || lazilyDiscovered) {</span>
        <span class="s0">// Existing module was preregistered, so it takes precedence</span>
        <span class="s5">continue;</span>
      <span class="s1">} </span><span class="s5">else if </span><span class="s1">([moduleClass </span><span class="s5">new</span><span class="s1">] == nil) {</span>
        <span class="s0">// The new module returned nil from init, so use the old module</span>
        <span class="s5">continue;</span>
      <span class="s1">} </span><span class="s5">else if </span><span class="s1">([moduleData.moduleClass </span><span class="s5">new</span><span class="s1">] != nil) {</span>
        <span class="s0">// Both modules were non-nil, so it's unclear which should take precedence</span>
        <span class="s1">RCTLogWarn(</span>
            <span class="s5">@</span><span class="s3">&quot;Attempted to register RCTBridgeModule class %@ for the &quot;</span>
             <span class="s3">&quot;name '%@', but name was already registered by class %@&quot;</span><span class="s5">,</span>
            <span class="s1">moduleClass</span><span class="s5">,</span>
            <span class="s1">moduleName</span><span class="s5">,</span>
            <span class="s1">moduleData.moduleClass)</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// Instantiate moduleData</span>
    <span class="s0">// TODO #13258411: can we defer this until config generation?</span>
    <span class="s1">int32_t moduleDataId = getUniqueId()</span><span class="s5">;</span>
    <span class="s1">BridgeNativeModulePerfLogger::moduleDataCreateStart([moduleName UTF8String]</span><span class="s5">, </span><span class="s1">moduleDataId)</span><span class="s5">;</span>
    <span class="s1">moduleData = [[RCTModuleData alloc] initWithModuleClass:moduleClass</span>
                                                     <span class="s1">bridge:self</span>
                                             <span class="s1">moduleRegistry:_objCModuleRegistry</span>
                                    <span class="s1">viewRegistry_DEPRECATED:_viewRegistry_DEPRECATED</span>
                                              <span class="s1">bundleManager:_bundleManager</span>
                                          <span class="s1">callableJSModules:_callableJSModules]</span><span class="s5">;</span>
    <span class="s1">BridgeNativeModulePerfLogger::moduleDataCreateEnd([moduleName UTF8String]</span><span class="s5">, </span><span class="s1">moduleDataId)</span><span class="s5">;</span>

    <span class="s1">_moduleDataByName[moduleName] = moduleData</span><span class="s5">;</span>
    <span class="s1">[_moduleClassesByID addObject:moduleClass]</span><span class="s5">;</span>
    <span class="s1">[moduleDataByID addObject:moduleData]</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s1">[_moduleDataByID addObjectsFromArray:moduleDataByID]</span><span class="s5">;</span>

  <span class="s1">RCT_PROFILE_END_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s5">;</span>

  <span class="s5">return </span><span class="s1">moduleDataByID</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)registerExtraModules</span>
<span class="s1">{</span>
  <span class="s1">RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;-[RCTCxxBridge initModulesWithDispatchGroup:] extraModules&quot;</span><span class="s5">, </span><span class="s1">nil)</span><span class="s5">;</span>

  <span class="s1">NSArray&lt;id&lt;RCTBridgeModule&gt;&gt; *appExtraModules = nil</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">([self.delegate respondsToSelector:</span><span class="s5">@selector</span><span class="s1">(extraModulesForBridge:)]) {</span>
    <span class="s1">appExtraModules = [self.delegate extraModulesForBridge:_parentBridge]</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(self.moduleProvider) {</span>
    <span class="s1">appExtraModules = self.moduleProvider()</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s1">NSMutableArray&lt;id&lt;RCTBridgeModule&gt;&gt; *extraModules = [NSMutableArray </span><span class="s5">new</span><span class="s1">]</span><span class="s5">;</span>

  <span class="s0">// Prevent TurboModules from appearing the NativeModule system</span>
  <span class="s5">for </span><span class="s1">(id&lt;RCTBridgeModule&gt; module in appExtraModules) {</span>
    <span class="s5">if </span><span class="s1">(!(RCTTurboModuleEnabled() &amp;&amp; [module conformsToProtocol:</span><span class="s5">@protocol</span><span class="s1">(RCTTurboModule)])) {</span>
      <span class="s1">[extraModules addObject:module]</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">RCT_PROFILE_END_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s5">;</span>

  <span class="s1">RCT_PROFILE_BEGIN_EVENT(</span>
      <span class="s1">RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;-[RCTCxxBridge initModulesWithDispatchGroup:] preinitialized moduleData&quot;</span><span class="s5">, </span><span class="s1">nil)</span><span class="s5">;</span>
  <span class="s0">// Set up moduleData for pre-initialized module instances</span>
  <span class="s5">for </span><span class="s1">(id&lt;RCTBridgeModule&gt; module in extraModules) {</span>
    <span class="s1">Class moduleClass = [module </span><span class="s5">class</span><span class="s1">]</span><span class="s5">;</span>
    <span class="s1">NSString *moduleName = RCTBridgeModuleNameForClass(moduleClass)</span><span class="s5">;</span>

    <span class="s5">if </span><span class="s1">(RCT_DEBUG) {</span>
      <span class="s0">// Check for name collisions between preregistered modules</span>
      <span class="s1">RCTModuleData *moduleData = _moduleDataByName[moduleName]</span><span class="s5">;</span>
      <span class="s5">if </span><span class="s1">(moduleData) {</span>
        <span class="s1">RCTLogError(</span>
            <span class="s5">@</span><span class="s3">&quot;Attempted to register RCTBridgeModule class %@ for the &quot;</span>
             <span class="s3">&quot;name '%@', but name was already registered by class %@&quot;</span><span class="s5">,</span>
            <span class="s1">moduleClass</span><span class="s5">,</span>
            <span class="s1">moduleName</span><span class="s5">,</span>
            <span class="s1">moduleData.moduleClass)</span><span class="s5">;</span>
        <span class="s5">continue;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s5">if </span><span class="s1">(RCTTurboModuleEnabled() &amp;&amp; [module conformsToProtocol:</span><span class="s5">@protocol</span><span class="s1">(RCTTurboModule)]) {</span>
<span class="s2">#if </span><span class="s1">RCT_DEBUG</span>
      <span class="s0">// TODO: don't ask for extra module for when TurboModule is enabled.</span>
      <span class="s1">RCTLogError(</span>
          <span class="s5">@</span><span class="s3">&quot;NativeModule '%@' was marked as TurboModule, but provided as an extra NativeModule &quot;</span>
           <span class="s3">&quot;by the class '%@', ignoring.&quot;</span><span class="s5">,</span>
          <span class="s1">moduleName</span><span class="s5">,</span>
          <span class="s1">moduleClass)</span><span class="s5">;</span>
<span class="s2">#endif</span>
      <span class="s5">continue;</span>
    <span class="s1">}</span>

    <span class="s0">// Instantiate moduleData container</span>
    <span class="s1">int32_t moduleDataId = getUniqueId()</span><span class="s5">;</span>
    <span class="s1">BridgeNativeModulePerfLogger::moduleDataCreateStart([moduleName UTF8String]</span><span class="s5">, </span><span class="s1">moduleDataId)</span><span class="s5">;</span>
    <span class="s1">RCTModuleData *moduleData = [[RCTModuleData alloc] initWithModuleInstance:module</span>
                                                                       <span class="s1">bridge:self</span>
                                                               <span class="s1">moduleRegistry:_objCModuleRegistry</span>
                                                      <span class="s1">viewRegistry_DEPRECATED:_viewRegistry_DEPRECATED</span>
                                                                <span class="s1">bundleManager:_bundleManager</span>
                                                            <span class="s1">callableJSModules:_callableJSModules]</span><span class="s5">;</span>
    <span class="s1">BridgeNativeModulePerfLogger::moduleDataCreateEnd([moduleName UTF8String]</span><span class="s5">, </span><span class="s1">moduleDataId)</span><span class="s5">;</span>

    <span class="s1">_moduleDataByName[moduleName] = moduleData</span><span class="s5">;</span>
    <span class="s1">[_moduleClassesByID addObject:moduleClass]</span><span class="s5">;</span>
    <span class="s1">[_moduleDataByID addObject:moduleData]</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s1">RCT_PROFILE_END_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)registerExtraLazyModules</span>
<span class="s1">{</span>
<span class="s2">#if </span><span class="s1">RCT_DEBUG</span>
  <span class="s0">// This is debug-only and only when Chrome is attached, since it expects all modules to be already</span>
  <span class="s0">// available on start up. Otherwise, we can let the lazy module discovery to load them on demand.</span>
  <span class="s1">Class executorClass = [_parentBridge executorClass]</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(executorClass &amp;&amp; [NSStringFromClass(executorClass) isEqualToString:</span><span class="s5">@</span><span class="s3">&quot;RCTWebSocketExecutor&quot;</span><span class="s1">]) {</span>
    <span class="s1">NSDictionary&lt;NSString *</span><span class="s5">, </span><span class="s1">Class&gt; *moduleClasses = nil</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">([self.delegate respondsToSelector:</span><span class="s5">@selector</span><span class="s1">(extraLazyModuleClassesForBridge:)]) {</span>
      <span class="s1">moduleClasses = [self.delegate extraLazyModuleClassesForBridge:_parentBridge]</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s5">if </span><span class="s1">(!moduleClasses) {</span>
      <span class="s5">return;</span>
    <span class="s1">}</span>

    <span class="s0">// This logic is mostly copied from `registerModulesForClasses:`, but with one difference:</span>
    <span class="s0">// we must use the names provided by the delegate method here.</span>
    <span class="s5">for </span><span class="s1">(NSString *moduleName in moduleClasses) {</span>
      <span class="s1">Class moduleClass = moduleClasses[moduleName]</span><span class="s5">;</span>
      <span class="s5">if </span><span class="s1">(RCTTurboModuleEnabled() &amp;&amp; [moduleClass conformsToProtocol:</span><span class="s5">@protocol</span><span class="s1">(RCTTurboModule)]) {</span>
        <span class="s5">continue;</span>
      <span class="s1">}</span>

      <span class="s0">// Check for module name collisions</span>
      <span class="s1">RCTModuleData *moduleData = _moduleDataByName[moduleName]</span><span class="s5">;</span>
      <span class="s5">if </span><span class="s1">(moduleData) {</span>
        <span class="s5">if </span><span class="s1">(moduleData.hasInstance) {</span>
          <span class="s0">// Existing module was preregistered, so it takes precedence</span>
          <span class="s5">continue;</span>
        <span class="s1">} </span><span class="s5">else if </span><span class="s1">([moduleClass </span><span class="s5">new</span><span class="s1">] == nil) {</span>
          <span class="s0">// The new module returned nil from init, so use the old module</span>
          <span class="s5">continue;</span>
        <span class="s1">} </span><span class="s5">else if </span><span class="s1">([moduleData.moduleClass </span><span class="s5">new</span><span class="s1">] != nil) {</span>
          <span class="s0">// Use existing module since it was already loaded but not yet instantiated.</span>
          <span class="s5">continue;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">int32_t moduleDataId = getUniqueId()</span><span class="s5">;</span>
      <span class="s1">BridgeNativeModulePerfLogger::moduleDataCreateStart([moduleName UTF8String]</span><span class="s5">, </span><span class="s1">moduleDataId)</span><span class="s5">;</span>
      <span class="s1">moduleData = [[RCTModuleData alloc] initWithModuleClass:moduleClass</span>
                                                       <span class="s1">bridge:self</span>
                                               <span class="s1">moduleRegistry:_objCModuleRegistry</span>
                                      <span class="s1">viewRegistry_DEPRECATED:_viewRegistry_DEPRECATED</span>
                                                <span class="s1">bundleManager:_bundleManager</span>
                                            <span class="s1">callableJSModules:_callableJSModules]</span><span class="s5">;</span>
      <span class="s1">BridgeNativeModulePerfLogger::moduleDataCreateEnd([moduleName UTF8String]</span><span class="s5">, </span><span class="s1">moduleDataId)</span><span class="s5">;</span>

      <span class="s1">_moduleDataByName[moduleName] = moduleData</span><span class="s5">;</span>
      <span class="s1">[_moduleClassesByID addObject:moduleClass]</span><span class="s5">;</span>
      <span class="s1">[_moduleDataByID addObject:moduleData]</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s2">#endif</span>
<span class="s1">}</span>

<span class="s1">- (NSArray&lt;RCTModuleData *&gt; *)_initializeModules:(NSArray&lt;Class&gt; *)modules</span>
                               <span class="s1">withDispatchGroup:(dispatch_group_t)dispatchGroup</span>
                                <span class="s1">lazilyDiscovered:(BOOL)lazilyDiscovered</span>
<span class="s1">{</span>
  <span class="s0">// Set up moduleData for automatically-exported modules</span>
  <span class="s1">NSArray&lt;RCTModuleData *&gt; *moduleDataById = [self _registerModulesForClasses:modules</span>
                                                             <span class="s1">lazilyDiscovered:lazilyDiscovered]</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">(lazilyDiscovered) {</span>
<span class="s2">#if </span><span class="s1">RCT_DEBUG</span>
    <span class="s0">// Lazily discovered modules do not require instantiation here,</span>
    <span class="s0">// as they are not allowed to have pre-instantiated instance</span>
    <span class="s0">// and must not require the main queue.</span>
    <span class="s5">for </span><span class="s1">(RCTModuleData *moduleData in moduleDataById) {</span>
      <span class="s1">RCTAssert(</span>
          <span class="s1">!(moduleData.requiresMainQueueSetup || moduleData.hasInstance)</span><span class="s5">,</span>
          <span class="s5">@</span><span class="s3">&quot;Module </span><span class="s5">\'</span><span class="s3">%@</span><span class="s5">\' </span><span class="s3">requires initialization on the Main Queue or has pre-instantiated, which is not supported for the lazily discovered modules.&quot;</span><span class="s5">,</span>
          <span class="s1">moduleData.name)</span><span class="s5">;</span>
    <span class="s1">}</span>
<span class="s2">#endif</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s1">RCT_PROFILE_BEGIN_EVENT(</span>
        <span class="s1">RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;-[RCTCxxBridge initModulesWithDispatchGroup:] moduleData.hasInstance&quot;</span><span class="s5">, </span><span class="s1">nil)</span><span class="s5">;</span>
    <span class="s0">// Dispatch module init onto main thread for those modules that require it</span>
    <span class="s0">// For non-lazily discovered modules we run through the entire set of modules</span>
    <span class="s0">// that we have, otherwise some modules coming from the delegate</span>
    <span class="s0">// or module provider block, will not be properly instantiated.</span>
    <span class="s5">for </span><span class="s1">(RCTModuleData *moduleData in _moduleDataByID) {</span>
      <span class="s5">if </span><span class="s1">(moduleData.hasInstance &amp;&amp; (!moduleData.requiresMainQueueSetup || RCTIsMainQueue())) {</span>
        <span class="s0">// Modules that were pre-initialized should ideally be set up before</span>
        <span class="s0">// bridge init has finished, otherwise the caller may try to access the</span>
        <span class="s0">// module directly rather than via `[bridge moduleForClass:]`, which won't</span>
        <span class="s0">// trigger the lazy initialization process. If the module cannot safely be</span>
        <span class="s0">// set up on the current thread, it will instead be async dispatched</span>
        <span class="s0">// to the main thread to be set up in _prepareModulesWithDispatchGroup:.</span>
        <span class="s1">(</span><span class="s5">void</span><span class="s1">)[moduleData instance]</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">RCT_PROFILE_END_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s5">;</span>

    <span class="s0">// From this point on, RCTDidInitializeModuleNotification notifications will</span>
    <span class="s0">// be sent the first time a module is accessed.</span>
    <span class="s1">_moduleSetupComplete = YES</span><span class="s5">;</span>
    <span class="s1">[self _prepareModulesWithDispatchGroup:dispatchGroup]</span><span class="s5">;</span>
  <span class="s1">}</span>

<span class="s2">#if </span><span class="s1">RCT_PROFILE</span>
  <span class="s5">if </span><span class="s1">(RCTProfileIsProfiling()) {</span>
    <span class="s0">// Depends on moduleDataByID being loaded</span>
    <span class="s1">RCTProfileHookModules(self)</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s2">#endif</span>
  <span class="s5">return </span><span class="s1">moduleDataById</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)registerAdditionalModuleClasses:(NSArray&lt;Class&gt; *)modules</span>
<span class="s1">{</span>
  <span class="s1">std::lock_guard&lt;std::mutex&gt; guard(_moduleRegistryLock)</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(_moduleRegistryCreated) {</span>
    <span class="s1">NSArray&lt;RCTModuleData *&gt; *newModules = [self _initializeModules:modules</span>
                                                  <span class="s1">withDispatchGroup:NULL</span>
                                                   <span class="s1">lazilyDiscovered:YES]</span><span class="s5">;</span>
    <span class="s1">assert(_reactInstance)</span><span class="s5">; </span><span class="s0">// at this point you must have reactInstance as you already called</span>
                            <span class="s0">// reactInstance-&gt;initializeBridge</span>
    <span class="s1">_reactInstance-&gt;getModuleRegistry().registerModules(createNativeModules(newModules</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">_reactInstance))</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s1">[self registerModulesForClasses:modules]</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)_prepareModulesWithDispatchGroup:(dispatch_group_t)dispatchGroup</span>
<span class="s1">{</span>
  <span class="s1">RCT_PROFILE_BEGIN_EVENT(</span><span class="s4">0</span><span class="s5">, @</span><span class="s3">&quot;-[RCTCxxBridge _prepareModulesWithDispatchGroup]&quot;</span><span class="s5">, </span><span class="s1">nil)</span><span class="s5">;</span>

  <span class="s1">BOOL initializeImmediately = NO</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(dispatchGroup == NULL) {</span>
    <span class="s0">// If no dispatchGroup is passed in, we must prepare everything immediately.</span>
    <span class="s0">// We better be on the right thread too.</span>
    <span class="s1">RCTAssertMainQueue()</span><span class="s5">;</span>
    <span class="s1">initializeImmediately = YES</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s0">// Set up modules that require main thread init or constants export</span>
  <span class="s1">[_performanceLogger setValue:</span><span class="s4">0 </span><span class="s1">forTag:RCTPLNativeModuleMainThread]</span><span class="s5">;</span>

  <span class="s5">for </span><span class="s1">(RCTModuleData *moduleData in _moduleDataByID) {</span>
    <span class="s5">if </span><span class="s1">(moduleData.requiresMainQueueSetup) {</span>
      <span class="s0">// Modules that need to be set up on the main thread cannot be initialized</span>
      <span class="s0">// lazily when required without doing a dispatch_sync to the main thread,</span>
      <span class="s0">// which can result in deadlock. To avoid this, we initialize all of these</span>
      <span class="s0">// modules on the main thread in parallel with loading the JS code, so</span>
      <span class="s0">// they will already be available before they are ever required.</span>
      <span class="s1">dispatch_block_t block = ^{</span>
        <span class="s5">if </span><span class="s1">(self.valid &amp;&amp; ![moduleData.moduleClass isSubclassOfClass:[RCTCxxModule </span><span class="s5">class</span><span class="s1">]]) {</span>
          <span class="s1">[self-&gt;_performanceLogger appendStartForTag:RCTPLNativeModuleMainThread]</span><span class="s5">;</span>
          <span class="s1">(</span><span class="s5">void</span><span class="s1">)[moduleData instance]</span><span class="s5">;</span>
          <span class="s5">if </span><span class="s1">(!RCTIsMainQueueExecutionOfConstantsToExportDisabled()) {</span>
            <span class="s1">[moduleData gatherConstants]</span><span class="s5">;</span>
          <span class="s1">}</span>
          <span class="s1">[self-&gt;_performanceLogger appendStopForTag:RCTPLNativeModuleMainThread]</span><span class="s5">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span><span class="s5">;</span>

      <span class="s5">if </span><span class="s1">(initializeImmediately &amp;&amp; RCTIsMainQueue()) {</span>
        <span class="s1">block()</span><span class="s5">;</span>
      <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
        <span class="s0">// We've already checked that dispatchGroup is non-null, but this satisfies the</span>
        <span class="s0">// Xcode analyzer</span>
        <span class="s5">if </span><span class="s1">(dispatchGroup) {</span>
          <span class="s1">dispatch_group_async(dispatchGroup</span><span class="s5">, </span><span class="s1">dispatch_get_main_queue()</span><span class="s5">, </span><span class="s1">block)</span><span class="s5">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">_modulesInitializedOnMainQueue++</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">[_performanceLogger setValue:_modulesInitializedOnMainQueue forTag:RCTPLNativeModuleMainThreadUsesCount]</span><span class="s5">;</span>
  <span class="s1">RCT_PROFILE_END_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)registerModuleForFrameUpdates:(id&lt;RCTBridgeModule&gt;)module withModuleData:(RCTModuleData *)moduleData</span>
<span class="s1">{</span>
  <span class="s1">[_displayLink registerModuleForFrameUpdates:module withModuleData:moduleData]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)executeSourceCode:(NSData *)sourceCode withSourceURL:(NSURL *)url sync:(BOOL)sync</span>
<span class="s1">{</span>
  <span class="s0">// This will get called from whatever thread was actually executing JS.</span>
  <span class="s1">dispatch_block_t completion = ^{</span>
    <span class="s0">// Log start up metrics early before processing any other js calls</span>
    <span class="s1">[self logStartupFinish]</span><span class="s5">;</span>
    <span class="s0">// Flush pending calls immediately so we preserve ordering</span>
    <span class="s1">[self _flushPendingCalls]</span><span class="s5">;</span>

    <span class="s0">// Perform the state update and notification on the main thread, so we can't run into</span>
    <span class="s0">// timing issues with RCTRootView</span>
    <span class="s1">dispatch_async(dispatch_get_main_queue()</span><span class="s5">, </span><span class="s1">^{</span>
      <span class="s1">[[NSNotificationCenter defaultCenter] postNotificationName:RCTJavaScriptDidLoadNotification</span>
                                                          <span class="s1">object:self-&gt;_parentBridge</span>
                                                        <span class="s1">userInfo:</span><span class="s5">@</span><span class="s1">{</span><span class="s5">@</span><span class="s3">&quot;bridge&quot; </span><span class="s1">: self}]</span><span class="s5">;</span>

      <span class="s0">// Starting the display link is not critical to startup, so do it last</span>
      <span class="s1">[self ensureOnJavaScriptThread:^{</span>
        <span class="s0">// Register the display link to start sending js calls after everything is setup</span>
        <span class="s1">[self-&gt;_displayLink addToRunLoop:[NSRunLoop currentRunLoop]]</span><span class="s5">;</span>
      <span class="s1">}]</span><span class="s5">;</span>
    <span class="s1">})</span><span class="s5">;</span>
  <span class="s1">}</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">(sync) {</span>
    <span class="s1">[self executeApplicationScriptSync:sourceCode url:url]</span><span class="s5">;</span>
    <span class="s1">completion()</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s1">[self enqueueApplicationScript:sourceCode url:url onComplete:completion]</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s0">// Use the original request URL here - HMRClient uses this to derive the /hot URL and entry point.</span>
  <span class="s1">[self.devSettings setupHMRClientWithBundleURL:self.bundleURL]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s2">#if </span><span class="s1">RCT_DEV_MENU | RCT_PACKAGER_LOADING_FUNCTIONALITY</span>
<span class="s1">- (</span><span class="s5">void</span><span class="s1">)loadAndExecuteSplitBundleURL:(NSURL *)bundleURL</span>
                             <span class="s1">onError:(RCTLoadAndExecuteErrorBlock)onError</span>
                          <span class="s1">onComplete:(dispatch_block_t)onComplete</span>
<span class="s1">{</span>
  <span class="s5">__weak __typeof</span><span class="s1">(self) weakSelf = self</span><span class="s5">;</span>
  <span class="s1">[RCTJavaScriptLoader loadBundleAtURL:bundleURL</span>
      <span class="s1">onProgress:^(RCTLoadingProgress *progressData) {</span>
<span class="s2">#if </span><span class="s1">(RCT_DEV_MENU | RCT_ENABLE_LOADING_VIEW) &amp;&amp; __has_include(&lt;React/RCTDevLoadingViewProtocol.h&gt;)</span>
        <span class="s1">id&lt;RCTDevLoadingViewProtocol&gt; loadingView = [weakSelf moduleForName:</span><span class="s5">@</span><span class="s3">&quot;DevLoadingView&quot;</span>
                                                      <span class="s1">lazilyLoadIfNecessary:YES]</span><span class="s5">;</span>
        <span class="s1">[loadingView updateProgress:progressData]</span><span class="s5">;</span>
<span class="s2">#endif</span>
      <span class="s1">}</span>
      <span class="s1">onComplete:^(NSError *error</span><span class="s5">, </span><span class="s1">RCTSource *source) {</span>
        <span class="s5">if </span><span class="s1">(error) {</span>
          <span class="s1">onError(error)</span><span class="s5">;</span>
          <span class="s5">return;</span>
        <span class="s1">}</span>

        <span class="s1">[self enqueueApplicationScript:source.data</span>
                                   <span class="s1">url:source.url</span>
                            <span class="s1">onComplete:^{</span>
                              <span class="s1">[self.devSettings setupHMRClientWithAdditionalBundleURL:source.url]</span><span class="s5">;</span>
                              <span class="s1">onComplete()</span><span class="s5">;</span>
                            <span class="s1">}]</span><span class="s5">;</span>
      <span class="s1">}]</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s2">#else</span>
<span class="s1">- (</span><span class="s5">void</span><span class="s1">)loadAndExecuteSplitBundleURL:(NSURL *)bundleURL</span>
                             <span class="s1">onError:(RCTLoadAndExecuteErrorBlock)onError</span>
                          <span class="s1">onComplete:(dispatch_block_t)onComplete</span>
<span class="s1">{</span>
<span class="s1">}</span>
<span class="s2">#endif</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)handleError:(NSError *)error</span>
<span class="s1">{</span>
  <span class="s0">// This is generally called when the infrastructure throws an</span>
  <span class="s0">// exception while calling JS.  Most product exceptions will not go</span>
  <span class="s0">// through this method, but through RCTExceptionManager.</span>

  <span class="s0">// There are three possible states:</span>
  <span class="s0">// 1. initializing == _valid &amp;&amp; _loading</span>
  <span class="s0">// 2. initializing/loading finished (success or failure) == _valid &amp;&amp; !_loading</span>
  <span class="s0">// 3. invalidated == !_valid &amp;&amp; !_loading</span>

  <span class="s0">// !_valid &amp;&amp; _loading can't happen.</span>

  <span class="s0">// In state 1: on main queue, move to state 2, reset the bridge, and RCTFatal.</span>
  <span class="s0">// In state 2: go directly to RCTFatal.  Do not enqueue, do not collect $200.</span>
  <span class="s0">// In state 3: do nothing.</span>

  <span class="s5">if </span><span class="s1">(self-&gt;_valid &amp;&amp; !self-&gt;_loading) {</span>
    <span class="s5">if </span><span class="s1">([error userInfo][RCTJSRawStackTraceKey]) {</span>
      <span class="s1">[self.redBox showErrorMessage:[error localizedDescription] withRawStack:[error userInfo][RCTJSRawStackTraceKey]]</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s1">RCTFatal(error)</span><span class="s5">;</span>

    <span class="s0">// RN will stop, but let the rest of the app keep going.</span>
    <span class="s5">return;</span>
  <span class="s1">}</span>

  <span class="s5">if </span><span class="s1">(!_valid || !_loading) {</span>
    <span class="s5">return;</span>
  <span class="s1">}</span>

  <span class="s0">// Hack: once the bridge is invalidated below, it won't initialize any new native</span>
  <span class="s0">// modules. Initialize the redbox module now so we can still report this error.</span>
  <span class="s1">RCTRedBox *redBox = [self redBox]</span><span class="s5">;</span>

  <span class="s1">_loading = NO</span><span class="s5">;</span>
  <span class="s1">_valid = NO</span><span class="s5">;</span>
  <span class="s1">_moduleRegistryCreated = NO</span><span class="s5">;</span>

  <span class="s1">dispatch_async(dispatch_get_main_queue()</span><span class="s5">, </span><span class="s1">^{</span>
    <span class="s5">if </span><span class="s1">(self-&gt;_jsMessageThread) {</span>
      <span class="s0">// Make sure initializeBridge completed</span>
      <span class="s1">self-&gt;_jsMessageThread-&gt;runOnQueueSync([] {})</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s1">self-&gt;_reactInstance.reset()</span><span class="s5">;</span>
    <span class="s1">self-&gt;_jsMessageThread.reset()</span><span class="s5">;</span>

    <span class="s1">[[NSNotificationCenter defaultCenter] postNotificationName:RCTJavaScriptDidFailToLoadNotification</span>
                                                        <span class="s1">object:self-&gt;_parentBridge</span>
                                                      <span class="s1">userInfo:</span><span class="s5">@</span><span class="s1">{</span><span class="s5">@</span><span class="s3">&quot;bridge&quot; </span><span class="s1">: self</span><span class="s5">, @</span><span class="s3">&quot;error&quot; </span><span class="s1">: error}]</span><span class="s5">;</span>

    <span class="s5">if </span><span class="s1">([error userInfo][RCTJSRawStackTraceKey]) {</span>
      <span class="s1">[redBox showErrorMessage:[error localizedDescription] withRawStack:[error userInfo][RCTJSRawStackTraceKey]]</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s1">RCTFatal(error)</span><span class="s5">;</span>
  <span class="s1">})</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">RCT_NOT_IMPLEMENTED(-(instancetype)initWithDelegate</span>
                    <span class="s1">: (__unused id&lt;RCTBridgeDelegate&gt;)delegate bundleURL</span>
                    <span class="s1">: (__unused NSURL *)bundleURL moduleProvider</span>
                    <span class="s1">: (__unused RCTBridgeModuleListProvider)block launchOptions</span>
                    <span class="s1">: (__unused NSDictionary *)launchOptions)</span>

<span class="s1">RCT_NOT_IMPLEMENTED(-(instancetype)initWithBundleURL</span>
                    <span class="s1">: (__unused NSURL *)bundleURL moduleProvider</span>
                    <span class="s1">: (__unused RCTBridgeModuleListProvider)block launchOptions</span>
                    <span class="s1">: (__unused NSDictionary *)launchOptions)</span>

<span class="s0">/** 
 * Prevent super from calling setUp (that'd create another batchedBridge) 
 */</span>
<span class="s1">- (</span><span class="s5">void</span><span class="s1">)setUp</span>
<span class="s1">{</span>
<span class="s1">}</span>

<span class="s1">- (Class)executorClass</span>
<span class="s1">{</span>
  <span class="s5">return </span><span class="s1">_parentBridge.executorClass</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)setExecutorClass:(Class)executorClass</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertMainQueue()</span><span class="s5">;</span>

  <span class="s1">_parentBridge.executorClass = executorClass</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (NSURL *)bundleURL</span>
<span class="s1">{</span>
  <span class="s5">return </span><span class="s1">_parentBridge.bundleURL</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)setBundleURL:(NSURL *)bundleURL</span>
<span class="s1">{</span>
  <span class="s1">_parentBridge.bundleURL = bundleURL</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (id&lt;RCTBridgeDelegate&gt;)delegate</span>
<span class="s1">{</span>
  <span class="s5">return </span><span class="s1">_parentBridge.delegate</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)dispatchBlock:(dispatch_block_t)block queue:(dispatch_queue_t)queue</span>
<span class="s1">{</span>
  <span class="s5">if </span><span class="s1">(queue == RCTJSThread) {</span>
    <span class="s1">[self ensureOnJavaScriptThread:block]</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(queue) {</span>
    <span class="s1">dispatch_async(queue</span><span class="s5">, </span><span class="s1">block)</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - RCTInvalidating</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)invalidate</span>
<span class="s1">{</span>
  <span class="s5">if </span><span class="s1">(_didInvalidate) {</span>
    <span class="s5">return;</span>
  <span class="s1">}</span>

  <span class="s1">RCTAssertMainQueue()</span><span class="s5">;</span>
  <span class="s1">RCTLogInfo(</span><span class="s5">@</span><span class="s3">&quot;Invalidating %@ (parent: %@, executor: %@)&quot;</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">_parentBridge</span><span class="s5">, </span><span class="s1">[self executorClass])</span><span class="s5">;</span>

  <span class="s1">_loading = NO</span><span class="s5">;</span>
  <span class="s1">_valid = NO</span><span class="s5">;</span>
  <span class="s1">_didInvalidate = YES</span><span class="s5">;</span>
  <span class="s1">_moduleRegistryCreated = NO</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">([RCTBridge currentBridge] == self) {</span>
    <span class="s1">[RCTBridge setCurrentBridge:nil]</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s0">// Stop JS instance and message thread</span>
  <span class="s1">[self ensureOnJavaScriptThread:^{</span>
    <span class="s1">[self-&gt;_displayLink invalidate]</span><span class="s5">;</span>
    <span class="s1">self-&gt;_displayLink = nil</span><span class="s5">;</span>

    <span class="s5">if </span><span class="s1">(RCTProfileIsProfiling()) {</span>
      <span class="s1">RCTProfileUnhookModules(self)</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s0">// Invalidate modules</span>

    <span class="s1">[[NSNotificationCenter defaultCenter] postNotificationName:RCTBridgeWillInvalidateModulesNotification</span>
                                                        <span class="s1">object:self-&gt;_parentBridge</span>
                                                      <span class="s1">userInfo:</span><span class="s5">@</span><span class="s1">{</span><span class="s5">@</span><span class="s3">&quot;bridge&quot; </span><span class="s1">: self}]</span><span class="s5">;</span>

    <span class="s0">// We're on the JS thread (which we'll be suspending soon), so no new calls will be made to native modules after</span>
    <span class="s0">// this completes. We must ensure all previous calls were dispatched before deallocating the instance (and module</span>
    <span class="s0">// wrappers) or we may have invalid pointers still in flight.</span>
    <span class="s1">dispatch_group_t moduleInvalidation = dispatch_group_create()</span><span class="s5">;</span>
    <span class="s5">for </span><span class="s1">(RCTModuleData *moduleData in self-&gt;_moduleDataByID) {</span>
      <span class="s0">// Be careful when grabbing an instance here, we don't want to instantiate</span>
      <span class="s0">// any modules just to invalidate them.</span>
      <span class="s5">if </span><span class="s1">(![moduleData hasInstance]) {</span>
        <span class="s5">continue;</span>
      <span class="s1">}</span>

      <span class="s5">if </span><span class="s1">([moduleData.instance respondsToSelector:</span><span class="s5">@selector</span><span class="s1">(invalidate)]) {</span>
        <span class="s1">dispatch_group_enter(moduleInvalidation)</span><span class="s5">;</span>
        <span class="s1">[self</span>
            <span class="s1">dispatchBlock:^{</span>
              <span class="s1">[(id&lt;RCTInvalidating&gt;)moduleData.instance invalidate]</span><span class="s5">;</span>
              <span class="s1">dispatch_group_leave(moduleInvalidation)</span><span class="s5">;</span>
            <span class="s1">}</span>
                    <span class="s1">queue:moduleData.methodQueue]</span><span class="s5">;</span>
      <span class="s1">}</span>
      <span class="s1">[moduleData invalidate]</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s5">if </span><span class="s1">(dispatch_group_wait(moduleInvalidation</span><span class="s5">, </span><span class="s1">dispatch_time(DISPATCH_TIME_NOW</span><span class="s5">, </span><span class="s4">10 </span><span class="s1">* NSEC_PER_SEC))) {</span>
      <span class="s1">RCTLogError(</span><span class="s5">@</span><span class="s3">&quot;Timed out waiting for modules to be invalidated&quot;</span><span class="s1">)</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s1">[[NSNotificationCenter defaultCenter] postNotificationName:RCTBridgeDidInvalidateModulesNotification</span>
                                                        <span class="s1">object:self-&gt;_parentBridge</span>
                                                      <span class="s1">userInfo:</span><span class="s5">@</span><span class="s1">{</span><span class="s5">@</span><span class="s3">&quot;bridge&quot; </span><span class="s1">: self}]</span><span class="s5">;</span>

    <span class="s1">self-&gt;_reactInstance.reset()</span><span class="s5">;</span>
    <span class="s1">self-&gt;_jsMessageThread.reset()</span><span class="s5">;</span>

    <span class="s1">self-&gt;_moduleDataByName = nil</span><span class="s5">;</span>
    <span class="s1">self-&gt;_moduleDataByID = nil</span><span class="s5">;</span>
    <span class="s1">self-&gt;_moduleClassesByID = nil</span><span class="s5">;</span>
    <span class="s1">self-&gt;_pendingCalls = nil</span><span class="s5">;</span>

    <span class="s1">[self-&gt;_jsThread cancel]</span><span class="s5">;</span>
    <span class="s1">self-&gt;_jsThread = nil</span><span class="s5">;</span>
    <span class="s1">CFRunLoopStop(CFRunLoopGetCurrent())</span><span class="s5">;</span>
  <span class="s1">}]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)logMessage:(NSString *)message level:(NSString *)level</span>
<span class="s1">{</span>
  <span class="s5">if </span><span class="s1">(RCT_DEBUG &amp;&amp; _valid) {</span>
    <span class="s1">[self enqueueJSCall:</span><span class="s5">@</span><span class="s3">&quot;RCTLog&quot; </span><span class="s1">method:</span><span class="s5">@</span><span class="s3">&quot;logIfNoNativeHook&quot; </span><span class="s1">args:</span><span class="s5">@</span><span class="s1">[ level</span><span class="s5">, </span><span class="s1">message ] completion:NULL]</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - RCTBridge methods</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)_runAfterLoad:(RCTPendingCall)block</span>
<span class="s1">{</span>
  <span class="s0">// Ordering here is tricky.  Ideally, the C++ bridge would provide</span>
  <span class="s0">// functionality to defer calls until after the app is loaded.  Until that</span>
  <span class="s0">// happens, we do this.  _pendingCount keeps a count of blocks which have</span>
  <span class="s0">// been deferred.  It is incremented using an atomic barrier call before each</span>
  <span class="s0">// block is added to the js queue, and decremented using an atomic barrier</span>
  <span class="s0">// call after the block is executed.  If _pendingCount is zero, there is no</span>
  <span class="s0">// work either in the js queue, or in _pendingCalls, so it is safe to add new</span>
  <span class="s0">// work to the JS queue directly.</span>

  <span class="s5">if </span><span class="s1">(self.loading || _pendingCount &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s0">// From the callers' perspective:</span>

    <span class="s0">// Phase 1: jsQueueBlocks are added to the queue; _pendingCount is</span>
    <span class="s0">// incremented for each.  If the first block is created after self.loading is</span>
    <span class="s0">// true, phase 1 will be nothing.</span>
    <span class="s1">_pendingCount++</span><span class="s5">;</span>
    <span class="s1">dispatch_block_t jsQueueBlock = ^{</span>
      <span class="s0">// From the perspective of the JS queue:</span>
      <span class="s5">if </span><span class="s1">(self.loading) {</span>
        <span class="s0">// Phase A: jsQueueBlocks are executed.  self.loading is true, so they</span>
        <span class="s0">// are added to _pendingCalls.</span>
        <span class="s1">[self-&gt;_pendingCalls addObject:block]</span><span class="s5">;</span>
      <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
        <span class="s0">// Phase C: More jsQueueBlocks are executed.  self.loading is false, so</span>
        <span class="s0">// each block is executed, adding work to the queue, and _pendingCount is</span>
        <span class="s0">// decremented.</span>
        <span class="s1">block()</span><span class="s5">;</span>
        <span class="s1">self-&gt;_pendingCount--</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s5">;</span>
    <span class="s1">[self ensureOnJavaScriptThread:jsQueueBlock]</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s0">// Phase 2/Phase D: blocks are executed directly, adding work to the JS queue.</span>
    <span class="s1">block()</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)logStartupFinish</span>
<span class="s1">{</span>
  <span class="s0">// Log metrics about native requires during the bridge startup.</span>
  <span class="s1">uint64_t nativeRequiresCount = [_performanceLogger valueForTag:RCTPLRAMNativeRequiresCount]</span><span class="s5">;</span>
  <span class="s1">[_performanceLogger setValue:nativeRequiresCount forTag:RCTPLRAMStartupNativeRequiresCount]</span><span class="s5">;</span>
  <span class="s1">uint64_t nativeRequires = [_performanceLogger valueForTag:RCTPLRAMNativeRequires]</span><span class="s5">;</span>
  <span class="s1">[_performanceLogger setValue:nativeRequires forTag:RCTPLRAMStartupNativeRequires]</span><span class="s5">;</span>

  <span class="s1">[_performanceLogger markStopForTag:RCTPLBridgeStartup]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)_flushPendingCalls</span>
<span class="s1">{</span>
  <span class="s1">RCT_PROFILE_BEGIN_EVENT(</span><span class="s4">0</span><span class="s5">, @</span><span class="s3">&quot;Processing pendingCalls&quot;</span><span class="s5">, @</span><span class="s1">{</span><span class="s5">@</span><span class="s3">&quot;count&quot; </span><span class="s1">: [</span><span class="s5">@</span><span class="s1">(_pendingCalls.count) stringValue]})</span><span class="s5">;</span>
  <span class="s0">// Phase B: _flushPendingCalls happens.  Each block in _pendingCalls is</span>
  <span class="s0">// executed, adding work to the queue, and _pendingCount is decremented.</span>
  <span class="s0">// loading is set to NO.</span>
  <span class="s1">NSArray&lt;RCTPendingCall&gt; *pendingCalls = _pendingCalls</span><span class="s5">;</span>
  <span class="s1">_pendingCalls = nil</span><span class="s5">;</span>
  <span class="s5">for </span><span class="s1">(RCTPendingCall call in pendingCalls) {</span>
    <span class="s1">call()</span><span class="s5">;</span>
    <span class="s1">_pendingCount--</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s1">_loading = NO</span><span class="s5">;</span>
  <span class="s1">RCT_PROFILE_END_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Public. Can be invoked from any thread. 
 */</span>
<span class="s1">- (</span><span class="s5">void</span><span class="s1">)enqueueJSCall:(NSString *)module</span>
               <span class="s1">method:(NSString *)method</span>
                 <span class="s1">args:(NSArray *)args</span>
           <span class="s1">completion:(dispatch_block_t)completion</span>
<span class="s1">{</span>
  <span class="s5">if </span><span class="s1">(!self.valid) {</span>
    <span class="s5">return;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * AnyThread 
   */</span>
  <span class="s1">RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;-[RCTCxxBridge enqueueJSCall:]&quot;</span><span class="s5">, </span><span class="s1">nil)</span><span class="s5">;</span>

  <span class="s1">RCTProfileBeginFlowEvent()</span><span class="s5">;</span>
  <span class="s5">__weak __typeof</span><span class="s1">(self) weakSelf = self</span><span class="s5">;</span>
  <span class="s1">[self _runAfterLoad:^() {</span>
    <span class="s1">RCTProfileEndFlowEvent()</span><span class="s5">;</span>
    <span class="s5">__strong __typeof</span><span class="s1">(weakSelf) strongSelf = weakSelf</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(!strongSelf) {</span>
      <span class="s5">return;</span>
    <span class="s1">}</span>

    <span class="s5">if </span><span class="s1">(strongSelf-&gt;_reactInstance) {</span>
      <span class="s1">strongSelf-&gt;_reactInstance-&gt;callJSFunction(</span>
          <span class="s1">[module UTF8String]</span><span class="s5">, </span><span class="s1">[method UTF8String]</span><span class="s5">, </span><span class="s1">convertIdToFollyDynamic(args ?: </span><span class="s5">@</span><span class="s1">[]))</span><span class="s5">;</span>

      <span class="s0">// ensureOnJavaScriptThread may execute immediately, so use jsMessageThread, to make sure</span>
      <span class="s0">// the block is invoked after callJSFunction</span>
      <span class="s5">if </span><span class="s1">(completion) {</span>
        <span class="s5">if </span><span class="s1">(strongSelf-&gt;_jsMessageThread) {</span>
          <span class="s1">strongSelf-&gt;_jsMessageThread-&gt;runOnQueue(completion)</span><span class="s5">;</span>
        <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
          <span class="s1">RCTLogWarn(</span><span class="s5">@</span><span class="s3">&quot;Can't invoke completion without messageThread&quot;</span><span class="s1">)</span><span class="s5">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}]</span><span class="s5">;</span>

  <span class="s1">RCT_PROFILE_END_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Called by RCTModuleMethod from any thread. 
 */</span>
<span class="s1">- (</span><span class="s5">void</span><span class="s1">)enqueueCallback:(NSNumber *)cbID args:(NSArray *)args</span>
<span class="s1">{</span>
  <span class="s5">if </span><span class="s1">(!self.valid) {</span>
    <span class="s5">return;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * AnyThread 
   */</span>

  <span class="s1">RCTProfileBeginFlowEvent()</span><span class="s5">;</span>
  <span class="s5">__weak __typeof</span><span class="s1">(self) weakSelf = self</span><span class="s5">;</span>
  <span class="s1">[self _runAfterLoad:^() {</span>
    <span class="s1">RCTProfileEndFlowEvent()</span><span class="s5">;</span>
    <span class="s5">__strong __typeof</span><span class="s1">(weakSelf) strongSelf = weakSelf</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(!strongSelf) {</span>
      <span class="s5">return;</span>
    <span class="s1">}</span>

    <span class="s5">if </span><span class="s1">(strongSelf-&gt;_reactInstance) {</span>
      <span class="s1">strongSelf-&gt;_reactInstance-&gt;callJSCallback([cbID unsignedLongLongValue]</span><span class="s5">, </span><span class="s1">convertIdToFollyDynamic(args ?: </span><span class="s5">@</span><span class="s1">[]))</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">}]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Private hack to support `setTimeout(fn, 0)` 
 */</span>
<span class="s1">- (</span><span class="s5">void</span><span class="s1">)_immediatelyCallTimer:(NSNumber *)timer</span>
<span class="s1">{</span>
  <span class="s5">if </span><span class="s1">(_reactInstance) {</span>
    <span class="s1">_reactInstance-&gt;callJSFunction(</span>
        <span class="s3">&quot;JSTimers&quot;</span><span class="s5">, </span><span class="s3">&quot;callTimers&quot;</span><span class="s5">, </span><span class="s1">folly::</span><span class="s5">dynamic</span><span class="s1">::array(folly::</span><span class="s5">dynamic</span><span class="s1">::array([timer doubleValue])))</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)enqueueApplicationScript:(NSData *)script url:(NSURL *)url onComplete:(dispatch_block_t)onComplete</span>
<span class="s1">{</span>
  <span class="s1">RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;-[RCTCxxBridge enqueueApplicationScript]&quot;</span><span class="s5">, </span><span class="s1">nil)</span><span class="s5">;</span>

  <span class="s1">[self executeApplicationScript:script url:url async:YES]</span><span class="s5">;</span>

  <span class="s1">RCT_PROFILE_END_EVENT(RCTProfileTagAlways</span><span class="s5">, @</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s5">;</span>

  <span class="s0">// Assumes that onComplete can be called when the next block on the JS thread is scheduled</span>
  <span class="s5">if </span><span class="s1">(onComplete) {</span>
    <span class="s1">RCTAssert(_jsMessageThread != </span><span class="s5">nullptr, @</span><span class="s3">&quot;Cannot invoke completion without jsMessageThread&quot;</span><span class="s1">)</span><span class="s5">;</span>
    <span class="s1">_jsMessageThread-&gt;runOnQueue(onComplete)</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)executeApplicationScriptSync:(NSData *)script url:(NSURL *)url</span>
<span class="s1">{</span>
  <span class="s1">[self executeApplicationScript:script url:url async:NO]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static </span><span class="s1">uint32_t RCTReadUInt32LE(NSData *script</span><span class="s5">, </span><span class="s1">uint32_t offset)</span>
<span class="s1">{</span>
  <span class="s5">return </span><span class="s1">[script length] &lt; offset + </span><span class="s4">4 </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: CFSwapInt32LittleToHost(*(((uint32_t *)[script bytes]) + offset / </span><span class="s4">4</span><span class="s1">))</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)executeApplicationScript:(NSData *)script url:(NSURL *)url async:(BOOL)async</span>
<span class="s1">{</span>
  <span class="s1">[self _tryAndHandleError:^{</span>
    <span class="s1">NSString *sourceUrlStr = deriveSourceURL(url)</span><span class="s5">;</span>
    <span class="s1">[[NSNotificationCenter defaultCenter] postNotificationName:RCTJavaScriptWillStartExecutingNotification</span>
                                                        <span class="s1">object:self-&gt;_parentBridge</span>
                                                      <span class="s1">userInfo:</span><span class="s5">@</span><span class="s1">{</span><span class="s5">@</span><span class="s3">&quot;bridge&quot; </span><span class="s1">: self}]</span><span class="s5">;</span>

    <span class="s1">BundleHeader header</span><span class="s5">;</span>
    <span class="s1">[script getBytes:&amp;header length:</span><span class="s5">sizeof</span><span class="s1">(header)]</span><span class="s5">;</span>
    <span class="s1">ScriptTag scriptType = parseTypeFromHeader(header)</span><span class="s5">;</span>

    <span class="s0">// hold a local reference to reactInstance in case a parallel thread</span>
    <span class="s0">// resets it between null check and usage</span>
    <span class="s5">auto </span><span class="s1">reactInstance = self-&gt;_reactInstance</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(reactInstance &amp;&amp; scriptType == ScriptTag::MetroHBCBundle) {</span>
      <span class="s1">uint32_t offset = </span><span class="s4">8</span><span class="s5">;</span>
      <span class="s5">while </span><span class="s1">(offset &lt; script.length) {</span>
        <span class="s1">uint32_t fileLength = RCTReadUInt32LE(script</span><span class="s5">, </span><span class="s1">offset)</span><span class="s5">;</span>
        <span class="s1">NSData *unit = [script subdataWithRange:NSMakeRange(offset + </span><span class="s4">4</span><span class="s5">, </span><span class="s1">fileLength)]</span><span class="s5">;</span>
        <span class="s1">reactInstance-&gt;loadScriptFromString(std::make_unique&lt;NSDataBigString&gt;(unit)</span><span class="s5">, </span><span class="s1">sourceUrlStr.UTF8String</span><span class="s5">, false</span><span class="s1">)</span><span class="s5">;</span>
        <span class="s1">offset += ((fileLength + RCT_BYTECODE_ALIGNMENT - </span><span class="s4">1</span><span class="s1">) &amp; ~(RCT_BYTECODE_ALIGNMENT - </span><span class="s4">1</span><span class="s1">)) + </span><span class="s4">4</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s5">else if </span><span class="s1">(scriptType == ScriptTag::RAMBundle) {</span>
      <span class="s1">[self-&gt;_performanceLogger markStartForTag:RCTPLRAMBundleLoad]</span><span class="s5">;</span>
      <span class="s5">auto </span><span class="s1">ramBundle = std::make_unique&lt;JSIndexedRAMBundle&gt;(sourceUrlStr.UTF8String)</span><span class="s5">;</span>
      <span class="s1">std::unique_ptr&lt;</span><span class="s5">const </span><span class="s1">JSBigString&gt; scriptStr = ramBundle-&gt;getStartupCode()</span><span class="s5">;</span>
      <span class="s1">[self-&gt;_performanceLogger markStopForTag:RCTPLRAMBundleLoad]</span><span class="s5">;</span>
      <span class="s1">[self-&gt;_performanceLogger setValue:scriptStr-&gt;size() forTag:RCTPLRAMStartupCodeSize]</span><span class="s5">;</span>
      <span class="s5">if </span><span class="s1">(reactInstance) {</span>
        <span class="s5">auto </span><span class="s1">registry =</span>
            <span class="s1">RAMBundleRegistry::multipleBundlesRegistry(std::move(ramBundle)</span><span class="s5">, </span><span class="s1">JSIndexedRAMBundle::buildFactory())</span><span class="s5">;</span>
        <span class="s1">reactInstance-&gt;loadRAMBundle(std::move(registry)</span><span class="s5">, </span><span class="s1">std::move(scriptStr)</span><span class="s5">, </span><span class="s1">sourceUrlStr.UTF8String</span><span class="s5">, </span><span class="s1">!async)</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s5">else if </span><span class="s1">(reactInstance) {</span>
      <span class="s1">reactInstance-&gt;loadScriptFromString(std::make_unique&lt;NSDataBigString&gt;(script)</span><span class="s5">, </span><span class="s1">sourceUrlStr.UTF8String</span><span class="s5">, </span><span class="s1">!async)</span><span class="s5">;</span>
    <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
      <span class="s1">std::string methodName = async ? </span><span class="s3">&quot;loadBundle&quot; </span><span class="s1">: </span><span class="s3">&quot;loadBundleSync&quot;</span><span class="s5">;</span>
      <span class="s5">throw </span><span class="s1">std::logic_error(</span><span class="s3">&quot;Attempt to call &quot; </span><span class="s1">+ methodName + </span><span class="s3">&quot;: on uninitialized bridge&quot;</span><span class="s1">)</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">}]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)registerSegmentWithId:(NSUInteger)segmentId path:(NSString *)path</span>
<span class="s1">{</span>
  <span class="s5">if </span><span class="s1">(_reactInstance) {</span>
    <span class="s1">_reactInstance-&gt;registerBundle(</span><span class="s5">static_cast</span><span class="s1">&lt;uint32_t&gt;(segmentId)</span><span class="s5">, </span><span class="s1">path.UTF8String)</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Payload Processing</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)partialBatchDidFlush</span>
<span class="s1">{</span>
  <span class="s5">for </span><span class="s1">(RCTModuleData *moduleData in _moduleDataByID) {</span>
    <span class="s5">if </span><span class="s1">(moduleData.implementsPartialBatchDidFlush) {</span>
      <span class="s1">[self</span>
          <span class="s1">dispatchBlock:^{</span>
            <span class="s1">[moduleData.instance partialBatchDidFlush]</span><span class="s5">;</span>
          <span class="s1">}</span>
                  <span class="s1">queue:moduleData.methodQueue]</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)batchDidComplete</span>
<span class="s1">{</span>
  <span class="s0">// TODO #12592471: batchDidComplete is only used by RCTUIManager,</span>
  <span class="s0">// can we eliminate this special case?</span>
  <span class="s5">for </span><span class="s1">(RCTModuleData *moduleData in _moduleDataByID) {</span>
    <span class="s5">if </span><span class="s1">(moduleData.implementsBatchDidComplete) {</span>
      <span class="s1">[self</span>
          <span class="s1">dispatchBlock:^{</span>
            <span class="s1">[moduleData.instance batchDidComplete]</span><span class="s5">;</span>
          <span class="s1">}</span>
                  <span class="s1">queue:moduleData.methodQueue]</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)startProfiling</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertMainQueue()</span><span class="s5">;</span>

  <span class="s1">[self ensureOnJavaScriptThread:^{</span>
<span class="s2">#if </span><span class="s1">WITH_FBSYSTRACE</span>
    <span class="s1">[RCTFBSystrace registerCallbacks]</span><span class="s5">;</span>
<span class="s2">#endif</span>
    <span class="s1">RCTProfileInit(self)</span><span class="s5">;</span>

    <span class="s1">[self enqueueJSCall:</span><span class="s5">@</span><span class="s3">&quot;Systrace&quot; </span><span class="s1">method:</span><span class="s5">@</span><span class="s3">&quot;setEnabled&quot; </span><span class="s1">args:</span><span class="s5">@</span><span class="s1">[ </span><span class="s5">@</span><span class="s1">YES ] completion:NULL]</span><span class="s5">;</span>
  <span class="s1">}]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)stopProfiling:(</span><span class="s5">void </span><span class="s1">(^)(NSData *))callback</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertMainQueue()</span><span class="s5">;</span>

  <span class="s1">[self ensureOnJavaScriptThread:^{</span>
    <span class="s1">[self enqueueJSCall:</span><span class="s5">@</span><span class="s3">&quot;Systrace&quot; </span><span class="s1">method:</span><span class="s5">@</span><span class="s3">&quot;setEnabled&quot; </span><span class="s1">args:</span><span class="s5">@</span><span class="s1">[ </span><span class="s5">@</span><span class="s1">NO ] completion:NULL]</span><span class="s5">;</span>
    <span class="s1">RCTProfileEnd(self</span><span class="s5">, </span><span class="s1">^(NSString *log) {</span>
      <span class="s1">NSData *logData = [log dataUsingEncoding:NSUTF8StringEncoding]</span><span class="s5">;</span>
      <span class="s1">callback(logData)</span><span class="s5">;</span>
<span class="s2">#if </span><span class="s1">WITH_FBSYSTRACE</span>
      <span class="s5">if </span><span class="s1">(![RCTFBSystrace verifyTraceSize:logData.length]) {</span>
        <span class="s1">RCTLogWarn(</span>
            <span class="s5">@</span><span class="s3">&quot;Your FBSystrace trace might be truncated, try to bump up the buffer size&quot;</span>
             <span class="s3">&quot; in RCTFBSystrace.m or capture a shorter trace&quot;</span><span class="s1">)</span><span class="s5">;</span>
      <span class="s1">}</span>
      <span class="s1">[RCTFBSystrace unregisterCallbacks]</span><span class="s5">;</span>
<span class="s2">#endif</span>
    <span class="s1">})</span><span class="s5">;</span>
  <span class="s1">}]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)isBatchActive</span>
<span class="s1">{</span>
  <span class="s5">return </span><span class="s1">_reactInstance ? _reactInstance-&gt;isBatchActive() : NO</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void </span><span class="s1">*)runtime</span>
<span class="s1">{</span>
  <span class="s5">if </span><span class="s1">(!_reactInstance) {</span>
    <span class="s5">return nullptr;</span>
  <span class="s1">}</span>

  <span class="s5">return </span><span class="s1">_reactInstance-&gt;getJavaScriptContext()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s5">void</span><span class="s1">)invokeAsync:(std::function&lt;</span><span class="s5">void</span><span class="s1">()&gt; &amp;&amp;)func</span>
<span class="s1">{</span>
  <span class="s1">__block </span><span class="s5">auto </span><span class="s1">retainedFunc = std::move(func)</span><span class="s5">;</span>
  <span class="s5">__weak __typeof</span><span class="s1">(self) weakSelf = self</span><span class="s5">;</span>
  <span class="s1">[self _runAfterLoad:^{</span>
    <span class="s5">__strong __typeof</span><span class="s1">(self) strongSelf = weakSelf</span><span class="s5">;</span>

    <span class="s5">if </span><span class="s1">(std::shared_ptr&lt;CallInvoker&gt; jsInvoker = strongSelf.jsCallInvoker) {</span>
      <span class="s1">jsInvoker-&gt;invokeAsync(std::move(retainedFunc))</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">}]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - RCTBridge (RCTTurboModule)</span>

<span class="s1">- (std::shared_ptr&lt;CallInvoker&gt;)jsCallInvoker</span>
<span class="s1">{</span>
  <span class="s5">return </span><span class="s1">_reactInstance ? _reactInstance-&gt;getJSCallInvoker() : </span><span class="s5">nullptr;</span>
<span class="s1">}</span>

<span class="s1">- (std::shared_ptr&lt;CallInvoker&gt;)decorateNativeCallInvoker:(std::shared_ptr&lt;CallInvoker&gt;)nativeInvoker</span>
<span class="s1">{</span>
  <span class="s5">return </span><span class="s1">_reactInstance ? _reactInstance-&gt;getDecoratedNativeCallInvoker(nativeInvoker) : </span><span class="s5">nullptr;</span>
<span class="s1">}</span>

<span class="s5">@end</span>
</pre>
</body>
</html>
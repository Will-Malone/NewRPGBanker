<html>
<head>
<title>RNSScreen.mm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bbb529;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RNSScreen.mm</font>
</center></td></tr></table>
<pre><span class="s0">#import </span><span class="s2">&lt;UIKit/UIKit.h&gt;</span>

<span class="s0">#import </span><span class="s2">&quot;RNSScreen.h&quot;</span>
<span class="s0">#import </span><span class="s2">&quot;RNSScreenContainer.h&quot;</span>
<span class="s0">#import </span><span class="s2">&quot;RNSScreenWindowTraits.h&quot;</span>

<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTConversions.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTFabricComponentsPlugins.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTRootComponentView.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTSurfaceTouchHandler.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;react/renderer/components/rnscreens/EventEmitters.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;react/renderer/components/rnscreens/Props.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;react/renderer/components/rnscreens/RCTComponentViewHelpers.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;rnscreens/RNSScreenComponentDescriptor.h&gt;</span>
<span class="s0">#import </span><span class="s2">&quot;RNSConvert.h&quot;</span>
<span class="s0">#import </span><span class="s2">&quot;RNSScreenViewEvent.h&quot;</span>
<span class="s0">#else</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTTouchHandler.h&gt;</span>
<span class="s0">#endif</span>

<span class="s0">#import </span><span class="s2">&lt;React/RCTShadowView.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTUIManager.h&gt;</span>
<span class="s0">#import </span><span class="s2">&quot;RNSScreenStack.h&quot;</span>
<span class="s0">#import </span><span class="s2">&quot;RNSScreenStackHeaderConfig.h&quot;</span>

<span class="s3">@interface </span><span class="s1">RNSScreenView ()</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
    <span class="s1">&lt;RCTRNSScreenViewProtocol</span><span class="s3">, </span><span class="s1">UIAdaptivePresentationControllerDelegate&gt;</span>
<span class="s0">#else</span>
    <span class="s1">&lt;UIAdaptivePresentationControllerDelegate</span><span class="s3">, </span><span class="s1">RCTInvalidating&gt;</span>
<span class="s0">#endif</span>
<span class="s3">@end</span>

<span class="s3">@implementation </span><span class="s1">RNSScreenView {</span>
  <span class="s3">__weak </span><span class="s1">RCTBridge *_bridge</span><span class="s3">;</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s1">RCTSurfaceTouchHandler *_touchHandler</span><span class="s3">;</span>
  <span class="s1">facebook::react::RNSScreenShadowNode::ConcreteState::Shared _state</span><span class="s3">;</span>
  <span class="s4">// on fabric, they are not available by default so we need them exposed here too</span>
  <span class="s1">NSMutableArray&lt;UIView *&gt; *_reactSubviews</span><span class="s3">;</span>
<span class="s0">#else</span>
  <span class="s1">RCTTouchHandler *_touchHandler</span><span class="s3">;</span>
  <span class="s1">CGRect _reactFrame</span><span class="s3">;</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s1">- (instancetype)initWithFrame:(CGRect)frame</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(self = [super initWithFrame:frame]) {</span>
    <span class="s3">static const auto </span><span class="s1">defaultProps = std::make_shared&lt;</span><span class="s3">const </span><span class="s1">facebook::react::RNSScreenProps&gt;()</span><span class="s3">;</span>
    <span class="s1">_props = defaultProps</span><span class="s3">;</span>
    <span class="s1">_reactSubviews = [NSMutableArray </span><span class="s3">new</span><span class="s1">]</span><span class="s3">;</span>
    <span class="s1">[self initCommonProps]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">self</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">#endif </span><span class="s4">// RCT_NEW_ARCH_ENABLED</span>

<span class="s1">- (instancetype)initWithBridge:(RCTBridge *)bridge</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(self = [super init]) {</span>
    <span class="s1">_bridge = bridge</span><span class="s3">;</span>
    <span class="s1">[self initCommonProps]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">self</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)initCommonProps</span>
<span class="s1">{</span>
  <span class="s1">_controller = [[RNSScreen alloc] initWithView:self]</span><span class="s3">;</span>
  <span class="s1">_stackPresentation = RNSScreenStackPresentationPush</span><span class="s3">;</span>
  <span class="s1">_stackAnimation = RNSScreenStackAnimationDefault</span><span class="s3">;</span>
  <span class="s1">_gestureEnabled = YES</span><span class="s3">;</span>
  <span class="s1">_replaceAnimation = RNSScreenReplaceAnimationPop</span><span class="s3">;</span>
  <span class="s1">_dismissed = NO</span><span class="s3">;</span>
  <span class="s1">_hasStatusBarStyleSet = NO</span><span class="s3">;</span>
  <span class="s1">_hasStatusBarAnimationSet = NO</span><span class="s3">;</span>
  <span class="s1">_hasStatusBarHiddenSet = NO</span><span class="s3">;</span>
  <span class="s1">_hasOrientationSet = NO</span><span class="s3">;</span>
  <span class="s1">_hasHomeIndicatorHiddenSet = NO</span><span class="s3">;</span>
<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
  <span class="s1">_sheetExpandsWhenScrolledToEdge = YES</span><span class="s3">;</span>
<span class="s0">#endif </span><span class="s4">// !TARGET_OS_TV</span>
<span class="s1">}</span>

<span class="s1">- (UIViewController *)reactViewController</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">_controller</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s1">- (NSArray&lt;UIView *&gt; *)reactSubviews</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">_reactSubviews</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">#endif</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)updateBounds</span>
<span class="s1">{</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s3">if </span><span class="s1">(_state != </span><span class="s3">nullptr</span><span class="s1">) {</span>
    <span class="s3">auto </span><span class="s1">newState = facebook::react::RNSScreenState{RCTSizeFromCGSize(self.bounds.size)}</span><span class="s3">;</span>
    <span class="s1">_state-&gt;updateState(std::move(newState))</span><span class="s3">;</span>
    <span class="s1">UINavigationController *navctr = _controller.navigationController</span><span class="s3">;</span>
    <span class="s1">[navctr.view setNeedsLayout]</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#else</span>
  <span class="s1">[_bridge.uiManager setSize:self.bounds.size forView:self]</span><span class="s3">;</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)setStackPresentation:(RNSScreenStackPresentation)stackPresentation</span>
<span class="s1">{</span>
  <span class="s3">switch </span><span class="s1">(stackPresentation) {</span>
    <span class="s3">case </span><span class="s1">RNSScreenStackPresentationModal:</span>
<span class="s0">#if </span><span class="s1">defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; defined(__IPHONE_13_0) &amp;&amp; \ 
    __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_13_0</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">@available</span><span class="s1">(iOS </span><span class="s5">13.0</span><span class="s3">, </span><span class="s1">tvOS </span><span class="s5">13.0</span><span class="s3">, </span><span class="s1">*)) {</span>
        <span class="s1">_controller.modalPresentationStyle = UIModalPresentationAutomatic</span><span class="s3">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">_controller.modalPresentationStyle = UIModalPresentationFullScreen</span><span class="s3">;</span>
      <span class="s1">}</span>
<span class="s0">#else</span>
      <span class="s1">_controller.modalPresentationStyle = UIModalPresentationFullScreen</span><span class="s3">;</span>
<span class="s0">#endif</span>
      <span class="s3">break;</span>
    <span class="s3">case </span><span class="s1">RNSScreenStackPresentationFullScreenModal:</span>
      <span class="s1">_controller.modalPresentationStyle = UIModalPresentationFullScreen</span><span class="s3">;</span>
      <span class="s3">break;</span>
<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
    <span class="s3">case </span><span class="s1">RNSScreenStackPresentationFormSheet:</span>
      <span class="s1">_controller.modalPresentationStyle = UIModalPresentationFormSheet</span><span class="s3">;</span>
      <span class="s3">break;</span>
<span class="s0">#endif</span>
    <span class="s3">case </span><span class="s1">RNSScreenStackPresentationTransparentModal:</span>
      <span class="s1">_controller.modalPresentationStyle = UIModalPresentationOverFullScreen</span><span class="s3">;</span>
      <span class="s3">break;</span>
    <span class="s3">case </span><span class="s1">RNSScreenStackPresentationContainedModal:</span>
      <span class="s1">_controller.modalPresentationStyle = UIModalPresentationCurrentContext</span><span class="s3">;</span>
      <span class="s3">break;</span>
    <span class="s3">case </span><span class="s1">RNSScreenStackPresentationContainedTransparentModal:</span>
      <span class="s1">_controller.modalPresentationStyle = UIModalPresentationOverCurrentContext</span><span class="s3">;</span>
      <span class="s3">break;</span>
    <span class="s3">case </span><span class="s1">RNSScreenStackPresentationPush:</span>
      <span class="s4">// ignored, we only need to keep in mind not to set presentation delegate</span>
      <span class="s3">break;</span>
  <span class="s1">}</span>

  <span class="s4">// There is a bug in UIKit which causes retain loop when presentationController is accessed for a</span>
  <span class="s4">// controller that is not going to be presented modally. We therefore need to avoid setting the</span>
  <span class="s4">// delegate for screens presented using push. This also means that when controller is updated from</span>
  <span class="s4">// modal to push type, this may cause memory leak, we warn about that as well.</span>
  <span class="s3">if </span><span class="s1">(stackPresentation != RNSScreenStackPresentationPush) {</span>
    <span class="s4">// `modalPresentationStyle` must be set before accessing `presentationController`</span>
    <span class="s4">// otherwise a default controller will be created and cannot be changed after.</span>
    <span class="s4">// Documented here:</span>
    <span class="s4">// https://developer.apple.com/documentation/uikit/uiviewcontroller/1621426-presentationcontroller?language=objc</span>
    <span class="s1">_controller.presentationController.delegate = self</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(_stackPresentation != RNSScreenStackPresentationPush) {</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
    <span class="s4">// TODO: on Fabric, same controllers can be used as modals and then recycled and used a push which would result in</span>
    <span class="s4">// this error. It would be good to check if it doesn't leak in such case.</span>
<span class="s0">#else</span>
    <span class="s1">RCTLogError(</span>
        <span class="s3">@</span><span class="s2">&quot;Screen presentation updated from modal to push, this may likely result in a screen object leakage. If you need to change presentation style create a new screen object instead&quot;</span><span class="s1">)</span><span class="s3">;</span>
<span class="s0">#endif</span>
  <span class="s1">}</span>
  <span class="s1">_stackPresentation = stackPresentation</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)setStackAnimation:(RNSScreenStackAnimation)stackAnimation</span>
<span class="s1">{</span>
  <span class="s1">_stackAnimation = stackAnimation</span><span class="s3">;</span>

  <span class="s3">switch </span><span class="s1">(stackAnimation) {</span>
    <span class="s3">case </span><span class="s1">RNSScreenStackAnimationFade:</span>
      <span class="s1">_controller.modalTransitionStyle = UIModalTransitionStyleCrossDissolve</span><span class="s3">;</span>
      <span class="s3">break;</span>
<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
    <span class="s3">case </span><span class="s1">RNSScreenStackAnimationFlip:</span>
      <span class="s1">_controller.modalTransitionStyle = UIModalTransitionStyleFlipHorizontal</span><span class="s3">;</span>
      <span class="s3">break;</span>
<span class="s0">#endif</span>
    <span class="s3">case </span><span class="s1">RNSScreenStackAnimationNone:</span>
    <span class="s3">case </span><span class="s1">RNSScreenStackAnimationDefault:</span>
    <span class="s3">case </span><span class="s1">RNSScreenStackAnimationSimplePush:</span>
    <span class="s3">case </span><span class="s1">RNSScreenStackAnimationSlideFromBottom:</span>
    <span class="s3">case </span><span class="s1">RNSScreenStackAnimationFadeFromBottom:</span>
      <span class="s4">// Default</span>
      <span class="s3">break;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)setGestureEnabled:(BOOL)gestureEnabled</span>
<span class="s1">{</span>
<span class="s0">#if </span><span class="s1">defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; defined(__IPHONE_13_0) &amp;&amp; \ 
    __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_13_0</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">@available</span><span class="s1">(iOS </span><span class="s5">13.0</span><span class="s3">, </span><span class="s1">tvOS </span><span class="s5">13.0</span><span class="s3">, </span><span class="s1">*)) {</span>
    <span class="s1">_controller.modalInPresentation = !gestureEnabled</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#endif</span>

  <span class="s1">_gestureEnabled = gestureEnabled</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)setReplaceAnimation:(RNSScreenReplaceAnimation)replaceAnimation</span>
<span class="s1">{</span>
  <span class="s1">_replaceAnimation = replaceAnimation</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s4">// Nil will be provided when activityState is set as an animated value and we change</span>
<span class="s4">// it from JS to be a plain value (non animated).</span>
<span class="s4">// In case when nil is received, we want to ignore such value and not make</span>
<span class="s4">// any updates as the actual non-nil value will follow immediately.</span>
<span class="s1">- (</span><span class="s3">void</span><span class="s1">)setActivityStateOrNil:(NSNumber *)activityStateOrNil</span>
<span class="s1">{</span>
  <span class="s3">int </span><span class="s1">activityState = [activityStateOrNil intValue]</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">(activityStateOrNil != nil &amp;&amp; activityState != -</span><span class="s5">1 </span><span class="s1">&amp;&amp; activityState != _activityState) {</span>
    <span class="s1">_activityState = activityState</span><span class="s3">;</span>
    <span class="s1">[_reactSuperview markChildUpdated]</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
<span class="s1">- (</span><span class="s3">void</span><span class="s1">)setStatusBarStyle:(RNSStatusBarStyle)statusBarStyle</span>
<span class="s1">{</span>
  <span class="s1">_hasStatusBarStyleSet = YES</span><span class="s3">;</span>
  <span class="s1">_statusBarStyle = statusBarStyle</span><span class="s3">;</span>
  <span class="s1">[RNSScreenWindowTraits assertViewControllerBasedStatusBarAppearenceSet]</span><span class="s3">;</span>
  <span class="s1">[RNSScreenWindowTraits updateStatusBarAppearance]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)setStatusBarAnimation:(UIStatusBarAnimation)statusBarAnimation</span>
<span class="s1">{</span>
  <span class="s1">_hasStatusBarAnimationSet = YES</span><span class="s3">;</span>
  <span class="s1">_statusBarAnimation = statusBarAnimation</span><span class="s3">;</span>
  <span class="s1">[RNSScreenWindowTraits assertViewControllerBasedStatusBarAppearenceSet]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)setStatusBarHidden:(BOOL)statusBarHidden</span>
<span class="s1">{</span>
  <span class="s1">_hasStatusBarHiddenSet = YES</span><span class="s3">;</span>
  <span class="s1">_statusBarHidden = statusBarHidden</span><span class="s3">;</span>
  <span class="s1">[RNSScreenWindowTraits assertViewControllerBasedStatusBarAppearenceSet]</span><span class="s3">;</span>
  <span class="s1">[RNSScreenWindowTraits updateStatusBarAppearance]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)setScreenOrientation:(UIInterfaceOrientationMask)screenOrientation</span>
<span class="s1">{</span>
  <span class="s1">_hasOrientationSet = YES</span><span class="s3">;</span>
  <span class="s1">_screenOrientation = screenOrientation</span><span class="s3">;</span>
  <span class="s1">[RNSScreenWindowTraits enforceDesiredDeviceOrientation]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)setHomeIndicatorHidden:(BOOL)homeIndicatorHidden</span>
<span class="s1">{</span>
  <span class="s1">_hasHomeIndicatorHiddenSet = YES</span><span class="s3">;</span>
  <span class="s1">_homeIndicatorHidden = homeIndicatorHidden</span><span class="s3">;</span>
  <span class="s1">[RNSScreenWindowTraits updateHomeIndicatorAutoHidden]</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">#endif</span>

<span class="s1">- (UIView *)reactSuperview</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">_reactSuperview</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)addSubview:(UIView *)view</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(![view isKindOfClass:[RNSScreenStackHeaderConfig </span><span class="s3">class</span><span class="s1">]]) {</span>
    <span class="s1">[super addSubview:view]</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">((RNSScreenStackHeaderConfig *)view).screenView = self</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)notifyDismissedWithCount:(</span><span class="s3">int</span><span class="s1">)dismissCount</span>
<span class="s1">{</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s4">// If screen is already unmounted then there will be no event emitter</span>
  <span class="s4">// it will be cleaned in prepareForRecycle</span>
  <span class="s3">if </span><span class="s1">(_eventEmitter != </span><span class="s3">nullptr</span><span class="s1">) {</span>
    <span class="s1">std::dynamic_pointer_cast&lt;</span><span class="s3">const </span><span class="s1">facebook::react::RNSScreenEventEmitter&gt;(_eventEmitter)</span>
        <span class="s1">-&gt;onDismissed(facebook::react::RNSScreenEventEmitter::OnDismissed{.dismissCount = dismissCount})</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#else</span>
  <span class="s4">// TODO: hopefully problems connected to dismissed prop are only the case on paper</span>
  <span class="s1">_dismissed = YES</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">(self.onDismissed) {</span>
    <span class="s1">dispatch_async(dispatch_get_main_queue()</span><span class="s3">, </span><span class="s1">^{</span>
      <span class="s3">if </span><span class="s1">(self.onDismissed) {</span>
        <span class="s1">self.onDismissed(</span><span class="s3">@</span><span class="s1">{</span><span class="s3">@</span><span class="s2">&quot;dismissCount&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(dismissCount)})</span><span class="s3">;</span>
      <span class="s1">}</span>
    <span class="s1">})</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)notifyDismissCancelledWithDismissCount:(</span><span class="s3">int</span><span class="s1">)dismissCount</span>
<span class="s1">{</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s4">// If screen is already unmounted then there will be no event emitter</span>
  <span class="s4">// it will be cleaned in prepareForRecycle</span>
  <span class="s3">if </span><span class="s1">(_eventEmitter != </span><span class="s3">nullptr</span><span class="s1">) {</span>
    <span class="s1">std::dynamic_pointer_cast&lt;</span><span class="s3">const </span><span class="s1">facebook::react::RNSScreenEventEmitter&gt;(_eventEmitter)</span>
        <span class="s1">-&gt;onNativeDismissCancelled(</span>
            <span class="s1">facebook::react::RNSScreenEventEmitter::OnNativeDismissCancelled{.dismissCount = dismissCount})</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#else</span>
  <span class="s3">if </span><span class="s1">(self.onNativeDismissCancelled) {</span>
    <span class="s1">self.onNativeDismissCancelled(</span><span class="s3">@</span><span class="s1">{</span><span class="s3">@</span><span class="s2">&quot;dismissCount&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(dismissCount)})</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)notifyWillAppear</span>
<span class="s1">{</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s4">// If screen is already unmounted then there will be no event emitter</span>
  <span class="s4">// it will be cleaned in prepareForRecycle</span>
  <span class="s3">if </span><span class="s1">(_eventEmitter != </span><span class="s3">nullptr</span><span class="s1">) {</span>
    <span class="s1">std::dynamic_pointer_cast&lt;</span><span class="s3">const </span><span class="s1">facebook::react::RNSScreenEventEmitter&gt;(_eventEmitter)</span>
        <span class="s1">-&gt;onWillAppear(facebook::react::RNSScreenEventEmitter::OnWillAppear{})</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s1">[self updateLayoutMetrics:_newLayoutMetrics oldLayoutMetrics:_oldLayoutMetrics]</span><span class="s3">;</span>
<span class="s0">#else</span>
  <span class="s3">if </span><span class="s1">(self.onWillAppear) {</span>
    <span class="s1">self.onWillAppear(nil)</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s4">// we do it here too because at this moment the `parentViewController` is already not nil,</span>
  <span class="s4">// so if the parent is not UINavCtr, the frame will be updated to the correct one.</span>
  <span class="s1">[self reactSetFrame:_reactFrame]</span><span class="s3">;</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)notifyWillDisappear</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(_hideKeyboardOnSwipe) {</span>
    <span class="s1">[self endEditing:YES]</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s4">// If screen is already unmounted then there will be no event emitter</span>
  <span class="s4">// it will be cleaned in prepareForRecycle</span>
  <span class="s3">if </span><span class="s1">(_eventEmitter != </span><span class="s3">nullptr</span><span class="s1">) {</span>
    <span class="s1">std::dynamic_pointer_cast&lt;</span><span class="s3">const </span><span class="s1">facebook::react::RNSScreenEventEmitter&gt;(_eventEmitter)</span>
        <span class="s1">-&gt;onWillDisappear(facebook::react::RNSScreenEventEmitter::OnWillDisappear{})</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#else</span>
  <span class="s3">if </span><span class="s1">(self.onWillDisappear) {</span>
    <span class="s1">self.onWillDisappear(nil)</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)notifyAppear</span>
<span class="s1">{</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s4">// If screen is already unmounted then there will be no event emitter</span>
  <span class="s4">// it will be cleaned in prepareForRecycle</span>
  <span class="s3">if </span><span class="s1">(_eventEmitter != </span><span class="s3">nullptr</span><span class="s1">) {</span>
    <span class="s1">std::dynamic_pointer_cast&lt;</span><span class="s3">const </span><span class="s1">facebook::react::RNSScreenEventEmitter&gt;(_eventEmitter)</span>
        <span class="s1">-&gt;onAppear(facebook::react::RNSScreenEventEmitter::OnAppear{})</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#else</span>
  <span class="s3">if </span><span class="s1">(self.onAppear) {</span>
    <span class="s1">dispatch_async(dispatch_get_main_queue()</span><span class="s3">, </span><span class="s1">^{</span>
      <span class="s3">if </span><span class="s1">(self.onAppear) {</span>
        <span class="s1">self.onAppear(nil)</span><span class="s3">;</span>
      <span class="s1">}</span>
    <span class="s1">})</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)notifyDisappear</span>
<span class="s1">{</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s4">// If screen is already unmounted then there will be no event emitter</span>
  <span class="s4">// it will be cleaned in prepareForRecycle</span>
  <span class="s3">if </span><span class="s1">(_eventEmitter != </span><span class="s3">nullptr</span><span class="s1">) {</span>
    <span class="s1">std::dynamic_pointer_cast&lt;</span><span class="s3">const </span><span class="s1">facebook::react::RNSScreenEventEmitter&gt;(_eventEmitter)</span>
        <span class="s1">-&gt;onDisappear(facebook::react::RNSScreenEventEmitter::OnDisappear{})</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#else</span>
  <span class="s3">if </span><span class="s1">(self.onDisappear) {</span>
    <span class="s1">self.onDisappear(nil)</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)isMountedUnderScreenOrReactRoot</span>
<span class="s1">{</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s0">#define </span><span class="s1">RNS_EXPECTED_VIEW RCTRootComponentView</span>
<span class="s0">#else</span>
<span class="s0">#define </span><span class="s1">RNS_EXPECTED_VIEW RCTRootView</span>
<span class="s0">#endif</span>
  <span class="s3">for </span><span class="s1">(UIView *parent = self.superview</span><span class="s3">; </span><span class="s1">parent != nil</span><span class="s3">; </span><span class="s1">parent = parent.superview) {</span>
    <span class="s3">if </span><span class="s1">([parent isKindOfClass:[RNS_EXPECTED_VIEW </span><span class="s3">class</span><span class="s1">]] || [parent isKindOfClass:[RNSScreenView </span><span class="s3">class</span><span class="s1">]]) {</span>
      <span class="s3">return </span><span class="s1">YES</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">NO</span><span class="s3">;</span>
<span class="s0">#undef </span><span class="s1">RNS_EXPECTED_VIEW</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)didMoveToWindow</span>
<span class="s1">{</span>
  <span class="s4">// For RN touches to work we need to instantiate and connect RCTTouchHandler. This only applies</span>
  <span class="s4">// for screens that aren't mounted under RCTRootView e.g., modals that are mounted directly to</span>
  <span class="s4">// root application window.</span>
  <span class="s3">if </span><span class="s1">(self.window != nil &amp;&amp; ![self isMountedUnderScreenOrReactRoot]) {</span>
    <span class="s3">if </span><span class="s1">(_touchHandler == nil) {</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
      <span class="s1">_touchHandler = [RCTSurfaceTouchHandler </span><span class="s3">new</span><span class="s1">]</span><span class="s3">;</span>
<span class="s0">#else</span>
      <span class="s1">_touchHandler = [[RCTTouchHandler alloc] initWithBridge:_bridge]</span><span class="s3">;</span>
<span class="s0">#endif</span>
    <span class="s1">}</span>
    <span class="s1">[_touchHandler attachToView:self]</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">[_touchHandler detachFromView:self]</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s1">- (RCTSurfaceTouchHandler *)touchHandler</span>
<span class="s0">#else</span>
<span class="s1">- (RCTTouchHandler *)touchHandler</span>
<span class="s0">#endif</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(_touchHandler != nil) {</span>
    <span class="s3">return </span><span class="s1">_touchHandler</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s1">UIView *parent = [self superview]</span><span class="s3">;</span>
  <span class="s3">while </span><span class="s1">(parent != nil &amp;&amp; ![parent respondsToSelector:</span><span class="s3">@selector</span><span class="s1">(touchHandler)])</span>
    <span class="s1">parent = parent.superview</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">(parent != nil) {</span>
    <span class="s3">return </span><span class="s1">[parent performSelector:</span><span class="s3">@selector</span><span class="s1">(touchHandler)]</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">nil</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)notifyFinishTransitioning</span>
<span class="s1">{</span>
  <span class="s1">[_controller notifyFinishTransitioning]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)notifyTransitionProgress:(</span><span class="s3">double</span><span class="s1">)progress closing:(BOOL)closing goingForward:(BOOL)goingForward</span>
<span class="s1">{</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s3">if </span><span class="s1">(_eventEmitter != </span><span class="s3">nullptr</span><span class="s1">) {</span>
    <span class="s1">std::dynamic_pointer_cast&lt;</span><span class="s3">const </span><span class="s1">facebook::react::RNSScreenEventEmitter&gt;(_eventEmitter)</span>
        <span class="s1">-&gt;onTransitionProgress(facebook::react::RNSScreenEventEmitter::OnTransitionProgress{</span>
            <span class="s1">.progress = progress</span><span class="s3">, </span><span class="s1">.closing = closing ? </span><span class="s5">1 </span><span class="s1">: </span><span class="s5">0</span><span class="s3">, </span><span class="s1">.goingForward = goingForward ? </span><span class="s5">1 </span><span class="s1">: </span><span class="s5">0</span><span class="s1">})</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s1">RNSScreenViewEvent *event = [[RNSScreenViewEvent alloc] initWithEventName:</span><span class="s3">@</span><span class="s2">&quot;onTransitionProgress&quot;</span>
                                                                   <span class="s1">reactTag:[NSNumber numberWithInt:self.tag]</span>
                                                                   <span class="s1">progress:progress</span>
                                                                    <span class="s1">closing:closing</span>
                                                               <span class="s1">goingForward:goingForward]</span><span class="s3">;</span>
  <span class="s1">[[RCTBridge currentBridge].eventDispatcher sendEvent:event]</span><span class="s3">;</span>
<span class="s0">#else</span>
  <span class="s3">if </span><span class="s1">(self.onTransitionProgress) {</span>
    <span class="s1">self.onTransitionProgress(</span><span class="s3">@</span><span class="s1">{</span>
      <span class="s3">@</span><span class="s2">&quot;progress&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(progress)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;closing&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(closing ? </span><span class="s5">1 </span><span class="s1">: </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;goingForward&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(goingForward ? </span><span class="s5">1 </span><span class="s1">: </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">})</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)presentationControllerWillDismiss:(UIPresentationController *)presentationController</span>
<span class="s1">{</span>
  <span class="s4">// We need to call both &quot;cancel&quot; and &quot;reset&quot; here because RN's gesture recognizer</span>
  <span class="s4">// does not handle the scenario when it gets cancelled by other top</span>
  <span class="s4">// level gesture recognizer. In this case by the modal dismiss gesture.</span>
  <span class="s4">// Because of that, at the moment when this method gets called the React's</span>
  <span class="s4">// gesture recognizer is already in FAILED state but cancel events never gets</span>
  <span class="s4">// send to JS. Calling &quot;reset&quot; forces RCTTouchHanler to dispatch cancel event.</span>
  <span class="s4">// To test this behavior one need to open a dismissable modal and start</span>
  <span class="s4">// pulling down starting at some touchable item. Without &quot;reset&quot; the touchable</span>
  <span class="s4">// will never go back from highlighted state even when the modal start sliding</span>
  <span class="s4">// down.</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s1">[_touchHandler setEnabled:NO]</span><span class="s3">;</span>
  <span class="s1">[_touchHandler setEnabled:YES]</span><span class="s3">;</span>
<span class="s0">#else</span>
  <span class="s1">[_touchHandler cancel]</span><span class="s3">;</span>
<span class="s0">#endif</span>
  <span class="s1">[_touchHandler reset]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)presentationControllerShouldDismiss:(UIPresentationController *)presentationController</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(_preventNativeDismiss) {</span>
    <span class="s1">[self notifyDismissCancelledWithDismissCount:</span><span class="s5">1</span><span class="s1">]</span><span class="s3">;</span>
    <span class="s3">return </span><span class="s1">NO</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">_gestureEnabled</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)presentationControllerDidDismiss:(UIPresentationController *)presentationController</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">([_reactSuperview respondsToSelector:</span><span class="s3">@selector</span><span class="s1">(presentationControllerDidDismiss:)]) {</span>
    <span class="s1">[_reactSuperview performSelector:</span><span class="s3">@selector</span><span class="s1">(presentationControllerDidDismiss:) withObject:presentationController]</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)isModal</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">self.stackPresentation != RNSScreenStackPresentationPush</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
<span class="s4">/** 
 * Updates settings for sheet presentation controller. 
 * Note that this method should not be called inside `stackPresentation` setter, because on Paper we don't have 
 * guarantee that values of all related props had been updated earlier. 
 */</span>
<span class="s1">- (</span><span class="s3">void</span><span class="s1">)updatePresentationStyle</span>
<span class="s1">{</span>
<span class="s0">#if </span><span class="s1">defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; defined(__IPHONE_15_0) &amp;&amp; \ 
    __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_15_0</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">@available</span><span class="s1">(iOS </span><span class="s5">15.0</span><span class="s3">, </span><span class="s1">*)) {</span>
    <span class="s1">UISheetPresentationController *sheet = _controller.sheetPresentationController</span><span class="s3">;</span>
    <span class="s3">if </span><span class="s1">(_stackPresentation == RNSScreenStackPresentationFormSheet &amp;&amp; sheet != nil) {</span>
      <span class="s1">sheet.prefersScrollingExpandsWhenScrolledToEdge = _sheetExpandsWhenScrolledToEdge</span><span class="s3">;</span>
      <span class="s1">sheet.prefersGrabberVisible = _sheetGrabberVisible</span><span class="s3">;</span>
      <span class="s1">sheet.preferredCornerRadius =</span>
          <span class="s1">_sheetCornerRadius &lt; </span><span class="s5">0 </span><span class="s1">? UISheetPresentationControllerAutomaticDimension : _sheetCornerRadius</span><span class="s3">;</span>

      <span class="s3">if </span><span class="s1">(_sheetLargestUndimmedDetent == RNSScreenDetentTypeMedium) {</span>
        <span class="s1">sheet.largestUndimmedDetentIdentifier = UISheetPresentationControllerDetentIdentifierMedium</span><span class="s3">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(_sheetLargestUndimmedDetent == RNSScreenDetentTypeLarge) {</span>
        <span class="s1">sheet.largestUndimmedDetentIdentifier = UISheetPresentationControllerDetentIdentifierLarge</span><span class="s3">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(_sheetLargestUndimmedDetent == RNSScreenDetentTypeAll) {</span>
        <span class="s1">sheet.largestUndimmedDetentIdentifier = nil</span><span class="s3">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">RCTLogError(</span><span class="s3">@</span><span class="s2">&quot;Unhandled value of sheetLargestUndimmedDetent passed&quot;</span><span class="s1">)</span><span class="s3">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(_sheetAllowedDetents == RNSScreenDetentTypeMedium) {</span>
        <span class="s1">sheet.detents = </span><span class="s3">@</span><span class="s1">[ UISheetPresentationControllerDetent.mediumDetent ]</span><span class="s3">;</span>
        <span class="s3">if </span><span class="s1">(sheet.selectedDetentIdentifier != UISheetPresentationControllerDetentIdentifierMedium) {</span>
          <span class="s1">[sheet animateChanges:^{</span>
            <span class="s1">sheet.selectedDetentIdentifier = UISheetPresentationControllerDetentIdentifierMedium</span><span class="s3">;</span>
          <span class="s1">}]</span><span class="s3">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(_sheetAllowedDetents == RNSScreenDetentTypeLarge) {</span>
        <span class="s1">sheet.detents = </span><span class="s3">@</span><span class="s1">[ UISheetPresentationControllerDetent.largeDetent ]</span><span class="s3">;</span>
        <span class="s3">if </span><span class="s1">(sheet.selectedDetentIdentifier != UISheetPresentationControllerDetentIdentifierLarge) {</span>
          <span class="s1">[sheet animateChanges:^{</span>
            <span class="s1">sheet.selectedDetentIdentifier = UISheetPresentationControllerDetentIdentifierLarge</span><span class="s3">;</span>
          <span class="s1">}]</span><span class="s3">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(_sheetAllowedDetents == RNSScreenDetentTypeAll) {</span>
        <span class="s1">sheet.detents =</span>
            <span class="s3">@</span><span class="s1">[ UISheetPresentationControllerDetent.mediumDetent</span><span class="s3">, </span><span class="s1">UISheetPresentationControllerDetent.largeDetent ]</span><span class="s3">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">RCTLogError(</span><span class="s3">@</span><span class="s2">&quot;Unhandled value of sheetAllowedDetents passed&quot;</span><span class="s1">)</span><span class="s3">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s0">#endif </span><span class="s4">// Check for max allowed iOS version</span>
<span class="s1">}</span>
<span class="s0">#endif </span><span class="s4">// !TARGET_OS_TV</span>

<span class="s0">#pragma </span><span class="s1">mark - Fabric specific</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>

<span class="s1">+ (facebook::react::ComponentDescriptorProvider)componentDescriptorProvider</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">facebook::react::concreteComponentDescriptorProvider&lt;facebook::react::RNSScreenComponentDescriptor&gt;()</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)mountChildComponentView:(UIView&lt;RCTComponentViewProtocol&gt; *)childComponentView index:(NSInteger)index</span>
<span class="s1">{</span>
  <span class="s1">[super mountChildComponentView:childComponentView index:index]</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">([childComponentView isKindOfClass:[RNSScreenStackHeaderConfig </span><span class="s3">class</span><span class="s1">]]) {</span>
    <span class="s1">_config = childComponentView</span><span class="s3">;</span>
    <span class="s1">((RNSScreenStackHeaderConfig *)childComponentView).screenView = self</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s1">[_reactSubviews insertObject:childComponentView atIndex:index]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)unmountChildComponentView:(UIView&lt;RCTComponentViewProtocol&gt; *)childComponentView index:(NSInteger)index</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">([childComponentView isKindOfClass:[RNSScreenStackHeaderConfig </span><span class="s3">class</span><span class="s1">]]) {</span>
    <span class="s1">_config = nil</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s1">[_reactSubviews removeObject:childComponentView]</span><span class="s3">;</span>
  <span class="s1">[super unmountChildComponentView:childComponentView index:index]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s0">#pragma </span><span class="s1">mark - RCTComponentViewProtocol</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)prepareForRecycle</span>
<span class="s1">{</span>
  <span class="s1">[super prepareForRecycle]</span><span class="s3">;</span>
  <span class="s4">// TODO: Make sure that there is no edge case when this should be uncommented</span>
  <span class="s4">// _controller=nil;</span>
  <span class="s1">_dismissed = NO</span><span class="s3">;</span>
  <span class="s1">_state.reset()</span><span class="s3">;</span>
  <span class="s1">_touchHandler = nil</span><span class="s3">;</span>

  <span class="s4">// We set this prop to default value here to workaround view-recycling.</span>
  <span class="s4">// Let's assume the view has had _stackPresentation == &lt;some modal stack presentation&gt; set</span>
  <span class="s4">// before below line was executed. Then, when instantiated again (with the same modal presentation)</span>
  <span class="s4">// updateProps:oldProps: method would be called and setter for stack presentation would not be called.</span>
  <span class="s4">// This is crucial as in that setter we register `self.controller` as a delegate</span>
  <span class="s4">// (UIAdaptivePresentationControllerDelegate) to presentation controller and this leads to buggy modal behaviour as we</span>
  <span class="s4">// rely on UIAdaptivePresentationControllerDelegate callbacks. Restoring the default value and then comparing against</span>
  <span class="s4">// it in updateProps:oldProps: allows for setter to be called, however if there was some additional logic to execute</span>
  <span class="s4">// when stackPresentation is set to &quot;push&quot; the setter would not be triggered.</span>
  <span class="s1">_stackPresentation = RNSScreenStackPresentationPush</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)updateProps:(facebook::react::Props::Shared </span><span class="s3">const </span><span class="s1">&amp;)props</span>
           <span class="s1">oldProps:(facebook::react::Props::Shared </span><span class="s3">const </span><span class="s1">&amp;)oldProps</span>
<span class="s1">{</span>
  <span class="s3">const auto </span><span class="s1">&amp;oldScreenProps = *std::static_pointer_cast&lt;</span><span class="s3">const </span><span class="s1">facebook::react::RNSScreenProps&gt;(_props)</span><span class="s3">;</span>
  <span class="s3">const auto </span><span class="s1">&amp;newScreenProps = *std::static_pointer_cast&lt;</span><span class="s3">const </span><span class="s1">facebook::react::RNSScreenProps&gt;(props)</span><span class="s3">;</span>

  <span class="s1">[self setFullScreenSwipeEnabled:newScreenProps.fullScreenSwipeEnabled]</span><span class="s3">;</span>

  <span class="s1">[self setGestureEnabled:newScreenProps.gestureEnabled]</span><span class="s3">;</span>

  <span class="s1">[self setTransitionDuration:[NSNumber numberWithInt:newScreenProps.transitionDuration]]</span><span class="s3">;</span>

  <span class="s1">[self setHideKeyboardOnSwipe:newScreenProps.hideKeyboardOnSwipe]</span><span class="s3">;</span>

  <span class="s1">[self setCustomAnimationOnSwipe:newScreenProps.customAnimationOnSwipe]</span><span class="s3">;</span>

  <span class="s1">[self</span>
      <span class="s1">setGestureResponseDistance:[RNSConvert</span>
                                     <span class="s1">gestureResponseDistanceDictFromCppStruct:newScreenProps.gestureResponseDistance]]</span><span class="s3">;</span>

  <span class="s1">[self setPreventNativeDismiss:newScreenProps.preventNativeDismiss]</span><span class="s3">;</span>

  <span class="s1">[self setActivityStateOrNil:[NSNumber numberWithFloat:newScreenProps.activityState]]</span><span class="s3">;</span>

  <span class="s1">[self setSwipeDirection:[RNSConvert RNSScreenSwipeDirectionFromCppEquivalent:newScreenProps.swipeDirection]]</span><span class="s3">;</span>

<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
  <span class="s3">if </span><span class="s1">(newScreenProps.statusBarHidden != oldScreenProps.statusBarHidden) {</span>
    <span class="s1">[self setStatusBarHidden:newScreenProps.statusBarHidden]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(newScreenProps.statusBarStyle != oldScreenProps.statusBarStyle) {</span>
    <span class="s1">[self setStatusBarStyle:[RCTConvert</span>
                                <span class="s1">RNSStatusBarStyle:RCTNSStringFromStringNilIfEmpty(newScreenProps.statusBarStyle)]]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(newScreenProps.statusBarAnimation != oldScreenProps.statusBarAnimation) {</span>
    <span class="s1">[self setStatusBarAnimation:[RCTConvert UIStatusBarAnimation:RCTNSStringFromStringNilIfEmpty(</span>
                                                                     <span class="s1">newScreenProps.statusBarAnimation)]]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(newScreenProps.screenOrientation != oldScreenProps.screenOrientation) {</span>
    <span class="s1">[self setScreenOrientation:[RCTConvert UIInterfaceOrientationMask:RCTNSStringFromStringNilIfEmpty(</span>
                                                                          <span class="s1">newScreenProps.screenOrientation)]]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(newScreenProps.homeIndicatorHidden != oldScreenProps.homeIndicatorHidden) {</span>
    <span class="s1">[self setHomeIndicatorHidden:newScreenProps.homeIndicatorHidden]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s1">[self setSheetGrabberVisible:newScreenProps.sheetGrabberVisible]</span><span class="s3">;</span>
  <span class="s1">[self setSheetCornerRadius:newScreenProps.sheetCornerRadius]</span><span class="s3">;</span>
  <span class="s1">[self setSheetExpandsWhenScrolledToEdge:newScreenProps.sheetExpandsWhenScrolledToEdge]</span><span class="s3">;</span>

  <span class="s3">if </span><span class="s1">(newScreenProps.sheetAllowedDetents != oldScreenProps.sheetAllowedDetents) {</span>
    <span class="s1">[self setSheetAllowedDetents:[RNSConvert RNSScreenDetentTypeFromAllowedDetents:newScreenProps.sheetAllowedDetents]]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(newScreenProps.sheetLargestUndimmedDetent != oldScreenProps.sheetLargestUndimmedDetent) {</span>
    <span class="s1">[self setSheetLargestUndimmedDetent:</span>
              <span class="s1">[RNSConvert RNSScreenDetentTypeFromLargestUndimmedDetent:newScreenProps.sheetLargestUndimmedDetent]]</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#endif </span><span class="s4">// !TARGET_OS_TV</span>

  <span class="s4">// Notice that we compare against _stackPresentation, not oldScreenProps.stackPresentation.</span>
  <span class="s4">// See comment in prepareForRecycle method for explanation.</span>
  <span class="s1">RNSScreenStackPresentation newStackPresentation =</span>
      <span class="s1">[RNSConvert RNSScreenStackPresentationFromCppEquivalent:newScreenProps.stackPresentation]</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">(newStackPresentation != _stackPresentation) {</span>
    <span class="s1">[self setStackPresentation:newStackPresentation]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(newScreenProps.stackAnimation != oldScreenProps.stackAnimation) {</span>
    <span class="s1">[self setStackAnimation:[RNSConvert RNSScreenStackAnimationFromCppEquivalent:newScreenProps.stackAnimation]]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(newScreenProps.replaceAnimation != oldScreenProps.replaceAnimation) {</span>
    <span class="s1">[self setReplaceAnimation:[RNSConvert RNSScreenReplaceAnimationFromCppEquivalent:newScreenProps.replaceAnimation]]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s1">[super updateProps:props oldProps:oldProps]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)updateState:(facebook::react::State::Shared </span><span class="s3">const </span><span class="s1">&amp;)state</span>
           <span class="s1">oldState:(facebook::react::State::Shared </span><span class="s3">const </span><span class="s1">&amp;)oldState</span>
<span class="s1">{</span>
  <span class="s1">_state = std::static_pointer_cast&lt;</span><span class="s3">const </span><span class="s1">facebook::react::RNSScreenShadowNode::ConcreteState&gt;(state)</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)updateLayoutMetrics:(</span><span class="s3">const </span><span class="s1">facebook::react::LayoutMetrics &amp;)layoutMetrics</span>
           <span class="s1">oldLayoutMetrics:(</span><span class="s3">const </span><span class="s1">facebook::react::LayoutMetrics &amp;)oldLayoutMetrics</span>
<span class="s1">{</span>
  <span class="s1">_newLayoutMetrics = layoutMetrics</span><span class="s3">;</span>
  <span class="s1">_oldLayoutMetrics = oldLayoutMetrics</span><span class="s3">;</span>
  <span class="s1">UIViewController *parentVC = self.reactViewController.parentViewController</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">(parentVC != nil &amp;&amp; ![parentVC isKindOfClass:[RNScreensNavigationController </span><span class="s3">class</span><span class="s1">]]) {</span>
    <span class="s1">[super updateLayoutMetrics:layoutMetrics oldLayoutMetrics:oldLayoutMetrics]</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s4">// when screen is mounted under RNScreensNavigationController it's size is controller</span>
  <span class="s4">// by the navigation controller itself. That is, it is set to fill space of</span>
  <span class="s4">// the controller. In that case we ignore react layout system from managing</span>
  <span class="s4">// the screen dimensions and we wait for the screen VC to update and then we</span>
  <span class="s4">// pass the dimensions to ui view manager to take into account when laying out</span>
  <span class="s4">// subviews</span>
  <span class="s4">// Explanation taken from `reactSetFrame`, which is old arch equivalent of this code.</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)finalizeUpdates:(RNComponentViewUpdateMask)updateMask</span>
<span class="s1">{</span>
<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
  <span class="s1">[self updatePresentationStyle]</span><span class="s3">;</span>
<span class="s0">#endif </span><span class="s4">// !TARGET_OS_TV</span>
<span class="s1">}</span>

<span class="s0">#pragma </span><span class="s1">mark - Paper specific</span>
<span class="s0">#else</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)didSetProps:(NSArray&lt;NSString *&gt; *)changedProps</span>
<span class="s1">{</span>
  <span class="s1">[super didSetProps:changedProps]</span><span class="s3">;</span>
<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
  <span class="s1">[self updatePresentationStyle]</span><span class="s3">;</span>
<span class="s0">#endif </span><span class="s4">// !TARGET_OS_TV</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)setPointerEvents:(RCTPointerEvents)pointerEvents</span>
<span class="s1">{</span>
  <span class="s4">// pointer events settings are managed by the parent screen container, we ignore</span>
  <span class="s4">// any attempt of setting that via React props</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)reactSetFrame:(CGRect)frame</span>
<span class="s1">{</span>
  <span class="s1">_reactFrame = frame</span><span class="s3">;</span>
  <span class="s1">UIViewController *parentVC = self.reactViewController.parentViewController</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">(parentVC != nil &amp;&amp; ![parentVC isKindOfClass:[RNScreensNavigationController </span><span class="s3">class</span><span class="s1">]]) {</span>
    <span class="s1">[super reactSetFrame:frame]</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s4">// when screen is mounted under RNScreensNavigationController it's size is controller</span>
  <span class="s4">// by the navigation controller itself. That is, it is set to fill space of</span>
  <span class="s4">// the controller. In that case we ignore react layout system from managing</span>
  <span class="s4">// the screen dimensions and we wait for the screen VC to update and then we</span>
  <span class="s4">// pass the dimensions to ui view manager to take into account when laying out</span>
  <span class="s4">// subviews</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)invalidate</span>
<span class="s1">{</span>
  <span class="s1">_controller = nil</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">#endif</span>

<span class="s3">@end</span>

<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s1">Class&lt;RCTComponentViewProtocol&gt; RNSScreenCls(</span><span class="s3">void</span><span class="s1">)</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">RNSScreenView.</span><span class="s3">class;</span>
<span class="s1">}</span>
<span class="s0">#endif</span>

<span class="s0">#pragma </span><span class="s1">mark - RNSScreen</span>

<span class="s3">@implementation </span><span class="s1">RNSScreen {</span>
  <span class="s3">__weak </span><span class="s1">id _previousFirstResponder</span><span class="s3">;</span>
  <span class="s1">CGRect _lastViewFrame</span><span class="s3">;</span>
  <span class="s1">RNSScreenView *_initialView</span><span class="s3">;</span>
  <span class="s1">UIView *_fakeView</span><span class="s3">;</span>
  <span class="s1">CADisplayLink *_animationTimer</span><span class="s3">;</span>
  <span class="s1">CGFloat _currentAlpha</span><span class="s3">;</span>
  <span class="s1">BOOL _closing</span><span class="s3">;</span>
  <span class="s1">BOOL _goingForward</span><span class="s3">;</span>
  <span class="s3">int </span><span class="s1">_dismissCount</span><span class="s3">;</span>
  <span class="s1">BOOL _isSwiping</span><span class="s3">;</span>
  <span class="s1">BOOL _shouldNotify</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s0">#pragma </span><span class="s1">mark - Common</span>

<span class="s1">- (instancetype)initWithView:(UIView *)view</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(self = [super init]) {</span>
    <span class="s1">self.view = view</span><span class="s3">;</span>
    <span class="s1">_fakeView = [UIView </span><span class="s3">new</span><span class="s1">]</span><span class="s3">;</span>
    <span class="s1">_shouldNotify = YES</span><span class="s3">;</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
    <span class="s1">_initialView = (RNSScreenView *)view</span><span class="s3">;</span>
<span class="s0">#endif</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">self</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s4">// TODO: Find out why this is executed when screen is going out</span>
<span class="s1">- (</span><span class="s3">void</span><span class="s1">)viewWillAppear:(BOOL)animated</span>
<span class="s1">{</span>
  <span class="s1">[super viewWillAppear:animated]</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">(!_isSwiping) {</span>
    <span class="s1">[self.screenView notifyWillAppear]</span><span class="s3">;</span>
    <span class="s3">if </span><span class="s1">(self.transitionCoordinator.isInteractive) {</span>
      <span class="s4">// we started dismissing with swipe gesture</span>
      <span class="s1">_isSwiping = YES</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s4">// this event is also triggered if we cancelled the swipe.</span>
    <span class="s4">// The _isSwiping is still true, but we don't want to notify then</span>
    <span class="s1">_shouldNotify = NO</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s1">[self hideHeaderIfNecessary]</span><span class="s3">;</span>
  <span class="s4">// as per documentation of these methods</span>
  <span class="s1">_goingForward = [self isBeingPresented] || [self isMovingToParentViewController]</span><span class="s3">;</span>

  <span class="s1">[RNSScreenWindowTraits updateWindowTraits]</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">(_shouldNotify) {</span>
    <span class="s1">_closing = NO</span><span class="s3">;</span>
    <span class="s1">[self notifyTransitionProgress:</span><span class="s5">0.0 </span><span class="s1">closing:_closing goingForward:_goingForward]</span><span class="s3">;</span>
    <span class="s1">[self setupProgressNotification]</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)viewWillDisappear:(BOOL)animated</span>
<span class="s1">{</span>
  <span class="s1">[super viewWillDisappear:animated]</span><span class="s3">;</span>
  <span class="s4">// self.navigationController might be null when we are dismissing a modal</span>
  <span class="s3">if </span><span class="s1">(!self.transitionCoordinator.isInteractive &amp;&amp; self.navigationController != nil) {</span>
    <span class="s4">// user might have long pressed ios 14 back button item,</span>
    <span class="s4">// so he can go back more than one screen and we need to dismiss more screens in JS stack then.</span>
    <span class="s4">// We check it by calculating the difference between the index of currently displayed screen</span>
    <span class="s4">// and the index of the target screen, which is the view of topViewController at this point.</span>
    <span class="s4">// If the value is lower than 1, it means we are dismissing a modal, or navigating forward, or going back with JS.</span>
    <span class="s3">int </span><span class="s1">selfIndex = [self getIndexOfView:self.screenView]</span><span class="s3">;</span>
    <span class="s3">int </span><span class="s1">targetIndex = [self getIndexOfView:self.navigationController.topViewController.view]</span><span class="s3">;</span>
    <span class="s1">_dismissCount = selfIndex - targetIndex &gt; </span><span class="s5">0 </span><span class="s1">? selfIndex - targetIndex : </span><span class="s5">1</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">_dismissCount = </span><span class="s5">1</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s4">// same flow as in viewWillAppear</span>
  <span class="s3">if </span><span class="s1">(!_isSwiping) {</span>
    <span class="s1">[self.screenView notifyWillDisappear]</span><span class="s3">;</span>
    <span class="s3">if </span><span class="s1">(self.transitionCoordinator.isInteractive) {</span>
      <span class="s1">_isSwiping = YES</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">_shouldNotify = NO</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s4">// as per documentation of these methods</span>
  <span class="s1">_goingForward = !([self isBeingDismissed] || [self isMovingFromParentViewController])</span><span class="s3">;</span>

  <span class="s3">if </span><span class="s1">(_shouldNotify) {</span>
    <span class="s1">_closing = YES</span><span class="s3">;</span>
    <span class="s1">[self notifyTransitionProgress:</span><span class="s5">0.0 </span><span class="s1">closing:_closing goingForward:_goingForward]</span><span class="s3">;</span>
    <span class="s1">[self setupProgressNotification]</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)viewDidAppear:(BOOL)animated</span>
<span class="s1">{</span>
  <span class="s1">[super viewDidAppear:animated]</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">(!_isSwiping || _shouldNotify) {</span>
    <span class="s4">// we are going forward or dismissing without swipe</span>
    <span class="s4">// or successfully swiped back</span>
    <span class="s1">[self.screenView notifyAppear]</span><span class="s3">;</span>
    <span class="s1">[self notifyTransitionProgress:</span><span class="s5">1.0 </span><span class="s1">closing:NO goingForward:_goingForward]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s1">_isSwiping = NO</span><span class="s3">;</span>
  <span class="s1">_shouldNotify = YES</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)viewDidDisappear:(BOOL)animated</span>
<span class="s1">{</span>
  <span class="s1">[super viewDidDisappear:animated]</span><span class="s3">;</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s1">[self resetViewToScreen]</span><span class="s3">;</span>
<span class="s0">#endif</span>
  <span class="s3">if </span><span class="s1">(self.parentViewController == nil &amp;&amp; self.presentingViewController == nil) {</span>
    <span class="s3">if </span><span class="s1">(self.screenView.preventNativeDismiss) {</span>
      <span class="s4">// if we want to prevent the native dismiss, we do not send dismissal event,</span>
      <span class="s4">// but instead call `updateContainer`, which restores the JS navigation stack</span>
      <span class="s1">[self.screenView.reactSuperview updateContainer]</span><span class="s3">;</span>
      <span class="s1">[self.screenView notifyDismissCancelledWithDismissCount:_dismissCount]</span><span class="s3">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s4">// screen dismissed, send event</span>
      <span class="s1">[self.screenView notifyDismissedWithCount:_dismissCount]</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s4">// same flow as in viewDidAppear</span>
  <span class="s3">if </span><span class="s1">(!_isSwiping || _shouldNotify) {</span>
    <span class="s1">[self.screenView notifyDisappear]</span><span class="s3">;</span>
    <span class="s1">[self notifyTransitionProgress:</span><span class="s5">1.0 </span><span class="s1">closing:YES goingForward:_goingForward]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s1">_isSwiping = NO</span><span class="s3">;</span>
  <span class="s1">_shouldNotify = YES</span><span class="s3">;</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s0">#else</span>
  <span class="s1">[self traverseForScrollView:self.screenView]</span><span class="s3">;</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)viewDidLayoutSubviews</span>
<span class="s1">{</span>
  <span class="s1">[super viewDidLayoutSubviews]</span><span class="s3">;</span>

  <span class="s4">// The below code makes the screen view adapt dimensions provided by the system. We take these</span>
  <span class="s4">// into account only when the view is mounted under RNScreensNavigationController in which case system</span>
  <span class="s4">// provides additional padding to account for possible header, and in the case when screen is</span>
  <span class="s4">// shown as a native modal, as the final dimensions of the modal on iOS 12+ are shorter than the</span>
  <span class="s4">// screen size</span>
  <span class="s1">BOOL isDisplayedWithinUINavController =</span>
      <span class="s1">[self.parentViewController isKindOfClass:[RNScreensNavigationController </span><span class="s3">class</span><span class="s1">]]</span><span class="s3">;</span>
  <span class="s1">BOOL isPresentedAsNativeModal = self.parentViewController == nil &amp;&amp; self.presentingViewController != nil</span><span class="s3">;</span>

  <span class="s3">if </span><span class="s1">(isDisplayedWithinUINavController || isPresentedAsNativeModal) {</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
    <span class="s1">[self.screenView updateBounds]</span><span class="s3">;</span>
<span class="s0">#else</span>
    <span class="s3">if </span><span class="s1">(!CGRectEqualToRect(_lastViewFrame</span><span class="s3">, </span><span class="s1">self.screenView.frame)) {</span>
      <span class="s1">_lastViewFrame = self.screenView.frame</span><span class="s3">;</span>
      <span class="s1">[((RNSScreenView *)self.viewIfLoaded) updateBounds]</span><span class="s3">;</span>
    <span class="s1">}</span>
<span class="s0">#endif</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)notifyFinishTransitioning</span>
<span class="s1">{</span>
  <span class="s1">[_previousFirstResponder becomeFirstResponder]</span><span class="s3">;</span>
  <span class="s1">_previousFirstResponder = nil</span><span class="s3">;</span>
  <span class="s4">// the correct Screen for appearance is set after the transition, same for orientation.</span>
  <span class="s1">[RNSScreenWindowTraits updateWindowTraits]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)willMoveToParentViewController:(UIViewController *)parent</span>
<span class="s1">{</span>
  <span class="s1">[super willMoveToParentViewController:parent]</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">(parent == nil) {</span>
    <span class="s1">id responder = [self findFirstResponder:self.screenView]</span><span class="s3">;</span>
    <span class="s3">if </span><span class="s1">(responder != nil) {</span>
      <span class="s1">_previousFirstResponder = responder</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (id)findFirstResponder:(UIView *)parent</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(parent.isFirstResponder) {</span>
    <span class="s3">return </span><span class="s1">parent</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s3">for </span><span class="s1">(UIView *subView in parent.subviews) {</span>
    <span class="s1">id responder = [self findFirstResponder:subView]</span><span class="s3">;</span>
    <span class="s3">if </span><span class="s1">(responder != nil) {</span>
      <span class="s3">return </span><span class="s1">responder</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">nil</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s0">#pragma </span><span class="s1">mark - transition progress related methods</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)setupProgressNotification</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(self.transitionCoordinator != nil) {</span>
    <span class="s1">_fakeView.alpha = </span><span class="s5">0.0</span><span class="s3">;</span>
    <span class="s1">[self.transitionCoordinator</span>
        <span class="s1">animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; </span><span class="s3">_Nonnull </span><span class="s1">context) {</span>
          <span class="s1">[[context containerView] addSubview:self-&gt;_fakeView]</span><span class="s3">;</span>
          <span class="s1">self-&gt;_fakeView.alpha = </span><span class="s5">1.0</span><span class="s3">;</span>
          <span class="s1">self-&gt;_animationTimer = [CADisplayLink displayLinkWithTarget:self </span><span class="s3">selector</span><span class="s1">:</span><span class="s3">@selector</span><span class="s1">(handleAnimation)]</span><span class="s3">;</span>
          <span class="s1">[self-&gt;_animationTimer addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode]</span><span class="s3">;</span>
        <span class="s1">}</span>
        <span class="s1">completion:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; </span><span class="s3">_Nonnull </span><span class="s1">context) {</span>
          <span class="s1">[self-&gt;_animationTimer setPaused:YES]</span><span class="s3">;</span>
          <span class="s1">[self-&gt;_animationTimer invalidate]</span><span class="s3">;</span>
          <span class="s1">[self-&gt;_fakeView removeFromSuperview]</span><span class="s3">;</span>
        <span class="s1">}]</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)handleAnimation</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">([[_fakeView layer] presentationLayer] != nil) {</span>
    <span class="s1">CGFloat fakeViewAlpha = _fakeView.layer.presentationLayer.opacity</span><span class="s3">;</span>
    <span class="s3">if </span><span class="s1">(_currentAlpha != fakeViewAlpha) {</span>
      <span class="s1">_currentAlpha = fmax(</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">fmin(</span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">fakeViewAlpha))</span><span class="s3">;</span>
      <span class="s1">[self notifyTransitionProgress:_currentAlpha closing:_closing goingForward:_goingForward]</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)notifyTransitionProgress:(</span><span class="s3">double</span><span class="s1">)progress closing:(BOOL)closing goingForward:(BOOL)goingForward</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">([self.view isKindOfClass:[RNSScreenView </span><span class="s3">class</span><span class="s1">]]) {</span>
    <span class="s4">// if the view is already snapshot, there is not sense in sending progress since on JS side</span>
    <span class="s4">// the component is already not present</span>
    <span class="s1">[(RNSScreenView *)self.view notifyTransitionProgress:progress closing:closing goingForward:goingForward]</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
<span class="s4">// if the returned vc is a child, it means that it can provide config;</span>
<span class="s4">// if the returned vc is self, it means that there is no child for config and self has config to provide,</span>
<span class="s4">// so we return self which results in asking self for preferredStatusBarStyle/Animation etc.;</span>
<span class="s4">// if the returned vc is nil, it means none of children could provide config and self does not have config either,</span>
<span class="s4">// so if it was asked by parent, it will fallback to parent's option, or use default option if it is the top Screen</span>
<span class="s1">- (UIViewController *)findChildVCForConfigAndTrait:(RNSWindowTrait)trait includingModals:(BOOL)includingModals</span>
<span class="s1">{</span>
  <span class="s1">UIViewController *lastViewController = [[self childViewControllers] lastObject]</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">([self.presentedViewController isKindOfClass:[RNSScreen </span><span class="s3">class</span><span class="s1">]]) {</span>
    <span class="s1">lastViewController = self.presentedViewController</span><span class="s3">;</span>
    <span class="s4">// we don't want to allow controlling of status bar appearance when we present non-fullScreen modal</span>
    <span class="s4">// and it is not possible if `modalPresentationCapturesStatusBarAppearance` is not set to YES, so even</span>
    <span class="s4">// if we went into a modal here and ask it, it wouldn't take any effect. For fullScreen modals, the system</span>
    <span class="s4">// asks them by itself, so we can stop traversing here.</span>
    <span class="s4">// for screen orientation, we need to start the search again from that modal</span>
    <span class="s3">return </span><span class="s1">!includingModals</span>
        <span class="s1">? nil</span>
        <span class="s1">: [(RNSScreen *)lastViewController findChildVCForConfigAndTrait:trait includingModals:includingModals]</span>
            <span class="s1">?: lastViewController</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s1">UIViewController *selfOrNil = [self hasTraitSet:trait] ? self : nil</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">(lastViewController == nil) {</span>
    <span class="s3">return </span><span class="s1">selfOrNil</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">([lastViewController conformsToProtocol:</span><span class="s3">@protocol</span><span class="s1">(RNScreensViewControllerDelegate)]) {</span>
      <span class="s4">// If there is a child (should be VC of ScreenContainer or ScreenStack), that has a child that could provide the</span>
      <span class="s4">// trait, we recursively go into its findChildVCForConfig, and if one of the children has the trait set, we return</span>
      <span class="s4">// it, otherwise we return self if this VC has config, and nil if it doesn't we use</span>
      <span class="s4">// `childViewControllerForStatusBarStyle` for all options since the behavior is the same for all of them</span>
      <span class="s1">UIViewController *childScreen = [lastViewController childViewControllerForStatusBarStyle]</span><span class="s3">;</span>
      <span class="s3">if </span><span class="s1">([childScreen isKindOfClass:[RNSScreen </span><span class="s3">class</span><span class="s1">]]) {</span>
        <span class="s3">return </span><span class="s1">[(RNSScreen *)childScreen findChildVCForConfigAndTrait:trait includingModals:includingModals]</span>
            <span class="s1">?: selfOrNil</span><span class="s3">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">selfOrNil</span><span class="s3">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s4">// child vc is not from this library, so we don't ask it</span>
      <span class="s3">return </span><span class="s1">selfOrNil</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)hasTraitSet:(RNSWindowTrait)trait</span>
<span class="s1">{</span>
  <span class="s3">switch </span><span class="s1">(trait) {</span>
    <span class="s3">case </span><span class="s1">RNSWindowTraitStyle: {</span>
      <span class="s3">return </span><span class="s1">self.screenView.hasStatusBarStyleSet</span><span class="s3">;</span>
    <span class="s1">}</span>
    <span class="s3">case </span><span class="s1">RNSWindowTraitAnimation: {</span>
      <span class="s3">return </span><span class="s1">self.screenView.hasStatusBarAnimationSet</span><span class="s3">;</span>
    <span class="s1">}</span>
    <span class="s3">case </span><span class="s1">RNSWindowTraitHidden: {</span>
      <span class="s3">return </span><span class="s1">self.screenView.hasStatusBarHiddenSet</span><span class="s3">;</span>
    <span class="s1">}</span>
    <span class="s3">case </span><span class="s1">RNSWindowTraitOrientation: {</span>
      <span class="s3">return </span><span class="s1">self.screenView.hasOrientationSet</span><span class="s3">;</span>
    <span class="s1">}</span>
    <span class="s3">case </span><span class="s1">RNSWindowTraitHomeIndicatorHidden: {</span>
      <span class="s3">return </span><span class="s1">self.screenView.hasHomeIndicatorHiddenSet</span><span class="s3">;</span>
    <span class="s1">}</span>
    <span class="s3">default</span><span class="s1">: {</span>
      <span class="s1">RCTLogError(</span><span class="s3">@</span><span class="s2">&quot;Unknown trait passed: %d&quot;</span><span class="s3">, </span><span class="s1">(</span><span class="s3">int</span><span class="s1">)trait)</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">NO</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (UIViewController *)childViewControllerForStatusBarHidden</span>
<span class="s1">{</span>
  <span class="s1">UIViewController *vc = [self findChildVCForConfigAndTrait:RNSWindowTraitHidden includingModals:NO]</span><span class="s3">;</span>
  <span class="s3">return </span><span class="s1">vc == self ? nil : vc</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)prefersStatusBarHidden</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">self.screenView.statusBarHidden</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (UIViewController *)childViewControllerForStatusBarStyle</span>
<span class="s1">{</span>
  <span class="s1">UIViewController *vc = [self findChildVCForConfigAndTrait:RNSWindowTraitStyle includingModals:NO]</span><span class="s3">;</span>
  <span class="s3">return </span><span class="s1">vc == self ? nil : vc</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (UIStatusBarStyle)preferredStatusBarStyle</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">[RNSScreenWindowTraits statusBarStyleForRNSStatusBarStyle:self.screenView.statusBarStyle]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (UIStatusBarAnimation)preferredStatusBarUpdateAnimation</span>
<span class="s1">{</span>
  <span class="s1">UIViewController *vc = [self findChildVCForConfigAndTrait:RNSWindowTraitAnimation includingModals:NO]</span><span class="s3">;</span>

  <span class="s3">if </span><span class="s1">([vc isKindOfClass:[RNSScreen </span><span class="s3">class</span><span class="s1">]]) {</span>
    <span class="s3">return </span><span class="s1">((RNSScreen *)vc).screenView.statusBarAnimation</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">UIStatusBarAnimationFade</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (UIInterfaceOrientationMask)supportedInterfaceOrientations</span>
<span class="s1">{</span>
  <span class="s1">UIViewController *vc = [self findChildVCForConfigAndTrait:RNSWindowTraitOrientation includingModals:YES]</span><span class="s3">;</span>

  <span class="s3">if </span><span class="s1">([vc isKindOfClass:[RNSScreen </span><span class="s3">class</span><span class="s1">]]) {</span>
    <span class="s3">return </span><span class="s1">((RNSScreen *)vc).screenView.screenOrientation</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">UIInterfaceOrientationMaskAllButUpsideDown</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (UIViewController *)childViewControllerForHomeIndicatorAutoHidden</span>
<span class="s1">{</span>
  <span class="s1">UIViewController *vc = [self findChildVCForConfigAndTrait:RNSWindowTraitHomeIndicatorHidden includingModals:YES]</span><span class="s3">;</span>
  <span class="s3">return </span><span class="s1">vc == self ? nil : vc</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)prefersHomeIndicatorAutoHidden</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">self.screenView.homeIndicatorHidden</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s1">- (</span><span class="s3">int</span><span class="s1">)getParentChildrenCount</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">(</span><span class="s3">int</span><span class="s1">)[[self.screenView.reactSuperview reactSubviews] count]</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">#endif</span>

<span class="s1">- (</span><span class="s3">int</span><span class="s1">)getIndexOfView:(UIView *)view</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">(</span><span class="s3">int</span><span class="s1">)[[self.screenView.reactSuperview reactSubviews] indexOfObject:view]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s4">// since on Fabric the view of controller can be a snapshot of type `UIView`,</span>
<span class="s4">// when we want to check props of ScreenView, we need to get them from _initialView</span>
<span class="s1">- (RNSScreenView *)screenView</span>
<span class="s1">{</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s3">return </span><span class="s1">_initialView</span><span class="s3">;</span>
<span class="s0">#else</span>
  <span class="s3">return </span><span class="s1">(RNSScreenView *)self.view</span><span class="s3">;</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)hideHeaderIfNecessary</span>
<span class="s1">{</span>
<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
  <span class="s4">// On iOS &gt;=13, there is a bug when user transitions from screen with active search bar to screen without header</span>
  <span class="s4">// In that case default iOS header will be shown. To fix this we hide header when the screens that appears has header</span>
  <span class="s4">// hidden and search bar was active on previous screen. We need to do it asynchronously, because default header is</span>
  <span class="s4">// added after viewWillAppear.</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">@available</span><span class="s1">(iOS </span><span class="s5">13.0</span><span class="s3">, </span><span class="s1">*)) {</span>
    <span class="s1">NSUInteger currentIndex = [self.navigationController.viewControllers indexOfObject:self]</span><span class="s3">;</span>

    <span class="s4">// we need to check whether reactSubviews array is empty, because on Fabric child nodes are unmounted first -&gt;</span>
    <span class="s4">// reactSubviews array may be empty</span>
    <span class="s3">if </span><span class="s1">(currentIndex &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; [self.screenView.reactSubviews count] &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp;</span>
        <span class="s1">[self.screenView.reactSubviews[</span><span class="s5">0</span><span class="s1">] isKindOfClass:[RNSScreenStackHeaderConfig </span><span class="s3">class</span><span class="s1">]]) {</span>
      <span class="s1">UINavigationItem *prevNavigationItem =</span>
          <span class="s1">[self.navigationController.viewControllers objectAtIndex:currentIndex - </span><span class="s5">1</span><span class="s1">].navigationItem</span><span class="s3">;</span>
      <span class="s1">RNSScreenStackHeaderConfig *config = ((RNSScreenStackHeaderConfig *)self.screenView.reactSubviews[</span><span class="s5">0</span><span class="s1">])</span><span class="s3">;</span>

      <span class="s1">BOOL wasSearchBarActive = prevNavigationItem.searchController.active</span><span class="s3">;</span>

<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
      <span class="s1">BOOL shouldHideHeader = !config.show</span><span class="s3">;</span>
<span class="s0">#else</span>
      <span class="s1">BOOL shouldHideHeader = config.hide</span><span class="s3">;</span>
<span class="s0">#endif</span>

      <span class="s3">if </span><span class="s1">(wasSearchBarActive &amp;&amp; shouldHideHeader) {</span>
        <span class="s1">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">;</span>
        <span class="s1">dispatch_after(popTime</span><span class="s3">, </span><span class="s1">dispatch_get_main_queue()</span><span class="s3">, </span><span class="s1">^(</span><span class="s3">void</span><span class="s1">) {</span>
          <span class="s1">[self.navigationController setNavigationBarHidden:YES animated:NO]</span><span class="s3">;</span>
        <span class="s1">})</span><span class="s3">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s0">#pragma </span><span class="s1">mark - Fabric specific</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)setViewToSnapshot:(UIView *)snapshot</span>
<span class="s1">{</span>
  <span class="s4">// modals of native stack seem not to support</span>
  <span class="s4">// changing their view by just setting the view</span>
  <span class="s3">if </span><span class="s1">(_initialView.stackPresentation != RNSScreenStackPresentationPush) {</span>
    <span class="s1">UIView *superView = self.view.superview</span><span class="s3">;</span>
    <span class="s1">[self.view removeFromSuperview]</span><span class="s3">;</span>
    <span class="s1">self.view = snapshot</span><span class="s3">;</span>
    <span class="s1">[superView addSubview:self.view]</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">[self.view removeFromSuperview]</span><span class="s3">;</span>
    <span class="s1">self.view = snapshot</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)resetViewToScreen</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(self.view != _initialView) {</span>
    <span class="s1">[self.view removeFromSuperview]</span><span class="s3">;</span>
    <span class="s1">self.view = _initialView</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">#else</span>
<span class="s0">#pragma </span><span class="s1">mark - Paper specific</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)traverseForScrollView:(UIView *)view</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(![[self.view valueForKey:</span><span class="s3">@</span><span class="s2">&quot;_bridge&quot;</span><span class="s1">] valueForKey:</span><span class="s3">@</span><span class="s2">&quot;_jsThread&quot;</span><span class="s1">]) {</span>
    <span class="s4">// we don't want to send `scrollViewDidEndDecelerating` event to JS before the JS thread is ready</span>
    <span class="s3">return;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">([view isKindOfClass:[UIScrollView </span><span class="s3">class</span><span class="s1">]] &amp;&amp;</span>
      <span class="s1">([[(UIScrollView *)view delegate] respondsToSelector:</span><span class="s3">@selector</span><span class="s1">(scrollViewDidEndDecelerating:)])) {</span>
    <span class="s1">[[(UIScrollView *)view delegate] scrollViewDidEndDecelerating:(id)view]</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s1">[view.subviews enumerateObjectsUsingBlock:^(</span><span class="s3">__kindof </span><span class="s1">UIView *</span><span class="s3">_Nonnull </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">NSUInteger idx</span><span class="s3">, </span><span class="s1">BOOL *</span><span class="s3">_Nonnull </span><span class="s1">stop) {</span>
    <span class="s1">[self traverseForScrollView:obj]</span><span class="s3">;</span>
  <span class="s1">}]</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">#endif</span>

<span class="s3">@end</span>

<span class="s3">@implementation </span><span class="s1">RNSScreenManager</span>

<span class="s1">RCT_EXPORT_MODULE()</span>

<span class="s4">// we want to handle the case when activityState is nil</span>
<span class="s1">RCT_REMAP_VIEW_PROPERTY(activityState</span><span class="s3">, </span><span class="s1">activityStateOrNil</span><span class="s3">, </span><span class="s1">NSNumber)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(customAnimationOnSwipe</span><span class="s3">, </span><span class="s1">BOOL)</span><span class="s3">;</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(fullScreenSwipeEnabled</span><span class="s3">, </span><span class="s1">BOOL)</span><span class="s3">;</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(gestureEnabled</span><span class="s3">, </span><span class="s1">BOOL)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(gestureResponseDistance</span><span class="s3">, </span><span class="s1">NSDictionary)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(hideKeyboardOnSwipe</span><span class="s3">, </span><span class="s1">BOOL)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(preventNativeDismiss</span><span class="s3">, </span><span class="s1">BOOL)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(replaceAnimation</span><span class="s3">, </span><span class="s1">RNSScreenReplaceAnimation)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(stackPresentation</span><span class="s3">, </span><span class="s1">RNSScreenStackPresentation)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(stackAnimation</span><span class="s3">, </span><span class="s1">RNSScreenStackAnimation)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(swipeDirection</span><span class="s3">, </span><span class="s1">RNSScreenSwipeDirection)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(transitionDuration</span><span class="s3">, </span><span class="s1">NSNumber)</span>

<span class="s1">RCT_EXPORT_VIEW_PROPERTY(onAppear</span><span class="s3">, </span><span class="s1">RCTDirectEventBlock)</span><span class="s3">;</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(onDisappear</span><span class="s3">, </span><span class="s1">RCTDirectEventBlock)</span><span class="s3">;</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(onDismissed</span><span class="s3">, </span><span class="s1">RCTDirectEventBlock)</span><span class="s3">;</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(onNativeDismissCancelled</span><span class="s3">, </span><span class="s1">RCTDirectEventBlock)</span><span class="s3">;</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(onTransitionProgress</span><span class="s3">, </span><span class="s1">RCTDirectEventBlock)</span><span class="s3">;</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(onWillAppear</span><span class="s3">, </span><span class="s1">RCTDirectEventBlock)</span><span class="s3">;</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(onWillDisappear</span><span class="s3">, </span><span class="s1">RCTDirectEventBlock)</span><span class="s3">;</span>

<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(screenOrientation</span><span class="s3">, </span><span class="s1">UIInterfaceOrientationMask)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(statusBarAnimation</span><span class="s3">, </span><span class="s1">UIStatusBarAnimation)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(statusBarHidden</span><span class="s3">, </span><span class="s1">BOOL)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(statusBarStyle</span><span class="s3">, </span><span class="s1">RNSStatusBarStyle)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(homeIndicatorHidden</span><span class="s3">, </span><span class="s1">BOOL)</span>

<span class="s1">RCT_EXPORT_VIEW_PROPERTY(sheetAllowedDetents</span><span class="s3">, </span><span class="s1">RNSScreenDetentType)</span><span class="s3">;</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(sheetLargestUndimmedDetent</span><span class="s3">, </span><span class="s1">RNSScreenDetentType)</span><span class="s3">;</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(sheetGrabberVisible</span><span class="s3">, </span><span class="s1">BOOL)</span><span class="s3">;</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(sheetCornerRadius</span><span class="s3">, </span><span class="s1">CGFloat)</span><span class="s3">;</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(sheetExpandsWhenScrolledToEdge</span><span class="s3">, </span><span class="s1">BOOL)</span><span class="s3">;</span>
<span class="s0">#endif</span>

<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
<span class="s4">// See:</span>
<span class="s4">// 1. https://github.com/software-mansion/react-native-screens/pull/1543</span>
<span class="s4">// 2. https://github.com/software-mansion/react-native-screens/pull/1596</span>
<span class="s4">// This class is instatiated from React Native's internals during application startup</span>
<span class="s1">- (instancetype)init</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(self = [super init]) {</span>
    <span class="s1">dispatch_async(dispatch_get_main_queue()</span><span class="s3">, </span><span class="s1">^{</span>
      <span class="s1">[[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications]</span><span class="s3">;</span>
    <span class="s1">})</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">self</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)dealloc</span>
<span class="s1">{</span>
  <span class="s1">dispatch_sync(dispatch_get_main_queue()</span><span class="s3">, </span><span class="s1">^{</span>
    <span class="s1">[[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications]</span><span class="s3">;</span>
  <span class="s1">})</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">#endif </span><span class="s4">// !TARGET_OS_TV</span>

<span class="s1">- (UIView *)view</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">[[RNSScreenView alloc] initWithBridge:self.bridge]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">+ (BOOL)requiresMainQueueSetup</span>
<span class="s1">{</span>
  <span class="s4">// Returning NO here despite the fact some initialization in -init method dispatches tasks</span>
  <span class="s4">// on main queue, because the comments in RN source code states that modules which return YES</span>
  <span class="s4">// here will be constructed ahead-of-time -- and this is not required in our case.</span>
  <span class="s3">return </span><span class="s1">NO</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s3">@end</span>

<span class="s3">@implementation </span><span class="s1">RCTConvert (RNSScreen)</span>

<span class="s1">RCT_ENUM_CONVERTER(</span>
    <span class="s1">RNSScreenStackPresentation</span><span class="s3">,</span>
    <span class="s1">(</span><span class="s3">@</span><span class="s1">{</span>
      <span class="s3">@</span><span class="s2">&quot;push&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenStackPresentationPush)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;modal&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenStackPresentationModal)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;fullScreenModal&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenStackPresentationFullScreenModal)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;formSheet&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenStackPresentationFormSheet)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;containedModal&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenStackPresentationContainedModal)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;transparentModal&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenStackPresentationTransparentModal)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;containedTransparentModal&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenStackPresentationContainedTransparentModal)</span>
    <span class="s1">})</span><span class="s3">,</span>
    <span class="s1">RNSScreenStackPresentationPush</span><span class="s3">,</span>
    <span class="s1">integerValue)</span>

<span class="s1">RCT_ENUM_CONVERTER(</span>
    <span class="s1">RNSScreenStackAnimation</span><span class="s3">,</span>
    <span class="s1">(</span><span class="s3">@</span><span class="s1">{</span>
      <span class="s3">@</span><span class="s2">&quot;default&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenStackAnimationDefault)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;none&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenStackAnimationNone)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;fade&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenStackAnimationFade)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;fade_from_bottom&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenStackAnimationFadeFromBottom)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;flip&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenStackAnimationFlip)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;simple_push&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenStackAnimationSimplePush)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;slide_from_bottom&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenStackAnimationSlideFromBottom)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;slide_from_right&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenStackAnimationDefault)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;slide_from_left&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenStackAnimationDefault)</span><span class="s3">,</span>
    <span class="s1">})</span><span class="s3">,</span>
    <span class="s1">RNSScreenStackAnimationDefault</span><span class="s3">,</span>
    <span class="s1">integerValue)</span>

<span class="s1">RCT_ENUM_CONVERTER(</span>
    <span class="s1">RNSScreenReplaceAnimation</span><span class="s3">,</span>
    <span class="s1">(</span><span class="s3">@</span><span class="s1">{</span>
      <span class="s3">@</span><span class="s2">&quot;push&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenReplaceAnimationPush)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;pop&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenReplaceAnimationPop)</span><span class="s3">,</span>
    <span class="s1">})</span><span class="s3">,</span>
    <span class="s1">RNSScreenReplaceAnimationPop</span><span class="s3">,</span>
    <span class="s1">integerValue)</span>

<span class="s1">RCT_ENUM_CONVERTER(</span>
    <span class="s1">RNSScreenSwipeDirection</span><span class="s3">,</span>
    <span class="s1">(</span><span class="s3">@</span><span class="s1">{</span>
      <span class="s3">@</span><span class="s2">&quot;vertical&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenSwipeDirectionVertical)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;horizontal&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenSwipeDirectionHorizontal)</span><span class="s3">,</span>
    <span class="s1">})</span><span class="s3">,</span>
    <span class="s1">RNSScreenSwipeDirectionHorizontal</span><span class="s3">,</span>
    <span class="s1">integerValue)</span>

<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
<span class="s1">RCT_ENUM_CONVERTER(</span>
    <span class="s1">UIStatusBarAnimation</span><span class="s3">,</span>
    <span class="s1">(</span><span class="s3">@</span><span class="s1">{</span>
      <span class="s3">@</span><span class="s2">&quot;none&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIStatusBarAnimationNone)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;fade&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIStatusBarAnimationFade)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;slide&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIStatusBarAnimationSlide)</span>
    <span class="s1">})</span><span class="s3">,</span>
    <span class="s1">UIStatusBarAnimationNone</span><span class="s3">,</span>
    <span class="s1">integerValue)</span>

<span class="s1">RCT_ENUM_CONVERTER(</span>
    <span class="s1">RNSStatusBarStyle</span><span class="s3">,</span>
    <span class="s1">(</span><span class="s3">@</span><span class="s1">{</span>
      <span class="s3">@</span><span class="s2">&quot;auto&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSStatusBarStyleAuto)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;inverted&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSStatusBarStyleInverted)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;light&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSStatusBarStyleLight)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;dark&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSStatusBarStyleDark)</span><span class="s3">,</span>
    <span class="s1">})</span><span class="s3">,</span>
    <span class="s1">RNSStatusBarStyleAuto</span><span class="s3">,</span>
    <span class="s1">integerValue)</span>

<span class="s1">RCT_ENUM_CONVERTER(</span>
    <span class="s1">RNSScreenDetentType</span><span class="s3">,</span>
    <span class="s1">(</span><span class="s3">@</span><span class="s1">{</span>
      <span class="s3">@</span><span class="s2">&quot;large&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenDetentTypeLarge)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;medium&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenDetentTypeMedium)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;all&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(RNSScreenDetentTypeAll)</span><span class="s3">,</span>
    <span class="s1">})</span><span class="s3">,</span>
    <span class="s1">RNSScreenDetentTypeAll</span><span class="s3">,</span>
    <span class="s1">integerValue)</span>

<span class="s1">+ (UIInterfaceOrientationMask)UIInterfaceOrientationMask:(id)json</span>
<span class="s1">{</span>
  <span class="s1">json = [self NSString:json]</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">([json isEqualToString:</span><span class="s3">@</span><span class="s2">&quot;default&quot;</span><span class="s1">]) {</span>
    <span class="s3">return </span><span class="s1">UIInterfaceOrientationMaskAllButUpsideDown</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">([json isEqualToString:</span><span class="s3">@</span><span class="s2">&quot;all&quot;</span><span class="s1">]) {</span>
    <span class="s3">return </span><span class="s1">UIInterfaceOrientationMaskAll</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">([json isEqualToString:</span><span class="s3">@</span><span class="s2">&quot;portrait&quot;</span><span class="s1">]) {</span>
    <span class="s3">return </span><span class="s1">UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskPortraitUpsideDown</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">([json isEqualToString:</span><span class="s3">@</span><span class="s2">&quot;portrait_up&quot;</span><span class="s1">]) {</span>
    <span class="s3">return </span><span class="s1">UIInterfaceOrientationMaskPortrait</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">([json isEqualToString:</span><span class="s3">@</span><span class="s2">&quot;portrait_down&quot;</span><span class="s1">]) {</span>
    <span class="s3">return </span><span class="s1">UIInterfaceOrientationMaskPortraitUpsideDown</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">([json isEqualToString:</span><span class="s3">@</span><span class="s2">&quot;landscape&quot;</span><span class="s1">]) {</span>
    <span class="s3">return </span><span class="s1">UIInterfaceOrientationMaskLandscape</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">([json isEqualToString:</span><span class="s3">@</span><span class="s2">&quot;landscape_left&quot;</span><span class="s1">]) {</span>
    <span class="s3">return </span><span class="s1">UIInterfaceOrientationMaskLandscapeLeft</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">([json isEqualToString:</span><span class="s3">@</span><span class="s2">&quot;landscape_right&quot;</span><span class="s1">]) {</span>
    <span class="s3">return </span><span class="s1">UIInterfaceOrientationMaskLandscapeRight</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">UIInterfaceOrientationMaskAllButUpsideDown</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">#endif</span>

<span class="s3">@end</span>
</pre>
</body>
</html>
<html>
<head>
<title>no-unnecessary-condition.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
no-unnecessary-condition.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || </span><span class="s2">function </span><span class="s1">(mod) {</span>
    <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
    <span class="s2">var </span><span class="s1">result = {};</span>
    <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">mod) </span><span class="s2">if </span><span class="s1">(k !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);</span>
    <span class="s1">__setModuleDefault(result, mod);</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">};</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">const utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s1">const tsutils_1 = require(</span><span class="s0">&quot;tsutils&quot;</span><span class="s1">);</span>
<span class="s1">const ts = __importStar(require(</span><span class="s0">&quot;typescript&quot;</span><span class="s1">));</span>
<span class="s1">const util_1 = require(</span><span class="s0">&quot;../util&quot;</span><span class="s1">);</span>
<span class="s3">// Truthiness utilities</span>
<span class="s3">// #region</span>
<span class="s1">const isTruthyLiteral = (type) =&gt; (</span><span class="s4">0</span><span class="s1">, tsutils_1.isBooleanLiteralType)(type, </span><span class="s2">true</span><span class="s1">) || ((</span><span class="s4">0</span><span class="s1">, tsutils_1.isLiteralType)(type) &amp;&amp; !!type.value);</span>
<span class="s1">const isPossiblyFalsy = (type) =&gt; (</span><span class="s4">0</span><span class="s1">, tsutils_1.unionTypeParts)(type)</span>
    <span class="s3">// PossiblyFalsy flag includes literal values, so exclude ones that</span>
    <span class="s3">// are definitely truthy</span>
    <span class="s1">.filter(t =&gt; !isTruthyLiteral(t))</span>
    <span class="s1">.some(type =&gt; (</span><span class="s4">0</span><span class="s1">, util_1.isTypeFlagSet)(type, ts.TypeFlags.PossiblyFalsy));</span>
<span class="s1">const isPossiblyTruthy = (type) =&gt; (</span><span class="s4">0</span><span class="s1">, tsutils_1.unionTypeParts)(type).some(type =&gt; !(</span><span class="s4">0</span><span class="s1">, tsutils_1.isFalsyType)(type));</span>
<span class="s3">// Nullish utilities</span>
<span class="s1">const nullishFlag = ts.TypeFlags.Undefined | ts.TypeFlags.Null;</span>
<span class="s1">const isNullishType = (type) =&gt; (</span><span class="s4">0</span><span class="s1">, util_1.isTypeFlagSet)(type, nullishFlag);</span>
<span class="s1">const isPossiblyNullish = (type) =&gt; (</span><span class="s4">0</span><span class="s1">, tsutils_1.unionTypeParts)(type).some(isNullishType);</span>
<span class="s1">const isAlwaysNullish = (type) =&gt; (</span><span class="s4">0</span><span class="s1">, tsutils_1.unionTypeParts)(type).every(isNullishType);</span>
<span class="s3">// isLiteralType only covers numbers and strings, this is a more exhaustive check.</span>
<span class="s1">const isLiteral = (type) =&gt; (</span><span class="s4">0</span><span class="s1">, tsutils_1.isBooleanLiteralType)(type, </span><span class="s2">true</span><span class="s1">) ||</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, tsutils_1.isBooleanLiteralType)(type, </span><span class="s2">false</span><span class="s1">) ||</span>
    <span class="s1">type.flags === ts.TypeFlags.Undefined ||</span>
    <span class="s1">type.flags === ts.TypeFlags.Null ||</span>
    <span class="s1">type.flags === ts.TypeFlags.Void ||</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, tsutils_1.isLiteralType)(type);</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= (</span><span class="s4">0</span><span class="s1">, util_1.createRule)({</span>
    <span class="s1">name: </span><span class="s0">'no-unnecessary-condition'</span><span class="s1">,</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s0">'suggestion'</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">'Disallow conditionals where the type is always truthy or always falsy'</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s0">'strict'</span><span class="s1">,</span>
            <span class="s1">requiresTypeChecking: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">schema: [</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'object'</span><span class="s1">,</span>
                <span class="s1">properties: {</span>
                    <span class="s1">allowConstantLoopConditions: {</span>
                        <span class="s1">description: </span><span class="s0">'Whether to ignore constant loop conditions, such as `while (true)`.'</span><span class="s1">,</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {</span>
                        <span class="s1">description: </span><span class="s0">'Whether to not error when running with a tsconfig that has strictNullChecks turned.'</span><span class="s1">,</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                <span class="s1">},</span>
                <span class="s1">additionalProperties: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">},</span>
        <span class="s1">],</span>
        <span class="s1">fixable: </span><span class="s0">'code'</span><span class="s1">,</span>
        <span class="s1">messages: {</span>
            <span class="s1">alwaysTruthy: </span><span class="s0">'Unnecessary conditional, value is always truthy.'</span><span class="s1">,</span>
            <span class="s1">alwaysFalsy: </span><span class="s0">'Unnecessary conditional, value is always falsy.'</span><span class="s1">,</span>
            <span class="s1">alwaysTruthyFunc: </span><span class="s0">'This callback should return a conditional, but return is always truthy.'</span><span class="s1">,</span>
            <span class="s1">alwaysFalsyFunc: </span><span class="s0">'This callback should return a conditional, but return is always falsy.'</span><span class="s1">,</span>
            <span class="s1">neverNullish: </span><span class="s0">'Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.'</span><span class="s1">,</span>
            <span class="s1">alwaysNullish: </span><span class="s0">'Unnecessary conditional, left-hand side of `??` operator is always `null` or `undefined`.'</span><span class="s1">,</span>
            <span class="s1">literalBooleanExpression: </span><span class="s0">'Unnecessary conditional, both sides of the expression are literal values.'</span><span class="s1">,</span>
            <span class="s1">noOverlapBooleanExpression: </span><span class="s0">'Unnecessary conditional, the types have no overlap.'</span><span class="s1">,</span>
            <span class="s1">never: </span><span class="s0">'Unnecessary conditional, value is `never`.'</span><span class="s1">,</span>
            <span class="s1">neverOptionalChain: </span><span class="s0">'Unnecessary optional chain on a non-nullish value.'</span><span class="s1">,</span>
            <span class="s1">noStrictNullCheck: </span><span class="s0">'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.'</span><span class="s1">,</span>
        <span class="s1">},</span>
    <span class="s1">},</span>
    <span class="s1">defaultOptions: [</span>
        <span class="s1">{</span>
            <span class="s1">allowConstantLoopConditions: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">},</span>
    <span class="s1">],</span>
    <span class="s1">create(context, [{ allowConstantLoopConditions, allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing, },]) {</span>
        <span class="s1">const service = (</span><span class="s4">0</span><span class="s1">, util_1.getParserServices)(context);</span>
        <span class="s1">const checker = service.program.getTypeChecker();</span>
        <span class="s1">const sourceCode = context.getSourceCode();</span>
        <span class="s1">const compilerOptions = service.program.getCompilerOptions();</span>
        <span class="s1">const isStrictNullChecks = (</span><span class="s4">0</span><span class="s1">, tsutils_1.isStrictCompilerOptionEnabled)(compilerOptions, </span><span class="s0">'strictNullChecks'</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(!isStrictNullChecks &amp;&amp;</span>
            <span class="s1">allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== </span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s1">context.report({</span>
                <span class="s1">loc: {</span>
                    <span class="s1">start: { line: </span><span class="s4">0</span><span class="s1">, column: </span><span class="s4">0 </span><span class="s1">},</span>
                    <span class="s1">end: { line: </span><span class="s4">0</span><span class="s1">, column: </span><span class="s4">0 </span><span class="s1">},</span>
                <span class="s1">},</span>
                <span class="s1">messageId: </span><span class="s0">'noStrictNullCheck'</span><span class="s1">,</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">getNodeType(node) {</span>
            <span class="s1">const tsNode = service.esTreeNodeToTSNodeMap.get(node);</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, util_1.getConstrainedTypeAtLocation)(checker, tsNode);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">nodeIsArrayType(node) {</span>
            <span class="s1">const nodeType = getNodeType(node);</span>
            <span class="s2">return </span><span class="s1">checker.isArrayType(nodeType);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">nodeIsTupleType(node) {</span>
            <span class="s1">const nodeType = getNodeType(node);</span>
            <span class="s2">return </span><span class="s1">checker.isTupleType(nodeType);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">isArrayIndexExpression(node) {</span>
            <span class="s2">return </span><span class="s1">(</span>
            <span class="s3">// Is an index signature</span>
            <span class="s1">node.type === utils_1.AST_NODE_TYPES.MemberExpression &amp;&amp;</span>
                <span class="s1">node.computed &amp;&amp;</span>
                <span class="s3">// ...into an array type</span>
                <span class="s1">(nodeIsArrayType(node.object) ||</span>
                    <span class="s3">// ... or a tuple type</span>
                    <span class="s1">(nodeIsTupleType(node.object) &amp;&amp;</span>
                        <span class="s3">// Exception: literal index into a tuple - will have a sound type</span>
                        <span class="s1">node.property.type !== utils_1.AST_NODE_TYPES.Literal)));</span>
        <span class="s1">}</span>
        <span class="s3">/** 
         * Checks if a conditional node is necessary: 
         * if the type of the node is always true or always false, it's not necessary. 
         */</span>
        <span class="s2">function </span><span class="s1">checkNode(node, isUnaryNotArgument = </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s3">// Check if the node is Unary Negation expression and handle it</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.UnaryExpression &amp;&amp;</span>
                <span class="s1">node.operator === </span><span class="s0">'!'</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">checkNode(node.argument, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">// Since typescript array index signature types don't represent the</span>
            <span class="s3">//  possibility of out-of-bounds access, if we're indexing into an array</span>
            <span class="s3">//  just skip the check, to avoid false positives</span>
            <span class="s2">if </span><span class="s1">(isArrayIndexExpression(node)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">// When checking logical expressions, only check the right side</span>
            <span class="s3">//  as the left side has been checked by checkLogicalExpressionForUnnecessaryConditionals</span>
            <span class="s3">//</span>
            <span class="s3">// Unless the node is nullish coalescing, as it's common to use patterns like `nullBool ?? true` to to strict</span>
            <span class="s3">//  boolean checks if we inspect the right here, it'll usually be a constant condition on purpose.</span>
            <span class="s3">// In this case it's better to inspect the type of the expression as a whole.</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.LogicalExpression &amp;&amp;</span>
                <span class="s1">node.operator !== </span><span class="s0">'??'</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">checkNode(node.right);</span>
            <span class="s1">}</span>
            <span class="s1">const type = getNodeType(node);</span>
            <span class="s3">// Conditional is always necessary if it involves:</span>
            <span class="s3">//    `any` or `unknown` or a naked type variable</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, tsutils_1.unionTypeParts)(type).some(part =&gt; (</span><span class="s4">0</span><span class="s1">, util_1.isTypeAnyType)(part) ||</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, util_1.isTypeUnknownType)(part) ||</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, util_1.isTypeFlagSet)(part, ts.TypeFlags.TypeVariable))) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">let messageId = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, util_1.isTypeFlagSet)(type, ts.TypeFlags.Never)) {</span>
                <span class="s1">messageId = </span><span class="s0">'never'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!isPossiblyTruthy(type)) {</span>
                <span class="s1">messageId = !isUnaryNotArgument ? </span><span class="s0">'alwaysFalsy' </span><span class="s1">: </span><span class="s0">'alwaysTruthy'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!isPossiblyFalsy(type)) {</span>
                <span class="s1">messageId = !isUnaryNotArgument ? </span><span class="s0">'alwaysTruthy' </span><span class="s1">: </span><span class="s0">'alwaysFalsy'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(messageId) {</span>
                <span class="s1">context.report({ node, messageId });</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkNodeForNullish(node) {</span>
            <span class="s1">const type = getNodeType(node);</span>
            <span class="s3">// Conditional is always necessary if it involves `any`, `unknown` or a naked type parameter</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, util_1.isTypeFlagSet)(type, ts.TypeFlags.Any | ts.TypeFlags.Unknown | ts.TypeFlags.TypeParameter)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">let messageId = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, util_1.isTypeFlagSet)(type, ts.TypeFlags.Never)) {</span>
                <span class="s1">messageId = </span><span class="s0">'never'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!isPossiblyNullish(type)) {</span>
                <span class="s3">// Since typescript array index signature types don't represent the</span>
                <span class="s3">//  possibility of out-of-bounds access, if we're indexing into an array</span>
                <span class="s3">//  just skip the check, to avoid false positives</span>
                <span class="s2">if </span><span class="s1">(!isArrayIndexExpression(node) &amp;&amp;</span>
                    <span class="s1">!(node.type === utils_1.AST_NODE_TYPES.ChainExpression &amp;&amp;</span>
                        <span class="s1">node.expression.type !== utils_1.AST_NODE_TYPES.TSNonNullExpression &amp;&amp;</span>
                        <span class="s1">optionChainContainsOptionArrayIndex(node.expression))) {</span>
                    <span class="s1">messageId = </span><span class="s0">'neverNullish'</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(isAlwaysNullish(type)) {</span>
                <span class="s1">messageId = </span><span class="s0">'alwaysNullish'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(messageId) {</span>
                <span class="s1">context.report({ node, messageId });</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">/** 
         * Checks that a binary expression is necessarily conditional, reports otherwise. 
         * If both sides of the binary expression are literal values, it's not a necessary condition. 
         * 
         * NOTE: It's also unnecessary if the types that don't overlap at all 
         *    but that case is handled by the Typescript compiler itself. 
         *    Known exceptions: 
         *      * https://github.com/microsoft/TypeScript/issues/32627 
         *      * https://github.com/microsoft/TypeScript/issues/37160 (handled) 
         */</span>
        <span class="s1">const BOOL_OPERATORS = </span><span class="s2">new </span><span class="s1">Set([</span>
            <span class="s0">'&lt;'</span><span class="s1">,</span>
            <span class="s0">'&gt;'</span><span class="s1">,</span>
            <span class="s0">'&lt;='</span><span class="s1">,</span>
            <span class="s0">'&gt;='</span><span class="s1">,</span>
            <span class="s0">'=='</span><span class="s1">,</span>
            <span class="s0">'==='</span><span class="s1">,</span>
            <span class="s0">'!='</span><span class="s1">,</span>
            <span class="s0">'!=='</span><span class="s1">,</span>
        <span class="s1">]);</span>
        <span class="s2">function </span><span class="s1">checkIfBinaryExpressionIsNecessaryConditional(node) {</span>
            <span class="s2">if </span><span class="s1">(!BOOL_OPERATORS.has(node.operator)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">const leftType = getNodeType(node.left);</span>
            <span class="s1">const rightType = getNodeType(node.right);</span>
            <span class="s2">if </span><span class="s1">(isLiteral(leftType) &amp;&amp; isLiteral(rightType)) {</span>
                <span class="s1">context.report({ node, messageId: </span><span class="s0">'literalBooleanExpression' </span><span class="s1">});</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">// Workaround for https://github.com/microsoft/TypeScript/issues/37160</span>
            <span class="s2">if </span><span class="s1">(isStrictNullChecks) {</span>
                <span class="s1">const UNDEFINED = ts.TypeFlags.Undefined;</span>
                <span class="s1">const NULL = ts.TypeFlags.Null;</span>
                <span class="s1">const VOID = ts.TypeFlags.Void;</span>
                <span class="s1">const isComparable = (type, flag) =&gt; {</span>
                    <span class="s3">// Allow comparison to `any`, `unknown` or a naked type parameter.</span>
                    <span class="s1">flag |=</span>
                        <span class="s1">ts.TypeFlags.Any |</span>
                            <span class="s1">ts.TypeFlags.Unknown |</span>
                            <span class="s1">ts.TypeFlags.TypeParameter;</span>
                    <span class="s3">// Allow loose comparison to nullish values.</span>
                    <span class="s2">if </span><span class="s1">(node.operator === </span><span class="s0">'==' </span><span class="s1">|| node.operator === </span><span class="s0">'!='</span><span class="s1">) {</span>
                        <span class="s1">flag |= NULL | UNDEFINED | VOID;</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, util_1.isTypeFlagSet)(type, flag);</span>
                <span class="s1">};</span>
                <span class="s2">if </span><span class="s1">((leftType.flags === UNDEFINED &amp;&amp;</span>
                    <span class="s1">!isComparable(rightType, UNDEFINED | VOID)) ||</span>
                    <span class="s1">(rightType.flags === UNDEFINED &amp;&amp;</span>
                        <span class="s1">!isComparable(leftType, UNDEFINED | VOID)) ||</span>
                    <span class="s1">(leftType.flags === NULL &amp;&amp; !isComparable(rightType, NULL)) ||</span>
                    <span class="s1">(rightType.flags === NULL &amp;&amp; !isComparable(leftType, NULL))) {</span>
                    <span class="s1">context.report({ node, messageId: </span><span class="s0">'noOverlapBooleanExpression' </span><span class="s1">});</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">/** 
         * Checks that a logical expression contains a boolean, reports otherwise. 
         */</span>
        <span class="s2">function </span><span class="s1">checkLogicalExpressionForUnnecessaryConditionals(node) {</span>
            <span class="s2">if </span><span class="s1">(node.operator === </span><span class="s0">'??'</span><span class="s1">) {</span>
                <span class="s1">checkNodeForNullish(node.left);</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">// Only checks the left side, since the right side might not be &quot;conditional&quot; at all.</span>
            <span class="s3">// The right side will be checked if the LogicalExpression is used in a conditional context</span>
            <span class="s1">checkNode(node.left);</span>
        <span class="s1">}</span>
        <span class="s3">/** 
         * Checks that a testable expression of a loop is necessarily conditional, reports otherwise. 
         */</span>
        <span class="s2">function </span><span class="s1">checkIfLoopIsNecessaryConditional(node) {</span>
            <span class="s2">if </span><span class="s1">(node.test == </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s3">// e.g. `for(;;)`</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">/** 
             * Allow: 
             *   while (true) {} 
             *   for (;true;) {} 
             *   do {} while (true) 
             */</span>
            <span class="s2">if </span><span class="s1">(allowConstantLoopConditions &amp;&amp;</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, tsutils_1.isBooleanLiteralType)(getNodeType(node.test), </span><span class="s2">true</span><span class="s1">)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">checkNode(node.test);</span>
        <span class="s1">}</span>
        <span class="s1">const ARRAY_PREDICATE_FUNCTIONS = </span><span class="s2">new </span><span class="s1">Set([</span>
            <span class="s0">'filter'</span><span class="s1">,</span>
            <span class="s0">'find'</span><span class="s1">,</span>
            <span class="s0">'some'</span><span class="s1">,</span>
            <span class="s0">'every'</span><span class="s1">,</span>
        <span class="s1">]);</span>
        <span class="s2">function </span><span class="s1">isArrayPredicateFunction(node) {</span>
            <span class="s1">const { callee } = node;</span>
            <span class="s2">return </span><span class="s1">(</span>
            <span class="s3">// looks like `something.filter` or `something.find`</span>
            <span class="s1">callee.type === utils_1.AST_NODE_TYPES.MemberExpression &amp;&amp;</span>
                <span class="s1">callee.property.type === utils_1.AST_NODE_TYPES.Identifier &amp;&amp;</span>
                <span class="s1">ARRAY_PREDICATE_FUNCTIONS.has(callee.property.name) &amp;&amp;</span>
                <span class="s3">// and the left-hand side is an array, according to the types</span>
                <span class="s1">(nodeIsArrayType(callee.object) || nodeIsTupleType(callee.object)));</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkCallExpression(node) {</span>
            <span class="s3">// If this is something like arr.filter(x =&gt; /*condition*/), check `condition`</span>
            <span class="s2">if </span><span class="s1">(isArrayPredicateFunction(node) &amp;&amp; node.arguments.length) {</span>
                <span class="s1">const callback = node.arguments[</span><span class="s4">0</span><span class="s1">];</span>
                <span class="s3">// Inline defined functions</span>
                <span class="s2">if </span><span class="s1">((callback.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||</span>
                    <span class="s1">callback.type === utils_1.AST_NODE_TYPES.FunctionExpression) &amp;&amp;</span>
                    <span class="s1">callback.body) {</span>
                    <span class="s3">// Two special cases, where we can directly check the node that's returned:</span>
                    <span class="s3">// () =&gt; something</span>
                    <span class="s2">if </span><span class="s1">(callback.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {</span>
                        <span class="s2">return </span><span class="s1">checkNode(callback.body);</span>
                    <span class="s1">}</span>
                    <span class="s3">// () =&gt; { return something; }</span>
                    <span class="s1">const callbackBody = callback.body.body;</span>
                    <span class="s2">if </span><span class="s1">(callbackBody.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
                        <span class="s1">callbackBody[</span><span class="s4">0</span><span class="s1">].type === utils_1.AST_NODE_TYPES.ReturnStatement &amp;&amp;</span>
                        <span class="s1">callbackBody[</span><span class="s4">0</span><span class="s1">].argument) {</span>
                        <span class="s2">return </span><span class="s1">checkNode(callbackBody[</span><span class="s4">0</span><span class="s1">].argument);</span>
                    <span class="s1">}</span>
                    <span class="s3">// Potential enhancement: could use code-path analysis to check</span>
                    <span class="s3">//   any function with a single return statement</span>
                    <span class="s3">// (Value to complexity ratio is dubious however)</span>
                <span class="s1">}</span>
                <span class="s3">// Otherwise just do type analysis on the function as a whole.</span>
                <span class="s1">const returnTypes = (</span><span class="s4">0</span><span class="s1">, tsutils_1.getCallSignaturesOfType)(getNodeType(callback)).map(sig =&gt; sig.getReturnType());</span>
                <span class="s3">/* istanbul ignore if */ </span><span class="s2">if </span><span class="s1">(returnTypes.length === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s3">// Not a callable function</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">// Predicate is always necessary if it involves `any` or `unknown`</span>
                <span class="s2">if </span><span class="s1">(returnTypes.some(t =&gt; (</span><span class="s4">0</span><span class="s1">, util_1.isTypeAnyType)(t) || (</span><span class="s4">0</span><span class="s1">, util_1.isTypeUnknownType)(t))) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!returnTypes.some(isPossiblyFalsy)) {</span>
                    <span class="s2">return </span><span class="s1">context.report({</span>
                        <span class="s1">node: callback,</span>
                        <span class="s1">messageId: </span><span class="s0">'alwaysTruthyFunc'</span><span class="s1">,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!returnTypes.some(isPossiblyTruthy)) {</span>
                    <span class="s2">return </span><span class="s1">context.report({</span>
                        <span class="s1">node: callback,</span>
                        <span class="s1">messageId: </span><span class="s0">'alwaysFalsyFunc'</span><span class="s1">,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">// Recursively searches an optional chain for an array index expression</span>
        <span class="s3">//  Has to search the entire chain, because an array index will &quot;infect&quot; the rest of the types</span>
        <span class="s3">//  Example:</span>
        <span class="s3">//  ```</span>
        <span class="s3">//  [{x: {y: &quot;z&quot;} }][n] // type is {x: {y: &quot;z&quot;}}</span>
        <span class="s3">//    ?.x // type is {y: &quot;z&quot;}</span>
        <span class="s3">//    ?.y // This access is considered &quot;unnecessary&quot; according to the types</span>
        <span class="s3">//  ```</span>
        <span class="s2">function </span><span class="s1">optionChainContainsOptionArrayIndex(node) {</span>
            <span class="s1">const lhsNode = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;</span>
            <span class="s2">if </span><span class="s1">(node.optional &amp;&amp; isArrayIndexExpression(lhsNode)) {</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(lhsNode.type === utils_1.AST_NODE_TYPES.MemberExpression ||</span>
                <span class="s1">lhsNode.type === utils_1.AST_NODE_TYPES.CallExpression) {</span>
                <span class="s2">return </span><span class="s1">optionChainContainsOptionArrayIndex(lhsNode);</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">isNullablePropertyType(objType, propertyType) {</span>
            <span class="s2">if </span><span class="s1">(propertyType.isUnion()) {</span>
                <span class="s2">return </span><span class="s1">propertyType.types.some(type =&gt; isNullablePropertyType(objType, type));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(propertyType.isNumberLiteral() || propertyType.isStringLiteral()) {</span>
                <span class="s1">const propType = (</span><span class="s4">0</span><span class="s1">, util_1.getTypeOfPropertyOfName)(checker, objType, propertyType.value.toString());</span>
                <span class="s2">if </span><span class="s1">(propType) {</span>
                    <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, util_1.isNullableType)(propType, { allowUndefined: </span><span class="s2">true </span><span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">const typeName = (</span><span class="s4">0</span><span class="s1">, util_1.getTypeName)(checker, propertyType);</span>
            <span class="s2">return </span><span class="s1">!!((typeName === </span><span class="s0">'string' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">checker.getIndexInfoOfType(objType, ts.IndexKind.String)) ||</span>
                <span class="s1">(typeName === </span><span class="s0">'number' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">checker.getIndexInfoOfType(objType, ts.IndexKind.Number)));</span>
        <span class="s1">}</span>
        <span class="s3">// Checks whether a member expression is nullable or not regardless of it's previous node.</span>
        <span class="s3">//  Example:</span>
        <span class="s3">//  ```</span>
        <span class="s3">//  // 'bar' is nullable if 'foo' is null.</span>
        <span class="s3">//  // but this function checks regardless of 'foo' type, so returns 'true'.</span>
        <span class="s3">//  declare const foo: { bar : { baz: string } } | null</span>
        <span class="s3">//  foo?.bar;</span>
        <span class="s3">//  ```</span>
        <span class="s2">function </span><span class="s1">isNullableOriginFromPrev(node) {</span>
            <span class="s1">const prevType = getNodeType(node.object);</span>
            <span class="s1">const property = node.property;</span>
            <span class="s2">if </span><span class="s1">(prevType.isUnion() &amp;&amp; (</span><span class="s4">0</span><span class="s1">, util_1.isIdentifier)(property)) {</span>
                <span class="s1">const isOwnNullable = prevType.types.some(type =&gt; {</span>
                    <span class="s2">if </span><span class="s1">(node.computed) {</span>
                        <span class="s1">const propertyType = getNodeType(node.property);</span>
                        <span class="s2">return </span><span class="s1">isNullablePropertyType(type, propertyType);</span>
                    <span class="s1">}</span>
                    <span class="s1">const propType = (</span><span class="s4">0</span><span class="s1">, util_1.getTypeOfPropertyOfName)(checker, type, property.name);</span>
                    <span class="s2">if </span><span class="s1">(propType) {</span>
                        <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, util_1.isNullableType)(propType, { allowUndefined: </span><span class="s2">true </span><span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">!!checker.getIndexInfoOfType(type, ts.IndexKind.String);</span>
                <span class="s1">});</span>
                <span class="s2">return </span><span class="s1">(!isOwnNullable &amp;&amp; (</span><span class="s4">0</span><span class="s1">, util_1.isNullableType)(prevType, { allowUndefined: </span><span class="s2">true </span><span class="s1">}));</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">isOptionableExpression(node) {</span>
            <span class="s1">const type = getNodeType(node);</span>
            <span class="s1">const isOwnNullable = node.type === utils_1.AST_NODE_TYPES.MemberExpression</span>
                <span class="s1">? !isNullableOriginFromPrev(node)</span>
                <span class="s1">: </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">const possiblyVoid = (</span><span class="s4">0</span><span class="s1">, util_1.isTypeFlagSet)(type, ts.TypeFlags.Void);</span>
            <span class="s2">return </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, util_1.isTypeFlagSet)(type, ts.TypeFlags.Any | ts.TypeFlags.Unknown) ||</span>
                <span class="s1">(isOwnNullable &amp;&amp;</span>
                    <span class="s1">((</span><span class="s4">0</span><span class="s1">, util_1.isNullableType)(type, { allowUndefined: </span><span class="s2">true </span><span class="s1">}) || possiblyVoid)));</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkOptionalChain(node, beforeOperator, fix) {</span>
            <span class="s3">// We only care if this step in the chain is optional. If just descend</span>
            <span class="s3">// from an optional chain, then that's fine.</span>
            <span class="s2">if </span><span class="s1">(!node.optional) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">// Since typescript array index signature types don't represent the</span>
            <span class="s3">//  possibility of out-of-bounds access, if we're indexing into an array</span>
            <span class="s3">//  just skip the check, to avoid false positives</span>
            <span class="s2">if </span><span class="s1">(optionChainContainsOptionArrayIndex(node)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">const nodeToCheck = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;</span>
            <span class="s2">if </span><span class="s1">(isOptionableExpression(nodeToCheck)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">const questionDotOperator = (</span><span class="s4">0</span><span class="s1">, util_1.nullThrows)(sourceCode.getTokenAfter(beforeOperator, token =&gt; token.type === utils_1.AST_TOKEN_TYPES.Punctuator &amp;&amp; token.value === </span><span class="s0">'?.'</span><span class="s1">), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'operator'</span><span class="s1">, node.type));</span>
            <span class="s1">context.report({</span>
                <span class="s1">node,</span>
                <span class="s1">loc: questionDotOperator.loc,</span>
                <span class="s1">messageId: </span><span class="s0">'neverOptionalChain'</span><span class="s1">,</span>
                <span class="s1">fix(fixer) {</span>
                    <span class="s2">return </span><span class="s1">fixer.replaceText(questionDotOperator, fix);</span>
                <span class="s1">},</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkOptionalMemberExpression(node) {</span>
            <span class="s1">checkOptionalChain(node, node.object, node.computed ? </span><span class="s0">'' </span><span class="s1">: </span><span class="s0">'.'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkOptionalCallExpression(node) {</span>
            <span class="s1">checkOptionalChain(node, node.callee, </span><span class="s0">''</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkAssignmentExpression(node) {</span>
            <span class="s3">// Similar to checkLogicalExpressionForUnnecessaryConditionals, since</span>
            <span class="s3">// a ||= b is equivalent to a || (a = b)</span>
            <span class="s2">if </span><span class="s1">([</span><span class="s0">'||='</span><span class="s1">, </span><span class="s0">'&amp;&amp;='</span><span class="s1">].includes(node.operator)) {</span>
                <span class="s1">checkNode(node.left);</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(node.operator === </span><span class="s0">'??='</span><span class="s1">) {</span>
                <span class="s1">checkNodeForNullish(node.left);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">AssignmentExpression: checkAssignmentExpression,</span>
            <span class="s1">BinaryExpression: checkIfBinaryExpressionIsNecessaryConditional,</span>
            <span class="s1">CallExpression: checkCallExpression,</span>
            <span class="s1">ConditionalExpression: (node) =&gt; checkNode(node.test),</span>
            <span class="s1">DoWhileStatement: checkIfLoopIsNecessaryConditional,</span>
            <span class="s1">ForStatement: checkIfLoopIsNecessaryConditional,</span>
            <span class="s1">IfStatement: (node) =&gt; checkNode(node.test),</span>
            <span class="s1">LogicalExpression: checkLogicalExpressionForUnnecessaryConditionals,</span>
            <span class="s1">WhileStatement: checkIfLoopIsNecessaryConditional,</span>
            <span class="s0">'MemberExpression[optional = true]'</span><span class="s1">: checkOptionalMemberExpression,</span>
            <span class="s0">'CallExpression[optional = true]'</span><span class="s1">: checkOptionalCallExpression,</span>
        <span class="s1">};</span>
    <span class="s1">},</span>
<span class="s1">});</span>
<span class="s3">//# sourceMappingURL=no-unnecessary-condition.js.map</span></pre>
</body>
</html>
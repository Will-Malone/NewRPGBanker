<html>
<head>
<title>yargs-parser.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
yargs-parser.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @license 
 * Copyright (c) 2016, Contributors 
 * SPDX-License-Identifier: ISC 
 */</span>
<span class="s1">import { tokenizeArgString } from </span><span class="s2">'./tokenize-arg-string.js'</span><span class="s1">;</span>
<span class="s1">import { DefaultValuesForTypeKey } from </span><span class="s2">'./yargs-parser-types.js'</span><span class="s1">;</span>
<span class="s1">import { camelCase, decamelize, looksLikeNumber } from </span><span class="s2">'./string-utils.js'</span><span class="s1">;</span>
<span class="s1">let mixin;</span>
<span class="s1">export class YargsParser {</span>
    <span class="s1">constructor(_mixin) {</span>
        <span class="s1">mixin = _mixin;</span>
    <span class="s1">}</span>
    <span class="s1">parse(argsInput, options) {</span>
        <span class="s1">const opts = Object.assign({</span>
            <span class="s1">alias: undefined,</span>
            <span class="s1">array: undefined,</span>
            <span class="s1">boolean: undefined,</span>
            <span class="s1">config: undefined,</span>
            <span class="s1">configObjects: undefined,</span>
            <span class="s1">configuration: undefined,</span>
            <span class="s1">coerce: undefined,</span>
            <span class="s1">count: undefined,</span>
            <span class="s3">default</span><span class="s1">: undefined,</span>
            <span class="s1">envPrefix: undefined,</span>
            <span class="s1">narg: undefined,</span>
            <span class="s1">normalize: undefined,</span>
            <span class="s1">string: undefined,</span>
            <span class="s1">number: undefined,</span>
            <span class="s1">__: undefined,</span>
            <span class="s1">key: undefined</span>
        <span class="s1">}, options);</span>
        <span class="s0">// allow a string argument to be passed in rather</span>
        <span class="s0">// than an argv array.</span>
        <span class="s1">const args = tokenizeArgString(argsInput);</span>
        <span class="s0">// tokenizeArgString adds extra quotes to args if argsInput is a string</span>
        <span class="s0">// only strip those extra quotes in processValue if argsInput is a string</span>
        <span class="s1">const inputIsString = </span><span class="s3">typeof </span><span class="s1">argsInput === </span><span class="s2">'string'</span><span class="s1">;</span>
        <span class="s0">// aliases might have transitive relationships, normalize this.</span>
        <span class="s1">const aliases = combineAliases(Object.assign(Object.create(</span><span class="s3">null</span><span class="s1">), opts.alias));</span>
        <span class="s1">const configuration = Object.assign({</span>
            <span class="s2">'boolean-negation'</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s2">'camel-case-expansion'</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s2">'combine-arrays'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s2">'dot-notation'</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s2">'duplicate-arguments-array'</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s2">'flatten-duplicate-arrays'</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s2">'greedy-arrays'</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s2">'halt-at-non-option'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s2">'nargs-eats-options'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s2">'negation-prefix'</span><span class="s1">: </span><span class="s2">'no-'</span><span class="s1">,</span>
            <span class="s2">'parse-numbers'</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s2">'parse-positional-numbers'</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s2">'populate--'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s2">'set-placeholder-key'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s2">'short-option-groups'</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s2">'strip-aliased'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s2">'strip-dashed'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s2">'unknown-options-as-args'</span><span class="s1">: </span><span class="s3">false</span>
        <span class="s1">}, opts.configuration);</span>
        <span class="s1">const defaults = Object.assign(Object.create(</span><span class="s3">null</span><span class="s1">), opts.</span><span class="s3">default</span><span class="s1">);</span>
        <span class="s1">const configObjects = opts.configObjects || [];</span>
        <span class="s1">const envPrefix = opts.envPrefix;</span>
        <span class="s1">const notFlagsOption = configuration[</span><span class="s2">'populate--'</span><span class="s1">];</span>
        <span class="s1">const notFlagsArgv = notFlagsOption ? </span><span class="s2">'--' </span><span class="s1">: </span><span class="s2">'_'</span><span class="s1">;</span>
        <span class="s1">const newAliases = Object.create(</span><span class="s3">null</span><span class="s1">);</span>
        <span class="s1">const defaulted = Object.create(</span><span class="s3">null</span><span class="s1">);</span>
        <span class="s0">// allow a i18n handler to be passed in, default to a fake one (util.format).</span>
        <span class="s1">const __ = opts.__ || mixin.format;</span>
        <span class="s1">const flags = {</span>
            <span class="s1">aliases: Object.create(</span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">arrays: Object.create(</span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">bools: Object.create(</span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">strings: Object.create(</span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">numbers: Object.create(</span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">counts: Object.create(</span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">normalize: Object.create(</span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">configs: Object.create(</span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">nargs: Object.create(</span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">coercions: Object.create(</span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">keys: []</span>
        <span class="s1">};</span>
        <span class="s1">const negative = /^-([</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">]+(\.[</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">]+)?|\.[</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">]+)$/;</span>
        <span class="s1">const negatedBoolean = </span><span class="s3">new </span><span class="s1">RegExp(</span><span class="s2">'^--' </span><span class="s1">+ configuration[</span><span class="s2">'negation-prefix'</span><span class="s1">] + </span><span class="s2">'(.+)'</span><span class="s1">);</span>
        <span class="s1">[].concat(opts.array || []).filter(Boolean).forEach(</span><span class="s3">function </span><span class="s1">(opt) {</span>
            <span class="s1">const key = </span><span class="s3">typeof </span><span class="s1">opt === </span><span class="s2">'object' </span><span class="s1">? opt.key : opt;</span>
            <span class="s0">// assign to flags[bools|strings|numbers]</span>
            <span class="s1">const assignment = Object.keys(opt).map(</span><span class="s3">function </span><span class="s1">(key) {</span>
                <span class="s1">const arrayFlagKeys = {</span>
                    <span class="s1">boolean: </span><span class="s2">'bools'</span><span class="s1">,</span>
                    <span class="s1">string: </span><span class="s2">'strings'</span><span class="s1">,</span>
                    <span class="s1">number: </span><span class="s2">'numbers'</span>
                <span class="s1">};</span>
                <span class="s3">return </span><span class="s1">arrayFlagKeys[key];</span>
            <span class="s1">}).filter(Boolean).pop();</span>
            <span class="s0">// assign key to be coerced</span>
            <span class="s3">if </span><span class="s1">(assignment) {</span>
                <span class="s1">flags[assignment][key] = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">flags.arrays[key] = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">flags.keys.push(key);</span>
        <span class="s1">});</span>
        <span class="s1">[].concat(opts.boolean || []).filter(Boolean).forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
            <span class="s1">flags.bools[key] = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">flags.keys.push(key);</span>
        <span class="s1">});</span>
        <span class="s1">[].concat(opts.string || []).filter(Boolean).forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
            <span class="s1">flags.strings[key] = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">flags.keys.push(key);</span>
        <span class="s1">});</span>
        <span class="s1">[].concat(opts.number || []).filter(Boolean).forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
            <span class="s1">flags.numbers[key] = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">flags.keys.push(key);</span>
        <span class="s1">});</span>
        <span class="s1">[].concat(opts.count || []).filter(Boolean).forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
            <span class="s1">flags.counts[key] = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">flags.keys.push(key);</span>
        <span class="s1">});</span>
        <span class="s1">[].concat(opts.normalize || []).filter(Boolean).forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
            <span class="s1">flags.normalize[key] = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">flags.keys.push(key);</span>
        <span class="s1">});</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">opts.narg === </span><span class="s2">'object'</span><span class="s1">) {</span>
            <span class="s1">Object.entries(opts.narg).forEach(([key, value]) =&gt; {</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'number'</span><span class="s1">) {</span>
                    <span class="s1">flags.nargs[key] = value;</span>
                    <span class="s1">flags.keys.push(key);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">opts.coerce === </span><span class="s2">'object'</span><span class="s1">) {</span>
            <span class="s1">Object.entries(opts.coerce).forEach(([key, value]) =&gt; {</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'function'</span><span class="s1">) {</span>
                    <span class="s1">flags.coercions[key] = value;</span>
                    <span class="s1">flags.keys.push(key);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">opts.config !== </span><span class="s2">'undefined'</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(Array.isArray(opts.config) || </span><span class="s3">typeof </span><span class="s1">opts.config === </span><span class="s2">'string'</span><span class="s1">) {</span>
                <span class="s1">;</span>
                <span class="s1">[].concat(opts.config).filter(Boolean).forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
                    <span class="s1">flags.configs[key] = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">opts.config === </span><span class="s2">'object'</span><span class="s1">) {</span>
                <span class="s1">Object.entries(opts.config).forEach(([key, value]) =&gt; {</span>
                    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'boolean' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'function'</span><span class="s1">) {</span>
                        <span class="s1">flags.configs[key] = value;</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">// create a lookup table that takes into account all</span>
        <span class="s0">// combinations of aliases: {f: ['foo'], foo: ['f']}</span>
        <span class="s1">extendAliases(opts.key, aliases, opts.</span><span class="s3">default</span><span class="s1">, flags.arrays);</span>
        <span class="s0">// apply default values to all aliases.</span>
        <span class="s1">Object.keys(defaults).forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
            <span class="s1">(flags.aliases[key] || []).forEach(</span><span class="s3">function </span><span class="s1">(alias) {</span>
                <span class="s1">defaults[alias] = defaults[key];</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
        <span class="s1">let error = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">checkConfiguration();</span>
        <span class="s1">let notFlags = [];</span>
        <span class="s1">const argv = Object.assign(Object.create(</span><span class="s3">null</span><span class="s1">), { _: [] });</span>
        <span class="s0">// TODO(bcoe): for the first pass at removing object prototype  we didn't</span>
        <span class="s0">// remove all prototypes from objects returned by this API, we might want</span>
        <span class="s0">// to gradually move towards doing so.</span>
        <span class="s1">const argvReturn = {};</span>
        <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; args.length; i++) {</span>
            <span class="s1">const arg = args[i];</span>
            <span class="s1">const truncatedArg = arg.replace(/^-{</span><span class="s4">3</span><span class="s1">,}/, </span><span class="s2">'---'</span><span class="s1">);</span>
            <span class="s1">let broken;</span>
            <span class="s1">let key;</span>
            <span class="s1">let letters;</span>
            <span class="s1">let m;</span>
            <span class="s1">let next;</span>
            <span class="s1">let value;</span>
            <span class="s0">// any unknown option (except for end-of-options, &quot;--&quot;)</span>
            <span class="s3">if </span><span class="s1">(arg !== </span><span class="s2">'--' </span><span class="s1">&amp;&amp; /^-/.test(arg) &amp;&amp; isUnknownOptionAsArg(arg)) {</span>
                <span class="s1">pushPositional(arg);</span>
                <span class="s0">// ---, ---=, ----, etc,</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(truncatedArg.match(/^---+(=|$)/)) {</span>
                <span class="s0">// options without key name are invalid.</span>
                <span class="s1">pushPositional(arg);</span>
                <span class="s3">continue</span><span class="s1">;</span>
                <span class="s0">// -- separated by =</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(arg.match(/^--.+=/) || (!configuration[</span><span class="s2">'short-option-groups'</span><span class="s1">] &amp;&amp; arg.match(/^-.+=/))) {</span>
                <span class="s0">// Using [\s\S] instead of . because js doesn't support the</span>
                <span class="s0">// 'dotall' regex modifier. See:</span>
                <span class="s0">// http://stackoverflow.com/a/1068308/13216</span>
                <span class="s1">m = arg.match(/^--?([^=]+)=([\s\S]*)$/);</span>
                <span class="s0">// arrays format = '--f=a b c'</span>
                <span class="s3">if </span><span class="s1">(m !== </span><span class="s3">null </span><span class="s1">&amp;&amp; Array.isArray(m) &amp;&amp; m.length &gt;= </span><span class="s4">3</span><span class="s1">) {</span>
                    <span class="s3">if </span><span class="s1">(checkAllAliases(m[</span><span class="s4">1</span><span class="s1">], flags.arrays)) {</span>
                        <span class="s1">i = eatArray(i, m[</span><span class="s4">1</span><span class="s1">], args, m[</span><span class="s4">2</span><span class="s1">]);</span>
                    <span class="s1">}</span>
                    <span class="s3">else if </span><span class="s1">(checkAllAliases(m[</span><span class="s4">1</span><span class="s1">], flags.nargs) !== </span><span class="s3">false</span><span class="s1">) {</span>
                        <span class="s0">// nargs format = '--f=monkey washing cat'</span>
                        <span class="s1">i = eatNargs(i, m[</span><span class="s4">1</span><span class="s1">], args, m[</span><span class="s4">2</span><span class="s1">]);</span>
                    <span class="s1">}</span>
                    <span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">setArg(m[</span><span class="s4">1</span><span class="s1">], m[</span><span class="s4">2</span><span class="s1">], </span><span class="s3">true</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(arg.match(negatedBoolean) &amp;&amp; configuration[</span><span class="s2">'boolean-negation'</span><span class="s1">]) {</span>
                <span class="s1">m = arg.match(negatedBoolean);</span>
                <span class="s3">if </span><span class="s1">(m !== </span><span class="s3">null </span><span class="s1">&amp;&amp; Array.isArray(m) &amp;&amp; m.length &gt;= </span><span class="s4">2</span><span class="s1">) {</span>
                    <span class="s1">key = m[</span><span class="s4">1</span><span class="s1">];</span>
                    <span class="s1">setArg(key, checkAllAliases(key, flags.arrays) ? [</span><span class="s3">false</span><span class="s1">] : </span><span class="s3">false</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s0">// -- separated by space.</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(arg.match(/^--.+/) || (!configuration[</span><span class="s2">'short-option-groups'</span><span class="s1">] &amp;&amp; arg.match(/^-[^-]+/))) {</span>
                <span class="s1">m = arg.match(/^--?(.+)/);</span>
                <span class="s3">if </span><span class="s1">(m !== </span><span class="s3">null </span><span class="s1">&amp;&amp; Array.isArray(m) &amp;&amp; m.length &gt;= </span><span class="s4">2</span><span class="s1">) {</span>
                    <span class="s1">key = m[</span><span class="s4">1</span><span class="s1">];</span>
                    <span class="s3">if </span><span class="s1">(checkAllAliases(key, flags.arrays)) {</span>
                        <span class="s0">// array format = '--foo a b c'</span>
                        <span class="s1">i = eatArray(i, key, args);</span>
                    <span class="s1">}</span>
                    <span class="s3">else if </span><span class="s1">(checkAllAliases(key, flags.nargs) !== </span><span class="s3">false</span><span class="s1">) {</span>
                        <span class="s0">// nargs format = '--foo a b c'</span>
                        <span class="s0">// should be truthy even if: flags.nargs[key] === 0</span>
                        <span class="s1">i = eatNargs(i, key, args);</span>
                    <span class="s1">}</span>
                    <span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">next = args[i + </span><span class="s4">1</span><span class="s1">];</span>
                        <span class="s3">if </span><span class="s1">(next !== undefined &amp;&amp; (!next.match(/^-/) ||</span>
                            <span class="s1">next.match(negative)) &amp;&amp;</span>
                            <span class="s1">!checkAllAliases(key, flags.bools) &amp;&amp;</span>
                            <span class="s1">!checkAllAliases(key, flags.counts)) {</span>
                            <span class="s1">setArg(key, next);</span>
                            <span class="s1">i++;</span>
                        <span class="s1">}</span>
                        <span class="s3">else if </span><span class="s1">(/^(</span><span class="s3">true</span><span class="s1">|</span><span class="s3">false</span><span class="s1">)$/.test(next)) {</span>
                            <span class="s1">setArg(key, next);</span>
                            <span class="s1">i++;</span>
                        <span class="s1">}</span>
                        <span class="s3">else </span><span class="s1">{</span>
                            <span class="s1">setArg(key, defaultValue(key));</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">// dot-notation flag separated by '='.</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(arg.match(/^-.\..+=/)) {</span>
                <span class="s1">m = arg.match(/^-([^=]+)=([\s\S]*)$/);</span>
                <span class="s3">if </span><span class="s1">(m !== </span><span class="s3">null </span><span class="s1">&amp;&amp; Array.isArray(m) &amp;&amp; m.length &gt;= </span><span class="s4">3</span><span class="s1">) {</span>
                    <span class="s1">setArg(m[</span><span class="s4">1</span><span class="s1">], m[</span><span class="s4">2</span><span class="s1">]);</span>
                <span class="s1">}</span>
                <span class="s0">// dot-notation flag separated by space.</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(arg.match(/^-.\..+/) &amp;&amp; !arg.match(negative)) {</span>
                <span class="s1">next = args[i + </span><span class="s4">1</span><span class="s1">];</span>
                <span class="s1">m = arg.match(/^-(.\..+)/);</span>
                <span class="s3">if </span><span class="s1">(m !== </span><span class="s3">null </span><span class="s1">&amp;&amp; Array.isArray(m) &amp;&amp; m.length &gt;= </span><span class="s4">2</span><span class="s1">) {</span>
                    <span class="s1">key = m[</span><span class="s4">1</span><span class="s1">];</span>
                    <span class="s3">if </span><span class="s1">(next !== undefined &amp;&amp; !next.match(/^-/) &amp;&amp;</span>
                        <span class="s1">!checkAllAliases(key, flags.bools) &amp;&amp;</span>
                        <span class="s1">!checkAllAliases(key, flags.counts)) {</span>
                        <span class="s1">setArg(key, next);</span>
                        <span class="s1">i++;</span>
                    <span class="s1">}</span>
                    <span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">setArg(key, defaultValue(key));</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(arg.match(/^-[^-]+/) &amp;&amp; !arg.match(negative)) {</span>
                <span class="s1">letters = arg.slice(</span><span class="s4">1</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">).split(</span><span class="s2">''</span><span class="s1">);</span>
                <span class="s1">broken = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s3">for </span><span class="s1">(let j = </span><span class="s4">0</span><span class="s1">; j &lt; letters.length; j++) {</span>
                    <span class="s1">next = arg.slice(j + </span><span class="s4">2</span><span class="s1">);</span>
                    <span class="s3">if </span><span class="s1">(letters[j + </span><span class="s4">1</span><span class="s1">] &amp;&amp; letters[j + </span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'='</span><span class="s1">) {</span>
                        <span class="s1">value = arg.slice(j + </span><span class="s4">3</span><span class="s1">);</span>
                        <span class="s1">key = letters[j];</span>
                        <span class="s3">if </span><span class="s1">(checkAllAliases(key, flags.arrays)) {</span>
                            <span class="s0">// array format = '-f=a b c'</span>
                            <span class="s1">i = eatArray(i, key, args, value);</span>
                        <span class="s1">}</span>
                        <span class="s3">else if </span><span class="s1">(checkAllAliases(key, flags.nargs) !== </span><span class="s3">false</span><span class="s1">) {</span>
                            <span class="s0">// nargs format = '-f=monkey washing cat'</span>
                            <span class="s1">i = eatNargs(i, key, args, value);</span>
                        <span class="s1">}</span>
                        <span class="s3">else </span><span class="s1">{</span>
                            <span class="s1">setArg(key, value);</span>
                        <span class="s1">}</span>
                        <span class="s1">broken = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s3">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(next === </span><span class="s2">'-'</span><span class="s1">) {</span>
                        <span class="s1">setArg(letters[j], next);</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s0">// current letter is an alphabetic character and next value is a number</span>
                    <span class="s3">if </span><span class="s1">(/[A-Za-z]/.test(letters[j]) &amp;&amp;</span>
                        <span class="s1">/^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) &amp;&amp;</span>
                        <span class="s1">checkAllAliases(next, flags.bools) === </span><span class="s3">false</span><span class="s1">) {</span>
                        <span class="s1">setArg(letters[j], next);</span>
                        <span class="s1">broken = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s3">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(letters[j + </span><span class="s4">1</span><span class="s1">] &amp;&amp; letters[j + </span><span class="s4">1</span><span class="s1">].match(/\W/)) {</span>
                        <span class="s1">setArg(letters[j], next);</span>
                        <span class="s1">broken = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s3">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">setArg(letters[j], defaultValue(letters[j]));</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">key = arg.slice(-</span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">];</span>
                <span class="s3">if </span><span class="s1">(!broken &amp;&amp; key !== </span><span class="s2">'-'</span><span class="s1">) {</span>
                    <span class="s3">if </span><span class="s1">(checkAllAliases(key, flags.arrays)) {</span>
                        <span class="s0">// array format = '-f a b c'</span>
                        <span class="s1">i = eatArray(i, key, args);</span>
                    <span class="s1">}</span>
                    <span class="s3">else if </span><span class="s1">(checkAllAliases(key, flags.nargs) !== </span><span class="s3">false</span><span class="s1">) {</span>
                        <span class="s0">// nargs format = '-f a b c'</span>
                        <span class="s0">// should be truthy even if: flags.nargs[key] === 0</span>
                        <span class="s1">i = eatNargs(i, key, args);</span>
                    <span class="s1">}</span>
                    <span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">next = args[i + </span><span class="s4">1</span><span class="s1">];</span>
                        <span class="s3">if </span><span class="s1">(next !== undefined &amp;&amp; (!/^(-|--)[^-]/.test(next) ||</span>
                            <span class="s1">next.match(negative)) &amp;&amp;</span>
                            <span class="s1">!checkAllAliases(key, flags.bools) &amp;&amp;</span>
                            <span class="s1">!checkAllAliases(key, flags.counts)) {</span>
                            <span class="s1">setArg(key, next);</span>
                            <span class="s1">i++;</span>
                        <span class="s1">}</span>
                        <span class="s3">else if </span><span class="s1">(/^(</span><span class="s3">true</span><span class="s1">|</span><span class="s3">false</span><span class="s1">)$/.test(next)) {</span>
                            <span class="s1">setArg(key, next);</span>
                            <span class="s1">i++;</span>
                        <span class="s1">}</span>
                        <span class="s3">else </span><span class="s1">{</span>
                            <span class="s1">setArg(key, defaultValue(key));</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(arg.match(/^-[</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">]$/) &amp;&amp;</span>
                <span class="s1">arg.match(negative) &amp;&amp;</span>
                <span class="s1">checkAllAliases(arg.slice(</span><span class="s4">1</span><span class="s1">), flags.bools)) {</span>
                <span class="s0">// single-digit boolean alias, e.g: xargs -0</span>
                <span class="s1">key = arg.slice(</span><span class="s4">1</span><span class="s1">);</span>
                <span class="s1">setArg(key, defaultValue(key));</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(arg === </span><span class="s2">'--'</span><span class="s1">) {</span>
                <span class="s1">notFlags = args.slice(i + </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(configuration[</span><span class="s2">'halt-at-non-option'</span><span class="s1">]) {</span>
                <span class="s1">notFlags = args.slice(i);</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">{</span>
                <span class="s1">pushPositional(arg);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">// order of precedence:</span>
        <span class="s0">// 1. command line arg</span>
        <span class="s0">// 2. value from env var</span>
        <span class="s0">// 3. value from config file</span>
        <span class="s0">// 4. value from config objects</span>
        <span class="s0">// 5. configured default value</span>
        <span class="s1">applyEnvVars(argv, </span><span class="s3">true</span><span class="s1">); </span><span class="s0">// special case: check env vars that point to config file</span>
        <span class="s1">applyEnvVars(argv, </span><span class="s3">false</span><span class="s1">);</span>
        <span class="s1">setConfig(argv);</span>
        <span class="s1">setConfigObjects();</span>
        <span class="s1">applyDefaultsAndAliases(argv, flags.aliases, defaults, </span><span class="s3">true</span><span class="s1">);</span>
        <span class="s1">applyCoercions(argv);</span>
        <span class="s3">if </span><span class="s1">(configuration[</span><span class="s2">'set-placeholder-key'</span><span class="s1">])</span>
            <span class="s1">setPlaceholderKeys(argv);</span>
        <span class="s0">// for any counts either not in args or without an explicit default, set to 0</span>
        <span class="s1">Object.keys(flags.counts).forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
            <span class="s3">if </span><span class="s1">(!hasKey(argv, key.split(</span><span class="s2">'.'</span><span class="s1">)))</span>
                <span class="s1">setArg(key, </span><span class="s4">0</span><span class="s1">);</span>
        <span class="s1">});</span>
        <span class="s0">// '--' defaults to undefined.</span>
        <span class="s3">if </span><span class="s1">(notFlagsOption &amp;&amp; notFlags.length)</span>
            <span class="s1">argv[notFlagsArgv] = [];</span>
        <span class="s1">notFlags.forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
            <span class="s1">argv[notFlagsArgv].push(key);</span>
        <span class="s1">});</span>
        <span class="s3">if </span><span class="s1">(configuration[</span><span class="s2">'camel-case-expansion'</span><span class="s1">] &amp;&amp; configuration[</span><span class="s2">'strip-dashed'</span><span class="s1">]) {</span>
            <span class="s1">Object.keys(argv).filter(key =&gt; key !== </span><span class="s2">'--' </span><span class="s1">&amp;&amp; key.includes(</span><span class="s2">'-'</span><span class="s1">)).forEach(key =&gt; {</span>
                <span class="s3">delete </span><span class="s1">argv[key];</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(configuration[</span><span class="s2">'strip-aliased'</span><span class="s1">]) {</span>
            <span class="s1">;</span>
            <span class="s1">[].concat(...Object.keys(aliases).map(k =&gt; aliases[k])).forEach(alias =&gt; {</span>
                <span class="s3">if </span><span class="s1">(configuration[</span><span class="s2">'camel-case-expansion'</span><span class="s1">] &amp;&amp; alias.includes(</span><span class="s2">'-'</span><span class="s1">)) {</span>
                    <span class="s3">delete </span><span class="s1">argv[alias.split(</span><span class="s2">'.'</span><span class="s1">).map(prop =&gt; camelCase(prop)).join(</span><span class="s2">'.'</span><span class="s1">)];</span>
                <span class="s1">}</span>
                <span class="s3">delete </span><span class="s1">argv[alias];</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s0">// Push argument into positional array, applying numeric coercion:</span>
        <span class="s3">function </span><span class="s1">pushPositional(arg) {</span>
            <span class="s1">const maybeCoercedNumber = maybeCoerceNumber(</span><span class="s2">'_'</span><span class="s1">, arg);</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">maybeCoercedNumber === </span><span class="s2">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">maybeCoercedNumber === </span><span class="s2">'number'</span><span class="s1">) {</span>
                <span class="s1">argv._.push(maybeCoercedNumber);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">// how many arguments should we consume, based</span>
        <span class="s0">// on the nargs option?</span>
        <span class="s3">function </span><span class="s1">eatNargs(i, key, args, argAfterEqualSign) {</span>
            <span class="s1">let ii;</span>
            <span class="s1">let toEat = checkAllAliases(key, flags.nargs);</span>
            <span class="s0">// NaN has a special meaning for the array type, indicating that one or</span>
            <span class="s0">// more values are expected.</span>
            <span class="s1">toEat = </span><span class="s3">typeof </span><span class="s1">toEat !== </span><span class="s2">'number' </span><span class="s1">|| isNaN(toEat) ? </span><span class="s4">1 </span><span class="s1">: toEat;</span>
            <span class="s3">if </span><span class="s1">(toEat === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s3">if </span><span class="s1">(!isUndefined(argAfterEqualSign)) {</span>
                    <span class="s1">error = Error(__(</span><span class="s2">'Argument unexpected for: %s'</span><span class="s1">, key));</span>
                <span class="s1">}</span>
                <span class="s1">setArg(key, defaultValue(key));</span>
                <span class="s3">return </span><span class="s1">i;</span>
            <span class="s1">}</span>
            <span class="s1">let available = isUndefined(argAfterEqualSign) ? </span><span class="s4">0 </span><span class="s1">: </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(configuration[</span><span class="s2">'nargs-eats-options'</span><span class="s1">]) {</span>
                <span class="s0">// classic behavior, yargs eats positional and dash arguments.</span>
                <span class="s3">if </span><span class="s1">(args.length - (i + </span><span class="s4">1</span><span class="s1">) + available &lt; toEat) {</span>
                    <span class="s1">error = Error(__(</span><span class="s2">'Not enough arguments following: %s'</span><span class="s1">, key));</span>
                <span class="s1">}</span>
                <span class="s1">available = toEat;</span>
            <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">{</span>
                <span class="s0">// nargs will not consume flag arguments, e.g., -abc, --foo,</span>
                <span class="s0">// and terminates when one is observed.</span>
                <span class="s3">for </span><span class="s1">(ii = i + </span><span class="s4">1</span><span class="s1">; ii &lt; args.length; ii++) {</span>
                    <span class="s3">if </span><span class="s1">(!args[ii].match(/^-[^</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii]))</span>
                        <span class="s1">available++;</span>
                    <span class="s3">else</span>
                        <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(available &lt; toEat)</span>
                    <span class="s1">error = Error(__(</span><span class="s2">'Not enough arguments following: %s'</span><span class="s1">, key));</span>
            <span class="s1">}</span>
            <span class="s1">let consumed = Math.min(available, toEat);</span>
            <span class="s3">if </span><span class="s1">(!isUndefined(argAfterEqualSign) &amp;&amp; consumed &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">setArg(key, argAfterEqualSign);</span>
                <span class="s1">consumed--;</span>
            <span class="s1">}</span>
            <span class="s3">for </span><span class="s1">(ii = i + </span><span class="s4">1</span><span class="s1">; ii &lt; (consumed + i + </span><span class="s4">1</span><span class="s1">); ii++) {</span>
                <span class="s1">setArg(key, args[ii]);</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">(i + consumed);</span>
        <span class="s1">}</span>
        <span class="s0">// if an option is an array, eat all non-hyphenated arguments</span>
        <span class="s0">// following it... YUM!</span>
        <span class="s0">// e.g., --foo apple banana cat becomes [&quot;apple&quot;, &quot;banana&quot;, &quot;cat&quot;]</span>
        <span class="s3">function </span><span class="s1">eatArray(i, key, args, argAfterEqualSign) {</span>
            <span class="s1">let argsToSet = [];</span>
            <span class="s1">let next = argAfterEqualSign || args[i + </span><span class="s4">1</span><span class="s1">];</span>
            <span class="s0">// If both array and nargs are configured, enforce the nargs count:</span>
            <span class="s1">const nargsCount = checkAllAliases(key, flags.nargs);</span>
            <span class="s3">if </span><span class="s1">(checkAllAliases(key, flags.bools) &amp;&amp; !(/^(</span><span class="s3">true</span><span class="s1">|</span><span class="s3">false</span><span class="s1">)$/.test(next))) {</span>
                <span class="s1">argsToSet.push(</span><span class="s3">true</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(isUndefined(next) ||</span>
                <span class="s1">(isUndefined(argAfterEqualSign) &amp;&amp; /^-/.test(next) &amp;&amp; !negative.test(next) &amp;&amp; !isUnknownOptionAsArg(next))) {</span>
                <span class="s0">// for keys without value ==&gt; argsToSet remains an empty []</span>
                <span class="s0">// set user default value, if available</span>
                <span class="s3">if </span><span class="s1">(defaults[key] !== undefined) {</span>
                    <span class="s1">const defVal = defaults[key];</span>
                    <span class="s1">argsToSet = Array.isArray(defVal) ? defVal : [defVal];</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">{</span>
                <span class="s0">// value in --option=value is eaten as is</span>
                <span class="s3">if </span><span class="s1">(!isUndefined(argAfterEqualSign)) {</span>
                    <span class="s1">argsToSet.push(processValue(key, argAfterEqualSign, </span><span class="s3">true</span><span class="s1">));</span>
                <span class="s1">}</span>
                <span class="s3">for </span><span class="s1">(let ii = i + </span><span class="s4">1</span><span class="s1">; ii &lt; args.length; ii++) {</span>
                    <span class="s3">if </span><span class="s1">((!configuration[</span><span class="s2">'greedy-arrays'</span><span class="s1">] &amp;&amp; argsToSet.length &gt; </span><span class="s4">0</span><span class="s1">) ||</span>
                        <span class="s1">(nargsCount &amp;&amp; </span><span class="s3">typeof </span><span class="s1">nargsCount === </span><span class="s2">'number' </span><span class="s1">&amp;&amp; argsToSet.length &gt;= nargsCount))</span>
                        <span class="s3">break</span><span class="s1">;</span>
                    <span class="s1">next = args[ii];</span>
                    <span class="s3">if </span><span class="s1">(/^-/.test(next) &amp;&amp; !negative.test(next) &amp;&amp; !isUnknownOptionAsArg(next))</span>
                        <span class="s3">break</span><span class="s1">;</span>
                    <span class="s1">i = ii;</span>
                    <span class="s1">argsToSet.push(processValue(key, next, inputIsString));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">// If both array and nargs are configured, create an error if less than</span>
            <span class="s0">// nargs positionals were found. NaN has special meaning, indicating</span>
            <span class="s0">// that at least one value is required (more are okay).</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">nargsCount === </span><span class="s2">'number' </span><span class="s1">&amp;&amp; ((nargsCount &amp;&amp; argsToSet.length &lt; nargsCount) ||</span>
                <span class="s1">(isNaN(nargsCount) &amp;&amp; argsToSet.length === </span><span class="s4">0</span><span class="s1">))) {</span>
                <span class="s1">error = Error(__(</span><span class="s2">'Not enough arguments following: %s'</span><span class="s1">, key));</span>
            <span class="s1">}</span>
            <span class="s1">setArg(key, argsToSet);</span>
            <span class="s3">return </span><span class="s1">i;</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">setArg(key, val, shouldStripQuotes = inputIsString) {</span>
            <span class="s3">if </span><span class="s1">(/-/.test(key) &amp;&amp; configuration[</span><span class="s2">'camel-case-expansion'</span><span class="s1">]) {</span>
                <span class="s1">const alias = key.split(</span><span class="s2">'.'</span><span class="s1">).map(</span><span class="s3">function </span><span class="s1">(prop) {</span>
                    <span class="s3">return </span><span class="s1">camelCase(prop);</span>
                <span class="s1">}).join(</span><span class="s2">'.'</span><span class="s1">);</span>
                <span class="s1">addNewAlias(key, alias);</span>
            <span class="s1">}</span>
            <span class="s1">const value = processValue(key, val, shouldStripQuotes);</span>
            <span class="s1">const splitKey = key.split(</span><span class="s2">'.'</span><span class="s1">);</span>
            <span class="s1">setKey(argv, splitKey, value);</span>
            <span class="s0">// handle populating aliases of the full key</span>
            <span class="s3">if </span><span class="s1">(flags.aliases[key]) {</span>
                <span class="s1">flags.aliases[key].forEach(</span><span class="s3">function </span><span class="s1">(x) {</span>
                    <span class="s1">const keyProperties = x.split(</span><span class="s2">'.'</span><span class="s1">);</span>
                    <span class="s1">setKey(argv, keyProperties, value);</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s0">// handle populating aliases of the first element of the dot-notation key</span>
            <span class="s3">if </span><span class="s1">(splitKey.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; configuration[</span><span class="s2">'dot-notation'</span><span class="s1">]) {</span>
                <span class="s1">;</span>
                <span class="s1">(flags.aliases[splitKey[</span><span class="s4">0</span><span class="s1">]] || []).forEach(</span><span class="s3">function </span><span class="s1">(x) {</span>
                    <span class="s1">let keyProperties = x.split(</span><span class="s2">'.'</span><span class="s1">);</span>
                    <span class="s0">// expand alias with nested objects in key</span>
                    <span class="s1">const a = [].concat(splitKey);</span>
                    <span class="s1">a.shift(); </span><span class="s0">// nuke the old key.</span>
                    <span class="s1">keyProperties = keyProperties.concat(a);</span>
                    <span class="s0">// populate alias only if is not already an alias of the full key</span>
                    <span class="s0">// (already populated above)</span>
                    <span class="s3">if </span><span class="s1">(!(flags.aliases[key] || []).includes(keyProperties.join(</span><span class="s2">'.'</span><span class="s1">))) {</span>
                        <span class="s1">setKey(argv, keyProperties, value);</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s0">// Set normalize getter and setter when key is in 'normalize' but isn't an array</span>
            <span class="s3">if </span><span class="s1">(checkAllAliases(key, flags.normalize) &amp;&amp; !checkAllAliases(key, flags.arrays)) {</span>
                <span class="s1">const keys = [key].concat(flags.aliases[key] || []);</span>
                <span class="s1">keys.forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
                    <span class="s1">Object.defineProperty(argvReturn, key, {</span>
                        <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
                        <span class="s1">get() {</span>
                            <span class="s3">return </span><span class="s1">val;</span>
                        <span class="s1">},</span>
                        <span class="s1">set(value) {</span>
                            <span class="s1">val = </span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'string' </span><span class="s1">? mixin.normalize(value) : value;</span>
                        <span class="s1">}</span>
                    <span class="s1">});</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">addNewAlias(key, alias) {</span>
            <span class="s3">if </span><span class="s1">(!(flags.aliases[key] &amp;&amp; flags.aliases[key].length)) {</span>
                <span class="s1">flags.aliases[key] = [alias];</span>
                <span class="s1">newAliases[alias] = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(!(flags.aliases[alias] &amp;&amp; flags.aliases[alias].length)) {</span>
                <span class="s1">addNewAlias(alias, key);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">processValue(key, val, shouldStripQuotes) {</span>
            <span class="s0">// strings may be quoted, clean this up as we assign values.</span>
            <span class="s3">if </span><span class="s1">(shouldStripQuotes) {</span>
                <span class="s1">val = stripQuotes(val);</span>
            <span class="s1">}</span>
            <span class="s0">// handle parsing boolean arguments --foo=true --bar false.</span>
            <span class="s3">if </span><span class="s1">(checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">val === </span><span class="s2">'string'</span><span class="s1">)</span>
                    <span class="s1">val = val === </span><span class="s2">'true'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">let value = Array.isArray(val)</span>
                <span class="s1">? val.map(</span><span class="s3">function </span><span class="s1">(v) { </span><span class="s3">return </span><span class="s1">maybeCoerceNumber(key, v); })</span>
                <span class="s1">: maybeCoerceNumber(key, val);</span>
            <span class="s0">// increment a count given as arg (either no value or value parsed as boolean)</span>
            <span class="s3">if </span><span class="s1">(checkAllAliases(key, flags.counts) &amp;&amp; (isUndefined(value) || </span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'boolean'</span><span class="s1">)) {</span>
                <span class="s1">value = increment();</span>
            <span class="s1">}</span>
            <span class="s0">// Set normalized value when key is in 'normalize' and in 'arrays'</span>
            <span class="s3">if </span><span class="s1">(checkAllAliases(key, flags.normalize) &amp;&amp; checkAllAliases(key, flags.arrays)) {</span>
                <span class="s3">if </span><span class="s1">(Array.isArray(val))</span>
                    <span class="s1">value = val.map((val) =&gt; { </span><span class="s3">return </span><span class="s1">mixin.normalize(val); });</span>
                <span class="s3">else</span>
                    <span class="s1">value = mixin.normalize(val);</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">value;</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">maybeCoerceNumber(key, value) {</span>
            <span class="s3">if </span><span class="s1">(!configuration[</span><span class="s2">'parse-positional-numbers'</span><span class="s1">] &amp;&amp; key === </span><span class="s2">'_'</span><span class="s1">)</span>
                <span class="s3">return </span><span class="s1">value;</span>
            <span class="s3">if </span><span class="s1">(!checkAllAliases(key, flags.strings) &amp;&amp; !checkAllAliases(key, flags.bools) &amp;&amp; !Array.isArray(value)) {</span>
                <span class="s1">const shouldCoerceNumber = looksLikeNumber(value) &amp;&amp; configuration[</span><span class="s2">'parse-numbers'</span><span class="s1">] &amp;&amp; (Number.isSafeInteger(Math.floor(parseFloat(`${value}`))));</span>
                <span class="s3">if </span><span class="s1">(shouldCoerceNumber || (!isUndefined(value) &amp;&amp; checkAllAliases(key, flags.numbers))) {</span>
                    <span class="s1">value = Number(value);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">value;</span>
        <span class="s1">}</span>
        <span class="s0">// set args from config.json file, this should be</span>
        <span class="s0">// applied last so that defaults can be applied.</span>
        <span class="s3">function </span><span class="s1">setConfig(argv) {</span>
            <span class="s1">const configLookup = Object.create(</span><span class="s3">null</span><span class="s1">);</span>
            <span class="s0">// expand defaults/aliases, in-case any happen to reference</span>
            <span class="s0">// the config.json file.</span>
            <span class="s1">applyDefaultsAndAliases(configLookup, flags.aliases, defaults);</span>
            <span class="s1">Object.keys(flags.configs).forEach(</span><span class="s3">function </span><span class="s1">(configKey) {</span>
                <span class="s1">const configPath = argv[configKey] || configLookup[configKey];</span>
                <span class="s3">if </span><span class="s1">(configPath) {</span>
                    <span class="s3">try </span><span class="s1">{</span>
                        <span class="s1">let config = </span><span class="s3">null</span><span class="s1">;</span>
                        <span class="s1">const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);</span>
                        <span class="s1">const resolveConfig = flags.configs[configKey];</span>
                        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">resolveConfig === </span><span class="s2">'function'</span><span class="s1">) {</span>
                            <span class="s3">try </span><span class="s1">{</span>
                                <span class="s1">config = resolveConfig(resolvedConfigPath);</span>
                            <span class="s1">}</span>
                            <span class="s3">catch </span><span class="s1">(e) {</span>
                                <span class="s1">config = e;</span>
                            <span class="s1">}</span>
                            <span class="s3">if </span><span class="s1">(config </span><span class="s3">instanceof </span><span class="s1">Error) {</span>
                                <span class="s1">error = config;</span>
                                <span class="s3">return</span><span class="s1">;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s3">else </span><span class="s1">{</span>
                            <span class="s1">config = mixin.require(resolvedConfigPath);</span>
                        <span class="s1">}</span>
                        <span class="s1">setConfigObject(config);</span>
                    <span class="s1">}</span>
                    <span class="s3">catch </span><span class="s1">(ex) {</span>
                        <span class="s0">// Deno will receive a PermissionDenied error if an attempt is</span>
                        <span class="s0">// made to load config without the --allow-read flag:</span>
                        <span class="s3">if </span><span class="s1">(ex.name === </span><span class="s2">'PermissionDenied'</span><span class="s1">)</span>
                            <span class="s1">error = ex;</span>
                        <span class="s3">else if </span><span class="s1">(argv[configKey])</span>
                            <span class="s1">error = Error(__(</span><span class="s2">'Invalid JSON config file: %s'</span><span class="s1">, configPath));</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s0">// set args from config object.</span>
        <span class="s0">// it recursively checks nested objects.</span>
        <span class="s3">function </span><span class="s1">setConfigObject(config, prev) {</span>
            <span class="s1">Object.keys(config).forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
                <span class="s1">const value = config[key];</span>
                <span class="s1">const fullKey = prev ? prev + </span><span class="s2">'.' </span><span class="s1">+ key : key;</span>
                <span class="s0">// if the value is an inner object and we have dot-notation</span>
                <span class="s0">// enabled, treat inner objects in config the same as</span>
                <span class="s0">// heavily nested dot notations (foo.bar.apple).</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; value !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !Array.isArray(value) &amp;&amp; configuration[</span><span class="s2">'dot-notation'</span><span class="s1">]) {</span>
                    <span class="s0">// if the value is an object but not an array, check nested object</span>
                    <span class="s1">setConfigObject(value, fullKey);</span>
                <span class="s1">}</span>
                <span class="s3">else </span><span class="s1">{</span>
                    <span class="s0">// setting arguments via CLI takes precedence over</span>
                    <span class="s0">// values within the config file.</span>
                    <span class="s3">if </span><span class="s1">(!hasKey(argv, fullKey.split(</span><span class="s2">'.'</span><span class="s1">)) || (checkAllAliases(fullKey, flags.arrays) &amp;&amp; configuration[</span><span class="s2">'combine-arrays'</span><span class="s1">])) {</span>
                        <span class="s1">setArg(fullKey, value);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s0">// set all config objects passed in opts</span>
        <span class="s3">function </span><span class="s1">setConfigObjects() {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">configObjects !== </span><span class="s2">'undefined'</span><span class="s1">) {</span>
                <span class="s1">configObjects.forEach(</span><span class="s3">function </span><span class="s1">(configObject) {</span>
                    <span class="s1">setConfigObject(configObject);</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">applyEnvVars(argv, configOnly) {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">envPrefix === </span><span class="s2">'undefined'</span><span class="s1">)</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">const prefix = </span><span class="s3">typeof </span><span class="s1">envPrefix === </span><span class="s2">'string' </span><span class="s1">? envPrefix : </span><span class="s2">''</span><span class="s1">;</span>
            <span class="s1">const env = mixin.env();</span>
            <span class="s1">Object.keys(env).forEach(</span><span class="s3">function </span><span class="s1">(envVar) {</span>
                <span class="s3">if </span><span class="s1">(prefix === </span><span class="s2">'' </span><span class="s1">|| envVar.lastIndexOf(prefix, </span><span class="s4">0</span><span class="s1">) === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s0">// get array of nested keys and convert them to camel case</span>
                    <span class="s1">const keys = envVar.split(</span><span class="s2">'__'</span><span class="s1">).map(</span><span class="s3">function </span><span class="s1">(key, i) {</span>
                        <span class="s3">if </span><span class="s1">(i === </span><span class="s4">0</span><span class="s1">) {</span>
                            <span class="s1">key = key.substring(prefix.length);</span>
                        <span class="s1">}</span>
                        <span class="s3">return </span><span class="s1">camelCase(key);</span>
                    <span class="s1">});</span>
                    <span class="s3">if </span><span class="s1">(((configOnly &amp;&amp; flags.configs[keys.join(</span><span class="s2">'.'</span><span class="s1">)]) || !configOnly) &amp;&amp; !hasKey(argv, keys)) {</span>
                        <span class="s1">setArg(keys.join(</span><span class="s2">'.'</span><span class="s1">), env[envVar]);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">applyCoercions(argv) {</span>
            <span class="s1">let coerce;</span>
            <span class="s1">const applied = </span><span class="s3">new </span><span class="s1">Set();</span>
            <span class="s1">Object.keys(argv).forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
                <span class="s3">if </span><span class="s1">(!applied.has(key)) { </span><span class="s0">// If we haven't already coerced this option via one of its aliases</span>
                    <span class="s1">coerce = checkAllAliases(key, flags.coercions);</span>
                    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">coerce === </span><span class="s2">'function'</span><span class="s1">) {</span>
                        <span class="s3">try </span><span class="s1">{</span>
                            <span class="s1">const value = maybeCoerceNumber(key, coerce(argv[key]));</span>
                            <span class="s1">([].concat(flags.aliases[key] || [], key)).forEach(ali =&gt; {</span>
                                <span class="s1">applied.add(ali);</span>
                                <span class="s1">argv[ali] = value;</span>
                            <span class="s1">});</span>
                        <span class="s1">}</span>
                        <span class="s3">catch </span><span class="s1">(err) {</span>
                            <span class="s1">error = err;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">setPlaceholderKeys(argv) {</span>
            <span class="s1">flags.keys.forEach((key) =&gt; {</span>
                <span class="s0">// don't set placeholder keys for dot notation options 'foo.bar'.</span>
                <span class="s3">if </span><span class="s1">(~key.indexOf(</span><span class="s2">'.'</span><span class="s1">))</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">argv[key] === </span><span class="s2">'undefined'</span><span class="s1">)</span>
                    <span class="s1">argv[key] = undefined;</span>
            <span class="s1">});</span>
            <span class="s3">return </span><span class="s1">argv;</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">applyDefaultsAndAliases(obj, aliases, defaults, canLog = </span><span class="s3">false</span><span class="s1">) {</span>
            <span class="s1">Object.keys(defaults).forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
                <span class="s3">if </span><span class="s1">(!hasKey(obj, key.split(</span><span class="s2">'.'</span><span class="s1">))) {</span>
                    <span class="s1">setKey(obj, key.split(</span><span class="s2">'.'</span><span class="s1">), defaults[key]);</span>
                    <span class="s3">if </span><span class="s1">(canLog)</span>
                        <span class="s1">defaulted[key] = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">(aliases[key] || []).forEach(</span><span class="s3">function </span><span class="s1">(x) {</span>
                        <span class="s3">if </span><span class="s1">(hasKey(obj, x.split(</span><span class="s2">'.'</span><span class="s1">)))</span>
                            <span class="s3">return</span><span class="s1">;</span>
                        <span class="s1">setKey(obj, x.split(</span><span class="s2">'.'</span><span class="s1">), defaults[key]);</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">hasKey(obj, keys) {</span>
            <span class="s1">let o = obj;</span>
            <span class="s3">if </span><span class="s1">(!configuration[</span><span class="s2">'dot-notation'</span><span class="s1">])</span>
                <span class="s1">keys = [keys.join(</span><span class="s2">'.'</span><span class="s1">)];</span>
            <span class="s1">keys.slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">).forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
                <span class="s1">o = (o[key] || {});</span>
            <span class="s1">});</span>
            <span class="s1">const key = keys[keys.length - </span><span class="s4">1</span><span class="s1">];</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">o !== </span><span class="s2">'object'</span><span class="s1">)</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">else</span>
                <span class="s3">return </span><span class="s1">key </span><span class="s3">in </span><span class="s1">o;</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">setKey(obj, keys, value) {</span>
            <span class="s1">let o = obj;</span>
            <span class="s3">if </span><span class="s1">(!configuration[</span><span class="s2">'dot-notation'</span><span class="s1">])</span>
                <span class="s1">keys = [keys.join(</span><span class="s2">'.'</span><span class="s1">)];</span>
            <span class="s1">keys.slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">).forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
                <span class="s0">// TODO(bcoe): in the next major version of yargs, switch to</span>
                <span class="s0">// Object.create(null) for dot notation:</span>
                <span class="s1">key = sanitizeKey(key);</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">o === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; o[key] === undefined) {</span>
                    <span class="s1">o[key] = {};</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">o[key] !== </span><span class="s2">'object' </span><span class="s1">|| Array.isArray(o[key])) {</span>
                    <span class="s0">// ensure that o[key] is an array, and that the last item is an empty object.</span>
                    <span class="s3">if </span><span class="s1">(Array.isArray(o[key])) {</span>
                        <span class="s1">o[key].push({});</span>
                    <span class="s1">}</span>
                    <span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">o[key] = [o[key], {}];</span>
                    <span class="s1">}</span>
                    <span class="s0">// we want to update the empty object at the end of the o[key] array, so set o to that object</span>
                    <span class="s1">o = o[key][o[key].length - </span><span class="s4">1</span><span class="s1">];</span>
                <span class="s1">}</span>
                <span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">o = o[key];</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s0">// TODO(bcoe): in the next major version of yargs, switch to</span>
            <span class="s0">// Object.create(null) for dot notation:</span>
            <span class="s1">const key = sanitizeKey(keys[keys.length - </span><span class="s4">1</span><span class="s1">]);</span>
            <span class="s1">const isTypeArray = checkAllAliases(keys.join(</span><span class="s2">'.'</span><span class="s1">), flags.arrays);</span>
            <span class="s1">const isValueArray = Array.isArray(value);</span>
            <span class="s1">let duplicate = configuration[</span><span class="s2">'duplicate-arguments-array'</span><span class="s1">];</span>
            <span class="s0">// nargs has higher priority than duplicate</span>
            <span class="s3">if </span><span class="s1">(!duplicate &amp;&amp; checkAllAliases(key, flags.nargs)) {</span>
                <span class="s1">duplicate = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">((!isUndefined(o[key]) &amp;&amp; flags.nargs[key] === </span><span class="s4">1</span><span class="s1">) || (Array.isArray(o[key]) &amp;&amp; o[key].length === flags.nargs[key])) {</span>
                    <span class="s1">o[key] = undefined;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(value === increment()) {</span>
                <span class="s1">o[key] = increment(o[key]);</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(Array.isArray(o[key])) {</span>
                <span class="s3">if </span><span class="s1">(duplicate &amp;&amp; isTypeArray &amp;&amp; isValueArray) {</span>
                    <span class="s1">o[key] = configuration[</span><span class="s2">'flatten-duplicate-arrays'</span><span class="s1">] ? o[key].concat(value) : (Array.isArray(o[key][</span><span class="s4">0</span><span class="s1">]) ? o[key] : [o[key]]).concat([value]);</span>
                <span class="s1">}</span>
                <span class="s3">else if </span><span class="s1">(!duplicate &amp;&amp; Boolean(isTypeArray) === Boolean(isValueArray)) {</span>
                    <span class="s1">o[key] = value;</span>
                <span class="s1">}</span>
                <span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">o[key] = o[key].concat([value]);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(o[key] === undefined &amp;&amp; isTypeArray) {</span>
                <span class="s1">o[key] = isValueArray ? value : [value];</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(duplicate &amp;&amp; !(o[key] === undefined ||</span>
                <span class="s1">checkAllAliases(key, flags.counts) ||</span>
                <span class="s1">checkAllAliases(key, flags.bools))) {</span>
                <span class="s1">o[key] = [o[key], value];</span>
            <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">{</span>
                <span class="s1">o[key] = value;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">// extend the aliases list with inferred aliases.</span>
        <span class="s3">function </span><span class="s1">extendAliases(...args) {</span>
            <span class="s1">args.forEach(</span><span class="s3">function </span><span class="s1">(obj) {</span>
                <span class="s1">Object.keys(obj || {}).forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
                    <span class="s0">// short-circuit if we've already added a key</span>
                    <span class="s0">// to the aliases array, for example it might</span>
                    <span class="s0">// exist in both 'opts.default' and 'opts.key'.</span>
                    <span class="s3">if </span><span class="s1">(flags.aliases[key])</span>
                        <span class="s3">return</span><span class="s1">;</span>
                    <span class="s1">flags.aliases[key] = [].concat(aliases[key] || []);</span>
                    <span class="s0">// For &quot;--option-name&quot;, also set argv.optionName</span>
                    <span class="s1">flags.aliases[key].concat(key).forEach(</span><span class="s3">function </span><span class="s1">(x) {</span>
                        <span class="s3">if </span><span class="s1">(/-/.test(x) &amp;&amp; configuration[</span><span class="s2">'camel-case-expansion'</span><span class="s1">]) {</span>
                            <span class="s1">const c = camelCase(x);</span>
                            <span class="s3">if </span><span class="s1">(c !== key &amp;&amp; flags.aliases[key].indexOf(c) === -</span><span class="s4">1</span><span class="s1">) {</span>
                                <span class="s1">flags.aliases[key].push(c);</span>
                                <span class="s1">newAliases[c] = </span><span class="s3">true</span><span class="s1">;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">});</span>
                    <span class="s0">// For &quot;--optionName&quot;, also set argv['option-name']</span>
                    <span class="s1">flags.aliases[key].concat(key).forEach(</span><span class="s3">function </span><span class="s1">(x) {</span>
                        <span class="s3">if </span><span class="s1">(x.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; /[A-Z]/.test(x) &amp;&amp; configuration[</span><span class="s2">'camel-case-expansion'</span><span class="s1">]) {</span>
                            <span class="s1">const c = decamelize(x, </span><span class="s2">'-'</span><span class="s1">);</span>
                            <span class="s3">if </span><span class="s1">(c !== key &amp;&amp; flags.aliases[key].indexOf(c) === -</span><span class="s4">1</span><span class="s1">) {</span>
                                <span class="s1">flags.aliases[key].push(c);</span>
                                <span class="s1">newAliases[c] = </span><span class="s3">true</span><span class="s1">;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">});</span>
                    <span class="s1">flags.aliases[key].forEach(</span><span class="s3">function </span><span class="s1">(x) {</span>
                        <span class="s1">flags.aliases[x] = [key].concat(flags.aliases[key].filter(</span><span class="s3">function </span><span class="s1">(y) {</span>
                            <span class="s3">return </span><span class="s1">x !== y;</span>
                        <span class="s1">}));</span>
                    <span class="s1">});</span>
                <span class="s1">});</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">checkAllAliases(key, flag) {</span>
            <span class="s1">const toCheck = [].concat(flags.aliases[key] || [], key);</span>
            <span class="s1">const keys = Object.keys(flag);</span>
            <span class="s1">const setAlias = toCheck.find(key =&gt; keys.includes(key));</span>
            <span class="s3">return </span><span class="s1">setAlias ? flag[setAlias] : </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">hasAnyFlag(key) {</span>
            <span class="s1">const flagsKeys = Object.keys(flags);</span>
            <span class="s1">const toCheck = [].concat(flagsKeys.map(k =&gt; flags[k]));</span>
            <span class="s3">return </span><span class="s1">toCheck.some(</span><span class="s3">function </span><span class="s1">(flag) {</span>
                <span class="s3">return </span><span class="s1">Array.isArray(flag) ? flag.includes(key) : flag[key];</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">hasFlagsMatching(arg, ...patterns) {</span>
            <span class="s1">const toCheck = [].concat(...patterns);</span>
            <span class="s3">return </span><span class="s1">toCheck.some(</span><span class="s3">function </span><span class="s1">(pattern) {</span>
                <span class="s1">const match = arg.match(pattern);</span>
                <span class="s3">return </span><span class="s1">match &amp;&amp; hasAnyFlag(match[</span><span class="s4">1</span><span class="s1">]);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s0">// based on a simplified version of the short flag group parsing logic</span>
        <span class="s3">function </span><span class="s1">hasAllShortFlags(arg) {</span>
            <span class="s0">// if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group</span>
            <span class="s3">if </span><span class="s1">(arg.match(negative) || !arg.match(/^-[^-]+/)) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">let hasAllFlags = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">let next;</span>
            <span class="s1">const letters = arg.slice(</span><span class="s4">1</span><span class="s1">).split(</span><span class="s2">''</span><span class="s1">);</span>
            <span class="s3">for </span><span class="s1">(let j = </span><span class="s4">0</span><span class="s1">; j &lt; letters.length; j++) {</span>
                <span class="s1">next = arg.slice(j + </span><span class="s4">2</span><span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(!hasAnyFlag(letters[j])) {</span>
                    <span class="s1">hasAllFlags = </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">((letters[j + </span><span class="s4">1</span><span class="s1">] &amp;&amp; letters[j + </span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'='</span><span class="s1">) ||</span>
                    <span class="s1">next === </span><span class="s2">'-' </span><span class="s1">||</span>
                    <span class="s1">(/[A-Za-z]/.test(letters[j]) &amp;&amp; /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) ||</span>
                    <span class="s1">(letters[j + </span><span class="s4">1</span><span class="s1">] &amp;&amp; letters[j + </span><span class="s4">1</span><span class="s1">].match(/\W/))) {</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">hasAllFlags;</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">isUnknownOptionAsArg(arg) {</span>
            <span class="s3">return </span><span class="s1">configuration[</span><span class="s2">'unknown-options-as-args'</span><span class="s1">] &amp;&amp; isUnknownOption(arg);</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">isUnknownOption(arg) {</span>
            <span class="s1">arg = arg.replace(/^-{</span><span class="s4">3</span><span class="s1">,}/, </span><span class="s2">'--'</span><span class="s1">);</span>
            <span class="s0">// ignore negative numbers</span>
            <span class="s3">if </span><span class="s1">(arg.match(negative)) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">// if this is a short option group and all of them are configured, it isn't unknown</span>
            <span class="s3">if </span><span class="s1">(hasAllShortFlags(arg)) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">// e.g. '--count=2'</span>
            <span class="s1">const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;</span>
            <span class="s0">// e.g. '-a' or '--arg'</span>
            <span class="s1">const normalFlag = /^-+([^=]+?)$/;</span>
            <span class="s0">// e.g. '-a-'</span>
            <span class="s1">const flagEndingInHyphen = /^-+([^=]+?)-$/;</span>
            <span class="s0">// e.g. '-abc123'</span>
            <span class="s1">const flagEndingInDigits = /^-+([^=]+?\d+)$/;</span>
            <span class="s0">// e.g. '-a/usr/local'</span>
            <span class="s1">const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;</span>
            <span class="s0">// check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method</span>
            <span class="s3">return </span><span class="s1">!hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);</span>
        <span class="s1">}</span>
        <span class="s0">// make a best effort to pick a default value</span>
        <span class="s0">// for an option based on name and type.</span>
        <span class="s3">function </span><span class="s1">defaultValue(key) {</span>
            <span class="s3">if </span><span class="s1">(!checkAllAliases(key, flags.bools) &amp;&amp;</span>
                <span class="s1">!checkAllAliases(key, flags.counts) &amp;&amp;</span>
                <span class="s1">`${key}` </span><span class="s3">in </span><span class="s1">defaults) {</span>
                <span class="s3">return </span><span class="s1">defaults[key];</span>
            <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">{</span>
                <span class="s3">return </span><span class="s1">defaultForType(guessType(key));</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">// return a default value, given the type of a flag.,</span>
        <span class="s3">function </span><span class="s1">defaultForType(type) {</span>
            <span class="s1">const def = {</span>
                <span class="s1">[DefaultValuesForTypeKey.BOOLEAN]: </span><span class="s3">true</span><span class="s1">,</span>
                <span class="s1">[DefaultValuesForTypeKey.STRING]: </span><span class="s2">''</span><span class="s1">,</span>
                <span class="s1">[DefaultValuesForTypeKey.NUMBER]: undefined,</span>
                <span class="s1">[DefaultValuesForTypeKey.ARRAY]: []</span>
            <span class="s1">};</span>
            <span class="s3">return </span><span class="s1">def[type];</span>
        <span class="s1">}</span>
        <span class="s0">// given a flag, enforce a default type.</span>
        <span class="s3">function </span><span class="s1">guessType(key) {</span>
            <span class="s1">let type = DefaultValuesForTypeKey.BOOLEAN;</span>
            <span class="s3">if </span><span class="s1">(checkAllAliases(key, flags.strings))</span>
                <span class="s1">type = DefaultValuesForTypeKey.STRING;</span>
            <span class="s3">else if </span><span class="s1">(checkAllAliases(key, flags.numbers))</span>
                <span class="s1">type = DefaultValuesForTypeKey.NUMBER;</span>
            <span class="s3">else if </span><span class="s1">(checkAllAliases(key, flags.bools))</span>
                <span class="s1">type = DefaultValuesForTypeKey.BOOLEAN;</span>
            <span class="s3">else if </span><span class="s1">(checkAllAliases(key, flags.arrays))</span>
                <span class="s1">type = DefaultValuesForTypeKey.ARRAY;</span>
            <span class="s3">return </span><span class="s1">type;</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">isUndefined(num) {</span>
            <span class="s3">return </span><span class="s1">num === undefined;</span>
        <span class="s1">}</span>
        <span class="s0">// check user configuration settings for inconsistencies</span>
        <span class="s3">function </span><span class="s1">checkConfiguration() {</span>
            <span class="s0">// count keys should not be set as array/narg</span>
            <span class="s1">Object.keys(flags.counts).find(key =&gt; {</span>
                <span class="s3">if </span><span class="s1">(checkAllAliases(key, flags.arrays)) {</span>
                    <span class="s1">error = Error(__(</span><span class="s2">'Invalid configuration: %s, opts.count excludes opts.array.'</span><span class="s1">, key));</span>
                    <span class="s3">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">else if </span><span class="s1">(checkAllAliases(key, flags.nargs)) {</span>
                    <span class="s1">error = Error(__(</span><span class="s2">'Invalid configuration: %s, opts.count excludes opts.narg.'</span><span class="s1">, key));</span>
                    <span class="s3">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">aliases: Object.assign({}, flags.aliases),</span>
            <span class="s1">argv: Object.assign(argvReturn, argv),</span>
            <span class="s1">configuration: configuration,</span>
            <span class="s1">defaulted: Object.assign({}, defaulted),</span>
            <span class="s1">error: error,</span>
            <span class="s1">newAliases: Object.assign({}, newAliases)</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">// if any aliases reference each other, we should</span>
<span class="s0">// merge them together.</span>
<span class="s3">function </span><span class="s1">combineAliases(aliases) {</span>
    <span class="s1">const aliasArrays = [];</span>
    <span class="s1">const combined = Object.create(</span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">let change = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s0">// turn alias lookup hash {key: ['alias1', 'alias2']} into</span>
    <span class="s0">// a simple array ['key', 'alias1', 'alias2']</span>
    <span class="s1">Object.keys(aliases).forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
        <span class="s1">aliasArrays.push([].concat(aliases[key], key));</span>
    <span class="s1">});</span>
    <span class="s0">// combine arrays until zero changes are</span>
    <span class="s0">// made in an iteration.</span>
    <span class="s3">while </span><span class="s1">(change) {</span>
        <span class="s1">change = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; aliasArrays.length; i++) {</span>
            <span class="s3">for </span><span class="s1">(let ii = i + </span><span class="s4">1</span><span class="s1">; ii &lt; aliasArrays.length; ii++) {</span>
                <span class="s1">const intersect = aliasArrays[i].filter(</span><span class="s3">function </span><span class="s1">(v) {</span>
                    <span class="s3">return </span><span class="s1">aliasArrays[ii].indexOf(v) !== -</span><span class="s4">1</span><span class="s1">;</span>
                <span class="s1">});</span>
                <span class="s3">if </span><span class="s1">(intersect.length) {</span>
                    <span class="s1">aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);</span>
                    <span class="s1">aliasArrays.splice(ii, </span><span class="s4">1</span><span class="s1">);</span>
                    <span class="s1">change = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">// map arrays back to the hash-lookup (de-dupe while</span>
    <span class="s0">// we're at it).</span>
    <span class="s1">aliasArrays.forEach(</span><span class="s3">function </span><span class="s1">(aliasArray) {</span>
        <span class="s1">aliasArray = aliasArray.filter(</span><span class="s3">function </span><span class="s1">(v, i, self) {</span>
            <span class="s3">return </span><span class="s1">self.indexOf(v) === i;</span>
        <span class="s1">});</span>
        <span class="s1">const lastAlias = aliasArray.pop();</span>
        <span class="s3">if </span><span class="s1">(lastAlias !== undefined &amp;&amp; </span><span class="s3">typeof </span><span class="s1">lastAlias === </span><span class="s2">'string'</span><span class="s1">) {</span>
            <span class="s1">combined[lastAlias] = aliasArray;</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s3">return </span><span class="s1">combined;</span>
<span class="s1">}</span>
<span class="s0">// this function should only be called when a count is given as an arg</span>
<span class="s0">// it is NOT called to set a default value</span>
<span class="s0">// thus we can start the count at 1 instead of 0</span>
<span class="s3">function </span><span class="s1">increment(orig) {</span>
    <span class="s3">return </span><span class="s1">orig !== undefined ? orig + </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">// TODO(bcoe): in the next major version of yargs, switch to</span>
<span class="s0">// Object.create(null) for dot notation:</span>
<span class="s3">function </span><span class="s1">sanitizeKey(key) {</span>
    <span class="s3">if </span><span class="s1">(key === </span><span class="s2">'__proto__'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s2">'___proto___'</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">key;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">stripQuotes(val) {</span>
    <span class="s3">return </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">val === </span><span class="s2">'string' </span><span class="s1">&amp;&amp;</span>
        <span class="s1">(val[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">&quot;'&quot; </span><span class="s1">|| val[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">'&quot;'</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">val[val.length - </span><span class="s4">1</span><span class="s1">] === val[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">? val.substring(</span><span class="s4">1</span><span class="s1">, val.length - </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">: val;</span>
<span class="s1">}</span>
</pre>
</body>
</html>
<html>
<head>
<title>statement.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
statement.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= exports.ParseStatementFlag = exports.ParseFunctionFlag = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">_types = require(</span><span class="s0">&quot;../tokenizer/types&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_expression = require(</span><span class="s0">&quot;./expression&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_parseError = require(</span><span class="s0">&quot;../parse-error&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_identifier = require(</span><span class="s0">&quot;../util/identifier&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_scopeflags = require(</span><span class="s0">&quot;../util/scopeflags&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_util = require(</span><span class="s0">&quot;./util&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_productionParameter = require(</span><span class="s0">&quot;../util/production-parameter&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_expressionScope = require(</span><span class="s0">&quot;../util/expression-scope&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_tokenizer = require(</span><span class="s0">&quot;../tokenizer&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_location = require(</span><span class="s0">&quot;../util/location&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_node = require(</span><span class="s0">&quot;./node&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_lval = require(</span><span class="s0">&quot;./lval&quot;</span><span class="s1">);</span>
<span class="s1">const loopLabel = {</span>
    <span class="s1">kind: </span><span class="s0">&quot;loop&quot;</span>
  <span class="s1">},</span>
  <span class="s1">switchLabel = {</span>
    <span class="s1">kind: </span><span class="s0">&quot;switch&quot;</span>
  <span class="s1">};</span>
<span class="s2">var </span><span class="s1">ParseFunctionFlag = {</span>
  <span class="s1">Expression: </span><span class="s3">0</span><span class="s1">,</span>
  <span class="s1">Declaration: </span><span class="s3">1</span><span class="s1">,</span>
  <span class="s1">HangingDeclaration: </span><span class="s3">2</span><span class="s1">,</span>
  <span class="s1">NullableId: </span><span class="s3">4</span><span class="s1">,</span>
  <span class="s1">Async: </span><span class="s3">8</span>
<span class="s1">};</span>
<span class="s1">exports.ParseFunctionFlag = ParseFunctionFlag;</span>
<span class="s2">var </span><span class="s1">ParseStatementFlag = {</span>
  <span class="s1">StatementOnly: </span><span class="s3">0</span><span class="s1">,</span>
  <span class="s1">AllowImportExport: </span><span class="s3">1</span><span class="s1">,</span>
  <span class="s1">AllowDeclaration: </span><span class="s3">2</span><span class="s1">,</span>
  <span class="s1">AllowFunctionDeclaration: </span><span class="s3">4</span><span class="s1">,</span>
  <span class="s1">AllowLabeledFunction: </span><span class="s3">8</span>
<span class="s1">};</span>
<span class="s1">exports.ParseStatementFlag = ParseStatementFlag;</span>
<span class="s1">const loneSurrogate = /[\uD800-\uDFFF]/u;</span>
<span class="s1">const keywordRelationalOperator = /</span><span class="s2">in</span><span class="s1">(?:stanceof)?/y;</span>
<span class="s2">function </span><span class="s1">babel7CompatTokens(tokens, input) {</span>
  <span class="s2">for </span><span class="s1">(let i = </span><span class="s3">0</span><span class="s1">; i &lt; tokens.length; i++) {</span>
    <span class="s1">const token = tokens[i];</span>
    <span class="s1">const {</span>
      <span class="s1">type</span>
    <span class="s1">} = token;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s0">&quot;number&quot;</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(type === </span><span class="s3">136</span><span class="s1">) {</span>
          <span class="s1">const {</span>
            <span class="s1">loc,</span>
            <span class="s1">start,</span>
            <span class="s1">value,</span>
            <span class="s1">end</span>
          <span class="s1">} = token;</span>
          <span class="s1">const hashEndPos = start + </span><span class="s3">1</span><span class="s1">;</span>
          <span class="s1">const hashEndLoc = (</span><span class="s3">0</span><span class="s1">, _location.createPositionWithColumnOffset)(loc.start, </span><span class="s3">1</span><span class="s1">);</span>
          <span class="s1">tokens.splice(i, </span><span class="s3">1</span><span class="s1">, </span><span class="s2">new </span><span class="s1">_tokenizer.Token({</span>
            <span class="s1">type: (</span><span class="s3">0</span><span class="s1">, _types.getExportedToken)(</span><span class="s3">27</span><span class="s1">),</span>
            <span class="s1">value: </span><span class="s0">&quot;#&quot;</span><span class="s1">,</span>
            <span class="s1">start: start,</span>
            <span class="s1">end: hashEndPos,</span>
            <span class="s1">startLoc: loc.start,</span>
            <span class="s1">endLoc: hashEndLoc</span>
          <span class="s1">}), </span><span class="s2">new </span><span class="s1">_tokenizer.Token({</span>
            <span class="s1">type: (</span><span class="s3">0</span><span class="s1">, _types.getExportedToken)(</span><span class="s3">130</span><span class="s1">),</span>
            <span class="s1">value: value,</span>
            <span class="s1">start: hashEndPos,</span>
            <span class="s1">end: end,</span>
            <span class="s1">startLoc: hashEndLoc,</span>
            <span class="s1">endLoc: loc.end</span>
          <span class="s1">}));</span>
          <span class="s1">i++;</span>
          <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _types.tokenIsTemplate)(type)) {</span>
          <span class="s1">const {</span>
            <span class="s1">loc,</span>
            <span class="s1">start,</span>
            <span class="s1">value,</span>
            <span class="s1">end</span>
          <span class="s1">} = token;</span>
          <span class="s1">const backquoteEnd = start + </span><span class="s3">1</span><span class="s1">;</span>
          <span class="s1">const backquoteEndLoc = (</span><span class="s3">0</span><span class="s1">, _location.createPositionWithColumnOffset)(loc.start, </span><span class="s3">1</span><span class="s1">);</span>
          <span class="s1">let startToken;</span>
          <span class="s2">if </span><span class="s1">(input.charCodeAt(start) === </span><span class="s3">96</span><span class="s1">) {</span>
            <span class="s1">startToken = </span><span class="s2">new </span><span class="s1">_tokenizer.Token({</span>
              <span class="s1">type: (</span><span class="s3">0</span><span class="s1">, _types.getExportedToken)(</span><span class="s3">22</span><span class="s1">),</span>
              <span class="s1">value: </span><span class="s0">&quot;`&quot;</span><span class="s1">,</span>
              <span class="s1">start: start,</span>
              <span class="s1">end: backquoteEnd,</span>
              <span class="s1">startLoc: loc.start,</span>
              <span class="s1">endLoc: backquoteEndLoc</span>
            <span class="s1">});</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">startToken = </span><span class="s2">new </span><span class="s1">_tokenizer.Token({</span>
              <span class="s1">type: (</span><span class="s3">0</span><span class="s1">, _types.getExportedToken)(</span><span class="s3">8</span><span class="s1">),</span>
              <span class="s1">value: </span><span class="s0">&quot;}&quot;</span><span class="s1">,</span>
              <span class="s1">start: start,</span>
              <span class="s1">end: backquoteEnd,</span>
              <span class="s1">startLoc: loc.start,</span>
              <span class="s1">endLoc: backquoteEndLoc</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
          <span class="s1">let templateValue, templateElementEnd, templateElementEndLoc, endToken;</span>
          <span class="s2">if </span><span class="s1">(type === </span><span class="s3">24</span><span class="s1">) {</span>
            <span class="s1">templateElementEnd = end - </span><span class="s3">1</span><span class="s1">;</span>
            <span class="s1">templateElementEndLoc = (</span><span class="s3">0</span><span class="s1">, _location.createPositionWithColumnOffset)(loc.end, -</span><span class="s3">1</span><span class="s1">);</span>
            <span class="s1">templateValue = value === </span><span class="s2">null </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: value.slice(</span><span class="s3">1</span><span class="s1">, -</span><span class="s3">1</span><span class="s1">);</span>
            <span class="s1">endToken = </span><span class="s2">new </span><span class="s1">_tokenizer.Token({</span>
              <span class="s1">type: (</span><span class="s3">0</span><span class="s1">, _types.getExportedToken)(</span><span class="s3">22</span><span class="s1">),</span>
              <span class="s1">value: </span><span class="s0">&quot;`&quot;</span><span class="s1">,</span>
              <span class="s1">start: templateElementEnd,</span>
              <span class="s1">end: end,</span>
              <span class="s1">startLoc: templateElementEndLoc,</span>
              <span class="s1">endLoc: loc.end</span>
            <span class="s1">});</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">templateElementEnd = end - </span><span class="s3">2</span><span class="s1">;</span>
            <span class="s1">templateElementEndLoc = (</span><span class="s3">0</span><span class="s1">, _location.createPositionWithColumnOffset)(loc.end, -</span><span class="s3">2</span><span class="s1">);</span>
            <span class="s1">templateValue = value === </span><span class="s2">null </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: value.slice(</span><span class="s3">1</span><span class="s1">, -</span><span class="s3">2</span><span class="s1">);</span>
            <span class="s1">endToken = </span><span class="s2">new </span><span class="s1">_tokenizer.Token({</span>
              <span class="s1">type: (</span><span class="s3">0</span><span class="s1">, _types.getExportedToken)(</span><span class="s3">23</span><span class="s1">),</span>
              <span class="s1">value: </span><span class="s0">&quot;${&quot;</span><span class="s1">,</span>
              <span class="s1">start: templateElementEnd,</span>
              <span class="s1">end: end,</span>
              <span class="s1">startLoc: templateElementEndLoc,</span>
              <span class="s1">endLoc: loc.end</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
          <span class="s1">tokens.splice(i, </span><span class="s3">1</span><span class="s1">, startToken, </span><span class="s2">new </span><span class="s1">_tokenizer.Token({</span>
            <span class="s1">type: (</span><span class="s3">0</span><span class="s1">, _types.getExportedToken)(</span><span class="s3">20</span><span class="s1">),</span>
            <span class="s1">value: templateValue,</span>
            <span class="s1">start: backquoteEnd,</span>
            <span class="s1">end: templateElementEnd,</span>
            <span class="s1">startLoc: backquoteEndLoc,</span>
            <span class="s1">endLoc: templateElementEndLoc</span>
          <span class="s1">}), endToken);</span>
          <span class="s1">i += </span><span class="s3">2</span><span class="s1">;</span>
          <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">token.type = (</span><span class="s3">0</span><span class="s1">, _types.getExportedToken)(type);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">tokens;</span>
<span class="s1">}</span>
<span class="s1">class StatementParser extends _expression.</span><span class="s2">default </span><span class="s1">{</span>
  <span class="s1">parseTopLevel(file, program) {</span>
    <span class="s1">file.program = </span><span class="s2">this</span><span class="s1">.parseProgram(program);</span>
    <span class="s1">file.comments = </span><span class="s2">this</span><span class="s1">.state.comments;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.tokens) {</span>
      <span class="s1">file.tokens = babel7CompatTokens(</span><span class="s2">this</span><span class="s1">.tokens, </span><span class="s2">this</span><span class="s1">.input);</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(file, </span><span class="s0">&quot;File&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseProgram(program, end = </span><span class="s3">137</span><span class="s1">, sourceType = </span><span class="s2">this</span><span class="s1">.options.sourceType) {</span>
    <span class="s1">program.sourceType = sourceType;</span>
    <span class="s1">program.interpreter = </span><span class="s2">this</span><span class="s1">.parseInterpreterDirective();</span>
    <span class="s2">this</span><span class="s1">.parseBlockBody(program, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">true</span><span class="s1">, end);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.inModule &amp;&amp; !</span><span class="s2">this</span><span class="s1">.options.allowUndeclaredExports &amp;&amp; </span><span class="s2">this</span><span class="s1">.scope.undefinedExports.size &gt; </span><span class="s3">0</span><span class="s1">) {</span>
      <span class="s2">for </span><span class="s1">(const [localName, at] of Array.from(</span><span class="s2">this</span><span class="s1">.scope.undefinedExports)) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ModuleExportUndefined, {</span>
          <span class="s1">at,</span>
          <span class="s1">localName</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">let finishedProgram;</span>
    <span class="s2">if </span><span class="s1">(end === </span><span class="s3">137</span><span class="s1">) {</span>
      <span class="s1">finishedProgram = </span><span class="s2">this</span><span class="s1">.finishNode(program, </span><span class="s0">&quot;Program&quot;</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">finishedProgram = </span><span class="s2">this</span><span class="s1">.finishNodeAt(program, </span><span class="s0">&quot;Program&quot;</span><span class="s1">, (</span><span class="s3">0</span><span class="s1">, _location.createPositionWithColumnOffset)(</span><span class="s2">this</span><span class="s1">.state.startLoc, -</span><span class="s3">1</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">finishedProgram;</span>
  <span class="s1">}</span>
  <span class="s1">stmtToDirective(stmt) {</span>
    <span class="s1">const directive = stmt;</span>
    <span class="s1">directive.type = </span><span class="s0">&quot;Directive&quot;</span><span class="s1">;</span>
    <span class="s1">directive.value = directive.expression;</span>
    <span class="s2">delete </span><span class="s1">directive.expression;</span>
    <span class="s1">const directiveLiteral = directive.value;</span>
    <span class="s1">const expressionValue = directiveLiteral.value;</span>
    <span class="s1">const raw = </span><span class="s2">this</span><span class="s1">.input.slice(directiveLiteral.start, directiveLiteral.end);</span>
    <span class="s1">const val = directiveLiteral.value = raw.slice(</span><span class="s3">1</span><span class="s1">, -</span><span class="s3">1</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.addExtra(directiveLiteral, </span><span class="s0">&quot;raw&quot;</span><span class="s1">, raw);</span>
    <span class="s2">this</span><span class="s1">.addExtra(directiveLiteral, </span><span class="s0">&quot;rawValue&quot;</span><span class="s1">, val);</span>
    <span class="s2">this</span><span class="s1">.addExtra(directiveLiteral, </span><span class="s0">&quot;expressionValue&quot;</span><span class="s1">, expressionValue);</span>
    <span class="s1">directiveLiteral.type = </span><span class="s0">&quot;DirectiveLiteral&quot;</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">directive;</span>
  <span class="s1">}</span>
  <span class="s1">parseInterpreterDirective() {</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">28</span><span class="s1">)) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s1">node.value = </span><span class="s2">this</span><span class="s1">.state.value;</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;InterpreterDirective&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">isLet() {</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">99</span><span class="s1">)) {</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.hasFollowingBindingAtom();</span>
  <span class="s1">}</span>
  <span class="s1">chStartsBindingIdentifier(ch, pos) {</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _identifier.isIdentifierStart)(ch)) {</span>
      <span class="s1">keywordRelationalOperator.lastIndex = pos;</span>
      <span class="s2">if </span><span class="s1">(keywordRelationalOperator.test(</span><span class="s2">this</span><span class="s1">.input)) {</span>
        <span class="s1">const endCh = </span><span class="s2">this</span><span class="s1">.codePointAtPos(keywordRelationalOperator.lastIndex);</span>
        <span class="s2">if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, _identifier.isIdentifierChar)(endCh) &amp;&amp; endCh !== </span><span class="s3">92</span><span class="s1">) {</span>
          <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ch === </span><span class="s3">92</span><span class="s1">) {</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">chStartsBindingPattern(ch) {</span>
    <span class="s2">return </span><span class="s1">ch === </span><span class="s3">91 </span><span class="s1">|| ch === </span><span class="s3">123</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">hasFollowingBindingAtom() {</span>
    <span class="s1">const next = </span><span class="s2">this</span><span class="s1">.nextTokenStart();</span>
    <span class="s1">const nextCh = </span><span class="s2">this</span><span class="s1">.codePointAtPos(next);</span>
    <span class="s2">return this</span><span class="s1">.chStartsBindingPattern(nextCh) || </span><span class="s2">this</span><span class="s1">.chStartsBindingIdentifier(nextCh, next);</span>
  <span class="s1">}</span>
  <span class="s1">hasInLineFollowingBindingIdentifier() {</span>
    <span class="s1">const next = </span><span class="s2">this</span><span class="s1">.nextTokenInLineStart();</span>
    <span class="s1">const nextCh = </span><span class="s2">this</span><span class="s1">.codePointAtPos(next);</span>
    <span class="s2">return this</span><span class="s1">.chStartsBindingIdentifier(nextCh, next);</span>
  <span class="s1">}</span>
  <span class="s1">startsUsingForOf() {</span>
    <span class="s1">const {</span>
      <span class="s1">type,</span>
      <span class="s1">containsEsc</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.lookahead();</span>
    <span class="s2">if </span><span class="s1">(type === </span><span class="s3">101 </span><span class="s1">&amp;&amp; !containsEsc) {</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _types.tokenIsIdentifier)(type) &amp;&amp; !</span><span class="s2">this</span><span class="s1">.hasFollowingLineBreak()) {</span>
      <span class="s2">this</span><span class="s1">.expectPlugin(</span><span class="s0">&quot;explicitResourceManagement&quot;</span><span class="s1">);</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">startsAwaitUsing() {</span>
    <span class="s1">let next = </span><span class="s2">this</span><span class="s1">.nextTokenInLineStart();</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isUnparsedContextual(next, </span><span class="s0">&quot;using&quot;</span><span class="s1">)) {</span>
      <span class="s1">next = </span><span class="s2">this</span><span class="s1">.nextTokenInLineStartSince(next + </span><span class="s3">5</span><span class="s1">);</span>
      <span class="s1">const nextCh = </span><span class="s2">this</span><span class="s1">.codePointAtPos(next);</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.chStartsBindingIdentifier(nextCh, next)) {</span>
        <span class="s2">this</span><span class="s1">.expectPlugin(</span><span class="s0">&quot;explicitResourceManagement&quot;</span><span class="s1">);</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">parseModuleItem() {</span>
    <span class="s2">return this</span><span class="s1">.parseStatementLike(ParseStatementFlag.AllowImportExport | ParseStatementFlag.AllowDeclaration | ParseStatementFlag.AllowFunctionDeclaration | ParseStatementFlag.AllowLabeledFunction);</span>
  <span class="s1">}</span>
  <span class="s1">parseStatementListItem() {</span>
    <span class="s2">return this</span><span class="s1">.parseStatementLike(ParseStatementFlag.AllowDeclaration | ParseStatementFlag.AllowFunctionDeclaration | (!</span><span class="s2">this</span><span class="s1">.options.annexB || </span><span class="s2">this</span><span class="s1">.state.strict ? </span><span class="s3">0 </span><span class="s1">: ParseStatementFlag.AllowLabeledFunction));</span>
  <span class="s1">}</span>
  <span class="s1">parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s1">let flags = ParseStatementFlag.StatementOnly;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.annexB &amp;&amp; !</span><span class="s2">this</span><span class="s1">.state.strict) {</span>
      <span class="s1">flags |= ParseStatementFlag.AllowFunctionDeclaration;</span>
      <span class="s2">if </span><span class="s1">(allowLabeledFunction) {</span>
        <span class="s1">flags |= ParseStatementFlag.AllowLabeledFunction;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseStatementLike(flags);</span>
  <span class="s1">}</span>
  <span class="s1">parseStatement() {</span>
    <span class="s2">return this</span><span class="s1">.parseStatementLike(ParseStatementFlag.StatementOnly);</span>
  <span class="s1">}</span>
  <span class="s1">parseStatementLike(flags) {</span>
    <span class="s1">let decorators = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">26</span><span class="s1">)) {</span>
      <span class="s1">decorators = </span><span class="s2">this</span><span class="s1">.parseDecorators(</span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseStatementContent(flags, decorators);</span>
  <span class="s1">}</span>
  <span class="s1">parseStatementContent(flags, decorators) {</span>
    <span class="s1">const starttype = </span><span class="s2">this</span><span class="s1">.state.type;</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s1">const allowDeclaration = !!(flags &amp; ParseStatementFlag.AllowDeclaration);</span>
    <span class="s1">const allowFunctionDeclaration = !!(flags &amp; ParseStatementFlag.AllowFunctionDeclaration);</span>
    <span class="s1">const topLevel = flags &amp; ParseStatementFlag.AllowImportExport;</span>
    <span class="s2">switch </span><span class="s1">(starttype) {</span>
      <span class="s2">case </span><span class="s3">60</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseBreakContinueStatement(node, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s2">case </span><span class="s3">63</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseBreakContinueStatement(node, </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s2">case </span><span class="s3">64</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseDebuggerStatement(node);</span>
      <span class="s2">case </span><span class="s3">90</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseDoWhileStatement(node);</span>
      <span class="s2">case </span><span class="s3">91</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseForStatement(node);</span>
      <span class="s2">case </span><span class="s3">68</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.lookaheadCharCode() === </span><span class="s3">46</span><span class="s1">) </span><span class="s2">break</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(!allowFunctionDeclaration) {</span>
          <span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.state.strict ? _parseError.Errors.StrictFunction : </span><span class="s2">this</span><span class="s1">.options.annexB ? _parseError.Errors.SloppyFunctionAnnexB : _parseError.Errors.SloppyFunction, {</span>
            <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.parseFunctionStatement(node, </span><span class="s2">false</span><span class="s1">, !allowDeclaration &amp;&amp; allowFunctionDeclaration);</span>
      <span class="s2">case </span><span class="s3">80</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">(!allowDeclaration) </span><span class="s2">this</span><span class="s1">.unexpected();</span>
        <span class="s2">return this</span><span class="s1">.parseClass(</span><span class="s2">this</span><span class="s1">.maybeTakeDecorators(decorators, node), </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s2">case </span><span class="s3">69</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseIfStatement(node);</span>
      <span class="s2">case </span><span class="s3">70</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseReturnStatement(node);</span>
      <span class="s2">case </span><span class="s3">71</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseSwitchStatement(node);</span>
      <span class="s2">case </span><span class="s3">72</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseThrowStatement(node);</span>
      <span class="s2">case </span><span class="s3">73</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseTryStatement(node);</span>
      <span class="s2">case </span><span class="s3">96</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.state.containsEsc &amp;&amp; </span><span class="s2">this</span><span class="s1">.startsAwaitUsing()) {</span>
          <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isAwaitAllowed()) {</span>
            <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.AwaitUsingNotInAsyncContext, {</span>
              <span class="s1">at: node</span>
            <span class="s1">});</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!allowDeclaration) {</span>
            <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnexpectedLexicalDeclaration, {</span>
              <span class="s1">at: node</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
          <span class="s2">this</span><span class="s1">.next();</span>
          <span class="s2">return this</span><span class="s1">.parseVarStatement(node, </span><span class="s0">&quot;await using&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s3">105</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.state.containsEsc || !</span><span class="s2">this</span><span class="s1">.hasInLineFollowingBindingIdentifier()) {</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.expectPlugin(</span><span class="s0">&quot;explicitResourceManagement&quot;</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.scope.inModule &amp;&amp; </span><span class="s2">this</span><span class="s1">.scope.inTopLevel) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnexpectedUsingDeclaration, {</span>
            <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
          <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!allowDeclaration) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnexpectedLexicalDeclaration, {</span>
            <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.parseVarStatement(node, </span><span class="s0">&quot;using&quot;</span><span class="s1">);</span>
      <span class="s2">case </span><span class="s3">99</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.state.containsEsc) {</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s1">const next = </span><span class="s2">this</span><span class="s1">.nextTokenStart();</span>
          <span class="s1">const nextCh = </span><span class="s2">this</span><span class="s1">.codePointAtPos(next);</span>
          <span class="s2">if </span><span class="s1">(nextCh !== </span><span class="s3">91</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(!allowDeclaration &amp;&amp; </span><span class="s2">this</span><span class="s1">.hasFollowingLineBreak()) </span><span class="s2">break</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.chStartsBindingIdentifier(nextCh, next) &amp;&amp; nextCh !== </span><span class="s3">123</span><span class="s1">) {</span>
              <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">75</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(!allowDeclaration) {</span>
            <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnexpectedLexicalDeclaration, {</span>
              <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">74</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">const kind = </span><span class="s2">this</span><span class="s1">.state.value;</span>
          <span class="s2">return this</span><span class="s1">.parseVarStatement(node, kind);</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">92</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseWhileStatement(node);</span>
      <span class="s2">case </span><span class="s3">76</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseWithStatement(node);</span>
      <span class="s2">case </span><span class="s3">5</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseBlock();</span>
      <span class="s2">case </span><span class="s3">13</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseEmptyStatement(node);</span>
      <span class="s2">case </span><span class="s3">83</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">const nextTokenCharCode = </span><span class="s2">this</span><span class="s1">.lookaheadCharCode();</span>
          <span class="s2">if </span><span class="s1">(nextTokenCharCode === </span><span class="s3">40 </span><span class="s1">|| nextTokenCharCode === </span><span class="s3">46</span><span class="s1">) {</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">82</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.options.allowImportExportEverywhere &amp;&amp; !topLevel) {</span>
            <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnexpectedImportExport, {</span>
              <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
          <span class="s2">this</span><span class="s1">.next();</span>
          <span class="s1">let result;</span>
          <span class="s2">if </span><span class="s1">(starttype === </span><span class="s3">83</span><span class="s1">) {</span>
            <span class="s1">result = </span><span class="s2">this</span><span class="s1">.parseImport(node);</span>
            <span class="s2">if </span><span class="s1">(result.type === </span><span class="s0">&quot;ImportDeclaration&quot; </span><span class="s1">&amp;&amp; (!result.importKind || result.importKind === </span><span class="s0">&quot;value&quot;</span><span class="s1">)) {</span>
              <span class="s2">this</span><span class="s1">.sawUnambiguousESM = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">result = </span><span class="s2">this</span><span class="s1">.parseExport(node, decorators);</span>
            <span class="s2">if </span><span class="s1">(result.type === </span><span class="s0">&quot;ExportNamedDeclaration&quot; </span><span class="s1">&amp;&amp; (!result.exportKind || result.exportKind === </span><span class="s0">&quot;value&quot;</span><span class="s1">) || result.type === </span><span class="s0">&quot;ExportAllDeclaration&quot; </span><span class="s1">&amp;&amp; (!result.exportKind || result.exportKind === </span><span class="s0">&quot;value&quot;</span><span class="s1">) || result.type === </span><span class="s0">&quot;ExportDefaultDeclaration&quot;</span><span class="s1">) {</span>
              <span class="s2">this</span><span class="s1">.sawUnambiguousESM = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s2">this</span><span class="s1">.assertModuleNodeAllowed(result);</span>
          <span class="s2">return </span><span class="s1">result;</span>
        <span class="s1">}</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isAsyncFunction()) {</span>
            <span class="s2">if </span><span class="s1">(!allowDeclaration) {</span>
              <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.AsyncFunctionInSingleStatementContext, {</span>
                <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
              <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.next();</span>
            <span class="s2">return this</span><span class="s1">.parseFunctionStatement(node, </span><span class="s2">true</span><span class="s1">, !allowDeclaration &amp;&amp; allowFunctionDeclaration);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">const maybeName = </span><span class="s2">this</span><span class="s1">.state.value;</span>
    <span class="s1">const expr = </span><span class="s2">this</span><span class="s1">.parseExpression();</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _types.tokenIsIdentifier)(starttype) &amp;&amp; expr.type === </span><span class="s0">&quot;Identifier&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">14</span><span class="s1">)) {</span>
      <span class="s2">return this</span><span class="s1">.parseLabeledStatement(node, maybeName, expr, flags);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return this</span><span class="s1">.parseExpressionStatement(node, expr, decorators);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">assertModuleNodeAllowed(node) {</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.options.allowImportExportEverywhere &amp;&amp; !</span><span class="s2">this</span><span class="s1">.inModule) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ImportOutsideModule, {</span>
        <span class="s1">at: node</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">decoratorsEnabledBeforeExport() {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;decorators-legacy&quot;</span><span class="s1">)) </span><span class="s2">return true</span><span class="s1">;</span>
    <span class="s2">return this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;decorators&quot;</span><span class="s1">) &amp;&amp; </span><span class="s2">this</span><span class="s1">.getPluginOption(</span><span class="s0">&quot;decorators&quot;</span><span class="s1">, </span><span class="s0">&quot;decoratorsBeforeExport&quot;</span><span class="s1">) !== </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">maybeTakeDecorators(maybeDecorators, classNode, exportNode) {</span>
    <span class="s2">if </span><span class="s1">(maybeDecorators) {</span>
      <span class="s2">if </span><span class="s1">(classNode.decorators &amp;&amp; classNode.decorators.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof this</span><span class="s1">.getPluginOption(</span><span class="s0">&quot;decorators&quot;</span><span class="s1">, </span><span class="s0">&quot;decoratorsBeforeExport&quot;</span><span class="s1">) !== </span><span class="s0">&quot;boolean&quot;</span><span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.DecoratorsBeforeAfterExport, {</span>
            <span class="s1">at: classNode.decorators[</span><span class="s3">0</span><span class="s1">]</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">classNode.decorators.unshift(...maybeDecorators);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">classNode.decorators = maybeDecorators;</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.resetStartLocationFromNode(classNode, maybeDecorators[</span><span class="s3">0</span><span class="s1">]);</span>
      <span class="s2">if </span><span class="s1">(exportNode) </span><span class="s2">this</span><span class="s1">.resetStartLocationFromNode(exportNode, classNode);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">classNode;</span>
  <span class="s1">}</span>
  <span class="s1">canHaveLeadingDecorator() {</span>
    <span class="s2">return this</span><span class="s1">.match(</span><span class="s3">80</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseDecorators(allowExport) {</span>
    <span class="s1">const decorators = [];</span>
    <span class="s2">do </span><span class="s1">{</span>
      <span class="s1">decorators.push(</span><span class="s2">this</span><span class="s1">.parseDecorator());</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">26</span><span class="s1">));</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">82</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(!allowExport) {</span>
        <span class="s2">this</span><span class="s1">.unexpected();</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.decoratorsEnabledBeforeExport()) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.DecoratorExportClass, {</span>
          <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.canHaveLeadingDecorator()) {</span>
      <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.UnexpectedLeadingDecorator, {</span>
        <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">decorators;</span>
  <span class="s1">}</span>
  <span class="s1">parseDecorator() {</span>
    <span class="s2">this</span><span class="s1">.expectOnePlugin([</span><span class="s0">&quot;decorators&quot;</span><span class="s1">, </span><span class="s0">&quot;decorators-legacy&quot;</span><span class="s1">]);</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;decorators&quot;</span><span class="s1">)) {</span>
      <span class="s1">const startLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
      <span class="s1">let expr;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">10</span><span class="s1">)) {</span>
        <span class="s1">const startLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
        <span class="s2">this</span><span class="s1">.next();</span>
        <span class="s1">expr = </span><span class="s2">this</span><span class="s1">.parseExpression();</span>
        <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">11</span><span class="s1">);</span>
        <span class="s1">expr = </span><span class="s2">this</span><span class="s1">.wrapParenthesis(startLoc, expr);</span>
        <span class="s1">const paramsStartLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
        <span class="s1">node.expression = </span><span class="s2">this</span><span class="s1">.parseMaybeDecoratorArguments(expr);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.getPluginOption(</span><span class="s0">&quot;decorators&quot;</span><span class="s1">, </span><span class="s0">&quot;allowCallParenthesized&quot;</span><span class="s1">) === </span><span class="s2">false </span><span class="s1">&amp;&amp; node.expression !== expr) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.DecoratorArgumentsOutsideParentheses, {</span>
            <span class="s1">at: paramsStartLoc</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">expr = </span><span class="s2">this</span><span class="s1">.parseIdentifier(</span><span class="s2">false</span><span class="s1">);</span>
        <span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">16</span><span class="s1">)) {</span>
          <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNodeAt(startLoc);</span>
          <span class="s1">node.object = expr;</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">136</span><span class="s1">)) {</span>
            <span class="s2">this</span><span class="s1">.classScope.usePrivateName(</span><span class="s2">this</span><span class="s1">.state.value, </span><span class="s2">this</span><span class="s1">.state.startLoc);</span>
            <span class="s1">node.property = </span><span class="s2">this</span><span class="s1">.parsePrivateName();</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">node.property = </span><span class="s2">this</span><span class="s1">.parseIdentifier(</span><span class="s2">true</span><span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s1">node.computed = </span><span class="s2">false</span><span class="s1">;</span>
          <span class="s1">expr = </span><span class="s2">this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;MemberExpression&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">node.expression = </span><span class="s2">this</span><span class="s1">.parseMaybeDecoratorArguments(expr);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">node.expression = </span><span class="s2">this</span><span class="s1">.parseExprSubscripts();</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;Decorator&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseMaybeDecoratorArguments(expr) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">10</span><span class="s1">)) {</span>
      <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNodeAtNode(expr);</span>
      <span class="s1">node.callee = expr;</span>
      <span class="s1">node.arguments = </span><span class="s2">this</span><span class="s1">.parseCallExpressionArguments(</span><span class="s3">11</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.toReferencedList(node.arguments);</span>
      <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;CallExpression&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">expr;</span>
  <span class="s1">}</span>
  <span class="s1">parseBreakContinueStatement(node, isBreak) {</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isLineTerminator()) {</span>
      <span class="s1">node.label = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">node.label = </span><span class="s2">this</span><span class="s1">.parseIdentifier();</span>
      <span class="s2">this</span><span class="s1">.semicolon();</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.verifyBreakContinue(node, isBreak);</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, isBreak ? </span><span class="s0">&quot;BreakStatement&quot; </span><span class="s1">: </span><span class="s0">&quot;ContinueStatement&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">verifyBreakContinue(node, isBreak) {</span>
    <span class="s1">let i;</span>
    <span class="s2">for </span><span class="s1">(i = </span><span class="s3">0</span><span class="s1">; i &lt; </span><span class="s2">this</span><span class="s1">.state.labels.length; ++i) {</span>
      <span class="s1">const lab = </span><span class="s2">this</span><span class="s1">.state.labels[i];</span>
      <span class="s2">if </span><span class="s1">(node.label == </span><span class="s2">null </span><span class="s1">|| lab.name === node.label.name) {</span>
        <span class="s2">if </span><span class="s1">(lab.kind != </span><span class="s2">null </span><span class="s1">&amp;&amp; (isBreak || lab.kind === </span><span class="s0">&quot;loop&quot;</span><span class="s1">)) </span><span class="s2">break</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(node.label &amp;&amp; isBreak) </span><span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(i === </span><span class="s2">this</span><span class="s1">.state.labels.length) {</span>
      <span class="s1">const type = isBreak ? </span><span class="s0">&quot;BreakStatement&quot; </span><span class="s1">: </span><span class="s0">&quot;ContinueStatement&quot;</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.IllegalBreakContinue, {</span>
        <span class="s1">at: node,</span>
        <span class="s1">type</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseDebuggerStatement(node) {</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">this</span><span class="s1">.semicolon();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;DebuggerStatement&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseHeaderExpression() {</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">10</span><span class="s1">);</span>
    <span class="s1">const val = </span><span class="s2">this</span><span class="s1">.parseExpression();</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">11</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">val;</span>
  <span class="s1">}</span>
  <span class="s1">parseDoWhileStatement(node) {</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">this</span><span class="s1">.state.labels.push(loopLabel);</span>
    <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.withSmartMixTopicForbiddingContext(() =&gt; </span><span class="s2">this</span><span class="s1">.parseStatement());</span>
    <span class="s2">this</span><span class="s1">.state.labels.pop();</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">92</span><span class="s1">);</span>
    <span class="s1">node.test = </span><span class="s2">this</span><span class="s1">.parseHeaderExpression();</span>
    <span class="s2">this</span><span class="s1">.eat(</span><span class="s3">13</span><span class="s1">);</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;DoWhileStatement&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseForStatement(node) {</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">this</span><span class="s1">.state.labels.push(loopLabel);</span>
    <span class="s1">let awaitAt = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isAwaitAllowed() &amp;&amp; </span><span class="s2">this</span><span class="s1">.eatContextual(</span><span class="s3">96</span><span class="s1">)) {</span>
      <span class="s1">awaitAt = </span><span class="s2">this</span><span class="s1">.state.lastTokStartLoc;</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.scope.enter(_scopeflags.SCOPE_OTHER);</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">10</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">13</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(awaitAt !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.unexpected(awaitAt);</span>
      <span class="s1">}</span>
      <span class="s2">return this</span><span class="s1">.parseFor(node, </span><span class="s2">null</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">const startsWithLet = </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">99</span><span class="s1">);</span>
    <span class="s1">{</span>
      <span class="s1">const startsWithAwaitUsing = </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">96</span><span class="s1">) &amp;&amp; </span><span class="s2">this</span><span class="s1">.startsAwaitUsing();</span>
      <span class="s1">const starsWithUsingDeclaration = startsWithAwaitUsing || </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">105</span><span class="s1">) &amp;&amp; </span><span class="s2">this</span><span class="s1">.startsUsingForOf();</span>
      <span class="s1">const isLetOrUsing = startsWithLet &amp;&amp; </span><span class="s2">this</span><span class="s1">.hasFollowingBindingAtom() || starsWithUsingDeclaration;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">74</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">75</span><span class="s1">) || isLetOrUsing) {</span>
        <span class="s1">const initNode = </span><span class="s2">this</span><span class="s1">.startNode();</span>
        <span class="s1">let kind;</span>
        <span class="s2">if </span><span class="s1">(startsWithAwaitUsing) {</span>
          <span class="s1">kind = </span><span class="s0">&quot;await using&quot;</span><span class="s1">;</span>
          <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isAwaitAllowed()) {</span>
            <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.AwaitUsingNotInAsyncContext, {</span>
              <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
          <span class="s2">this</span><span class="s1">.next();</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">kind = </span><span class="s2">this</span><span class="s1">.state.value;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.next();</span>
        <span class="s2">this</span><span class="s1">.parseVar(initNode, </span><span class="s2">true</span><span class="s1">, kind);</span>
        <span class="s1">const init = </span><span class="s2">this</span><span class="s1">.finishNode(initNode, </span><span class="s0">&quot;VariableDeclaration&quot;</span><span class="s1">);</span>
        <span class="s1">const isForIn = </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">58</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(isForIn &amp;&amp; starsWithUsingDeclaration) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ForInUsing, {</span>
            <span class="s1">at: init</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((isForIn || </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">101</span><span class="s1">)) &amp;&amp; init.declarations.length === </span><span class="s3">1</span><span class="s1">) {</span>
          <span class="s2">return this</span><span class="s1">.parseForIn(node, init, awaitAt);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(awaitAt !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">.unexpected(awaitAt);</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.parseFor(node, init);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">const startsWithAsync = </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">95</span><span class="s1">);</span>
    <span class="s1">const refExpressionErrors = </span><span class="s2">new </span><span class="s1">_util.ExpressionErrors();</span>
    <span class="s1">const init = </span><span class="s2">this</span><span class="s1">.parseExpression(</span><span class="s2">true</span><span class="s1">, refExpressionErrors);</span>
    <span class="s1">const isForOf = </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">101</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(isForOf) {</span>
      <span class="s2">if </span><span class="s1">(startsWithLet) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ForOfLet, {</span>
          <span class="s1">at: init</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(awaitAt === </span><span class="s2">null </span><span class="s1">&amp;&amp; startsWithAsync &amp;&amp; init.type === </span><span class="s0">&quot;Identifier&quot;</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ForOfAsync, {</span>
          <span class="s1">at: init</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isForOf || </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">58</span><span class="s1">)) {</span>
      <span class="s2">this</span><span class="s1">.checkDestructuringPrivate(refExpressionErrors);</span>
      <span class="s2">this</span><span class="s1">.toAssignable(init, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">const type = isForOf ? </span><span class="s0">&quot;ForOfStatement&quot; </span><span class="s1">: </span><span class="s0">&quot;ForInStatement&quot;</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.checkLVal(init, {</span>
        <span class="s2">in</span><span class="s1">: {</span>
          <span class="s1">type</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
      <span class="s2">return this</span><span class="s1">.parseForIn(node, init, awaitAt);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">this</span><span class="s1">.checkExpressionErrors(refExpressionErrors, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(awaitAt !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.unexpected(awaitAt);</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseFor(node, init);</span>
  <span class="s1">}</span>
  <span class="s1">parseFunctionStatement(node, isAsync, isHangingDeclaration) {</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">return this</span><span class="s1">.parseFunction(node, ParseFunctionFlag.Declaration | (isHangingDeclaration ? ParseFunctionFlag.HangingDeclaration : </span><span class="s3">0</span><span class="s1">) | (isAsync ? ParseFunctionFlag.Async : </span><span class="s3">0</span><span class="s1">));</span>
  <span class="s1">}</span>
  <span class="s1">parseIfStatement(node) {</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s1">node.test = </span><span class="s2">this</span><span class="s1">.parseHeaderExpression();</span>
    <span class="s1">node.consequent = </span><span class="s2">this</span><span class="s1">.parseStatementOrSloppyAnnexBFunctionDeclaration();</span>
    <span class="s1">node.alternate = </span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">66</span><span class="s1">) ? </span><span class="s2">this</span><span class="s1">.parseStatementOrSloppyAnnexBFunctionDeclaration() : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;IfStatement&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseReturnStatement(node) {</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.prodParam.hasReturn &amp;&amp; !</span><span class="s2">this</span><span class="s1">.options.allowReturnOutsideFunction) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.IllegalReturn, {</span>
        <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isLineTerminator()) {</span>
      <span class="s1">node.argument = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">node.argument = </span><span class="s2">this</span><span class="s1">.parseExpression();</span>
      <span class="s2">this</span><span class="s1">.semicolon();</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ReturnStatement&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseSwitchStatement(node) {</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s1">node.discriminant = </span><span class="s2">this</span><span class="s1">.parseHeaderExpression();</span>
    <span class="s1">const cases = node.cases = [];</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">5</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.state.labels.push(switchLabel);</span>
    <span class="s2">this</span><span class="s1">.scope.enter(_scopeflags.SCOPE_OTHER);</span>
    <span class="s1">let cur;</span>
    <span class="s2">for </span><span class="s1">(let sawDefault; !</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">8</span><span class="s1">);) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">61</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">65</span><span class="s1">)) {</span>
        <span class="s1">const isCase = </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">61</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(cur) </span><span class="s2">this</span><span class="s1">.finishNode(cur, </span><span class="s0">&quot;SwitchCase&quot;</span><span class="s1">);</span>
        <span class="s1">cases.push(cur = </span><span class="s2">this</span><span class="s1">.startNode());</span>
        <span class="s1">cur.consequent = [];</span>
        <span class="s2">this</span><span class="s1">.next();</span>
        <span class="s2">if </span><span class="s1">(isCase) {</span>
          <span class="s1">cur.test = </span><span class="s2">this</span><span class="s1">.parseExpression();</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(sawDefault) {</span>
            <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.MultipleDefaultsInSwitch, {</span>
              <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.lastTokStartLoc</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
          <span class="s1">sawDefault = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s1">cur.test = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">14</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(cur) {</span>
          <span class="s1">cur.consequent.push(</span><span class="s2">this</span><span class="s1">.parseStatementListItem());</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">this</span><span class="s1">.unexpected();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.scope.exit();</span>
    <span class="s2">if </span><span class="s1">(cur) </span><span class="s2">this</span><span class="s1">.finishNode(cur, </span><span class="s0">&quot;SwitchCase&quot;</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">this</span><span class="s1">.state.labels.pop();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;SwitchStatement&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseThrowStatement(node) {</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPrecedingLineBreak()) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.NewlineAfterThrow, {</span>
        <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.lastTokEndLoc</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">node.argument = </span><span class="s2">this</span><span class="s1">.parseExpression();</span>
    <span class="s2">this</span><span class="s1">.semicolon();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ThrowStatement&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseCatchClauseParam() {</span>
    <span class="s1">const param = </span><span class="s2">this</span><span class="s1">.parseBindingAtom();</span>
    <span class="s2">this</span><span class="s1">.scope.enter(</span><span class="s2">this</span><span class="s1">.options.annexB &amp;&amp; param.type === </span><span class="s0">&quot;Identifier&quot; </span><span class="s1">? _scopeflags.SCOPE_SIMPLE_CATCH : </span><span class="s3">0</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.checkLVal(param, {</span>
      <span class="s2">in</span><span class="s1">: {</span>
        <span class="s1">type: </span><span class="s0">&quot;CatchClause&quot;</span>
      <span class="s1">},</span>
      <span class="s1">binding: _scopeflags.BIND_CATCH_PARAM</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">param;</span>
  <span class="s1">}</span>
  <span class="s1">parseTryStatement(node) {</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s1">node.block = </span><span class="s2">this</span><span class="s1">.parseBlock();</span>
    <span class="s1">node.handler = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">62</span><span class="s1">)) {</span>
      <span class="s1">const clause = </span><span class="s2">this</span><span class="s1">.startNode();</span>
      <span class="s2">this</span><span class="s1">.next();</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">10</span><span class="s1">)) {</span>
        <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">10</span><span class="s1">);</span>
        <span class="s1">clause.param = </span><span class="s2">this</span><span class="s1">.parseCatchClauseParam();</span>
        <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">11</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">clause.param = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.scope.enter(_scopeflags.SCOPE_OTHER);</span>
      <span class="s1">}</span>
      <span class="s1">clause.body = </span><span class="s2">this</span><span class="s1">.withSmartMixTopicForbiddingContext(() =&gt; </span><span class="s2">this</span><span class="s1">.parseBlock(</span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">));</span>
      <span class="s2">this</span><span class="s1">.scope.exit();</span>
      <span class="s1">node.handler = </span><span class="s2">this</span><span class="s1">.finishNode(clause, </span><span class="s0">&quot;CatchClause&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">node.finalizer = </span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">67</span><span class="s1">) ? </span><span class="s2">this</span><span class="s1">.parseBlock() : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(!node.handler &amp;&amp; !node.finalizer) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.NoCatchOrFinally, {</span>
        <span class="s1">at: node</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;TryStatement&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseVarStatement(node, kind, allowMissingInitializer = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">this</span><span class="s1">.parseVar(node, </span><span class="s2">false</span><span class="s1">, kind, allowMissingInitializer);</span>
    <span class="s2">this</span><span class="s1">.semicolon();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;VariableDeclaration&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseWhileStatement(node) {</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s1">node.test = </span><span class="s2">this</span><span class="s1">.parseHeaderExpression();</span>
    <span class="s2">this</span><span class="s1">.state.labels.push(loopLabel);</span>
    <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.withSmartMixTopicForbiddingContext(() =&gt; </span><span class="s2">this</span><span class="s1">.parseStatement());</span>
    <span class="s2">this</span><span class="s1">.state.labels.pop();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;WhileStatement&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseWithStatement(node) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.state.strict) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.StrictWith, {</span>
        <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s1">node.object = </span><span class="s2">this</span><span class="s1">.parseHeaderExpression();</span>
    <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.withSmartMixTopicForbiddingContext(() =&gt; </span><span class="s2">this</span><span class="s1">.parseStatement());</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;WithStatement&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseEmptyStatement(node) {</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;EmptyStatement&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseLabeledStatement(node, maybeName, expr, flags) {</span>
    <span class="s2">for </span><span class="s1">(const label of </span><span class="s2">this</span><span class="s1">.state.labels) {</span>
      <span class="s2">if </span><span class="s1">(label.name === maybeName) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.LabelRedeclaration, {</span>
          <span class="s1">at: expr,</span>
          <span class="s1">labelName: maybeName</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">const kind = (</span><span class="s3">0</span><span class="s1">, _types.tokenIsLoop)(</span><span class="s2">this</span><span class="s1">.state.type) ? </span><span class="s0">&quot;loop&quot; </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">71</span><span class="s1">) ? </span><span class="s0">&quot;switch&quot; </span><span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">for </span><span class="s1">(let i = </span><span class="s2">this</span><span class="s1">.state.labels.length - </span><span class="s3">1</span><span class="s1">; i &gt;= </span><span class="s3">0</span><span class="s1">; i--) {</span>
      <span class="s1">const label = </span><span class="s2">this</span><span class="s1">.state.labels[i];</span>
      <span class="s2">if </span><span class="s1">(label.statementStart === node.start) {</span>
        <span class="s1">label.statementStart = </span><span class="s2">this</span><span class="s1">.state.start;</span>
        <span class="s1">label.kind = kind;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.state.labels.push({</span>
      <span class="s1">name: maybeName,</span>
      <span class="s1">kind: kind,</span>
      <span class="s1">statementStart: </span><span class="s2">this</span><span class="s1">.state.start</span>
    <span class="s1">});</span>
    <span class="s1">node.body = flags &amp; ParseStatementFlag.AllowLabeledFunction ? </span><span class="s2">this</span><span class="s1">.parseStatementOrSloppyAnnexBFunctionDeclaration(</span><span class="s2">true</span><span class="s1">) : </span><span class="s2">this</span><span class="s1">.parseStatement();</span>
    <span class="s2">this</span><span class="s1">.state.labels.pop();</span>
    <span class="s1">node.label = expr;</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;LabeledStatement&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseExpressionStatement(node, expr, decorators) {</span>
    <span class="s1">node.expression = expr;</span>
    <span class="s2">this</span><span class="s1">.semicolon();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ExpressionStatement&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseBlock(allowDirectives = </span><span class="s2">false</span><span class="s1">, createNewLexicalScope = </span><span class="s2">true</span><span class="s1">, afterBlockParse) {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s2">if </span><span class="s1">(allowDirectives) {</span>
      <span class="s2">this</span><span class="s1">.state.strictErrors.clear();</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">5</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(createNewLexicalScope) {</span>
      <span class="s2">this</span><span class="s1">.scope.enter(_scopeflags.SCOPE_OTHER);</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.parseBlockBody(node, allowDirectives, </span><span class="s2">false</span><span class="s1">, </span><span class="s3">8</span><span class="s1">, afterBlockParse);</span>
    <span class="s2">if </span><span class="s1">(createNewLexicalScope) {</span>
      <span class="s2">this</span><span class="s1">.scope.exit();</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;BlockStatement&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">isValidDirective(stmt) {</span>
    <span class="s2">return </span><span class="s1">stmt.type === </span><span class="s0">&quot;ExpressionStatement&quot; </span><span class="s1">&amp;&amp; stmt.expression.type === </span><span class="s0">&quot;StringLiteral&quot; </span><span class="s1">&amp;&amp; !stmt.expression.extra.parenthesized;</span>
  <span class="s1">}</span>
  <span class="s1">parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {</span>
    <span class="s1">const body = node.body = [];</span>
    <span class="s1">const directives = node.directives = [];</span>
    <span class="s2">this</span><span class="s1">.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);</span>
  <span class="s1">}</span>
  <span class="s1">parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {</span>
    <span class="s1">const oldStrict = </span><span class="s2">this</span><span class="s1">.state.strict;</span>
    <span class="s1">let hasStrictModeDirective = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">let parsedNonDirective = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">while </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.match(end)) {</span>
      <span class="s1">const stmt = topLevel ? </span><span class="s2">this</span><span class="s1">.parseModuleItem() : </span><span class="s2">this</span><span class="s1">.parseStatementListItem();</span>
      <span class="s2">if </span><span class="s1">(directives &amp;&amp; !parsedNonDirective) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isValidDirective(stmt)) {</span>
          <span class="s1">const directive = </span><span class="s2">this</span><span class="s1">.stmtToDirective(stmt);</span>
          <span class="s1">directives.push(directive);</span>
          <span class="s2">if </span><span class="s1">(!hasStrictModeDirective &amp;&amp; directive.value.value === </span><span class="s0">&quot;use strict&quot;</span><span class="s1">) {</span>
            <span class="s1">hasStrictModeDirective = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.setStrict(</span><span class="s2">true</span><span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">parsedNonDirective = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.state.strictErrors.clear();</span>
      <span class="s1">}</span>
      <span class="s1">body.push(stmt);</span>
    <span class="s1">}</span>
    <span class="s1">afterBlockParse == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: afterBlockParse.call(</span><span class="s2">this</span><span class="s1">, hasStrictModeDirective);</span>
    <span class="s2">if </span><span class="s1">(!oldStrict) {</span>
      <span class="s2">this</span><span class="s1">.setStrict(</span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.next();</span>
  <span class="s1">}</span>
  <span class="s1">parseFor(node, init) {</span>
    <span class="s1">node.init = init;</span>
    <span class="s2">this</span><span class="s1">.semicolon(</span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">node.test = </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">13</span><span class="s1">) ? </span><span class="s2">null </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.parseExpression();</span>
    <span class="s2">this</span><span class="s1">.semicolon(</span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">node.update = </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">11</span><span class="s1">) ? </span><span class="s2">null </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.parseExpression();</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">11</span><span class="s1">);</span>
    <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.withSmartMixTopicForbiddingContext(() =&gt; </span><span class="s2">this</span><span class="s1">.parseStatement());</span>
    <span class="s2">this</span><span class="s1">.scope.exit();</span>
    <span class="s2">this</span><span class="s1">.state.labels.pop();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ForStatement&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseForIn(node, init, awaitAt) {</span>
    <span class="s1">const isForIn = </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">58</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">if </span><span class="s1">(isForIn) {</span>
      <span class="s2">if </span><span class="s1">(awaitAt !== </span><span class="s2">null</span><span class="s1">) </span><span class="s2">this</span><span class="s1">.unexpected(awaitAt);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">node.await = awaitAt !== </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(init.type === </span><span class="s0">&quot;VariableDeclaration&quot; </span><span class="s1">&amp;&amp; init.declarations[</span><span class="s3">0</span><span class="s1">].init != </span><span class="s2">null </span><span class="s1">&amp;&amp; (!isForIn || !</span><span class="s2">this</span><span class="s1">.options.annexB || </span><span class="s2">this</span><span class="s1">.state.strict || init.kind !== </span><span class="s0">&quot;var&quot; </span><span class="s1">|| init.declarations[</span><span class="s3">0</span><span class="s1">].id.type !== </span><span class="s0">&quot;Identifier&quot;</span><span class="s1">)) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ForInOfLoopInitializer, {</span>
        <span class="s1">at: init,</span>
        <span class="s1">type: isForIn ? </span><span class="s0">&quot;ForInStatement&quot; </span><span class="s1">: </span><span class="s0">&quot;ForOfStatement&quot;</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(init.type === </span><span class="s0">&quot;AssignmentPattern&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.InvalidLhs, {</span>
        <span class="s1">at: init,</span>
        <span class="s1">ancestor: {</span>
          <span class="s1">type: </span><span class="s0">&quot;ForStatement&quot;</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">node.left = init;</span>
    <span class="s1">node.right = isForIn ? </span><span class="s2">this</span><span class="s1">.parseExpression() : </span><span class="s2">this</span><span class="s1">.parseMaybeAssignAllowIn();</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">11</span><span class="s1">);</span>
    <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.withSmartMixTopicForbiddingContext(() =&gt; </span><span class="s2">this</span><span class="s1">.parseStatement());</span>
    <span class="s2">this</span><span class="s1">.scope.exit();</span>
    <span class="s2">this</span><span class="s1">.state.labels.pop();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, isForIn ? </span><span class="s0">&quot;ForInStatement&quot; </span><span class="s1">: </span><span class="s0">&quot;ForOfStatement&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseVar(node, isFor, kind, allowMissingInitializer = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s1">const declarations = node.declarations = [];</span>
    <span class="s1">node.kind = kind;</span>
    <span class="s2">for </span><span class="s1">(;;) {</span>
      <span class="s1">const decl = </span><span class="s2">this</span><span class="s1">.startNode();</span>
      <span class="s2">this</span><span class="s1">.parseVarId(decl, kind);</span>
      <span class="s1">decl.init = !</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">29</span><span class="s1">) ? </span><span class="s2">null </span><span class="s1">: isFor ? </span><span class="s2">this</span><span class="s1">.parseMaybeAssignDisallowIn() : </span><span class="s2">this</span><span class="s1">.parseMaybeAssignAllowIn();</span>
      <span class="s2">if </span><span class="s1">(decl.init === </span><span class="s2">null </span><span class="s1">&amp;&amp; !allowMissingInitializer) {</span>
        <span class="s2">if </span><span class="s1">(decl.id.type !== </span><span class="s0">&quot;Identifier&quot; </span><span class="s1">&amp;&amp; !(isFor &amp;&amp; (</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">58</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">101</span><span class="s1">)))) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.DeclarationMissingInitializer, {</span>
            <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.lastTokEndLoc,</span>
            <span class="s1">kind: </span><span class="s0">&quot;destructuring&quot;</span>
          <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(kind === </span><span class="s0">&quot;const&quot; </span><span class="s1">&amp;&amp; !(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">58</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">101</span><span class="s1">))) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.DeclarationMissingInitializer, {</span>
            <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.lastTokEndLoc,</span>
            <span class="s1">kind: </span><span class="s0">&quot;const&quot;</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">declarations.push(</span><span class="s2">this</span><span class="s1">.finishNode(decl, </span><span class="s0">&quot;VariableDeclarator&quot;</span><span class="s1">));</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">12</span><span class="s1">)) </span><span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">node;</span>
  <span class="s1">}</span>
  <span class="s1">parseVarId(decl, kind) {</span>
    <span class="s1">const id = </span><span class="s2">this</span><span class="s1">.parseBindingAtom();</span>
    <span class="s2">this</span><span class="s1">.checkLVal(id, {</span>
      <span class="s2">in</span><span class="s1">: {</span>
        <span class="s1">type: </span><span class="s0">&quot;VariableDeclarator&quot;</span>
      <span class="s1">},</span>
      <span class="s1">binding: kind === </span><span class="s0">&quot;var&quot; </span><span class="s1">? _scopeflags.BIND_VAR : _scopeflags.BIND_LEXICAL</span>
    <span class="s1">});</span>
    <span class="s1">decl.id = id;</span>
  <span class="s1">}</span>
  <span class="s1">parseAsyncFunctionExpression(node) {</span>
    <span class="s2">return this</span><span class="s1">.parseFunction(node, ParseFunctionFlag.Async);</span>
  <span class="s1">}</span>
  <span class="s1">parseFunction(node, flags = ParseFunctionFlag.Expression) {</span>
    <span class="s1">const hangingDeclaration = flags &amp; ParseFunctionFlag.HangingDeclaration;</span>
    <span class="s1">const isDeclaration = !!(flags &amp; ParseFunctionFlag.Declaration);</span>
    <span class="s1">const requireId = isDeclaration &amp;&amp; !(flags &amp; ParseFunctionFlag.NullableId);</span>
    <span class="s1">const isAsync = !!(flags &amp; ParseFunctionFlag.Async);</span>
    <span class="s2">this</span><span class="s1">.initFunction(node, isAsync);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">55</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(hangingDeclaration) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.GeneratorInSingleStatementContext, {</span>
          <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.next();</span>
      <span class="s1">node.generator = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isDeclaration) {</span>
      <span class="s1">node.id = </span><span class="s2">this</span><span class="s1">.parseFunctionId(requireId);</span>
    <span class="s1">}</span>
    <span class="s1">const oldMaybeInArrowParameters = </span><span class="s2">this</span><span class="s1">.state.maybeInArrowParameters;</span>
    <span class="s2">this</span><span class="s1">.state.maybeInArrowParameters = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.scope.enter(_scopeflags.SCOPE_FUNCTION);</span>
    <span class="s2">this</span><span class="s1">.prodParam.enter((</span><span class="s3">0</span><span class="s1">, _productionParameter.functionFlags)(isAsync, node.generator));</span>
    <span class="s2">if </span><span class="s1">(!isDeclaration) {</span>
      <span class="s1">node.id = </span><span class="s2">this</span><span class="s1">.parseFunctionId();</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.parseFunctionParams(node, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.withSmartMixTopicForbiddingContext(() =&gt; {</span>
      <span class="s2">this</span><span class="s1">.parseFunctionBodyAndFinish(node, isDeclaration ? </span><span class="s0">&quot;FunctionDeclaration&quot; </span><span class="s1">: </span><span class="s0">&quot;FunctionExpression&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s2">this</span><span class="s1">.prodParam.exit();</span>
    <span class="s2">this</span><span class="s1">.scope.exit();</span>
    <span class="s2">if </span><span class="s1">(isDeclaration &amp;&amp; !hangingDeclaration) {</span>
      <span class="s2">this</span><span class="s1">.registerFunctionStatementId(node);</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.state.maybeInArrowParameters = oldMaybeInArrowParameters;</span>
    <span class="s2">return </span><span class="s1">node;</span>
  <span class="s1">}</span>
  <span class="s1">parseFunctionId(requireId) {</span>
    <span class="s2">return </span><span class="s1">requireId || (</span><span class="s3">0</span><span class="s1">, _types.tokenIsIdentifier)(</span><span class="s2">this</span><span class="s1">.state.type) ? </span><span class="s2">this</span><span class="s1">.parseIdentifier() : </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">parseFunctionParams(node, isConstructor) {</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">10</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.expressionScope.enter((</span><span class="s3">0</span><span class="s1">, _expressionScope.newParameterDeclarationScope)());</span>
    <span class="s1">node.params = </span><span class="s2">this</span><span class="s1">.parseBindingList(</span><span class="s3">11</span><span class="s1">, </span><span class="s3">41</span><span class="s1">, _lval.ParseBindingListFlags.IS_FUNCTION_PARAMS | (isConstructor ? _lval.ParseBindingListFlags.IS_CONSTRUCTOR_PARAMS : </span><span class="s3">0</span><span class="s1">));</span>
    <span class="s2">this</span><span class="s1">.expressionScope.exit();</span>
  <span class="s1">}</span>
  <span class="s1">registerFunctionStatementId(node) {</span>
    <span class="s2">if </span><span class="s1">(!node.id) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.scope.declareName(node.id.name, !</span><span class="s2">this</span><span class="s1">.options.annexB || </span><span class="s2">this</span><span class="s1">.state.strict || node.generator || node.async ? </span><span class="s2">this</span><span class="s1">.scope.treatFunctionsAsVar ? _scopeflags.BIND_VAR : _scopeflags.BIND_LEXICAL : _scopeflags.BIND_FUNCTION, node.id.loc.start);</span>
  <span class="s1">}</span>
  <span class="s1">parseClass(node, isStatement, optionalId) {</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s1">const oldStrict = </span><span class="s2">this</span><span class="s1">.state.strict;</span>
    <span class="s2">this</span><span class="s1">.state.strict = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.parseClassId(node, isStatement, optionalId);</span>
    <span class="s2">this</span><span class="s1">.parseClassSuper(node);</span>
    <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.parseClassBody(!!node.superClass, oldStrict);</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, isStatement ? </span><span class="s0">&quot;ClassDeclaration&quot; </span><span class="s1">: </span><span class="s0">&quot;ClassExpression&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">isClassProperty() {</span>
    <span class="s2">return this</span><span class="s1">.match(</span><span class="s3">29</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">13</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">8</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">isClassMethod() {</span>
    <span class="s2">return this</span><span class="s1">.match(</span><span class="s3">10</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">isNonstaticConstructor(method) {</span>
    <span class="s2">return </span><span class="s1">!method.computed &amp;&amp; !method.static &amp;&amp; (method.key.name === </span><span class="s0">&quot;constructor&quot; </span><span class="s1">|| method.key.value === </span><span class="s0">&quot;constructor&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseClassBody(hadSuperClass, oldStrict) {</span>
    <span class="s2">this</span><span class="s1">.classScope.enter();</span>
    <span class="s1">const state = {</span>
      <span class="s1">hadConstructor: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">hadSuperClass</span>
    <span class="s1">};</span>
    <span class="s1">let decorators = [];</span>
    <span class="s1">const classBody = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s1">classBody.body = [];</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">5</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.withSmartMixTopicForbiddingContext(() =&gt; {</span>
      <span class="s2">while </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">8</span><span class="s1">)) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">13</span><span class="s1">)) {</span>
          <span class="s2">if </span><span class="s1">(decorators.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.DecoratorSemicolon, {</span>
              <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.lastTokEndLoc</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
          <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">26</span><span class="s1">)) {</span>
          <span class="s1">decorators.push(</span><span class="s2">this</span><span class="s1">.parseDecorator());</span>
          <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">const member = </span><span class="s2">this</span><span class="s1">.startNode();</span>
        <span class="s2">if </span><span class="s1">(decorators.length) {</span>
          <span class="s1">member.decorators = decorators;</span>
          <span class="s2">this</span><span class="s1">.resetStartLocationFromNode(member, decorators[</span><span class="s3">0</span><span class="s1">]);</span>
          <span class="s1">decorators = [];</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.parseClassMember(classBody, member, state);</span>
        <span class="s2">if </span><span class="s1">(member.kind === </span><span class="s0">&quot;constructor&quot; </span><span class="s1">&amp;&amp; member.decorators &amp;&amp; member.decorators.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.DecoratorConstructor, {</span>
            <span class="s1">at: member</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">this</span><span class="s1">.state.strict = oldStrict;</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">if </span><span class="s1">(decorators.length) {</span>
      <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.TrailingDecorator, {</span>
        <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.classScope.exit();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(classBody, </span><span class="s0">&quot;ClassBody&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseClassMemberFromModifier(classBody, member) {</span>
    <span class="s1">const key = </span><span class="s2">this</span><span class="s1">.parseIdentifier(</span><span class="s2">true</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isClassMethod()) {</span>
      <span class="s1">const method = member;</span>
      <span class="s1">method.kind = </span><span class="s0">&quot;method&quot;</span><span class="s1">;</span>
      <span class="s1">method.computed = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">method.key = key;</span>
      <span class="s1">method.static = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.pushClassMethod(classBody, method, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isClassProperty()) {</span>
      <span class="s1">const prop = member;</span>
      <span class="s1">prop.computed = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">prop.key = key;</span>
      <span class="s1">prop.static = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">classBody.body.push(</span><span class="s2">this</span><span class="s1">.parseClassProperty(prop));</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.resetPreviousNodeTrailingComments(key);</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">parseClassMember(classBody, member, state) {</span>
    <span class="s1">const isStatic = </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">104</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(isStatic) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.parseClassMemberFromModifier(classBody, member)) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">5</span><span class="s1">)) {</span>
        <span class="s2">this</span><span class="s1">.parseClassStaticBlock(classBody, member);</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.parseClassMemberWithIsStatic(classBody, member, state, isStatic);</span>
  <span class="s1">}</span>
  <span class="s1">parseClassMemberWithIsStatic(classBody, member, state, isStatic) {</span>
    <span class="s1">const publicMethod = member;</span>
    <span class="s1">const privateMethod = member;</span>
    <span class="s1">const publicProp = member;</span>
    <span class="s1">const privateProp = member;</span>
    <span class="s1">const accessorProp = member;</span>
    <span class="s1">const method = publicMethod;</span>
    <span class="s1">const publicMember = publicMethod;</span>
    <span class="s1">member.static = isStatic;</span>
    <span class="s2">this</span><span class="s1">.parsePropertyNamePrefixOperator(member);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">55</span><span class="s1">)) {</span>
      <span class="s1">method.kind = </span><span class="s0">&quot;method&quot;</span><span class="s1">;</span>
      <span class="s1">const isPrivateName = </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">136</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.parseClassElementName(method);</span>
      <span class="s2">if </span><span class="s1">(isPrivateName) {</span>
        <span class="s2">this</span><span class="s1">.pushClassPrivateMethod(classBody, privateMethod, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isNonstaticConstructor(publicMethod)) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ConstructorIsGenerator, {</span>
          <span class="s1">at: publicMethod.key</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.pushClassMethod(classBody, publicMethod, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const isContextual = (</span><span class="s3">0</span><span class="s1">, _types.tokenIsIdentifier)(</span><span class="s2">this</span><span class="s1">.state.type) &amp;&amp; !</span><span class="s2">this</span><span class="s1">.state.containsEsc;</span>
    <span class="s1">const isPrivate = </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">136</span><span class="s1">);</span>
    <span class="s1">const key = </span><span class="s2">this</span><span class="s1">.parseClassElementName(member);</span>
    <span class="s1">const maybeQuestionTokenStartLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
    <span class="s2">this</span><span class="s1">.parsePostMemberNameModifiers(publicMember);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isClassMethod()) {</span>
      <span class="s1">method.kind = </span><span class="s0">&quot;method&quot;</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(isPrivate) {</span>
        <span class="s2">this</span><span class="s1">.pushClassPrivateMethod(classBody, privateMethod, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const isConstructor = </span><span class="s2">this</span><span class="s1">.isNonstaticConstructor(publicMethod);</span>
      <span class="s1">let allowsDirectSuper = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(isConstructor) {</span>
        <span class="s1">publicMethod.kind = </span><span class="s0">&quot;constructor&quot;</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(state.hadConstructor &amp;&amp; !</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;typescript&quot;</span><span class="s1">)) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.DuplicateConstructor, {</span>
            <span class="s1">at: key</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isConstructor &amp;&amp; </span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;typescript&quot;</span><span class="s1">) &amp;&amp; member.override) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.OverrideOnConstructor, {</span>
            <span class="s1">at: key</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">state.hadConstructor = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">allowsDirectSuper = state.hadSuperClass;</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.pushClassMethod(classBody, publicMethod, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, isConstructor, allowsDirectSuper);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isClassProperty()) {</span>
      <span class="s2">if </span><span class="s1">(isPrivate) {</span>
        <span class="s2">this</span><span class="s1">.pushClassPrivateProperty(classBody, privateProp);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.pushClassProperty(classBody, publicProp);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isContextual &amp;&amp; key.name === </span><span class="s0">&quot;async&quot; </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.isLineTerminator()) {</span>
      <span class="s2">this</span><span class="s1">.resetPreviousNodeTrailingComments(key);</span>
      <span class="s1">const isGenerator = </span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">55</span><span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(publicMember.optional) {</span>
        <span class="s2">this</span><span class="s1">.unexpected(maybeQuestionTokenStartLoc);</span>
      <span class="s1">}</span>
      <span class="s1">method.kind = </span><span class="s0">&quot;method&quot;</span><span class="s1">;</span>
      <span class="s1">const isPrivate = </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">136</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.parseClassElementName(method);</span>
      <span class="s2">this</span><span class="s1">.parsePostMemberNameModifiers(publicMember);</span>
      <span class="s2">if </span><span class="s1">(isPrivate) {</span>
        <span class="s2">this</span><span class="s1">.pushClassPrivateMethod(classBody, privateMethod, isGenerator, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isNonstaticConstructor(publicMethod)) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ConstructorIsAsync, {</span>
            <span class="s1">at: publicMethod.key</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.pushClassMethod(classBody, publicMethod, isGenerator, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isContextual &amp;&amp; (key.name === </span><span class="s0">&quot;get&quot; </span><span class="s1">|| key.name === </span><span class="s0">&quot;set&quot;</span><span class="s1">) &amp;&amp; !(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">55</span><span class="s1">) &amp;&amp; </span><span class="s2">this</span><span class="s1">.isLineTerminator())) {</span>
      <span class="s2">this</span><span class="s1">.resetPreviousNodeTrailingComments(key);</span>
      <span class="s1">method.kind = key.name;</span>
      <span class="s1">const isPrivate = </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">136</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.parseClassElementName(publicMethod);</span>
      <span class="s2">if </span><span class="s1">(isPrivate) {</span>
        <span class="s2">this</span><span class="s1">.pushClassPrivateMethod(classBody, privateMethod, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isNonstaticConstructor(publicMethod)) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ConstructorIsAccessor, {</span>
            <span class="s1">at: publicMethod.key</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.pushClassMethod(classBody, publicMethod, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.checkGetterSetterParams(publicMethod);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isContextual &amp;&amp; key.name === </span><span class="s0">&quot;accessor&quot; </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.isLineTerminator()) {</span>
      <span class="s2">this</span><span class="s1">.expectPlugin(</span><span class="s0">&quot;decoratorAutoAccessors&quot;</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.resetPreviousNodeTrailingComments(key);</span>
      <span class="s1">const isPrivate = </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">136</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.parseClassElementName(publicProp);</span>
      <span class="s2">this</span><span class="s1">.pushClassAccessorProperty(classBody, accessorProp, isPrivate);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isLineTerminator()) {</span>
      <span class="s2">if </span><span class="s1">(isPrivate) {</span>
        <span class="s2">this</span><span class="s1">.pushClassPrivateProperty(classBody, privateProp);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.pushClassProperty(classBody, publicProp);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">this</span><span class="s1">.unexpected();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseClassElementName(member) {</span>
    <span class="s1">const {</span>
      <span class="s1">type,</span>
      <span class="s1">value</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
    <span class="s2">if </span><span class="s1">((type === </span><span class="s3">130 </span><span class="s1">|| type === </span><span class="s3">131</span><span class="s1">) &amp;&amp; member.static &amp;&amp; value === </span><span class="s0">&quot;prototype&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.StaticPrototype, {</span>
        <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(type === </span><span class="s3">136</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(value === </span><span class="s0">&quot;constructor&quot;</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ConstructorClassPrivateField, {</span>
          <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s1">const key = </span><span class="s2">this</span><span class="s1">.parsePrivateName();</span>
      <span class="s1">member.key = key;</span>
      <span class="s2">return </span><span class="s1">key;</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parsePropertyName(member);</span>
  <span class="s1">}</span>
  <span class="s1">parseClassStaticBlock(classBody, member) {</span>
    <span class="s2">var </span><span class="s1">_member$decorators;</span>
    <span class="s2">this</span><span class="s1">.scope.enter(_scopeflags.SCOPE_CLASS | _scopeflags.SCOPE_STATIC_BLOCK | _scopeflags.SCOPE_SUPER);</span>
    <span class="s1">const oldLabels = </span><span class="s2">this</span><span class="s1">.state.labels;</span>
    <span class="s2">this</span><span class="s1">.state.labels = [];</span>
    <span class="s2">this</span><span class="s1">.prodParam.enter(_productionParameter.PARAM);</span>
    <span class="s1">const body = member.body = [];</span>
    <span class="s2">this</span><span class="s1">.parseBlockOrModuleBlockBody(body, undefined, </span><span class="s2">false</span><span class="s1">, </span><span class="s3">8</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.prodParam.exit();</span>
    <span class="s2">this</span><span class="s1">.scope.exit();</span>
    <span class="s2">this</span><span class="s1">.state.labels = oldLabels;</span>
    <span class="s1">classBody.body.push(</span><span class="s2">this</span><span class="s1">.finishNode(member, </span><span class="s0">&quot;StaticBlock&quot;</span><span class="s1">));</span>
    <span class="s2">if </span><span class="s1">((_member$decorators = member.decorators) != </span><span class="s2">null </span><span class="s1">&amp;&amp; _member$decorators.length) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.DecoratorStaticBlock, {</span>
        <span class="s1">at: member</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">pushClassProperty(classBody, prop) {</span>
    <span class="s2">if </span><span class="s1">(!prop.computed &amp;&amp; (prop.key.name === </span><span class="s0">&quot;constructor&quot; </span><span class="s1">|| prop.key.value === </span><span class="s0">&quot;constructor&quot;</span><span class="s1">)) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ConstructorClassField, {</span>
        <span class="s1">at: prop.key</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">classBody.body.push(</span><span class="s2">this</span><span class="s1">.parseClassProperty(prop));</span>
  <span class="s1">}</span>
  <span class="s1">pushClassPrivateProperty(classBody, prop) {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.parseClassPrivateProperty(prop);</span>
    <span class="s1">classBody.body.push(node);</span>
    <span class="s2">this</span><span class="s1">.classScope.declarePrivateName(</span><span class="s2">this</span><span class="s1">.getPrivateNameSV(node.key), _scopeflags.CLASS_ELEMENT_OTHER, node.key.loc.start);</span>
  <span class="s1">}</span>
  <span class="s1">pushClassAccessorProperty(classBody, prop, isPrivate) {</span>
    <span class="s2">if </span><span class="s1">(!isPrivate &amp;&amp; !prop.computed) {</span>
      <span class="s1">const key = prop.key;</span>
      <span class="s2">if </span><span class="s1">(key.name === </span><span class="s0">&quot;constructor&quot; </span><span class="s1">|| key.value === </span><span class="s0">&quot;constructor&quot;</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ConstructorClassField, {</span>
          <span class="s1">at: key</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.parseClassAccessorProperty(prop);</span>
    <span class="s1">classBody.body.push(node);</span>
    <span class="s2">if </span><span class="s1">(isPrivate) {</span>
      <span class="s2">this</span><span class="s1">.classScope.declarePrivateName(</span><span class="s2">this</span><span class="s1">.getPrivateNameSV(node.key), _scopeflags.CLASS_ELEMENT_OTHER, node.key.loc.start);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {</span>
    <span class="s1">classBody.body.push(</span><span class="s2">this</span><span class="s1">.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, </span><span class="s0">&quot;ClassMethod&quot;</span><span class="s1">, </span><span class="s2">true</span><span class="s1">));</span>
  <span class="s1">}</span>
  <span class="s1">pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.parseMethod(method, isGenerator, isAsync, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s0">&quot;ClassPrivateMethod&quot;</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">classBody.body.push(node);</span>
    <span class="s1">const kind = node.kind === </span><span class="s0">&quot;get&quot; </span><span class="s1">? node.static ? _scopeflags.CLASS_ELEMENT_STATIC_GETTER : _scopeflags.CLASS_ELEMENT_INSTANCE_GETTER : node.kind === </span><span class="s0">&quot;set&quot; </span><span class="s1">? node.static ? _scopeflags.CLASS_ELEMENT_STATIC_SETTER : _scopeflags.CLASS_ELEMENT_INSTANCE_SETTER : _scopeflags.CLASS_ELEMENT_OTHER;</span>
    <span class="s2">this</span><span class="s1">.declareClassPrivateMethodInScope(node, kind);</span>
  <span class="s1">}</span>
  <span class="s1">declareClassPrivateMethodInScope(node, kind) {</span>
    <span class="s2">this</span><span class="s1">.classScope.declarePrivateName(</span><span class="s2">this</span><span class="s1">.getPrivateNameSV(node.key), kind, node.key.loc.start);</span>
  <span class="s1">}</span>
  <span class="s1">parsePostMemberNameModifiers(methodOrProp) {}</span>
  <span class="s1">parseClassPrivateProperty(node) {</span>
    <span class="s2">this</span><span class="s1">.parseInitializer(node);</span>
    <span class="s2">this</span><span class="s1">.semicolon();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ClassPrivateProperty&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseClassProperty(node) {</span>
    <span class="s2">this</span><span class="s1">.parseInitializer(node);</span>
    <span class="s2">this</span><span class="s1">.semicolon();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ClassProperty&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseClassAccessorProperty(node) {</span>
    <span class="s2">this</span><span class="s1">.parseInitializer(node);</span>
    <span class="s2">this</span><span class="s1">.semicolon();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ClassAccessorProperty&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseInitializer(node) {</span>
    <span class="s2">this</span><span class="s1">.scope.enter(_scopeflags.SCOPE_CLASS | _scopeflags.SCOPE_SUPER);</span>
    <span class="s2">this</span><span class="s1">.expressionScope.enter((</span><span class="s3">0</span><span class="s1">, _expressionScope.newExpressionScope)());</span>
    <span class="s2">this</span><span class="s1">.prodParam.enter(_productionParameter.PARAM);</span>
    <span class="s1">node.value = </span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">29</span><span class="s1">) ? </span><span class="s2">this</span><span class="s1">.parseMaybeAssignAllowIn() : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.expressionScope.exit();</span>
    <span class="s2">this</span><span class="s1">.prodParam.exit();</span>
    <span class="s2">this</span><span class="s1">.scope.exit();</span>
  <span class="s1">}</span>
  <span class="s1">parseClassId(node, isStatement, optionalId, bindingType = _scopeflags.BIND_CLASS) {</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _types.tokenIsIdentifier)(</span><span class="s2">this</span><span class="s1">.state.type)) {</span>
      <span class="s1">node.id = </span><span class="s2">this</span><span class="s1">.parseIdentifier();</span>
      <span class="s2">if </span><span class="s1">(isStatement) {</span>
        <span class="s2">this</span><span class="s1">.declareNameFromIdentifier(node.id, bindingType);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(optionalId || !isStatement) {</span>
        <span class="s1">node.id = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.MissingClassName, {</span>
          <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseClassSuper(node) {</span>
    <span class="s1">node.superClass = </span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">81</span><span class="s1">) ? </span><span class="s2">this</span><span class="s1">.parseExprSubscripts() : </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">parseExport(node, decorators) {</span>
    <span class="s1">const maybeDefaultIdentifier = </span><span class="s2">this</span><span class="s1">.parseMaybeImportPhase(node, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">const hasDefault = </span><span class="s2">this</span><span class="s1">.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);</span>
    <span class="s1">const parseAfterDefault = !hasDefault || </span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">12</span><span class="s1">);</span>
    <span class="s1">const hasStar = parseAfterDefault &amp;&amp; </span><span class="s2">this</span><span class="s1">.eatExportStar(node);</span>
    <span class="s1">const hasNamespace = hasStar &amp;&amp; </span><span class="s2">this</span><span class="s1">.maybeParseExportNamespaceSpecifier(node);</span>
    <span class="s1">const parseAfterNamespace = parseAfterDefault &amp;&amp; (!hasNamespace || </span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">12</span><span class="s1">));</span>
    <span class="s1">const isFromRequired = hasDefault || hasStar;</span>
    <span class="s2">if </span><span class="s1">(hasStar &amp;&amp; !hasNamespace) {</span>
      <span class="s2">if </span><span class="s1">(hasDefault) </span><span class="s2">this</span><span class="s1">.unexpected();</span>
      <span class="s2">if </span><span class="s1">(decorators) {</span>
        <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.UnsupportedDecoratorExport, {</span>
          <span class="s1">at: node</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.parseExportFrom(node, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ExportAllDeclaration&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">const hasSpecifiers = </span><span class="s2">this</span><span class="s1">.maybeParseExportNamedSpecifiers(node);</span>
    <span class="s2">if </span><span class="s1">(hasDefault &amp;&amp; parseAfterDefault &amp;&amp; !hasStar &amp;&amp; !hasSpecifiers) {</span>
      <span class="s2">this</span><span class="s1">.unexpected(</span><span class="s2">null</span><span class="s1">, </span><span class="s3">5</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(hasNamespace &amp;&amp; parseAfterNamespace) {</span>
      <span class="s2">this</span><span class="s1">.unexpected(</span><span class="s2">null</span><span class="s1">, </span><span class="s3">97</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">let hasDeclaration;</span>
    <span class="s2">if </span><span class="s1">(isFromRequired || hasSpecifiers) {</span>
      <span class="s1">hasDeclaration = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(decorators) {</span>
        <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.UnsupportedDecoratorExport, {</span>
          <span class="s1">at: node</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.parseExportFrom(node, isFromRequired);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">hasDeclaration = </span><span class="s2">this</span><span class="s1">.maybeParseExportDeclaration(node);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isFromRequired || hasSpecifiers || hasDeclaration) {</span>
      <span class="s2">var </span><span class="s1">_node2$declaration;</span>
      <span class="s1">const node2 = node;</span>
      <span class="s2">this</span><span class="s1">.checkExport(node2, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, !!node2.source);</span>
      <span class="s2">if </span><span class="s1">(((_node2$declaration = node2.declaration) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _node2$declaration.type) === </span><span class="s0">&quot;ClassDeclaration&quot;</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.maybeTakeDecorators(decorators, node2.declaration, node2);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(decorators) {</span>
        <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.UnsupportedDecoratorExport, {</span>
          <span class="s1">at: node</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">return this</span><span class="s1">.finishNode(node2, </span><span class="s0">&quot;ExportNamedDeclaration&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">65</span><span class="s1">)) {</span>
      <span class="s1">const node2 = node;</span>
      <span class="s1">const decl = </span><span class="s2">this</span><span class="s1">.parseExportDefaultExpression();</span>
      <span class="s1">node2.declaration = decl;</span>
      <span class="s2">if </span><span class="s1">(decl.type === </span><span class="s0">&quot;ClassDeclaration&quot;</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.maybeTakeDecorators(decorators, decl, node2);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(decorators) {</span>
        <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.UnsupportedDecoratorExport, {</span>
          <span class="s1">at: node</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.checkExport(node2, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s2">return this</span><span class="s1">.finishNode(node2, </span><span class="s0">&quot;ExportDefaultDeclaration&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.unexpected(</span><span class="s2">null</span><span class="s1">, </span><span class="s3">5</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">eatExportStar(node) {</span>
    <span class="s2">return this</span><span class="s1">.eat(</span><span class="s3">55</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {</span>
    <span class="s2">if </span><span class="s1">(maybeDefaultIdentifier || </span><span class="s2">this</span><span class="s1">.isExportDefaultSpecifier()) {</span>
      <span class="s2">this</span><span class="s1">.expectPlugin(</span><span class="s0">&quot;exportDefaultFrom&quot;</span><span class="s1">, maybeDefaultIdentifier == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: maybeDefaultIdentifier.loc.start);</span>
      <span class="s1">const id = maybeDefaultIdentifier || </span><span class="s2">this</span><span class="s1">.parseIdentifier(</span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">const specifier = </span><span class="s2">this</span><span class="s1">.startNodeAtNode(id);</span>
      <span class="s1">specifier.exported = id;</span>
      <span class="s1">node.specifiers = [</span><span class="s2">this</span><span class="s1">.finishNode(specifier, </span><span class="s0">&quot;ExportDefaultSpecifier&quot;</span><span class="s1">)];</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">maybeParseExportNamespaceSpecifier(node) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">93</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(!node.specifiers) node.specifiers = [];</span>
      <span class="s1">const specifier = </span><span class="s2">this</span><span class="s1">.startNodeAt(</span><span class="s2">this</span><span class="s1">.state.lastTokStartLoc);</span>
      <span class="s2">this</span><span class="s1">.next();</span>
      <span class="s1">specifier.exported = </span><span class="s2">this</span><span class="s1">.parseModuleExportName();</span>
      <span class="s1">node.specifiers.push(</span><span class="s2">this</span><span class="s1">.finishNode(specifier, </span><span class="s0">&quot;ExportNamespaceSpecifier&quot;</span><span class="s1">));</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">maybeParseExportNamedSpecifiers(node) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">5</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(!node.specifiers) node.specifiers = [];</span>
      <span class="s1">const isTypeExport = node.exportKind === </span><span class="s0">&quot;type&quot;</span><span class="s1">;</span>
      <span class="s1">node.specifiers.push(...</span><span class="s2">this</span><span class="s1">.parseExportSpecifiers(isTypeExport));</span>
      <span class="s1">node.source = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">node.declaration = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;importAssertions&quot;</span><span class="s1">)) {</span>
        <span class="s1">node.assertions = [];</span>
      <span class="s1">}</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">maybeParseExportDeclaration(node) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.shouldParseExportDeclaration()) {</span>
      <span class="s1">node.specifiers = [];</span>
      <span class="s1">node.source = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;importAssertions&quot;</span><span class="s1">)) {</span>
        <span class="s1">node.assertions = [];</span>
      <span class="s1">}</span>
      <span class="s1">node.declaration = </span><span class="s2">this</span><span class="s1">.parseExportDeclaration(node);</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">isAsyncFunction() {</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">95</span><span class="s1">)) </span><span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">const next = </span><span class="s2">this</span><span class="s1">.nextTokenInLineStart();</span>
    <span class="s2">return this</span><span class="s1">.isUnparsedContextual(next, </span><span class="s0">&quot;function&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseExportDefaultExpression() {</span>
    <span class="s1">const expr = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">68</span><span class="s1">)) {</span>
      <span class="s2">this</span><span class="s1">.next();</span>
      <span class="s2">return this</span><span class="s1">.parseFunction(expr, ParseFunctionFlag.Declaration | ParseFunctionFlag.NullableId);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isAsyncFunction()) {</span>
      <span class="s2">this</span><span class="s1">.next();</span>
      <span class="s2">this</span><span class="s1">.next();</span>
      <span class="s2">return this</span><span class="s1">.parseFunction(expr, ParseFunctionFlag.Declaration | ParseFunctionFlag.NullableId | ParseFunctionFlag.Async);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">80</span><span class="s1">)) {</span>
      <span class="s2">return this</span><span class="s1">.parseClass(expr, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">26</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;decorators&quot;</span><span class="s1">) &amp;&amp; </span><span class="s2">this</span><span class="s1">.getPluginOption(</span><span class="s0">&quot;decorators&quot;</span><span class="s1">, </span><span class="s0">&quot;decoratorsBeforeExport&quot;</span><span class="s1">) === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.DecoratorBeforeExport, {</span>
          <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">return this</span><span class="s1">.parseClass(</span><span class="s2">this</span><span class="s1">.maybeTakeDecorators(</span><span class="s2">this</span><span class="s1">.parseDecorators(</span><span class="s2">false</span><span class="s1">), </span><span class="s2">this</span><span class="s1">.startNode()), </span><span class="s2">true</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">75</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">74</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.isLet()) {</span>
      <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.UnsupportedDefaultExport, {</span>
        <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">const res = </span><span class="s2">this</span><span class="s1">.parseMaybeAssignAllowIn();</span>
    <span class="s2">this</span><span class="s1">.semicolon();</span>
    <span class="s2">return </span><span class="s1">res;</span>
  <span class="s1">}</span>
  <span class="s1">parseExportDeclaration(node) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">80</span><span class="s1">)) {</span>
      <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.parseClass(</span><span class="s2">this</span><span class="s1">.startNode(), </span><span class="s2">true</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s2">return </span><span class="s1">node;</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseStatementListItem();</span>
  <span class="s1">}</span>
  <span class="s1">isExportDefaultSpecifier() {</span>
    <span class="s1">const {</span>
      <span class="s1">type</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _types.tokenIsIdentifier)(type)) {</span>
      <span class="s2">if </span><span class="s1">(type === </span><span class="s3">95 </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.state.containsEsc || type === </span><span class="s3">99</span><span class="s1">) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">((type === </span><span class="s3">128 </span><span class="s1">|| type === </span><span class="s3">127</span><span class="s1">) &amp;&amp; !</span><span class="s2">this</span><span class="s1">.state.containsEsc) {</span>
        <span class="s1">const {</span>
          <span class="s1">type: nextType</span>
        <span class="s1">} = </span><span class="s2">this</span><span class="s1">.lookahead();</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _types.tokenIsIdentifier)(nextType) &amp;&amp; nextType !== </span><span class="s3">97 </span><span class="s1">|| nextType === </span><span class="s3">5</span><span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">.expectOnePlugin([</span><span class="s0">&quot;flow&quot;</span><span class="s1">, </span><span class="s0">&quot;typescript&quot;</span><span class="s1">]);</span>
          <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">65</span><span class="s1">)) {</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const next = </span><span class="s2">this</span><span class="s1">.nextTokenStart();</span>
    <span class="s1">const hasFrom = </span><span class="s2">this</span><span class="s1">.isUnparsedContextual(next, </span><span class="s0">&quot;from&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.input.charCodeAt(next) === </span><span class="s3">44 </span><span class="s1">|| (</span><span class="s3">0</span><span class="s1">, _types.tokenIsIdentifier)(</span><span class="s2">this</span><span class="s1">.state.type) &amp;&amp; hasFrom) {</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">65</span><span class="s1">) &amp;&amp; hasFrom) {</span>
      <span class="s1">const nextAfterFrom = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.nextTokenStartSince(next + </span><span class="s3">4</span><span class="s1">));</span>
      <span class="s2">return </span><span class="s1">nextAfterFrom === </span><span class="s3">34 </span><span class="s1">|| nextAfterFrom === </span><span class="s3">39</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">parseExportFrom(node, expect) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eatContextual(</span><span class="s3">97</span><span class="s1">)) {</span>
      <span class="s1">node.source = </span><span class="s2">this</span><span class="s1">.parseImportSource();</span>
      <span class="s2">this</span><span class="s1">.checkExport(node);</span>
      <span class="s2">this</span><span class="s1">.maybeParseImportAttributes(node);</span>
      <span class="s2">this</span><span class="s1">.checkJSONModuleImport(node);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(expect) {</span>
      <span class="s2">this</span><span class="s1">.unexpected();</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.semicolon();</span>
  <span class="s1">}</span>
  <span class="s1">shouldParseExportDeclaration() {</span>
    <span class="s1">const {</span>
      <span class="s1">type</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
    <span class="s2">if </span><span class="s1">(type === </span><span class="s3">26</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.expectOnePlugin([</span><span class="s0">&quot;decorators&quot;</span><span class="s1">, </span><span class="s0">&quot;decorators-legacy&quot;</span><span class="s1">]);</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;decorators&quot;</span><span class="s1">)) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.getPluginOption(</span><span class="s0">&quot;decorators&quot;</span><span class="s1">, </span><span class="s0">&quot;decoratorsBeforeExport&quot;</span><span class="s1">) === </span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.DecoratorBeforeExport, {</span>
            <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">type === </span><span class="s3">74 </span><span class="s1">|| type === </span><span class="s3">75 </span><span class="s1">|| type === </span><span class="s3">68 </span><span class="s1">|| type === </span><span class="s3">80 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.isLet() || </span><span class="s2">this</span><span class="s1">.isAsyncFunction();</span>
  <span class="s1">}</span>
  <span class="s1">checkExport(node, checkNames, isDefault, isFrom) {</span>
    <span class="s2">if </span><span class="s1">(checkNames) {</span>
      <span class="s2">if </span><span class="s1">(isDefault) {</span>
        <span class="s2">this</span><span class="s1">.checkDuplicateExports(node, </span><span class="s0">&quot;default&quot;</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;exportDefaultFrom&quot;</span><span class="s1">)) {</span>
          <span class="s2">var </span><span class="s1">_declaration$extra;</span>
          <span class="s1">const declaration = node.declaration;</span>
          <span class="s2">if </span><span class="s1">(declaration.type === </span><span class="s0">&quot;Identifier&quot; </span><span class="s1">&amp;&amp; declaration.name === </span><span class="s0">&quot;from&quot; </span><span class="s1">&amp;&amp; declaration.end - declaration.start === </span><span class="s3">4 </span><span class="s1">&amp;&amp; !((_declaration$extra = declaration.extra) != </span><span class="s2">null </span><span class="s1">&amp;&amp; _declaration$extra.parenthesized)) {</span>
            <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ExportDefaultFromAsIdentifier, {</span>
              <span class="s1">at: declaration</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node.specifiers &amp;&amp; node.specifiers.length) {</span>
        <span class="s2">for </span><span class="s1">(const specifier of node.specifiers) {</span>
          <span class="s1">const {</span>
            <span class="s1">exported</span>
          <span class="s1">} = specifier;</span>
          <span class="s1">const exportName = exported.type === </span><span class="s0">&quot;Identifier&quot; </span><span class="s1">? exported.name : exported.value;</span>
          <span class="s2">this</span><span class="s1">.checkDuplicateExports(specifier, exportName);</span>
          <span class="s2">if </span><span class="s1">(!isFrom &amp;&amp; specifier.local) {</span>
            <span class="s1">const {</span>
              <span class="s1">local</span>
            <span class="s1">} = specifier;</span>
            <span class="s2">if </span><span class="s1">(local.type !== </span><span class="s0">&quot;Identifier&quot;</span><span class="s1">) {</span>
              <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ExportBindingIsString, {</span>
                <span class="s1">at: specifier,</span>
                <span class="s1">localName: local.value,</span>
                <span class="s1">exportName</span>
              <span class="s1">});</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s2">this</span><span class="s1">.checkReservedWord(local.name, local.loc.start, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
              <span class="s2">this</span><span class="s1">.scope.checkLocalExport(local);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node.declaration) {</span>
        <span class="s2">if </span><span class="s1">(node.declaration.type === </span><span class="s0">&quot;FunctionDeclaration&quot; </span><span class="s1">|| node.declaration.type === </span><span class="s0">&quot;ClassDeclaration&quot;</span><span class="s1">) {</span>
          <span class="s1">const id = node.declaration.id;</span>
          <span class="s2">if </span><span class="s1">(!id) </span><span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;Assertion failure&quot;</span><span class="s1">);</span>
          <span class="s2">this</span><span class="s1">.checkDuplicateExports(node, id.name);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node.declaration.type === </span><span class="s0">&quot;VariableDeclaration&quot;</span><span class="s1">) {</span>
          <span class="s2">for </span><span class="s1">(const declaration of node.declaration.declarations) {</span>
            <span class="s2">this</span><span class="s1">.checkDeclaration(declaration.id);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">checkDeclaration(node) {</span>
    <span class="s2">if </span><span class="s1">(node.type === </span><span class="s0">&quot;Identifier&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.checkDuplicateExports(node, node.name);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node.type === </span><span class="s0">&quot;ObjectPattern&quot;</span><span class="s1">) {</span>
      <span class="s2">for </span><span class="s1">(const prop of node.properties) {</span>
        <span class="s2">this</span><span class="s1">.checkDeclaration(prop);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node.type === </span><span class="s0">&quot;ArrayPattern&quot;</span><span class="s1">) {</span>
      <span class="s2">for </span><span class="s1">(const elem of node.elements) {</span>
        <span class="s2">if </span><span class="s1">(elem) {</span>
          <span class="s2">this</span><span class="s1">.checkDeclaration(elem);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node.type === </span><span class="s0">&quot;ObjectProperty&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.checkDeclaration(node.value);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node.type === </span><span class="s0">&quot;RestElement&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.checkDeclaration(node.argument);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node.type === </span><span class="s0">&quot;AssignmentPattern&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.checkDeclaration(node.left);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">checkDuplicateExports(node, exportName) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.exportedIdentifiers.has(exportName)) {</span>
      <span class="s2">if </span><span class="s1">(exportName === </span><span class="s0">&quot;default&quot;</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.DuplicateDefaultExport, {</span>
          <span class="s1">at: node</span>
        <span class="s1">});</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.DuplicateExport, {</span>
          <span class="s1">at: node,</span>
          <span class="s1">exportName</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.exportedIdentifiers.add(exportName);</span>
  <span class="s1">}</span>
  <span class="s1">parseExportSpecifiers(isInTypeExport) {</span>
    <span class="s1">const nodes = [];</span>
    <span class="s1">let first = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">5</span><span class="s1">);</span>
    <span class="s2">while </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">8</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(first) {</span>
        <span class="s1">first = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">12</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">8</span><span class="s1">)) </span><span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const isMaybeTypeOnly = </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">128</span><span class="s1">);</span>
      <span class="s1">const isString = </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">131</span><span class="s1">);</span>
      <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
      <span class="s1">node.local = </span><span class="s2">this</span><span class="s1">.parseModuleExportName();</span>
      <span class="s1">nodes.push(</span><span class="s2">this</span><span class="s1">.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">nodes;</span>
  <span class="s1">}</span>
  <span class="s1">parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eatContextual(</span><span class="s3">93</span><span class="s1">)) {</span>
      <span class="s1">node.exported = </span><span class="s2">this</span><span class="s1">.parseModuleExportName();</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isString) {</span>
      <span class="s1">node.exported = (</span><span class="s3">0</span><span class="s1">, _node.cloneStringLiteral)(node.local);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!node.exported) {</span>
      <span class="s1">node.exported = (</span><span class="s3">0</span><span class="s1">, _node.cloneIdentifier)(node.local);</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ExportSpecifier&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseModuleExportName() {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">131</span><span class="s1">)) {</span>
      <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.parseStringLiteral(</span><span class="s2">this</span><span class="s1">.state.value);</span>
      <span class="s1">const surrogate = result.value.match(loneSurrogate);</span>
      <span class="s2">if </span><span class="s1">(surrogate) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ModuleExportNameHasLoneSurrogate, {</span>
          <span class="s1">at: result,</span>
          <span class="s1">surrogateCharCode: surrogate[</span><span class="s3">0</span><span class="s1">].charCodeAt(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseIdentifier(</span><span class="s2">true</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">isJSONModuleImport(node) {</span>
    <span class="s2">if </span><span class="s1">(node.assertions != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">node.assertions.some(({</span>
        <span class="s1">key,</span>
        <span class="s1">value</span>
      <span class="s1">}) =&gt; {</span>
        <span class="s2">return </span><span class="s1">value.value === </span><span class="s0">&quot;json&quot; </span><span class="s1">&amp;&amp; (key.type === </span><span class="s0">&quot;Identifier&quot; </span><span class="s1">? key.name === </span><span class="s0">&quot;type&quot; </span><span class="s1">: key.value === </span><span class="s0">&quot;type&quot;</span><span class="s1">);</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">checkImportReflection(node) {</span>
    <span class="s2">if </span><span class="s1">(node.module) {</span>
      <span class="s2">var </span><span class="s1">_node$assertions;</span>
      <span class="s2">if </span><span class="s1">(node.specifiers.length !== </span><span class="s3">1 </span><span class="s1">|| node.specifiers[</span><span class="s3">0</span><span class="s1">].type !== </span><span class="s0">&quot;ImportDefaultSpecifier&quot;</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ImportReflectionNotBinding, {</span>
          <span class="s1">at: node.specifiers[</span><span class="s3">0</span><span class="s1">].loc.start</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(((_node$assertions = node.assertions) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _node$assertions.length) &gt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ImportReflectionHasAssertion, {</span>
          <span class="s1">at: node.specifiers[</span><span class="s3">0</span><span class="s1">].loc.start</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">checkJSONModuleImport(node) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isJSONModuleImport(node) &amp;&amp; node.type !== </span><span class="s0">&quot;ExportAllDeclaration&quot;</span><span class="s1">) {</span>
      <span class="s1">const {</span>
        <span class="s1">specifiers</span>
      <span class="s1">} = node;</span>
      <span class="s2">if </span><span class="s1">(specifiers != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">const nonDefaultNamedSpecifier = specifiers.find(specifier =&gt; {</span>
          <span class="s1">let imported;</span>
          <span class="s2">if </span><span class="s1">(specifier.type === </span><span class="s0">&quot;ExportSpecifier&quot;</span><span class="s1">) {</span>
            <span class="s1">imported = specifier.local;</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(specifier.type === </span><span class="s0">&quot;ImportSpecifier&quot;</span><span class="s1">) {</span>
            <span class="s1">imported = specifier.imported;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(imported !== undefined) {</span>
            <span class="s2">return </span><span class="s1">imported.type === </span><span class="s0">&quot;Identifier&quot; </span><span class="s1">? imported.name !== </span><span class="s0">&quot;default&quot; </span><span class="s1">: imported.value !== </span><span class="s0">&quot;default&quot;</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(nonDefaultNamedSpecifier !== undefined) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ImportJSONBindingNotDefault, {</span>
            <span class="s1">at: nonDefaultNamedSpecifier.loc.start</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">isPotentialImportPhase(isExport) {</span>
    <span class="s2">return </span><span class="s1">!isExport &amp;&amp; </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">125</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">applyImportPhase(node, isExport, phase, loc) {</span>
    <span class="s2">if </span><span class="s1">(isExport) {</span>
      <span class="s1">;</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(phase === </span><span class="s0">&quot;module&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.expectPlugin(</span><span class="s0">&quot;importReflection&quot;</span><span class="s1">, loc);</span>
      <span class="s1">node.module = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;importReflection&quot;</span><span class="s1">)) {</span>
      <span class="s1">node.module = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseMaybeImportPhase(node, isExport) {</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isPotentialImportPhase(isExport)) {</span>
      <span class="s2">this</span><span class="s1">.applyImportPhase(node, isExport, </span><span class="s2">null</span><span class="s1">);</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const phaseIdentifier = </span><span class="s2">this</span><span class="s1">.parseIdentifier(</span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">const {</span>
      <span class="s1">type</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
    <span class="s1">const isImportPhase = (</span><span class="s3">0</span><span class="s1">, _types.tokenIsKeywordOrIdentifier)(type) ? type !== </span><span class="s3">97 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.lookaheadCharCode() === </span><span class="s3">102 </span><span class="s1">: type !== </span><span class="s3">12</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(isImportPhase) {</span>
      <span class="s2">this</span><span class="s1">.resetPreviousIdentifierLeadingComments(phaseIdentifier);</span>
      <span class="s2">this</span><span class="s1">.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">this</span><span class="s1">.applyImportPhase(node, isExport, </span><span class="s2">null</span><span class="s1">);</span>
      <span class="s2">return </span><span class="s1">phaseIdentifier;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">isPrecedingIdImportPhase(phase) {</span>
    <span class="s1">const {</span>
      <span class="s1">type</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _types.tokenIsIdentifier)(type) ? type !== </span><span class="s3">97 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.lookaheadCharCode() === </span><span class="s3">102 </span><span class="s1">: type !== </span><span class="s3">12</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">parseImport(node) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">131</span><span class="s1">)) {</span>
      <span class="s2">return this</span><span class="s1">.parseImportSourceAndAttributes(node);</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseImportSpecifiersAndAfter(node, </span><span class="s2">this</span><span class="s1">.parseMaybeImportPhase(node, </span><span class="s2">false</span><span class="s1">));</span>
  <span class="s1">}</span>
  <span class="s1">parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {</span>
    <span class="s1">node.specifiers = [];</span>
    <span class="s1">const hasDefault = </span><span class="s2">this</span><span class="s1">.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);</span>
    <span class="s1">const parseNext = !hasDefault || </span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">12</span><span class="s1">);</span>
    <span class="s1">const hasStar = parseNext &amp;&amp; </span><span class="s2">this</span><span class="s1">.maybeParseStarImportSpecifier(node);</span>
    <span class="s2">if </span><span class="s1">(parseNext &amp;&amp; !hasStar) </span><span class="s2">this</span><span class="s1">.parseNamedImportSpecifiers(node);</span>
    <span class="s2">this</span><span class="s1">.expectContextual(</span><span class="s3">97</span><span class="s1">);</span>
    <span class="s2">return this</span><span class="s1">.parseImportSourceAndAttributes(node);</span>
  <span class="s1">}</span>
  <span class="s1">parseImportSourceAndAttributes(node) {</span>
    <span class="s2">var </span><span class="s1">_node$specifiers;</span>
    <span class="s1">(_node$specifiers = node.specifiers) != </span><span class="s2">null </span><span class="s1">? _node$specifiers : node.specifiers = [];</span>
    <span class="s1">node.source = </span><span class="s2">this</span><span class="s1">.parseImportSource();</span>
    <span class="s2">this</span><span class="s1">.maybeParseImportAttributes(node);</span>
    <span class="s2">this</span><span class="s1">.checkImportReflection(node);</span>
    <span class="s2">this</span><span class="s1">.checkJSONModuleImport(node);</span>
    <span class="s2">this</span><span class="s1">.semicolon();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ImportDeclaration&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseImportSource() {</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">131</span><span class="s1">)) </span><span class="s2">this</span><span class="s1">.unexpected();</span>
    <span class="s2">return this</span><span class="s1">.parseExprAtom();</span>
  <span class="s1">}</span>
  <span class="s1">parseImportSpecifierLocal(node, specifier, type) {</span>
    <span class="s1">specifier.local = </span><span class="s2">this</span><span class="s1">.parseIdentifier();</span>
    <span class="s1">node.specifiers.push(</span><span class="s2">this</span><span class="s1">.finishImportSpecifier(specifier, type));</span>
  <span class="s1">}</span>
  <span class="s1">finishImportSpecifier(specifier, type, bindingType = _scopeflags.BIND_LEXICAL) {</span>
    <span class="s2">this</span><span class="s1">.checkLVal(specifier.local, {</span>
      <span class="s2">in</span><span class="s1">: {</span>
        <span class="s1">type</span>
      <span class="s1">},</span>
      <span class="s1">binding: bindingType</span>
    <span class="s1">});</span>
    <span class="s2">return this</span><span class="s1">.finishNode(specifier, type);</span>
  <span class="s1">}</span>
  <span class="s1">parseImportAttributes() {</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">5</span><span class="s1">);</span>
    <span class="s1">const attrs = [];</span>
    <span class="s1">const attrNames = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s2">do </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">8</span><span class="s1">)) {</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
      <span class="s1">const keyName = </span><span class="s2">this</span><span class="s1">.state.value;</span>
      <span class="s2">if </span><span class="s1">(attrNames.has(keyName)) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ModuleAttributesWithDuplicateKeys, {</span>
          <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc,</span>
          <span class="s1">key: keyName</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s1">attrNames.add(keyName);</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">131</span><span class="s1">)) {</span>
        <span class="s1">node.key = </span><span class="s2">this</span><span class="s1">.parseStringLiteral(keyName);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">node.key = </span><span class="s2">this</span><span class="s1">.parseIdentifier(</span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">14</span><span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">131</span><span class="s1">)) {</span>
        <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.ModuleAttributeInvalidValue, {</span>
          <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s1">node.value = </span><span class="s2">this</span><span class="s1">.parseStringLiteral(</span><span class="s2">this</span><span class="s1">.state.value);</span>
      <span class="s1">attrs.push(</span><span class="s2">this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ImportAttribute&quot;</span><span class="s1">));</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">12</span><span class="s1">));</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">8</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">attrs;</span>
  <span class="s1">}</span>
  <span class="s1">parseModuleAttributes() {</span>
    <span class="s1">const attrs = [];</span>
    <span class="s1">const attributes = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s2">do </span><span class="s1">{</span>
      <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
      <span class="s1">node.key = </span><span class="s2">this</span><span class="s1">.parseIdentifier(</span><span class="s2">true</span><span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(node.key.name !== </span><span class="s0">&quot;type&quot;</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ModuleAttributeDifferentFromType, {</span>
          <span class="s1">at: node.key</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(attributes.has(node.key.name)) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ModuleAttributesWithDuplicateKeys, {</span>
          <span class="s1">at: node.key,</span>
          <span class="s1">key: node.key.name</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s1">attributes.add(node.key.name);</span>
      <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">14</span><span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">131</span><span class="s1">)) {</span>
        <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.ModuleAttributeInvalidValue, {</span>
          <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s1">node.value = </span><span class="s2">this</span><span class="s1">.parseStringLiteral(</span><span class="s2">this</span><span class="s1">.state.value);</span>
      <span class="s1">attrs.push(</span><span class="s2">this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ImportAttribute&quot;</span><span class="s1">));</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">12</span><span class="s1">));</span>
    <span class="s2">return </span><span class="s1">attrs;</span>
  <span class="s1">}</span>
  <span class="s1">maybeParseImportAttributes(node) {</span>
    <span class="s1">let attributes;</span>
    <span class="s1">let useWith = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">76</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPrecedingLineBreak() &amp;&amp; </span><span class="s2">this</span><span class="s1">.lookaheadCharCode() === </span><span class="s3">40</span><span class="s1">) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.next();</span>
      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;moduleAttributes&quot;</span><span class="s1">)) {</span>
          <span class="s1">attributes = </span><span class="s2">this</span><span class="s1">.parseModuleAttributes();</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">this</span><span class="s1">.expectImportAttributesPlugin();</span>
          <span class="s1">attributes = </span><span class="s2">this</span><span class="s1">.parseImportAttributes();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">useWith = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">94</span><span class="s1">) &amp;&amp; !</span><span class="s2">this</span><span class="s1">.hasPrecedingLineBreak()) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;importAttributes&quot;</span><span class="s1">)) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.getPluginOption(</span><span class="s0">&quot;importAttributes&quot;</span><span class="s1">, </span><span class="s0">&quot;deprecatedAssertSyntax&quot;</span><span class="s1">) !== </span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ImportAttributesUseAssert, {</span>
            <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.addExtra(node, </span><span class="s0">&quot;deprecatedAssertSyntax&quot;</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.expectOnePlugin([</span><span class="s0">&quot;importAttributes&quot;</span><span class="s1">, </span><span class="s0">&quot;importAssertions&quot;</span><span class="s1">]);</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.next();</span>
      <span class="s1">attributes = </span><span class="s2">this</span><span class="s1">.parseImportAttributes();</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;importAttributes&quot;</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;importAssertions&quot;</span><span class="s1">)) {</span>
      <span class="s1">attributes = [];</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;moduleAttributes&quot;</span><span class="s1">)) {</span>
        <span class="s1">attributes = [];</span>
      <span class="s1">} </span><span class="s2">else return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!useWith &amp;&amp; </span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;importAssertions&quot;</span><span class="s1">)) {</span>
      <span class="s1">node.assertions = attributes;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">node.attributes = attributes;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {</span>
    <span class="s2">if </span><span class="s1">(maybeDefaultIdentifier) {</span>
      <span class="s1">const specifier = </span><span class="s2">this</span><span class="s1">.startNodeAtNode(maybeDefaultIdentifier);</span>
      <span class="s1">specifier.local = maybeDefaultIdentifier;</span>
      <span class="s1">node.specifiers.push(</span><span class="s2">this</span><span class="s1">.finishImportSpecifier(specifier, </span><span class="s0">&quot;ImportDefaultSpecifier&quot;</span><span class="s1">));</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _types.tokenIsKeywordOrIdentifier)(</span><span class="s2">this</span><span class="s1">.state.type)) {</span>
      <span class="s2">this</span><span class="s1">.parseImportSpecifierLocal(node, </span><span class="s2">this</span><span class="s1">.startNode(), </span><span class="s0">&quot;ImportDefaultSpecifier&quot;</span><span class="s1">);</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">maybeParseStarImportSpecifier(node) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">55</span><span class="s1">)) {</span>
      <span class="s1">const specifier = </span><span class="s2">this</span><span class="s1">.startNode();</span>
      <span class="s2">this</span><span class="s1">.next();</span>
      <span class="s2">this</span><span class="s1">.expectContextual(</span><span class="s3">93</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.parseImportSpecifierLocal(node, specifier, </span><span class="s0">&quot;ImportNamespaceSpecifier&quot;</span><span class="s1">);</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">parseNamedImportSpecifiers(node) {</span>
    <span class="s1">let first = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">5</span><span class="s1">);</span>
    <span class="s2">while </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">8</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(first) {</span>
        <span class="s1">first = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">14</span><span class="s1">)) {</span>
          <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.DestructureNamedImport, {</span>
            <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">12</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">8</span><span class="s1">)) </span><span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const specifier = </span><span class="s2">this</span><span class="s1">.startNode();</span>
      <span class="s1">const importedIsString = </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">131</span><span class="s1">);</span>
      <span class="s1">const isMaybeTypeOnly = </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">128</span><span class="s1">);</span>
      <span class="s1">specifier.imported = </span><span class="s2">this</span><span class="s1">.parseModuleExportName();</span>
      <span class="s1">const importSpecifier = </span><span class="s2">this</span><span class="s1">.parseImportSpecifier(specifier, importedIsString, node.importKind === </span><span class="s0">&quot;type&quot; </span><span class="s1">|| node.importKind === </span><span class="s0">&quot;typeof&quot;</span><span class="s1">, isMaybeTypeOnly, undefined);</span>
      <span class="s1">node.specifiers.push(importSpecifier);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eatContextual(</span><span class="s3">93</span><span class="s1">)) {</span>
      <span class="s1">specifier.local = </span><span class="s2">this</span><span class="s1">.parseIdentifier();</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">const {</span>
        <span class="s1">imported</span>
      <span class="s1">} = specifier;</span>
      <span class="s2">if </span><span class="s1">(importedIsString) {</span>
        <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.ImportBindingIsString, {</span>
          <span class="s1">at: specifier,</span>
          <span class="s1">importName: imported.value</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.checkReservedWord(imported.name, specifier.loc.start, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(!specifier.local) {</span>
        <span class="s1">specifier.local = (</span><span class="s3">0</span><span class="s1">, _node.cloneIdentifier)(imported);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishImportSpecifier(specifier, </span><span class="s0">&quot;ImportSpecifier&quot;</span><span class="s1">, bindingType);</span>
  <span class="s1">}</span>
  <span class="s1">isThisParam(param) {</span>
    <span class="s2">return </span><span class="s1">param.type === </span><span class="s0">&quot;Identifier&quot; </span><span class="s1">&amp;&amp; param.name === </span><span class="s0">&quot;this&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= StatementParser;</span>

<span class="s4">//# sourceMappingURL=statement.js.map</span>
</pre>
</body>
</html>
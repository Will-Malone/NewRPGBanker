<html>
<head>
<title>ReactNativeRenderer-profiling.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ReactNativeRenderer-profiling.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * Copyright (c) Facebook, Inc. and its affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 * @noflow 
 * @nolint 
 * @providesModule ReactNativeRenderer-profiling 
 * @preventMunge 
 * @generated SignedSource&lt;&lt;380a53922e2dcceb4a32c98acc12f578&gt;&gt; 
 */</span>


          <span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s0">/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */</span>
<span class="s3">if </span><span class="s1">(</span>
  <span class="s3">typeof </span><span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__ !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp;</span>
  <span class="s3">typeof </span><span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===</span>
    <span class="s2">'function'</span>
<span class="s1">) {</span>
  <span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(</span><span class="s3">new </span><span class="s1">Error());</span>
<span class="s1">}</span>
          <span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">require(</span><span class="s2">&quot;react-native/Libraries/ReactPrivate/ReactNativePrivateInitializeCore&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">ReactNativePrivateInterface = require(</span><span class="s2">&quot;react-native/Libraries/ReactPrivate/ReactNativePrivateInterface&quot;</span><span class="s1">),</span>
  <span class="s1">React = require(</span><span class="s2">&quot;react&quot;</span><span class="s1">),</span>
  <span class="s1">Scheduler = require(</span><span class="s2">&quot;scheduler&quot;</span><span class="s1">);</span>
<span class="s3">function </span><span class="s1">invokeGuardedCallbackImpl(name, func, context, a, b, c, d, e, f) {</span>
  <span class="s3">var </span><span class="s1">funcArgs = Array.prototype.slice.call(arguments, </span><span class="s4">3</span><span class="s1">);</span>
  <span class="s3">try </span><span class="s1">{</span>
    <span class="s1">func.apply(context, funcArgs);</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
    <span class="s3">this</span><span class="s1">.onError(error);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">hasError = !</span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">caughtError = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">hasRethrowError = !</span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">rethrowError = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">reporter = {</span>
    <span class="s1">onError: </span><span class="s3">function</span><span class="s1">(error) {</span>
      <span class="s1">hasError = !</span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">caughtError = error;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s3">function </span><span class="s1">invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {</span>
  <span class="s1">hasError = !</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">caughtError = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">invokeGuardedCallbackImpl.apply(reporter, arguments);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">invokeGuardedCallbackAndCatchFirstError(</span>
  <span class="s1">name,</span>
  <span class="s1">func,</span>
  <span class="s1">context,</span>
  <span class="s1">a,</span>
  <span class="s1">b,</span>
  <span class="s1">c,</span>
  <span class="s1">d,</span>
  <span class="s1">e,</span>
  <span class="s1">f</span>
<span class="s1">) {</span>
  <span class="s1">invokeGuardedCallback.apply(</span><span class="s3">this</span><span class="s1">, arguments);</span>
  <span class="s3">if </span><span class="s1">(hasError) {</span>
    <span class="s3">if </span><span class="s1">(hasError) {</span>
      <span class="s3">var </span><span class="s1">error = caughtError;</span>
      <span class="s1">hasError = !</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">caughtError = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else</span>
      <span class="s3">throw </span><span class="s1">Error(</span>
        <span class="s2">&quot;clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">hasRethrowError || ((hasRethrowError = !</span><span class="s4">0</span><span class="s1">), (rethrowError = error));</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">isArrayImpl = Array.isArray,</span>
  <span class="s1">getFiberCurrentPropsFromNode = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">getInstanceFromNode = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">getNodeFromInstance = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">executeDispatch(event, listener, inst) {</span>
  <span class="s3">var </span><span class="s1">type = event.type || </span><span class="s2">&quot;unknown-event&quot;</span><span class="s1">;</span>
  <span class="s1">event.currentTarget = getNodeFromInstance(inst);</span>
  <span class="s1">invokeGuardedCallbackAndCatchFirstError(type, listener, </span><span class="s3">void </span><span class="s4">0</span><span class="s1">, event);</span>
  <span class="s1">event.currentTarget = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">executeDirectDispatch(event) {</span>
  <span class="s3">var </span><span class="s1">dispatchListener = event._dispatchListeners,</span>
    <span class="s1">dispatchInstance = event._dispatchInstances;</span>
  <span class="s3">if </span><span class="s1">(isArrayImpl(dispatchListener))</span>
    <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;executeDirectDispatch(...): Invalid `event`.&quot;</span><span class="s1">);</span>
  <span class="s1">event.currentTarget = dispatchListener</span>
    <span class="s1">? getNodeFromInstance(dispatchInstance)</span>
    <span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">dispatchListener = dispatchListener ? dispatchListener(event) : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">event.currentTarget = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">event._dispatchListeners = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">event._dispatchInstances = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">dispatchListener;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">assign = Object.assign;</span>
<span class="s3">function </span><span class="s1">functionThatReturnsTrue() {</span>
  <span class="s3">return </span><span class="s1">!</span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">functionThatReturnsFalse() {</span>
  <span class="s3">return </span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">SyntheticEvent(</span>
  <span class="s1">dispatchConfig,</span>
  <span class="s1">targetInst,</span>
  <span class="s1">nativeEvent,</span>
  <span class="s1">nativeEventTarget</span>
<span class="s1">) {</span>
  <span class="s3">this</span><span class="s1">.dispatchConfig = dispatchConfig;</span>
  <span class="s3">this</span><span class="s1">._targetInst = targetInst;</span>
  <span class="s3">this</span><span class="s1">.nativeEvent = nativeEvent;</span>
  <span class="s3">this</span><span class="s1">._dispatchInstances = </span><span class="s3">this</span><span class="s1">._dispatchListeners = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">dispatchConfig = </span><span class="s3">this</span><span class="s1">.constructor.Interface;</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">propName </span><span class="s3">in </span><span class="s1">dispatchConfig)</span>
    <span class="s1">dispatchConfig.hasOwnProperty(propName) &amp;&amp;</span>
      <span class="s1">((targetInst = dispatchConfig[propName])</span>
        <span class="s1">? (</span><span class="s3">this</span><span class="s1">[propName] = targetInst(nativeEvent))</span>
        <span class="s1">: </span><span class="s2">&quot;target&quot; </span><span class="s1">=== propName</span>
        <span class="s1">? (</span><span class="s3">this</span><span class="s1">.target = nativeEventTarget)</span>
        <span class="s1">: (</span><span class="s3">this</span><span class="s1">[propName] = nativeEvent[propName]));</span>
  <span class="s3">this</span><span class="s1">.isDefaultPrevented = (</span><span class="s3">null </span><span class="s1">!= nativeEvent.defaultPrevented</span>
  <span class="s1">? nativeEvent.defaultPrevented</span>
  <span class="s1">: !</span><span class="s4">1 </span><span class="s1">=== nativeEvent.returnValue)</span>
    <span class="s1">? functionThatReturnsTrue</span>
    <span class="s1">: functionThatReturnsFalse;</span>
  <span class="s3">this</span><span class="s1">.isPropagationStopped = functionThatReturnsFalse;</span>
  <span class="s3">return this</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">assign(SyntheticEvent.prototype, {</span>
  <span class="s1">preventDefault: </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">this</span><span class="s1">.defaultPrevented = !</span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">event = </span><span class="s3">this</span><span class="s1">.nativeEvent;</span>
    <span class="s1">event &amp;&amp;</span>
      <span class="s1">(event.preventDefault</span>
        <span class="s1">? event.preventDefault()</span>
        <span class="s1">: </span><span class="s2">&quot;unknown&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">event.returnValue &amp;&amp; (event.returnValue = !</span><span class="s4">1</span><span class="s1">),</span>
      <span class="s1">(</span><span class="s3">this</span><span class="s1">.isDefaultPrevented = functionThatReturnsTrue));</span>
  <span class="s1">},</span>
  <span class="s1">stopPropagation: </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">var </span><span class="s1">event = </span><span class="s3">this</span><span class="s1">.nativeEvent;</span>
    <span class="s1">event &amp;&amp;</span>
      <span class="s1">(event.stopPropagation</span>
        <span class="s1">? event.stopPropagation()</span>
        <span class="s1">: </span><span class="s2">&quot;unknown&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">event.cancelBubble &amp;&amp; (event.cancelBubble = !</span><span class="s4">0</span><span class="s1">),</span>
      <span class="s1">(</span><span class="s3">this</span><span class="s1">.isPropagationStopped = functionThatReturnsTrue));</span>
  <span class="s1">},</span>
  <span class="s1">persist: </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">this</span><span class="s1">.isPersistent = functionThatReturnsTrue;</span>
  <span class="s1">},</span>
  <span class="s1">isPersistent: functionThatReturnsFalse,</span>
  <span class="s1">destructor: </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">var </span><span class="s1">Interface = </span><span class="s3">this</span><span class="s1">.constructor.Interface,</span>
      <span class="s1">propName;</span>
    <span class="s3">for </span><span class="s1">(propName </span><span class="s3">in </span><span class="s1">Interface) </span><span class="s3">this</span><span class="s1">[propName] = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.nativeEvent = </span><span class="s3">this</span><span class="s1">._targetInst = </span><span class="s3">this</span><span class="s1">.dispatchConfig = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.isPropagationStopped = </span><span class="s3">this</span><span class="s1">.isDefaultPrevented = functionThatReturnsFalse;</span>
    <span class="s3">this</span><span class="s1">._dispatchInstances = </span><span class="s3">this</span><span class="s1">._dispatchListeners = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">});</span>
<span class="s1">SyntheticEvent.Interface = {</span>
  <span class="s1">type: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">target: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">currentTarget: </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">},</span>
  <span class="s1">eventPhase: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">bubbles: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">cancelable: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">timeStamp: </span><span class="s3">function</span><span class="s1">(event) {</span>
    <span class="s3">return </span><span class="s1">event.timeStamp || Date.now();</span>
  <span class="s1">},</span>
  <span class="s1">defaultPrevented: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">isTrusted: </span><span class="s3">null</span>
<span class="s1">};</span>
<span class="s1">SyntheticEvent.extend = </span><span class="s3">function</span><span class="s1">(Interface) {</span>
  <span class="s3">function </span><span class="s1">E() {}</span>
  <span class="s3">function </span><span class="s1">Class() {</span>
    <span class="s3">return </span><span class="s1">Super.apply(</span><span class="s3">this</span><span class="s1">, arguments);</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">Super = </span><span class="s3">this</span><span class="s1">;</span>
  <span class="s1">E.prototype = Super.prototype;</span>
  <span class="s3">var </span><span class="s1">prototype = </span><span class="s3">new </span><span class="s1">E();</span>
  <span class="s1">assign(prototype, Class.prototype);</span>
  <span class="s1">Class.prototype = prototype;</span>
  <span class="s1">Class.prototype.constructor = Class;</span>
  <span class="s1">Class.Interface = assign({}, Super.Interface, Interface);</span>
  <span class="s1">Class.extend = Super.extend;</span>
  <span class="s1">addEventPoolingTo(Class);</span>
  <span class="s3">return </span><span class="s1">Class;</span>
<span class="s1">};</span>
<span class="s1">addEventPoolingTo(SyntheticEvent);</span>
<span class="s3">function </span><span class="s1">createOrGetPooledEvent(</span>
  <span class="s1">dispatchConfig,</span>
  <span class="s1">targetInst,</span>
  <span class="s1">nativeEvent,</span>
  <span class="s1">nativeInst</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.eventPool.length) {</span>
    <span class="s3">var </span><span class="s1">instance = </span><span class="s3">this</span><span class="s1">.eventPool.pop();</span>
    <span class="s3">this</span><span class="s1">.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);</span>
    <span class="s3">return </span><span class="s1">instance;</span>
  <span class="s1">}</span>
  <span class="s3">return new this</span><span class="s1">(dispatchConfig, targetInst, nativeEvent, nativeInst);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">releasePooledEvent(event) {</span>
  <span class="s3">if </span><span class="s1">(!(event </span><span class="s3">instanceof this</span><span class="s1">))</span>
    <span class="s3">throw </span><span class="s1">Error(</span>
      <span class="s2">&quot;Trying to release an event instance into a pool of a different type.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">event.destructor();</span>
  <span class="s4">10 </span><span class="s1">&gt; </span><span class="s3">this</span><span class="s1">.eventPool.length &amp;&amp; </span><span class="s3">this</span><span class="s1">.eventPool.push(event);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">addEventPoolingTo(EventConstructor) {</span>
  <span class="s1">EventConstructor.getPooled = createOrGetPooledEvent;</span>
  <span class="s1">EventConstructor.eventPool = [];</span>
  <span class="s1">EventConstructor.release = releasePooledEvent;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">ResponderSyntheticEvent = SyntheticEvent.extend({</span>
  <span class="s1">touchHistory: </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">});</span>
<span class="s3">function </span><span class="s1">isStartish(topLevelType) {</span>
  <span class="s3">return </span><span class="s2">&quot;topTouchStart&quot; </span><span class="s1">=== topLevelType;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isMoveish(topLevelType) {</span>
  <span class="s3">return </span><span class="s2">&quot;topTouchMove&quot; </span><span class="s1">=== topLevelType;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">startDependencies = [</span><span class="s2">&quot;topTouchStart&quot;</span><span class="s1">],</span>
  <span class="s1">moveDependencies = [</span><span class="s2">&quot;topTouchMove&quot;</span><span class="s1">],</span>
  <span class="s1">endDependencies = [</span><span class="s2">&quot;topTouchCancel&quot;</span><span class="s1">, </span><span class="s2">&quot;topTouchEnd&quot;</span><span class="s1">],</span>
  <span class="s1">touchBank = [],</span>
  <span class="s1">touchHistory = {</span>
    <span class="s1">touchBank: touchBank,</span>
    <span class="s1">numberActiveTouches: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">indexOfSingleActiveTouch: -</span><span class="s4">1</span><span class="s1">,</span>
    <span class="s1">mostRecentTimeStamp: </span><span class="s4">0</span>
  <span class="s1">};</span>
<span class="s3">function </span><span class="s1">timestampForTouch(touch) {</span>
  <span class="s3">return </span><span class="s1">touch.timeStamp || touch.timestamp;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getTouchIdentifier(_ref) {</span>
  <span class="s1">_ref = _ref.identifier;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">== _ref) </span><span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Touch object is missing identifier.&quot;</span><span class="s1">);</span>
  <span class="s3">return </span><span class="s1">_ref;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">recordTouchStart(touch) {</span>
  <span class="s3">var </span><span class="s1">identifier = getTouchIdentifier(touch),</span>
    <span class="s1">touchRecord = touchBank[identifier];</span>
  <span class="s1">touchRecord</span>
    <span class="s1">? ((touchRecord.touchActive = !</span><span class="s4">0</span><span class="s1">),</span>
      <span class="s1">(touchRecord.startPageX = touch.pageX),</span>
      <span class="s1">(touchRecord.startPageY = touch.pageY),</span>
      <span class="s1">(touchRecord.startTimeStamp = timestampForTouch(touch)),</span>
      <span class="s1">(touchRecord.currentPageX = touch.pageX),</span>
      <span class="s1">(touchRecord.currentPageY = touch.pageY),</span>
      <span class="s1">(touchRecord.currentTimeStamp = timestampForTouch(touch)),</span>
      <span class="s1">(touchRecord.previousPageX = touch.pageX),</span>
      <span class="s1">(touchRecord.previousPageY = touch.pageY),</span>
      <span class="s1">(touchRecord.previousTimeStamp = timestampForTouch(touch)))</span>
    <span class="s1">: ((touchRecord = {</span>
        <span class="s1">touchActive: !</span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">startPageX: touch.pageX,</span>
        <span class="s1">startPageY: touch.pageY,</span>
        <span class="s1">startTimeStamp: timestampForTouch(touch),</span>
        <span class="s1">currentPageX: touch.pageX,</span>
        <span class="s1">currentPageY: touch.pageY,</span>
        <span class="s1">currentTimeStamp: timestampForTouch(touch),</span>
        <span class="s1">previousPageX: touch.pageX,</span>
        <span class="s1">previousPageY: touch.pageY,</span>
        <span class="s1">previousTimeStamp: timestampForTouch(touch)</span>
      <span class="s1">}),</span>
      <span class="s1">(touchBank[identifier] = touchRecord));</span>
  <span class="s1">touchHistory.mostRecentTimeStamp = timestampForTouch(touch);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">recordTouchMove(touch) {</span>
  <span class="s3">var </span><span class="s1">touchRecord = touchBank[getTouchIdentifier(touch)];</span>
  <span class="s1">touchRecord &amp;&amp;</span>
    <span class="s1">((touchRecord.touchActive = !</span><span class="s4">0</span><span class="s1">),</span>
    <span class="s1">(touchRecord.previousPageX = touchRecord.currentPageX),</span>
    <span class="s1">(touchRecord.previousPageY = touchRecord.currentPageY),</span>
    <span class="s1">(touchRecord.previousTimeStamp = touchRecord.currentTimeStamp),</span>
    <span class="s1">(touchRecord.currentPageX = touch.pageX),</span>
    <span class="s1">(touchRecord.currentPageY = touch.pageY),</span>
    <span class="s1">(touchRecord.currentTimeStamp = timestampForTouch(touch)),</span>
    <span class="s1">(touchHistory.mostRecentTimeStamp = timestampForTouch(touch)));</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">recordTouchEnd(touch) {</span>
  <span class="s3">var </span><span class="s1">touchRecord = touchBank[getTouchIdentifier(touch)];</span>
  <span class="s1">touchRecord &amp;&amp;</span>
    <span class="s1">((touchRecord.touchActive = !</span><span class="s4">1</span><span class="s1">),</span>
    <span class="s1">(touchRecord.previousPageX = touchRecord.currentPageX),</span>
    <span class="s1">(touchRecord.previousPageY = touchRecord.currentPageY),</span>
    <span class="s1">(touchRecord.previousTimeStamp = touchRecord.currentTimeStamp),</span>
    <span class="s1">(touchRecord.currentPageX = touch.pageX),</span>
    <span class="s1">(touchRecord.currentPageY = touch.pageY),</span>
    <span class="s1">(touchRecord.currentTimeStamp = timestampForTouch(touch)),</span>
    <span class="s1">(touchHistory.mostRecentTimeStamp = timestampForTouch(touch)));</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">instrumentationCallback,</span>
  <span class="s1">ResponderTouchHistoryStore = {</span>
    <span class="s1">instrument: </span><span class="s3">function</span><span class="s1">(callback) {</span>
      <span class="s1">instrumentationCallback = callback;</span>
    <span class="s1">},</span>
    <span class="s1">recordTouchTrack: </span><span class="s3">function</span><span class="s1">(topLevelType, nativeEvent) {</span>
      <span class="s3">null </span><span class="s1">!= instrumentationCallback &amp;&amp;</span>
        <span class="s1">instrumentationCallback(topLevelType, nativeEvent);</span>
      <span class="s3">if </span><span class="s1">(isMoveish(topLevelType))</span>
        <span class="s1">nativeEvent.changedTouches.forEach(recordTouchMove);</span>
      <span class="s3">else if </span><span class="s1">(isStartish(topLevelType))</span>
        <span class="s1">nativeEvent.changedTouches.forEach(recordTouchStart),</span>
          <span class="s1">(touchHistory.numberActiveTouches = nativeEvent.touches.length),</span>
          <span class="s4">1 </span><span class="s1">=== touchHistory.numberActiveTouches &amp;&amp;</span>
            <span class="s1">(touchHistory.indexOfSingleActiveTouch =</span>
              <span class="s1">nativeEvent.touches[</span><span class="s4">0</span><span class="s1">].identifier);</span>
      <span class="s3">else if </span><span class="s1">(</span>
        <span class="s2">&quot;topTouchEnd&quot; </span><span class="s1">=== topLevelType ||</span>
        <span class="s2">&quot;topTouchCancel&quot; </span><span class="s1">=== topLevelType</span>
      <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">(</span>
          <span class="s1">(nativeEvent.changedTouches.forEach(recordTouchEnd),</span>
          <span class="s1">(touchHistory.numberActiveTouches = nativeEvent.touches.length),</span>
          <span class="s4">1 </span><span class="s1">=== touchHistory.numberActiveTouches)</span>
        <span class="s1">)</span>
          <span class="s3">for </span><span class="s1">(</span>
            <span class="s1">topLevelType = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">topLevelType &lt; touchBank.length;</span>
            <span class="s1">topLevelType++</span>
          <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">(</span>
              <span class="s1">((nativeEvent = touchBank[topLevelType]),</span>
              <span class="s3">null </span><span class="s1">!= nativeEvent &amp;&amp; nativeEvent.touchActive)</span>
            <span class="s1">) {</span>
              <span class="s1">touchHistory.indexOfSingleActiveTouch = topLevelType;</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">touchHistory: touchHistory</span>
  <span class="s1">};</span>
<span class="s3">function </span><span class="s1">accumulate(current, next) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">== next)</span>
    <span class="s3">throw </span><span class="s1">Error(</span>
      <span class="s2">&quot;accumulate(...): Accumulated items must not be null or undefined.&quot;</span>
    <span class="s1">);</span>
  <span class="s3">return null </span><span class="s1">== current</span>
    <span class="s1">? next</span>
    <span class="s1">: isArrayImpl(current)</span>
    <span class="s1">? current.concat(next)</span>
    <span class="s1">: isArrayImpl(next)</span>
    <span class="s1">? [current].concat(next)</span>
    <span class="s1">: [current, next];</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">accumulateInto(current, next) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">== next)</span>
    <span class="s3">throw </span><span class="s1">Error(</span>
      <span class="s2">&quot;accumulateInto(...): Accumulated items must not be null or undefined.&quot;</span>
    <span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">== current) </span><span class="s3">return </span><span class="s1">next;</span>
  <span class="s3">if </span><span class="s1">(isArrayImpl(current)) {</span>
    <span class="s3">if </span><span class="s1">(isArrayImpl(next)) </span><span class="s3">return </span><span class="s1">current.push.apply(current, next), current;</span>
    <span class="s1">current.push(next);</span>
    <span class="s3">return </span><span class="s1">current;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">isArrayImpl(next) ? [current].concat(next) : [current, next];</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">forEachAccumulated(arr, cb, scope) {</span>
  <span class="s1">Array.isArray(arr) ? arr.forEach(cb, scope) : arr &amp;&amp; cb.call(scope, arr);</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">responderInst = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">trackedTouchCount = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">changeResponder(nextResponderInst, blockHostResponder) {</span>
  <span class="s3">var </span><span class="s1">oldResponderInst = responderInst;</span>
  <span class="s1">responderInst = nextResponderInst;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== ResponderEventPlugin.GlobalResponderHandler)</span>
    <span class="s1">ResponderEventPlugin.GlobalResponderHandler.onChange(</span>
      <span class="s1">oldResponderInst,</span>
      <span class="s1">nextResponderInst,</span>
      <span class="s1">blockHostResponder</span>
    <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">eventTypes = {</span>
  <span class="s1">startShouldSetResponder: {</span>
    <span class="s1">phasedRegistrationNames: {</span>
      <span class="s1">bubbled: </span><span class="s2">&quot;onStartShouldSetResponder&quot;</span><span class="s1">,</span>
      <span class="s1">captured: </span><span class="s2">&quot;onStartShouldSetResponderCapture&quot;</span>
    <span class="s1">},</span>
    <span class="s1">dependencies: startDependencies</span>
  <span class="s1">},</span>
  <span class="s1">scrollShouldSetResponder: {</span>
    <span class="s1">phasedRegistrationNames: {</span>
      <span class="s1">bubbled: </span><span class="s2">&quot;onScrollShouldSetResponder&quot;</span><span class="s1">,</span>
      <span class="s1">captured: </span><span class="s2">&quot;onScrollShouldSetResponderCapture&quot;</span>
    <span class="s1">},</span>
    <span class="s1">dependencies: [</span><span class="s2">&quot;topScroll&quot;</span><span class="s1">]</span>
  <span class="s1">},</span>
  <span class="s1">selectionChangeShouldSetResponder: {</span>
    <span class="s1">phasedRegistrationNames: {</span>
      <span class="s1">bubbled: </span><span class="s2">&quot;onSelectionChangeShouldSetResponder&quot;</span><span class="s1">,</span>
      <span class="s1">captured: </span><span class="s2">&quot;onSelectionChangeShouldSetResponderCapture&quot;</span>
    <span class="s1">},</span>
    <span class="s1">dependencies: [</span><span class="s2">&quot;topSelectionChange&quot;</span><span class="s1">]</span>
  <span class="s1">},</span>
  <span class="s1">moveShouldSetResponder: {</span>
    <span class="s1">phasedRegistrationNames: {</span>
      <span class="s1">bubbled: </span><span class="s2">&quot;onMoveShouldSetResponder&quot;</span><span class="s1">,</span>
      <span class="s1">captured: </span><span class="s2">&quot;onMoveShouldSetResponderCapture&quot;</span>
    <span class="s1">},</span>
    <span class="s1">dependencies: moveDependencies</span>
  <span class="s1">},</span>
  <span class="s1">responderStart: {</span>
    <span class="s1">registrationName: </span><span class="s2">&quot;onResponderStart&quot;</span><span class="s1">,</span>
    <span class="s1">dependencies: startDependencies</span>
  <span class="s1">},</span>
  <span class="s1">responderMove: {</span>
    <span class="s1">registrationName: </span><span class="s2">&quot;onResponderMove&quot;</span><span class="s1">,</span>
    <span class="s1">dependencies: moveDependencies</span>
  <span class="s1">},</span>
  <span class="s1">responderEnd: {</span>
    <span class="s1">registrationName: </span><span class="s2">&quot;onResponderEnd&quot;</span><span class="s1">,</span>
    <span class="s1">dependencies: endDependencies</span>
  <span class="s1">},</span>
  <span class="s1">responderRelease: {</span>
    <span class="s1">registrationName: </span><span class="s2">&quot;onResponderRelease&quot;</span><span class="s1">,</span>
    <span class="s1">dependencies: endDependencies</span>
  <span class="s1">},</span>
  <span class="s1">responderTerminationRequest: {</span>
    <span class="s1">registrationName: </span><span class="s2">&quot;onResponderTerminationRequest&quot;</span><span class="s1">,</span>
    <span class="s1">dependencies: []</span>
  <span class="s1">},</span>
  <span class="s1">responderGrant: { registrationName: </span><span class="s2">&quot;onResponderGrant&quot;</span><span class="s1">, dependencies: [] },</span>
  <span class="s1">responderReject: { registrationName: </span><span class="s2">&quot;onResponderReject&quot;</span><span class="s1">, dependencies: [] },</span>
  <span class="s1">responderTerminate: {</span>
    <span class="s1">registrationName: </span><span class="s2">&quot;onResponderTerminate&quot;</span><span class="s1">,</span>
    <span class="s1">dependencies: []</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s3">function </span><span class="s1">getParent(inst) {</span>
  <span class="s3">do </span><span class="s1">inst = inst.</span><span class="s3">return</span><span class="s1">;</span>
  <span class="s3">while </span><span class="s1">(inst &amp;&amp; </span><span class="s4">5 </span><span class="s1">!== inst.tag);</span>
  <span class="s3">return </span><span class="s1">inst ? inst : </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">traverseTwoPhase(inst, fn, arg) {</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">path = []; inst; ) path.push(inst), (inst = getParent(inst));</span>
  <span class="s3">for </span><span class="s1">(inst = path.length; </span><span class="s4">0 </span><span class="s1">&lt; inst--; ) fn(path[inst], </span><span class="s2">&quot;captured&quot;</span><span class="s1">, arg);</span>
  <span class="s3">for </span><span class="s1">(inst = </span><span class="s4">0</span><span class="s1">; inst &lt; path.length; inst++) fn(path[inst], </span><span class="s2">&quot;bubbled&quot;</span><span class="s1">, arg);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getListener(inst, registrationName) {</span>
  <span class="s1">inst = inst.stateNode;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== inst) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">inst = getFiberCurrentPropsFromNode(inst);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== inst) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">((inst = inst[registrationName]) &amp;&amp; </span><span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">inst)</span>
    <span class="s3">throw </span><span class="s1">Error(</span>
      <span class="s2">&quot;Expected `&quot; </span><span class="s1">+</span>
        <span class="s1">registrationName +</span>
        <span class="s2">&quot;` listener to be a function, instead got a value of `&quot; </span><span class="s1">+</span>
        <span class="s3">typeof </span><span class="s1">inst +</span>
        <span class="s2">&quot;` type.&quot;</span>
    <span class="s1">);</span>
  <span class="s3">return </span><span class="s1">inst;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">accumulateDirectionalDispatches(inst, phase, event) {</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">(phase = getListener(</span>
      <span class="s1">inst,</span>
      <span class="s1">event.dispatchConfig.phasedRegistrationNames[phase]</span>
    <span class="s1">))</span>
  <span class="s1">)</span>
    <span class="s1">(event._dispatchListeners = accumulateInto(</span>
      <span class="s1">event._dispatchListeners,</span>
      <span class="s1">phase</span>
    <span class="s1">)),</span>
      <span class="s1">(event._dispatchInstances = accumulateInto(</span>
        <span class="s1">event._dispatchInstances,</span>
        <span class="s1">inst</span>
      <span class="s1">));</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">accumulateDirectDispatchesSingle(event) {</span>
  <span class="s3">if </span><span class="s1">(event &amp;&amp; event.dispatchConfig.registrationName) {</span>
    <span class="s3">var </span><span class="s1">inst = event._targetInst;</span>
    <span class="s3">if </span><span class="s1">(inst &amp;&amp; event &amp;&amp; event.dispatchConfig.registrationName) {</span>
      <span class="s3">var </span><span class="s1">listener = getListener(inst, event.dispatchConfig.registrationName);</span>
      <span class="s1">listener &amp;&amp;</span>
        <span class="s1">((event._dispatchListeners = accumulateInto(</span>
          <span class="s1">event._dispatchListeners,</span>
          <span class="s1">listener</span>
        <span class="s1">)),</span>
        <span class="s1">(event._dispatchInstances = accumulateInto(</span>
          <span class="s1">event._dispatchInstances,</span>
          <span class="s1">inst</span>
        <span class="s1">)));</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">accumulateTwoPhaseDispatchesSingleSkipTarget(event) {</span>
  <span class="s3">if </span><span class="s1">(event &amp;&amp; event.dispatchConfig.phasedRegistrationNames) {</span>
    <span class="s3">var </span><span class="s1">targetInst = event._targetInst;</span>
    <span class="s1">targetInst = targetInst ? getParent(targetInst) : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">traverseTwoPhase(targetInst, accumulateDirectionalDispatches, event);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">accumulateTwoPhaseDispatchesSingle(event) {</span>
  <span class="s1">event &amp;&amp;</span>
    <span class="s1">event.dispatchConfig.phasedRegistrationNames &amp;&amp;</span>
    <span class="s1">traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">ResponderEventPlugin = {</span>
    <span class="s1">_getResponder: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s3">return </span><span class="s1">responderInst;</span>
    <span class="s1">},</span>
    <span class="s1">eventTypes: eventTypes,</span>
    <span class="s1">extractEvents: </span><span class="s3">function</span><span class="s1">(</span>
      <span class="s1">topLevelType,</span>
      <span class="s1">targetInst,</span>
      <span class="s1">nativeEvent,</span>
      <span class="s1">nativeEventTarget</span>
    <span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(isStartish(topLevelType)) trackedTouchCount += </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s3">else if </span><span class="s1">(</span>
        <span class="s2">&quot;topTouchEnd&quot; </span><span class="s1">=== topLevelType ||</span>
        <span class="s2">&quot;topTouchCancel&quot; </span><span class="s1">=== topLevelType</span>
      <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">&lt;= trackedTouchCount) --trackedTouchCount;</span>
        <span class="s3">else return null</span><span class="s1">;</span>
      <span class="s1">ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">targetInst &amp;&amp;</span>
        <span class="s1">((</span><span class="s2">&quot;topScroll&quot; </span><span class="s1">=== topLevelType &amp;&amp; !nativeEvent.responderIgnoreScroll) ||</span>
          <span class="s1">(</span><span class="s4">0 </span><span class="s1">&lt; trackedTouchCount &amp;&amp; </span><span class="s2">&quot;topSelectionChange&quot; </span><span class="s1">=== topLevelType) ||</span>
          <span class="s1">isStartish(topLevelType) ||</span>
          <span class="s1">isMoveish(topLevelType))</span>
      <span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">shouldSetEventType = isStartish(topLevelType)</span>
          <span class="s1">? eventTypes.startShouldSetResponder</span>
          <span class="s1">: isMoveish(topLevelType)</span>
          <span class="s1">? eventTypes.moveShouldSetResponder</span>
          <span class="s1">: </span><span class="s2">&quot;topSelectionChange&quot; </span><span class="s1">=== topLevelType</span>
          <span class="s1">? eventTypes.selectionChangeShouldSetResponder</span>
          <span class="s1">: eventTypes.scrollShouldSetResponder;</span>
        <span class="s3">if </span><span class="s1">(responderInst)</span>
          <span class="s1">b: {</span>
            <span class="s3">var </span><span class="s1">JSCompiler_temp = responderInst;</span>
            <span class="s3">for </span><span class="s1">(</span>
              <span class="s3">var </span><span class="s1">depthA = </span><span class="s4">0</span><span class="s1">, tempA = JSCompiler_temp;</span>
              <span class="s1">tempA;</span>
              <span class="s1">tempA = getParent(tempA)</span>
            <span class="s1">)</span>
              <span class="s1">depthA++;</span>
            <span class="s1">tempA = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">tempB = targetInst; tempB; tempB = getParent(tempB))</span>
              <span class="s1">tempA++;</span>
            <span class="s3">for </span><span class="s1">(; </span><span class="s4">0 </span><span class="s1">&lt; depthA - tempA; )</span>
              <span class="s1">(JSCompiler_temp = getParent(JSCompiler_temp)), depthA--;</span>
            <span class="s3">for </span><span class="s1">(; </span><span class="s4">0 </span><span class="s1">&lt; tempA - depthA; )</span>
              <span class="s1">(targetInst = getParent(targetInst)), tempA--;</span>
            <span class="s3">for </span><span class="s1">(; depthA--; ) {</span>
              <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">JSCompiler_temp === targetInst ||</span>
                <span class="s1">JSCompiler_temp === targetInst.alternate</span>
              <span class="s1">)</span>
                <span class="s3">break </span><span class="s1">b;</span>
              <span class="s1">JSCompiler_temp = getParent(JSCompiler_temp);</span>
              <span class="s1">targetInst = getParent(targetInst);</span>
            <span class="s1">}</span>
            <span class="s1">JSCompiler_temp = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">JSCompiler_temp = targetInst;</span>
        <span class="s1">targetInst = JSCompiler_temp;</span>
        <span class="s1">JSCompiler_temp = targetInst === responderInst;</span>
        <span class="s1">shouldSetEventType = ResponderSyntheticEvent.getPooled(</span>
          <span class="s1">shouldSetEventType,</span>
          <span class="s1">targetInst,</span>
          <span class="s1">nativeEvent,</span>
          <span class="s1">nativeEventTarget</span>
        <span class="s1">);</span>
        <span class="s1">shouldSetEventType.touchHistory =</span>
          <span class="s1">ResponderTouchHistoryStore.touchHistory;</span>
        <span class="s1">JSCompiler_temp</span>
          <span class="s1">? forEachAccumulated(</span>
              <span class="s1">shouldSetEventType,</span>
              <span class="s1">accumulateTwoPhaseDispatchesSingleSkipTarget</span>
            <span class="s1">)</span>
          <span class="s1">: forEachAccumulated(</span>
              <span class="s1">shouldSetEventType,</span>
              <span class="s1">accumulateTwoPhaseDispatchesSingle</span>
            <span class="s1">);</span>
        <span class="s1">b: {</span>
          <span class="s1">JSCompiler_temp = shouldSetEventType._dispatchListeners;</span>
          <span class="s1">targetInst = shouldSetEventType._dispatchInstances;</span>
          <span class="s3">if </span><span class="s1">(isArrayImpl(JSCompiler_temp))</span>
            <span class="s3">for </span><span class="s1">(</span>
              <span class="s1">depthA = </span><span class="s4">0</span><span class="s1">;</span>
              <span class="s1">depthA &lt; JSCompiler_temp.length &amp;&amp;</span>
              <span class="s1">!shouldSetEventType.isPropagationStopped();</span>
              <span class="s1">depthA++</span>
            <span class="s1">) {</span>
              <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">JSCompiler_temp[depthA](shouldSetEventType, targetInst[depthA])</span>
              <span class="s1">) {</span>
                <span class="s1">JSCompiler_temp = targetInst[depthA];</span>
                <span class="s3">break </span><span class="s1">b;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s3">else if </span><span class="s1">(</span>
            <span class="s1">JSCompiler_temp &amp;&amp;</span>
            <span class="s1">JSCompiler_temp(shouldSetEventType, targetInst)</span>
          <span class="s1">) {</span>
            <span class="s1">JSCompiler_temp = targetInst;</span>
            <span class="s3">break </span><span class="s1">b;</span>
          <span class="s1">}</span>
          <span class="s1">JSCompiler_temp = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">shouldSetEventType._dispatchInstances = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">shouldSetEventType._dispatchListeners = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">shouldSetEventType.isPersistent() ||</span>
          <span class="s1">shouldSetEventType.constructor.release(shouldSetEventType);</span>
        <span class="s3">if </span><span class="s1">(JSCompiler_temp &amp;&amp; JSCompiler_temp !== responderInst)</span>
          <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">((shouldSetEventType = ResponderSyntheticEvent.getPooled(</span>
              <span class="s1">eventTypes.responderGrant,</span>
              <span class="s1">JSCompiler_temp,</span>
              <span class="s1">nativeEvent,</span>
              <span class="s1">nativeEventTarget</span>
            <span class="s1">)),</span>
            <span class="s1">(shouldSetEventType.touchHistory =</span>
              <span class="s1">ResponderTouchHistoryStore.touchHistory),</span>
            <span class="s1">forEachAccumulated(</span>
              <span class="s1">shouldSetEventType,</span>
              <span class="s1">accumulateDirectDispatchesSingle</span>
            <span class="s1">),</span>
            <span class="s1">(targetInst = !</span><span class="s4">0 </span><span class="s1">=== executeDirectDispatch(shouldSetEventType)),</span>
            <span class="s1">responderInst)</span>
          <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">(</span>
              <span class="s1">((depthA = ResponderSyntheticEvent.getPooled(</span>
                <span class="s1">eventTypes.responderTerminationRequest,</span>
                <span class="s1">responderInst,</span>
                <span class="s1">nativeEvent,</span>
                <span class="s1">nativeEventTarget</span>
              <span class="s1">)),</span>
              <span class="s1">(depthA.touchHistory = ResponderTouchHistoryStore.touchHistory),</span>
              <span class="s1">forEachAccumulated(depthA, accumulateDirectDispatchesSingle),</span>
              <span class="s1">(tempA =</span>
                <span class="s1">!depthA._dispatchListeners || executeDirectDispatch(depthA)),</span>
              <span class="s1">depthA.isPersistent() || depthA.constructor.release(depthA),</span>
              <span class="s1">tempA)</span>
            <span class="s1">) {</span>
              <span class="s1">depthA = ResponderSyntheticEvent.getPooled(</span>
                <span class="s1">eventTypes.responderTerminate,</span>
                <span class="s1">responderInst,</span>
                <span class="s1">nativeEvent,</span>
                <span class="s1">nativeEventTarget</span>
              <span class="s1">);</span>
              <span class="s1">depthA.touchHistory = ResponderTouchHistoryStore.touchHistory;</span>
              <span class="s1">forEachAccumulated(depthA, accumulateDirectDispatchesSingle);</span>
              <span class="s3">var </span><span class="s1">JSCompiler_temp$jscomp$0 = accumulate(</span>
                <span class="s1">JSCompiler_temp$jscomp$0,</span>
                <span class="s1">[shouldSetEventType, depthA]</span>
              <span class="s1">);</span>
              <span class="s1">changeResponder(JSCompiler_temp, targetInst);</span>
            <span class="s1">} </span><span class="s3">else</span>
              <span class="s1">(shouldSetEventType = ResponderSyntheticEvent.getPooled(</span>
                <span class="s1">eventTypes.responderReject,</span>
                <span class="s1">JSCompiler_temp,</span>
                <span class="s1">nativeEvent,</span>
                <span class="s1">nativeEventTarget</span>
              <span class="s1">)),</span>
                <span class="s1">(shouldSetEventType.touchHistory =</span>
                  <span class="s1">ResponderTouchHistoryStore.touchHistory),</span>
                <span class="s1">forEachAccumulated(</span>
                  <span class="s1">shouldSetEventType,</span>
                  <span class="s1">accumulateDirectDispatchesSingle</span>
                <span class="s1">),</span>
                <span class="s1">(JSCompiler_temp$jscomp$0 = accumulate(</span>
                  <span class="s1">JSCompiler_temp$jscomp$0,</span>
                  <span class="s1">shouldSetEventType</span>
                <span class="s1">));</span>
          <span class="s3">else</span>
            <span class="s1">(JSCompiler_temp$jscomp$0 = accumulate(</span>
              <span class="s1">JSCompiler_temp$jscomp$0,</span>
              <span class="s1">shouldSetEventType</span>
            <span class="s1">)),</span>
              <span class="s1">changeResponder(JSCompiler_temp, targetInst);</span>
        <span class="s3">else </span><span class="s1">JSCompiler_temp$jscomp$0 = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">JSCompiler_temp$jscomp$0 = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">shouldSetEventType = responderInst &amp;&amp; isStartish(topLevelType);</span>
      <span class="s1">JSCompiler_temp = responderInst &amp;&amp; isMoveish(topLevelType);</span>
      <span class="s1">targetInst =</span>
        <span class="s1">responderInst &amp;&amp;</span>
        <span class="s1">(</span><span class="s2">&quot;topTouchEnd&quot; </span><span class="s1">=== topLevelType || </span><span class="s2">&quot;topTouchCancel&quot; </span><span class="s1">=== topLevelType);</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">(shouldSetEventType = shouldSetEventType</span>
          <span class="s1">? eventTypes.responderStart</span>
          <span class="s1">: JSCompiler_temp</span>
          <span class="s1">? eventTypes.responderMove</span>
          <span class="s1">: targetInst</span>
          <span class="s1">? eventTypes.responderEnd</span>
          <span class="s1">: </span><span class="s3">null</span><span class="s1">)</span>
      <span class="s1">)</span>
        <span class="s1">(shouldSetEventType = ResponderSyntheticEvent.getPooled(</span>
          <span class="s1">shouldSetEventType,</span>
          <span class="s1">responderInst,</span>
          <span class="s1">nativeEvent,</span>
          <span class="s1">nativeEventTarget</span>
        <span class="s1">)),</span>
          <span class="s1">(shouldSetEventType.touchHistory =</span>
            <span class="s1">ResponderTouchHistoryStore.touchHistory),</span>
          <span class="s1">forEachAccumulated(</span>
            <span class="s1">shouldSetEventType,</span>
            <span class="s1">accumulateDirectDispatchesSingle</span>
          <span class="s1">),</span>
          <span class="s1">(JSCompiler_temp$jscomp$0 = accumulate(</span>
            <span class="s1">JSCompiler_temp$jscomp$0,</span>
            <span class="s1">shouldSetEventType</span>
          <span class="s1">));</span>
      <span class="s1">shouldSetEventType = responderInst &amp;&amp; </span><span class="s2">&quot;topTouchCancel&quot; </span><span class="s1">=== topLevelType;</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">(topLevelType =</span>
          <span class="s1">responderInst &amp;&amp;</span>
          <span class="s1">!shouldSetEventType &amp;&amp;</span>
          <span class="s1">(</span><span class="s2">&quot;topTouchEnd&quot; </span><span class="s1">=== topLevelType || </span><span class="s2">&quot;topTouchCancel&quot; </span><span class="s1">=== topLevelType))</span>
      <span class="s1">)</span>
        <span class="s1">a: {</span>
          <span class="s3">if </span><span class="s1">((topLevelType = nativeEvent.touches) &amp;&amp; </span><span class="s4">0 </span><span class="s1">!== topLevelType.length)</span>
            <span class="s3">for </span><span class="s1">(</span>
              <span class="s1">JSCompiler_temp = </span><span class="s4">0</span><span class="s1">;</span>
              <span class="s1">JSCompiler_temp &lt; topLevelType.length;</span>
              <span class="s1">JSCompiler_temp++</span>
            <span class="s1">)</span>
              <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">((targetInst = topLevelType[JSCompiler_temp].target),</span>
                <span class="s3">null </span><span class="s1">!== targetInst &amp;&amp;</span>
                  <span class="s3">void </span><span class="s4">0 </span><span class="s1">!== targetInst &amp;&amp;</span>
                  <span class="s4">0 </span><span class="s1">!== targetInst)</span>
              <span class="s1">) {</span>
                <span class="s1">depthA = getInstanceFromNode(targetInst);</span>
                <span class="s1">b: {</span>
                  <span class="s3">for </span><span class="s1">(targetInst = responderInst; depthA; ) {</span>
                    <span class="s3">if </span><span class="s1">(</span>
                      <span class="s1">targetInst === depthA ||</span>
                      <span class="s1">targetInst === depthA.alternate</span>
                    <span class="s1">) {</span>
                      <span class="s1">targetInst = !</span><span class="s4">0</span><span class="s1">;</span>
                      <span class="s3">break </span><span class="s1">b;</span>
                    <span class="s1">}</span>
                    <span class="s1">depthA = getParent(depthA);</span>
                  <span class="s1">}</span>
                  <span class="s1">targetInst = !</span><span class="s4">1</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(targetInst) {</span>
                  <span class="s1">topLevelType = !</span><span class="s4">1</span><span class="s1">;</span>
                  <span class="s3">break </span><span class="s1">a;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
          <span class="s1">topLevelType = !</span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">(topLevelType = shouldSetEventType</span>
          <span class="s1">? eventTypes.responderTerminate</span>
          <span class="s1">: topLevelType</span>
          <span class="s1">? eventTypes.responderRelease</span>
          <span class="s1">: </span><span class="s3">null</span><span class="s1">)</span>
      <span class="s1">)</span>
        <span class="s1">(nativeEvent = ResponderSyntheticEvent.getPooled(</span>
          <span class="s1">topLevelType,</span>
          <span class="s1">responderInst,</span>
          <span class="s1">nativeEvent,</span>
          <span class="s1">nativeEventTarget</span>
        <span class="s1">)),</span>
          <span class="s1">(nativeEvent.touchHistory = ResponderTouchHistoryStore.touchHistory),</span>
          <span class="s1">forEachAccumulated(nativeEvent, accumulateDirectDispatchesSingle),</span>
          <span class="s1">(JSCompiler_temp$jscomp$0 = accumulate(</span>
            <span class="s1">JSCompiler_temp$jscomp$0,</span>
            <span class="s1">nativeEvent</span>
          <span class="s1">)),</span>
          <span class="s1">changeResponder(</span><span class="s3">null</span><span class="s1">);</span>
      <span class="s3">return </span><span class="s1">JSCompiler_temp$jscomp$0;</span>
    <span class="s1">},</span>
    <span class="s1">GlobalResponderHandler: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">injection: {</span>
      <span class="s1">injectGlobalResponderHandler: </span><span class="s3">function</span><span class="s1">(GlobalResponderHandler) {</span>
        <span class="s1">ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">},</span>
  <span class="s1">eventPluginOrder = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">namesToPlugins = {};</span>
<span class="s3">function </span><span class="s1">recomputePluginOrdering() {</span>
  <span class="s3">if </span><span class="s1">(eventPluginOrder)</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">pluginName </span><span class="s3">in </span><span class="s1">namesToPlugins) {</span>
      <span class="s3">var </span><span class="s1">pluginModule = namesToPlugins[pluginName],</span>
        <span class="s1">pluginIndex = eventPluginOrder.indexOf(pluginName);</span>
      <span class="s3">if </span><span class="s1">(-</span><span class="s4">1 </span><span class="s1">&gt;= pluginIndex)</span>
        <span class="s3">throw </span><span class="s1">Error(</span>
          <span class="s2">&quot;EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `&quot; </span><span class="s1">+</span>
            <span class="s1">(pluginName + </span><span class="s2">&quot;`.&quot;</span><span class="s1">)</span>
        <span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(!plugins[pluginIndex]) {</span>
        <span class="s3">if </span><span class="s1">(!pluginModule.extractEvents)</span>
          <span class="s3">throw </span><span class="s1">Error(</span>
            <span class="s2">&quot;EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `&quot; </span><span class="s1">+</span>
              <span class="s1">(pluginName + </span><span class="s2">&quot;` does not.&quot;</span><span class="s1">)</span>
          <span class="s1">);</span>
        <span class="s1">plugins[pluginIndex] = pluginModule;</span>
        <span class="s1">pluginIndex = pluginModule.eventTypes;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">eventName </span><span class="s3">in </span><span class="s1">pluginIndex) {</span>
          <span class="s3">var </span><span class="s1">JSCompiler_inline_result = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
          <span class="s3">var </span><span class="s1">dispatchConfig = pluginIndex[eventName],</span>
            <span class="s1">eventName$jscomp$0 = eventName;</span>
          <span class="s3">if </span><span class="s1">(eventNameDispatchConfigs.hasOwnProperty(eventName$jscomp$0))</span>
            <span class="s3">throw </span><span class="s1">Error(</span>
              <span class="s2">&quot;EventPluginRegistry: More than one plugin attempted to publish the same event name, `&quot; </span><span class="s1">+</span>
                <span class="s1">(eventName$jscomp$0 + </span><span class="s2">&quot;`.&quot;</span><span class="s1">)</span>
            <span class="s1">);</span>
          <span class="s1">eventNameDispatchConfigs[eventName$jscomp$0] = dispatchConfig;</span>
          <span class="s3">var </span><span class="s1">phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;</span>
          <span class="s3">if </span><span class="s1">(phasedRegistrationNames) {</span>
            <span class="s3">for </span><span class="s1">(JSCompiler_inline_result </span><span class="s3">in </span><span class="s1">phasedRegistrationNames)</span>
              <span class="s1">phasedRegistrationNames.hasOwnProperty(</span>
                <span class="s1">JSCompiler_inline_result</span>
              <span class="s1">) &amp;&amp;</span>
                <span class="s1">publishRegistrationName(</span>
                  <span class="s1">phasedRegistrationNames[JSCompiler_inline_result],</span>
                  <span class="s1">pluginModule,</span>
                  <span class="s1">eventName$jscomp$0</span>
                <span class="s1">);</span>
            <span class="s1">JSCompiler_inline_result = !</span><span class="s4">0</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else</span>
            <span class="s1">dispatchConfig.registrationName</span>
              <span class="s1">? (publishRegistrationName(</span>
                  <span class="s1">dispatchConfig.registrationName,</span>
                  <span class="s1">pluginModule,</span>
                  <span class="s1">eventName$jscomp$0</span>
                <span class="s1">),</span>
                <span class="s1">(JSCompiler_inline_result = !</span><span class="s4">0</span><span class="s1">))</span>
              <span class="s1">: (JSCompiler_inline_result = !</span><span class="s4">1</span><span class="s1">);</span>
          <span class="s3">if </span><span class="s1">(!JSCompiler_inline_result)</span>
            <span class="s3">throw </span><span class="s1">Error(</span>
              <span class="s2">&quot;EventPluginRegistry: Failed to publish event `&quot; </span><span class="s1">+</span>
                <span class="s1">eventName +</span>
                <span class="s2">&quot;` for plugin `&quot; </span><span class="s1">+</span>
                <span class="s1">pluginName +</span>
                <span class="s2">&quot;`.&quot;</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">publishRegistrationName(registrationName, pluginModule) {</span>
  <span class="s3">if </span><span class="s1">(registrationNameModules[registrationName])</span>
    <span class="s3">throw </span><span class="s1">Error(</span>
      <span class="s2">&quot;EventPluginRegistry: More than one plugin attempted to publish the same registration name, `&quot; </span><span class="s1">+</span>
        <span class="s1">(registrationName + </span><span class="s2">&quot;`.&quot;</span><span class="s1">)</span>
    <span class="s1">);</span>
  <span class="s1">registrationNameModules[registrationName] = pluginModule;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">plugins = [],</span>
  <span class="s1">eventNameDispatchConfigs = {},</span>
  <span class="s1">registrationNameModules = {};</span>
<span class="s3">function </span><span class="s1">getListeners(</span>
  <span class="s1">inst,</span>
  <span class="s1">registrationName,</span>
  <span class="s1">phase,</span>
  <span class="s1">dispatchToImperativeListeners</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">stateNode = inst.stateNode;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== stateNode) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">inst = getFiberCurrentPropsFromNode(stateNode);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== inst) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">((inst = inst[registrationName]) &amp;&amp; </span><span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">inst)</span>
    <span class="s3">throw </span><span class="s1">Error(</span>
      <span class="s2">&quot;Expected `&quot; </span><span class="s1">+</span>
        <span class="s1">registrationName +</span>
        <span class="s2">&quot;` listener to be a function, instead got a value of `&quot; </span><span class="s1">+</span>
        <span class="s3">typeof </span><span class="s1">inst +</span>
        <span class="s2">&quot;` type.&quot;</span>
    <span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">!(</span>
      <span class="s1">dispatchToImperativeListeners &amp;&amp;</span>
      <span class="s1">stateNode.canonical &amp;&amp;</span>
      <span class="s1">stateNode.canonical._eventListeners</span>
    <span class="s1">)</span>
  <span class="s1">)</span>
    <span class="s3">return </span><span class="s1">inst;</span>
  <span class="s3">var </span><span class="s1">listeners = [];</span>
  <span class="s1">inst &amp;&amp; listeners.push(inst);</span>
  <span class="s3">var </span><span class="s1">requestedPhaseIsCapture = </span><span class="s2">&quot;captured&quot; </span><span class="s1">=== phase,</span>
    <span class="s1">mangledImperativeRegistrationName = requestedPhaseIsCapture</span>
      <span class="s1">? </span><span class="s2">&quot;rn:&quot; </span><span class="s1">+ registrationName.replace(/Capture$/, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
      <span class="s1">: </span><span class="s2">&quot;rn:&quot; </span><span class="s1">+ registrationName;</span>
  <span class="s1">stateNode.canonical._eventListeners[mangledImperativeRegistrationName] &amp;&amp;</span>
    <span class="s4">0 </span><span class="s1">&lt;</span>
      <span class="s1">stateNode.canonical._eventListeners[mangledImperativeRegistrationName]</span>
        <span class="s1">.length &amp;&amp;</span>
    <span class="s1">stateNode.canonical._eventListeners[</span>
      <span class="s1">mangledImperativeRegistrationName</span>
    <span class="s1">].forEach(</span><span class="s3">function</span><span class="s1">(listenerObj) {</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">(</span><span class="s3">null </span><span class="s1">!= listenerObj.options.capture &amp;&amp; listenerObj.options.capture) ===</span>
        <span class="s1">requestedPhaseIsCapture</span>
      <span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">listenerFnWrapper = </span><span class="s3">function</span><span class="s1">(syntheticEvent) {</span>
          <span class="s3">var </span><span class="s1">eventInst = </span><span class="s3">new </span><span class="s1">ReactNativePrivateInterface.CustomEvent(</span>
            <span class="s1">mangledImperativeRegistrationName,</span>
            <span class="s1">{ detail: syntheticEvent.nativeEvent }</span>
          <span class="s1">);</span>
          <span class="s1">eventInst.isTrusted = !</span><span class="s4">0</span><span class="s1">;</span>
          <span class="s1">eventInst.setSyntheticEvent(syntheticEvent);</span>
          <span class="s3">for </span><span class="s1">(</span>
            <span class="s3">var </span><span class="s1">_len = arguments.length,</span>
              <span class="s1">args = Array(</span><span class="s4">1 </span><span class="s1">&lt; _len ? _len - </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">),</span>
              <span class="s1">_key = </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">_key &lt; _len;</span>
            <span class="s1">_key++</span>
          <span class="s1">)</span>
            <span class="s1">args[_key - </span><span class="s4">1</span><span class="s1">] = arguments[_key];</span>
          <span class="s1">listenerObj.listener.apply(listenerObj, [eventInst].concat(args));</span>
        <span class="s1">};</span>
        <span class="s1">listenerObj.options.once</span>
          <span class="s1">? listeners.push(</span><span class="s3">function</span><span class="s1">() {</span>
              <span class="s1">stateNode.canonical.removeEventListener_unstable(</span>
                <span class="s1">mangledImperativeRegistrationName,</span>
                <span class="s1">listenerObj.listener,</span>
                <span class="s1">listenerObj.capture</span>
              <span class="s1">);</span>
              <span class="s1">listenerObj.invalidated ||</span>
                <span class="s1">((listenerObj.invalidated = !</span><span class="s4">0</span><span class="s1">),</span>
                <span class="s1">listenerObj.listener.apply(listenerObj, arguments));</span>
            <span class="s1">})</span>
          <span class="s1">: listeners.push(listenerFnWrapper);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s3">return </span><span class="s4">0 </span><span class="s1">=== listeners.length</span>
    <span class="s1">? </span><span class="s3">null</span>
    <span class="s1">: </span><span class="s4">1 </span><span class="s1">=== listeners.length</span>
    <span class="s1">? listeners[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">: listeners;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">customBubblingEventTypes =</span>
    <span class="s1">ReactNativePrivateInterface.ReactNativeViewConfigRegistry</span>
      <span class="s1">.customBubblingEventTypes,</span>
  <span class="s1">customDirectEventTypes =</span>
    <span class="s1">ReactNativePrivateInterface.ReactNativeViewConfigRegistry</span>
      <span class="s1">.customDirectEventTypes;</span>
<span class="s3">function </span><span class="s1">accumulateListenersAndInstances(inst, event, listeners) {</span>
  <span class="s3">var </span><span class="s1">listenersLength = listeners</span>
    <span class="s1">? isArrayImpl(listeners)</span>
      <span class="s1">? listeners.length</span>
      <span class="s1">: </span><span class="s4">1</span>
    <span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">&lt; listenersLength)</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">((event._dispatchListeners = accumulateInto(</span>
        <span class="s1">event._dispatchListeners,</span>
        <span class="s1">listeners</span>
      <span class="s1">)),</span>
      <span class="s3">null </span><span class="s1">== event._dispatchInstances &amp;&amp; </span><span class="s4">1 </span><span class="s1">=== listenersLength)</span>
    <span class="s1">)</span>
      <span class="s1">event._dispatchInstances = inst;</span>
    <span class="s3">else</span>
      <span class="s3">for </span><span class="s1">(</span>
        <span class="s1">event._dispatchInstances = event._dispatchInstances || [],</span>
          <span class="s1">isArrayImpl(event._dispatchInstances) ||</span>
            <span class="s1">(event._dispatchInstances = [event._dispatchInstances]),</span>
          <span class="s1">listeners = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">listeners &lt; listenersLength;</span>
        <span class="s1">listeners++</span>
      <span class="s1">)</span>
        <span class="s1">event._dispatchInstances.push(inst);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">accumulateDirectionalDispatches$1(inst, phase, event) {</span>
  <span class="s1">phase = getListeners(</span>
    <span class="s1">inst,</span>
    <span class="s1">event.dispatchConfig.phasedRegistrationNames[phase],</span>
    <span class="s1">phase,</span>
    <span class="s1">!</span><span class="s4">0</span>
  <span class="s1">);</span>
  <span class="s1">accumulateListenersAndInstances(inst, event, phase);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">traverseTwoPhase$1(inst, fn, arg, skipBubbling) {</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">path = []; inst; ) {</span>
    <span class="s1">path.push(inst);</span>
    <span class="s3">do </span><span class="s1">inst = inst.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">while </span><span class="s1">(inst &amp;&amp; </span><span class="s4">5 </span><span class="s1">!== inst.tag);</span>
    <span class="s1">inst = inst ? inst : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">for </span><span class="s1">(inst = path.length; </span><span class="s4">0 </span><span class="s1">&lt; inst--; ) fn(path[inst], </span><span class="s2">&quot;captured&quot;</span><span class="s1">, arg);</span>
  <span class="s3">if </span><span class="s1">(skipBubbling) fn(path[</span><span class="s4">0</span><span class="s1">], </span><span class="s2">&quot;bubbled&quot;</span><span class="s1">, arg);</span>
  <span class="s3">else</span>
    <span class="s3">for </span><span class="s1">(inst = </span><span class="s4">0</span><span class="s1">; inst &lt; path.length; inst++) fn(path[inst], </span><span class="s2">&quot;bubbled&quot;</span><span class="s1">, arg);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">accumulateTwoPhaseDispatchesSingle$1(event) {</span>
  <span class="s1">event &amp;&amp;</span>
    <span class="s1">event.dispatchConfig.phasedRegistrationNames &amp;&amp;</span>
    <span class="s1">traverseTwoPhase$1(</span>
      <span class="s1">event._targetInst,</span>
      <span class="s1">accumulateDirectionalDispatches$1,</span>
      <span class="s1">event,</span>
      <span class="s1">!</span><span class="s4">1</span>
    <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">accumulateDirectDispatchesSingle$1(event) {</span>
  <span class="s3">if </span><span class="s1">(event &amp;&amp; event.dispatchConfig.registrationName) {</span>
    <span class="s3">var </span><span class="s1">inst = event._targetInst;</span>
    <span class="s3">if </span><span class="s1">(inst &amp;&amp; event &amp;&amp; event.dispatchConfig.registrationName) {</span>
      <span class="s3">var </span><span class="s1">listeners = getListeners(</span>
        <span class="s1">inst,</span>
        <span class="s1">event.dispatchConfig.registrationName,</span>
        <span class="s2">&quot;bubbled&quot;</span><span class="s1">,</span>
        <span class="s1">!</span><span class="s4">1</span>
      <span class="s1">);</span>
      <span class="s1">accumulateListenersAndInstances(inst, event, listeners);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">if </span><span class="s1">(eventPluginOrder)</span>
  <span class="s3">throw </span><span class="s1">Error(</span>
    <span class="s2">&quot;EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.&quot;</span>
  <span class="s1">);</span>
<span class="s1">eventPluginOrder = Array.prototype.slice.call([</span>
  <span class="s2">&quot;ResponderEventPlugin&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;ReactNativeBridgeEventPlugin&quot;</span>
<span class="s1">]);</span>
<span class="s1">recomputePluginOrdering();</span>
<span class="s3">var </span><span class="s1">injectedNamesToPlugins$jscomp$inline_240 = {</span>
    <span class="s1">ResponderEventPlugin: ResponderEventPlugin,</span>
    <span class="s1">ReactNativeBridgeEventPlugin: {</span>
      <span class="s1">eventTypes: {},</span>
      <span class="s1">extractEvents: </span><span class="s3">function</span><span class="s1">(</span>
        <span class="s1">topLevelType,</span>
        <span class="s1">targetInst,</span>
        <span class="s1">nativeEvent,</span>
        <span class="s1">nativeEventTarget</span>
      <span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">== targetInst) </span><span class="s3">return null</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">bubbleDispatchConfig = customBubblingEventTypes[topLevelType],</span>
          <span class="s1">directDispatchConfig = customDirectEventTypes[topLevelType];</span>
        <span class="s3">if </span><span class="s1">(!bubbleDispatchConfig &amp;&amp; !directDispatchConfig)</span>
          <span class="s3">throw </span><span class="s1">Error(</span>
            <span class="s2">'Unsupported top level event type &quot;' </span><span class="s1">+ topLevelType + </span><span class="s2">'&quot; dispatched'</span>
          <span class="s1">);</span>
        <span class="s1">topLevelType = SyntheticEvent.getPooled(</span>
          <span class="s1">bubbleDispatchConfig || directDispatchConfig,</span>
          <span class="s1">targetInst,</span>
          <span class="s1">nativeEvent,</span>
          <span class="s1">nativeEventTarget</span>
        <span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(bubbleDispatchConfig)</span>
          <span class="s3">null </span><span class="s1">!= topLevelType &amp;&amp;</span>
          <span class="s3">null </span><span class="s1">!= topLevelType.dispatchConfig.phasedRegistrationNames &amp;&amp;</span>
          <span class="s1">topLevelType.dispatchConfig.phasedRegistrationNames.skipBubbling</span>
            <span class="s1">? topLevelType &amp;&amp;</span>
              <span class="s1">topLevelType.dispatchConfig.phasedRegistrationNames &amp;&amp;</span>
              <span class="s1">traverseTwoPhase$1(</span>
                <span class="s1">topLevelType._targetInst,</span>
                <span class="s1">accumulateDirectionalDispatches$1,</span>
                <span class="s1">topLevelType,</span>
                <span class="s1">!</span><span class="s4">0</span>
              <span class="s1">)</span>
            <span class="s1">: forEachAccumulated(</span>
                <span class="s1">topLevelType,</span>
                <span class="s1">accumulateTwoPhaseDispatchesSingle$1</span>
              <span class="s1">);</span>
        <span class="s3">else if </span><span class="s1">(directDispatchConfig)</span>
          <span class="s1">forEachAccumulated(topLevelType, accumulateDirectDispatchesSingle$1);</span>
        <span class="s3">else return null</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">topLevelType;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">},</span>
  <span class="s1">isOrderingDirty$jscomp$inline_241 = !</span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">pluginName$jscomp$inline_242;</span>
<span class="s3">for </span><span class="s1">(pluginName$jscomp$inline_242 </span><span class="s3">in </span><span class="s1">injectedNamesToPlugins$jscomp$inline_240)</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">injectedNamesToPlugins$jscomp$inline_240.hasOwnProperty(</span>
      <span class="s1">pluginName$jscomp$inline_242</span>
    <span class="s1">)</span>
  <span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">pluginModule$jscomp$inline_243 =</span>
      <span class="s1">injectedNamesToPlugins$jscomp$inline_240[pluginName$jscomp$inline_242];</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">!namesToPlugins.hasOwnProperty(pluginName$jscomp$inline_242) ||</span>
      <span class="s1">namesToPlugins[pluginName$jscomp$inline_242] !==</span>
        <span class="s1">pluginModule$jscomp$inline_243</span>
    <span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(namesToPlugins[pluginName$jscomp$inline_242])</span>
        <span class="s3">throw </span><span class="s1">Error(</span>
          <span class="s2">&quot;EventPluginRegistry: Cannot inject two different event plugins using the same name, `&quot; </span><span class="s1">+</span>
            <span class="s1">(pluginName$jscomp$inline_242 + </span><span class="s2">&quot;`.&quot;</span><span class="s1">)</span>
        <span class="s1">);</span>
      <span class="s1">namesToPlugins[</span>
        <span class="s1">pluginName$jscomp$inline_242</span>
      <span class="s1">] = pluginModule$jscomp$inline_243;</span>
      <span class="s1">isOrderingDirty$jscomp$inline_241 = !</span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">isOrderingDirty$jscomp$inline_241 &amp;&amp; recomputePluginOrdering();</span>
<span class="s3">var </span><span class="s1">instanceCache = </span><span class="s3">new </span><span class="s1">Map(),</span>
  <span class="s1">instanceProps = </span><span class="s3">new </span><span class="s1">Map();</span>
<span class="s3">function </span><span class="s1">getInstanceFromTag(tag) {</span>
  <span class="s3">return </span><span class="s1">instanceCache.get(tag) || </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">batchedUpdatesImpl(fn, bookkeeping) {</span>
  <span class="s3">return </span><span class="s1">fn(bookkeeping);</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">isInsideEventHandler = !</span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">batchedUpdates(fn, bookkeeping) {</span>
  <span class="s3">if </span><span class="s1">(isInsideEventHandler) </span><span class="s3">return </span><span class="s1">fn(bookkeeping);</span>
  <span class="s1">isInsideEventHandler = !</span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">try </span><span class="s1">{</span>
    <span class="s3">return </span><span class="s1">batchedUpdatesImpl(fn, bookkeeping);</span>
  <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
    <span class="s1">isInsideEventHandler = !</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">eventQueue = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">executeDispatchesAndReleaseTopLevel(e) {</span>
  <span class="s3">if </span><span class="s1">(e) {</span>
    <span class="s3">var </span><span class="s1">dispatchListeners = e._dispatchListeners,</span>
      <span class="s1">dispatchInstances = e._dispatchInstances;</span>
    <span class="s3">if </span><span class="s1">(isArrayImpl(dispatchListeners))</span>
      <span class="s3">for </span><span class="s1">(</span>
        <span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">i &lt; dispatchListeners.length &amp;&amp; !e.isPropagationStopped();</span>
        <span class="s1">i++</span>
      <span class="s1">)</span>
        <span class="s1">executeDispatch(e, dispatchListeners[i], dispatchInstances[i]);</span>
    <span class="s3">else</span>
      <span class="s1">dispatchListeners &amp;&amp;</span>
        <span class="s1">executeDispatch(e, dispatchListeners, dispatchInstances);</span>
    <span class="s1">e._dispatchListeners = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">e._dispatchInstances = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">e.isPersistent() || e.constructor.release(e);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">EMPTY_NATIVE_EVENT = {};</span>
<span class="s3">function </span><span class="s1">_receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {</span>
  <span class="s3">var </span><span class="s1">nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT,</span>
    <span class="s1">inst = getInstanceFromTag(rootNodeID),</span>
    <span class="s1">target = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">null </span><span class="s1">!= inst &amp;&amp; (target = inst.stateNode);</span>
  <span class="s1">batchedUpdates(</span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">var </span><span class="s1">JSCompiler_inline_result = target;</span>
    <span class="s3">for </span><span class="s1">(</span>
      <span class="s3">var </span><span class="s1">events = </span><span class="s3">null</span><span class="s1">, legacyPlugins = plugins, i = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">i &lt; legacyPlugins.length;</span>
      <span class="s1">i++</span>
    <span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">possiblePlugin = legacyPlugins[i];</span>
      <span class="s1">possiblePlugin &amp;&amp;</span>
        <span class="s1">(possiblePlugin = possiblePlugin.extractEvents(</span>
          <span class="s1">topLevelType,</span>
          <span class="s1">inst,</span>
          <span class="s1">nativeEvent,</span>
          <span class="s1">JSCompiler_inline_result</span>
        <span class="s1">)) &amp;&amp;</span>
        <span class="s1">(events = accumulateInto(events, possiblePlugin));</span>
    <span class="s1">}</span>
    <span class="s1">JSCompiler_inline_result = events;</span>
    <span class="s3">null </span><span class="s1">!== JSCompiler_inline_result &amp;&amp;</span>
      <span class="s1">(eventQueue = accumulateInto(eventQueue, JSCompiler_inline_result));</span>
    <span class="s1">JSCompiler_inline_result = eventQueue;</span>
    <span class="s1">eventQueue = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(JSCompiler_inline_result) {</span>
      <span class="s1">forEachAccumulated(</span>
        <span class="s1">JSCompiler_inline_result,</span>
        <span class="s1">executeDispatchesAndReleaseTopLevel</span>
      <span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(eventQueue)</span>
        <span class="s3">throw </span><span class="s1">Error(</span>
          <span class="s2">&quot;processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.&quot;</span>
        <span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(hasRethrowError)</span>
        <span class="s3">throw </span><span class="s1">((JSCompiler_inline_result = rethrowError),</span>
        <span class="s1">(hasRethrowError = !</span><span class="s4">1</span><span class="s1">),</span>
        <span class="s1">(rethrowError = </span><span class="s3">null</span><span class="s1">),</span>
        <span class="s1">JSCompiler_inline_result);</span>
    <span class="s1">}</span>
  <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">ReactNativePrivateInterface.RCTEventEmitter.register({</span>
  <span class="s1">receiveEvent: </span><span class="s3">function</span><span class="s1">(rootNodeID, topLevelType, nativeEventParam) {</span>
    <span class="s1">_receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);</span>
  <span class="s1">},</span>
  <span class="s1">receiveTouches: </span><span class="s3">function</span><span class="s1">(eventTopLevelType, touches, changedIndices) {</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s2">&quot;topTouchEnd&quot; </span><span class="s1">=== eventTopLevelType ||</span>
      <span class="s2">&quot;topTouchCancel&quot; </span><span class="s1">=== eventTopLevelType</span>
    <span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">JSCompiler_temp = [];</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; changedIndices.length; i++) {</span>
        <span class="s3">var </span><span class="s1">index$0 = changedIndices[i];</span>
        <span class="s1">JSCompiler_temp.push(touches[index$0]);</span>
        <span class="s1">touches[index$0] = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">for </span><span class="s1">(i = changedIndices = </span><span class="s4">0</span><span class="s1">; i &lt; touches.length; i++)</span>
        <span class="s1">(index$0 = touches[i]),</span>
          <span class="s3">null </span><span class="s1">!== index$0 &amp;&amp; (touches[changedIndices++] = index$0);</span>
      <span class="s1">touches.length = changedIndices;</span>
    <span class="s1">} </span><span class="s3">else</span>
      <span class="s3">for </span><span class="s1">(JSCompiler_temp = [], i = </span><span class="s4">0</span><span class="s1">; i &lt; changedIndices.length; i++)</span>
        <span class="s1">JSCompiler_temp.push(touches[changedIndices[i]]);</span>
    <span class="s3">for </span><span class="s1">(</span>
      <span class="s1">changedIndices = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">changedIndices &lt; JSCompiler_temp.length;</span>
      <span class="s1">changedIndices++</span>
    <span class="s1">) {</span>
      <span class="s1">i = JSCompiler_temp[changedIndices];</span>
      <span class="s1">i.changedTouches = JSCompiler_temp;</span>
      <span class="s1">i.touches = touches;</span>
      <span class="s1">index$0 = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">target = i.target;</span>
      <span class="s3">null </span><span class="s1">=== target || </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">=== target || </span><span class="s4">1 </span><span class="s1">&gt; target || (index$0 = target);</span>
      <span class="s1">_receiveRootNodeIDEvent(index$0, eventTopLevelType, i);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">});</span>
<span class="s1">getFiberCurrentPropsFromNode = </span><span class="s3">function</span><span class="s1">(stateNode) {</span>
  <span class="s3">return </span><span class="s1">instanceProps.get(stateNode._nativeTag) || </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s1">getInstanceFromNode = getInstanceFromTag;</span>
<span class="s1">getNodeFromInstance = </span><span class="s3">function</span><span class="s1">(inst) {</span>
  <span class="s1">inst = inst.stateNode;</span>
  <span class="s3">var </span><span class="s1">tag = inst._nativeTag;</span>
  <span class="s3">void </span><span class="s4">0 </span><span class="s1">=== tag &amp;&amp; ((inst = inst.canonical), (tag = inst._nativeTag));</span>
  <span class="s3">if </span><span class="s1">(!tag) </span><span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;All native instances should have a tag.&quot;</span><span class="s1">);</span>
  <span class="s3">return </span><span class="s1">inst;</span>
<span class="s1">};</span>
<span class="s1">ResponderEventPlugin.injection.injectGlobalResponderHandler({</span>
  <span class="s1">onChange: </span><span class="s3">function</span><span class="s1">(from, to, blockNativeResponder) {</span>
    <span class="s3">null </span><span class="s1">!== to</span>
      <span class="s1">? ReactNativePrivateInterface.UIManager.setJSResponder(</span>
          <span class="s1">to.stateNode._nativeTag,</span>
          <span class="s1">blockNativeResponder</span>
        <span class="s1">)</span>
      <span class="s1">: ReactNativePrivateInterface.UIManager.clearJSResponder();</span>
  <span class="s1">}</span>
<span class="s1">});</span>
<span class="s3">var </span><span class="s1">ReactSharedInternals =</span>
    <span class="s1">React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,</span>
  <span class="s1">REACT_ELEMENT_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.element&quot;</span><span class="s1">),</span>
  <span class="s1">REACT_PORTAL_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.portal&quot;</span><span class="s1">),</span>
  <span class="s1">REACT_FRAGMENT_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.fragment&quot;</span><span class="s1">),</span>
  <span class="s1">REACT_STRICT_MODE_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.strict_mode&quot;</span><span class="s1">),</span>
  <span class="s1">REACT_PROFILER_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.profiler&quot;</span><span class="s1">),</span>
  <span class="s1">REACT_PROVIDER_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.provider&quot;</span><span class="s1">),</span>
  <span class="s1">REACT_CONTEXT_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.context&quot;</span><span class="s1">),</span>
  <span class="s1">REACT_FORWARD_REF_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.forward_ref&quot;</span><span class="s1">),</span>
  <span class="s1">REACT_SUSPENSE_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.suspense&quot;</span><span class="s1">),</span>
  <span class="s1">REACT_SUSPENSE_LIST_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.suspense_list&quot;</span><span class="s1">),</span>
  <span class="s1">REACT_MEMO_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.memo&quot;</span><span class="s1">),</span>
  <span class="s1">REACT_LAZY_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.lazy&quot;</span><span class="s1">);</span>
<span class="s1">Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.scope&quot;</span><span class="s1">);</span>
<span class="s1">Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.debug_trace_mode&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_OFFSCREEN_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.offscreen&quot;</span><span class="s1">);</span>
<span class="s1">Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.legacy_hidden&quot;</span><span class="s1">);</span>
<span class="s1">Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.cache&quot;</span><span class="s1">);</span>
<span class="s1">Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.tracing_marker&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">MAYBE_ITERATOR_SYMBOL = Symbol.iterator;</span>
<span class="s3">function </span><span class="s1">getIteratorFn(maybeIterable) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== maybeIterable || </span><span class="s2">&quot;object&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">maybeIterable) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">maybeIterable =</span>
    <span class="s1">(MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||</span>
    <span class="s1">maybeIterable[</span><span class="s2">&quot;@@iterator&quot;</span><span class="s1">];</span>
  <span class="s3">return </span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">maybeIterable ? maybeIterable : </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getComponentNameFromType(type) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">== type) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">type) </span><span class="s3">return </span><span class="s1">type.displayName || type.name || </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;string&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">type) </span><span class="s3">return </span><span class="s1">type;</span>
  <span class="s3">switch </span><span class="s1">(type) {</span>
    <span class="s3">case </span><span class="s1">REACT_FRAGMENT_TYPE:</span>
      <span class="s3">return </span><span class="s2">&quot;Fragment&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
      <span class="s3">return </span><span class="s2">&quot;Portal&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s1">REACT_PROFILER_TYPE:</span>
      <span class="s3">return </span><span class="s2">&quot;Profiler&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s1">REACT_STRICT_MODE_TYPE:</span>
      <span class="s3">return </span><span class="s2">&quot;StrictMode&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
      <span class="s3">return </span><span class="s2">&quot;Suspense&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
      <span class="s3">return </span><span class="s2">&quot;SuspenseList&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;object&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">type)</span>
    <span class="s3">switch </span><span class="s1">(type.$$typeof) {</span>
      <span class="s3">case </span><span class="s1">REACT_CONTEXT_TYPE:</span>
        <span class="s3">return </span><span class="s1">(type.displayName || </span><span class="s2">&quot;Context&quot;</span><span class="s1">) + </span><span class="s2">&quot;.Consumer&quot;</span><span class="s1">;</span>
      <span class="s3">case </span><span class="s1">REACT_PROVIDER_TYPE:</span>
        <span class="s3">return </span><span class="s1">(type._context.displayName || </span><span class="s2">&quot;Context&quot;</span><span class="s1">) + </span><span class="s2">&quot;.Provider&quot;</span><span class="s1">;</span>
      <span class="s3">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
        <span class="s3">var </span><span class="s1">innerType = type.render;</span>
        <span class="s1">type = type.displayName;</span>
        <span class="s1">type ||</span>
          <span class="s1">((type = innerType.displayName || innerType.name || </span><span class="s2">&quot;&quot;</span><span class="s1">),</span>
          <span class="s1">(type = </span><span class="s2">&quot;&quot; </span><span class="s1">!== type ? </span><span class="s2">&quot;ForwardRef(&quot; </span><span class="s1">+ type + </span><span class="s2">&quot;)&quot; </span><span class="s1">: </span><span class="s2">&quot;ForwardRef&quot;</span><span class="s1">));</span>
        <span class="s3">return </span><span class="s1">type;</span>
      <span class="s3">case </span><span class="s1">REACT_MEMO_TYPE:</span>
        <span class="s3">return </span><span class="s1">(</span>
          <span class="s1">(innerType = type.displayName || </span><span class="s3">null</span><span class="s1">),</span>
          <span class="s3">null </span><span class="s1">!== innerType</span>
            <span class="s1">? innerType</span>
            <span class="s1">: getComponentNameFromType(type.type) || </span><span class="s2">&quot;Memo&quot;</span>
        <span class="s1">);</span>
      <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE:</span>
        <span class="s1">innerType = type._payload;</span>
        <span class="s1">type = type._init;</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">getComponentNameFromType(type(innerType));</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {}</span>
    <span class="s1">}</span>
  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getComponentNameFromFiber(fiber) {</span>
  <span class="s3">var </span><span class="s1">type = fiber.type;</span>
  <span class="s3">switch </span><span class="s1">(fiber.tag) {</span>
    <span class="s3">case </span><span class="s4">24</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">&quot;Cache&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">9</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(type.displayName || </span><span class="s2">&quot;Context&quot;</span><span class="s1">) + </span><span class="s2">&quot;.Consumer&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">10</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(type._context.displayName || </span><span class="s2">&quot;Context&quot;</span><span class="s1">) + </span><span class="s2">&quot;.Provider&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">18</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">&quot;DehydratedFragment&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">11</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(fiber = type.render),</span>
        <span class="s1">(fiber = fiber.displayName || fiber.name || </span><span class="s2">&quot;&quot;</span><span class="s1">),</span>
        <span class="s1">type.displayName ||</span>
          <span class="s1">(</span><span class="s2">&quot;&quot; </span><span class="s1">!== fiber ? </span><span class="s2">&quot;ForwardRef(&quot; </span><span class="s1">+ fiber + </span><span class="s2">&quot;)&quot; </span><span class="s1">: </span><span class="s2">&quot;ForwardRef&quot;</span><span class="s1">)</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">7</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">&quot;Fragment&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">type;</span>
    <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">&quot;Portal&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">&quot;Root&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">6</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">&quot;Text&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">16</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">getComponentNameFromType(type);</span>
    <span class="s3">case </span><span class="s4">8</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">type === REACT_STRICT_MODE_TYPE ? </span><span class="s2">&quot;StrictMode&quot; </span><span class="s1">: </span><span class="s2">&quot;Mode&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">22</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">&quot;Offscreen&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">12</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">&quot;Profiler&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">21</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">&quot;Scope&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">13</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">&quot;Suspense&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">19</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">&quot;SuspenseList&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">25</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">&quot;TracingMarker&quot;</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">17</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">2</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">14</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">15</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">type)</span>
        <span class="s3">return </span><span class="s1">type.displayName || type.name || </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;string&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">type) </span><span class="s3">return </span><span class="s1">type;</span>
  <span class="s1">}</span>
  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getNearestMountedFiber(fiber) {</span>
  <span class="s3">var </span><span class="s1">node = fiber,</span>
    <span class="s1">nearestMounted = fiber;</span>
  <span class="s3">if </span><span class="s1">(fiber.alternate) </span><span class="s3">for </span><span class="s1">(; node.</span><span class="s3">return</span><span class="s1">; ) node = node.</span><span class="s3">return</span><span class="s1">;</span>
  <span class="s3">else </span><span class="s1">{</span>
    <span class="s1">fiber = node;</span>
    <span class="s3">do</span>
      <span class="s1">(node = fiber),</span>
        <span class="s4">0 </span><span class="s1">!== (node.flags &amp; </span><span class="s4">4098</span><span class="s1">) &amp;&amp; (nearestMounted = node.</span><span class="s3">return</span><span class="s1">),</span>
        <span class="s1">(fiber = node.</span><span class="s3">return</span><span class="s1">);</span>
    <span class="s3">while </span><span class="s1">(fiber);</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s4">3 </span><span class="s1">=== node.tag ? nearestMounted : </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">assertIsMounted(fiber) {</span>
  <span class="s3">if </span><span class="s1">(getNearestMountedFiber(fiber) !== fiber)</span>
    <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Unable to find node on an unmounted component.&quot;</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">findCurrentFiberUsingSlowPath(fiber) {</span>
  <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>
  <span class="s3">if </span><span class="s1">(!alternate) {</span>
    <span class="s1">alternate = getNearestMountedFiber(fiber);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== alternate)</span>
      <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Unable to find node on an unmounted component.&quot;</span><span class="s1">);</span>
    <span class="s3">return </span><span class="s1">alternate !== fiber ? </span><span class="s3">null </span><span class="s1">: fiber;</span>
  <span class="s1">}</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">a = fiber, b = alternate; ; ) {</span>
    <span class="s3">var </span><span class="s1">parentA = a.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== parentA) </span><span class="s3">break</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">parentB = parentA.alternate;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== parentB) {</span>
      <span class="s1">b = parentA.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== b) {</span>
        <span class="s1">a = b;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(parentA.child === parentB.child) {</span>
      <span class="s3">for </span><span class="s1">(parentB = parentA.child; parentB; ) {</span>
        <span class="s3">if </span><span class="s1">(parentB === a) </span><span class="s3">return </span><span class="s1">assertIsMounted(parentA), fiber;</span>
        <span class="s3">if </span><span class="s1">(parentB === b) </span><span class="s3">return </span><span class="s1">assertIsMounted(parentA), alternate;</span>
        <span class="s1">parentB = parentB.sibling;</span>
      <span class="s1">}</span>
      <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Unable to find node on an unmounted component.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(a.</span><span class="s3">return </span><span class="s1">!== b.</span><span class="s3">return</span><span class="s1">) (a = parentA), (b = parentB);</span>
    <span class="s3">else </span><span class="s1">{</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">didFindChild = !</span><span class="s4">1</span><span class="s1">, child$1 = parentA.child; child$1; ) {</span>
        <span class="s3">if </span><span class="s1">(child$1 === a) {</span>
          <span class="s1">didFindChild = !</span><span class="s4">0</span><span class="s1">;</span>
          <span class="s1">a = parentA;</span>
          <span class="s1">b = parentB;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(child$1 === b) {</span>
          <span class="s1">didFindChild = !</span><span class="s4">0</span><span class="s1">;</span>
          <span class="s1">b = parentA;</span>
          <span class="s1">a = parentB;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">child$1 = child$1.sibling;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(!didFindChild) {</span>
        <span class="s3">for </span><span class="s1">(child$1 = parentB.child; child$1; ) {</span>
          <span class="s3">if </span><span class="s1">(child$1 === a) {</span>
            <span class="s1">didFindChild = !</span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">a = parentB;</span>
            <span class="s1">b = parentA;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s3">if </span><span class="s1">(child$1 === b) {</span>
            <span class="s1">didFindChild = !</span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">b = parentB;</span>
            <span class="s1">a = parentA;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s1">child$1 = child$1.sibling;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!didFindChild)</span>
          <span class="s3">throw </span><span class="s1">Error(</span>
            <span class="s2">&quot;Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.&quot;</span>
          <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(a.alternate !== b)</span>
      <span class="s3">throw </span><span class="s1">Error(</span>
        <span class="s2">&quot;Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
      <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">3 </span><span class="s1">!== a.tag)</span>
    <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Unable to find node on an unmounted component.&quot;</span><span class="s1">);</span>
  <span class="s3">return </span><span class="s1">a.stateNode.current === a ? fiber : alternate;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">findCurrentHostFiber(parent) {</span>
  <span class="s1">parent = findCurrentFiberUsingSlowPath(parent);</span>
  <span class="s3">return null </span><span class="s1">!== parent ? findCurrentHostFiberImpl(parent) : </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">findCurrentHostFiberImpl(node) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">5 </span><span class="s1">=== node.tag || </span><span class="s4">6 </span><span class="s1">=== node.tag) </span><span class="s3">return </span><span class="s1">node;</span>
  <span class="s3">for </span><span class="s1">(node = node.child; </span><span class="s3">null </span><span class="s1">!== node; ) {</span>
    <span class="s3">var </span><span class="s1">match = findCurrentHostFiberImpl(node);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== match) </span><span class="s3">return </span><span class="s1">match;</span>
    <span class="s1">node = node.sibling;</span>
  <span class="s1">}</span>
  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">emptyObject = {},</span>
  <span class="s1">removedKeys = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">removedKeyCount = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">deepDifferOptions = { unsafelyIgnoreFunctions: !</span><span class="s4">0 </span><span class="s1">};</span>
<span class="s3">function </span><span class="s1">defaultDiffer(prevProp, nextProp) {</span>
  <span class="s3">return </span><span class="s2">&quot;object&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">nextProp || </span><span class="s3">null </span><span class="s1">=== nextProp</span>
    <span class="s1">? !</span><span class="s4">0</span>
    <span class="s1">: ReactNativePrivateInterface.deepDiffer(</span>
        <span class="s1">prevProp,</span>
        <span class="s1">nextProp,</span>
        <span class="s1">deepDifferOptions</span>
      <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">restoreDeletedValuesInNestedArray(</span>
  <span class="s1">updatePayload,</span>
  <span class="s1">node,</span>
  <span class="s1">validAttributes</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(isArrayImpl(node))</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = node.length; i-- &amp;&amp; </span><span class="s4">0 </span><span class="s1">&lt; removedKeyCount; )</span>
      <span class="s1">restoreDeletedValuesInNestedArray(</span>
        <span class="s1">updatePayload,</span>
        <span class="s1">node[i],</span>
        <span class="s1">validAttributes</span>
      <span class="s1">);</span>
  <span class="s3">else if </span><span class="s1">(node &amp;&amp; </span><span class="s4">0 </span><span class="s1">&lt; removedKeyCount)</span>
    <span class="s3">for </span><span class="s1">(i </span><span class="s3">in </span><span class="s1">removedKeys)</span>
      <span class="s3">if </span><span class="s1">(removedKeys[i]) {</span>
        <span class="s3">var </span><span class="s1">nextProp = node[i];</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">void </span><span class="s4">0 </span><span class="s1">!== nextProp) {</span>
          <span class="s3">var </span><span class="s1">attributeConfig = validAttributes[i];</span>
          <span class="s3">if </span><span class="s1">(attributeConfig) {</span>
            <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">nextProp &amp;&amp; (nextProp = !</span><span class="s4">0</span><span class="s1">);</span>
            <span class="s2">&quot;undefined&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">nextProp &amp;&amp; (nextProp = </span><span class="s3">null</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;object&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">attributeConfig)</span>
              <span class="s1">updatePayload[i] = nextProp;</span>
            <span class="s3">else if </span><span class="s1">(</span>
              <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">attributeConfig.diff ||</span>
              <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">attributeConfig.process</span>
            <span class="s1">)</span>
              <span class="s1">(nextProp =</span>
                <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">attributeConfig.process</span>
                  <span class="s1">? attributeConfig.process(nextProp)</span>
                  <span class="s1">: nextProp),</span>
                <span class="s1">(updatePayload[i] = nextProp);</span>
            <span class="s1">removedKeys[i] = !</span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">removedKeyCount--;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">diffNestedProperty(</span>
  <span class="s1">updatePayload,</span>
  <span class="s1">prevProp,</span>
  <span class="s1">nextProp,</span>
  <span class="s1">validAttributes</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(!updatePayload &amp;&amp; prevProp === nextProp) </span><span class="s3">return </span><span class="s1">updatePayload;</span>
  <span class="s3">if </span><span class="s1">(!prevProp || !nextProp)</span>
    <span class="s3">return </span><span class="s1">nextProp</span>
      <span class="s1">? addNestedProperty(updatePayload, nextProp, validAttributes)</span>
      <span class="s1">: prevProp</span>
      <span class="s1">? clearNestedProperty(updatePayload, prevProp, validAttributes)</span>
      <span class="s1">: updatePayload;</span>
  <span class="s3">if </span><span class="s1">(!isArrayImpl(prevProp) &amp;&amp; !isArrayImpl(nextProp))</span>
    <span class="s3">return </span><span class="s1">diffProperties(updatePayload, prevProp, nextProp, validAttributes);</span>
  <span class="s3">if </span><span class="s1">(isArrayImpl(prevProp) &amp;&amp; isArrayImpl(nextProp)) {</span>
    <span class="s3">var </span><span class="s1">minLength =</span>
        <span class="s1">prevProp.length &lt; nextProp.length ? prevProp.length : nextProp.length,</span>
      <span class="s1">i;</span>
    <span class="s3">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; minLength; i++)</span>
      <span class="s1">updatePayload = diffNestedProperty(</span>
        <span class="s1">updatePayload,</span>
        <span class="s1">prevProp[i],</span>
        <span class="s1">nextProp[i],</span>
        <span class="s1">validAttributes</span>
      <span class="s1">);</span>
    <span class="s3">for </span><span class="s1">(; i &lt; prevProp.length; i++)</span>
      <span class="s1">updatePayload = clearNestedProperty(</span>
        <span class="s1">updatePayload,</span>
        <span class="s1">prevProp[i],</span>
        <span class="s1">validAttributes</span>
      <span class="s1">);</span>
    <span class="s3">for </span><span class="s1">(; i &lt; nextProp.length; i++)</span>
      <span class="s1">updatePayload = addNestedProperty(</span>
        <span class="s1">updatePayload,</span>
        <span class="s1">nextProp[i],</span>
        <span class="s1">validAttributes</span>
      <span class="s1">);</span>
    <span class="s3">return </span><span class="s1">updatePayload;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">isArrayImpl(prevProp)</span>
    <span class="s1">? diffProperties(</span>
        <span class="s1">updatePayload,</span>
        <span class="s1">ReactNativePrivateInterface.flattenStyle(prevProp),</span>
        <span class="s1">nextProp,</span>
        <span class="s1">validAttributes</span>
      <span class="s1">)</span>
    <span class="s1">: diffProperties(</span>
        <span class="s1">updatePayload,</span>
        <span class="s1">prevProp,</span>
        <span class="s1">ReactNativePrivateInterface.flattenStyle(nextProp),</span>
        <span class="s1">validAttributes</span>
      <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">addNestedProperty(updatePayload, nextProp, validAttributes) {</span>
  <span class="s3">if </span><span class="s1">(!nextProp) </span><span class="s3">return </span><span class="s1">updatePayload;</span>
  <span class="s3">if </span><span class="s1">(!isArrayImpl(nextProp))</span>
    <span class="s3">return </span><span class="s1">diffProperties(</span>
      <span class="s1">updatePayload,</span>
      <span class="s1">emptyObject,</span>
      <span class="s1">nextProp,</span>
      <span class="s1">validAttributes</span>
    <span class="s1">);</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; nextProp.length; i++)</span>
    <span class="s1">updatePayload = addNestedProperty(</span>
      <span class="s1">updatePayload,</span>
      <span class="s1">nextProp[i],</span>
      <span class="s1">validAttributes</span>
    <span class="s1">);</span>
  <span class="s3">return </span><span class="s1">updatePayload;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">clearNestedProperty(updatePayload, prevProp, validAttributes) {</span>
  <span class="s3">if </span><span class="s1">(!prevProp) </span><span class="s3">return </span><span class="s1">updatePayload;</span>
  <span class="s3">if </span><span class="s1">(!isArrayImpl(prevProp))</span>
    <span class="s3">return </span><span class="s1">diffProperties(</span>
      <span class="s1">updatePayload,</span>
      <span class="s1">prevProp,</span>
      <span class="s1">emptyObject,</span>
      <span class="s1">validAttributes</span>
    <span class="s1">);</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; prevProp.length; i++)</span>
    <span class="s1">updatePayload = clearNestedProperty(</span>
      <span class="s1">updatePayload,</span>
      <span class="s1">prevProp[i],</span>
      <span class="s1">validAttributes</span>
    <span class="s1">);</span>
  <span class="s3">return </span><span class="s1">updatePayload;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">diffProperties(updatePayload, prevProps, nextProps, validAttributes) {</span>
  <span class="s3">var </span><span class="s1">attributeConfig, propKey;</span>
  <span class="s3">for </span><span class="s1">(propKey </span><span class="s3">in </span><span class="s1">nextProps)</span>
    <span class="s3">if </span><span class="s1">((attributeConfig = validAttributes[propKey])) {</span>
      <span class="s3">var </span><span class="s1">prevProp = prevProps[propKey];</span>
      <span class="s3">var </span><span class="s1">nextProp = nextProps[propKey];</span>
      <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">nextProp &amp;&amp;</span>
        <span class="s1">((nextProp = !</span><span class="s4">0</span><span class="s1">), </span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">prevProp &amp;&amp; (prevProp = !</span><span class="s4">0</span><span class="s1">));</span>
      <span class="s2">&quot;undefined&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">nextProp &amp;&amp;</span>
        <span class="s1">((nextProp = </span><span class="s3">null</span><span class="s1">),</span>
        <span class="s2">&quot;undefined&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">prevProp &amp;&amp; (prevProp = </span><span class="s3">null</span><span class="s1">));</span>
      <span class="s1">removedKeys &amp;&amp; (removedKeys[propKey] = !</span><span class="s4">1</span><span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(updatePayload &amp;&amp; </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">!== updatePayload[propKey])</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;object&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">attributeConfig)</span>
          <span class="s1">updatePayload[propKey] = nextProp;</span>
        <span class="s3">else </span><span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(</span>
            <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">attributeConfig.diff ||</span>
            <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">attributeConfig.process</span>
          <span class="s1">)</span>
            <span class="s1">(attributeConfig =</span>
              <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">attributeConfig.process</span>
                <span class="s1">? attributeConfig.process(nextProp)</span>
                <span class="s1">: nextProp),</span>
              <span class="s1">(updatePayload[propKey] = attributeConfig);</span>
        <span class="s1">}</span>
      <span class="s3">else if </span><span class="s1">(prevProp !== nextProp)</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;object&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">attributeConfig)</span>
          <span class="s1">defaultDiffer(prevProp, nextProp) &amp;&amp;</span>
            <span class="s1">((updatePayload || (updatePayload = {}))[propKey] = nextProp);</span>
        <span class="s3">else if </span><span class="s1">(</span>
          <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">attributeConfig.diff ||</span>
          <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">attributeConfig.process</span>
        <span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(</span>
            <span class="s3">void </span><span class="s4">0 </span><span class="s1">=== prevProp ||</span>
            <span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">attributeConfig.diff</span>
              <span class="s1">? attributeConfig.diff(prevProp, nextProp)</span>
              <span class="s1">: defaultDiffer(prevProp, nextProp))</span>
          <span class="s1">)</span>
            <span class="s1">(attributeConfig =</span>
              <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">attributeConfig.process</span>
                <span class="s1">? attributeConfig.process(nextProp)</span>
                <span class="s1">: nextProp),</span>
              <span class="s1">((updatePayload || (updatePayload = {}))[</span>
                <span class="s1">propKey</span>
              <span class="s1">] = attributeConfig);</span>
        <span class="s1">} </span><span class="s3">else</span>
          <span class="s1">(removedKeys = </span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">(removedKeyCount = </span><span class="s4">0</span><span class="s1">),</span>
            <span class="s1">(updatePayload = diffNestedProperty(</span>
              <span class="s1">updatePayload,</span>
              <span class="s1">prevProp,</span>
              <span class="s1">nextProp,</span>
              <span class="s1">attributeConfig</span>
            <span class="s1">)),</span>
            <span class="s4">0 </span><span class="s1">&lt; removedKeyCount &amp;&amp;</span>
              <span class="s1">updatePayload &amp;&amp;</span>
              <span class="s1">(restoreDeletedValuesInNestedArray(</span>
                <span class="s1">updatePayload,</span>
                <span class="s1">nextProp,</span>
                <span class="s1">attributeConfig</span>
              <span class="s1">),</span>
              <span class="s1">(removedKeys = </span><span class="s3">null</span><span class="s1">));</span>
    <span class="s1">}</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">propKey$3 </span><span class="s3">in </span><span class="s1">prevProps)</span>
    <span class="s3">void </span><span class="s4">0 </span><span class="s1">=== nextProps[propKey$3] &amp;&amp;</span>
      <span class="s1">(!(attributeConfig = validAttributes[propKey$3]) ||</span>
        <span class="s1">(updatePayload &amp;&amp; </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">!== updatePayload[propKey$3]) ||</span>
        <span class="s1">((prevProp = prevProps[propKey$3]),</span>
        <span class="s3">void </span><span class="s4">0 </span><span class="s1">!== prevProp &amp;&amp;</span>
          <span class="s1">(</span><span class="s2">&quot;object&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">attributeConfig ||</span>
          <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">attributeConfig.diff ||</span>
          <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">attributeConfig.process</span>
            <span class="s1">? (((updatePayload || (updatePayload = {}))[propKey$3] = </span><span class="s3">null</span><span class="s1">),</span>
              <span class="s1">removedKeys || (removedKeys = {}),</span>
              <span class="s1">removedKeys[propKey$3] ||</span>
                <span class="s1">((removedKeys[propKey$3] = !</span><span class="s4">0</span><span class="s1">), removedKeyCount++))</span>
            <span class="s1">: (updatePayload = clearNestedProperty(</span>
                <span class="s1">updatePayload,</span>
                <span class="s1">prevProp,</span>
                <span class="s1">attributeConfig</span>
              <span class="s1">)))));</span>
  <span class="s3">return </span><span class="s1">updatePayload;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">mountSafeCallback_NOT_REALLY_SAFE(context, callback) {</span>
  <span class="s3">return function</span><span class="s1">() {</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">callback &amp;&amp;</span>
      <span class="s1">(</span><span class="s2">&quot;boolean&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">context.__isMounted || context.__isMounted)</span>
    <span class="s1">)</span>
      <span class="s3">return </span><span class="s1">callback.apply(context, arguments);</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">ReactNativeFiberHostComponent = (</span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">function </span><span class="s1">ReactNativeFiberHostComponent(tag, viewConfig) {</span>
      <span class="s3">this</span><span class="s1">._nativeTag = tag;</span>
      <span class="s3">this</span><span class="s1">._children = [];</span>
      <span class="s3">this</span><span class="s1">.viewConfig = viewConfig;</span>
    <span class="s1">}</span>
    <span class="s3">var </span><span class="s1">_proto = ReactNativeFiberHostComponent.prototype;</span>
    <span class="s1">_proto.blur = </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">ReactNativePrivateInterface.TextInputState.blurTextInput(</span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">};</span>
    <span class="s1">_proto.focus = </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">ReactNativePrivateInterface.TextInputState.focusTextInput(</span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">};</span>
    <span class="s1">_proto.measure = </span><span class="s3">function</span><span class="s1">(callback) {</span>
      <span class="s1">ReactNativePrivateInterface.UIManager.measure(</span>
        <span class="s3">this</span><span class="s1">._nativeTag,</span>
        <span class="s1">mountSafeCallback_NOT_REALLY_SAFE(</span><span class="s3">this</span><span class="s1">, callback)</span>
      <span class="s1">);</span>
    <span class="s1">};</span>
    <span class="s1">_proto.measureInWindow = </span><span class="s3">function</span><span class="s1">(callback) {</span>
      <span class="s1">ReactNativePrivateInterface.UIManager.measureInWindow(</span>
        <span class="s3">this</span><span class="s1">._nativeTag,</span>
        <span class="s1">mountSafeCallback_NOT_REALLY_SAFE(</span><span class="s3">this</span><span class="s1">, callback)</span>
      <span class="s1">);</span>
    <span class="s1">};</span>
    <span class="s1">_proto.measureLayout = </span><span class="s3">function</span><span class="s1">(relativeToNativeNode, onSuccess, onFail) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;number&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">relativeToNativeNode)</span>
        <span class="s3">var </span><span class="s1">relativeNode = relativeToNativeNode;</span>
      <span class="s3">else</span>
        <span class="s1">relativeToNativeNode._nativeTag &amp;&amp;</span>
          <span class="s1">(relativeNode = relativeToNativeNode._nativeTag);</span>
      <span class="s3">null </span><span class="s1">!= relativeNode &amp;&amp;</span>
        <span class="s1">ReactNativePrivateInterface.UIManager.measureLayout(</span>
          <span class="s3">this</span><span class="s1">._nativeTag,</span>
          <span class="s1">relativeNode,</span>
          <span class="s1">mountSafeCallback_NOT_REALLY_SAFE(</span><span class="s3">this</span><span class="s1">, onFail),</span>
          <span class="s1">mountSafeCallback_NOT_REALLY_SAFE(</span><span class="s3">this</span><span class="s1">, onSuccess)</span>
        <span class="s1">);</span>
    <span class="s1">};</span>
    <span class="s1">_proto.setNativeProps = </span><span class="s3">function</span><span class="s1">(nativeProps) {</span>
      <span class="s1">nativeProps = diffProperties(</span>
        <span class="s3">null</span><span class="s1">,</span>
        <span class="s1">emptyObject,</span>
        <span class="s1">nativeProps,</span>
        <span class="s3">this</span><span class="s1">.viewConfig.validAttributes</span>
      <span class="s1">);</span>
      <span class="s3">null </span><span class="s1">!= nativeProps &amp;&amp;</span>
        <span class="s1">ReactNativePrivateInterface.UIManager.updateView(</span>
          <span class="s3">this</span><span class="s1">._nativeTag,</span>
          <span class="s3">this</span><span class="s1">.viewConfig.uiViewClassName,</span>
          <span class="s1">nativeProps</span>
        <span class="s1">);</span>
    <span class="s1">};</span>
    <span class="s3">return </span><span class="s1">ReactNativeFiberHostComponent;</span>
  <span class="s1">})(),</span>
  <span class="s1">scheduleCallback = Scheduler.unstable_scheduleCallback,</span>
  <span class="s1">cancelCallback = Scheduler.unstable_cancelCallback,</span>
  <span class="s1">shouldYield = Scheduler.unstable_shouldYield,</span>
  <span class="s1">requestPaint = Scheduler.unstable_requestPaint,</span>
  <span class="s1">now = Scheduler.unstable_now,</span>
  <span class="s1">ImmediatePriority = Scheduler.unstable_ImmediatePriority,</span>
  <span class="s1">UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,</span>
  <span class="s1">NormalPriority = Scheduler.unstable_NormalPriority,</span>
  <span class="s1">IdlePriority = Scheduler.unstable_IdlePriority,</span>
  <span class="s1">rendererID = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">injectedHook = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">isDevToolsPresent = </span><span class="s2">&quot;undefined&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__;</span>
<span class="s3">function </span><span class="s1">onCommitRoot(root, eventPriority) {</span>
  <span class="s3">if </span><span class="s1">(injectedHook &amp;&amp; </span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">injectedHook.onCommitFiberRoot)</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">didError = </span><span class="s4">128 </span><span class="s1">=== (root.current.flags &amp; </span><span class="s4">128</span><span class="s1">);</span>
      <span class="s3">switch </span><span class="s1">(eventPriority) {</span>
        <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
          <span class="s3">var </span><span class="s1">schedulerPriority = ImmediatePriority;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
          <span class="s1">schedulerPriority = UserBlockingPriority;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">16</span><span class="s1">:</span>
          <span class="s1">schedulerPriority = NormalPriority;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">536870912</span><span class="s1">:</span>
          <span class="s1">schedulerPriority = IdlePriority;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">default</span><span class="s1">:</span>
          <span class="s1">schedulerPriority = NormalPriority;</span>
      <span class="s1">}</span>
      <span class="s1">injectedHook.onCommitFiberRoot(</span>
        <span class="s1">rendererID,</span>
        <span class="s1">root,</span>
        <span class="s1">schedulerPriority,</span>
        <span class="s1">didError</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,</span>
  <span class="s1">log = Math.log,</span>
  <span class="s1">LN2 = Math.LN2;</span>
<span class="s3">function </span><span class="s1">clz32Fallback(x) {</span>
  <span class="s1">x &gt;&gt;&gt;= </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s4">0 </span><span class="s1">=== x ? </span><span class="s4">32 </span><span class="s1">: (</span><span class="s4">31 </span><span class="s1">- ((log(x) / LN2) | </span><span class="s4">0</span><span class="s1">)) | </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">nextTransitionLane = </span><span class="s4">64</span><span class="s1">,</span>
  <span class="s1">nextRetryLane = </span><span class="s4">4194304</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">getHighestPriorityLanes(lanes) {</span>
  <span class="s3">switch </span><span class="s1">(lanes &amp; -lanes) {</span>
    <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">2</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s4">2</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s4">4</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">8</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s4">8</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">16</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s4">16</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">32</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s4">32</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">64</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">128</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">256</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">512</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">1024</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">2048</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">4096</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">8192</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">16384</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">32768</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">65536</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">131072</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">262144</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">524288</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">1048576</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">2097152</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">lanes &amp; </span><span class="s4">4194240</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">4194304</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">8388608</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">16777216</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">33554432</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">67108864</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">lanes &amp; </span><span class="s4">130023424</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">134217728</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s4">134217728</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">268435456</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s4">268435456</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">536870912</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s4">536870912</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">1073741824</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s4">1073741824</span><span class="s1">;</span>
    <span class="s3">default</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">lanes;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getNextLanes(root, wipLanes) {</span>
  <span class="s3">var </span><span class="s1">pendingLanes = root.pendingLanes;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== pendingLanes) </span><span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">nextLanes = </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">suspendedLanes = root.suspendedLanes,</span>
    <span class="s1">pingedLanes = root.pingedLanes,</span>
    <span class="s1">nonIdlePendingLanes = pendingLanes &amp; </span><span class="s4">268435455</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== nonIdlePendingLanes) {</span>
    <span class="s3">var </span><span class="s1">nonIdleUnblockedLanes = nonIdlePendingLanes &amp; ~suspendedLanes;</span>
    <span class="s4">0 </span><span class="s1">!== nonIdleUnblockedLanes</span>
      <span class="s1">? (nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes))</span>
      <span class="s1">: ((pingedLanes &amp;= nonIdlePendingLanes),</span>
        <span class="s4">0 </span><span class="s1">!== pingedLanes &amp;&amp;</span>
          <span class="s1">(nextLanes = getHighestPriorityLanes(pingedLanes)));</span>
  <span class="s1">} </span><span class="s3">else</span>
    <span class="s1">(nonIdlePendingLanes = pendingLanes &amp; ~suspendedLanes),</span>
      <span class="s4">0 </span><span class="s1">!== nonIdlePendingLanes</span>
        <span class="s1">? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))</span>
        <span class="s1">: </span><span class="s4">0 </span><span class="s1">!== pingedLanes &amp;&amp;</span>
          <span class="s1">(nextLanes = getHighestPriorityLanes(pingedLanes));</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== nextLanes) </span><span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s4">0 </span><span class="s1">!== wipLanes &amp;&amp;</span>
    <span class="s1">wipLanes !== nextLanes &amp;&amp;</span>
    <span class="s4">0 </span><span class="s1">=== (wipLanes &amp; suspendedLanes) &amp;&amp;</span>
    <span class="s1">((suspendedLanes = nextLanes &amp; -nextLanes),</span>
    <span class="s1">(pingedLanes = wipLanes &amp; -wipLanes),</span>
    <span class="s1">suspendedLanes &gt;= pingedLanes ||</span>
      <span class="s1">(</span><span class="s4">16 </span><span class="s1">=== suspendedLanes &amp;&amp; </span><span class="s4">0 </span><span class="s1">!== (pingedLanes &amp; </span><span class="s4">4194240</span><span class="s1">)))</span>
  <span class="s1">)</span>
    <span class="s3">return </span><span class="s1">wipLanes;</span>
  <span class="s4">0 </span><span class="s1">!== (nextLanes &amp; </span><span class="s4">4</span><span class="s1">) &amp;&amp; (nextLanes |= pendingLanes &amp; </span><span class="s4">16</span><span class="s1">);</span>
  <span class="s1">wipLanes = root.entangledLanes;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== wipLanes)</span>
    <span class="s3">for </span><span class="s1">(root = root.entanglements, wipLanes &amp;= nextLanes; </span><span class="s4">0 </span><span class="s1">&lt; wipLanes; )</span>
      <span class="s1">(pendingLanes = </span><span class="s4">31 </span><span class="s1">- clz32(wipLanes)),</span>
        <span class="s1">(suspendedLanes = </span><span class="s4">1 </span><span class="s1">&lt;&lt; pendingLanes),</span>
        <span class="s1">(nextLanes |= root[pendingLanes]),</span>
        <span class="s1">(wipLanes &amp;= ~suspendedLanes);</span>
  <span class="s3">return </span><span class="s1">nextLanes;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">computeExpirationTime(lane, currentTime) {</span>
  <span class="s3">switch </span><span class="s1">(lane) {</span>
    <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">2</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">currentTime + </span><span class="s4">250</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">8</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">16</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">32</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">64</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">128</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">256</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">512</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">1024</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">2048</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">4096</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">8192</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">16384</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">32768</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">65536</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">131072</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">262144</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">524288</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">1048576</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">2097152</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">currentTime + </span><span class="s4">5</span><span class="s1">e3;</span>
    <span class="s3">case </span><span class="s4">4194304</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">8388608</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">16777216</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">33554432</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">67108864</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">134217728</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">268435456</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">536870912</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">1073741824</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">default</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getLanesToRetrySynchronouslyOnError(root) {</span>
  <span class="s1">root = root.pendingLanes &amp; -</span><span class="s4">1073741825</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s4">0 </span><span class="s1">!== root ? root : root &amp; </span><span class="s4">1073741824 </span><span class="s1">? </span><span class="s4">1073741824 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">claimNextTransitionLane() {</span>
  <span class="s3">var </span><span class="s1">lane = nextTransitionLane;</span>
  <span class="s1">nextTransitionLane &lt;&lt;= </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s4">0 </span><span class="s1">=== (nextTransitionLane &amp; </span><span class="s4">4194240</span><span class="s1">) &amp;&amp; (nextTransitionLane = </span><span class="s4">64</span><span class="s1">);</span>
  <span class="s3">return </span><span class="s1">lane;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createLaneMap(initial) {</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">laneMap = [], i = </span><span class="s4">0</span><span class="s1">; </span><span class="s4">31 </span><span class="s1">&gt; i; i++) laneMap.push(initial);</span>
  <span class="s3">return </span><span class="s1">laneMap;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">markRootUpdated(root, updateLane, eventTime) {</span>
  <span class="s1">root.pendingLanes |= updateLane;</span>
  <span class="s4">536870912 </span><span class="s1">!== updateLane &amp;&amp;</span>
    <span class="s1">((root.suspendedLanes = </span><span class="s4">0</span><span class="s1">), (root.pingedLanes = </span><span class="s4">0</span><span class="s1">));</span>
  <span class="s1">root = root.eventTimes;</span>
  <span class="s1">updateLane = </span><span class="s4">31 </span><span class="s1">- clz32(updateLane);</span>
  <span class="s1">root[updateLane] = eventTime;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">markRootFinished(root, remainingLanes) {</span>
  <span class="s3">var </span><span class="s1">noLongerPendingLanes = root.pendingLanes &amp; ~remainingLanes;</span>
  <span class="s1">root.pendingLanes = remainingLanes;</span>
  <span class="s1">root.suspendedLanes = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">root.pingedLanes = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">root.expiredLanes &amp;= remainingLanes;</span>
  <span class="s1">root.mutableReadLanes &amp;= remainingLanes;</span>
  <span class="s1">root.entangledLanes &amp;= remainingLanes;</span>
  <span class="s1">remainingLanes = root.entanglements;</span>
  <span class="s3">var </span><span class="s1">eventTimes = root.eventTimes;</span>
  <span class="s3">for </span><span class="s1">(root = root.expirationTimes; </span><span class="s4">0 </span><span class="s1">&lt; noLongerPendingLanes; ) {</span>
    <span class="s3">var </span><span class="s1">index$8 = </span><span class="s4">31 </span><span class="s1">- clz32(noLongerPendingLanes),</span>
      <span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index$8;</span>
    <span class="s1">remainingLanes[index$8] = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">eventTimes[index$8] = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">root[index$8] = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">noLongerPendingLanes &amp;= ~lane;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">markRootEntangled(root, entangledLanes) {</span>
  <span class="s3">var </span><span class="s1">rootEntangledLanes = (root.entangledLanes |= entangledLanes);</span>
  <span class="s3">for </span><span class="s1">(root = root.entanglements; rootEntangledLanes; ) {</span>
    <span class="s3">var </span><span class="s1">index$9 = </span><span class="s4">31 </span><span class="s1">- clz32(rootEntangledLanes),</span>
      <span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index$9;</span>
    <span class="s1">(lane &amp; entangledLanes) | (root[index$9] &amp; entangledLanes) &amp;&amp;</span>
      <span class="s1">(root[index$9] |= entangledLanes);</span>
    <span class="s1">rootEntangledLanes &amp;= ~lane;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">addFiberToLanesMap(root, fiber, lanes) {</span>
  <span class="s3">if </span><span class="s1">(isDevToolsPresent)</span>
    <span class="s3">for </span><span class="s1">(root = root.pendingUpdatersLaneMap; </span><span class="s4">0 </span><span class="s1">&lt; lanes; ) {</span>
      <span class="s3">var </span><span class="s1">index$10 = </span><span class="s4">31 </span><span class="s1">- clz32(lanes),</span>
        <span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index$10;</span>
      <span class="s1">root[index$10].add(fiber);</span>
      <span class="s1">lanes &amp;= ~lane;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">movePendingFibersToMemoized(root, lanes) {</span>
  <span class="s3">if </span><span class="s1">(isDevToolsPresent)</span>
    <span class="s3">for </span><span class="s1">(</span>
      <span class="s3">var </span><span class="s1">pendingUpdatersLaneMap = root.pendingUpdatersLaneMap,</span>
        <span class="s1">memoizedUpdaters = root.memoizedUpdaters;</span>
      <span class="s4">0 </span><span class="s1">&lt; lanes;</span>

    <span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">index$11 = </span><span class="s4">31 </span><span class="s1">- clz32(lanes);</span>
      <span class="s1">root = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index$11;</span>
      <span class="s1">index$11 = pendingUpdatersLaneMap[index$11];</span>
      <span class="s4">0 </span><span class="s1">&lt; index$11.size &amp;&amp;</span>
        <span class="s1">(index$11.forEach(</span><span class="s3">function</span><span class="s1">(fiber) {</span>
          <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>
          <span class="s1">(</span><span class="s3">null </span><span class="s1">!== alternate &amp;&amp; memoizedUpdaters.has(alternate)) ||</span>
            <span class="s1">memoizedUpdaters.add(fiber);</span>
        <span class="s1">}),</span>
        <span class="s1">index$11.clear());</span>
      <span class="s1">lanes &amp;= ~root;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">currentUpdatePriority = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">lanesToEventPriority(lanes) {</span>
  <span class="s1">lanes &amp;= -lanes;</span>
  <span class="s3">return </span><span class="s4">1 </span><span class="s1">&lt; lanes</span>
    <span class="s1">? </span><span class="s4">4 </span><span class="s1">&lt; lanes</span>
      <span class="s1">? </span><span class="s4">0 </span><span class="s1">!== (lanes &amp; </span><span class="s4">268435455</span><span class="s1">)</span>
        <span class="s1">? </span><span class="s4">16</span>
        <span class="s1">: </span><span class="s4">536870912</span>
      <span class="s1">: </span><span class="s4">4</span>
    <span class="s1">: </span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">shim() {</span>
  <span class="s3">throw </span><span class="s1">Error(</span>
    <span class="s2">&quot;The current renderer does not support hydration. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">getViewConfigForType =</span>
    <span class="s1">ReactNativePrivateInterface.ReactNativeViewConfigRegistry.get,</span>
  <span class="s1">UPDATE_SIGNAL = {},</span>
  <span class="s1">nextReactTag = </span><span class="s4">3</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">allocateTag() {</span>
  <span class="s3">var </span><span class="s1">tag = nextReactTag;</span>
  <span class="s4">1 </span><span class="s1">=== tag % </span><span class="s4">10 </span><span class="s1">&amp;&amp; (tag += </span><span class="s4">2</span><span class="s1">);</span>
  <span class="s1">nextReactTag = tag + </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">tag;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">recursivelyUncacheFiberNode(node) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;number&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">node)</span>
    <span class="s1">instanceCache.</span><span class="s3">delete</span><span class="s1">(node), instanceProps.</span><span class="s3">delete</span><span class="s1">(node);</span>
  <span class="s3">else </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">tag = node._nativeTag;</span>
    <span class="s1">instanceCache.</span><span class="s3">delete</span><span class="s1">(tag);</span>
    <span class="s1">instanceProps.</span><span class="s3">delete</span><span class="s1">(tag);</span>
    <span class="s1">node._children.forEach(recursivelyUncacheFiberNode);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">finalizeInitialChildren(parentInstance) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== parentInstance._children.length) </span><span class="s3">return </span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">nativeTags = parentInstance._children.map(</span><span class="s3">function</span><span class="s1">(child) {</span>
    <span class="s3">return </span><span class="s2">&quot;number&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">child ? child : child._nativeTag;</span>
  <span class="s1">});</span>
  <span class="s1">ReactNativePrivateInterface.UIManager.setChildren(</span>
    <span class="s1">parentInstance._nativeTag,</span>
    <span class="s1">nativeTags</span>
  <span class="s1">);</span>
  <span class="s3">return </span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">scheduleTimeout = setTimeout,</span>
  <span class="s1">cancelTimeout = clearTimeout;</span>
<span class="s3">function </span><span class="s1">describeComponentFrame(name, source, ownerName) {</span>
  <span class="s1">source = </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
  <span class="s1">ownerName &amp;&amp; (source = </span><span class="s2">&quot; (created by &quot; </span><span class="s1">+ ownerName + </span><span class="s2">&quot;)&quot;</span><span class="s1">);</span>
  <span class="s3">return </span><span class="s2">&quot;</span><span class="s5">\n    </span><span class="s2">in &quot; </span><span class="s1">+ (name || </span><span class="s2">&quot;Unknown&quot;</span><span class="s1">) + source;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">describeFunctionComponentFrame(fn, source) {</span>
  <span class="s3">return </span><span class="s1">fn</span>
    <span class="s1">? describeComponentFrame(fn.displayName || fn.name || </span><span class="s3">null</span><span class="s1">, source, </span><span class="s3">null</span><span class="s1">)</span>
    <span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">hasOwnProperty = Object.prototype.hasOwnProperty,</span>
  <span class="s1">valueStack = [],</span>
  <span class="s1">index = -</span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">createCursor(defaultValue) {</span>
  <span class="s3">return </span><span class="s1">{ current: defaultValue };</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pop(cursor) {</span>
  <span class="s4">0 </span><span class="s1">&gt; index ||</span>
    <span class="s1">((cursor.current = valueStack[index]), (valueStack[index] = </span><span class="s3">null</span><span class="s1">), index--);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">push(cursor, value) {</span>
  <span class="s1">index++;</span>
  <span class="s1">valueStack[index] = cursor.current;</span>
  <span class="s1">cursor.current = value;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">emptyContextObject = {},</span>
  <span class="s1">contextStackCursor = createCursor(emptyContextObject),</span>
  <span class="s1">didPerformWorkStackCursor = createCursor(!</span><span class="s4">1</span><span class="s1">),</span>
  <span class="s1">previousContext = emptyContextObject;</span>
<span class="s3">function </span><span class="s1">getMaskedContext(workInProgress, unmaskedContext) {</span>
  <span class="s3">var </span><span class="s1">contextTypes = workInProgress.type.contextTypes;</span>
  <span class="s3">if </span><span class="s1">(!contextTypes) </span><span class="s3">return </span><span class="s1">emptyContextObject;</span>
  <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">instance &amp;&amp;</span>
    <span class="s1">instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext</span>
  <span class="s1">)</span>
    <span class="s3">return </span><span class="s1">instance.__reactInternalMemoizedMaskedChildContext;</span>
  <span class="s3">var </span><span class="s1">context = {},</span>
    <span class="s1">key;</span>
  <span class="s3">for </span><span class="s1">(key </span><span class="s3">in </span><span class="s1">contextTypes) context[key] = unmaskedContext[key];</span>
  <span class="s1">instance &amp;&amp;</span>
    <span class="s1">((workInProgress = workInProgress.stateNode),</span>
    <span class="s1">(workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext),</span>
    <span class="s1">(workInProgress.__reactInternalMemoizedMaskedChildContext = context));</span>
  <span class="s3">return </span><span class="s1">context;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isContextProvider(type) {</span>
  <span class="s1">type = type.childContextTypes;</span>
  <span class="s3">return null </span><span class="s1">!== type &amp;&amp; </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">!== type;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">popContext() {</span>
  <span class="s1">pop(didPerformWorkStackCursor);</span>
  <span class="s1">pop(contextStackCursor);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pushTopLevelContextObject(fiber, context, didChange) {</span>
  <span class="s3">if </span><span class="s1">(contextStackCursor.current !== emptyContextObject)</span>
    <span class="s3">throw </span><span class="s1">Error(</span>
      <span class="s2">&quot;Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">push(contextStackCursor, context);</span>
  <span class="s1">push(didPerformWorkStackCursor, didChange);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">processChildContext(fiber, type, parentContext) {</span>
  <span class="s3">var </span><span class="s1">instance = fiber.stateNode;</span>
  <span class="s1">type = type.childContextTypes;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">instance.getChildContext) </span><span class="s3">return </span><span class="s1">parentContext;</span>
  <span class="s1">instance = instance.getChildContext();</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">contextKey </span><span class="s3">in </span><span class="s1">instance)</span>
    <span class="s3">if </span><span class="s1">(!(contextKey </span><span class="s3">in </span><span class="s1">type))</span>
      <span class="s3">throw </span><span class="s1">Error(</span>
        <span class="s1">(getComponentNameFromFiber(fiber) || </span><span class="s2">&quot;Unknown&quot;</span><span class="s1">) +</span>
          <span class="s2">'.getChildContext(): key &quot;' </span><span class="s1">+</span>
          <span class="s1">contextKey +</span>
          <span class="s2">'&quot; is not defined in childContextTypes.'</span>
      <span class="s1">);</span>
  <span class="s3">return </span><span class="s1">assign({}, parentContext, instance);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pushContextProvider(workInProgress) {</span>
  <span class="s1">workInProgress =</span>
    <span class="s1">((workInProgress = workInProgress.stateNode) &amp;&amp;</span>
      <span class="s1">workInProgress.__reactInternalMemoizedMergedChildContext) ||</span>
    <span class="s1">emptyContextObject;</span>
  <span class="s1">previousContext = contextStackCursor.current;</span>
  <span class="s1">push(contextStackCursor, workInProgress);</span>
  <span class="s1">push(didPerformWorkStackCursor, didPerformWorkStackCursor.current);</span>
  <span class="s3">return </span><span class="s1">!</span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">invalidateContextProvider(workInProgress, type, didChange) {</span>
  <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>
  <span class="s3">if </span><span class="s1">(!instance)</span>
    <span class="s3">throw </span><span class="s1">Error(</span>
      <span class="s2">&quot;Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">didChange</span>
    <span class="s1">? ((workInProgress = processChildContext(</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">type,</span>
        <span class="s1">previousContext</span>
      <span class="s1">)),</span>
      <span class="s1">(instance.__reactInternalMemoizedMergedChildContext = workInProgress),</span>
      <span class="s1">pop(didPerformWorkStackCursor),</span>
      <span class="s1">pop(contextStackCursor),</span>
      <span class="s1">push(contextStackCursor, workInProgress))</span>
    <span class="s1">: pop(didPerformWorkStackCursor);</span>
  <span class="s1">push(didPerformWorkStackCursor, didChange);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">is(x, y) {</span>
  <span class="s3">return </span><span class="s1">(x === y &amp;&amp; (</span><span class="s4">0 </span><span class="s1">!== x || </span><span class="s4">1 </span><span class="s1">/ x === </span><span class="s4">1 </span><span class="s1">/ y)) || (x !== x &amp;&amp; y !== y);</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">objectIs = </span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">Object.is ? Object.is : is,</span>
  <span class="s1">syncQueue = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">includesLegacySyncCallbacks = !</span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">isFlushingSyncQueue = !</span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">flushSyncCallbacks() {</span>
  <span class="s3">if </span><span class="s1">(!isFlushingSyncQueue &amp;&amp; </span><span class="s3">null </span><span class="s1">!== syncQueue) {</span>
    <span class="s1">isFlushingSyncQueue = !</span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">previousUpdatePriority = currentUpdatePriority;</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">queue = syncQueue;</span>
      <span class="s3">for </span><span class="s1">(currentUpdatePriority = </span><span class="s4">1</span><span class="s1">; i &lt; queue.length; i++) {</span>
        <span class="s3">var </span><span class="s1">callback = queue[i];</span>
        <span class="s3">do </span><span class="s1">callback = callback(!</span><span class="s4">0</span><span class="s1">);</span>
        <span class="s3">while </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== callback);</span>
      <span class="s1">}</span>
      <span class="s1">syncQueue = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">includesLegacySyncCallbacks = !</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
      <span class="s3">throw </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== syncQueue &amp;&amp; (syncQueue = syncQueue.slice(i + </span><span class="s4">1</span><span class="s1">)),</span>
      <span class="s1">scheduleCallback(ImmediatePriority, flushSyncCallbacks),</span>
      <span class="s1">error);</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">(currentUpdatePriority = previousUpdatePriority),</span>
        <span class="s1">(isFlushingSyncQueue = !</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">forkStack = [],</span>
  <span class="s1">forkStackIndex = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">treeForkProvider = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">idStack = [],</span>
  <span class="s1">idStackIndex = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">treeContextProvider = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">popTreeContext(workInProgress) {</span>
  <span class="s3">for </span><span class="s1">(; workInProgress === treeForkProvider; )</span>
    <span class="s1">(treeForkProvider = forkStack[--forkStackIndex]),</span>
      <span class="s1">(forkStack[forkStackIndex] = </span><span class="s3">null</span><span class="s1">),</span>
      <span class="s1">--forkStackIndex,</span>
      <span class="s1">(forkStack[forkStackIndex] = </span><span class="s3">null</span><span class="s1">);</span>
  <span class="s3">for </span><span class="s1">(; workInProgress === treeContextProvider; )</span>
    <span class="s1">(treeContextProvider = idStack[--idStackIndex]),</span>
      <span class="s1">(idStack[idStackIndex] = </span><span class="s3">null</span><span class="s1">),</span>
      <span class="s1">--idStackIndex,</span>
      <span class="s1">(idStack[idStackIndex] = </span><span class="s3">null</span><span class="s1">),</span>
      <span class="s1">--idStackIndex,</span>
      <span class="s1">(idStack[idStackIndex] = </span><span class="s3">null</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">hydrationErrors = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;</span>
<span class="s3">function </span><span class="s1">shallowEqual(objA, objB) {</span>
  <span class="s3">if </span><span class="s1">(objectIs(objA, objB)) </span><span class="s3">return </span><span class="s1">!</span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s2">&quot;object&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">objA ||</span>
    <span class="s3">null </span><span class="s1">=== objA ||</span>
    <span class="s2">&quot;object&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">objB ||</span>
    <span class="s3">null </span><span class="s1">=== objB</span>
  <span class="s1">)</span>
    <span class="s3">return </span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">keysA = Object.keys(objA),</span>
    <span class="s1">keysB = Object.keys(objB);</span>
  <span class="s3">if </span><span class="s1">(keysA.length !== keysB.length) </span><span class="s3">return </span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">for </span><span class="s1">(keysB = </span><span class="s4">0</span><span class="s1">; keysB &lt; keysA.length; keysB++) {</span>
    <span class="s3">var </span><span class="s1">currentKey = keysA[keysB];</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">!hasOwnProperty.call(objB, currentKey) ||</span>
      <span class="s1">!objectIs(objA[currentKey], objB[currentKey])</span>
    <span class="s1">)</span>
      <span class="s3">return </span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">!</span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">describeFiber(fiber) {</span>
  <span class="s3">switch </span><span class="s1">(fiber.tag) {</span>
    <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">describeComponentFrame(fiber.type, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s3">case </span><span class="s4">16</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">describeComponentFrame(</span><span class="s2">&quot;Lazy&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s3">case </span><span class="s4">13</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">describeComponentFrame(</span><span class="s2">&quot;Suspense&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s3">case </span><span class="s4">19</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">describeComponentFrame(</span><span class="s2">&quot;SuspenseList&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">2</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">15</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">describeFunctionComponentFrame(fiber.type, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s3">case </span><span class="s4">11</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">describeFunctionComponentFrame(fiber.type.render, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(fiber = describeFunctionComponentFrame(fiber.type, </span><span class="s3">null</span><span class="s1">)), fiber;</span>
    <span class="s3">default</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getStackByFiberInDevAndProd(workInProgress) {</span>
  <span class="s3">try </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">info = </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
    <span class="s3">do</span>
      <span class="s1">(info += describeFiber(workInProgress)),</span>
        <span class="s1">(workInProgress = workInProgress.</span><span class="s3">return</span><span class="s1">);</span>
    <span class="s3">while </span><span class="s1">(workInProgress);</span>
    <span class="s3">return </span><span class="s1">info;</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {</span>
    <span class="s3">return </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">Error generating stack: &quot; </span><span class="s1">+ x.message + </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+ x.stack;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">resolveDefaultProps(Component, baseProps) {</span>
  <span class="s3">if </span><span class="s1">(Component &amp;&amp; Component.defaultProps) {</span>
    <span class="s1">baseProps = assign({}, baseProps);</span>
    <span class="s1">Component = Component.defaultProps;</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">propName </span><span class="s3">in </span><span class="s1">Component)</span>
      <span class="s3">void </span><span class="s4">0 </span><span class="s1">=== baseProps[propName] &amp;&amp;</span>
        <span class="s1">(baseProps[propName] = Component[propName]);</span>
    <span class="s3">return </span><span class="s1">baseProps;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">baseProps;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">valueCursor = createCursor(</span><span class="s3">null</span><span class="s1">),</span>
  <span class="s1">currentlyRenderingFiber = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">lastContextDependency = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">lastFullyObservedContext = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">resetContextDependencies() {</span>
  <span class="s1">lastFullyObservedContext = lastContextDependency = currentlyRenderingFiber = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">popProvider(context) {</span>
  <span class="s3">var </span><span class="s1">currentValue = valueCursor.current;</span>
  <span class="s1">pop(valueCursor);</span>
  <span class="s1">context._currentValue = currentValue;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {</span>
  <span class="s3">for </span><span class="s1">(; </span><span class="s3">null </span><span class="s1">!== parent; ) {</span>
    <span class="s3">var </span><span class="s1">alternate = parent.alternate;</span>
    <span class="s1">(parent.childLanes &amp; renderLanes) !== renderLanes</span>
      <span class="s1">? ((parent.childLanes |= renderLanes),</span>
        <span class="s3">null </span><span class="s1">!== alternate &amp;&amp; (alternate.childLanes |= renderLanes))</span>
      <span class="s1">: </span><span class="s3">null </span><span class="s1">!== alternate &amp;&amp;</span>
        <span class="s1">(alternate.childLanes &amp; renderLanes) !== renderLanes &amp;&amp;</span>
        <span class="s1">(alternate.childLanes |= renderLanes);</span>
    <span class="s3">if </span><span class="s1">(parent === propagationRoot) </span><span class="s3">break</span><span class="s1">;</span>
    <span class="s1">parent = parent.</span><span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">prepareToReadContext(workInProgress, renderLanes) {</span>
  <span class="s1">currentlyRenderingFiber = workInProgress;</span>
  <span class="s1">lastFullyObservedContext = lastContextDependency = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">workInProgress = workInProgress.dependencies;</span>
  <span class="s3">null </span><span class="s1">!== workInProgress &amp;&amp;</span>
    <span class="s3">null </span><span class="s1">!== workInProgress.firstContext &amp;&amp;</span>
    <span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (workInProgress.lanes &amp; renderLanes) &amp;&amp; (didReceiveUpdate = !</span><span class="s4">0</span><span class="s1">),</span>
    <span class="s1">(workInProgress.firstContext = </span><span class="s3">null</span><span class="s1">));</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">readContext(context) {</span>
  <span class="s3">var </span><span class="s1">value = context._currentValue;</span>
  <span class="s3">if </span><span class="s1">(lastFullyObservedContext !== context)</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">((context = { context: context, memoizedValue: value, next: </span><span class="s3">null </span><span class="s1">}),</span>
      <span class="s3">null </span><span class="s1">=== lastContextDependency)</span>
    <span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== currentlyRenderingFiber)</span>
        <span class="s3">throw </span><span class="s1">Error(</span>
          <span class="s2">&quot;Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().&quot;</span>
        <span class="s1">);</span>
      <span class="s1">lastContextDependency = context;</span>
      <span class="s1">currentlyRenderingFiber.dependencies = {</span>
        <span class="s1">lanes: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">firstContext: context</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">lastContextDependency = lastContextDependency.next = context;</span>
  <span class="s3">return </span><span class="s1">value;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">concurrentQueues = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">pushConcurrentUpdateQueue(queue) {</span>
  <span class="s3">null </span><span class="s1">=== concurrentQueues</span>
    <span class="s1">? (concurrentQueues = [queue])</span>
    <span class="s1">: concurrentQueues.push(queue);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">enqueueConcurrentHookUpdate(fiber, queue, update, lane) {</span>
  <span class="s3">var </span><span class="s1">interleaved = queue.interleaved;</span>
  <span class="s3">null </span><span class="s1">=== interleaved</span>
    <span class="s1">? ((update.next = update), pushConcurrentUpdateQueue(queue))</span>
    <span class="s1">: ((update.next = interleaved.next), (interleaved.next = update));</span>
  <span class="s1">queue.interleaved = update;</span>
  <span class="s3">return </span><span class="s1">markUpdateLaneFromFiberToRoot(fiber, lane);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">markUpdateLaneFromFiberToRoot(sourceFiber, lane) {</span>
  <span class="s1">sourceFiber.lanes |= lane;</span>
  <span class="s3">var </span><span class="s1">alternate = sourceFiber.alternate;</span>
  <span class="s3">null </span><span class="s1">!== alternate &amp;&amp; (alternate.lanes |= lane);</span>
  <span class="s1">alternate = sourceFiber;</span>
  <span class="s3">for </span><span class="s1">(sourceFiber = sourceFiber.</span><span class="s3">return</span><span class="s1">; </span><span class="s3">null </span><span class="s1">!== sourceFiber; )</span>
    <span class="s1">(sourceFiber.childLanes |= lane),</span>
      <span class="s1">(alternate = sourceFiber.alternate),</span>
      <span class="s3">null </span><span class="s1">!== alternate &amp;&amp; (alternate.childLanes |= lane),</span>
      <span class="s1">(alternate = sourceFiber),</span>
      <span class="s1">(sourceFiber = sourceFiber.</span><span class="s3">return</span><span class="s1">);</span>
  <span class="s3">return </span><span class="s4">3 </span><span class="s1">=== alternate.tag ? alternate.stateNode : </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">hasForceUpdate = !</span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">initializeUpdateQueue(fiber) {</span>
  <span class="s1">fiber.updateQueue = {</span>
    <span class="s1">baseState: fiber.memoizedState,</span>
    <span class="s1">firstBaseUpdate: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">lastBaseUpdate: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">shared: { pending: </span><span class="s3">null</span><span class="s1">, interleaved: </span><span class="s3">null</span><span class="s1">, lanes: </span><span class="s4">0 </span><span class="s1">},</span>
    <span class="s1">effects: </span><span class="s3">null</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">cloneUpdateQueue(current, workInProgress) {</span>
  <span class="s1">current = current.updateQueue;</span>
  <span class="s1">workInProgress.updateQueue === current &amp;&amp;</span>
    <span class="s1">(workInProgress.updateQueue = {</span>
      <span class="s1">baseState: current.baseState,</span>
      <span class="s1">firstBaseUpdate: current.firstBaseUpdate,</span>
      <span class="s1">lastBaseUpdate: current.lastBaseUpdate,</span>
      <span class="s1">shared: current.shared,</span>
      <span class="s1">effects: current.effects</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createUpdate(eventTime, lane) {</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">eventTime: eventTime,</span>
    <span class="s1">lane: lane,</span>
    <span class="s1">tag: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">payload: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">callback: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">next: </span><span class="s3">null</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">enqueueUpdate(fiber, update, lane) {</span>
  <span class="s3">var </span><span class="s1">updateQueue = fiber.updateQueue;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== updateQueue) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">updateQueue = updateQueue.shared;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (executionContext &amp; </span><span class="s4">2</span><span class="s1">)) {</span>
    <span class="s3">var </span><span class="s1">pending = updateQueue.pending;</span>
    <span class="s3">null </span><span class="s1">=== pending</span>
      <span class="s1">? (update.next = update)</span>
      <span class="s1">: ((update.next = pending.next), (pending.next = update));</span>
    <span class="s1">updateQueue.pending = update;</span>
    <span class="s3">return </span><span class="s1">markUpdateLaneFromFiberToRoot(fiber, lane);</span>
  <span class="s1">}</span>
  <span class="s1">pending = updateQueue.interleaved;</span>
  <span class="s3">null </span><span class="s1">=== pending</span>
    <span class="s1">? ((update.next = update), pushConcurrentUpdateQueue(updateQueue))</span>
    <span class="s1">: ((update.next = pending.next), (pending.next = update));</span>
  <span class="s1">updateQueue.interleaved = update;</span>
  <span class="s3">return </span><span class="s1">markUpdateLaneFromFiberToRoot(fiber, lane);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">entangleTransitions(root, fiber, lane) {</span>
  <span class="s1">fiber = fiber.updateQueue;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== fiber &amp;&amp; ((fiber = fiber.shared), </span><span class="s4">0 </span><span class="s1">!== (lane &amp; </span><span class="s4">4194240</span><span class="s1">))) {</span>
    <span class="s3">var </span><span class="s1">queueLanes = fiber.lanes;</span>
    <span class="s1">queueLanes &amp;= root.pendingLanes;</span>
    <span class="s1">lane |= queueLanes;</span>
    <span class="s1">fiber.lanes = lane;</span>
    <span class="s1">markRootEntangled(root, lane);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">enqueueCapturedUpdate(workInProgress, capturedUpdate) {</span>
  <span class="s3">var </span><span class="s1">queue = workInProgress.updateQueue,</span>
    <span class="s1">current = workInProgress.alternate;</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s3">null </span><span class="s1">!== current &amp;&amp;</span>
    <span class="s1">((current = current.updateQueue), queue === current)</span>
  <span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">newFirst = </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">newLast = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">queue = queue.firstBaseUpdate;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== queue) {</span>
      <span class="s3">do </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">clone = {</span>
          <span class="s1">eventTime: queue.eventTime,</span>
          <span class="s1">lane: queue.lane,</span>
          <span class="s1">tag: queue.tag,</span>
          <span class="s1">payload: queue.payload,</span>
          <span class="s1">callback: queue.callback,</span>
          <span class="s1">next: </span><span class="s3">null</span>
        <span class="s1">};</span>
        <span class="s3">null </span><span class="s1">=== newLast</span>
          <span class="s1">? (newFirst = newLast = clone)</span>
          <span class="s1">: (newLast = newLast.next = clone);</span>
        <span class="s1">queue = queue.next;</span>
      <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== queue);</span>
      <span class="s3">null </span><span class="s1">=== newLast</span>
        <span class="s1">? (newFirst = newLast = capturedUpdate)</span>
        <span class="s1">: (newLast = newLast.next = capturedUpdate);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">newFirst = newLast = capturedUpdate;</span>
    <span class="s1">queue = {</span>
      <span class="s1">baseState: current.baseState,</span>
      <span class="s1">firstBaseUpdate: newFirst,</span>
      <span class="s1">lastBaseUpdate: newLast,</span>
      <span class="s1">shared: current.shared,</span>
      <span class="s1">effects: current.effects</span>
    <span class="s1">};</span>
    <span class="s1">workInProgress.updateQueue = queue;</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">workInProgress = queue.lastBaseUpdate;</span>
  <span class="s3">null </span><span class="s1">=== workInProgress</span>
    <span class="s1">? (queue.firstBaseUpdate = capturedUpdate)</span>
    <span class="s1">: (workInProgress.next = capturedUpdate);</span>
  <span class="s1">queue.lastBaseUpdate = capturedUpdate;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">processUpdateQueue(</span>
  <span class="s1">workInProgress$jscomp$0,</span>
  <span class="s1">props,</span>
  <span class="s1">instance,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">queue = workInProgress$jscomp$0.updateQueue;</span>
  <span class="s1">hasForceUpdate = !</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">firstBaseUpdate = queue.firstBaseUpdate,</span>
    <span class="s1">lastBaseUpdate = queue.lastBaseUpdate,</span>
    <span class="s1">pendingQueue = queue.shared.pending;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== pendingQueue) {</span>
    <span class="s1">queue.shared.pending = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">lastPendingUpdate = pendingQueue,</span>
      <span class="s1">firstPendingUpdate = lastPendingUpdate.next;</span>
    <span class="s1">lastPendingUpdate.next = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">null </span><span class="s1">=== lastBaseUpdate</span>
      <span class="s1">? (firstBaseUpdate = firstPendingUpdate)</span>
      <span class="s1">: (lastBaseUpdate.next = firstPendingUpdate);</span>
    <span class="s1">lastBaseUpdate = lastPendingUpdate;</span>
    <span class="s3">var </span><span class="s1">current = workInProgress$jscomp$0.alternate;</span>
    <span class="s3">null </span><span class="s1">!== current &amp;&amp;</span>
      <span class="s1">((current = current.updateQueue),</span>
      <span class="s1">(pendingQueue = current.lastBaseUpdate),</span>
      <span class="s1">pendingQueue !== lastBaseUpdate &amp;&amp;</span>
        <span class="s1">(</span><span class="s3">null </span><span class="s1">=== pendingQueue</span>
          <span class="s1">? (current.firstBaseUpdate = firstPendingUpdate)</span>
          <span class="s1">: (pendingQueue.next = firstPendingUpdate),</span>
        <span class="s1">(current.lastBaseUpdate = lastPendingUpdate)));</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== firstBaseUpdate) {</span>
    <span class="s3">var </span><span class="s1">newState = queue.baseState;</span>
    <span class="s1">lastBaseUpdate = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">current = firstPendingUpdate = lastPendingUpdate = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">pendingQueue = firstBaseUpdate;</span>
    <span class="s3">do </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">updateLane = pendingQueue.lane,</span>
        <span class="s1">updateEventTime = pendingQueue.eventTime;</span>
      <span class="s3">if </span><span class="s1">((renderLanes &amp; updateLane) === updateLane) {</span>
        <span class="s3">null </span><span class="s1">!== current &amp;&amp;</span>
          <span class="s1">(current = current.next = {</span>
            <span class="s1">eventTime: updateEventTime,</span>
            <span class="s1">lane: </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s1">tag: pendingQueue.tag,</span>
            <span class="s1">payload: pendingQueue.payload,</span>
            <span class="s1">callback: pendingQueue.callback,</span>
            <span class="s1">next: </span><span class="s3">null</span>
          <span class="s1">});</span>
        <span class="s1">a: {</span>
          <span class="s3">var </span><span class="s1">workInProgress = workInProgress$jscomp$0,</span>
            <span class="s1">update = pendingQueue;</span>
          <span class="s1">updateLane = props;</span>
          <span class="s1">updateEventTime = instance;</span>
          <span class="s3">switch </span><span class="s1">(update.tag) {</span>
            <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
              <span class="s1">workInProgress = update.payload;</span>
              <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">workInProgress) {</span>
                <span class="s1">newState = workInProgress.call(</span>
                  <span class="s1">updateEventTime,</span>
                  <span class="s1">newState,</span>
                  <span class="s1">updateLane</span>
                <span class="s1">);</span>
                <span class="s3">break </span><span class="s1">a;</span>
              <span class="s1">}</span>
              <span class="s1">newState = workInProgress;</span>
              <span class="s3">break </span><span class="s1">a;</span>
            <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
              <span class="s1">workInProgress.flags = (workInProgress.flags &amp; -</span><span class="s4">65537</span><span class="s1">) | </span><span class="s4">128</span><span class="s1">;</span>
            <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
              <span class="s1">workInProgress = update.payload;</span>
              <span class="s1">updateLane =</span>
                <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">workInProgress</span>
                  <span class="s1">? workInProgress.call(updateEventTime, newState, updateLane)</span>
                  <span class="s1">: workInProgress;</span>
              <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== updateLane || </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">=== updateLane) </span><span class="s3">break </span><span class="s1">a;</span>
              <span class="s1">newState = assign({}, newState, updateLane);</span>
              <span class="s3">break </span><span class="s1">a;</span>
            <span class="s3">case </span><span class="s4">2</span><span class="s1">:</span>
              <span class="s1">hasForceUpdate = !</span><span class="s4">0</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">null </span><span class="s1">!== pendingQueue.callback &amp;&amp;</span>
          <span class="s4">0 </span><span class="s1">!== pendingQueue.lane &amp;&amp;</span>
          <span class="s1">((workInProgress$jscomp$0.flags |= </span><span class="s4">64</span><span class="s1">),</span>
          <span class="s1">(updateLane = queue.effects),</span>
          <span class="s3">null </span><span class="s1">=== updateLane</span>
            <span class="s1">? (queue.effects = [pendingQueue])</span>
            <span class="s1">: updateLane.push(pendingQueue));</span>
      <span class="s1">} </span><span class="s3">else</span>
        <span class="s1">(updateEventTime = {</span>
          <span class="s1">eventTime: updateEventTime,</span>
          <span class="s1">lane: updateLane,</span>
          <span class="s1">tag: pendingQueue.tag,</span>
          <span class="s1">payload: pendingQueue.payload,</span>
          <span class="s1">callback: pendingQueue.callback,</span>
          <span class="s1">next: </span><span class="s3">null</span>
        <span class="s1">}),</span>
          <span class="s3">null </span><span class="s1">=== current</span>
            <span class="s1">? ((firstPendingUpdate = current = updateEventTime),</span>
              <span class="s1">(lastPendingUpdate = newState))</span>
            <span class="s1">: (current = current.next = updateEventTime),</span>
          <span class="s1">(lastBaseUpdate |= updateLane);</span>
      <span class="s1">pendingQueue = pendingQueue.next;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== pendingQueue)</span>
        <span class="s3">if </span><span class="s1">(((pendingQueue = queue.shared.pending), </span><span class="s3">null </span><span class="s1">=== pendingQueue))</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">else</span>
          <span class="s1">(updateLane = pendingQueue),</span>
            <span class="s1">(pendingQueue = updateLane.next),</span>
            <span class="s1">(updateLane.next = </span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">(queue.lastBaseUpdate = updateLane),</span>
            <span class="s1">(queue.shared.pending = </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s3">null </span><span class="s1">=== current &amp;&amp; (lastPendingUpdate = newState);</span>
    <span class="s1">queue.baseState = lastPendingUpdate;</span>
    <span class="s1">queue.firstBaseUpdate = firstPendingUpdate;</span>
    <span class="s1">queue.lastBaseUpdate = current;</span>
    <span class="s1">props = queue.shared.interleaved;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== props) {</span>
      <span class="s1">queue = props;</span>
      <span class="s3">do </span><span class="s1">(lastBaseUpdate |= queue.lane), (queue = queue.next);</span>
      <span class="s3">while </span><span class="s1">(queue !== props);</span>
    <span class="s1">} </span><span class="s3">else null </span><span class="s1">=== firstBaseUpdate &amp;&amp; (queue.shared.lanes = </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">workInProgressRootSkippedLanes |= lastBaseUpdate;</span>
    <span class="s1">workInProgress$jscomp$0.lanes = lastBaseUpdate;</span>
    <span class="s1">workInProgress$jscomp$0.memoizedState = newState;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">commitUpdateQueue(finishedWork, finishedQueue, instance) {</span>
  <span class="s1">finishedWork = finishedQueue.effects;</span>
  <span class="s1">finishedQueue.effects = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== finishedWork)</span>
    <span class="s3">for </span><span class="s1">(</span>
      <span class="s1">finishedQueue = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">finishedQueue &lt; finishedWork.length;</span>
      <span class="s1">finishedQueue++</span>
    <span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">effect = finishedWork[finishedQueue],</span>
        <span class="s1">callback = effect.callback;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== callback) {</span>
        <span class="s1">effect.callback = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">callback)</span>
          <span class="s3">throw </span><span class="s1">Error(</span>
            <span class="s2">&quot;Invalid argument passed as callback. Expected a function. Instead received: &quot; </span><span class="s1">+</span>
              <span class="s1">callback</span>
          <span class="s1">);</span>
        <span class="s1">callback.call(instance);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">emptyRefsObject = </span><span class="s3">new </span><span class="s1">React.Component().refs;</span>
<span class="s3">function </span><span class="s1">applyDerivedStateFromProps(</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">ctor,</span>
  <span class="s1">getDerivedStateFromProps,</span>
  <span class="s1">nextProps</span>
<span class="s1">) {</span>
  <span class="s1">ctor = workInProgress.memoizedState;</span>
  <span class="s1">getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);</span>
  <span class="s1">getDerivedStateFromProps =</span>
    <span class="s3">null </span><span class="s1">=== getDerivedStateFromProps || </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">=== getDerivedStateFromProps</span>
      <span class="s1">? ctor</span>
      <span class="s1">: assign({}, ctor, getDerivedStateFromProps);</span>
  <span class="s1">workInProgress.memoizedState = getDerivedStateFromProps;</span>
  <span class="s4">0 </span><span class="s1">=== workInProgress.lanes &amp;&amp;</span>
    <span class="s1">(workInProgress.updateQueue.baseState = getDerivedStateFromProps);</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">classComponentUpdater = {</span>
  <span class="s1">isMounted: </span><span class="s3">function</span><span class="s1">(component) {</span>
    <span class="s3">return </span><span class="s1">(component = component._reactInternals)</span>
      <span class="s1">? getNearestMountedFiber(component) === component</span>
      <span class="s1">: !</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">},</span>
  <span class="s1">enqueueSetState: </span><span class="s3">function</span><span class="s1">(inst, payload, callback) {</span>
    <span class="s1">inst = inst._reactInternals;</span>
    <span class="s3">var </span><span class="s1">eventTime = requestEventTime(),</span>
      <span class="s1">lane = requestUpdateLane(inst),</span>
      <span class="s1">update = createUpdate(eventTime, lane);</span>
    <span class="s1">update.payload = payload;</span>
    <span class="s3">void </span><span class="s4">0 </span><span class="s1">!== callback &amp;&amp; </span><span class="s3">null </span><span class="s1">!== callback &amp;&amp; (update.callback = callback);</span>
    <span class="s1">payload = enqueueUpdate(inst, update, lane);</span>
    <span class="s3">null </span><span class="s1">!== payload &amp;&amp;</span>
      <span class="s1">(scheduleUpdateOnFiber(payload, inst, lane, eventTime),</span>
      <span class="s1">entangleTransitions(payload, inst, lane));</span>
  <span class="s1">},</span>
  <span class="s1">enqueueReplaceState: </span><span class="s3">function</span><span class="s1">(inst, payload, callback) {</span>
    <span class="s1">inst = inst._reactInternals;</span>
    <span class="s3">var </span><span class="s1">eventTime = requestEventTime(),</span>
      <span class="s1">lane = requestUpdateLane(inst),</span>
      <span class="s1">update = createUpdate(eventTime, lane);</span>
    <span class="s1">update.tag = </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">update.payload = payload;</span>
    <span class="s3">void </span><span class="s4">0 </span><span class="s1">!== callback &amp;&amp; </span><span class="s3">null </span><span class="s1">!== callback &amp;&amp; (update.callback = callback);</span>
    <span class="s1">payload = enqueueUpdate(inst, update, lane);</span>
    <span class="s3">null </span><span class="s1">!== payload &amp;&amp;</span>
      <span class="s1">(scheduleUpdateOnFiber(payload, inst, lane, eventTime),</span>
      <span class="s1">entangleTransitions(payload, inst, lane));</span>
  <span class="s1">},</span>
  <span class="s1">enqueueForceUpdate: </span><span class="s3">function</span><span class="s1">(inst, callback) {</span>
    <span class="s1">inst = inst._reactInternals;</span>
    <span class="s3">var </span><span class="s1">eventTime = requestEventTime(),</span>
      <span class="s1">lane = requestUpdateLane(inst),</span>
      <span class="s1">update = createUpdate(eventTime, lane);</span>
    <span class="s1">update.tag = </span><span class="s4">2</span><span class="s1">;</span>
    <span class="s3">void </span><span class="s4">0 </span><span class="s1">!== callback &amp;&amp; </span><span class="s3">null </span><span class="s1">!== callback &amp;&amp; (update.callback = callback);</span>
    <span class="s1">callback = enqueueUpdate(inst, update, lane);</span>
    <span class="s3">null </span><span class="s1">!== callback &amp;&amp;</span>
      <span class="s1">(scheduleUpdateOnFiber(callback, inst, lane, eventTime),</span>
      <span class="s1">entangleTransitions(callback, inst, lane));</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s3">function </span><span class="s1">checkShouldComponentUpdate(</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">ctor,</span>
  <span class="s1">oldProps,</span>
  <span class="s1">newProps,</span>
  <span class="s1">oldState,</span>
  <span class="s1">newState,</span>
  <span class="s1">nextContext</span>
<span class="s1">) {</span>
  <span class="s1">workInProgress = workInProgress.stateNode;</span>
  <span class="s3">return </span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">workInProgress.shouldComponentUpdate</span>
    <span class="s1">? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)</span>
    <span class="s1">: ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent</span>
    <span class="s1">? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)</span>
    <span class="s1">: !</span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">constructClassInstance(workInProgress, ctor, props) {</span>
  <span class="s3">var </span><span class="s1">isLegacyContextConsumer = !</span><span class="s4">1</span><span class="s1">,</span>
    <span class="s1">unmaskedContext = emptyContextObject;</span>
  <span class="s3">var </span><span class="s1">context = ctor.contextType;</span>
  <span class="s2">&quot;object&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">context &amp;&amp; </span><span class="s3">null </span><span class="s1">!== context</span>
    <span class="s1">? (context = readContext(context))</span>
    <span class="s1">: ((unmaskedContext = isContextProvider(ctor)</span>
        <span class="s1">? previousContext</span>
        <span class="s1">: contextStackCursor.current),</span>
      <span class="s1">(isLegacyContextConsumer = ctor.contextTypes),</span>
      <span class="s1">(context = (isLegacyContextConsumer =</span>
        <span class="s3">null </span><span class="s1">!== isLegacyContextConsumer &amp;&amp; </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">!== isLegacyContextConsumer)</span>
        <span class="s1">? getMaskedContext(workInProgress, unmaskedContext)</span>
        <span class="s1">: emptyContextObject));</span>
  <span class="s1">ctor = </span><span class="s3">new </span><span class="s1">ctor(props, context);</span>
  <span class="s1">workInProgress.memoizedState =</span>
    <span class="s3">null </span><span class="s1">!== ctor.state &amp;&amp; </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">!== ctor.state ? ctor.state : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">ctor.updater = classComponentUpdater;</span>
  <span class="s1">workInProgress.stateNode = ctor;</span>
  <span class="s1">ctor._reactInternals = workInProgress;</span>
  <span class="s1">isLegacyContextConsumer &amp;&amp;</span>
    <span class="s1">((workInProgress = workInProgress.stateNode),</span>
    <span class="s1">(workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext),</span>
    <span class="s1">(workInProgress.__reactInternalMemoizedMaskedChildContext = context));</span>
  <span class="s3">return </span><span class="s1">ctor;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">callComponentWillReceiveProps(</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">instance,</span>
  <span class="s1">newProps,</span>
  <span class="s1">nextContext</span>
<span class="s1">) {</span>
  <span class="s1">workInProgress = instance.state;</span>
  <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.componentWillReceiveProps &amp;&amp;</span>
    <span class="s1">instance.componentWillReceiveProps(newProps, nextContext);</span>
  <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps &amp;&amp;</span>
    <span class="s1">instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);</span>
  <span class="s1">instance.state !== workInProgress &amp;&amp;</span>
    <span class="s1">classComponentUpdater.enqueueReplaceState(instance, instance.state, </span><span class="s3">null</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">mountClassInstance(workInProgress, ctor, newProps, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>
  <span class="s1">instance.props = newProps;</span>
  <span class="s1">instance.state = workInProgress.memoizedState;</span>
  <span class="s1">instance.refs = emptyRefsObject;</span>
  <span class="s1">initializeUpdateQueue(workInProgress);</span>
  <span class="s3">var </span><span class="s1">contextType = ctor.contextType;</span>
  <span class="s2">&quot;object&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">contextType &amp;&amp; </span><span class="s3">null </span><span class="s1">!== contextType</span>
    <span class="s1">? (instance.context = readContext(contextType))</span>
    <span class="s1">: ((contextType = isContextProvider(ctor)</span>
        <span class="s1">? previousContext</span>
        <span class="s1">: contextStackCursor.current),</span>
      <span class="s1">(instance.context = getMaskedContext(workInProgress, contextType)));</span>
  <span class="s1">instance.state = workInProgress.memoizedState;</span>
  <span class="s1">contextType = ctor.getDerivedStateFromProps;</span>
  <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">contextType &amp;&amp;</span>
    <span class="s1">(applyDerivedStateFromProps(workInProgress, ctor, contextType, newProps),</span>
    <span class="s1">(instance.state = workInProgress.memoizedState));</span>
  <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">ctor.getDerivedStateFromProps ||</span>
    <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate ||</span>
    <span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillMount &amp;&amp;</span>
      <span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">instance.componentWillMount) ||</span>
    <span class="s1">((ctor = instance.state),</span>
    <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.componentWillMount &amp;&amp;</span>
      <span class="s1">instance.componentWillMount(),</span>
    <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillMount &amp;&amp;</span>
      <span class="s1">instance.UNSAFE_componentWillMount(),</span>
    <span class="s1">ctor !== instance.state &amp;&amp;</span>
      <span class="s1">classComponentUpdater.enqueueReplaceState(instance, instance.state, </span><span class="s3">null</span><span class="s1">),</span>
    <span class="s1">processUpdateQueue(workInProgress, newProps, instance, renderLanes),</span>
    <span class="s1">(instance.state = workInProgress.memoizedState));</span>
  <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.componentDidMount &amp;&amp;</span>
    <span class="s1">(workInProgress.flags |= </span><span class="s4">4</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">coerceRef(returnFiber, current, element) {</span>
  <span class="s1">returnFiber = element.ref;</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s3">null </span><span class="s1">!== returnFiber &amp;&amp;</span>
    <span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">returnFiber &amp;&amp;</span>
    <span class="s2">&quot;object&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">returnFiber</span>
  <span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(element._owner) {</span>
      <span class="s1">element = element._owner;</span>
      <span class="s3">if </span><span class="s1">(element) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">!== element.tag)</span>
          <span class="s3">throw </span><span class="s1">Error(</span>
            <span class="s2">&quot;Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref&quot;</span>
          <span class="s1">);</span>
        <span class="s3">var </span><span class="s1">inst = element.stateNode;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(!inst)</span>
        <span class="s3">throw </span><span class="s1">Error(</span>
          <span class="s2">&quot;Missing owner for string ref &quot; </span><span class="s1">+</span>
            <span class="s1">returnFiber +</span>
            <span class="s2">&quot;. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
        <span class="s1">);</span>
      <span class="s3">var </span><span class="s1">resolvedInst = inst,</span>
        <span class="s1">stringRef = </span><span class="s2">&quot;&quot; </span><span class="s1">+ returnFiber;</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s3">null </span><span class="s1">!== current &amp;&amp;</span>
        <span class="s3">null </span><span class="s1">!== current.ref &amp;&amp;</span>
        <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">current.ref &amp;&amp;</span>
        <span class="s1">current.ref._stringRef === stringRef</span>
      <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">current.ref;</span>
      <span class="s1">current = </span><span class="s3">function</span><span class="s1">(value) {</span>
        <span class="s3">var </span><span class="s1">refs = resolvedInst.refs;</span>
        <span class="s1">refs === emptyRefsObject &amp;&amp; (refs = resolvedInst.refs = {});</span>
        <span class="s3">null </span><span class="s1">=== value ? </span><span class="s3">delete </span><span class="s1">refs[stringRef] : (refs[stringRef] = value);</span>
      <span class="s1">};</span>
      <span class="s1">current._stringRef = stringRef;</span>
      <span class="s3">return </span><span class="s1">current;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;string&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">returnFiber)</span>
      <span class="s3">throw </span><span class="s1">Error(</span>
        <span class="s2">&quot;Expected ref to be a function, a string, an object returned by React.createRef(), or null.&quot;</span>
      <span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(!element._owner)</span>
      <span class="s3">throw </span><span class="s1">Error(</span>
        <span class="s2">&quot;Element ref was specified as a string (&quot; </span><span class="s1">+</span>
          <span class="s1">returnFiber +</span>
          <span class="s2">&quot;) but no owner was set. This could happen for one of the following reasons:</span><span class="s5">\n</span><span class="s2">1. You may be adding a ref to a function component</span><span class="s5">\n</span><span class="s2">2. You may be adding a ref to a component that was not created inside a component's render method</span><span class="s5">\n</span><span class="s2">3. You have multiple copies of React loaded</span><span class="s5">\n</span><span class="s2">See https://reactjs.org/link/refs-must-have-owner for more information.&quot;</span>
      <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">returnFiber;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">throwOnInvalidObjectType(returnFiber, newChild) {</span>
  <span class="s1">returnFiber = Object.prototype.toString.call(newChild);</span>
  <span class="s3">throw </span><span class="s1">Error(</span>
    <span class="s2">&quot;Objects are not valid as a React child (found: &quot; </span><span class="s1">+</span>
      <span class="s1">(</span><span class="s2">&quot;[object Object]&quot; </span><span class="s1">=== returnFiber</span>
        <span class="s1">? </span><span class="s2">&quot;object with keys {&quot; </span><span class="s1">+ Object.keys(newChild).join(</span><span class="s2">&quot;, &quot;</span><span class="s1">) + </span><span class="s2">&quot;}&quot;</span>
        <span class="s1">: returnFiber) +</span>
      <span class="s2">&quot;). If you meant to render a collection of children, use an array instead.&quot;</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">resolveLazy(lazyType) {</span>
  <span class="s3">var </span><span class="s1">init = lazyType._init;</span>
  <span class="s3">return </span><span class="s1">init(lazyType._payload);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">ChildReconciler(shouldTrackSideEffects) {</span>
  <span class="s3">function </span><span class="s1">deleteChild(returnFiber, childToDelete) {</span>
    <span class="s3">if </span><span class="s1">(shouldTrackSideEffects) {</span>
      <span class="s3">var </span><span class="s1">deletions = returnFiber.deletions;</span>
      <span class="s3">null </span><span class="s1">=== deletions</span>
        <span class="s1">? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= </span><span class="s4">16</span><span class="s1">))</span>
        <span class="s1">: deletions.push(childToDelete);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">deleteRemainingChildren(returnFiber, currentFirstChild) {</span>
    <span class="s3">if </span><span class="s1">(!shouldTrackSideEffects) </span><span class="s3">return null</span><span class="s1">;</span>
    <span class="s3">for </span><span class="s1">(; </span><span class="s3">null </span><span class="s1">!== currentFirstChild; )</span>
      <span class="s1">deleteChild(returnFiber, currentFirstChild),</span>
        <span class="s1">(currentFirstChild = currentFirstChild.sibling);</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">mapRemainingChildren(returnFiber, currentFirstChild) {</span>
    <span class="s3">for </span><span class="s1">(returnFiber = </span><span class="s3">new </span><span class="s1">Map(); </span><span class="s3">null </span><span class="s1">!== currentFirstChild; )</span>
      <span class="s3">null </span><span class="s1">!== currentFirstChild.key</span>
        <span class="s1">? returnFiber.set(currentFirstChild.key, currentFirstChild)</span>
        <span class="s1">: returnFiber.set(currentFirstChild.index, currentFirstChild),</span>
        <span class="s1">(currentFirstChild = currentFirstChild.sibling);</span>
    <span class="s3">return </span><span class="s1">returnFiber;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">useFiber(fiber, pendingProps) {</span>
    <span class="s1">fiber = createWorkInProgress(fiber, pendingProps);</span>
    <span class="s1">fiber.index = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">fiber.sibling = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">placeChild(newFiber, lastPlacedIndex, newIndex) {</span>
    <span class="s1">newFiber.index = newIndex;</span>
    <span class="s3">if </span><span class="s1">(!shouldTrackSideEffects)</span>
      <span class="s3">return </span><span class="s1">(newFiber.flags |= </span><span class="s4">1048576</span><span class="s1">), lastPlacedIndex;</span>
    <span class="s1">newIndex = newFiber.alternate;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== newIndex)</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(newIndex = newIndex.index),</span>
        <span class="s1">newIndex &lt; lastPlacedIndex</span>
          <span class="s1">? ((newFiber.flags |= </span><span class="s4">2</span><span class="s1">), lastPlacedIndex)</span>
          <span class="s1">: newIndex</span>
      <span class="s1">);</span>
    <span class="s1">newFiber.flags |= </span><span class="s4">2</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">lastPlacedIndex;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">placeSingleChild(newFiber) {</span>
    <span class="s1">shouldTrackSideEffects &amp;&amp;</span>
      <span class="s3">null </span><span class="s1">=== newFiber.alternate &amp;&amp;</span>
      <span class="s1">(newFiber.flags |= </span><span class="s4">2</span><span class="s1">);</span>
    <span class="s3">return </span><span class="s1">newFiber;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">updateTextNode(returnFiber, current, textContent, lanes) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== current || </span><span class="s4">6 </span><span class="s1">!== current.tag)</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(current = createFiberFromText(textContent, returnFiber.mode, lanes)),</span>
        <span class="s1">(current.</span><span class="s3">return </span><span class="s1">= returnFiber),</span>
        <span class="s1">current</span>
      <span class="s1">);</span>
    <span class="s1">current = useFiber(current, textContent);</span>
    <span class="s1">current.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
    <span class="s3">return </span><span class="s1">current;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">updateElement(returnFiber, current, element, lanes) {</span>
    <span class="s3">var </span><span class="s1">elementType = element.type;</span>
    <span class="s3">if </span><span class="s1">(elementType === REACT_FRAGMENT_TYPE)</span>
      <span class="s3">return </span><span class="s1">updateFragment(</span>
        <span class="s1">returnFiber,</span>
        <span class="s1">current,</span>
        <span class="s1">element.props.children,</span>
        <span class="s1">lanes,</span>
        <span class="s1">element.key</span>
      <span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">null </span><span class="s1">!== current &amp;&amp;</span>
      <span class="s1">(current.elementType === elementType ||</span>
        <span class="s1">(</span><span class="s2">&quot;object&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">elementType &amp;&amp;</span>
          <span class="s3">null </span><span class="s1">!== elementType &amp;&amp;</span>
          <span class="s1">elementType.$$typeof === REACT_LAZY_TYPE &amp;&amp;</span>
          <span class="s1">resolveLazy(elementType) === current.type))</span>
    <span class="s1">)</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(lanes = useFiber(current, element.props)),</span>
        <span class="s1">(lanes.ref = coerceRef(returnFiber, current, element)),</span>
        <span class="s1">(lanes.</span><span class="s3">return </span><span class="s1">= returnFiber),</span>
        <span class="s1">lanes</span>
      <span class="s1">);</span>
    <span class="s1">lanes = createFiberFromTypeAndProps(</span>
      <span class="s1">element.type,</span>
      <span class="s1">element.key,</span>
      <span class="s1">element.props,</span>
      <span class="s3">null</span><span class="s1">,</span>
      <span class="s1">returnFiber.mode,</span>
      <span class="s1">lanes</span>
    <span class="s1">);</span>
    <span class="s1">lanes.ref = coerceRef(returnFiber, current, element);</span>
    <span class="s1">lanes.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
    <span class="s3">return </span><span class="s1">lanes;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">updatePortal(returnFiber, current, portal, lanes) {</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">null </span><span class="s1">=== current ||</span>
      <span class="s4">4 </span><span class="s1">!== current.tag ||</span>
      <span class="s1">current.stateNode.containerInfo !== portal.containerInfo ||</span>
      <span class="s1">current.stateNode.implementation !== portal.implementation</span>
    <span class="s1">)</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(current = createFiberFromPortal(portal, returnFiber.mode, lanes)),</span>
        <span class="s1">(current.</span><span class="s3">return </span><span class="s1">= returnFiber),</span>
        <span class="s1">current</span>
      <span class="s1">);</span>
    <span class="s1">current = useFiber(current, portal.children || []);</span>
    <span class="s1">current.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
    <span class="s3">return </span><span class="s1">current;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">updateFragment(returnFiber, current, fragment, lanes, key) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== current || </span><span class="s4">7 </span><span class="s1">!== current.tag)</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(current = createFiberFromFragment(</span>
          <span class="s1">fragment,</span>
          <span class="s1">returnFiber.mode,</span>
          <span class="s1">lanes,</span>
          <span class="s1">key</span>
        <span class="s1">)),</span>
        <span class="s1">(current.</span><span class="s3">return </span><span class="s1">= returnFiber),</span>
        <span class="s1">current</span>
      <span class="s1">);</span>
    <span class="s1">current = useFiber(current, fragment);</span>
    <span class="s1">current.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
    <span class="s3">return </span><span class="s1">current;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">createChild(returnFiber, newChild, lanes) {</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">(</span><span class="s2">&quot;string&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">newChild &amp;&amp; </span><span class="s2">&quot;&quot; </span><span class="s1">!== newChild) ||</span>
      <span class="s2">&quot;number&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">newChild</span>
    <span class="s1">)</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(newChild = createFiberFromText(</span>
          <span class="s2">&quot;&quot; </span><span class="s1">+ newChild,</span>
          <span class="s1">returnFiber.mode,</span>
          <span class="s1">lanes</span>
        <span class="s1">)),</span>
        <span class="s1">(newChild.</span><span class="s3">return </span><span class="s1">= returnFiber),</span>
        <span class="s1">newChild</span>
      <span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;object&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">newChild &amp;&amp; </span><span class="s3">null </span><span class="s1">!== newChild) {</span>
      <span class="s3">switch </span><span class="s1">(newChild.$$typeof) {</span>
        <span class="s3">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
          <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">(lanes = createFiberFromTypeAndProps(</span>
              <span class="s1">newChild.type,</span>
              <span class="s1">newChild.key,</span>
              <span class="s1">newChild.props,</span>
              <span class="s3">null</span><span class="s1">,</span>
              <span class="s1">returnFiber.mode,</span>
              <span class="s1">lanes</span>
            <span class="s1">)),</span>
            <span class="s1">(lanes.ref = coerceRef(returnFiber, </span><span class="s3">null</span><span class="s1">, newChild)),</span>
            <span class="s1">(lanes.</span><span class="s3">return </span><span class="s1">= returnFiber),</span>
            <span class="s1">lanes</span>
          <span class="s1">);</span>
        <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
          <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">(newChild = createFiberFromPortal(</span>
              <span class="s1">newChild,</span>
              <span class="s1">returnFiber.mode,</span>
              <span class="s1">lanes</span>
            <span class="s1">)),</span>
            <span class="s1">(newChild.</span><span class="s3">return </span><span class="s1">= returnFiber),</span>
            <span class="s1">newChild</span>
          <span class="s1">);</span>
        <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE:</span>
          <span class="s3">var </span><span class="s1">init = newChild._init;</span>
          <span class="s3">return </span><span class="s1">createChild(returnFiber, init(newChild._payload), lanes);</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(isArrayImpl(newChild) || getIteratorFn(newChild))</span>
        <span class="s3">return </span><span class="s1">(</span>
          <span class="s1">(newChild = createFiberFromFragment(</span>
            <span class="s1">newChild,</span>
            <span class="s1">returnFiber.mode,</span>
            <span class="s1">lanes,</span>
            <span class="s3">null</span>
          <span class="s1">)),</span>
          <span class="s1">(newChild.</span><span class="s3">return </span><span class="s1">= returnFiber),</span>
          <span class="s1">newChild</span>
        <span class="s1">);</span>
      <span class="s1">throwOnInvalidObjectType(returnFiber, newChild);</span>
    <span class="s1">}</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">updateSlot(returnFiber, oldFiber, newChild, lanes) {</span>
    <span class="s3">var </span><span class="s1">key = </span><span class="s3">null </span><span class="s1">!== oldFiber ? oldFiber.key : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">(</span><span class="s2">&quot;string&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">newChild &amp;&amp; </span><span class="s2">&quot;&quot; </span><span class="s1">!== newChild) ||</span>
      <span class="s2">&quot;number&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">newChild</span>
    <span class="s1">)</span>
      <span class="s3">return null </span><span class="s1">!== key</span>
        <span class="s1">? </span><span class="s3">null</span>
        <span class="s1">: updateTextNode(returnFiber, oldFiber, </span><span class="s2">&quot;&quot; </span><span class="s1">+ newChild, lanes);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;object&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">newChild &amp;&amp; </span><span class="s3">null </span><span class="s1">!== newChild) {</span>
      <span class="s3">switch </span><span class="s1">(newChild.$$typeof) {</span>
        <span class="s3">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
          <span class="s3">return </span><span class="s1">newChild.key === key</span>
            <span class="s1">? updateElement(returnFiber, oldFiber, newChild, lanes)</span>
            <span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
          <span class="s3">return </span><span class="s1">newChild.key === key</span>
            <span class="s1">? updatePortal(returnFiber, oldFiber, newChild, lanes)</span>
            <span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE:</span>
          <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">(key = newChild._init),</span>
            <span class="s1">updateSlot(returnFiber, oldFiber, key(newChild._payload), lanes)</span>
          <span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(isArrayImpl(newChild) || getIteratorFn(newChild))</span>
        <span class="s3">return null </span><span class="s1">!== key</span>
          <span class="s1">? </span><span class="s3">null</span>
          <span class="s1">: updateFragment(returnFiber, oldFiber, newChild, lanes, </span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">throwOnInvalidObjectType(returnFiber, newChild);</span>
    <span class="s1">}</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">updateFromMap(</span>
    <span class="s1">existingChildren,</span>
    <span class="s1">returnFiber,</span>
    <span class="s1">newIdx,</span>
    <span class="s1">newChild,</span>
    <span class="s1">lanes</span>
  <span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">(</span><span class="s2">&quot;string&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">newChild &amp;&amp; </span><span class="s2">&quot;&quot; </span><span class="s1">!== newChild) ||</span>
      <span class="s2">&quot;number&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">newChild</span>
    <span class="s1">)</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(existingChildren = existingChildren.get(newIdx) || </span><span class="s3">null</span><span class="s1">),</span>
        <span class="s1">updateTextNode(returnFiber, existingChildren, </span><span class="s2">&quot;&quot; </span><span class="s1">+ newChild, lanes)</span>
      <span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;object&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">newChild &amp;&amp; </span><span class="s3">null </span><span class="s1">!== newChild) {</span>
      <span class="s3">switch </span><span class="s1">(newChild.$$typeof) {</span>
        <span class="s3">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
          <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">(existingChildren =</span>
              <span class="s1">existingChildren.get(</span>
                <span class="s3">null </span><span class="s1">=== newChild.key ? newIdx : newChild.key</span>
              <span class="s1">) || </span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">updateElement(returnFiber, existingChildren, newChild, lanes)</span>
          <span class="s1">);</span>
        <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
          <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">(existingChildren =</span>
              <span class="s1">existingChildren.get(</span>
                <span class="s3">null </span><span class="s1">=== newChild.key ? newIdx : newChild.key</span>
              <span class="s1">) || </span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">updatePortal(returnFiber, existingChildren, newChild, lanes)</span>
          <span class="s1">);</span>
        <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE:</span>
          <span class="s3">var </span><span class="s1">init = newChild._init;</span>
          <span class="s3">return </span><span class="s1">updateFromMap(</span>
            <span class="s1">existingChildren,</span>
            <span class="s1">returnFiber,</span>
            <span class="s1">newIdx,</span>
            <span class="s1">init(newChild._payload),</span>
            <span class="s1">lanes</span>
          <span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(isArrayImpl(newChild) || getIteratorFn(newChild))</span>
        <span class="s3">return </span><span class="s1">(</span>
          <span class="s1">(existingChildren = existingChildren.get(newIdx) || </span><span class="s3">null</span><span class="s1">),</span>
          <span class="s1">updateFragment(returnFiber, existingChildren, newChild, lanes, </span><span class="s3">null</span><span class="s1">)</span>
        <span class="s1">);</span>
      <span class="s1">throwOnInvalidObjectType(returnFiber, newChild);</span>
    <span class="s1">}</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">reconcileChildrenArray(</span>
    <span class="s1">returnFiber,</span>
    <span class="s1">currentFirstChild,</span>
    <span class="s1">newChildren,</span>
    <span class="s1">lanes</span>
  <span class="s1">) {</span>
    <span class="s3">for </span><span class="s1">(</span>
      <span class="s3">var </span><span class="s1">resultingFirstChild = </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">previousNewFiber = </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">oldFiber = currentFirstChild,</span>
        <span class="s1">newIdx = (currentFirstChild = </span><span class="s4">0</span><span class="s1">),</span>
        <span class="s1">nextOldFiber = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">null </span><span class="s1">!== oldFiber &amp;&amp; newIdx &lt; newChildren.length;</span>
      <span class="s1">newIdx++</span>
    <span class="s1">) {</span>
      <span class="s1">oldFiber.index &gt; newIdx</span>
        <span class="s1">? ((nextOldFiber = oldFiber), (oldFiber = </span><span class="s3">null</span><span class="s1">))</span>
        <span class="s1">: (nextOldFiber = oldFiber.sibling);</span>
      <span class="s3">var </span><span class="s1">newFiber = updateSlot(</span>
        <span class="s1">returnFiber,</span>
        <span class="s1">oldFiber,</span>
        <span class="s1">newChildren[newIdx],</span>
        <span class="s1">lanes</span>
      <span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== newFiber) {</span>
        <span class="s3">null </span><span class="s1">=== oldFiber &amp;&amp; (oldFiber = nextOldFiber);</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">shouldTrackSideEffects &amp;&amp;</span>
        <span class="s1">oldFiber &amp;&amp;</span>
        <span class="s3">null </span><span class="s1">=== newFiber.alternate &amp;&amp;</span>
        <span class="s1">deleteChild(returnFiber, oldFiber);</span>
      <span class="s1">currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);</span>
      <span class="s3">null </span><span class="s1">=== previousNewFiber</span>
        <span class="s1">? (resultingFirstChild = newFiber)</span>
        <span class="s1">: (previousNewFiber.sibling = newFiber);</span>
      <span class="s1">previousNewFiber = newFiber;</span>
      <span class="s1">oldFiber = nextOldFiber;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(newIdx === newChildren.length)</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">deleteRemainingChildren(returnFiber, oldFiber), resultingFirstChild</span>
      <span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== oldFiber) {</span>
      <span class="s3">for </span><span class="s1">(; newIdx &lt; newChildren.length; newIdx++)</span>
        <span class="s1">(oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),</span>
          <span class="s3">null </span><span class="s1">!== oldFiber &amp;&amp;</span>
            <span class="s1">((currentFirstChild = placeChild(</span>
              <span class="s1">oldFiber,</span>
              <span class="s1">currentFirstChild,</span>
              <span class="s1">newIdx</span>
            <span class="s1">)),</span>
            <span class="s3">null </span><span class="s1">=== previousNewFiber</span>
              <span class="s1">? (resultingFirstChild = oldFiber)</span>
              <span class="s1">: (previousNewFiber.sibling = oldFiber),</span>
            <span class="s1">(previousNewFiber = oldFiber));</span>
      <span class="s3">return </span><span class="s1">resultingFirstChild;</span>
    <span class="s1">}</span>
    <span class="s3">for </span><span class="s1">(</span>
      <span class="s1">oldFiber = mapRemainingChildren(returnFiber, oldFiber);</span>
      <span class="s1">newIdx &lt; newChildren.length;</span>
      <span class="s1">newIdx++</span>
    <span class="s1">)</span>
      <span class="s1">(nextOldFiber = updateFromMap(</span>
        <span class="s1">oldFiber,</span>
        <span class="s1">returnFiber,</span>
        <span class="s1">newIdx,</span>
        <span class="s1">newChildren[newIdx],</span>
        <span class="s1">lanes</span>
      <span class="s1">)),</span>
        <span class="s3">null </span><span class="s1">!== nextOldFiber &amp;&amp;</span>
          <span class="s1">(shouldTrackSideEffects &amp;&amp;</span>
            <span class="s3">null </span><span class="s1">!== nextOldFiber.alternate &amp;&amp;</span>
            <span class="s1">oldFiber.</span><span class="s3">delete</span><span class="s1">(</span>
              <span class="s3">null </span><span class="s1">=== nextOldFiber.key ? newIdx : nextOldFiber.key</span>
            <span class="s1">),</span>
          <span class="s1">(currentFirstChild = placeChild(</span>
            <span class="s1">nextOldFiber,</span>
            <span class="s1">currentFirstChild,</span>
            <span class="s1">newIdx</span>
          <span class="s1">)),</span>
          <span class="s3">null </span><span class="s1">=== previousNewFiber</span>
            <span class="s1">? (resultingFirstChild = nextOldFiber)</span>
            <span class="s1">: (previousNewFiber.sibling = nextOldFiber),</span>
          <span class="s1">(previousNewFiber = nextOldFiber));</span>
    <span class="s1">shouldTrackSideEffects &amp;&amp;</span>
      <span class="s1">oldFiber.forEach(</span><span class="s3">function</span><span class="s1">(child) {</span>
        <span class="s3">return </span><span class="s1">deleteChild(returnFiber, child);</span>
      <span class="s1">});</span>
    <span class="s3">return </span><span class="s1">resultingFirstChild;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">reconcileChildrenIterator(</span>
    <span class="s1">returnFiber,</span>
    <span class="s1">currentFirstChild,</span>
    <span class="s1">newChildrenIterable,</span>
    <span class="s1">lanes</span>
  <span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">iteratorFn = getIteratorFn(newChildrenIterable);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">iteratorFn)</span>
      <span class="s3">throw </span><span class="s1">Error(</span>
        <span class="s2">&quot;An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">newChildrenIterable = iteratorFn.call(newChildrenIterable);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">== newChildrenIterable)</span>
      <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;An iterable object provided no iterator.&quot;</span><span class="s1">);</span>
    <span class="s3">for </span><span class="s1">(</span>
      <span class="s3">var </span><span class="s1">previousNewFiber = (iteratorFn = </span><span class="s3">null</span><span class="s1">),</span>
        <span class="s1">oldFiber = currentFirstChild,</span>
        <span class="s1">newIdx = (currentFirstChild = </span><span class="s4">0</span><span class="s1">),</span>
        <span class="s1">nextOldFiber = </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">step = newChildrenIterable.next();</span>
      <span class="s3">null </span><span class="s1">!== oldFiber &amp;&amp; !step.done;</span>
      <span class="s1">newIdx++, step = newChildrenIterable.next()</span>
    <span class="s1">) {</span>
      <span class="s1">oldFiber.index &gt; newIdx</span>
        <span class="s1">? ((nextOldFiber = oldFiber), (oldFiber = </span><span class="s3">null</span><span class="s1">))</span>
        <span class="s1">: (nextOldFiber = oldFiber.sibling);</span>
      <span class="s3">var </span><span class="s1">newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== newFiber) {</span>
        <span class="s3">null </span><span class="s1">=== oldFiber &amp;&amp; (oldFiber = nextOldFiber);</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">shouldTrackSideEffects &amp;&amp;</span>
        <span class="s1">oldFiber &amp;&amp;</span>
        <span class="s3">null </span><span class="s1">=== newFiber.alternate &amp;&amp;</span>
        <span class="s1">deleteChild(returnFiber, oldFiber);</span>
      <span class="s1">currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);</span>
      <span class="s3">null </span><span class="s1">=== previousNewFiber</span>
        <span class="s1">? (iteratorFn = newFiber)</span>
        <span class="s1">: (previousNewFiber.sibling = newFiber);</span>
      <span class="s1">previousNewFiber = newFiber;</span>
      <span class="s1">oldFiber = nextOldFiber;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(step.done)</span>
      <span class="s3">return </span><span class="s1">deleteRemainingChildren(returnFiber, oldFiber), iteratorFn;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== oldFiber) {</span>
      <span class="s3">for </span><span class="s1">(; !step.done; newIdx++, step = newChildrenIterable.next())</span>
        <span class="s1">(step = createChild(returnFiber, step.value, lanes)),</span>
          <span class="s3">null </span><span class="s1">!== step &amp;&amp;</span>
            <span class="s1">((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),</span>
            <span class="s3">null </span><span class="s1">=== previousNewFiber</span>
              <span class="s1">? (iteratorFn = step)</span>
              <span class="s1">: (previousNewFiber.sibling = step),</span>
            <span class="s1">(previousNewFiber = step));</span>
      <span class="s3">return </span><span class="s1">iteratorFn;</span>
    <span class="s1">}</span>
    <span class="s3">for </span><span class="s1">(</span>
      <span class="s1">oldFiber = mapRemainingChildren(returnFiber, oldFiber);</span>
      <span class="s1">!step.done;</span>
      <span class="s1">newIdx++, step = newChildrenIterable.next()</span>
    <span class="s1">)</span>
      <span class="s1">(step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),</span>
        <span class="s3">null </span><span class="s1">!== step &amp;&amp;</span>
          <span class="s1">(shouldTrackSideEffects &amp;&amp;</span>
            <span class="s3">null </span><span class="s1">!== step.alternate &amp;&amp;</span>
            <span class="s1">oldFiber.</span><span class="s3">delete</span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== step.key ? newIdx : step.key),</span>
          <span class="s1">(currentFirstChild = placeChild(step, currentFirstChild, newIdx)),</span>
          <span class="s3">null </span><span class="s1">=== previousNewFiber</span>
            <span class="s1">? (iteratorFn = step)</span>
            <span class="s1">: (previousNewFiber.sibling = step),</span>
          <span class="s1">(previousNewFiber = step));</span>
    <span class="s1">shouldTrackSideEffects &amp;&amp;</span>
      <span class="s1">oldFiber.forEach(</span><span class="s3">function</span><span class="s1">(child) {</span>
        <span class="s3">return </span><span class="s1">deleteChild(returnFiber, child);</span>
      <span class="s1">});</span>
    <span class="s3">return </span><span class="s1">iteratorFn;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">reconcileChildFibers(</span>
    <span class="s1">returnFiber,</span>
    <span class="s1">currentFirstChild,</span>
    <span class="s1">newChild,</span>
    <span class="s1">lanes</span>
  <span class="s1">) {</span>
    <span class="s2">&quot;object&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">newChild &amp;&amp;</span>
      <span class="s3">null </span><span class="s1">!== newChild &amp;&amp;</span>
      <span class="s1">newChild.type === REACT_FRAGMENT_TYPE &amp;&amp;</span>
      <span class="s3">null </span><span class="s1">=== newChild.key &amp;&amp;</span>
      <span class="s1">(newChild = newChild.props.children);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;object&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">newChild &amp;&amp; </span><span class="s3">null </span><span class="s1">!== newChild) {</span>
      <span class="s3">switch </span><span class="s1">(newChild.$$typeof) {</span>
        <span class="s3">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
          <span class="s1">a: {</span>
            <span class="s3">for </span><span class="s1">(</span>
              <span class="s3">var </span><span class="s1">key = newChild.key, child = currentFirstChild;</span>
              <span class="s3">null </span><span class="s1">!== child;</span>

            <span class="s1">) {</span>
              <span class="s3">if </span><span class="s1">(child.key === key) {</span>
                <span class="s1">key = newChild.type;</span>
                <span class="s3">if </span><span class="s1">(key === REACT_FRAGMENT_TYPE) {</span>
                  <span class="s3">if </span><span class="s1">(</span><span class="s4">7 </span><span class="s1">=== child.tag) {</span>
                    <span class="s1">deleteRemainingChildren(returnFiber, child.sibling);</span>
                    <span class="s1">currentFirstChild = useFiber(</span>
                      <span class="s1">child,</span>
                      <span class="s1">newChild.props.children</span>
                    <span class="s1">);</span>
                    <span class="s1">currentFirstChild.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
                    <span class="s1">returnFiber = currentFirstChild;</span>
                    <span class="s3">break </span><span class="s1">a;</span>
                  <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
                  <span class="s1">child.elementType === key ||</span>
                  <span class="s1">(</span><span class="s2">&quot;object&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">key &amp;&amp;</span>
                    <span class="s3">null </span><span class="s1">!== key &amp;&amp;</span>
                    <span class="s1">key.$$typeof === REACT_LAZY_TYPE &amp;&amp;</span>
                    <span class="s1">resolveLazy(key) === child.type)</span>
                <span class="s1">) {</span>
                  <span class="s1">deleteRemainingChildren(returnFiber, child.sibling);</span>
                  <span class="s1">currentFirstChild = useFiber(child, newChild.props);</span>
                  <span class="s1">currentFirstChild.ref = coerceRef(</span>
                    <span class="s1">returnFiber,</span>
                    <span class="s1">child,</span>
                    <span class="s1">newChild</span>
                  <span class="s1">);</span>
                  <span class="s1">currentFirstChild.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
                  <span class="s1">returnFiber = currentFirstChild;</span>
                  <span class="s3">break </span><span class="s1">a;</span>
                <span class="s1">}</span>
                <span class="s1">deleteRemainingChildren(returnFiber, child);</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">deleteChild(returnFiber, child);</span>
              <span class="s1">child = child.sibling;</span>
            <span class="s1">}</span>
            <span class="s1">newChild.type === REACT_FRAGMENT_TYPE</span>
              <span class="s1">? ((currentFirstChild = createFiberFromFragment(</span>
                  <span class="s1">newChild.props.children,</span>
                  <span class="s1">returnFiber.mode,</span>
                  <span class="s1">lanes,</span>
                  <span class="s1">newChild.key</span>
                <span class="s1">)),</span>
                <span class="s1">(currentFirstChild.</span><span class="s3">return </span><span class="s1">= returnFiber),</span>
                <span class="s1">(returnFiber = currentFirstChild))</span>
              <span class="s1">: ((lanes = createFiberFromTypeAndProps(</span>
                  <span class="s1">newChild.type,</span>
                  <span class="s1">newChild.key,</span>
                  <span class="s1">newChild.props,</span>
                  <span class="s3">null</span><span class="s1">,</span>
                  <span class="s1">returnFiber.mode,</span>
                  <span class="s1">lanes</span>
                <span class="s1">)),</span>
                <span class="s1">(lanes.ref = coerceRef(</span>
                  <span class="s1">returnFiber,</span>
                  <span class="s1">currentFirstChild,</span>
                  <span class="s1">newChild</span>
                <span class="s1">)),</span>
                <span class="s1">(lanes.</span><span class="s3">return </span><span class="s1">= returnFiber),</span>
                <span class="s1">(returnFiber = lanes));</span>
          <span class="s1">}</span>
          <span class="s3">return </span><span class="s1">placeSingleChild(returnFiber);</span>
        <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
          <span class="s1">a: {</span>
            <span class="s3">for </span><span class="s1">(child = newChild.key; </span><span class="s3">null </span><span class="s1">!== currentFirstChild; ) {</span>
              <span class="s3">if </span><span class="s1">(currentFirstChild.key === child)</span>
                <span class="s3">if </span><span class="s1">(</span>
                  <span class="s4">4 </span><span class="s1">=== currentFirstChild.tag &amp;&amp;</span>
                  <span class="s1">currentFirstChild.stateNode.containerInfo ===</span>
                    <span class="s1">newChild.containerInfo &amp;&amp;</span>
                  <span class="s1">currentFirstChild.stateNode.implementation ===</span>
                    <span class="s1">newChild.implementation</span>
                <span class="s1">) {</span>
                  <span class="s1">deleteRemainingChildren(</span>
                    <span class="s1">returnFiber,</span>
                    <span class="s1">currentFirstChild.sibling</span>
                  <span class="s1">);</span>
                  <span class="s1">currentFirstChild = useFiber(</span>
                    <span class="s1">currentFirstChild,</span>
                    <span class="s1">newChild.children || []</span>
                  <span class="s1">);</span>
                  <span class="s1">currentFirstChild.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
                  <span class="s1">returnFiber = currentFirstChild;</span>
                  <span class="s3">break </span><span class="s1">a;</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                  <span class="s1">deleteRemainingChildren(returnFiber, currentFirstChild);</span>
                  <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
              <span class="s3">else </span><span class="s1">deleteChild(returnFiber, currentFirstChild);</span>
              <span class="s1">currentFirstChild = currentFirstChild.sibling;</span>
            <span class="s1">}</span>
            <span class="s1">currentFirstChild = createFiberFromPortal(</span>
              <span class="s1">newChild,</span>
              <span class="s1">returnFiber.mode,</span>
              <span class="s1">lanes</span>
            <span class="s1">);</span>
            <span class="s1">currentFirstChild.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
            <span class="s1">returnFiber = currentFirstChild;</span>
          <span class="s1">}</span>
          <span class="s3">return </span><span class="s1">placeSingleChild(returnFiber);</span>
        <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE:</span>
          <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">(child = newChild._init),</span>
            <span class="s1">reconcileChildFibers(</span>
              <span class="s1">returnFiber,</span>
              <span class="s1">currentFirstChild,</span>
              <span class="s1">child(newChild._payload),</span>
              <span class="s1">lanes</span>
            <span class="s1">)</span>
          <span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(isArrayImpl(newChild))</span>
        <span class="s3">return </span><span class="s1">reconcileChildrenArray(</span>
          <span class="s1">returnFiber,</span>
          <span class="s1">currentFirstChild,</span>
          <span class="s1">newChild,</span>
          <span class="s1">lanes</span>
        <span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(getIteratorFn(newChild))</span>
        <span class="s3">return </span><span class="s1">reconcileChildrenIterator(</span>
          <span class="s1">returnFiber,</span>
          <span class="s1">currentFirstChild,</span>
          <span class="s1">newChild,</span>
          <span class="s1">lanes</span>
        <span class="s1">);</span>
      <span class="s1">throwOnInvalidObjectType(returnFiber, newChild);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">(</span><span class="s2">&quot;string&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">newChild &amp;&amp; </span><span class="s2">&quot;&quot; </span><span class="s1">!== newChild) ||</span>
      <span class="s2">&quot;number&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">newChild</span>
      <span class="s1">? ((newChild = </span><span class="s2">&quot;&quot; </span><span class="s1">+ newChild),</span>
        <span class="s3">null </span><span class="s1">!== currentFirstChild &amp;&amp; </span><span class="s4">6 </span><span class="s1">=== currentFirstChild.tag</span>
          <span class="s1">? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),</span>
            <span class="s1">(currentFirstChild = useFiber(currentFirstChild, newChild)),</span>
            <span class="s1">(currentFirstChild.</span><span class="s3">return </span><span class="s1">= returnFiber),</span>
            <span class="s1">(returnFiber = currentFirstChild))</span>
          <span class="s1">: (deleteRemainingChildren(returnFiber, currentFirstChild),</span>
            <span class="s1">(currentFirstChild = createFiberFromText(</span>
              <span class="s1">newChild,</span>
              <span class="s1">returnFiber.mode,</span>
              <span class="s1">lanes</span>
            <span class="s1">)),</span>
            <span class="s1">(currentFirstChild.</span><span class="s3">return </span><span class="s1">= returnFiber),</span>
            <span class="s1">(returnFiber = currentFirstChild)),</span>
        <span class="s1">placeSingleChild(returnFiber))</span>
      <span class="s1">: deleteRemainingChildren(returnFiber, currentFirstChild);</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">reconcileChildFibers;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">reconcileChildFibers = ChildReconciler(!</span><span class="s4">0</span><span class="s1">),</span>
  <span class="s1">mountChildFibers = ChildReconciler(!</span><span class="s4">1</span><span class="s1">),</span>
  <span class="s1">NO_CONTEXT = {},</span>
  <span class="s1">contextStackCursor$1 = createCursor(NO_CONTEXT),</span>
  <span class="s1">contextFiberStackCursor = createCursor(NO_CONTEXT),</span>
  <span class="s1">rootInstanceStackCursor = createCursor(NO_CONTEXT);</span>
<span class="s3">function </span><span class="s1">requiredContext(c) {</span>
  <span class="s3">if </span><span class="s1">(c === NO_CONTEXT)</span>
    <span class="s3">throw </span><span class="s1">Error(</span>
      <span class="s2">&quot;Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s3">return </span><span class="s1">c;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pushHostContainer(fiber, nextRootInstance) {</span>
  <span class="s1">push(rootInstanceStackCursor, nextRootInstance);</span>
  <span class="s1">push(contextFiberStackCursor, fiber);</span>
  <span class="s1">push(contextStackCursor$1, NO_CONTEXT);</span>
  <span class="s1">pop(contextStackCursor$1);</span>
  <span class="s1">push(contextStackCursor$1, { isInAParentText: !</span><span class="s4">1 </span><span class="s1">});</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">popHostContainer() {</span>
  <span class="s1">pop(contextStackCursor$1);</span>
  <span class="s1">pop(contextFiberStackCursor);</span>
  <span class="s1">pop(rootInstanceStackCursor);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pushHostContext(fiber) {</span>
  <span class="s1">requiredContext(rootInstanceStackCursor.current);</span>
  <span class="s3">var </span><span class="s1">context = requiredContext(contextStackCursor$1.current);</span>
  <span class="s3">var </span><span class="s1">JSCompiler_inline_result = fiber.type;</span>
  <span class="s1">JSCompiler_inline_result =</span>
    <span class="s2">&quot;AndroidTextInput&quot; </span><span class="s1">=== JSCompiler_inline_result ||</span>
    <span class="s2">&quot;RCTMultilineTextInputView&quot; </span><span class="s1">=== JSCompiler_inline_result ||</span>
    <span class="s2">&quot;RCTSinglelineTextInputView&quot; </span><span class="s1">=== JSCompiler_inline_result ||</span>
    <span class="s2">&quot;RCTText&quot; </span><span class="s1">=== JSCompiler_inline_result ||</span>
    <span class="s2">&quot;RCTVirtualText&quot; </span><span class="s1">=== JSCompiler_inline_result;</span>
  <span class="s1">JSCompiler_inline_result =</span>
    <span class="s1">context.isInAParentText !== JSCompiler_inline_result</span>
      <span class="s1">? { isInAParentText: JSCompiler_inline_result }</span>
      <span class="s1">: context;</span>
  <span class="s1">context !== JSCompiler_inline_result &amp;&amp;</span>
    <span class="s1">(push(contextFiberStackCursor, fiber),</span>
    <span class="s1">push(contextStackCursor$1, JSCompiler_inline_result));</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">popHostContext(fiber) {</span>
  <span class="s1">contextFiberStackCursor.current === fiber &amp;&amp;</span>
    <span class="s1">(pop(contextStackCursor$1), pop(contextFiberStackCursor));</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">suspenseStackCursor = createCursor(</span><span class="s4">0</span><span class="s1">);</span>
<span class="s3">function </span><span class="s1">findFirstSuspended(row) {</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">node = row; </span><span class="s3">null </span><span class="s1">!== node; ) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s4">13 </span><span class="s1">=== node.tag) {</span>
      <span class="s3">var </span><span class="s1">state = node.memoizedState;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== state &amp;&amp; (</span><span class="s3">null </span><span class="s1">=== state.dehydrated || shim() || shim()))</span>
        <span class="s3">return </span><span class="s1">node;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s4">19 </span><span class="s1">=== node.tag &amp;&amp; </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">!== node.memoizedProps.revealOrder) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (node.flags &amp; </span><span class="s4">128</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">node;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== node.child) {</span>
      <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
      <span class="s1">node = node.child;</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(node === row) </span><span class="s3">break</span><span class="s1">;</span>
    <span class="s3">for </span><span class="s1">(; </span><span class="s3">null </span><span class="s1">=== node.sibling; ) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== node.</span><span class="s3">return </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== row) </span><span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">node = node.sibling;</span>
  <span class="s1">}</span>
  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">workInProgressSources = [];</span>
<span class="s3">function </span><span class="s1">resetWorkInProgressVersions() {</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; workInProgressSources.length; i++)</span>
    <span class="s1">workInProgressSources[i]._workInProgressVersionPrimary = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">workInProgressSources.length = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,</span>
  <span class="s1">ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig,</span>
  <span class="s1">renderLanes = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">currentlyRenderingFiber$1 = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">currentHook = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">workInProgressHook = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">didScheduleRenderPhaseUpdate = !</span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">didScheduleRenderPhaseUpdateDuringThisPass = !</span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">globalClientIdCounter = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">throwInvalidHookError() {</span>
  <span class="s3">throw </span><span class="s1">Error(</span>
    <span class="s2">&quot;Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:</span><span class="s5">\n</span><span class="s2">1. You might have mismatching versions of React and the renderer (such as React DOM)</span><span class="s5">\n</span><span class="s2">2. You might be breaking the Rules of Hooks</span><span class="s5">\n</span><span class="s2">3. You might have more than one copy of React in the same app</span><span class="s5">\n</span><span class="s2">See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.&quot;</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">areHookInputsEqual(nextDeps, prevDeps) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== prevDeps) </span><span class="s3">return </span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++)</span>
    <span class="s3">if </span><span class="s1">(!objectIs(nextDeps[i], prevDeps[i])) </span><span class="s3">return </span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">!</span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">renderWithHooks(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">props,</span>
  <span class="s1">secondArg,</span>
  <span class="s1">nextRenderLanes</span>
<span class="s1">) {</span>
  <span class="s1">renderLanes = nextRenderLanes;</span>
  <span class="s1">currentlyRenderingFiber$1 = workInProgress;</span>
  <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">workInProgress.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">workInProgress.lanes = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">ReactCurrentDispatcher$1.current =</span>
    <span class="s3">null </span><span class="s1">=== current || </span><span class="s3">null </span><span class="s1">=== current.memoizedState</span>
      <span class="s1">? HooksDispatcherOnMount</span>
      <span class="s1">: HooksDispatcherOnUpdate;</span>
  <span class="s1">current = Component(props, secondArg);</span>
  <span class="s3">if </span><span class="s1">(didScheduleRenderPhaseUpdateDuringThisPass) {</span>
    <span class="s1">nextRenderLanes = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">do </span><span class="s1">{</span>
      <span class="s1">didScheduleRenderPhaseUpdateDuringThisPass = !</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s4">25 </span><span class="s1">&lt;= nextRenderLanes)</span>
        <span class="s3">throw </span><span class="s1">Error(</span>
          <span class="s2">&quot;Too many re-renders. React limits the number of renders to prevent an infinite loop.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">nextRenderLanes += </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">workInProgressHook = currentHook = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = HooksDispatcherOnRerender;</span>
      <span class="s1">current = Component(props, secondArg);</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(didScheduleRenderPhaseUpdateDuringThisPass);</span>
  <span class="s1">}</span>
  <span class="s1">ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;</span>
  <span class="s1">workInProgress = </span><span class="s3">null </span><span class="s1">!== currentHook &amp;&amp; </span><span class="s3">null </span><span class="s1">!== currentHook.next;</span>
  <span class="s1">renderLanes = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">workInProgressHook = currentHook = currentlyRenderingFiber$1 = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">didScheduleRenderPhaseUpdate = !</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(workInProgress)</span>
    <span class="s3">throw </span><span class="s1">Error(</span>
      <span class="s2">&quot;Rendered fewer hooks than expected. This may be caused by an accidental early return statement.&quot;</span>
    <span class="s1">);</span>
  <span class="s3">return </span><span class="s1">current;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">mountWorkInProgressHook() {</span>
  <span class="s3">var </span><span class="s1">hook = {</span>
    <span class="s1">memoizedState: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">baseState: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">baseQueue: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">queue: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">next: </span><span class="s3">null</span>
  <span class="s1">};</span>
  <span class="s3">null </span><span class="s1">=== workInProgressHook</span>
    <span class="s1">? (currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook)</span>
    <span class="s1">: (workInProgressHook = workInProgressHook.next = hook);</span>
  <span class="s3">return </span><span class="s1">workInProgressHook;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateWorkInProgressHook() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== currentHook) {</span>
    <span class="s3">var </span><span class="s1">nextCurrentHook = currentlyRenderingFiber$1.alternate;</span>
    <span class="s1">nextCurrentHook =</span>
      <span class="s3">null </span><span class="s1">!== nextCurrentHook ? nextCurrentHook.memoizedState : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">nextCurrentHook = currentHook.next;</span>
  <span class="s3">var </span><span class="s1">nextWorkInProgressHook =</span>
    <span class="s3">null </span><span class="s1">=== workInProgressHook</span>
      <span class="s1">? currentlyRenderingFiber$1.memoizedState</span>
      <span class="s1">: workInProgressHook.next;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== nextWorkInProgressHook)</span>
    <span class="s1">(workInProgressHook = nextWorkInProgressHook),</span>
      <span class="s1">(currentHook = nextCurrentHook);</span>
  <span class="s3">else </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== nextCurrentHook)</span>
      <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Rendered more hooks than during the previous render.&quot;</span><span class="s1">);</span>
    <span class="s1">currentHook = nextCurrentHook;</span>
    <span class="s1">nextCurrentHook = {</span>
      <span class="s1">memoizedState: currentHook.memoizedState,</span>
      <span class="s1">baseState: currentHook.baseState,</span>
      <span class="s1">baseQueue: currentHook.baseQueue,</span>
      <span class="s1">queue: currentHook.queue,</span>
      <span class="s1">next: </span><span class="s3">null</span>
    <span class="s1">};</span>
    <span class="s3">null </span><span class="s1">=== workInProgressHook</span>
      <span class="s1">? (currentlyRenderingFiber$1.memoizedState = workInProgressHook = nextCurrentHook)</span>
      <span class="s1">: (workInProgressHook = workInProgressHook.next = nextCurrentHook);</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">workInProgressHook;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">basicStateReducer(state, action) {</span>
  <span class="s3">return </span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">action ? action(state) : action;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateReducer(reducer) {</span>
  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook(),</span>
    <span class="s1">queue = hook.queue;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== queue)</span>
    <span class="s3">throw </span><span class="s1">Error(</span>
      <span class="s2">&quot;Should have a queue. This is likely a bug in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">queue.lastRenderedReducer = reducer;</span>
  <span class="s3">var </span><span class="s1">current = currentHook,</span>
    <span class="s1">baseQueue = current.baseQueue,</span>
    <span class="s1">pendingQueue = queue.pending;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== pendingQueue) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== baseQueue) {</span>
      <span class="s3">var </span><span class="s1">baseFirst = baseQueue.next;</span>
      <span class="s1">baseQueue.next = pendingQueue.next;</span>
      <span class="s1">pendingQueue.next = baseFirst;</span>
    <span class="s1">}</span>
    <span class="s1">current.baseQueue = baseQueue = pendingQueue;</span>
    <span class="s1">queue.pending = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== baseQueue) {</span>
    <span class="s1">pendingQueue = baseQueue.next;</span>
    <span class="s1">current = current.baseState;</span>
    <span class="s3">var </span><span class="s1">newBaseQueueFirst = (baseFirst = </span><span class="s3">null</span><span class="s1">),</span>
      <span class="s1">newBaseQueueLast = </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">update = pendingQueue;</span>
    <span class="s3">do </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">updateLane = update.lane;</span>
      <span class="s3">if </span><span class="s1">((renderLanes &amp; updateLane) === updateLane)</span>
        <span class="s3">null </span><span class="s1">!== newBaseQueueLast &amp;&amp;</span>
          <span class="s1">(newBaseQueueLast = newBaseQueueLast.next = {</span>
            <span class="s1">lane: </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s1">action: update.action,</span>
            <span class="s1">hasEagerState: update.hasEagerState,</span>
            <span class="s1">eagerState: update.eagerState,</span>
            <span class="s1">next: </span><span class="s3">null</span>
          <span class="s1">}),</span>
          <span class="s1">(current = update.hasEagerState</span>
            <span class="s1">? update.eagerState</span>
            <span class="s1">: reducer(current, update.action));</span>
      <span class="s3">else </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">clone = {</span>
          <span class="s1">lane: updateLane,</span>
          <span class="s1">action: update.action,</span>
          <span class="s1">hasEagerState: update.hasEagerState,</span>
          <span class="s1">eagerState: update.eagerState,</span>
          <span class="s1">next: </span><span class="s3">null</span>
        <span class="s1">};</span>
        <span class="s3">null </span><span class="s1">=== newBaseQueueLast</span>
          <span class="s1">? ((newBaseQueueFirst = newBaseQueueLast = clone),</span>
            <span class="s1">(baseFirst = current))</span>
          <span class="s1">: (newBaseQueueLast = newBaseQueueLast.next = clone);</span>
        <span class="s1">currentlyRenderingFiber$1.lanes |= updateLane;</span>
        <span class="s1">workInProgressRootSkippedLanes |= updateLane;</span>
      <span class="s1">}</span>
      <span class="s1">update = update.next;</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== update &amp;&amp; update !== pendingQueue);</span>
    <span class="s3">null </span><span class="s1">=== newBaseQueueLast</span>
      <span class="s1">? (baseFirst = current)</span>
      <span class="s1">: (newBaseQueueLast.next = newBaseQueueFirst);</span>
    <span class="s1">objectIs(current, hook.memoizedState) || (didReceiveUpdate = !</span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">hook.memoizedState = current;</span>
    <span class="s1">hook.baseState = baseFirst;</span>
    <span class="s1">hook.baseQueue = newBaseQueueLast;</span>
    <span class="s1">queue.lastRenderedState = current;</span>
  <span class="s1">}</span>
  <span class="s1">reducer = queue.interleaved;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== reducer) {</span>
    <span class="s1">baseQueue = reducer;</span>
    <span class="s3">do</span>
      <span class="s1">(pendingQueue = baseQueue.lane),</span>
        <span class="s1">(currentlyRenderingFiber$1.lanes |= pendingQueue),</span>
        <span class="s1">(workInProgressRootSkippedLanes |= pendingQueue),</span>
        <span class="s1">(baseQueue = baseQueue.next);</span>
    <span class="s3">while </span><span class="s1">(baseQueue !== reducer);</span>
  <span class="s1">} </span><span class="s3">else null </span><span class="s1">=== baseQueue &amp;&amp; (queue.lanes = </span><span class="s4">0</span><span class="s1">);</span>
  <span class="s3">return </span><span class="s1">[hook.memoizedState, queue.dispatch];</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">rerenderReducer(reducer) {</span>
  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook(),</span>
    <span class="s1">queue = hook.queue;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== queue)</span>
    <span class="s3">throw </span><span class="s1">Error(</span>
      <span class="s2">&quot;Should have a queue. This is likely a bug in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">queue.lastRenderedReducer = reducer;</span>
  <span class="s3">var </span><span class="s1">dispatch = queue.dispatch,</span>
    <span class="s1">lastRenderPhaseUpdate = queue.pending,</span>
    <span class="s1">newState = hook.memoizedState;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== lastRenderPhaseUpdate) {</span>
    <span class="s1">queue.pending = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);</span>
    <span class="s3">do </span><span class="s1">(newState = reducer(newState, update.action)), (update = update.next);</span>
    <span class="s3">while </span><span class="s1">(update !== lastRenderPhaseUpdate);</span>
    <span class="s1">objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !</span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">hook.memoizedState = newState;</span>
    <span class="s3">null </span><span class="s1">=== hook.baseQueue &amp;&amp; (hook.baseState = newState);</span>
    <span class="s1">queue.lastRenderedState = newState;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">[newState, dispatch];</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateMutableSource() {}</span>
<span class="s3">function </span><span class="s1">updateSyncExternalStore(subscribe, getSnapshot) {</span>
  <span class="s3">var </span><span class="s1">fiber = currentlyRenderingFiber$1,</span>
    <span class="s1">hook = updateWorkInProgressHook(),</span>
    <span class="s1">nextSnapshot = getSnapshot(),</span>
    <span class="s1">snapshotChanged = !objectIs(hook.memoizedState, nextSnapshot);</span>
  <span class="s1">snapshotChanged &amp;&amp;</span>
    <span class="s1">((hook.memoizedState = nextSnapshot), (didReceiveUpdate = !</span><span class="s4">0</span><span class="s1">));</span>
  <span class="s1">hook = hook.queue;</span>
  <span class="s1">updateEffect(subscribeToStore.bind(</span><span class="s3">null</span><span class="s1">, fiber, hook, subscribe), [</span>
    <span class="s1">subscribe</span>
  <span class="s1">]);</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">hook.getSnapshot !== getSnapshot ||</span>
    <span class="s1">snapshotChanged ||</span>
    <span class="s1">(</span><span class="s3">null </span><span class="s1">!== workInProgressHook &amp;&amp; workInProgressHook.memoizedState.tag &amp; </span><span class="s4">1</span><span class="s1">)</span>
  <span class="s1">) {</span>
    <span class="s1">fiber.flags |= </span><span class="s4">2048</span><span class="s1">;</span>
    <span class="s1">pushEffect(</span>
      <span class="s4">9</span><span class="s1">,</span>
      <span class="s1">updateStoreInstance.bind(</span><span class="s3">null</span><span class="s1">, fiber, hook, nextSnapshot, getSnapshot),</span>
      <span class="s3">void </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s3">null</span>
    <span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== workInProgressRoot)</span>
      <span class="s3">throw </span><span class="s1">Error(</span>
        <span class="s2">&quot;Expected a work-in-progress root. This is a bug in React. Please file an issue.&quot;</span>
      <span class="s1">);</span>
    <span class="s4">0 </span><span class="s1">!== (renderLanes &amp; </span><span class="s4">30</span><span class="s1">) ||</span>
      <span class="s1">pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">nextSnapshot;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {</span>
  <span class="s1">fiber.flags |= </span><span class="s4">16384</span><span class="s1">;</span>
  <span class="s1">fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };</span>
  <span class="s1">getSnapshot = currentlyRenderingFiber$1.updateQueue;</span>
  <span class="s3">null </span><span class="s1">=== getSnapshot</span>
    <span class="s1">? ((getSnapshot = { lastEffect: </span><span class="s3">null</span><span class="s1">, stores: </span><span class="s3">null </span><span class="s1">}),</span>
      <span class="s1">(currentlyRenderingFiber$1.updateQueue = getSnapshot),</span>
      <span class="s1">(getSnapshot.stores = [fiber]))</span>
    <span class="s1">: ((renderedSnapshot = getSnapshot.stores),</span>
      <span class="s3">null </span><span class="s1">=== renderedSnapshot</span>
        <span class="s1">? (getSnapshot.stores = [fiber])</span>
        <span class="s1">: renderedSnapshot.push(fiber));</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {</span>
  <span class="s1">inst.value = nextSnapshot;</span>
  <span class="s1">inst.getSnapshot = getSnapshot;</span>
  <span class="s1">checkIfSnapshotChanged(inst) &amp;&amp; forceStoreRerender(fiber);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">subscribeToStore(fiber, inst, subscribe) {</span>
  <span class="s3">return </span><span class="s1">subscribe(</span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s1">checkIfSnapshotChanged(inst) &amp;&amp; forceStoreRerender(fiber);</span>
  <span class="s1">});</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">checkIfSnapshotChanged(inst) {</span>
  <span class="s3">var </span><span class="s1">latestGetSnapshot = inst.getSnapshot;</span>
  <span class="s1">inst = inst.value;</span>
  <span class="s3">try </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">nextValue = latestGetSnapshot();</span>
    <span class="s3">return </span><span class="s1">!objectIs(inst, nextValue);</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
    <span class="s3">return </span><span class="s1">!</span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">forceStoreRerender(fiber) {</span>
  <span class="s3">var </span><span class="s1">root = markUpdateLaneFromFiberToRoot(fiber, </span><span class="s4">1</span><span class="s1">);</span>
  <span class="s3">null </span><span class="s1">!== root &amp;&amp; scheduleUpdateOnFiber(root, fiber, </span><span class="s4">1</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">mountState(initialState) {</span>
  <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
  <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">initialState &amp;&amp; (initialState = initialState());</span>
  <span class="s1">hook.memoizedState = hook.baseState = initialState;</span>
  <span class="s1">initialState = {</span>
    <span class="s1">pending: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">interleaved: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">lanes: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">dispatch: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">lastRenderedReducer: basicStateReducer,</span>
    <span class="s1">lastRenderedState: initialState</span>
  <span class="s1">};</span>
  <span class="s1">hook.queue = initialState;</span>
  <span class="s1">initialState = initialState.dispatch = dispatchSetState.bind(</span>
    <span class="s3">null</span><span class="s1">,</span>
    <span class="s1">currentlyRenderingFiber$1,</span>
    <span class="s1">initialState</span>
  <span class="s1">);</span>
  <span class="s3">return </span><span class="s1">[hook.memoizedState, initialState];</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pushEffect(tag, create, destroy, deps) {</span>
  <span class="s1">tag = { tag: tag, create: create, destroy: destroy, deps: deps, next: </span><span class="s3">null </span><span class="s1">};</span>
  <span class="s1">create = currentlyRenderingFiber$1.updateQueue;</span>
  <span class="s3">null </span><span class="s1">=== create</span>
    <span class="s1">? ((create = { lastEffect: </span><span class="s3">null</span><span class="s1">, stores: </span><span class="s3">null </span><span class="s1">}),</span>
      <span class="s1">(currentlyRenderingFiber$1.updateQueue = create),</span>
      <span class="s1">(create.lastEffect = tag.next = tag))</span>
    <span class="s1">: ((destroy = create.lastEffect),</span>
      <span class="s3">null </span><span class="s1">=== destroy</span>
        <span class="s1">? (create.lastEffect = tag.next = tag)</span>
        <span class="s1">: ((deps = destroy.next),</span>
          <span class="s1">(destroy.next = tag),</span>
          <span class="s1">(tag.next = deps),</span>
          <span class="s1">(create.lastEffect = tag)));</span>
  <span class="s3">return </span><span class="s1">tag;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateRef() {</span>
  <span class="s3">return </span><span class="s1">updateWorkInProgressHook().memoizedState;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">mountEffectImpl(fiberFlags, hookFlags, create, deps) {</span>
  <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
  <span class="s1">currentlyRenderingFiber$1.flags |= fiberFlags;</span>
  <span class="s1">hook.memoizedState = pushEffect(</span>
    <span class="s4">1 </span><span class="s1">| hookFlags,</span>
    <span class="s1">create,</span>
    <span class="s3">void </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s3">void </span><span class="s4">0 </span><span class="s1">=== deps ? </span><span class="s3">null </span><span class="s1">: deps</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateEffectImpl(fiberFlags, hookFlags, create, deps) {</span>
  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
  <span class="s1">deps = </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">=== deps ? </span><span class="s3">null </span><span class="s1">: deps;</span>
  <span class="s3">var </span><span class="s1">destroy = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== currentHook) {</span>
    <span class="s3">var </span><span class="s1">prevEffect = currentHook.memoizedState;</span>
    <span class="s1">destroy = prevEffect.destroy;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== deps &amp;&amp; areHookInputsEqual(deps, prevEffect.deps)) {</span>
      <span class="s1">hook.memoizedState = pushEffect(hookFlags, create, destroy, deps);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">currentlyRenderingFiber$1.flags |= fiberFlags;</span>
  <span class="s1">hook.memoizedState = pushEffect(</span><span class="s4">1 </span><span class="s1">| hookFlags, create, destroy, deps);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">mountEffect(create, deps) {</span>
  <span class="s3">return </span><span class="s1">mountEffectImpl(</span><span class="s4">8390656</span><span class="s1">, </span><span class="s4">8</span><span class="s1">, create, deps);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateEffect(create, deps) {</span>
  <span class="s3">return </span><span class="s1">updateEffectImpl(</span><span class="s4">2048</span><span class="s1">, </span><span class="s4">8</span><span class="s1">, create, deps);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateInsertionEffect(create, deps) {</span>
  <span class="s3">return </span><span class="s1">updateEffectImpl(</span><span class="s4">4</span><span class="s1">, </span><span class="s4">2</span><span class="s1">, create, deps);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateLayoutEffect(create, deps) {</span>
  <span class="s3">return </span><span class="s1">updateEffectImpl(</span><span class="s4">4</span><span class="s1">, </span><span class="s4">4</span><span class="s1">, create, deps);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">imperativeHandleEffect(create, ref) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">ref)</span>
    <span class="s3">return </span><span class="s1">(</span>
      <span class="s1">(create = create()),</span>
      <span class="s1">ref(create),</span>
      <span class="s3">function</span><span class="s1">() {</span>
        <span class="s1">ref(</span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== ref &amp;&amp; </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">!== ref)</span>
    <span class="s3">return </span><span class="s1">(</span>
      <span class="s1">(create = create()),</span>
      <span class="s1">(ref.current = create),</span>
      <span class="s3">function</span><span class="s1">() {</span>
        <span class="s1">ref.current = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateImperativeHandle(ref, create, deps) {</span>
  <span class="s1">deps = </span><span class="s3">null </span><span class="s1">!== deps &amp;&amp; </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">!== deps ? deps.concat([ref]) : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">updateEffectImpl(</span>
    <span class="s4">4</span><span class="s1">,</span>
    <span class="s4">4</span><span class="s1">,</span>
    <span class="s1">imperativeHandleEffect.bind(</span><span class="s3">null</span><span class="s1">, create, ref),</span>
    <span class="s1">deps</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">mountDebugValue() {}</span>
<span class="s3">function </span><span class="s1">updateCallback(callback, deps) {</span>
  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
  <span class="s1">deps = </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">=== deps ? </span><span class="s3">null </span><span class="s1">: deps;</span>
  <span class="s3">var </span><span class="s1">prevState = hook.memoizedState;</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s3">null </span><span class="s1">!== prevState &amp;&amp;</span>
    <span class="s3">null </span><span class="s1">!== deps &amp;&amp;</span>
    <span class="s1">areHookInputsEqual(deps, prevState[</span><span class="s4">1</span><span class="s1">])</span>
  <span class="s1">)</span>
    <span class="s3">return </span><span class="s1">prevState[</span><span class="s4">0</span><span class="s1">];</span>
  <span class="s1">hook.memoizedState = [callback, deps];</span>
  <span class="s3">return </span><span class="s1">callback;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateMemo(nextCreate, deps) {</span>
  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
  <span class="s1">deps = </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">=== deps ? </span><span class="s3">null </span><span class="s1">: deps;</span>
  <span class="s3">var </span><span class="s1">prevState = hook.memoizedState;</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s3">null </span><span class="s1">!== prevState &amp;&amp;</span>
    <span class="s3">null </span><span class="s1">!== deps &amp;&amp;</span>
    <span class="s1">areHookInputsEqual(deps, prevState[</span><span class="s4">1</span><span class="s1">])</span>
  <span class="s1">)</span>
    <span class="s3">return </span><span class="s1">prevState[</span><span class="s4">0</span><span class="s1">];</span>
  <span class="s1">nextCreate = nextCreate();</span>
  <span class="s1">hook.memoizedState = [nextCreate, deps];</span>
  <span class="s3">return </span><span class="s1">nextCreate;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateDeferredValueImpl(hook, prevValue, value) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (renderLanes &amp; </span><span class="s4">21</span><span class="s1">))</span>
    <span class="s3">return </span><span class="s1">(</span>
      <span class="s1">hook.baseState &amp;&amp; ((hook.baseState = !</span><span class="s4">1</span><span class="s1">), (didReceiveUpdate = !</span><span class="s4">0</span><span class="s1">)),</span>
      <span class="s1">(hook.memoizedState = value)</span>
    <span class="s1">);</span>
  <span class="s1">objectIs(value, prevValue) ||</span>
    <span class="s1">((value = claimNextTransitionLane()),</span>
    <span class="s1">(currentlyRenderingFiber$1.lanes |= value),</span>
    <span class="s1">(workInProgressRootSkippedLanes |= value),</span>
    <span class="s1">(hook.baseState = !</span><span class="s4">0</span><span class="s1">));</span>
  <span class="s3">return </span><span class="s1">prevValue;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">startTransition(setPending, callback) {</span>
  <span class="s3">var </span><span class="s1">previousPriority = currentUpdatePriority;</span>
  <span class="s1">currentUpdatePriority =</span>
    <span class="s4">0 </span><span class="s1">!== previousPriority &amp;&amp; </span><span class="s4">4 </span><span class="s1">&gt; previousPriority ? previousPriority : </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s1">setPending(!</span><span class="s4">0</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">prevTransition = ReactCurrentBatchConfig$1.transition;</span>
  <span class="s1">ReactCurrentBatchConfig$1.transition = {};</span>
  <span class="s3">try </span><span class="s1">{</span>
    <span class="s1">setPending(!</span><span class="s4">1</span><span class="s1">), callback();</span>
  <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
    <span class="s1">(currentUpdatePriority = previousPriority),</span>
      <span class="s1">(ReactCurrentBatchConfig$1.transition = prevTransition);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateId() {</span>
  <span class="s3">return </span><span class="s1">updateWorkInProgressHook().memoizedState;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">dispatchReducerAction(fiber, queue, action) {</span>
  <span class="s3">var </span><span class="s1">lane = requestUpdateLane(fiber);</span>
  <span class="s1">action = {</span>
    <span class="s1">lane: lane,</span>
    <span class="s1">action: action,</span>
    <span class="s1">hasEagerState: !</span><span class="s4">1</span><span class="s1">,</span>
    <span class="s1">eagerState: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">next: </span><span class="s3">null</span>
  <span class="s1">};</span>
  <span class="s3">if </span><span class="s1">(isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, action);</span>
  <span class="s3">else if </span><span class="s1">(</span>
    <span class="s1">((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),</span>
    <span class="s3">null </span><span class="s1">!== action)</span>
  <span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">eventTime = requestEventTime();</span>
    <span class="s1">scheduleUpdateOnFiber(action, fiber, lane, eventTime);</span>
    <span class="s1">entangleTransitionUpdate(action, queue, lane);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">dispatchSetState(fiber, queue, action) {</span>
  <span class="s3">var </span><span class="s1">lane = requestUpdateLane(fiber),</span>
    <span class="s1">update = {</span>
      <span class="s1">lane: lane,</span>
      <span class="s1">action: action,</span>
      <span class="s1">hasEagerState: !</span><span class="s4">1</span><span class="s1">,</span>
      <span class="s1">eagerState: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">next: </span><span class="s3">null</span>
    <span class="s1">};</span>
  <span class="s3">if </span><span class="s1">(isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);</span>
  <span class="s3">else </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s4">0 </span><span class="s1">=== fiber.lanes &amp;&amp;</span>
      <span class="s1">(</span><span class="s3">null </span><span class="s1">=== alternate || </span><span class="s4">0 </span><span class="s1">=== alternate.lanes) &amp;&amp;</span>
      <span class="s1">((alternate = queue.lastRenderedReducer), </span><span class="s3">null </span><span class="s1">!== alternate)</span>
    <span class="s1">)</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">currentState = queue.lastRenderedState,</span>
          <span class="s1">eagerState = alternate(currentState, action);</span>
        <span class="s1">update.hasEagerState = !</span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">update.eagerState = eagerState;</span>
        <span class="s3">if </span><span class="s1">(objectIs(eagerState, currentState)) {</span>
          <span class="s3">var </span><span class="s1">interleaved = queue.interleaved;</span>
          <span class="s3">null </span><span class="s1">=== interleaved</span>
            <span class="s1">? ((update.next = update), pushConcurrentUpdateQueue(queue))</span>
            <span class="s1">: ((update.next = interleaved.next), (interleaved.next = update));</span>
          <span class="s1">queue.interleaved = update;</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">}</span>
    <span class="s1">action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span>
    <span class="s3">null </span><span class="s1">!== action &amp;&amp;</span>
      <span class="s1">((update = requestEventTime()),</span>
      <span class="s1">scheduleUpdateOnFiber(action, fiber, lane, update),</span>
      <span class="s1">entangleTransitionUpdate(action, queue, lane));</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isRenderPhaseUpdate(fiber) {</span>
  <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>
  <span class="s3">return </span><span class="s1">(</span>
    <span class="s1">fiber === currentlyRenderingFiber$1 ||</span>
    <span class="s1">(</span><span class="s3">null </span><span class="s1">!== alternate &amp;&amp; alternate === currentlyRenderingFiber$1)</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">enqueueRenderPhaseUpdate(queue, update) {</span>
  <span class="s1">didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !</span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">pending = queue.pending;</span>
  <span class="s3">null </span><span class="s1">=== pending</span>
    <span class="s1">? (update.next = update)</span>
    <span class="s1">: ((update.next = pending.next), (pending.next = update));</span>
  <span class="s1">queue.pending = update;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">entangleTransitionUpdate(root, queue, lane) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (lane &amp; </span><span class="s4">4194240</span><span class="s1">)) {</span>
    <span class="s3">var </span><span class="s1">queueLanes = queue.lanes;</span>
    <span class="s1">queueLanes &amp;= root.pendingLanes;</span>
    <span class="s1">lane |= queueLanes;</span>
    <span class="s1">queue.lanes = lane;</span>
    <span class="s1">markRootEntangled(root, lane);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">ContextOnlyDispatcher = {</span>
    <span class="s1">readContext: readContext,</span>
    <span class="s1">useCallback: throwInvalidHookError,</span>
    <span class="s1">useContext: throwInvalidHookError,</span>
    <span class="s1">useEffect: throwInvalidHookError,</span>
    <span class="s1">useImperativeHandle: throwInvalidHookError,</span>
    <span class="s1">useInsertionEffect: throwInvalidHookError,</span>
    <span class="s1">useLayoutEffect: throwInvalidHookError,</span>
    <span class="s1">useMemo: throwInvalidHookError,</span>
    <span class="s1">useReducer: throwInvalidHookError,</span>
    <span class="s1">useRef: throwInvalidHookError,</span>
    <span class="s1">useState: throwInvalidHookError,</span>
    <span class="s1">useDebugValue: throwInvalidHookError,</span>
    <span class="s1">useDeferredValue: throwInvalidHookError,</span>
    <span class="s1">useTransition: throwInvalidHookError,</span>
    <span class="s1">useMutableSource: throwInvalidHookError,</span>
    <span class="s1">useSyncExternalStore: throwInvalidHookError,</span>
    <span class="s1">useId: throwInvalidHookError,</span>
    <span class="s1">unstable_isNewReconciler: !</span><span class="s4">1</span>
  <span class="s1">},</span>
  <span class="s1">HooksDispatcherOnMount = {</span>
    <span class="s1">readContext: readContext,</span>
    <span class="s1">useCallback: </span><span class="s3">function</span><span class="s1">(callback, deps) {</span>
      <span class="s1">mountWorkInProgressHook().memoizedState = [</span>
        <span class="s1">callback,</span>
        <span class="s3">void </span><span class="s4">0 </span><span class="s1">=== deps ? </span><span class="s3">null </span><span class="s1">: deps</span>
      <span class="s1">];</span>
      <span class="s3">return </span><span class="s1">callback;</span>
    <span class="s1">},</span>
    <span class="s1">useContext: readContext,</span>
    <span class="s1">useEffect: mountEffect,</span>
    <span class="s1">useImperativeHandle: </span><span class="s3">function</span><span class="s1">(ref, create, deps) {</span>
      <span class="s1">deps = </span><span class="s3">null </span><span class="s1">!== deps &amp;&amp; </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">!== deps ? deps.concat([ref]) : </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s1">mountEffectImpl(</span>
        <span class="s4">4</span><span class="s1">,</span>
        <span class="s4">4</span><span class="s1">,</span>
        <span class="s1">imperativeHandleEffect.bind(</span><span class="s3">null</span><span class="s1">, create, ref),</span>
        <span class="s1">deps</span>
      <span class="s1">);</span>
    <span class="s1">},</span>
    <span class="s1">useLayoutEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s3">return </span><span class="s1">mountEffectImpl(</span><span class="s4">4</span><span class="s1">, </span><span class="s4">4</span><span class="s1">, create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useInsertionEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s3">return </span><span class="s1">mountEffectImpl(</span><span class="s4">4</span><span class="s1">, </span><span class="s4">2</span><span class="s1">, create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useMemo: </span><span class="s3">function</span><span class="s1">(nextCreate, deps) {</span>
      <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
      <span class="s1">deps = </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">=== deps ? </span><span class="s3">null </span><span class="s1">: deps;</span>
      <span class="s1">nextCreate = nextCreate();</span>
      <span class="s1">hook.memoizedState = [nextCreate, deps];</span>
      <span class="s3">return </span><span class="s1">nextCreate;</span>
    <span class="s1">},</span>
    <span class="s1">useReducer: </span><span class="s3">function</span><span class="s1">(reducer, initialArg, init) {</span>
      <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
      <span class="s1">initialArg = </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">!== init ? init(initialArg) : initialArg;</span>
      <span class="s1">hook.memoizedState = hook.baseState = initialArg;</span>
      <span class="s1">reducer = {</span>
        <span class="s1">pending: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">interleaved: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">lanes: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">dispatch: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">lastRenderedReducer: reducer,</span>
        <span class="s1">lastRenderedState: initialArg</span>
      <span class="s1">};</span>
      <span class="s1">hook.queue = reducer;</span>
      <span class="s1">reducer = reducer.dispatch = dispatchReducerAction.bind(</span>
        <span class="s3">null</span><span class="s1">,</span>
        <span class="s1">currentlyRenderingFiber$1,</span>
        <span class="s1">reducer</span>
      <span class="s1">);</span>
      <span class="s3">return </span><span class="s1">[hook.memoizedState, reducer];</span>
    <span class="s1">},</span>
    <span class="s1">useRef: </span><span class="s3">function</span><span class="s1">(initialValue) {</span>
      <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
      <span class="s1">initialValue = { current: initialValue };</span>
      <span class="s3">return </span><span class="s1">(hook.memoizedState = initialValue);</span>
    <span class="s1">},</span>
    <span class="s1">useState: mountState,</span>
    <span class="s1">useDebugValue: mountDebugValue,</span>
    <span class="s1">useDeferredValue: </span><span class="s3">function</span><span class="s1">(value) {</span>
      <span class="s3">return </span><span class="s1">(mountWorkInProgressHook().memoizedState = value);</span>
    <span class="s1">},</span>
    <span class="s1">useTransition: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s3">var </span><span class="s1">_mountState = mountState(!</span><span class="s4">1</span><span class="s1">),</span>
        <span class="s1">isPending = _mountState[</span><span class="s4">0</span><span class="s1">];</span>
      <span class="s1">_mountState = startTransition.bind(</span><span class="s3">null</span><span class="s1">, _mountState[</span><span class="s4">1</span><span class="s1">]);</span>
      <span class="s1">mountWorkInProgressHook().memoizedState = _mountState;</span>
      <span class="s3">return </span><span class="s1">[isPending, _mountState];</span>
    <span class="s1">},</span>
    <span class="s1">useMutableSource: </span><span class="s3">function</span><span class="s1">() {},</span>
    <span class="s1">useSyncExternalStore: </span><span class="s3">function</span><span class="s1">(subscribe, getSnapshot) {</span>
      <span class="s3">var </span><span class="s1">fiber = currentlyRenderingFiber$1,</span>
        <span class="s1">hook = mountWorkInProgressHook();</span>
      <span class="s3">var </span><span class="s1">nextSnapshot = getSnapshot();</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== workInProgressRoot)</span>
        <span class="s3">throw </span><span class="s1">Error(</span>
          <span class="s2">&quot;Expected a work-in-progress root. This is a bug in React. Please file an issue.&quot;</span>
        <span class="s1">);</span>
      <span class="s4">0 </span><span class="s1">!== (renderLanes &amp; </span><span class="s4">30</span><span class="s1">) ||</span>
        <span class="s1">pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);</span>
      <span class="s1">hook.memoizedState = nextSnapshot;</span>
      <span class="s3">var </span><span class="s1">inst = { value: nextSnapshot, getSnapshot: getSnapshot };</span>
      <span class="s1">hook.queue = inst;</span>
      <span class="s1">mountEffect(subscribeToStore.bind(</span><span class="s3">null</span><span class="s1">, fiber, inst, subscribe), [</span>
        <span class="s1">subscribe</span>
      <span class="s1">]);</span>
      <span class="s1">fiber.flags |= </span><span class="s4">2048</span><span class="s1">;</span>
      <span class="s1">pushEffect(</span>
        <span class="s4">9</span><span class="s1">,</span>
        <span class="s1">updateStoreInstance.bind(</span><span class="s3">null</span><span class="s1">, fiber, inst, nextSnapshot, getSnapshot),</span>
        <span class="s3">void </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s3">null</span>
      <span class="s1">);</span>
      <span class="s3">return </span><span class="s1">nextSnapshot;</span>
    <span class="s1">},</span>
    <span class="s1">useId: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook(),</span>
        <span class="s1">identifierPrefix = workInProgressRoot.identifierPrefix,</span>
        <span class="s1">globalClientId = globalClientIdCounter++;</span>
      <span class="s1">identifierPrefix =</span>
        <span class="s2">&quot;:&quot; </span><span class="s1">+ identifierPrefix + </span><span class="s2">&quot;r&quot; </span><span class="s1">+ globalClientId.toString(</span><span class="s4">32</span><span class="s1">) + </span><span class="s2">&quot;:&quot;</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s1">(hook.memoizedState = identifierPrefix);</span>
    <span class="s1">},</span>
    <span class="s1">unstable_isNewReconciler: !</span><span class="s4">1</span>
  <span class="s1">},</span>
  <span class="s1">HooksDispatcherOnUpdate = {</span>
    <span class="s1">readContext: readContext,</span>
    <span class="s1">useCallback: updateCallback,</span>
    <span class="s1">useContext: readContext,</span>
    <span class="s1">useEffect: updateEffect,</span>
    <span class="s1">useImperativeHandle: updateImperativeHandle,</span>
    <span class="s1">useInsertionEffect: updateInsertionEffect,</span>
    <span class="s1">useLayoutEffect: updateLayoutEffect,</span>
    <span class="s1">useMemo: updateMemo,</span>
    <span class="s1">useReducer: updateReducer,</span>
    <span class="s1">useRef: updateRef,</span>
    <span class="s1">useState: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s3">return </span><span class="s1">updateReducer(basicStateReducer);</span>
    <span class="s1">},</span>
    <span class="s1">useDebugValue: mountDebugValue,</span>
    <span class="s1">useDeferredValue: </span><span class="s3">function</span><span class="s1">(value) {</span>
      <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
      <span class="s3">return </span><span class="s1">updateDeferredValueImpl(hook, currentHook.memoizedState, value);</span>
    <span class="s1">},</span>
    <span class="s1">useTransition: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s3">var </span><span class="s1">isPending = updateReducer(basicStateReducer)[</span><span class="s4">0</span><span class="s1">],</span>
        <span class="s1">start = updateWorkInProgressHook().memoizedState;</span>
      <span class="s3">return </span><span class="s1">[isPending, start];</span>
    <span class="s1">},</span>
    <span class="s1">useMutableSource: updateMutableSource,</span>
    <span class="s1">useSyncExternalStore: updateSyncExternalStore,</span>
    <span class="s1">useId: updateId,</span>
    <span class="s1">unstable_isNewReconciler: !</span><span class="s4">1</span>
  <span class="s1">},</span>
  <span class="s1">HooksDispatcherOnRerender = {</span>
    <span class="s1">readContext: readContext,</span>
    <span class="s1">useCallback: updateCallback,</span>
    <span class="s1">useContext: readContext,</span>
    <span class="s1">useEffect: updateEffect,</span>
    <span class="s1">useImperativeHandle: updateImperativeHandle,</span>
    <span class="s1">useInsertionEffect: updateInsertionEffect,</span>
    <span class="s1">useLayoutEffect: updateLayoutEffect,</span>
    <span class="s1">useMemo: updateMemo,</span>
    <span class="s1">useReducer: rerenderReducer,</span>
    <span class="s1">useRef: updateRef,</span>
    <span class="s1">useState: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s3">return </span><span class="s1">rerenderReducer(basicStateReducer);</span>
    <span class="s1">},</span>
    <span class="s1">useDebugValue: mountDebugValue,</span>
    <span class="s1">useDeferredValue: </span><span class="s3">function</span><span class="s1">(value) {</span>
      <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
      <span class="s3">return null </span><span class="s1">=== currentHook</span>
        <span class="s1">? (hook.memoizedState = value)</span>
        <span class="s1">: updateDeferredValueImpl(hook, currentHook.memoizedState, value);</span>
    <span class="s1">},</span>
    <span class="s1">useTransition: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s3">var </span><span class="s1">isPending = rerenderReducer(basicStateReducer)[</span><span class="s4">0</span><span class="s1">],</span>
        <span class="s1">start = updateWorkInProgressHook().memoizedState;</span>
      <span class="s3">return </span><span class="s1">[isPending, start];</span>
    <span class="s1">},</span>
    <span class="s1">useMutableSource: updateMutableSource,</span>
    <span class="s1">useSyncExternalStore: updateSyncExternalStore,</span>
    <span class="s1">useId: updateId,</span>
    <span class="s1">unstable_isNewReconciler: !</span><span class="s4">1</span>
  <span class="s1">},</span>
  <span class="s1">now$1 = Scheduler.unstable_now,</span>
  <span class="s1">commitTime = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">layoutEffectStartTime = -</span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">profilerStartTime = -</span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">passiveEffectStartTime = -</span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">currentUpdateIsNested = !</span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">nestedUpdateScheduled = !</span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">&lt;= profilerStartTime) {</span>
    <span class="s3">var </span><span class="s1">elapsedTime = now$1() - profilerStartTime;</span>
    <span class="s1">fiber.actualDuration += elapsedTime;</span>
    <span class="s1">overrideBaseTime &amp;&amp; (fiber.selfBaseDuration = elapsedTime);</span>
    <span class="s1">profilerStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">recordLayoutEffectDuration(fiber) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">&lt;= layoutEffectStartTime) {</span>
    <span class="s3">var </span><span class="s1">elapsedTime = now$1() - layoutEffectStartTime;</span>
    <span class="s1">layoutEffectStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">for </span><span class="s1">(fiber = fiber.</span><span class="s3">return</span><span class="s1">; </span><span class="s3">null </span><span class="s1">!== fiber; ) {</span>
      <span class="s3">switch </span><span class="s1">(fiber.tag) {</span>
        <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
          <span class="s1">fiber.stateNode.effectDuration += elapsedTime;</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">12</span><span class="s1">:</span>
          <span class="s1">fiber.stateNode.effectDuration += elapsedTime;</span>
          <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">fiber = fiber.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">recordPassiveEffectDuration(fiber) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">&lt;= passiveEffectStartTime) {</span>
    <span class="s3">var </span><span class="s1">elapsedTime = now$1() - passiveEffectStartTime;</span>
    <span class="s1">passiveEffectStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">for </span><span class="s1">(fiber = fiber.</span><span class="s3">return</span><span class="s1">; </span><span class="s3">null </span><span class="s1">!== fiber; ) {</span>
      <span class="s3">switch </span><span class="s1">(fiber.tag) {</span>
        <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
          <span class="s1">fiber = fiber.stateNode;</span>
          <span class="s3">null </span><span class="s1">!== fiber &amp;&amp; (fiber.passiveEffectDuration += elapsedTime);</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">12</span><span class="s1">:</span>
          <span class="s1">fiber = fiber.stateNode;</span>
          <span class="s3">null </span><span class="s1">!== fiber &amp;&amp; (fiber.passiveEffectDuration += elapsedTime);</span>
          <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">fiber = fiber.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">startLayoutEffectTimer() {</span>
  <span class="s1">layoutEffectStartTime = now$1();</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">transferActualDuration(fiber) {</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">child = fiber.child; child; )</span>
    <span class="s1">(fiber.actualDuration += child.actualDuration), (child = child.sibling);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createCapturedValueAtFiber(value, source) {</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">value: value,</span>
    <span class="s1">source: source,</span>
    <span class="s1">stack: getStackByFiberInDevAndProd(source),</span>
    <span class="s1">digest: </span><span class="s3">null</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createCapturedValue(value, digest, stack) {</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">value: value,</span>
    <span class="s1">source: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">stack: </span><span class="s3">null </span><span class="s1">!= stack ? stack : </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">digest: </span><span class="s3">null </span><span class="s1">!= digest ? digest : </span><span class="s3">null</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">if </span><span class="s1">(</span>
  <span class="s2">&quot;function&quot; </span><span class="s1">!==</span>
  <span class="s3">typeof </span><span class="s1">ReactNativePrivateInterface.ReactFiberErrorDialog.showErrorDialog</span>
<span class="s1">)</span>
  <span class="s3">throw </span><span class="s1">Error(</span>
    <span class="s2">&quot;Expected ReactFiberErrorDialog.showErrorDialog to be a function.&quot;</span>
  <span class="s1">);</span>
<span class="s3">function </span><span class="s1">logCapturedError(boundary, errorInfo) {</span>
  <span class="s3">try </span><span class="s1">{</span>
    <span class="s1">!</span><span class="s4">1 </span><span class="s1">!==</span>
      <span class="s1">ReactNativePrivateInterface.ReactFiberErrorDialog.showErrorDialog({</span>
        <span class="s1">componentStack: </span><span class="s3">null </span><span class="s1">!== errorInfo.stack ? errorInfo.stack : </span><span class="s2">&quot;&quot;</span><span class="s1">,</span>
        <span class="s1">error: errorInfo.value,</span>
        <span class="s1">errorBoundary:</span>
          <span class="s3">null </span><span class="s1">!== boundary &amp;&amp; </span><span class="s4">1 </span><span class="s1">=== boundary.tag ? boundary.stateNode : </span><span class="s3">null</span>
      <span class="s1">}) &amp;&amp; console.error(errorInfo.value);</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
    <span class="s1">setTimeout(</span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s3">throw </span><span class="s1">e;</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">PossiblyWeakMap = </span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">WeakMap ? WeakMap : Map;</span>
<span class="s3">function </span><span class="s1">createRootErrorUpdate(fiber, errorInfo, lane) {</span>
  <span class="s1">lane = createUpdate(-</span><span class="s4">1</span><span class="s1">, lane);</span>
  <span class="s1">lane.tag = </span><span class="s4">3</span><span class="s1">;</span>
  <span class="s1">lane.payload = { element: </span><span class="s3">null </span><span class="s1">};</span>
  <span class="s3">var </span><span class="s1">error = errorInfo.value;</span>
  <span class="s1">lane.callback = </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s1">hasUncaughtError || ((hasUncaughtError = !</span><span class="s4">0</span><span class="s1">), (firstUncaughtError = error));</span>
    <span class="s1">logCapturedError(fiber, errorInfo);</span>
  <span class="s1">};</span>
  <span class="s3">return </span><span class="s1">lane;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createClassErrorUpdate(fiber, errorInfo, lane) {</span>
  <span class="s1">lane = createUpdate(-</span><span class="s4">1</span><span class="s1">, lane);</span>
  <span class="s1">lane.tag = </span><span class="s4">3</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">getDerivedStateFromError = fiber.type.getDerivedStateFromError;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">getDerivedStateFromError) {</span>
    <span class="s3">var </span><span class="s1">error = errorInfo.value;</span>
    <span class="s1">lane.payload = </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s3">return </span><span class="s1">getDerivedStateFromError(error);</span>
    <span class="s1">};</span>
    <span class="s1">lane.callback = </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">logCapturedError(fiber, errorInfo);</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">inst = fiber.stateNode;</span>
  <span class="s3">null </span><span class="s1">!== inst &amp;&amp;</span>
    <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">inst.componentDidCatch &amp;&amp;</span>
    <span class="s1">(lane.callback = </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">logCapturedError(fiber, errorInfo);</span>
      <span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">getDerivedStateFromError &amp;&amp;</span>
        <span class="s1">(</span><span class="s3">null </span><span class="s1">=== legacyErrorBoundariesThatAlreadyFailed</span>
          <span class="s1">? (legacyErrorBoundariesThatAlreadyFailed = </span><span class="s3">new </span><span class="s1">Set([</span><span class="s3">this</span><span class="s1">]))</span>
          <span class="s1">: legacyErrorBoundariesThatAlreadyFailed.add(</span><span class="s3">this</span><span class="s1">));</span>
      <span class="s3">var </span><span class="s1">stack = errorInfo.stack;</span>
      <span class="s3">this</span><span class="s1">.componentDidCatch(errorInfo.value, {</span>
        <span class="s1">componentStack: </span><span class="s3">null </span><span class="s1">!== stack ? stack : </span><span class="s2">&quot;&quot;</span>
      <span class="s1">});</span>
    <span class="s1">});</span>
  <span class="s3">return </span><span class="s1">lane;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">attachPingListener(root, wakeable, lanes) {</span>
  <span class="s3">var </span><span class="s1">pingCache = root.pingCache;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== pingCache) {</span>
    <span class="s1">pingCache = root.pingCache = </span><span class="s3">new </span><span class="s1">PossiblyWeakMap();</span>
    <span class="s3">var </span><span class="s1">threadIDs = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">pingCache.set(wakeable, threadIDs);</span>
  <span class="s1">} </span><span class="s3">else</span>
    <span class="s1">(threadIDs = pingCache.get(wakeable)),</span>
      <span class="s3">void </span><span class="s4">0 </span><span class="s1">=== threadIDs &amp;&amp;</span>
        <span class="s1">((threadIDs = </span><span class="s3">new </span><span class="s1">Set()), pingCache.set(wakeable, threadIDs));</span>
  <span class="s1">threadIDs.has(lanes) ||</span>
    <span class="s1">(threadIDs.add(lanes),</span>
    <span class="s1">(pingCache = pingSuspendedRoot.bind(</span><span class="s3">null</span><span class="s1">, root, wakeable, lanes)),</span>
    <span class="s1">isDevToolsPresent &amp;&amp; restorePendingUpdaters(root, lanes),</span>
    <span class="s1">wakeable.then(pingCache, pingCache));</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner,</span>
  <span class="s1">didReceiveUpdate = !</span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes) {</span>
  <span class="s1">workInProgress.child =</span>
    <span class="s3">null </span><span class="s1">=== current</span>
      <span class="s1">? mountChildFibers(workInProgress, </span><span class="s3">null</span><span class="s1">, nextChildren, renderLanes)</span>
      <span class="s1">: reconcileChildFibers(</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">current.child,</span>
          <span class="s1">nextChildren,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateForwardRef(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">nextProps,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s1">Component = Component.render;</span>
  <span class="s3">var </span><span class="s1">ref = workInProgress.ref;</span>
  <span class="s1">prepareToReadContext(workInProgress, renderLanes);</span>
  <span class="s1">nextProps = renderWithHooks(</span>
    <span class="s1">current,</span>
    <span class="s1">workInProgress,</span>
    <span class="s1">Component,</span>
    <span class="s1">nextProps,</span>
    <span class="s1">ref,</span>
    <span class="s1">renderLanes</span>
  <span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== current &amp;&amp; !didReceiveUpdate)</span>
    <span class="s3">return </span><span class="s1">(</span>
      <span class="s1">(workInProgress.updateQueue = current.updateQueue),</span>
      <span class="s1">(workInProgress.flags &amp;= -</span><span class="s4">2053</span><span class="s1">),</span>
      <span class="s1">(current.lanes &amp;= ~renderLanes),</span>
      <span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)</span>
    <span class="s1">);</span>
  <span class="s1">workInProgress.flags |= </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">reconcileChildren(current, workInProgress, nextProps, renderLanes);</span>
  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateMemoComponent(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">nextProps,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== current) {</span>
    <span class="s3">var </span><span class="s1">type = Component.type;</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">type &amp;&amp;</span>
      <span class="s1">!shouldConstruct(type) &amp;&amp;</span>
      <span class="s3">void </span><span class="s4">0 </span><span class="s1">=== type.defaultProps &amp;&amp;</span>
      <span class="s3">null </span><span class="s1">=== Component.compare &amp;&amp;</span>
      <span class="s3">void </span><span class="s4">0 </span><span class="s1">=== Component.defaultProps</span>
    <span class="s1">)</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(workInProgress.tag = </span><span class="s4">15</span><span class="s1">),</span>
        <span class="s1">(workInProgress.type = type),</span>
        <span class="s1">updateSimpleMemoComponent(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">type,</span>
          <span class="s1">nextProps,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">)</span>
      <span class="s1">);</span>
    <span class="s1">current = createFiberFromTypeAndProps(</span>
      <span class="s1">Component.type,</span>
      <span class="s3">null</span><span class="s1">,</span>
      <span class="s1">nextProps,</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">workInProgress.mode,</span>
      <span class="s1">renderLanes</span>
    <span class="s1">);</span>
    <span class="s1">current.ref = workInProgress.ref;</span>
    <span class="s1">current.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
    <span class="s3">return </span><span class="s1">(workInProgress.child = current);</span>
  <span class="s1">}</span>
  <span class="s1">type = current.child;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (current.lanes &amp; renderLanes)) {</span>
    <span class="s3">var </span><span class="s1">prevProps = type.memoizedProps;</span>
    <span class="s1">Component = Component.compare;</span>
    <span class="s1">Component = </span><span class="s3">null </span><span class="s1">!== Component ? Component : shallowEqual;</span>
    <span class="s3">if </span><span class="s1">(Component(prevProps, nextProps) &amp;&amp; current.ref === workInProgress.ref)</span>
      <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
  <span class="s1">}</span>
  <span class="s1">workInProgress.flags |= </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">current = createWorkInProgress(type, nextProps);</span>
  <span class="s1">current.ref = workInProgress.ref;</span>
  <span class="s1">current.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
  <span class="s3">return </span><span class="s1">(workInProgress.child = current);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateSimpleMemoComponent(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">nextProps,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== current) {</span>
    <span class="s3">var </span><span class="s1">prevProps = current.memoizedProps;</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">shallowEqual(prevProps, nextProps) &amp;&amp;</span>
      <span class="s1">current.ref === workInProgress.ref</span>
    <span class="s1">)</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">((didReceiveUpdate = !</span><span class="s4">1</span><span class="s1">),</span>
        <span class="s1">(workInProgress.pendingProps = nextProps = prevProps),</span>
        <span class="s4">0 </span><span class="s1">!== (current.lanes &amp; renderLanes))</span>
      <span class="s1">)</span>
        <span class="s4">0 </span><span class="s1">!== (current.flags &amp; </span><span class="s4">131072</span><span class="s1">) &amp;&amp; (didReceiveUpdate = !</span><span class="s4">0</span><span class="s1">);</span>
      <span class="s3">else</span>
        <span class="s3">return </span><span class="s1">(</span>
          <span class="s1">(workInProgress.lanes = current.lanes),</span>
          <span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)</span>
        <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">updateFunctionComponent(</span>
    <span class="s1">current,</span>
    <span class="s1">workInProgress,</span>
    <span class="s1">Component,</span>
    <span class="s1">nextProps,</span>
    <span class="s1">renderLanes</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateOffscreenComponent(current, workInProgress, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">nextProps = workInProgress.pendingProps,</span>
    <span class="s1">nextChildren = nextProps.children,</span>
    <span class="s1">prevState = </span><span class="s3">null </span><span class="s1">!== current ? current.memoizedState : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;hidden&quot; </span><span class="s1">=== nextProps.mode)</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (workInProgress.mode &amp; </span><span class="s4">1</span><span class="s1">))</span>
      <span class="s1">(workInProgress.memoizedState = {</span>
        <span class="s1">baseLanes: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">cachePool: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">transitions: </span><span class="s3">null</span>
      <span class="s1">}),</span>
        <span class="s1">push(subtreeRenderLanesCursor, subtreeRenderLanes),</span>
        <span class="s1">(subtreeRenderLanes |= renderLanes);</span>
    <span class="s3">else </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (renderLanes &amp; </span><span class="s4">1073741824</span><span class="s1">))</span>
        <span class="s3">return </span><span class="s1">(</span>
          <span class="s1">(current =</span>
            <span class="s3">null </span><span class="s1">!== prevState</span>
              <span class="s1">? prevState.baseLanes | renderLanes</span>
              <span class="s1">: renderLanes),</span>
          <span class="s1">(workInProgress.lanes = workInProgress.childLanes = </span><span class="s4">1073741824</span><span class="s1">),</span>
          <span class="s1">(workInProgress.memoizedState = {</span>
            <span class="s1">baseLanes: current,</span>
            <span class="s1">cachePool: </span><span class="s3">null</span><span class="s1">,</span>
            <span class="s1">transitions: </span><span class="s3">null</span>
          <span class="s1">}),</span>
          <span class="s1">(workInProgress.updateQueue = </span><span class="s3">null</span><span class="s1">),</span>
          <span class="s1">push(subtreeRenderLanesCursor, subtreeRenderLanes),</span>
          <span class="s1">(subtreeRenderLanes |= current),</span>
          <span class="s3">null</span>
        <span class="s1">);</span>
      <span class="s1">workInProgress.memoizedState = {</span>
        <span class="s1">baseLanes: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">cachePool: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">transitions: </span><span class="s3">null</span>
      <span class="s1">};</span>
      <span class="s1">nextProps = </span><span class="s3">null </span><span class="s1">!== prevState ? prevState.baseLanes : renderLanes;</span>
      <span class="s1">push(subtreeRenderLanesCursor, subtreeRenderLanes);</span>
      <span class="s1">subtreeRenderLanes |= nextProps;</span>
    <span class="s1">}</span>
  <span class="s3">else</span>
    <span class="s3">null </span><span class="s1">!== prevState</span>
      <span class="s1">? ((nextProps = prevState.baseLanes | renderLanes),</span>
        <span class="s1">(workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">))</span>
      <span class="s1">: (nextProps = renderLanes),</span>
      <span class="s1">push(subtreeRenderLanesCursor, subtreeRenderLanes),</span>
      <span class="s1">(subtreeRenderLanes |= nextProps);</span>
  <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">markRef(current, workInProgress) {</span>
  <span class="s3">var </span><span class="s1">ref = workInProgress.ref;</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">(</span><span class="s3">null </span><span class="s1">=== current &amp;&amp; </span><span class="s3">null </span><span class="s1">!== ref) ||</span>
    <span class="s1">(</span><span class="s3">null </span><span class="s1">!== current &amp;&amp; current.ref !== ref)</span>
  <span class="s1">)</span>
    <span class="s1">workInProgress.flags |= </span><span class="s4">512</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateFunctionComponent(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">nextProps,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">context = isContextProvider(Component)</span>
    <span class="s1">? previousContext</span>
    <span class="s1">: contextStackCursor.current;</span>
  <span class="s1">context = getMaskedContext(workInProgress, context);</span>
  <span class="s1">prepareToReadContext(workInProgress, renderLanes);</span>
  <span class="s1">Component = renderWithHooks(</span>
    <span class="s1">current,</span>
    <span class="s1">workInProgress,</span>
    <span class="s1">Component,</span>
    <span class="s1">nextProps,</span>
    <span class="s1">context,</span>
    <span class="s1">renderLanes</span>
  <span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== current &amp;&amp; !didReceiveUpdate)</span>
    <span class="s3">return </span><span class="s1">(</span>
      <span class="s1">(workInProgress.updateQueue = current.updateQueue),</span>
      <span class="s1">(workInProgress.flags &amp;= -</span><span class="s4">2053</span><span class="s1">),</span>
      <span class="s1">(current.lanes &amp;= ~renderLanes),</span>
      <span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)</span>
    <span class="s1">);</span>
  <span class="s1">workInProgress.flags |= </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">reconcileChildren(current, workInProgress, Component, renderLanes);</span>
  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateClassComponent(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">nextProps,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
    <span class="s3">var </span><span class="s1">hasContext = !</span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">pushContextProvider(workInProgress);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">hasContext = !</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">prepareToReadContext(workInProgress, renderLanes);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== workInProgress.stateNode)</span>
    <span class="s1">resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress),</span>
      <span class="s1">constructClassInstance(workInProgress, Component, nextProps),</span>
      <span class="s1">mountClassInstance(workInProgress, Component, nextProps, renderLanes),</span>
      <span class="s1">(nextProps = !</span><span class="s4">0</span><span class="s1">);</span>
  <span class="s3">else if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== current) {</span>
    <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode,</span>
      <span class="s1">oldProps = workInProgress.memoizedProps;</span>
    <span class="s1">instance.props = oldProps;</span>
    <span class="s3">var </span><span class="s1">oldContext = instance.context,</span>
      <span class="s1">contextType = Component.contextType;</span>
    <span class="s2">&quot;object&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">contextType &amp;&amp; </span><span class="s3">null </span><span class="s1">!== contextType</span>
      <span class="s1">? (contextType = readContext(contextType))</span>
      <span class="s1">: ((contextType = isContextProvider(Component)</span>
          <span class="s1">? previousContext</span>
          <span class="s1">: contextStackCursor.current),</span>
        <span class="s1">(contextType = getMaskedContext(workInProgress, contextType)));</span>
    <span class="s3">var </span><span class="s1">getDerivedStateFromProps = Component.getDerivedStateFromProps,</span>
      <span class="s1">hasNewLifecycles =</span>
        <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">getDerivedStateFromProps ||</span>
        <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate;</span>
    <span class="s1">hasNewLifecycles ||</span>
      <span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps &amp;&amp;</span>
        <span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">instance.componentWillReceiveProps) ||</span>
      <span class="s1">((oldProps !== nextProps || oldContext !== contextType) &amp;&amp;</span>
        <span class="s1">callComponentWillReceiveProps(</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">instance,</span>
          <span class="s1">nextProps,</span>
          <span class="s1">contextType</span>
        <span class="s1">));</span>
    <span class="s1">hasForceUpdate = !</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">oldState = workInProgress.memoizedState;</span>
    <span class="s1">instance.state = oldState;</span>
    <span class="s1">processUpdateQueue(workInProgress, nextProps, instance, renderLanes);</span>
    <span class="s1">oldContext = workInProgress.memoizedState;</span>
    <span class="s1">oldProps !== nextProps ||</span>
    <span class="s1">oldState !== oldContext ||</span>
    <span class="s1">didPerformWorkStackCursor.current ||</span>
    <span class="s1">hasForceUpdate</span>
      <span class="s1">? (</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">getDerivedStateFromProps &amp;&amp;</span>
          <span class="s1">(applyDerivedStateFromProps(</span>
            <span class="s1">workInProgress,</span>
            <span class="s1">Component,</span>
            <span class="s1">getDerivedStateFromProps,</span>
            <span class="s1">nextProps</span>
          <span class="s1">),</span>
          <span class="s1">(oldContext = workInProgress.memoizedState)),</span>
        <span class="s1">(oldProps =</span>
          <span class="s1">hasForceUpdate ||</span>
          <span class="s1">checkShouldComponentUpdate(</span>
            <span class="s1">workInProgress,</span>
            <span class="s1">Component,</span>
            <span class="s1">oldProps,</span>
            <span class="s1">nextProps,</span>
            <span class="s1">oldState,</span>
            <span class="s1">oldContext,</span>
            <span class="s1">contextType</span>
          <span class="s1">))</span>
          <span class="s1">? (hasNewLifecycles ||</span>
              <span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillMount &amp;&amp;</span>
                <span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">instance.componentWillMount) ||</span>
              <span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.componentWillMount &amp;&amp;</span>
                <span class="s1">instance.componentWillMount(),</span>
              <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillMount &amp;&amp;</span>
                <span class="s1">instance.UNSAFE_componentWillMount()),</span>
            <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.componentDidMount &amp;&amp;</span>
              <span class="s1">(workInProgress.flags |= </span><span class="s4">4</span><span class="s1">))</span>
          <span class="s1">: (</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.componentDidMount &amp;&amp;</span>
              <span class="s1">(workInProgress.flags |= </span><span class="s4">4</span><span class="s1">),</span>
            <span class="s1">(workInProgress.memoizedProps = nextProps),</span>
            <span class="s1">(workInProgress.memoizedState = oldContext)),</span>
        <span class="s1">(instance.props = nextProps),</span>
        <span class="s1">(instance.state = oldContext),</span>
        <span class="s1">(instance.context = contextType),</span>
        <span class="s1">(nextProps = oldProps))</span>
      <span class="s1">: (</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.componentDidMount &amp;&amp;</span>
          <span class="s1">(workInProgress.flags |= </span><span class="s4">4</span><span class="s1">),</span>
        <span class="s1">(nextProps = !</span><span class="s4">1</span><span class="s1">));</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">instance = workInProgress.stateNode;</span>
    <span class="s1">cloneUpdateQueue(current, workInProgress);</span>
    <span class="s1">oldProps = workInProgress.memoizedProps;</span>
    <span class="s1">contextType =</span>
      <span class="s1">workInProgress.type === workInProgress.elementType</span>
        <span class="s1">? oldProps</span>
        <span class="s1">: resolveDefaultProps(workInProgress.type, oldProps);</span>
    <span class="s1">instance.props = contextType;</span>
    <span class="s1">hasNewLifecycles = workInProgress.pendingProps;</span>
    <span class="s1">oldState = instance.context;</span>
    <span class="s1">oldContext = Component.contextType;</span>
    <span class="s2">&quot;object&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">oldContext &amp;&amp; </span><span class="s3">null </span><span class="s1">!== oldContext</span>
      <span class="s1">? (oldContext = readContext(oldContext))</span>
      <span class="s1">: ((oldContext = isContextProvider(Component)</span>
          <span class="s1">? previousContext</span>
          <span class="s1">: contextStackCursor.current),</span>
        <span class="s1">(oldContext = getMaskedContext(workInProgress, oldContext)));</span>
    <span class="s3">var </span><span class="s1">getDerivedStateFromProps$jscomp$0 = Component.getDerivedStateFromProps;</span>
    <span class="s1">(getDerivedStateFromProps =</span>
      <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">getDerivedStateFromProps$jscomp$0 ||</span>
      <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate) ||</span>
      <span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps &amp;&amp;</span>
        <span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">instance.componentWillReceiveProps) ||</span>
      <span class="s1">((oldProps !== hasNewLifecycles || oldState !== oldContext) &amp;&amp;</span>
        <span class="s1">callComponentWillReceiveProps(</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">instance,</span>
          <span class="s1">nextProps,</span>
          <span class="s1">oldContext</span>
        <span class="s1">));</span>
    <span class="s1">hasForceUpdate = !</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">oldState = workInProgress.memoizedState;</span>
    <span class="s1">instance.state = oldState;</span>
    <span class="s1">processUpdateQueue(workInProgress, nextProps, instance, renderLanes);</span>
    <span class="s3">var </span><span class="s1">newState = workInProgress.memoizedState;</span>
    <span class="s1">oldProps !== hasNewLifecycles ||</span>
    <span class="s1">oldState !== newState ||</span>
    <span class="s1">didPerformWorkStackCursor.current ||</span>
    <span class="s1">hasForceUpdate</span>
      <span class="s1">? (</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">getDerivedStateFromProps$jscomp$0 &amp;&amp;</span>
          <span class="s1">(applyDerivedStateFromProps(</span>
            <span class="s1">workInProgress,</span>
            <span class="s1">Component,</span>
            <span class="s1">getDerivedStateFromProps$jscomp$0,</span>
            <span class="s1">nextProps</span>
          <span class="s1">),</span>
          <span class="s1">(newState = workInProgress.memoizedState)),</span>
        <span class="s1">(contextType =</span>
          <span class="s1">hasForceUpdate ||</span>
          <span class="s1">checkShouldComponentUpdate(</span>
            <span class="s1">workInProgress,</span>
            <span class="s1">Component,</span>
            <span class="s1">contextType,</span>
            <span class="s1">nextProps,</span>
            <span class="s1">oldState,</span>
            <span class="s1">newState,</span>
            <span class="s1">oldContext</span>
          <span class="s1">) ||</span>
          <span class="s1">!</span><span class="s4">1</span><span class="s1">)</span>
          <span class="s1">? (getDerivedStateFromProps ||</span>
              <span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillUpdate &amp;&amp;</span>
                <span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">instance.componentWillUpdate) ||</span>
              <span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.componentWillUpdate &amp;&amp;</span>
                <span class="s1">instance.componentWillUpdate(nextProps, newState, oldContext),</span>
              <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillUpdate &amp;&amp;</span>
                <span class="s1">instance.UNSAFE_componentWillUpdate(</span>
                  <span class="s1">nextProps,</span>
                  <span class="s1">newState,</span>
                  <span class="s1">oldContext</span>
                <span class="s1">)),</span>
            <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.componentDidUpdate &amp;&amp;</span>
              <span class="s1">(workInProgress.flags |= </span><span class="s4">4</span><span class="s1">),</span>
            <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate &amp;&amp;</span>
              <span class="s1">(workInProgress.flags |= </span><span class="s4">1024</span><span class="s1">))</span>
          <span class="s1">: (</span><span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">instance.componentDidUpdate ||</span>
              <span class="s1">(oldProps === current.memoizedProps &amp;&amp;</span>
                <span class="s1">oldState === current.memoizedState) ||</span>
              <span class="s1">(workInProgress.flags |= </span><span class="s4">4</span><span class="s1">),</span>
            <span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate ||</span>
              <span class="s1">(oldProps === current.memoizedProps &amp;&amp;</span>
                <span class="s1">oldState === current.memoizedState) ||</span>
              <span class="s1">(workInProgress.flags |= </span><span class="s4">1024</span><span class="s1">),</span>
            <span class="s1">(workInProgress.memoizedProps = nextProps),</span>
            <span class="s1">(workInProgress.memoizedState = newState)),</span>
        <span class="s1">(instance.props = nextProps),</span>
        <span class="s1">(instance.state = newState),</span>
        <span class="s1">(instance.context = oldContext),</span>
        <span class="s1">(nextProps = contextType))</span>
      <span class="s1">: (</span><span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">instance.componentDidUpdate ||</span>
          <span class="s1">(oldProps === current.memoizedProps &amp;&amp;</span>
            <span class="s1">oldState === current.memoizedState) ||</span>
          <span class="s1">(workInProgress.flags |= </span><span class="s4">4</span><span class="s1">),</span>
        <span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate ||</span>
          <span class="s1">(oldProps === current.memoizedProps &amp;&amp;</span>
            <span class="s1">oldState === current.memoizedState) ||</span>
          <span class="s1">(workInProgress.flags |= </span><span class="s4">1024</span><span class="s1">),</span>
        <span class="s1">(nextProps = !</span><span class="s4">1</span><span class="s1">));</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">finishClassComponent(</span>
    <span class="s1">current,</span>
    <span class="s1">workInProgress,</span>
    <span class="s1">Component,</span>
    <span class="s1">nextProps,</span>
    <span class="s1">hasContext,</span>
    <span class="s1">renderLanes</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">finishClassComponent(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">shouldUpdate,</span>
  <span class="s1">hasContext,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s1">markRef(current, workInProgress);</span>
  <span class="s3">var </span><span class="s1">didCaptureError = </span><span class="s4">0 </span><span class="s1">!== (workInProgress.flags &amp; </span><span class="s4">128</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(!shouldUpdate &amp;&amp; !didCaptureError)</span>
    <span class="s3">return </span><span class="s1">(</span>
      <span class="s1">hasContext &amp;&amp; invalidateContextProvider(workInProgress, Component, !</span><span class="s4">1</span><span class="s1">),</span>
      <span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)</span>
    <span class="s1">);</span>
  <span class="s1">shouldUpdate = workInProgress.stateNode;</span>
  <span class="s1">ReactCurrentOwner$1.current = workInProgress;</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">didCaptureError &amp;&amp;</span>
    <span class="s2">&quot;function&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">Component.getDerivedStateFromError</span>
  <span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">nextChildren = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">profilerStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">nextChildren = shouldUpdate.render();</span>
  <span class="s1">workInProgress.flags |= </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">null </span><span class="s1">!== current &amp;&amp; didCaptureError</span>
    <span class="s1">? ((didCaptureError = nextChildren),</span>
      <span class="s1">(workInProgress.child = reconcileChildFibers(</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">current.child,</span>
        <span class="s3">null</span><span class="s1">,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">)),</span>
      <span class="s1">(workInProgress.child = reconcileChildFibers(</span>
        <span class="s1">workInProgress,</span>
        <span class="s3">null</span><span class="s1">,</span>
        <span class="s1">didCaptureError,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">)))</span>
    <span class="s1">: reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
  <span class="s1">workInProgress.memoizedState = shouldUpdate.state;</span>
  <span class="s1">hasContext &amp;&amp; invalidateContextProvider(workInProgress, Component, !</span><span class="s4">0</span><span class="s1">);</span>
  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pushHostRootContext(workInProgress) {</span>
  <span class="s3">var </span><span class="s1">root = workInProgress.stateNode;</span>
  <span class="s1">root.pendingContext</span>
    <span class="s1">? pushTopLevelContextObject(</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">root.pendingContext,</span>
        <span class="s1">root.pendingContext !== root.context</span>
      <span class="s1">)</span>
    <span class="s1">: root.context &amp;&amp;</span>
      <span class="s1">pushTopLevelContextObject(workInProgress, root.context, !</span><span class="s4">1</span><span class="s1">);</span>
  <span class="s1">pushHostContainer(workInProgress, root.containerInfo);</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">SUSPENDED_MARKER = { dehydrated: </span><span class="s3">null</span><span class="s1">, treeContext: </span><span class="s3">null</span><span class="s1">, retryLane: </span><span class="s4">0 </span><span class="s1">};</span>
<span class="s3">function </span><span class="s1">mountSuspenseOffscreenState(renderLanes) {</span>
  <span class="s3">return </span><span class="s1">{ baseLanes: renderLanes, cachePool: </span><span class="s3">null</span><span class="s1">, transitions: </span><span class="s3">null </span><span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateSuspenseComponent(current, workInProgress, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">nextProps = workInProgress.pendingProps,</span>
    <span class="s1">suspenseContext = suspenseStackCursor.current,</span>
    <span class="s1">showFallback = !</span><span class="s4">1</span><span class="s1">,</span>
    <span class="s1">didSuspend = </span><span class="s4">0 </span><span class="s1">!== (workInProgress.flags &amp; </span><span class="s4">128</span><span class="s1">),</span>
    <span class="s1">JSCompiler_temp;</span>
  <span class="s1">(JSCompiler_temp = didSuspend) ||</span>
    <span class="s1">(JSCompiler_temp =</span>
      <span class="s3">null </span><span class="s1">!== current &amp;&amp; </span><span class="s3">null </span><span class="s1">=== current.memoizedState</span>
        <span class="s1">? !</span><span class="s4">1</span>
        <span class="s1">: </span><span class="s4">0 </span><span class="s1">!== (suspenseContext &amp; </span><span class="s4">2</span><span class="s1">));</span>
  <span class="s3">if </span><span class="s1">(JSCompiler_temp) (showFallback = !</span><span class="s4">0</span><span class="s1">), (workInProgress.flags &amp;= -</span><span class="s4">129</span><span class="s1">);</span>
  <span class="s3">else if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== current || </span><span class="s3">null </span><span class="s1">!== current.memoizedState)</span>
    <span class="s1">suspenseContext |= </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">push(suspenseStackCursor, suspenseContext &amp; </span><span class="s4">1</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== current) {</span>
    <span class="s1">current = workInProgress.memoizedState;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== current &amp;&amp; </span><span class="s3">null </span><span class="s1">!== current.dehydrated)</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s4">0 </span><span class="s1">=== (workInProgress.mode &amp; </span><span class="s4">1</span><span class="s1">)</span>
          <span class="s1">? (workInProgress.lanes = </span><span class="s4">1</span><span class="s1">)</span>
          <span class="s1">: shim()</span>
          <span class="s1">? (workInProgress.lanes = </span><span class="s4">8</span><span class="s1">)</span>
          <span class="s1">: (workInProgress.lanes = </span><span class="s4">1073741824</span><span class="s1">),</span>
        <span class="s3">null</span>
      <span class="s1">);</span>
    <span class="s1">didSuspend = nextProps.children;</span>
    <span class="s1">current = nextProps.fallback;</span>
    <span class="s3">return </span><span class="s1">showFallback</span>
      <span class="s1">? ((nextProps = workInProgress.mode),</span>
        <span class="s1">(showFallback = workInProgress.child),</span>
        <span class="s1">(didSuspend = { mode: </span><span class="s2">&quot;hidden&quot;</span><span class="s1">, children: didSuspend }),</span>
        <span class="s4">0 </span><span class="s1">=== (nextProps &amp; </span><span class="s4">1</span><span class="s1">) &amp;&amp; </span><span class="s3">null </span><span class="s1">!== showFallback</span>
          <span class="s1">? ((showFallback.childLanes = </span><span class="s4">0</span><span class="s1">),</span>
            <span class="s1">(showFallback.pendingProps = didSuspend),</span>
            <span class="s1">workInProgress.mode &amp; </span><span class="s4">2 </span><span class="s1">&amp;&amp;</span>
              <span class="s1">((showFallback.actualDuration = </span><span class="s4">0</span><span class="s1">),</span>
              <span class="s1">(showFallback.actualStartTime = -</span><span class="s4">1</span><span class="s1">),</span>
              <span class="s1">(showFallback.selfBaseDuration = </span><span class="s4">0</span><span class="s1">),</span>
              <span class="s1">(showFallback.treeBaseDuration = </span><span class="s4">0</span><span class="s1">)))</span>
          <span class="s1">: (showFallback = createFiberFromOffscreen(</span>
              <span class="s1">didSuspend,</span>
              <span class="s1">nextProps,</span>
              <span class="s4">0</span><span class="s1">,</span>
              <span class="s3">null</span>
            <span class="s1">)),</span>
        <span class="s1">(current = createFiberFromFragment(</span>
          <span class="s1">current,</span>
          <span class="s1">nextProps,</span>
          <span class="s1">renderLanes,</span>
          <span class="s3">null</span>
        <span class="s1">)),</span>
        <span class="s1">(showFallback.</span><span class="s3">return </span><span class="s1">= workInProgress),</span>
        <span class="s1">(current.</span><span class="s3">return </span><span class="s1">= workInProgress),</span>
        <span class="s1">(showFallback.sibling = current),</span>
        <span class="s1">(workInProgress.child = showFallback),</span>
        <span class="s1">(workInProgress.child.memoizedState = mountSuspenseOffscreenState(</span>
          <span class="s1">renderLanes</span>
        <span class="s1">)),</span>
        <span class="s1">(workInProgress.memoizedState = SUSPENDED_MARKER),</span>
        <span class="s1">current)</span>
      <span class="s1">: mountSuspensePrimaryChildren(workInProgress, didSuspend);</span>
  <span class="s1">}</span>
  <span class="s1">suspenseContext = current.memoizedState;</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s3">null </span><span class="s1">!== suspenseContext &amp;&amp;</span>
    <span class="s1">((JSCompiler_temp = suspenseContext.dehydrated), </span><span class="s3">null </span><span class="s1">!== JSCompiler_temp)</span>
  <span class="s1">)</span>
    <span class="s3">return </span><span class="s1">updateDehydratedSuspenseComponent(</span>
      <span class="s1">current,</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">didSuspend,</span>
      <span class="s1">nextProps,</span>
      <span class="s1">JSCompiler_temp,</span>
      <span class="s1">suspenseContext,</span>
      <span class="s1">renderLanes</span>
    <span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(showFallback) {</span>
    <span class="s1">showFallback = nextProps.fallback;</span>
    <span class="s1">didSuspend = workInProgress.mode;</span>
    <span class="s1">suspenseContext = current.child;</span>
    <span class="s1">JSCompiler_temp = suspenseContext.sibling;</span>
    <span class="s3">var </span><span class="s1">primaryChildProps = { mode: </span><span class="s2">&quot;hidden&quot;</span><span class="s1">, children: nextProps.children };</span>
    <span class="s4">0 </span><span class="s1">=== (didSuspend &amp; </span><span class="s4">1</span><span class="s1">) &amp;&amp; workInProgress.child !== suspenseContext</span>
      <span class="s1">? ((nextProps = workInProgress.child),</span>
        <span class="s1">(nextProps.childLanes = </span><span class="s4">0</span><span class="s1">),</span>
        <span class="s1">(nextProps.pendingProps = primaryChildProps),</span>
        <span class="s1">workInProgress.mode &amp; </span><span class="s4">2 </span><span class="s1">&amp;&amp;</span>
          <span class="s1">((nextProps.actualDuration = </span><span class="s4">0</span><span class="s1">),</span>
          <span class="s1">(nextProps.actualStartTime = -</span><span class="s4">1</span><span class="s1">),</span>
          <span class="s1">(nextProps.selfBaseDuration = suspenseContext.selfBaseDuration),</span>
          <span class="s1">(nextProps.treeBaseDuration = suspenseContext.treeBaseDuration)),</span>
        <span class="s1">(workInProgress.deletions = </span><span class="s3">null</span><span class="s1">))</span>
      <span class="s1">: ((nextProps = createWorkInProgress(suspenseContext, primaryChildProps)),</span>
        <span class="s1">(nextProps.subtreeFlags = suspenseContext.subtreeFlags &amp; </span><span class="s4">14680064</span><span class="s1">));</span>
    <span class="s3">null </span><span class="s1">!== JSCompiler_temp</span>
      <span class="s1">? (showFallback = createWorkInProgress(JSCompiler_temp, showFallback))</span>
      <span class="s1">: ((showFallback = createFiberFromFragment(</span>
          <span class="s1">showFallback,</span>
          <span class="s1">didSuspend,</span>
          <span class="s1">renderLanes,</span>
          <span class="s3">null</span>
        <span class="s1">)),</span>
        <span class="s1">(showFallback.flags |= </span><span class="s4">2</span><span class="s1">));</span>
    <span class="s1">showFallback.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">nextProps.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">nextProps.sibling = showFallback;</span>
    <span class="s1">workInProgress.child = nextProps;</span>
    <span class="s1">nextProps = showFallback;</span>
    <span class="s1">showFallback = workInProgress.child;</span>
    <span class="s1">didSuspend = current.child.memoizedState;</span>
    <span class="s1">didSuspend =</span>
      <span class="s3">null </span><span class="s1">=== didSuspend</span>
        <span class="s1">? mountSuspenseOffscreenState(renderLanes)</span>
        <span class="s1">: {</span>
            <span class="s1">baseLanes: didSuspend.baseLanes | renderLanes,</span>
            <span class="s1">cachePool: </span><span class="s3">null</span><span class="s1">,</span>
            <span class="s1">transitions: didSuspend.transitions</span>
          <span class="s1">};</span>
    <span class="s1">showFallback.memoizedState = didSuspend;</span>
    <span class="s1">showFallback.childLanes = current.childLanes &amp; ~renderLanes;</span>
    <span class="s1">workInProgress.memoizedState = SUSPENDED_MARKER;</span>
    <span class="s3">return </span><span class="s1">nextProps;</span>
  <span class="s1">}</span>
  <span class="s1">showFallback = current.child;</span>
  <span class="s1">current = showFallback.sibling;</span>
  <span class="s1">nextProps = createWorkInProgress(showFallback, {</span>
    <span class="s1">mode: </span><span class="s2">&quot;visible&quot;</span><span class="s1">,</span>
    <span class="s1">children: nextProps.children</span>
  <span class="s1">});</span>
  <span class="s4">0 </span><span class="s1">=== (workInProgress.mode &amp; </span><span class="s4">1</span><span class="s1">) &amp;&amp; (nextProps.lanes = renderLanes);</span>
  <span class="s1">nextProps.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
  <span class="s1">nextProps.sibling = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">null </span><span class="s1">!== current &amp;&amp;</span>
    <span class="s1">((renderLanes = workInProgress.deletions),</span>
    <span class="s3">null </span><span class="s1">=== renderLanes</span>
      <span class="s1">? ((workInProgress.deletions = [current]), (workInProgress.flags |= </span><span class="s4">16</span><span class="s1">))</span>
      <span class="s1">: renderLanes.push(current));</span>
  <span class="s1">workInProgress.child = nextProps;</span>
  <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">nextProps;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">mountSuspensePrimaryChildren(workInProgress, primaryChildren) {</span>
  <span class="s1">primaryChildren = createFiberFromOffscreen(</span>
    <span class="s1">{ mode: </span><span class="s2">&quot;visible&quot;</span><span class="s1">, children: primaryChildren },</span>
    <span class="s1">workInProgress.mode,</span>
    <span class="s4">0</span><span class="s1">,</span>
    <span class="s3">null</span>
  <span class="s1">);</span>
  <span class="s1">primaryChildren.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
  <span class="s3">return </span><span class="s1">(workInProgress.child = primaryChildren);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">retrySuspenseComponentWithoutHydrating(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">renderLanes,</span>
  <span class="s1">recoverableError</span>
<span class="s1">) {</span>
  <span class="s3">null </span><span class="s1">!== recoverableError &amp;&amp;</span>
    <span class="s1">(</span><span class="s3">null </span><span class="s1">=== hydrationErrors</span>
      <span class="s1">? (hydrationErrors = [recoverableError])</span>
      <span class="s1">: hydrationErrors.push(recoverableError));</span>
  <span class="s1">reconcileChildFibers(workInProgress, current.child, </span><span class="s3">null</span><span class="s1">, renderLanes);</span>
  <span class="s1">current = mountSuspensePrimaryChildren(</span>
    <span class="s1">workInProgress,</span>
    <span class="s1">workInProgress.pendingProps.children</span>
  <span class="s1">);</span>
  <span class="s1">current.flags |= </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">current;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateDehydratedSuspenseComponent(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">didSuspend,</span>
  <span class="s1">nextProps,</span>
  <span class="s1">suspenseInstance,</span>
  <span class="s1">suspenseState,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(didSuspend) {</span>
    <span class="s3">if </span><span class="s1">(workInProgress.flags &amp; </span><span class="s4">256</span><span class="s1">)</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(workInProgress.flags &amp;= -</span><span class="s4">257</span><span class="s1">),</span>
        <span class="s1">(suspenseState = createCapturedValue(</span>
          <span class="s1">Error(</span>
            <span class="s2">&quot;There was an error while hydrating this Suspense boundary. Switched to client rendering.&quot;</span>
          <span class="s1">)</span>
        <span class="s1">)),</span>
        <span class="s1">retrySuspenseComponentWithoutHydrating(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">renderLanes,</span>
          <span class="s1">suspenseState</span>
        <span class="s1">)</span>
      <span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== workInProgress.memoizedState)</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(workInProgress.child = current.child),</span>
        <span class="s1">(workInProgress.flags |= </span><span class="s4">128</span><span class="s1">),</span>
        <span class="s3">null</span>
      <span class="s1">);</span>
    <span class="s1">suspenseState = nextProps.fallback;</span>
    <span class="s1">didSuspend = workInProgress.mode;</span>
    <span class="s1">nextProps = createFiberFromOffscreen(</span>
      <span class="s1">{ mode: </span><span class="s2">&quot;visible&quot;</span><span class="s1">, children: nextProps.children },</span>
      <span class="s1">didSuspend,</span>
      <span class="s4">0</span><span class="s1">,</span>
      <span class="s3">null</span>
    <span class="s1">);</span>
    <span class="s1">suspenseState = createFiberFromFragment(</span>
      <span class="s1">suspenseState,</span>
      <span class="s1">didSuspend,</span>
      <span class="s1">renderLanes,</span>
      <span class="s3">null</span>
    <span class="s1">);</span>
    <span class="s1">suspenseState.flags |= </span><span class="s4">2</span><span class="s1">;</span>
    <span class="s1">nextProps.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">suspenseState.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">nextProps.sibling = suspenseState;</span>
    <span class="s1">workInProgress.child = nextProps;</span>
    <span class="s4">0 </span><span class="s1">!== (workInProgress.mode &amp; </span><span class="s4">1</span><span class="s1">) &amp;&amp;</span>
      <span class="s1">reconcileChildFibers(workInProgress, current.child, </span><span class="s3">null</span><span class="s1">, renderLanes);</span>
    <span class="s1">workInProgress.child.memoizedState = mountSuspenseOffscreenState(</span>
      <span class="s1">renderLanes</span>
    <span class="s1">);</span>
    <span class="s1">workInProgress.memoizedState = SUSPENDED_MARKER;</span>
    <span class="s3">return </span><span class="s1">suspenseState;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (workInProgress.mode &amp; </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s3">return </span><span class="s1">retrySuspenseComponentWithoutHydrating(</span>
      <span class="s1">current,</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">renderLanes,</span>
      <span class="s3">null</span>
    <span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(shim())</span>
    <span class="s3">return </span><span class="s1">(</span>
      <span class="s1">(suspenseState = shim().digest),</span>
      <span class="s1">(suspenseState = createCapturedValue(</span>
        <span class="s1">Error(</span>
          <span class="s2">&quot;The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.&quot;</span>
        <span class="s1">),</span>
        <span class="s1">suspenseState,</span>
        <span class="s3">void </span><span class="s4">0</span>
      <span class="s1">)),</span>
      <span class="s1">retrySuspenseComponentWithoutHydrating(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">renderLanes,</span>
        <span class="s1">suspenseState</span>
      <span class="s1">)</span>
    <span class="s1">);</span>
  <span class="s1">didSuspend = </span><span class="s4">0 </span><span class="s1">!== (renderLanes &amp; current.childLanes);</span>
  <span class="s3">if </span><span class="s1">(didReceiveUpdate || didSuspend) {</span>
    <span class="s1">nextProps = workInProgressRoot;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== nextProps) {</span>
      <span class="s3">switch </span><span class="s1">(renderLanes &amp; -renderLanes) {</span>
        <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
          <span class="s1">didSuspend = </span><span class="s4">2</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">16</span><span class="s1">:</span>
          <span class="s1">didSuspend = </span><span class="s4">8</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">64</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">128</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">256</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">512</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">1024</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">2048</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">4096</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">8192</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">16384</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">32768</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">65536</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">131072</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">262144</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">524288</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">1048576</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">2097152</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">4194304</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">8388608</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">16777216</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">33554432</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">67108864</span><span class="s1">:</span>
          <span class="s1">didSuspend = </span><span class="s4">32</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">536870912</span><span class="s1">:</span>
          <span class="s1">didSuspend = </span><span class="s4">268435456</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">default</span><span class="s1">:</span>
          <span class="s1">didSuspend = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">didSuspend =</span>
        <span class="s4">0 </span><span class="s1">!== (didSuspend &amp; (nextProps.suspendedLanes | renderLanes))</span>
          <span class="s1">? </span><span class="s4">0</span>
          <span class="s1">: didSuspend;</span>
      <span class="s4">0 </span><span class="s1">!== didSuspend &amp;&amp;</span>
        <span class="s1">didSuspend !== suspenseState.retryLane &amp;&amp;</span>
        <span class="s1">((suspenseState.retryLane = didSuspend),</span>
        <span class="s1">markUpdateLaneFromFiberToRoot(current, didSuspend),</span>
        <span class="s1">scheduleUpdateOnFiber(nextProps, current, didSuspend, -</span><span class="s4">1</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s1">renderDidSuspendDelayIfPossible();</span>
    <span class="s1">suspenseState = createCapturedValue(</span>
      <span class="s1">Error(</span>
        <span class="s2">&quot;This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition.&quot;</span>
      <span class="s1">)</span>
    <span class="s1">);</span>
    <span class="s3">return </span><span class="s1">retrySuspenseComponentWithoutHydrating(</span>
      <span class="s1">current,</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">renderLanes,</span>
      <span class="s1">suspenseState</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(shim())</span>
    <span class="s3">return </span><span class="s1">(</span>
      <span class="s1">(workInProgress.flags |= </span><span class="s4">128</span><span class="s1">),</span>
      <span class="s1">(workInProgress.child = current.child),</span>
      <span class="s1">retryDehydratedSuspenseBoundary.bind(</span><span class="s3">null</span><span class="s1">, current),</span>
      <span class="s1">shim(),</span>
      <span class="s3">null</span>
    <span class="s1">);</span>
  <span class="s1">current = mountSuspensePrimaryChildren(workInProgress, nextProps.children);</span>
  <span class="s1">current.flags |= </span><span class="s4">4096</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">current;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {</span>
  <span class="s1">fiber.lanes |= renderLanes;</span>
  <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>
  <span class="s3">null </span><span class="s1">!== alternate &amp;&amp; (alternate.lanes |= renderLanes);</span>
  <span class="s1">scheduleContextWorkOnParentPath(fiber.</span><span class="s3">return</span><span class="s1">, renderLanes, propagationRoot);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">initSuspenseListRenderState(</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">isBackwards,</span>
  <span class="s1">tail,</span>
  <span class="s1">lastContentRow,</span>
  <span class="s1">tailMode</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">renderState = workInProgress.memoizedState;</span>
  <span class="s3">null </span><span class="s1">=== renderState</span>
    <span class="s1">? (workInProgress.memoizedState = {</span>
        <span class="s1">isBackwards: isBackwards,</span>
        <span class="s1">rendering: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">renderingStartTime: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">last: lastContentRow,</span>
        <span class="s1">tail: tail,</span>
        <span class="s1">tailMode: tailMode</span>
      <span class="s1">})</span>
    <span class="s1">: ((renderState.isBackwards = isBackwards),</span>
      <span class="s1">(renderState.rendering = </span><span class="s3">null</span><span class="s1">),</span>
      <span class="s1">(renderState.renderingStartTime = </span><span class="s4">0</span><span class="s1">),</span>
      <span class="s1">(renderState.last = lastContentRow),</span>
      <span class="s1">(renderState.tail = tail),</span>
      <span class="s1">(renderState.tailMode = tailMode));</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateSuspenseListComponent(current, workInProgress, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">nextProps = workInProgress.pendingProps,</span>
    <span class="s1">revealOrder = nextProps.revealOrder,</span>
    <span class="s1">tailMode = nextProps.tail;</span>
  <span class="s1">reconcileChildren(current, workInProgress, nextProps.children, renderLanes);</span>
  <span class="s1">nextProps = suspenseStackCursor.current;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (nextProps &amp; </span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">(nextProps = (nextProps &amp; </span><span class="s4">1</span><span class="s1">) | </span><span class="s4">2</span><span class="s1">), (workInProgress.flags |= </span><span class="s4">128</span><span class="s1">);</span>
  <span class="s3">else </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== current &amp;&amp; </span><span class="s4">0 </span><span class="s1">!== (current.flags &amp; </span><span class="s4">128</span><span class="s1">))</span>
      <span class="s1">a: </span><span class="s3">for </span><span class="s1">(current = workInProgress.child; </span><span class="s3">null </span><span class="s1">!== current; ) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s4">13 </span><span class="s1">=== current.tag)</span>
          <span class="s3">null </span><span class="s1">!== current.memoizedState &amp;&amp;</span>
            <span class="s1">scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);</span>
        <span class="s3">else if </span><span class="s1">(</span><span class="s4">19 </span><span class="s1">=== current.tag)</span>
          <span class="s1">scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);</span>
        <span class="s3">else if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== current.child) {</span>
          <span class="s1">current.child.</span><span class="s3">return </span><span class="s1">= current;</span>
          <span class="s1">current = current.child;</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(current === workInProgress) </span><span class="s3">break </span><span class="s1">a;</span>
        <span class="s3">for </span><span class="s1">(; </span><span class="s3">null </span><span class="s1">=== current.sibling; ) {</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== current.</span><span class="s3">return </span><span class="s1">|| current.</span><span class="s3">return </span><span class="s1">=== workInProgress)</span>
            <span class="s3">break </span><span class="s1">a;</span>
          <span class="s1">current = current.</span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">current.sibling.</span><span class="s3">return </span><span class="s1">= current.</span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">current = current.sibling;</span>
      <span class="s1">}</span>
    <span class="s1">nextProps &amp;= </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">push(suspenseStackCursor, nextProps);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (workInProgress.mode &amp; </span><span class="s4">1</span><span class="s1">)) workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">else</span>
    <span class="s3">switch </span><span class="s1">(revealOrder) {</span>
      <span class="s3">case </span><span class="s2">&quot;forwards&quot;</span><span class="s1">:</span>
        <span class="s1">renderLanes = workInProgress.child;</span>
        <span class="s3">for </span><span class="s1">(revealOrder = </span><span class="s3">null</span><span class="s1">; </span><span class="s3">null </span><span class="s1">!== renderLanes; )</span>
          <span class="s1">(current = renderLanes.alternate),</span>
            <span class="s3">null </span><span class="s1">!== current &amp;&amp;</span>
              <span class="s3">null </span><span class="s1">=== findFirstSuspended(current) &amp;&amp;</span>
              <span class="s1">(revealOrder = renderLanes),</span>
            <span class="s1">(renderLanes = renderLanes.sibling);</span>
        <span class="s1">renderLanes = revealOrder;</span>
        <span class="s3">null </span><span class="s1">=== renderLanes</span>
          <span class="s1">? ((revealOrder = workInProgress.child),</span>
            <span class="s1">(workInProgress.child = </span><span class="s3">null</span><span class="s1">))</span>
          <span class="s1">: ((revealOrder = renderLanes.sibling), (renderLanes.sibling = </span><span class="s3">null</span><span class="s1">));</span>
        <span class="s1">initSuspenseListRenderState(</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">!</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">revealOrder,</span>
          <span class="s1">renderLanes,</span>
          <span class="s1">tailMode</span>
        <span class="s1">);</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s3">case </span><span class="s2">&quot;backwards&quot;</span><span class="s1">:</span>
        <span class="s1">renderLanes = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">revealOrder = workInProgress.child;</span>
        <span class="s3">for </span><span class="s1">(workInProgress.child = </span><span class="s3">null</span><span class="s1">; </span><span class="s3">null </span><span class="s1">!== revealOrder; ) {</span>
          <span class="s1">current = revealOrder.alternate;</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== current &amp;&amp; </span><span class="s3">null </span><span class="s1">=== findFirstSuspended(current)) {</span>
            <span class="s1">workInProgress.child = revealOrder;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s1">current = revealOrder.sibling;</span>
          <span class="s1">revealOrder.sibling = renderLanes;</span>
          <span class="s1">renderLanes = revealOrder;</span>
          <span class="s1">revealOrder = current;</span>
        <span class="s1">}</span>
        <span class="s1">initSuspenseListRenderState(</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">!</span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">renderLanes,</span>
          <span class="s3">null</span><span class="s1">,</span>
          <span class="s1">tailMode</span>
        <span class="s1">);</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s3">case </span><span class="s2">&quot;together&quot;</span><span class="s1">:</span>
        <span class="s1">initSuspenseListRenderState(workInProgress, !</span><span class="s4">1</span><span class="s1">, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">void </span><span class="s4">0</span><span class="s1">);</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s3">default</span><span class="s1">:</span>
        <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress) {</span>
  <span class="s4">0 </span><span class="s1">=== (workInProgress.mode &amp; </span><span class="s4">1</span><span class="s1">) &amp;&amp;</span>
    <span class="s3">null </span><span class="s1">!== current &amp;&amp;</span>
    <span class="s1">((current.alternate = </span><span class="s3">null</span><span class="s1">),</span>
    <span class="s1">(workInProgress.alternate = </span><span class="s3">null</span><span class="s1">),</span>
    <span class="s1">(workInProgress.flags |= </span><span class="s4">2</span><span class="s1">));</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {</span>
  <span class="s3">null </span><span class="s1">!== current &amp;&amp; (workInProgress.dependencies = current.dependencies);</span>
  <span class="s1">profilerStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">workInProgressRootSkippedLanes |= workInProgress.lanes;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (renderLanes &amp; workInProgress.childLanes)) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== current &amp;&amp; workInProgress.child !== current.child)</span>
    <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Resuming work not yet implemented.&quot;</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== workInProgress.child) {</span>
    <span class="s1">current = workInProgress.child;</span>
    <span class="s1">renderLanes = createWorkInProgress(current, current.pendingProps);</span>
    <span class="s1">workInProgress.child = renderLanes;</span>
    <span class="s3">for </span><span class="s1">(renderLanes.</span><span class="s3">return </span><span class="s1">= workInProgress; </span><span class="s3">null </span><span class="s1">!== current.sibling; )</span>
      <span class="s1">(current = current.sibling),</span>
        <span class="s1">(renderLanes = renderLanes.sibling = createWorkInProgress(</span>
          <span class="s1">current,</span>
          <span class="s1">current.pendingProps</span>
        <span class="s1">)),</span>
        <span class="s1">(renderLanes.</span><span class="s3">return </span><span class="s1">= workInProgress);</span>
    <span class="s1">renderLanes.sibling = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">attemptEarlyBailoutIfNoScheduledUpdate(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s3">switch </span><span class="s1">(workInProgress.tag) {</span>
    <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
      <span class="s1">pushHostRootContext(workInProgress);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
      <span class="s1">pushHostContext(workInProgress);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
      <span class="s1">isContextProvider(workInProgress.type) &amp;&amp;</span>
        <span class="s1">pushContextProvider(workInProgress);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
      <span class="s1">pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">10</span><span class="s1">:</span>
      <span class="s3">var </span><span class="s1">context = workInProgress.type._context,</span>
        <span class="s1">nextValue = workInProgress.memoizedProps.value;</span>
      <span class="s1">push(valueCursor, context._currentValue);</span>
      <span class="s1">context._currentValue = nextValue;</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">12</span><span class="s1">:</span>
      <span class="s4">0 </span><span class="s1">!== (renderLanes &amp; workInProgress.childLanes) &amp;&amp;</span>
        <span class="s1">(workInProgress.flags |= </span><span class="s4">4</span><span class="s1">);</span>
      <span class="s1">context = workInProgress.stateNode;</span>
      <span class="s1">context.effectDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">context.passiveEffectDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">13</span><span class="s1">:</span>
      <span class="s1">context = workInProgress.memoizedState;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== context) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== context.dehydrated)</span>
          <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">push(suspenseStackCursor, suspenseStackCursor.current &amp; </span><span class="s4">1</span><span class="s1">),</span>
            <span class="s1">(workInProgress.flags |= </span><span class="s4">128</span><span class="s1">),</span>
            <span class="s3">null</span>
          <span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (renderLanes &amp; workInProgress.child.childLanes))</span>
          <span class="s3">return </span><span class="s1">updateSuspenseComponent(current, workInProgress, renderLanes);</span>
        <span class="s1">push(suspenseStackCursor, suspenseStackCursor.current &amp; </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">current = bailoutOnAlreadyFinishedWork(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">);</span>
        <span class="s3">return null </span><span class="s1">!== current ? current.sibling : </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">push(suspenseStackCursor, suspenseStackCursor.current &amp; </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">19</span><span class="s1">:</span>
      <span class="s1">context = </span><span class="s4">0 </span><span class="s1">!== (renderLanes &amp; workInProgress.childLanes);</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (current.flags &amp; </span><span class="s4">128</span><span class="s1">)) {</span>
        <span class="s3">if </span><span class="s1">(context)</span>
          <span class="s3">return </span><span class="s1">updateSuspenseListComponent(</span>
            <span class="s1">current,</span>
            <span class="s1">workInProgress,</span>
            <span class="s1">renderLanes</span>
          <span class="s1">);</span>
        <span class="s1">workInProgress.flags |= </span><span class="s4">128</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">nextValue = workInProgress.memoizedState;</span>
      <span class="s3">null </span><span class="s1">!== nextValue &amp;&amp;</span>
        <span class="s1">((nextValue.rendering = </span><span class="s3">null</span><span class="s1">),</span>
        <span class="s1">(nextValue.tail = </span><span class="s3">null</span><span class="s1">),</span>
        <span class="s1">(nextValue.lastEffect = </span><span class="s3">null</span><span class="s1">));</span>
      <span class="s1">push(suspenseStackCursor, suspenseStackCursor.current);</span>
      <span class="s3">if </span><span class="s1">(context) </span><span class="s3">break</span><span class="s1">;</span>
      <span class="s3">else return null</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">22</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">23</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(workInProgress.lanes = </span><span class="s4">0</span><span class="s1">),</span>
        <span class="s1">updateOffscreenComponent(current, workInProgress, renderLanes)</span>
      <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">appendAllChildren,</span>
  <span class="s1">updateHostContainer,</span>
  <span class="s1">updateHostComponent$1,</span>
  <span class="s1">updateHostText$1;</span>
<span class="s1">appendAllChildren = </span><span class="s3">function</span><span class="s1">(parent, workInProgress) {</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">node = workInProgress.child; </span><span class="s3">null </span><span class="s1">!== node; ) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s4">5 </span><span class="s1">=== node.tag || </span><span class="s4">6 </span><span class="s1">=== node.tag) parent._children.push(node.stateNode);</span>
    <span class="s3">else if </span><span class="s1">(</span><span class="s4">4 </span><span class="s1">!== node.tag &amp;&amp; </span><span class="s3">null </span><span class="s1">!== node.child) {</span>
      <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
      <span class="s1">node = node.child;</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(node === workInProgress) </span><span class="s3">break</span><span class="s1">;</span>
    <span class="s3">for </span><span class="s1">(; </span><span class="s3">null </span><span class="s1">=== node.sibling; ) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== node.</span><span class="s3">return </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== workInProgress) </span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">node = node.sibling;</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s1">updateHostContainer = </span><span class="s3">function</span><span class="s1">() {};</span>
<span class="s1">updateHostComponent$1 = </span><span class="s3">function</span><span class="s1">(current, workInProgress, type, newProps) {</span>
  <span class="s1">current.memoizedProps !== newProps &amp;&amp;</span>
    <span class="s1">(requiredContext(contextStackCursor$1.current),</span>
    <span class="s1">(workInProgress.updateQueue = UPDATE_SIGNAL)) &amp;&amp;</span>
    <span class="s1">(workInProgress.flags |= </span><span class="s4">4</span><span class="s1">);</span>
<span class="s1">};</span>
<span class="s1">updateHostText$1 = </span><span class="s3">function</span><span class="s1">(current, workInProgress, oldText, newText) {</span>
  <span class="s1">oldText !== newText &amp;&amp; (workInProgress.flags |= </span><span class="s4">4</span><span class="s1">);</span>
<span class="s1">};</span>
<span class="s3">function </span><span class="s1">cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {</span>
  <span class="s3">switch </span><span class="s1">(renderState.tailMode) {</span>
    <span class="s3">case </span><span class="s2">&quot;hidden&quot;</span><span class="s1">:</span>
      <span class="s1">hasRenderedATailFallback = renderState.tail;</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">lastTailNode = </span><span class="s3">null</span><span class="s1">; </span><span class="s3">null </span><span class="s1">!== hasRenderedATailFallback; )</span>
        <span class="s3">null </span><span class="s1">!== hasRenderedATailFallback.alternate &amp;&amp;</span>
          <span class="s1">(lastTailNode = hasRenderedATailFallback),</span>
          <span class="s1">(hasRenderedATailFallback = hasRenderedATailFallback.sibling);</span>
      <span class="s3">null </span><span class="s1">=== lastTailNode</span>
        <span class="s1">? (renderState.tail = </span><span class="s3">null</span><span class="s1">)</span>
        <span class="s1">: (lastTailNode.sibling = </span><span class="s3">null</span><span class="s1">);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s2">&quot;collapsed&quot;</span><span class="s1">:</span>
      <span class="s1">lastTailNode = renderState.tail;</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">lastTailNode$65 = </span><span class="s3">null</span><span class="s1">; </span><span class="s3">null </span><span class="s1">!== lastTailNode; )</span>
        <span class="s3">null </span><span class="s1">!== lastTailNode.alternate &amp;&amp; (lastTailNode$65 = lastTailNode),</span>
          <span class="s1">(lastTailNode = lastTailNode.sibling);</span>
      <span class="s3">null </span><span class="s1">=== lastTailNode$65</span>
        <span class="s1">? hasRenderedATailFallback || </span><span class="s3">null </span><span class="s1">=== renderState.tail</span>
          <span class="s1">? (renderState.tail = </span><span class="s3">null</span><span class="s1">)</span>
          <span class="s1">: (renderState.tail.sibling = </span><span class="s3">null</span><span class="s1">)</span>
        <span class="s1">: (lastTailNode$65.sibling = </span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">bubbleProperties(completedWork) {</span>
  <span class="s3">var </span><span class="s1">didBailout =</span>
      <span class="s3">null </span><span class="s1">!== completedWork.alternate &amp;&amp;</span>
      <span class="s1">completedWork.alternate.child === completedWork.child,</span>
    <span class="s1">newChildLanes = </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">subtreeFlags = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(didBailout)</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (completedWork.mode &amp; </span><span class="s4">2</span><span class="s1">)) {</span>
      <span class="s3">for </span><span class="s1">(</span>
        <span class="s3">var </span><span class="s1">treeBaseDuration$67 = completedWork.selfBaseDuration,</span>
          <span class="s1">child$68 = completedWork.child;</span>
        <span class="s3">null </span><span class="s1">!== child$68;</span>

      <span class="s1">)</span>
        <span class="s1">(newChildLanes |= child$68.lanes | child$68.childLanes),</span>
          <span class="s1">(subtreeFlags |= child$68.subtreeFlags &amp; </span><span class="s4">14680064</span><span class="s1">),</span>
          <span class="s1">(subtreeFlags |= child$68.flags &amp; </span><span class="s4">14680064</span><span class="s1">),</span>
          <span class="s1">(treeBaseDuration$67 += child$68.treeBaseDuration),</span>
          <span class="s1">(child$68 = child$68.sibling);</span>
      <span class="s1">completedWork.treeBaseDuration = treeBaseDuration$67;</span>
    <span class="s1">} </span><span class="s3">else</span>
      <span class="s3">for </span><span class="s1">(</span>
        <span class="s1">treeBaseDuration$67 = completedWork.child;</span>
        <span class="s3">null </span><span class="s1">!== treeBaseDuration$67;</span>

      <span class="s1">)</span>
        <span class="s1">(newChildLanes |=</span>
          <span class="s1">treeBaseDuration$67.lanes | treeBaseDuration$67.childLanes),</span>
          <span class="s1">(subtreeFlags |= treeBaseDuration$67.subtreeFlags &amp; </span><span class="s4">14680064</span><span class="s1">),</span>
          <span class="s1">(subtreeFlags |= treeBaseDuration$67.flags &amp; </span><span class="s4">14680064</span><span class="s1">),</span>
          <span class="s1">(treeBaseDuration$67.</span><span class="s3">return </span><span class="s1">= completedWork),</span>
          <span class="s1">(treeBaseDuration$67 = treeBaseDuration$67.sibling);</span>
  <span class="s3">else if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (completedWork.mode &amp; </span><span class="s4">2</span><span class="s1">)) {</span>
    <span class="s1">treeBaseDuration$67 = completedWork.actualDuration;</span>
    <span class="s1">child$68 = completedWork.selfBaseDuration;</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">child = completedWork.child; </span><span class="s3">null </span><span class="s1">!== child; )</span>
      <span class="s1">(newChildLanes |= child.lanes | child.childLanes),</span>
        <span class="s1">(subtreeFlags |= child.subtreeFlags),</span>
        <span class="s1">(subtreeFlags |= child.flags),</span>
        <span class="s1">(treeBaseDuration$67 += child.actualDuration),</span>
        <span class="s1">(child$68 += child.treeBaseDuration),</span>
        <span class="s1">(child = child.sibling);</span>
    <span class="s1">completedWork.actualDuration = treeBaseDuration$67;</span>
    <span class="s1">completedWork.treeBaseDuration = child$68;</span>
  <span class="s1">} </span><span class="s3">else</span>
    <span class="s3">for </span><span class="s1">(</span>
      <span class="s1">treeBaseDuration$67 = completedWork.child;</span>
      <span class="s3">null </span><span class="s1">!== treeBaseDuration$67;</span>

    <span class="s1">)</span>
      <span class="s1">(newChildLanes |=</span>
        <span class="s1">treeBaseDuration$67.lanes | treeBaseDuration$67.childLanes),</span>
        <span class="s1">(subtreeFlags |= treeBaseDuration$67.subtreeFlags),</span>
        <span class="s1">(subtreeFlags |= treeBaseDuration$67.flags),</span>
        <span class="s1">(treeBaseDuration$67.</span><span class="s3">return </span><span class="s1">= completedWork),</span>
        <span class="s1">(treeBaseDuration$67 = treeBaseDuration$67.sibling);</span>
  <span class="s1">completedWork.subtreeFlags |= subtreeFlags;</span>
  <span class="s1">completedWork.childLanes = newChildLanes;</span>
  <span class="s3">return </span><span class="s1">didBailout;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">completeWork(current, workInProgress, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">newProps = workInProgress.pendingProps;</span>
  <span class="s1">popTreeContext(workInProgress);</span>
  <span class="s3">switch </span><span class="s1">(workInProgress.tag) {</span>
    <span class="s3">case </span><span class="s4">2</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">16</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">15</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">11</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">7</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">8</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">12</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">9</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">14</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">bubbleProperties(workInProgress), </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">isContextProvider(workInProgress.type) &amp;&amp; popContext(),</span>
        <span class="s1">bubbleProperties(workInProgress),</span>
        <span class="s3">null</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(renderLanes = workInProgress.stateNode),</span>
        <span class="s1">popHostContainer(),</span>
        <span class="s1">pop(didPerformWorkStackCursor),</span>
        <span class="s1">pop(contextStackCursor),</span>
        <span class="s1">resetWorkInProgressVersions(),</span>
        <span class="s1">renderLanes.pendingContext &amp;&amp;</span>
          <span class="s1">((renderLanes.context = renderLanes.pendingContext),</span>
          <span class="s1">(renderLanes.pendingContext = </span><span class="s3">null</span><span class="s1">)),</span>
        <span class="s1">(</span><span class="s3">null </span><span class="s1">!== current &amp;&amp; </span><span class="s3">null </span><span class="s1">!== current.child) ||</span>
          <span class="s3">null </span><span class="s1">=== current ||</span>
          <span class="s1">(current.memoizedState.isDehydrated &amp;&amp;</span>
            <span class="s4">0 </span><span class="s1">=== (workInProgress.flags &amp; </span><span class="s4">256</span><span class="s1">)) ||</span>
          <span class="s1">((workInProgress.flags |= </span><span class="s4">1024</span><span class="s1">),</span>
          <span class="s3">null </span><span class="s1">!== hydrationErrors &amp;&amp;</span>
            <span class="s1">(queueRecoverableErrors(hydrationErrors),</span>
            <span class="s1">(hydrationErrors = </span><span class="s3">null</span><span class="s1">))),</span>
        <span class="s1">updateHostContainer(current, workInProgress),</span>
        <span class="s1">bubbleProperties(workInProgress),</span>
        <span class="s3">null</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
      <span class="s1">popHostContext(workInProgress);</span>
      <span class="s1">renderLanes = requiredContext(rootInstanceStackCursor.current);</span>
      <span class="s3">var </span><span class="s1">type = workInProgress.type;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== current &amp;&amp; </span><span class="s3">null </span><span class="s1">!= workInProgress.stateNode)</span>
        <span class="s1">updateHostComponent$1(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">type,</span>
          <span class="s1">newProps,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">),</span>
          <span class="s1">current.ref !== workInProgress.ref &amp;&amp; (workInProgress.flags |= </span><span class="s4">512</span><span class="s1">);</span>
      <span class="s3">else </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(!newProps) {</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== workInProgress.stateNode)</span>
            <span class="s3">throw </span><span class="s1">Error(</span>
              <span class="s2">&quot;We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
            <span class="s1">);</span>
          <span class="s1">bubbleProperties(workInProgress);</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">requiredContext(contextStackCursor$1.current);</span>
        <span class="s1">current = allocateTag();</span>
        <span class="s1">type = getViewConfigForType(type);</span>
        <span class="s3">var </span><span class="s1">updatePayload = diffProperties(</span>
          <span class="s3">null</span><span class="s1">,</span>
          <span class="s1">emptyObject,</span>
          <span class="s1">newProps,</span>
          <span class="s1">type.validAttributes</span>
        <span class="s1">);</span>
        <span class="s1">ReactNativePrivateInterface.UIManager.createView(</span>
          <span class="s1">current,</span>
          <span class="s1">type.uiViewClassName,</span>
          <span class="s1">renderLanes,</span>
          <span class="s1">updatePayload</span>
        <span class="s1">);</span>
        <span class="s1">renderLanes = </span><span class="s3">new </span><span class="s1">ReactNativeFiberHostComponent(</span>
          <span class="s1">current,</span>
          <span class="s1">type,</span>
          <span class="s1">workInProgress</span>
        <span class="s1">);</span>
        <span class="s1">instanceCache.set(current, workInProgress);</span>
        <span class="s1">instanceProps.set(current, newProps);</span>
        <span class="s1">appendAllChildren(renderLanes, workInProgress, !</span><span class="s4">1</span><span class="s1">, !</span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">workInProgress.stateNode = renderLanes;</span>
        <span class="s1">finalizeInitialChildren(renderLanes) &amp;&amp; (workInProgress.flags |= </span><span class="s4">4</span><span class="s1">);</span>
        <span class="s3">null </span><span class="s1">!== workInProgress.ref &amp;&amp; (workInProgress.flags |= </span><span class="s4">512</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s1">bubbleProperties(workInProgress);</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">6</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">(current &amp;&amp; </span><span class="s3">null </span><span class="s1">!= workInProgress.stateNode)</span>
        <span class="s1">updateHostText$1(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">current.memoizedProps,</span>
          <span class="s1">newProps</span>
        <span class="s1">);</span>
      <span class="s3">else </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;string&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">newProps &amp;&amp; </span><span class="s3">null </span><span class="s1">=== workInProgress.stateNode)</span>
          <span class="s3">throw </span><span class="s1">Error(</span>
            <span class="s2">&quot;We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
          <span class="s1">);</span>
        <span class="s1">current = requiredContext(rootInstanceStackCursor.current);</span>
        <span class="s3">if </span><span class="s1">(!requiredContext(contextStackCursor$1.current).isInAParentText)</span>
          <span class="s3">throw </span><span class="s1">Error(</span>
            <span class="s2">&quot;Text strings must be rendered within a &lt;Text&gt; component.&quot;</span>
          <span class="s1">);</span>
        <span class="s1">renderLanes = allocateTag();</span>
        <span class="s1">ReactNativePrivateInterface.UIManager.createView(</span>
          <span class="s1">renderLanes,</span>
          <span class="s2">&quot;RCTRawText&quot;</span><span class="s1">,</span>
          <span class="s1">current,</span>
          <span class="s1">{ text: newProps }</span>
        <span class="s1">);</span>
        <span class="s1">instanceCache.set(renderLanes, workInProgress);</span>
        <span class="s1">workInProgress.stateNode = renderLanes;</span>
      <span class="s1">}</span>
      <span class="s1">bubbleProperties(workInProgress);</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">13</span><span class="s1">:</span>
      <span class="s1">pop(suspenseStackCursor);</span>
      <span class="s1">newProps = workInProgress.memoizedState;</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s3">null </span><span class="s1">=== current ||</span>
        <span class="s1">(</span><span class="s3">null </span><span class="s1">!== current.memoizedState &amp;&amp;</span>
          <span class="s3">null </span><span class="s1">!== current.memoizedState.dehydrated)</span>
      <span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== newProps &amp;&amp; </span><span class="s3">null </span><span class="s1">!== newProps.dehydrated) {</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== current) {</span>
            <span class="s3">throw </span><span class="s1">Error(</span>
              <span class="s2">&quot;A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.&quot;</span>
            <span class="s1">);</span>
            <span class="s3">throw </span><span class="s1">Error(</span>
              <span class="s2">&quot;Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s4">0 </span><span class="s1">=== (workInProgress.flags &amp; </span><span class="s4">128</span><span class="s1">) &amp;&amp;</span>
            <span class="s1">(workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">);</span>
          <span class="s1">workInProgress.flags |= </span><span class="s4">4</span><span class="s1">;</span>
          <span class="s1">bubbleProperties(workInProgress);</span>
          <span class="s4">0 </span><span class="s1">!== (workInProgress.mode &amp; </span><span class="s4">2</span><span class="s1">) &amp;&amp;</span>
            <span class="s3">null </span><span class="s1">!== newProps &amp;&amp;</span>
            <span class="s1">((type = workInProgress.child),</span>
            <span class="s3">null </span><span class="s1">!== type &amp;&amp;</span>
              <span class="s1">(workInProgress.treeBaseDuration -= type.treeBaseDuration));</span>
          <span class="s1">type = !</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else</span>
          <span class="s3">null </span><span class="s1">!== hydrationErrors &amp;&amp;</span>
            <span class="s1">(queueRecoverableErrors(hydrationErrors), (hydrationErrors = </span><span class="s3">null</span><span class="s1">)),</span>
            <span class="s1">(type = !</span><span class="s4">0</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(!type) </span><span class="s3">return </span><span class="s1">workInProgress.flags &amp; </span><span class="s4">65536 </span><span class="s1">? workInProgress : </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (workInProgress.flags &amp; </span><span class="s4">128</span><span class="s1">))</span>
        <span class="s3">return </span><span class="s1">(</span>
          <span class="s1">(workInProgress.lanes = renderLanes),</span>
          <span class="s4">0 </span><span class="s1">!== (workInProgress.mode &amp; </span><span class="s4">2</span><span class="s1">) &amp;&amp;</span>
            <span class="s1">transferActualDuration(workInProgress),</span>
          <span class="s1">workInProgress</span>
        <span class="s1">);</span>
      <span class="s1">renderLanes = </span><span class="s3">null </span><span class="s1">!== newProps;</span>
      <span class="s1">renderLanes !== (</span><span class="s3">null </span><span class="s1">!== current &amp;&amp; </span><span class="s3">null </span><span class="s1">!== current.memoizedState) &amp;&amp;</span>
        <span class="s1">renderLanes &amp;&amp;</span>
        <span class="s1">((workInProgress.child.flags |= </span><span class="s4">8192</span><span class="s1">),</span>
        <span class="s4">0 </span><span class="s1">!== (workInProgress.mode &amp; </span><span class="s4">1</span><span class="s1">) &amp;&amp;</span>
          <span class="s1">(</span><span class="s3">null </span><span class="s1">=== current || </span><span class="s4">0 </span><span class="s1">!== (suspenseStackCursor.current &amp; </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">? </span><span class="s4">0 </span><span class="s1">=== workInProgressRootExitStatus &amp;&amp;</span>
              <span class="s1">(workInProgressRootExitStatus = </span><span class="s4">3</span><span class="s1">)</span>
            <span class="s1">: renderDidSuspendDelayIfPossible()));</span>
      <span class="s3">null </span><span class="s1">!== workInProgress.updateQueue &amp;&amp; (workInProgress.flags |= </span><span class="s4">4</span><span class="s1">);</span>
      <span class="s1">bubbleProperties(workInProgress);</span>
      <span class="s4">0 </span><span class="s1">!== (workInProgress.mode &amp; </span><span class="s4">2</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">renderLanes &amp;&amp;</span>
        <span class="s1">((current = workInProgress.child),</span>
        <span class="s3">null </span><span class="s1">!== current &amp;&amp;</span>
          <span class="s1">(workInProgress.treeBaseDuration -= current.treeBaseDuration));</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">popHostContainer(),</span>
        <span class="s1">updateHostContainer(current, workInProgress),</span>
        <span class="s1">bubbleProperties(workInProgress),</span>
        <span class="s3">null</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">10</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">popProvider(workInProgress.type._context),</span>
        <span class="s1">bubbleProperties(workInProgress),</span>
        <span class="s3">null</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">17</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">isContextProvider(workInProgress.type) &amp;&amp; popContext(),</span>
        <span class="s1">bubbleProperties(workInProgress),</span>
        <span class="s3">null</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">19</span><span class="s1">:</span>
      <span class="s1">pop(suspenseStackCursor);</span>
      <span class="s1">type = workInProgress.memoizedState;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== type) </span><span class="s3">return </span><span class="s1">bubbleProperties(workInProgress), </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">newProps = </span><span class="s4">0 </span><span class="s1">!== (workInProgress.flags &amp; </span><span class="s4">128</span><span class="s1">);</span>
      <span class="s1">updatePayload = type.rendering;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== updatePayload)</span>
        <span class="s3">if </span><span class="s1">(newProps) cutOffTailIfNeeded(type, !</span><span class="s4">1</span><span class="s1">);</span>
        <span class="s3">else </span><span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(</span>
            <span class="s4">0 </span><span class="s1">!== workInProgressRootExitStatus ||</span>
            <span class="s1">(</span><span class="s3">null </span><span class="s1">!== current &amp;&amp; </span><span class="s4">0 </span><span class="s1">!== (current.flags &amp; </span><span class="s4">128</span><span class="s1">))</span>
          <span class="s1">)</span>
            <span class="s3">for </span><span class="s1">(current = workInProgress.child; </span><span class="s3">null </span><span class="s1">!== current; ) {</span>
              <span class="s1">updatePayload = findFirstSuspended(current);</span>
              <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== updatePayload) {</span>
                <span class="s1">workInProgress.flags |= </span><span class="s4">128</span><span class="s1">;</span>
                <span class="s1">cutOffTailIfNeeded(type, !</span><span class="s4">1</span><span class="s1">);</span>
                <span class="s1">current = updatePayload.updateQueue;</span>
                <span class="s3">null </span><span class="s1">!== current &amp;&amp;</span>
                  <span class="s1">((workInProgress.updateQueue = current),</span>
                  <span class="s1">(workInProgress.flags |= </span><span class="s4">4</span><span class="s1">));</span>
                <span class="s1">workInProgress.subtreeFlags = </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s1">current = renderLanes;</span>
                <span class="s3">for </span><span class="s1">(renderLanes = workInProgress.child; </span><span class="s3">null </span><span class="s1">!== renderLanes; )</span>
                  <span class="s1">(newProps = renderLanes),</span>
                    <span class="s1">(updatePayload = current),</span>
                    <span class="s1">(newProps.flags &amp;= </span><span class="s4">14680066</span><span class="s1">),</span>
                    <span class="s1">(type = newProps.alternate),</span>
                    <span class="s3">null </span><span class="s1">=== type</span>
                      <span class="s1">? ((newProps.childLanes = </span><span class="s4">0</span><span class="s1">),</span>
                        <span class="s1">(newProps.lanes = updatePayload),</span>
                        <span class="s1">(newProps.child = </span><span class="s3">null</span><span class="s1">),</span>
                        <span class="s1">(newProps.subtreeFlags = </span><span class="s4">0</span><span class="s1">),</span>
                        <span class="s1">(newProps.memoizedProps = </span><span class="s3">null</span><span class="s1">),</span>
                        <span class="s1">(newProps.memoizedState = </span><span class="s3">null</span><span class="s1">),</span>
                        <span class="s1">(newProps.updateQueue = </span><span class="s3">null</span><span class="s1">),</span>
                        <span class="s1">(newProps.dependencies = </span><span class="s3">null</span><span class="s1">),</span>
                        <span class="s1">(newProps.stateNode = </span><span class="s3">null</span><span class="s1">),</span>
                        <span class="s1">(newProps.selfBaseDuration = </span><span class="s4">0</span><span class="s1">),</span>
                        <span class="s1">(newProps.treeBaseDuration = </span><span class="s4">0</span><span class="s1">))</span>
                      <span class="s1">: ((newProps.childLanes = type.childLanes),</span>
                        <span class="s1">(newProps.lanes = type.lanes),</span>
                        <span class="s1">(newProps.child = type.child),</span>
                        <span class="s1">(newProps.subtreeFlags = </span><span class="s4">0</span><span class="s1">),</span>
                        <span class="s1">(newProps.deletions = </span><span class="s3">null</span><span class="s1">),</span>
                        <span class="s1">(newProps.memoizedProps = type.memoizedProps),</span>
                        <span class="s1">(newProps.memoizedState = type.memoizedState),</span>
                        <span class="s1">(newProps.updateQueue = type.updateQueue),</span>
                        <span class="s1">(newProps.type = type.type),</span>
                        <span class="s1">(updatePayload = type.dependencies),</span>
                        <span class="s1">(newProps.dependencies =</span>
                          <span class="s3">null </span><span class="s1">=== updatePayload</span>
                            <span class="s1">? </span><span class="s3">null</span>
                            <span class="s1">: {</span>
                                <span class="s1">lanes: updatePayload.lanes,</span>
                                <span class="s1">firstContext: updatePayload.firstContext</span>
                              <span class="s1">}),</span>
                        <span class="s1">(newProps.selfBaseDuration = type.selfBaseDuration),</span>
                        <span class="s1">(newProps.treeBaseDuration = type.treeBaseDuration)),</span>
                    <span class="s1">(renderLanes = renderLanes.sibling);</span>
                <span class="s1">push(</span>
                  <span class="s1">suspenseStackCursor,</span>
                  <span class="s1">(suspenseStackCursor.current &amp; </span><span class="s4">1</span><span class="s1">) | </span><span class="s4">2</span>
                <span class="s1">);</span>
                <span class="s3">return </span><span class="s1">workInProgress.child;</span>
              <span class="s1">}</span>
              <span class="s1">current = current.sibling;</span>
            <span class="s1">}</span>
          <span class="s3">null </span><span class="s1">!== type.tail &amp;&amp;</span>
            <span class="s1">now() &gt; workInProgressRootRenderTargetTime &amp;&amp;</span>
            <span class="s1">((workInProgress.flags |= </span><span class="s4">128</span><span class="s1">),</span>
            <span class="s1">(newProps = !</span><span class="s4">0</span><span class="s1">),</span>
            <span class="s1">cutOffTailIfNeeded(type, !</span><span class="s4">1</span><span class="s1">),</span>
            <span class="s1">(workInProgress.lanes = </span><span class="s4">4194304</span><span class="s1">));</span>
        <span class="s1">}</span>
      <span class="s3">else </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(!newProps)</span>
          <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">((current = findFirstSuspended(updatePayload)), </span><span class="s3">null </span><span class="s1">!== current)</span>
          <span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(</span>
              <span class="s1">((workInProgress.flags |= </span><span class="s4">128</span><span class="s1">),</span>
              <span class="s1">(newProps = !</span><span class="s4">0</span><span class="s1">),</span>
              <span class="s1">(current = current.updateQueue),</span>
              <span class="s3">null </span><span class="s1">!== current &amp;&amp;</span>
                <span class="s1">((workInProgress.updateQueue = current),</span>
                <span class="s1">(workInProgress.flags |= </span><span class="s4">4</span><span class="s1">)),</span>
              <span class="s1">cutOffTailIfNeeded(type, !</span><span class="s4">0</span><span class="s1">),</span>
              <span class="s3">null </span><span class="s1">=== type.tail &amp;&amp;</span>
                <span class="s2">&quot;hidden&quot; </span><span class="s1">=== type.tailMode &amp;&amp;</span>
                <span class="s1">!updatePayload.alternate)</span>
            <span class="s1">)</span>
              <span class="s3">return </span><span class="s1">bubbleProperties(workInProgress), </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else</span>
            <span class="s4">2 </span><span class="s1">* now() - type.renderingStartTime &gt;</span>
              <span class="s1">workInProgressRootRenderTargetTime &amp;&amp;</span>
              <span class="s4">1073741824 </span><span class="s1">!== renderLanes &amp;&amp;</span>
              <span class="s1">((workInProgress.flags |= </span><span class="s4">128</span><span class="s1">),</span>
              <span class="s1">(newProps = !</span><span class="s4">0</span><span class="s1">),</span>
              <span class="s1">cutOffTailIfNeeded(type, !</span><span class="s4">1</span><span class="s1">),</span>
              <span class="s1">(workInProgress.lanes = </span><span class="s4">4194304</span><span class="s1">));</span>
        <span class="s1">type.isBackwards</span>
          <span class="s1">? ((updatePayload.sibling = workInProgress.child),</span>
            <span class="s1">(workInProgress.child = updatePayload))</span>
          <span class="s1">: ((current = type.last),</span>
            <span class="s3">null </span><span class="s1">!== current</span>
              <span class="s1">? (current.sibling = updatePayload)</span>
              <span class="s1">: (workInProgress.child = updatePayload),</span>
            <span class="s1">(type.last = updatePayload));</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== type.tail)</span>
        <span class="s3">return </span><span class="s1">(</span>
          <span class="s1">(workInProgress = type.tail),</span>
          <span class="s1">(type.rendering = workInProgress),</span>
          <span class="s1">(type.tail = workInProgress.sibling),</span>
          <span class="s1">(type.renderingStartTime = now()),</span>
          <span class="s1">(workInProgress.sibling = </span><span class="s3">null</span><span class="s1">),</span>
          <span class="s1">(current = suspenseStackCursor.current),</span>
          <span class="s1">push(suspenseStackCursor, newProps ? (current &amp; </span><span class="s4">1</span><span class="s1">) | </span><span class="s4">2 </span><span class="s1">: current &amp; </span><span class="s4">1</span><span class="s1">),</span>
          <span class="s1">workInProgress</span>
        <span class="s1">);</span>
      <span class="s1">bubbleProperties(workInProgress);</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">22</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">23</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">popRenderLanes(),</span>
        <span class="s1">(renderLanes = </span><span class="s3">null </span><span class="s1">!== workInProgress.memoizedState),</span>
        <span class="s3">null </span><span class="s1">!== current &amp;&amp;</span>
          <span class="s1">(</span><span class="s3">null </span><span class="s1">!== current.memoizedState) !== renderLanes &amp;&amp;</span>
          <span class="s1">(workInProgress.flags |= </span><span class="s4">8192</span><span class="s1">),</span>
        <span class="s1">renderLanes &amp;&amp; </span><span class="s4">0 </span><span class="s1">!== (workInProgress.mode &amp; </span><span class="s4">1</span><span class="s1">)</span>
          <span class="s1">? </span><span class="s4">0 </span><span class="s1">!== (subtreeRenderLanes &amp; </span><span class="s4">1073741824</span><span class="s1">) &amp;&amp;</span>
            <span class="s1">(bubbleProperties(workInProgress),</span>
            <span class="s1">workInProgress.subtreeFlags &amp; </span><span class="s4">6 </span><span class="s1">&amp;&amp; (workInProgress.flags |= </span><span class="s4">8192</span><span class="s1">))</span>
          <span class="s1">: bubbleProperties(workInProgress),</span>
        <span class="s3">null</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">24</span><span class="s1">:</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">25</span><span class="s1">:</span>
      <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">throw </span><span class="s1">Error(</span>
    <span class="s2">&quot;Unknown unit of work tag (&quot; </span><span class="s1">+</span>
      <span class="s1">workInProgress.tag +</span>
      <span class="s2">&quot;). This error is likely caused by a bug in React. Please file an issue.&quot;</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">unwindWork(current, workInProgress) {</span>
  <span class="s1">popTreeContext(workInProgress);</span>
  <span class="s3">switch </span><span class="s1">(workInProgress.tag) {</span>
    <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">isContextProvider(workInProgress.type) &amp;&amp; popContext(),</span>
        <span class="s1">(current = workInProgress.flags),</span>
        <span class="s1">current &amp; </span><span class="s4">65536</span>
          <span class="s1">? ((workInProgress.flags = (current &amp; -</span><span class="s4">65537</span><span class="s1">) | </span><span class="s4">128</span><span class="s1">),</span>
            <span class="s4">0 </span><span class="s1">!== (workInProgress.mode &amp; </span><span class="s4">2</span><span class="s1">) &amp;&amp;</span>
              <span class="s1">transferActualDuration(workInProgress),</span>
            <span class="s1">workInProgress)</span>
          <span class="s1">: </span><span class="s3">null</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">popHostContainer(),</span>
        <span class="s1">pop(didPerformWorkStackCursor),</span>
        <span class="s1">pop(contextStackCursor),</span>
        <span class="s1">resetWorkInProgressVersions(),</span>
        <span class="s1">(current = workInProgress.flags),</span>
        <span class="s4">0 </span><span class="s1">!== (current &amp; </span><span class="s4">65536</span><span class="s1">) &amp;&amp; </span><span class="s4">0 </span><span class="s1">=== (current &amp; </span><span class="s4">128</span><span class="s1">)</span>
          <span class="s1">? ((workInProgress.flags = (current &amp; -</span><span class="s4">65537</span><span class="s1">) | </span><span class="s4">128</span><span class="s1">), workInProgress)</span>
          <span class="s1">: </span><span class="s3">null</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">popHostContext(workInProgress), </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">13</span><span class="s1">:</span>
      <span class="s1">pop(suspenseStackCursor);</span>
      <span class="s1">current = workInProgress.memoizedState;</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s3">null </span><span class="s1">!== current &amp;&amp;</span>
        <span class="s3">null </span><span class="s1">!== current.dehydrated &amp;&amp;</span>
        <span class="s3">null </span><span class="s1">=== workInProgress.alternate</span>
      <span class="s1">)</span>
        <span class="s3">throw </span><span class="s1">Error(</span>
          <span class="s2">&quot;Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">current = workInProgress.flags;</span>
      <span class="s3">return </span><span class="s1">current &amp; </span><span class="s4">65536</span>
        <span class="s1">? ((workInProgress.flags = (current &amp; -</span><span class="s4">65537</span><span class="s1">) | </span><span class="s4">128</span><span class="s1">),</span>
          <span class="s4">0 </span><span class="s1">!== (workInProgress.mode &amp; </span><span class="s4">2</span><span class="s1">) &amp;&amp;</span>
            <span class="s1">transferActualDuration(workInProgress),</span>
          <span class="s1">workInProgress)</span>
        <span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">19</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">pop(suspenseStackCursor), </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">popHostContainer(), </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">10</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">popProvider(workInProgress.type._context), </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">22</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">23</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">popRenderLanes(), </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">24</span><span class="s1">:</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s3">default</span><span class="s1">:</span>
      <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">PossiblyWeakSet = </span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">WeakSet ? WeakSet : Set,</span>
  <span class="s1">nextEffect = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">inProgressLanes = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">inProgressRoot = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">safelyDetachRef(current, nearestMountedAncestor) {</span>
  <span class="s3">var </span><span class="s1">ref = current.ref;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== ref)</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">ref)</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(current.mode &amp; </span><span class="s4">2</span><span class="s1">)</span>
          <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">startLayoutEffectTimer(), ref(</span><span class="s3">null</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
            <span class="s1">recordLayoutEffectDuration(current);</span>
          <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">ref(</span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s1">captureCommitPhaseError(current, nearestMountedAncestor, error);</span>
      <span class="s1">}</span>
    <span class="s3">else </span><span class="s1">ref.current = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">safelyCallDestroy(current, nearestMountedAncestor, destroy) {</span>
  <span class="s3">try </span><span class="s1">{</span>
    <span class="s1">destroy();</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
    <span class="s1">captureCommitPhaseError(current, nearestMountedAncestor, error);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">shouldFireAfterActiveInstanceBlur = !</span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">commitBeforeMutationEffects(root, firstChild) {</span>
  <span class="s3">for </span><span class="s1">(nextEffect = firstChild; </span><span class="s3">null </span><span class="s1">!== nextEffect; )</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">((root = nextEffect),</span>
      <span class="s1">(firstChild = root.child),</span>
      <span class="s4">0 </span><span class="s1">!== (root.subtreeFlags &amp; </span><span class="s4">1028</span><span class="s1">) &amp;&amp; </span><span class="s3">null </span><span class="s1">!== firstChild)</span>
    <span class="s1">)</span>
      <span class="s1">(firstChild.</span><span class="s3">return </span><span class="s1">= root), (nextEffect = firstChild);</span>
    <span class="s3">else</span>
      <span class="s3">for </span><span class="s1">(; </span><span class="s3">null </span><span class="s1">!== nextEffect; ) {</span>
        <span class="s1">root = nextEffect;</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">var </span><span class="s1">current = root.alternate;</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (root.flags &amp; </span><span class="s4">1024</span><span class="s1">))</span>
            <span class="s3">switch </span><span class="s1">(root.tag) {</span>
              <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
              <span class="s3">case </span><span class="s4">11</span><span class="s1">:</span>
              <span class="s3">case </span><span class="s4">15</span><span class="s1">:</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== current) {</span>
                  <span class="s3">var </span><span class="s1">prevProps = current.memoizedProps,</span>
                    <span class="s1">prevState = current.memoizedState,</span>
                    <span class="s1">instance = root.stateNode,</span>
                    <span class="s1">snapshot = instance.getSnapshotBeforeUpdate(</span>
                      <span class="s1">root.elementType === root.type</span>
                        <span class="s1">? prevProps</span>
                        <span class="s1">: resolveDefaultProps(root.type, prevProps),</span>
                      <span class="s1">prevState</span>
                    <span class="s1">);</span>
                  <span class="s1">instance.__reactInternalSnapshotBeforeUpdate = snapshot;</span>
                <span class="s1">}</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
              <span class="s3">case </span><span class="s4">6</span><span class="s1">:</span>
              <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
              <span class="s3">case </span><span class="s4">17</span><span class="s1">:</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">default</span><span class="s1">:</span>
                <span class="s3">throw </span><span class="s1">Error(</span>
                  <span class="s2">&quot;This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
                <span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
          <span class="s1">captureCommitPhaseError(root, root.</span><span class="s3">return</span><span class="s1">, error);</span>
        <span class="s1">}</span>
        <span class="s1">firstChild = root.sibling;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== firstChild) {</span>
          <span class="s1">firstChild.</span><span class="s3">return </span><span class="s1">= root.</span><span class="s3">return</span><span class="s1">;</span>
          <span class="s1">nextEffect = firstChild;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">nextEffect = root.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
  <span class="s1">current = shouldFireAfterActiveInstanceBlur;</span>
  <span class="s1">shouldFireAfterActiveInstanceBlur = !</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">current;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">commitHookEffectListUnmount(</span>
  <span class="s1">flags,</span>
  <span class="s1">finishedWork,</span>
  <span class="s1">nearestMountedAncestor</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">updateQueue = finishedWork.updateQueue;</span>
  <span class="s1">updateQueue = </span><span class="s3">null </span><span class="s1">!== updateQueue ? updateQueue.lastEffect : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== updateQueue) {</span>
    <span class="s3">var </span><span class="s1">effect = (updateQueue = updateQueue.next);</span>
    <span class="s3">do </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">((effect.tag &amp; flags) === flags) {</span>
        <span class="s3">var </span><span class="s1">destroy = effect.destroy;</span>
        <span class="s1">effect.destroy = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">void </span><span class="s4">0 </span><span class="s1">!== destroy &amp;&amp;</span>
          <span class="s1">safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);</span>
      <span class="s1">}</span>
      <span class="s1">effect = effect.next;</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(effect !== updateQueue);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">commitHookEffectListMount(flags, finishedWork) {</span>
  <span class="s1">finishedWork = finishedWork.updateQueue;</span>
  <span class="s1">finishedWork = </span><span class="s3">null </span><span class="s1">!== finishedWork ? finishedWork.lastEffect : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== finishedWork) {</span>
    <span class="s3">var </span><span class="s1">effect = (finishedWork = finishedWork.next);</span>
    <span class="s3">do </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">((effect.tag &amp; flags) === flags) {</span>
        <span class="s3">var </span><span class="s1">create$83 = effect.create;</span>
        <span class="s1">effect.destroy = create$83();</span>
      <span class="s1">}</span>
      <span class="s1">effect = effect.next;</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(effect !== finishedWork);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">detachFiberAfterEffects(fiber) {</span>
  <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>
  <span class="s3">null </span><span class="s1">!== alternate &amp;&amp;</span>
    <span class="s1">((fiber.alternate = </span><span class="s3">null</span><span class="s1">), detachFiberAfterEffects(alternate));</span>
  <span class="s1">fiber.child = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">fiber.deletions = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">fiber.sibling = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">fiber.stateNode = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">fiber.</span><span class="s3">return </span><span class="s1">= </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">fiber.dependencies = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">fiber.memoizedProps = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">fiber.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">fiber.pendingProps = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">fiber.stateNode = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">fiber.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isHostParent(fiber) {</span>
  <span class="s3">return </span><span class="s4">5 </span><span class="s1">=== fiber.tag || </span><span class="s4">3 </span><span class="s1">=== fiber.tag || </span><span class="s4">4 </span><span class="s1">=== fiber.tag;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getHostSibling(fiber) {</span>
  <span class="s1">a: </span><span class="s3">for </span><span class="s1">(;;) {</span>
    <span class="s3">for </span><span class="s1">(; </span><span class="s3">null </span><span class="s1">=== fiber.sibling; ) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== fiber.</span><span class="s3">return </span><span class="s1">|| isHostParent(fiber.</span><span class="s3">return</span><span class="s1">)) </span><span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">fiber = fiber.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">fiber.sibling.</span><span class="s3">return </span><span class="s1">= fiber.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">for </span><span class="s1">(</span>
      <span class="s1">fiber = fiber.sibling;</span>
      <span class="s4">5 </span><span class="s1">!== fiber.tag &amp;&amp; </span><span class="s4">6 </span><span class="s1">!== fiber.tag &amp;&amp; </span><span class="s4">18 </span><span class="s1">!== fiber.tag;</span>

    <span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(fiber.flags &amp; </span><span class="s4">2</span><span class="s1">) </span><span class="s3">continue </span><span class="s1">a;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== fiber.child || </span><span class="s4">4 </span><span class="s1">=== fiber.tag) </span><span class="s3">continue </span><span class="s1">a;</span>
      <span class="s3">else </span><span class="s1">(fiber.child.</span><span class="s3">return </span><span class="s1">= fiber), (fiber = fiber.child);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(!(fiber.flags &amp; </span><span class="s4">2</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">fiber.stateNode;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">insertOrAppendPlacementNodeIntoContainer(node, before, parent) {</span>
  <span class="s3">var </span><span class="s1">tag = node.tag;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">5 </span><span class="s1">=== tag || </span><span class="s4">6 </span><span class="s1">=== tag)</span>
    <span class="s3">if </span><span class="s1">(((node = node.stateNode), before)) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;number&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">parent)</span>
        <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Container does not support insertBefore operation&quot;</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else</span>
      <span class="s1">ReactNativePrivateInterface.UIManager.setChildren(parent, [</span>
        <span class="s2">&quot;number&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">node ? node : node._nativeTag</span>
      <span class="s1">]);</span>
  <span class="s3">else if </span><span class="s1">(</span><span class="s4">4 </span><span class="s1">!== tag &amp;&amp; ((node = node.child), </span><span class="s3">null </span><span class="s1">!== node))</span>
    <span class="s3">for </span><span class="s1">(</span>
      <span class="s1">insertOrAppendPlacementNodeIntoContainer(node, before, parent),</span>
        <span class="s1">node = node.sibling;</span>
      <span class="s3">null </span><span class="s1">!== node;</span>

    <span class="s1">)</span>
      <span class="s1">insertOrAppendPlacementNodeIntoContainer(node, before, parent),</span>
        <span class="s1">(node = node.sibling);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">insertOrAppendPlacementNode(node, before, parent) {</span>
  <span class="s3">var </span><span class="s1">tag = node.tag;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">5 </span><span class="s1">=== tag || </span><span class="s4">6 </span><span class="s1">=== tag)</span>
    <span class="s3">if </span><span class="s1">(((node = node.stateNode), before)) {</span>
      <span class="s1">tag = parent._children;</span>
      <span class="s3">var </span><span class="s1">index = tag.indexOf(node);</span>
      <span class="s4">0 </span><span class="s1">&lt;= index</span>
        <span class="s1">? (tag.splice(index, </span><span class="s4">1</span><span class="s1">),</span>
          <span class="s1">(before = tag.indexOf(before)),</span>
          <span class="s1">tag.splice(before, </span><span class="s4">0</span><span class="s1">, node),</span>
          <span class="s1">ReactNativePrivateInterface.UIManager.manageChildren(</span>
            <span class="s1">parent._nativeTag,</span>
            <span class="s1">[index],</span>
            <span class="s1">[before],</span>
            <span class="s1">[],</span>
            <span class="s1">[],</span>
            <span class="s1">[]</span>
          <span class="s1">))</span>
        <span class="s1">: ((before = tag.indexOf(before)),</span>
          <span class="s1">tag.splice(before, </span><span class="s4">0</span><span class="s1">, node),</span>
          <span class="s1">ReactNativePrivateInterface.UIManager.manageChildren(</span>
            <span class="s1">parent._nativeTag,</span>
            <span class="s1">[],</span>
            <span class="s1">[],</span>
            <span class="s1">[</span><span class="s2">&quot;number&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">node ? node : node._nativeTag],</span>
            <span class="s1">[before],</span>
            <span class="s1">[]</span>
          <span class="s1">));</span>
    <span class="s1">} </span><span class="s3">else</span>
      <span class="s1">(before = </span><span class="s2">&quot;number&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">node ? node : node._nativeTag),</span>
        <span class="s1">(tag = parent._children),</span>
        <span class="s1">(index = tag.indexOf(node)),</span>
        <span class="s4">0 </span><span class="s1">&lt;= index</span>
          <span class="s1">? (tag.splice(index, </span><span class="s4">1</span><span class="s1">),</span>
            <span class="s1">tag.push(node),</span>
            <span class="s1">ReactNativePrivateInterface.UIManager.manageChildren(</span>
              <span class="s1">parent._nativeTag,</span>
              <span class="s1">[index],</span>
              <span class="s1">[tag.length - </span><span class="s4">1</span><span class="s1">],</span>
              <span class="s1">[],</span>
              <span class="s1">[],</span>
              <span class="s1">[]</span>
            <span class="s1">))</span>
          <span class="s1">: (tag.push(node),</span>
            <span class="s1">ReactNativePrivateInterface.UIManager.manageChildren(</span>
              <span class="s1">parent._nativeTag,</span>
              <span class="s1">[],</span>
              <span class="s1">[],</span>
              <span class="s1">[before],</span>
              <span class="s1">[tag.length - </span><span class="s4">1</span><span class="s1">],</span>
              <span class="s1">[]</span>
            <span class="s1">));</span>
  <span class="s3">else if </span><span class="s1">(</span><span class="s4">4 </span><span class="s1">!== tag &amp;&amp; ((node = node.child), </span><span class="s3">null </span><span class="s1">!== node))</span>
    <span class="s3">for </span><span class="s1">(</span>
      <span class="s1">insertOrAppendPlacementNode(node, before, parent), node = node.sibling;</span>
      <span class="s3">null </span><span class="s1">!== node;</span>

    <span class="s1">)</span>
      <span class="s1">insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">hostParent = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">hostParentIsContainer = !</span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">recursivelyTraverseDeletionEffects(</span>
  <span class="s1">finishedRoot,</span>
  <span class="s1">nearestMountedAncestor,</span>
  <span class="s1">parent</span>
<span class="s1">) {</span>
  <span class="s3">for </span><span class="s1">(parent = parent.child; </span><span class="s3">null </span><span class="s1">!== parent; )</span>
    <span class="s1">commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),</span>
      <span class="s1">(parent = parent.sibling);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">commitDeletionEffectsOnFiber(</span>
  <span class="s1">finishedRoot,</span>
  <span class="s1">nearestMountedAncestor,</span>
  <span class="s1">deletedFiber</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(injectedHook &amp;&amp; </span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">injectedHook.onCommitFiberUnmount)</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {}</span>
  <span class="s3">switch </span><span class="s1">(deletedFiber.tag) {</span>
    <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
      <span class="s1">safelyDetachRef(deletedFiber, nearestMountedAncestor);</span>
    <span class="s3">case </span><span class="s4">6</span><span class="s1">:</span>
      <span class="s3">var </span><span class="s1">prevHostParent = hostParent,</span>
        <span class="s1">prevHostParentIsContainer = hostParentIsContainer;</span>
      <span class="s1">hostParent = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">recursivelyTraverseDeletionEffects(</span>
        <span class="s1">finishedRoot,</span>
        <span class="s1">nearestMountedAncestor,</span>
        <span class="s1">deletedFiber</span>
      <span class="s1">);</span>
      <span class="s1">hostParent = prevHostParent;</span>
      <span class="s1">hostParentIsContainer = prevHostParentIsContainer;</span>
      <span class="s3">null </span><span class="s1">!== hostParent &amp;&amp;</span>
        <span class="s1">(hostParentIsContainer</span>
          <span class="s1">? ((finishedRoot = hostParent),</span>
            <span class="s1">recursivelyUncacheFiberNode(deletedFiber.stateNode),</span>
            <span class="s1">ReactNativePrivateInterface.UIManager.manageChildren(</span>
              <span class="s1">finishedRoot,</span>
              <span class="s1">[],</span>
              <span class="s1">[],</span>
              <span class="s1">[],</span>
              <span class="s1">[],</span>
              <span class="s1">[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">))</span>
          <span class="s1">: ((finishedRoot = hostParent),</span>
            <span class="s1">(nearestMountedAncestor = deletedFiber.stateNode),</span>
            <span class="s1">recursivelyUncacheFiberNode(nearestMountedAncestor),</span>
            <span class="s1">(deletedFiber = finishedRoot._children),</span>
            <span class="s1">(nearestMountedAncestor = deletedFiber.indexOf(</span>
              <span class="s1">nearestMountedAncestor</span>
            <span class="s1">)),</span>
            <span class="s1">deletedFiber.splice(nearestMountedAncestor, </span><span class="s4">1</span><span class="s1">),</span>
            <span class="s1">ReactNativePrivateInterface.UIManager.manageChildren(</span>
              <span class="s1">finishedRoot._nativeTag,</span>
              <span class="s1">[],</span>
              <span class="s1">[],</span>
              <span class="s1">[],</span>
              <span class="s1">[],</span>
              <span class="s1">[nearestMountedAncestor]</span>
            <span class="s1">)));</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">18</span><span class="s1">:</span>
      <span class="s3">null </span><span class="s1">!== hostParent &amp;&amp; shim(hostParent, deletedFiber.stateNode);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
      <span class="s1">prevHostParent = hostParent;</span>
      <span class="s1">prevHostParentIsContainer = hostParentIsContainer;</span>
      <span class="s1">hostParent = deletedFiber.stateNode.containerInfo;</span>
      <span class="s1">hostParentIsContainer = !</span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">recursivelyTraverseDeletionEffects(</span>
        <span class="s1">finishedRoot,</span>
        <span class="s1">nearestMountedAncestor,</span>
        <span class="s1">deletedFiber</span>
      <span class="s1">);</span>
      <span class="s1">hostParent = prevHostParent;</span>
      <span class="s1">hostParentIsContainer = prevHostParentIsContainer;</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">11</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">14</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">15</span><span class="s1">:</span>
      <span class="s1">prevHostParent = deletedFiber.updateQueue;</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s3">null </span><span class="s1">!== prevHostParent &amp;&amp;</span>
        <span class="s1">((prevHostParent = prevHostParent.lastEffect), </span><span class="s3">null </span><span class="s1">!== prevHostParent)</span>
      <span class="s1">) {</span>
        <span class="s1">prevHostParentIsContainer = prevHostParent = prevHostParent.next;</span>
        <span class="s3">do </span><span class="s1">{</span>
          <span class="s3">var </span><span class="s1">_effect = prevHostParentIsContainer,</span>
            <span class="s1">destroy = _effect.destroy;</span>
          <span class="s1">_effect = _effect.tag;</span>
          <span class="s3">void </span><span class="s4">0 </span><span class="s1">!== destroy &amp;&amp;</span>
            <span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (_effect &amp; </span><span class="s4">2</span><span class="s1">)</span>
              <span class="s1">? safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy)</span>
              <span class="s1">: </span><span class="s4">0 </span><span class="s1">!== (_effect &amp; </span><span class="s4">4</span><span class="s1">) &amp;&amp;</span>
                <span class="s1">(deletedFiber.mode &amp; </span><span class="s4">2</span>
                  <span class="s1">? (startLayoutEffectTimer(),</span>
                    <span class="s1">safelyCallDestroy(</span>
                      <span class="s1">deletedFiber,</span>
                      <span class="s1">nearestMountedAncestor,</span>
                      <span class="s1">destroy</span>
                    <span class="s1">),</span>
                    <span class="s1">recordLayoutEffectDuration(deletedFiber))</span>
                  <span class="s1">: safelyCallDestroy(</span>
                      <span class="s1">deletedFiber,</span>
                      <span class="s1">nearestMountedAncestor,</span>
                      <span class="s1">destroy</span>
                    <span class="s1">)));</span>
          <span class="s1">prevHostParentIsContainer = prevHostParentIsContainer.next;</span>
        <span class="s1">} </span><span class="s3">while </span><span class="s1">(prevHostParentIsContainer !== prevHostParent);</span>
      <span class="s1">}</span>
      <span class="s1">recursivelyTraverseDeletionEffects(</span>
        <span class="s1">finishedRoot,</span>
        <span class="s1">nearestMountedAncestor,</span>
        <span class="s1">deletedFiber</span>
      <span class="s1">);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
      <span class="s1">safelyDetachRef(deletedFiber, nearestMountedAncestor);</span>
      <span class="s1">prevHostParent = deletedFiber.stateNode;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">prevHostParent.componentWillUnmount)</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">((prevHostParent.props = deletedFiber.memoizedProps),</span>
            <span class="s1">(prevHostParent.state = deletedFiber.memoizedState),</span>
            <span class="s1">deletedFiber.mode &amp; </span><span class="s4">2</span><span class="s1">)</span>
          <span class="s1">)</span>
            <span class="s3">try </span><span class="s1">{</span>
              <span class="s1">startLayoutEffectTimer(), prevHostParent.componentWillUnmount();</span>
            <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
              <span class="s1">recordLayoutEffectDuration(deletedFiber);</span>
            <span class="s1">}</span>
          <span class="s3">else </span><span class="s1">prevHostParent.componentWillUnmount();</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
          <span class="s1">captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);</span>
        <span class="s1">}</span>
      <span class="s1">recursivelyTraverseDeletionEffects(</span>
        <span class="s1">finishedRoot,</span>
        <span class="s1">nearestMountedAncestor,</span>
        <span class="s1">deletedFiber</span>
      <span class="s1">);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">21</span><span class="s1">:</span>
      <span class="s1">recursivelyTraverseDeletionEffects(</span>
        <span class="s1">finishedRoot,</span>
        <span class="s1">nearestMountedAncestor,</span>
        <span class="s1">deletedFiber</span>
      <span class="s1">);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">22</span><span class="s1">:</span>
      <span class="s1">recursivelyTraverseDeletionEffects(</span>
        <span class="s1">finishedRoot,</span>
        <span class="s1">nearestMountedAncestor,</span>
        <span class="s1">deletedFiber</span>
      <span class="s1">);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">default</span><span class="s1">:</span>
      <span class="s1">recursivelyTraverseDeletionEffects(</span>
        <span class="s1">finishedRoot,</span>
        <span class="s1">nearestMountedAncestor,</span>
        <span class="s1">deletedFiber</span>
      <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">attachSuspenseRetryListeners(finishedWork) {</span>
  <span class="s3">var </span><span class="s1">wakeables = finishedWork.updateQueue;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== wakeables) {</span>
    <span class="s1">finishedWork.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">retryCache = finishedWork.stateNode;</span>
    <span class="s3">null </span><span class="s1">=== retryCache &amp;&amp;</span>
      <span class="s1">(retryCache = finishedWork.stateNode = </span><span class="s3">new </span><span class="s1">PossiblyWeakSet());</span>
    <span class="s1">wakeables.forEach(</span><span class="s3">function</span><span class="s1">(wakeable) {</span>
      <span class="s3">var </span><span class="s1">retry = resolveRetryWakeable.bind(</span><span class="s3">null</span><span class="s1">, finishedWork, wakeable);</span>
      <span class="s3">if </span><span class="s1">(!retryCache.has(wakeable)) {</span>
        <span class="s1">retryCache.add(wakeable);</span>
        <span class="s3">if </span><span class="s1">(isDevToolsPresent)</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== inProgressLanes &amp;&amp; </span><span class="s3">null </span><span class="s1">!== inProgressRoot)</span>
            <span class="s1">restorePendingUpdaters(inProgressRoot, inProgressLanes);</span>
          <span class="s3">else</span>
            <span class="s3">throw </span><span class="s1">Error(</span>
              <span class="s2">&quot;Expected finished root and lanes to be set. This is a bug in React.&quot;</span>
            <span class="s1">);</span>
        <span class="s1">wakeable.then(retry, retry);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">commitMutationEffects(root, finishedWork, committedLanes) {</span>
  <span class="s1">inProgressLanes = committedLanes;</span>
  <span class="s1">inProgressRoot = root;</span>
  <span class="s1">commitMutationEffectsOnFiber(finishedWork, root);</span>
  <span class="s1">inProgressRoot = inProgressLanes = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {</span>
  <span class="s3">var </span><span class="s1">deletions = parentFiber.deletions;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== deletions)</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; deletions.length; i++) {</span>
      <span class="s3">var </span><span class="s1">childToDelete = deletions[i];</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">root = root$jscomp$0,</span>
          <span class="s1">returnFiber = parentFiber,</span>
          <span class="s1">parent = returnFiber;</span>
        <span class="s1">a: </span><span class="s3">for </span><span class="s1">(; </span><span class="s3">null </span><span class="s1">!== parent; ) {</span>
          <span class="s3">switch </span><span class="s1">(parent.tag) {</span>
            <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
              <span class="s1">hostParent = parent.stateNode;</span>
              <span class="s1">hostParentIsContainer = !</span><span class="s4">1</span><span class="s1">;</span>
              <span class="s3">break </span><span class="s1">a;</span>
            <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
              <span class="s1">hostParent = parent.stateNode.containerInfo;</span>
              <span class="s1">hostParentIsContainer = !</span><span class="s4">0</span><span class="s1">;</span>
              <span class="s3">break </span><span class="s1">a;</span>
            <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
              <span class="s1">hostParent = parent.stateNode.containerInfo;</span>
              <span class="s1">hostParentIsContainer = !</span><span class="s4">0</span><span class="s1">;</span>
              <span class="s3">break </span><span class="s1">a;</span>
          <span class="s1">}</span>
          <span class="s1">parent = parent.</span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== hostParent)</span>
          <span class="s3">throw </span><span class="s1">Error(</span>
            <span class="s2">&quot;Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
          <span class="s1">);</span>
        <span class="s1">commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);</span>
        <span class="s1">hostParent = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">hostParentIsContainer = !</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">alternate = childToDelete.alternate;</span>
        <span class="s3">null </span><span class="s1">!== alternate &amp;&amp; (alternate.</span><span class="s3">return </span><span class="s1">= </span><span class="s3">null</span><span class="s1">);</span>
        <span class="s1">childToDelete.</span><span class="s3">return </span><span class="s1">= </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s1">captureCommitPhaseError(childToDelete, parentFiber, error);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(parentFiber.subtreeFlags &amp; </span><span class="s4">12854</span><span class="s1">)</span>
    <span class="s3">for </span><span class="s1">(parentFiber = parentFiber.child; </span><span class="s3">null </span><span class="s1">!== parentFiber; )</span>
      <span class="s1">commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),</span>
        <span class="s1">(parentFiber = parentFiber.sibling);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">commitMutationEffectsOnFiber(finishedWork, root) {</span>
  <span class="s3">var </span><span class="s1">current = finishedWork.alternate,</span>
    <span class="s1">flags = finishedWork.flags;</span>
  <span class="s3">switch </span><span class="s1">(finishedWork.tag) {</span>
    <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">11</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">14</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s4">15</span><span class="s1">:</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>
      <span class="s3">if </span><span class="s1">(flags &amp; </span><span class="s4">4</span><span class="s1">) {</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s1">commitHookEffectListUnmount(</span><span class="s4">3</span><span class="s1">, finishedWork, finishedWork.</span><span class="s3">return</span><span class="s1">),</span>
            <span class="s1">commitHookEffectListMount(</span><span class="s4">3</span><span class="s1">, finishedWork);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
          <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s3">return</span><span class="s1">, error);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(finishedWork.mode &amp; </span><span class="s4">2</span><span class="s1">) {</span>
          <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">startLayoutEffectTimer(),</span>
              <span class="s1">commitHookEffectListUnmount(</span><span class="s4">5</span><span class="s1">, finishedWork, finishedWork.</span><span class="s3">return</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error$95) {</span>
            <span class="s1">captureCommitPhaseError(</span>
              <span class="s1">finishedWork,</span>
              <span class="s1">finishedWork.</span><span class="s3">return</span><span class="s1">,</span>
              <span class="s1">error$95</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s1">recordLayoutEffectDuration(finishedWork);</span>
        <span class="s1">} </span><span class="s3">else</span>
          <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">commitHookEffectListUnmount(</span><span class="s4">5</span><span class="s1">, finishedWork, finishedWork.</span><span class="s3">return</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error$96) {</span>
            <span class="s1">captureCommitPhaseError(</span>
              <span class="s1">finishedWork,</span>
              <span class="s1">finishedWork.</span><span class="s3">return</span><span class="s1">,</span>
              <span class="s1">error$96</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>
      <span class="s1">flags &amp; </span><span class="s4">512 </span><span class="s1">&amp;&amp;</span>
        <span class="s3">null </span><span class="s1">!== current &amp;&amp;</span>
        <span class="s1">safelyDetachRef(current, current.</span><span class="s3">return</span><span class="s1">);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>
      <span class="s1">flags &amp; </span><span class="s4">512 </span><span class="s1">&amp;&amp;</span>
        <span class="s3">null </span><span class="s1">!== current &amp;&amp;</span>
        <span class="s1">safelyDetachRef(current, current.</span><span class="s3">return</span><span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(flags &amp; </span><span class="s4">4</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">instance$98 = finishedWork.stateNode;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!= instance$98) {</span>
          <span class="s3">var </span><span class="s1">newProps = finishedWork.memoizedProps,</span>
            <span class="s1">oldProps = </span><span class="s3">null </span><span class="s1">!== current ? current.memoizedProps : newProps,</span>
            <span class="s1">updatePayload = finishedWork.updateQueue;</span>
          <span class="s1">finishedWork.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== updatePayload)</span>
            <span class="s3">try </span><span class="s1">{</span>
              <span class="s3">var </span><span class="s1">viewConfig = instance$98.viewConfig;</span>
              <span class="s1">instanceProps.set(instance$98._nativeTag, newProps);</span>
              <span class="s3">var </span><span class="s1">updatePayload$jscomp$0 = diffProperties(</span>
                <span class="s3">null</span><span class="s1">,</span>
                <span class="s1">oldProps,</span>
                <span class="s1">newProps,</span>
                <span class="s1">viewConfig.validAttributes</span>
              <span class="s1">);</span>
              <span class="s3">null </span><span class="s1">!= updatePayload$jscomp$0 &amp;&amp;</span>
                <span class="s1">ReactNativePrivateInterface.UIManager.updateView(</span>
                  <span class="s1">instance$98._nativeTag,</span>
                  <span class="s1">viewConfig.uiViewClassName,</span>
                  <span class="s1">updatePayload$jscomp$0</span>
                <span class="s1">);</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error$99) {</span>
              <span class="s1">captureCommitPhaseError(</span>
                <span class="s1">finishedWork,</span>
                <span class="s1">finishedWork.</span><span class="s3">return</span><span class="s1">,</span>
                <span class="s1">error$99</span>
              <span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">6</span><span class="s1">:</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>
      <span class="s3">if </span><span class="s1">(flags &amp; </span><span class="s4">4</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== finishedWork.stateNode)</span>
          <span class="s3">throw </span><span class="s1">Error(</span>
            <span class="s2">&quot;This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
          <span class="s1">);</span>
        <span class="s1">viewConfig = finishedWork.stateNode;</span>
        <span class="s1">updatePayload$jscomp$0 = finishedWork.memoizedProps;</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s1">ReactNativePrivateInterface.UIManager.updateView(</span>
            <span class="s1">viewConfig,</span>
            <span class="s2">&quot;RCTRawText&quot;</span><span class="s1">,</span>
            <span class="s1">{ text: updatePayload$jscomp$0 }</span>
          <span class="s1">);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error$100) {</span>
          <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s3">return</span><span class="s1">, error$100);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">13</span><span class="s1">:</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>
      <span class="s1">viewConfig = finishedWork.child;</span>
      <span class="s1">viewConfig.flags &amp; </span><span class="s4">8192 </span><span class="s1">&amp;&amp;</span>
        <span class="s1">((updatePayload$jscomp$0 = </span><span class="s3">null </span><span class="s1">!== viewConfig.memoizedState),</span>
        <span class="s1">(viewConfig.stateNode.isHidden = updatePayload$jscomp$0),</span>
        <span class="s1">!updatePayload$jscomp$0 ||</span>
          <span class="s1">(</span><span class="s3">null </span><span class="s1">!== viewConfig.alternate &amp;&amp;</span>
            <span class="s3">null </span><span class="s1">!== viewConfig.alternate.memoizedState) ||</span>
          <span class="s1">(globalMostRecentFallbackTime = now()));</span>
      <span class="s1">flags &amp; </span><span class="s4">4 </span><span class="s1">&amp;&amp; attachSuspenseRetryListeners(finishedWork);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">22</span><span class="s1">:</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>
      <span class="s3">if </span><span class="s1">(flags &amp; </span><span class="s4">8192</span><span class="s1">)</span>
        <span class="s1">a: </span><span class="s3">for </span><span class="s1">(</span>
          <span class="s1">viewConfig = </span><span class="s3">null </span><span class="s1">!== finishedWork.memoizedState,</span>
            <span class="s1">finishedWork.stateNode.isHidden = viewConfig,</span>
            <span class="s1">updatePayload$jscomp$0 = </span><span class="s3">null</span><span class="s1">,</span>
            <span class="s1">current = finishedWork;</span>
          <span class="s1">;</span>

        <span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s4">5 </span><span class="s1">=== current.tag) {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== updatePayload$jscomp$0) {</span>
              <span class="s1">updatePayload$jscomp$0 = current;</span>
              <span class="s3">try </span><span class="s1">{</span>
                <span class="s3">if </span><span class="s1">(((instance$98 = current.stateNode), viewConfig))</span>
                  <span class="s1">(newProps = instance$98.viewConfig),</span>
                    <span class="s1">(oldProps = diffProperties(</span>
                      <span class="s3">null</span><span class="s1">,</span>
                      <span class="s1">emptyObject,</span>
                      <span class="s1">{ style: { display: </span><span class="s2">&quot;none&quot; </span><span class="s1">} },</span>
                      <span class="s1">newProps.validAttributes</span>
                    <span class="s1">)),</span>
                    <span class="s1">ReactNativePrivateInterface.UIManager.updateView(</span>
                      <span class="s1">instance$98._nativeTag,</span>
                      <span class="s1">newProps.uiViewClassName,</span>
                      <span class="s1">oldProps</span>
                    <span class="s1">);</span>
                <span class="s3">else </span><span class="s1">{</span>
                  <span class="s1">updatePayload = current.stateNode;</span>
                  <span class="s3">var </span><span class="s1">props = current.memoizedProps,</span>
                    <span class="s1">viewConfig$jscomp$0 = updatePayload.viewConfig,</span>
                    <span class="s1">prevProps = assign({}, props, {</span>
                      <span class="s1">style: [props.style, { display: </span><span class="s2">&quot;none&quot; </span><span class="s1">}]</span>
                    <span class="s1">});</span>
                  <span class="s3">var </span><span class="s1">updatePayload$jscomp$1 = diffProperties(</span>
                    <span class="s3">null</span><span class="s1">,</span>
                    <span class="s1">prevProps,</span>
                    <span class="s1">props,</span>
                    <span class="s1">viewConfig$jscomp$0.validAttributes</span>
                  <span class="s1">);</span>
                  <span class="s1">ReactNativePrivateInterface.UIManager.updateView(</span>
                    <span class="s1">updatePayload._nativeTag,</span>
                    <span class="s1">viewConfig$jscomp$0.uiViewClassName,</span>
                    <span class="s1">updatePayload$jscomp$1</span>
                  <span class="s1">);</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
                <span class="s1">captureCommitPhaseError(</span>
                  <span class="s1">finishedWork,</span>
                  <span class="s1">finishedWork.</span><span class="s3">return</span><span class="s1">,</span>
                  <span class="s1">error</span>
                <span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s4">6 </span><span class="s1">=== current.tag) {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== updatePayload$jscomp$0)</span>
              <span class="s3">try </span><span class="s1">{</span>
                <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Not yet implemented.&quot;</span><span class="s1">);</span>
              <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error$90) {</span>
                <span class="s1">captureCommitPhaseError(</span>
                  <span class="s1">finishedWork,</span>
                  <span class="s1">finishedWork.</span><span class="s3">return</span><span class="s1">,</span>
                  <span class="s1">error$90</span>
                <span class="s1">);</span>
              <span class="s1">}</span>
          <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
            <span class="s1">((</span><span class="s4">22 </span><span class="s1">!== current.tag &amp;&amp; </span><span class="s4">23 </span><span class="s1">!== current.tag) ||</span>
              <span class="s3">null </span><span class="s1">=== current.memoizedState ||</span>
              <span class="s1">current === finishedWork) &amp;&amp;</span>
            <span class="s3">null </span><span class="s1">!== current.child</span>
          <span class="s1">) {</span>
            <span class="s1">current.child.</span><span class="s3">return </span><span class="s1">= current;</span>
            <span class="s1">current = current.child;</span>
            <span class="s3">continue</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s3">if </span><span class="s1">(current === finishedWork) </span><span class="s3">break </span><span class="s1">a;</span>
          <span class="s3">for </span><span class="s1">(; </span><span class="s3">null </span><span class="s1">=== current.sibling; ) {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== current.</span><span class="s3">return </span><span class="s1">|| current.</span><span class="s3">return </span><span class="s1">=== finishedWork)</span>
              <span class="s3">break </span><span class="s1">a;</span>
            <span class="s1">updatePayload$jscomp$0 === current &amp;&amp;</span>
              <span class="s1">(updatePayload$jscomp$0 = </span><span class="s3">null</span><span class="s1">);</span>
            <span class="s1">current = current.</span><span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s1">updatePayload$jscomp$0 === current &amp;&amp; (updatePayload$jscomp$0 = </span><span class="s3">null</span><span class="s1">);</span>
          <span class="s1">current.sibling.</span><span class="s3">return </span><span class="s1">= current.</span><span class="s3">return</span><span class="s1">;</span>
          <span class="s1">current = current.sibling;</span>
        <span class="s1">}</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">19</span><span class="s1">:</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>
      <span class="s1">flags &amp; </span><span class="s4">4 </span><span class="s1">&amp;&amp; attachSuspenseRetryListeners(finishedWork);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">21</span><span class="s1">:</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">default</span><span class="s1">:</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork),</span>
        <span class="s1">commitReconciliationEffects(finishedWork);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">commitReconciliationEffects(finishedWork) {</span>
  <span class="s3">var </span><span class="s1">flags = finishedWork.flags;</span>
  <span class="s3">if </span><span class="s1">(flags &amp; </span><span class="s4">2</span><span class="s1">) {</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">a: {</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">parent = finishedWork.</span><span class="s3">return</span><span class="s1">; </span><span class="s3">null </span><span class="s1">!== parent; ) {</span>
          <span class="s3">if </span><span class="s1">(isHostParent(parent)) {</span>
            <span class="s3">var </span><span class="s1">JSCompiler_inline_result = parent;</span>
            <span class="s3">break </span><span class="s1">a;</span>
          <span class="s1">}</span>
          <span class="s1">parent = parent.</span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">throw </span><span class="s1">Error(</span>
          <span class="s2">&quot;Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s3">switch </span><span class="s1">(JSCompiler_inline_result.tag) {</span>
        <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
          <span class="s3">var </span><span class="s1">parent$jscomp$0 = JSCompiler_inline_result.stateNode;</span>
          <span class="s1">JSCompiler_inline_result.flags &amp; </span><span class="s4">32 </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(JSCompiler_inline_result.flags &amp;= -</span><span class="s4">33</span><span class="s1">);</span>
          <span class="s3">var </span><span class="s1">before = getHostSibling(finishedWork);</span>
          <span class="s1">insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
          <span class="s3">var </span><span class="s1">parent$91 = JSCompiler_inline_result.stateNode.containerInfo,</span>
            <span class="s1">before$92 = getHostSibling(finishedWork);</span>
          <span class="s1">insertOrAppendPlacementNodeIntoContainer(</span>
            <span class="s1">finishedWork,</span>
            <span class="s1">before$92,</span>
            <span class="s1">parent$91</span>
          <span class="s1">);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">default</span><span class="s1">:</span>
          <span class="s3">throw </span><span class="s1">Error(</span>
            <span class="s2">&quot;Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
          <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
      <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s3">return</span><span class="s1">, error);</span>
    <span class="s1">}</span>
    <span class="s1">finishedWork.flags &amp;= -</span><span class="s4">3</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">flags &amp; </span><span class="s4">4096 </span><span class="s1">&amp;&amp; (finishedWork.flags &amp;= -</span><span class="s4">4097</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">commitLayoutEffects(finishedWork, root, committedLanes) {</span>
  <span class="s1">inProgressLanes = committedLanes;</span>
  <span class="s1">inProgressRoot = root;</span>
  <span class="s3">for </span><span class="s1">(nextEffect = finishedWork; </span><span class="s3">null </span><span class="s1">!== nextEffect; )</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">((root = nextEffect),</span>
      <span class="s1">(committedLanes = root.child),</span>
      <span class="s4">0 </span><span class="s1">!== (root.subtreeFlags &amp; </span><span class="s4">8772</span><span class="s1">) &amp;&amp; </span><span class="s3">null </span><span class="s1">!== committedLanes)</span>
    <span class="s1">)</span>
      <span class="s1">(committedLanes.</span><span class="s3">return </span><span class="s1">= root), (nextEffect = committedLanes);</span>
    <span class="s3">else</span>
      <span class="s3">for </span><span class="s1">(root = finishedWork; </span><span class="s3">null </span><span class="s1">!== nextEffect; ) {</span>
        <span class="s1">committedLanes = nextEffect;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (committedLanes.flags &amp; </span><span class="s4">8772</span><span class="s1">)) {</span>
          <span class="s3">var </span><span class="s1">current = committedLanes.alternate;</span>
          <span class="s3">try </span><span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (committedLanes.flags &amp; </span><span class="s4">8772</span><span class="s1">))</span>
              <span class="s3">switch </span><span class="s1">(committedLanes.tag) {</span>
                <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s3">case </span><span class="s4">11</span><span class="s1">:</span>
                <span class="s3">case </span><span class="s4">15</span><span class="s1">:</span>
                  <span class="s3">if </span><span class="s1">(committedLanes.mode &amp; </span><span class="s4">2</span><span class="s1">)</span>
                    <span class="s3">try </span><span class="s1">{</span>
                      <span class="s1">startLayoutEffectTimer(),</span>
                        <span class="s1">commitHookEffectListMount(</span><span class="s4">5</span><span class="s1">, committedLanes);</span>
                    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
                      <span class="s1">recordLayoutEffectDuration(committedLanes);</span>
                    <span class="s1">}</span>
                  <span class="s3">else </span><span class="s1">commitHookEffectListMount(</span><span class="s4">5</span><span class="s1">, committedLanes);</span>
                  <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
                  <span class="s3">var </span><span class="s1">instance = committedLanes.stateNode;</span>
                  <span class="s3">if </span><span class="s1">(committedLanes.flags &amp; </span><span class="s4">4</span><span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== current)</span>
                      <span class="s3">if </span><span class="s1">(committedLanes.mode &amp; </span><span class="s4">2</span><span class="s1">)</span>
                        <span class="s3">try </span><span class="s1">{</span>
                          <span class="s1">startLayoutEffectTimer(),</span>
                            <span class="s1">instance.componentDidMount();</span>
                        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
                          <span class="s1">recordLayoutEffectDuration(committedLanes);</span>
                        <span class="s1">}</span>
                      <span class="s3">else </span><span class="s1">instance.componentDidMount();</span>
                    <span class="s3">else </span><span class="s1">{</span>
                      <span class="s3">var </span><span class="s1">prevProps =</span>
                          <span class="s1">committedLanes.elementType === committedLanes.type</span>
                            <span class="s1">? current.memoizedProps</span>
                            <span class="s1">: resolveDefaultProps(</span>
                                <span class="s1">committedLanes.type,</span>
                                <span class="s1">current.memoizedProps</span>
                              <span class="s1">),</span>
                        <span class="s1">prevState = current.memoizedState;</span>
                      <span class="s3">if </span><span class="s1">(committedLanes.mode &amp; </span><span class="s4">2</span><span class="s1">)</span>
                        <span class="s3">try </span><span class="s1">{</span>
                          <span class="s1">startLayoutEffectTimer(),</span>
                            <span class="s1">instance.componentDidUpdate(</span>
                              <span class="s1">prevProps,</span>
                              <span class="s1">prevState,</span>
                              <span class="s1">instance.__reactInternalSnapshotBeforeUpdate</span>
                            <span class="s1">);</span>
                        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
                          <span class="s1">recordLayoutEffectDuration(committedLanes);</span>
                        <span class="s1">}</span>
                      <span class="s3">else</span>
                        <span class="s1">instance.componentDidUpdate(</span>
                          <span class="s1">prevProps,</span>
                          <span class="s1">prevState,</span>
                          <span class="s1">instance.__reactInternalSnapshotBeforeUpdate</span>
                        <span class="s1">);</span>
                    <span class="s1">}</span>
                  <span class="s3">var </span><span class="s1">updateQueue = committedLanes.updateQueue;</span>
                  <span class="s3">null </span><span class="s1">!== updateQueue &amp;&amp;</span>
                    <span class="s1">commitUpdateQueue(committedLanes, updateQueue, instance);</span>
                  <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
                  <span class="s3">var </span><span class="s1">updateQueue$85 = committedLanes.updateQueue;</span>
                  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== updateQueue$85) {</span>
                    <span class="s3">var </span><span class="s1">instance$86 = </span><span class="s3">null</span><span class="s1">;</span>
                    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== committedLanes.child)</span>
                      <span class="s3">switch </span><span class="s1">(committedLanes.child.tag) {</span>
                        <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
                          <span class="s1">instance$86 = committedLanes.child.stateNode;</span>
                          <span class="s3">break</span><span class="s1">;</span>
                        <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
                          <span class="s1">instance$86 = committedLanes.child.stateNode;</span>
                      <span class="s1">}</span>
                    <span class="s1">commitUpdateQueue(</span>
                      <span class="s1">committedLanes,</span>
                      <span class="s1">updateQueue$85,</span>
                      <span class="s1">instance$86</span>
                    <span class="s1">);</span>
                  <span class="s1">}</span>
                  <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
                  <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">case </span><span class="s4">6</span><span class="s1">:</span>
                  <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
                  <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">case </span><span class="s4">12</span><span class="s1">:</span>
                  <span class="s3">var </span><span class="s1">_finishedWork$memoize2 = committedLanes.memoizedProps,</span>
                    <span class="s1">onCommit = _finishedWork$memoize2.onCommit,</span>
                    <span class="s1">onRender = _finishedWork$memoize2.onRender,</span>
                    <span class="s1">effectDuration = committedLanes.stateNode.effectDuration;</span>
                  <span class="s1">instance$86 = commitTime;</span>
                  <span class="s1">current = </span><span class="s3">null </span><span class="s1">=== current ? </span><span class="s2">&quot;mount&quot; </span><span class="s1">: </span><span class="s2">&quot;update&quot;</span><span class="s1">;</span>
                  <span class="s1">currentUpdateIsNested &amp;&amp; (current = </span><span class="s2">&quot;nested-update&quot;</span><span class="s1">);</span>
                  <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">onRender &amp;&amp;</span>
                    <span class="s1">onRender(</span>
                      <span class="s1">committedLanes.memoizedProps.id,</span>
                      <span class="s1">current,</span>
                      <span class="s1">committedLanes.actualDuration,</span>
                      <span class="s1">committedLanes.treeBaseDuration,</span>
                      <span class="s1">committedLanes.actualStartTime,</span>
                      <span class="s1">instance$86</span>
                    <span class="s1">);</span>
                  <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">onCommit &amp;&amp;</span>
                    <span class="s1">onCommit(</span>
                      <span class="s1">committedLanes.memoizedProps.id,</span>
                      <span class="s1">current,</span>
                      <span class="s1">effectDuration,</span>
                      <span class="s1">instance$86</span>
                    <span class="s1">);</span>
                  <span class="s1">enqueuePendingPassiveProfilerEffect(committedLanes);</span>
                  <span class="s3">var </span><span class="s1">parentFiber = committedLanes.</span><span class="s3">return</span><span class="s1">;</span>
                  <span class="s1">a: </span><span class="s3">for </span><span class="s1">(; </span><span class="s3">null </span><span class="s1">!== parentFiber; ) {</span>
                    <span class="s3">switch </span><span class="s1">(parentFiber.tag) {</span>
                      <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
                        <span class="s1">parentFiber.stateNode.effectDuration += effectDuration;</span>
                        <span class="s3">break </span><span class="s1">a;</span>
                      <span class="s3">case </span><span class="s4">12</span><span class="s1">:</span>
                        <span class="s1">parentFiber.stateNode.effectDuration += effectDuration;</span>
                        <span class="s3">break </span><span class="s1">a;</span>
                    <span class="s1">}</span>
                    <span class="s1">parentFiber = parentFiber.</span><span class="s3">return</span><span class="s1">;</span>
                  <span class="s1">}</span>
                  <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">case </span><span class="s4">13</span><span class="s1">:</span>
                  <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">case </span><span class="s4">19</span><span class="s1">:</span>
                <span class="s3">case </span><span class="s4">17</span><span class="s1">:</span>
                <span class="s3">case </span><span class="s4">21</span><span class="s1">:</span>
                <span class="s3">case </span><span class="s4">22</span><span class="s1">:</span>
                <span class="s3">case </span><span class="s4">23</span><span class="s1">:</span>
                <span class="s3">case </span><span class="s4">25</span><span class="s1">:</span>
                  <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">default</span><span class="s1">:</span>
                  <span class="s3">throw </span><span class="s1">Error(</span>
                    <span class="s2">&quot;This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
                  <span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(committedLanes.flags &amp; </span><span class="s4">512</span><span class="s1">) {</span>
              <span class="s1">instance$86 = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
              <span class="s1">current = committedLanes;</span>
              <span class="s3">var </span><span class="s1">ref = current.ref;</span>
              <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== ref) {</span>
                <span class="s3">var </span><span class="s1">instance$jscomp$0 = current.stateNode;</span>
                <span class="s3">switch </span><span class="s1">(current.tag) {</span>
                  <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
                    <span class="s1">instance$86 = instance$jscomp$0;</span>
                    <span class="s3">break</span><span class="s1">;</span>
                  <span class="s3">default</span><span class="s1">:</span>
                    <span class="s1">instance$86 = instance$jscomp$0;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">ref)</span>
                  <span class="s3">if </span><span class="s1">(current.mode &amp; </span><span class="s4">2</span><span class="s1">)</span>
                    <span class="s3">try </span><span class="s1">{</span>
                      <span class="s1">startLayoutEffectTimer(), ref(instance$86);</span>
                    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
                      <span class="s1">recordLayoutEffectDuration(current);</span>
                    <span class="s1">}</span>
                  <span class="s3">else </span><span class="s1">ref(instance$86);</span>
                <span class="s3">else </span><span class="s1">ref.current = instance$86;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
            <span class="s1">captureCommitPhaseError(</span>
              <span class="s1">committedLanes,</span>
              <span class="s1">committedLanes.</span><span class="s3">return</span><span class="s1">,</span>
              <span class="s1">error</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(committedLanes === root) {</span>
          <span class="s1">nextEffect = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">instance$86 = committedLanes.sibling;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== instance$86) {</span>
          <span class="s1">instance$86.</span><span class="s3">return </span><span class="s1">= committedLanes.</span><span class="s3">return</span><span class="s1">;</span>
          <span class="s1">nextEffect = instance$86;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">nextEffect = committedLanes.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
  <span class="s1">inProgressRoot = inProgressLanes = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">ceil = Math.ceil,</span>
  <span class="s1">ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,</span>
  <span class="s1">ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,</span>
  <span class="s1">ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig,</span>
  <span class="s1">executionContext = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">workInProgressRoot = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">workInProgress = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">workInProgressRootRenderLanes = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">subtreeRenderLanes = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">subtreeRenderLanesCursor = createCursor(</span><span class="s4">0</span><span class="s1">),</span>
  <span class="s1">workInProgressRootExitStatus = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">workInProgressRootFatalError = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">workInProgressRootSkippedLanes = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">workInProgressRootInterleavedUpdatedLanes = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">workInProgressRootPingedLanes = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">workInProgressRootConcurrentErrors = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">workInProgressRootRecoverableErrors = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">globalMostRecentFallbackTime = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">workInProgressRootRenderTargetTime = Infinity,</span>
  <span class="s1">workInProgressTransitions = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">hasUncaughtError = !</span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">firstUncaughtError = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">legacyErrorBoundariesThatAlreadyFailed = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">rootDoesHavePassiveEffects = !</span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">rootWithPendingPassiveEffects = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">pendingPassiveEffectsLanes = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">pendingPassiveProfilerEffects = [],</span>
  <span class="s1">nestedUpdateCount = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">rootWithNestedUpdates = </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">currentEventTime = -</span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">currentEventTransitionLane = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">requestEventTime() {</span>
  <span class="s3">return </span><span class="s4">0 </span><span class="s1">!== (executionContext &amp; </span><span class="s4">6</span><span class="s1">)</span>
    <span class="s1">? now()</span>
    <span class="s1">: -</span><span class="s4">1 </span><span class="s1">!== currentEventTime</span>
    <span class="s1">? currentEventTime</span>
    <span class="s1">: (currentEventTime = now());</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">requestUpdateLane(fiber) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (fiber.mode &amp; </span><span class="s4">1</span><span class="s1">)) </span><span class="s3">return </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (executionContext &amp; </span><span class="s4">2</span><span class="s1">) &amp;&amp; </span><span class="s4">0 </span><span class="s1">!== workInProgressRootRenderLanes)</span>
    <span class="s3">return </span><span class="s1">workInProgressRootRenderLanes &amp; -workInProgressRootRenderLanes;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== ReactCurrentBatchConfig.transition)</span>
    <span class="s3">return </span><span class="s1">(</span>
      <span class="s4">0 </span><span class="s1">=== currentEventTransitionLane &amp;&amp;</span>
        <span class="s1">(currentEventTransitionLane = claimNextTransitionLane()),</span>
      <span class="s1">currentEventTransitionLane</span>
    <span class="s1">);</span>
  <span class="s1">fiber = currentUpdatePriority;</span>
  <span class="s3">return </span><span class="s4">0 </span><span class="s1">!== fiber ? fiber : </span><span class="s4">16</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">scheduleUpdateOnFiber(root, fiber, lane, eventTime) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">50 </span><span class="s1">&lt; nestedUpdateCount)</span>
    <span class="s3">throw </span><span class="s1">((nestedUpdateCount = </span><span class="s4">0</span><span class="s1">),</span>
    <span class="s1">(rootWithNestedUpdates = </span><span class="s3">null</span><span class="s1">),</span>
    <span class="s1">Error(</span>
      <span class="s2">&quot;Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.&quot;</span>
    <span class="s1">));</span>
  <span class="s1">markRootUpdated(root, lane, eventTime);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (executionContext &amp; </span><span class="s4">2</span><span class="s1">) || root !== workInProgressRoot)</span>
    <span class="s1">isDevToolsPresent &amp;&amp; addFiberToLanesMap(root, fiber, lane),</span>
      <span class="s1">root === workInProgressRoot &amp;&amp;</span>
        <span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (executionContext &amp; </span><span class="s4">2</span><span class="s1">) &amp;&amp;</span>
          <span class="s1">(workInProgressRootInterleavedUpdatedLanes |= lane),</span>
        <span class="s4">4 </span><span class="s1">=== workInProgressRootExitStatus &amp;&amp;</span>
          <span class="s1">markRootSuspended$1(root, workInProgressRootRenderLanes)),</span>
      <span class="s1">ensureRootIsScheduled(root, eventTime),</span>
      <span class="s4">1 </span><span class="s1">=== lane &amp;&amp;</span>
        <span class="s4">0 </span><span class="s1">=== executionContext &amp;&amp;</span>
        <span class="s4">0 </span><span class="s1">=== (fiber.mode &amp; </span><span class="s4">1</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">((workInProgressRootRenderTargetTime = now() + </span><span class="s4">500</span><span class="s1">),</span>
        <span class="s1">includesLegacySyncCallbacks &amp;&amp; flushSyncCallbacks());</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">ensureRootIsScheduled(root, currentTime) {</span>
  <span class="s3">for </span><span class="s1">(</span>
    <span class="s3">var </span><span class="s1">existingCallbackNode = root.callbackNode,</span>
      <span class="s1">suspendedLanes = root.suspendedLanes,</span>
      <span class="s1">pingedLanes = root.pingedLanes,</span>
      <span class="s1">expirationTimes = root.expirationTimes,</span>
      <span class="s1">lanes = root.pendingLanes;</span>
    <span class="s4">0 </span><span class="s1">&lt; lanes;</span>

  <span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">index$6 = </span><span class="s4">31 </span><span class="s1">- clz32(lanes),</span>
      <span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index$6,</span>
      <span class="s1">expirationTime = expirationTimes[index$6];</span>
    <span class="s3">if </span><span class="s1">(-</span><span class="s4">1 </span><span class="s1">=== expirationTime) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (lane &amp; suspendedLanes) || </span><span class="s4">0 </span><span class="s1">!== (lane &amp; pingedLanes))</span>
        <span class="s1">expirationTimes[index$6] = computeExpirationTime(lane, currentTime);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">expirationTime &lt;= currentTime &amp;&amp; (root.expiredLanes |= lane);</span>
    <span class="s1">lanes &amp;= ~lane;</span>
  <span class="s1">}</span>
  <span class="s1">suspendedLanes = getNextLanes(</span>
    <span class="s1">root,</span>
    <span class="s1">root === workInProgressRoot ? workInProgressRootRenderLanes : </span><span class="s4">0</span>
  <span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== suspendedLanes)</span>
    <span class="s3">null </span><span class="s1">!== existingCallbackNode &amp;&amp; cancelCallback(existingCallbackNode),</span>
      <span class="s1">(root.callbackNode = </span><span class="s3">null</span><span class="s1">),</span>
      <span class="s1">(root.callbackPriority = </span><span class="s4">0</span><span class="s1">);</span>
  <span class="s3">else if </span><span class="s1">(</span>
    <span class="s1">((currentTime = suspendedLanes &amp; -suspendedLanes),</span>
    <span class="s1">root.callbackPriority !== currentTime)</span>
  <span class="s1">) {</span>
    <span class="s3">null </span><span class="s1">!= existingCallbackNode &amp;&amp; cancelCallback(existingCallbackNode);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">=== currentTime)</span>
      <span class="s4">0 </span><span class="s1">=== root.tag</span>
        <span class="s1">? ((existingCallbackNode = performSyncWorkOnRoot.bind(</span><span class="s3">null</span><span class="s1">, root)),</span>
          <span class="s1">(includesLegacySyncCallbacks = !</span><span class="s4">0</span><span class="s1">),</span>
          <span class="s3">null </span><span class="s1">=== syncQueue</span>
            <span class="s1">? (syncQueue = [existingCallbackNode])</span>
            <span class="s1">: syncQueue.push(existingCallbackNode))</span>
        <span class="s1">: ((existingCallbackNode = performSyncWorkOnRoot.bind(</span><span class="s3">null</span><span class="s1">, root)),</span>
          <span class="s3">null </span><span class="s1">=== syncQueue</span>
            <span class="s1">? (syncQueue = [existingCallbackNode])</span>
            <span class="s1">: syncQueue.push(existingCallbackNode)),</span>
        <span class="s1">scheduleCallback(ImmediatePriority, flushSyncCallbacks),</span>
        <span class="s1">(existingCallbackNode = </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s3">else </span><span class="s1">{</span>
      <span class="s3">switch </span><span class="s1">(lanesToEventPriority(suspendedLanes)) {</span>
        <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
          <span class="s1">existingCallbackNode = ImmediatePriority;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
          <span class="s1">existingCallbackNode = UserBlockingPriority;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">16</span><span class="s1">:</span>
          <span class="s1">existingCallbackNode = NormalPriority;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">536870912</span><span class="s1">:</span>
          <span class="s1">existingCallbackNode = IdlePriority;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">default</span><span class="s1">:</span>
          <span class="s1">existingCallbackNode = NormalPriority;</span>
      <span class="s1">}</span>
      <span class="s1">existingCallbackNode = scheduleCallback$1(</span>
        <span class="s1">existingCallbackNode,</span>
        <span class="s1">performConcurrentWorkOnRoot.bind(</span><span class="s3">null</span><span class="s1">, root)</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">root.callbackPriority = currentTime;</span>
    <span class="s1">root.callbackNode = existingCallbackNode;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">performConcurrentWorkOnRoot(root, didTimeout) {</span>
  <span class="s1">nestedUpdateScheduled = currentUpdateIsNested = !</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">currentEventTime = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">currentEventTransitionLane = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (executionContext &amp; </span><span class="s4">6</span><span class="s1">))</span>
    <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Should not already be working.&quot;</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">originalCallbackNode = root.callbackNode;</span>
  <span class="s3">if </span><span class="s1">(flushPassiveEffects() &amp;&amp; root.callbackNode !== originalCallbackNode)</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">lanes = getNextLanes(</span>
    <span class="s1">root,</span>
    <span class="s1">root === workInProgressRoot ? workInProgressRootRenderLanes : </span><span class="s4">0</span>
  <span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== lanes) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (lanes &amp; </span><span class="s4">30</span><span class="s1">) || </span><span class="s4">0 </span><span class="s1">!== (lanes &amp; root.expiredLanes) || didTimeout)</span>
    <span class="s1">didTimeout = renderRootSync(root, lanes);</span>
  <span class="s3">else </span><span class="s1">{</span>
    <span class="s1">didTimeout = lanes;</span>
    <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
    <span class="s1">executionContext |= </span><span class="s4">2</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">prevDispatcher = pushDispatcher();</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">workInProgressRoot !== root ||</span>
      <span class="s1">workInProgressRootRenderLanes !== didTimeout</span>
    <span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(isDevToolsPresent) {</span>
        <span class="s3">var </span><span class="s1">memoizedUpdaters = root.memoizedUpdaters;</span>
        <span class="s4">0 </span><span class="s1">&lt; memoizedUpdaters.size &amp;&amp;</span>
          <span class="s1">(restorePendingUpdaters(root, workInProgressRootRenderLanes),</span>
          <span class="s1">memoizedUpdaters.clear());</span>
        <span class="s1">movePendingFibersToMemoized(root, didTimeout);</span>
      <span class="s1">}</span>
      <span class="s1">workInProgressTransitions = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">workInProgressRootRenderTargetTime = now() + </span><span class="s4">500</span><span class="s1">;</span>
      <span class="s1">prepareFreshStack(root, didTimeout);</span>
    <span class="s1">}</span>
    <span class="s3">do</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">workLoopConcurrent();</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(thrownValue) {</span>
        <span class="s1">handleError(root, thrownValue);</span>
      <span class="s1">}</span>
    <span class="s3">while </span><span class="s1">(</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">resetContextDependencies();</span>
    <span class="s1">ReactCurrentDispatcher$2.current = prevDispatcher;</span>
    <span class="s1">executionContext = prevExecutionContext;</span>
    <span class="s3">null </span><span class="s1">!== workInProgress</span>
      <span class="s1">? (didTimeout = </span><span class="s4">0</span><span class="s1">)</span>
      <span class="s1">: ((workInProgressRoot = </span><span class="s3">null</span><span class="s1">),</span>
        <span class="s1">(workInProgressRootRenderLanes = </span><span class="s4">0</span><span class="s1">),</span>
        <span class="s1">(didTimeout = workInProgressRootExitStatus));</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== didTimeout) {</span>
    <span class="s4">2 </span><span class="s1">=== didTimeout &amp;&amp;</span>
      <span class="s1">((prevExecutionContext = getLanesToRetrySynchronouslyOnError(root)),</span>
      <span class="s4">0 </span><span class="s1">!== prevExecutionContext &amp;&amp;</span>
        <span class="s1">((lanes = prevExecutionContext),</span>
        <span class="s1">(didTimeout = recoverFromConcurrentError(root, prevExecutionContext))));</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">=== didTimeout)</span>
      <span class="s3">throw </span><span class="s1">((originalCallbackNode = workInProgressRootFatalError),</span>
      <span class="s1">prepareFreshStack(root, </span><span class="s4">0</span><span class="s1">),</span>
      <span class="s1">markRootSuspended$1(root, lanes),</span>
      <span class="s1">ensureRootIsScheduled(root, now()),</span>
      <span class="s1">originalCallbackNode);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s4">6 </span><span class="s1">=== didTimeout) markRootSuspended$1(root, lanes);</span>
    <span class="s3">else </span><span class="s1">{</span>
      <span class="s1">prevExecutionContext = root.current.alternate;</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s4">0 </span><span class="s1">=== (lanes &amp; </span><span class="s4">30</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">!isRenderConsistentWithExternalStores(prevExecutionContext) &amp;&amp;</span>
        <span class="s1">((didTimeout = renderRootSync(root, lanes)),</span>
        <span class="s4">2 </span><span class="s1">=== didTimeout &amp;&amp;</span>
          <span class="s1">((prevDispatcher = getLanesToRetrySynchronouslyOnError(root)),</span>
          <span class="s4">0 </span><span class="s1">!== prevDispatcher &amp;&amp;</span>
            <span class="s1">((lanes = prevDispatcher),</span>
            <span class="s1">(didTimeout = recoverFromConcurrentError(root, prevDispatcher)))),</span>
        <span class="s4">1 </span><span class="s1">=== didTimeout)</span>
      <span class="s1">)</span>
        <span class="s3">throw </span><span class="s1">((originalCallbackNode = workInProgressRootFatalError),</span>
        <span class="s1">prepareFreshStack(root, </span><span class="s4">0</span><span class="s1">),</span>
        <span class="s1">markRootSuspended$1(root, lanes),</span>
        <span class="s1">ensureRootIsScheduled(root, now()),</span>
        <span class="s1">originalCallbackNode);</span>
      <span class="s1">root.finishedWork = prevExecutionContext;</span>
      <span class="s1">root.finishedLanes = lanes;</span>
      <span class="s3">switch </span><span class="s1">(didTimeout) {</span>
        <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
          <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Root did not complete. This is a bug in React.&quot;</span><span class="s1">);</span>
        <span class="s3">case </span><span class="s4">2</span><span class="s1">:</span>
          <span class="s1">commitRoot(</span>
            <span class="s1">root,</span>
            <span class="s1">workInProgressRootRecoverableErrors,</span>
            <span class="s1">workInProgressTransitions</span>
          <span class="s1">);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
          <span class="s1">markRootSuspended$1(root, lanes);</span>
          <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">(lanes &amp; </span><span class="s4">130023424</span><span class="s1">) === lanes &amp;&amp;</span>
            <span class="s1">((didTimeout = globalMostRecentFallbackTime + </span><span class="s4">500 </span><span class="s1">- now()),</span>
            <span class="s4">10 </span><span class="s1">&lt; didTimeout)</span>
          <span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== getNextLanes(root, </span><span class="s4">0</span><span class="s1">)) </span><span class="s3">break</span><span class="s1">;</span>
            <span class="s1">prevExecutionContext = root.suspendedLanes;</span>
            <span class="s3">if </span><span class="s1">((prevExecutionContext &amp; lanes) !== lanes) {</span>
              <span class="s1">requestEventTime();</span>
              <span class="s1">root.pingedLanes |= root.suspendedLanes &amp; prevExecutionContext;</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">root.timeoutHandle = scheduleTimeout(</span>
              <span class="s1">commitRoot.bind(</span>
                <span class="s3">null</span><span class="s1">,</span>
                <span class="s1">root,</span>
                <span class="s1">workInProgressRootRecoverableErrors,</span>
                <span class="s1">workInProgressTransitions</span>
              <span class="s1">),</span>
              <span class="s1">didTimeout</span>
            <span class="s1">);</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s1">commitRoot(</span>
            <span class="s1">root,</span>
            <span class="s1">workInProgressRootRecoverableErrors,</span>
            <span class="s1">workInProgressTransitions</span>
          <span class="s1">);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
          <span class="s1">markRootSuspended$1(root, lanes);</span>
          <span class="s3">if </span><span class="s1">((lanes &amp; </span><span class="s4">4194240</span><span class="s1">) === lanes) </span><span class="s3">break</span><span class="s1">;</span>
          <span class="s1">didTimeout = root.eventTimes;</span>
          <span class="s3">for </span><span class="s1">(prevExecutionContext = -</span><span class="s4">1</span><span class="s1">; </span><span class="s4">0 </span><span class="s1">&lt; lanes; )</span>
            <span class="s1">(memoizedUpdaters = </span><span class="s4">31 </span><span class="s1">- clz32(lanes)),</span>
              <span class="s1">(prevDispatcher = </span><span class="s4">1 </span><span class="s1">&lt;&lt; memoizedUpdaters),</span>
              <span class="s1">(memoizedUpdaters = didTimeout[memoizedUpdaters]),</span>
              <span class="s1">memoizedUpdaters &gt; prevExecutionContext &amp;&amp;</span>
                <span class="s1">(prevExecutionContext = memoizedUpdaters),</span>
              <span class="s1">(lanes &amp;= ~prevDispatcher);</span>
          <span class="s1">lanes = prevExecutionContext;</span>
          <span class="s1">lanes = now() - lanes;</span>
          <span class="s1">lanes =</span>
            <span class="s1">(</span><span class="s4">120 </span><span class="s1">&gt; lanes</span>
              <span class="s1">? </span><span class="s4">120</span>
              <span class="s1">: </span><span class="s4">480 </span><span class="s1">&gt; lanes</span>
              <span class="s1">? </span><span class="s4">480</span>
              <span class="s1">: </span><span class="s4">1080 </span><span class="s1">&gt; lanes</span>
              <span class="s1">? </span><span class="s4">1080</span>
              <span class="s1">: </span><span class="s4">1920 </span><span class="s1">&gt; lanes</span>
              <span class="s1">? </span><span class="s4">1920</span>
              <span class="s1">: </span><span class="s4">3</span><span class="s1">e3 &gt; lanes</span>
              <span class="s1">? </span><span class="s4">3</span><span class="s1">e3</span>
              <span class="s1">: </span><span class="s4">4320 </span><span class="s1">&gt; lanes</span>
              <span class="s1">? </span><span class="s4">4320</span>
              <span class="s1">: </span><span class="s4">1960 </span><span class="s1">* ceil(lanes / </span><span class="s4">1960</span><span class="s1">)) - lanes;</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s4">10 </span><span class="s1">&lt; lanes) {</span>
            <span class="s1">root.timeoutHandle = scheduleTimeout(</span>
              <span class="s1">commitRoot.bind(</span>
                <span class="s3">null</span><span class="s1">,</span>
                <span class="s1">root,</span>
                <span class="s1">workInProgressRootRecoverableErrors,</span>
                <span class="s1">workInProgressTransitions</span>
              <span class="s1">),</span>
              <span class="s1">lanes</span>
            <span class="s1">);</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s1">commitRoot(</span>
            <span class="s1">root,</span>
            <span class="s1">workInProgressRootRecoverableErrors,</span>
            <span class="s1">workInProgressTransitions</span>
          <span class="s1">);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
          <span class="s1">commitRoot(</span>
            <span class="s1">root,</span>
            <span class="s1">workInProgressRootRecoverableErrors,</span>
            <span class="s1">workInProgressTransitions</span>
          <span class="s1">);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">default</span><span class="s1">:</span>
          <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Unknown root exit status.&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">ensureRootIsScheduled(root, now());</span>
  <span class="s3">return </span><span class="s1">root.callbackNode === originalCallbackNode</span>
    <span class="s1">? performConcurrentWorkOnRoot.bind(</span><span class="s3">null</span><span class="s1">, root)</span>
    <span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">recoverFromConcurrentError(root, errorRetryLanes) {</span>
  <span class="s3">var </span><span class="s1">errorsFromFirstAttempt = workInProgressRootConcurrentErrors;</span>
  <span class="s1">root.current.memoizedState.isDehydrated &amp;&amp;</span>
    <span class="s1">(prepareFreshStack(root, errorRetryLanes).flags |= </span><span class="s4">256</span><span class="s1">);</span>
  <span class="s1">root = renderRootSync(root, errorRetryLanes);</span>
  <span class="s4">2 </span><span class="s1">!== root &amp;&amp;</span>
    <span class="s1">((errorRetryLanes = workInProgressRootRecoverableErrors),</span>
    <span class="s1">(workInProgressRootRecoverableErrors = errorsFromFirstAttempt),</span>
    <span class="s3">null </span><span class="s1">!== errorRetryLanes &amp;&amp; queueRecoverableErrors(errorRetryLanes));</span>
  <span class="s3">return </span><span class="s1">root;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">queueRecoverableErrors(errors) {</span>
  <span class="s3">null </span><span class="s1">=== workInProgressRootRecoverableErrors</span>
    <span class="s1">? (workInProgressRootRecoverableErrors = errors)</span>
    <span class="s1">: workInProgressRootRecoverableErrors.push.apply(</span>
        <span class="s1">workInProgressRootRecoverableErrors,</span>
        <span class="s1">errors</span>
      <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isRenderConsistentWithExternalStores(finishedWork) {</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">node = finishedWork; ; ) {</span>
    <span class="s3">if </span><span class="s1">(node.flags &amp; </span><span class="s4">16384</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">updateQueue = node.updateQueue;</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s3">null </span><span class="s1">!== updateQueue &amp;&amp;</span>
        <span class="s1">((updateQueue = updateQueue.stores), </span><span class="s3">null </span><span class="s1">!== updateQueue)</span>
      <span class="s1">)</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; updateQueue.length; i++) {</span>
          <span class="s3">var </span><span class="s1">check = updateQueue[i],</span>
            <span class="s1">getSnapshot = check.getSnapshot;</span>
          <span class="s1">check = check.value;</span>
          <span class="s3">try </span><span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(!objectIs(getSnapshot(), check)) </span><span class="s3">return </span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
            <span class="s3">return </span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">updateQueue = node.child;</span>
    <span class="s3">if </span><span class="s1">(node.subtreeFlags &amp; </span><span class="s4">16384 </span><span class="s1">&amp;&amp; </span><span class="s3">null </span><span class="s1">!== updateQueue)</span>
      <span class="s1">(updateQueue.</span><span class="s3">return </span><span class="s1">= node), (node = updateQueue);</span>
    <span class="s3">else </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(node === finishedWork) </span><span class="s3">break</span><span class="s1">;</span>
      <span class="s3">for </span><span class="s1">(; </span><span class="s3">null </span><span class="s1">=== node.sibling; ) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== node.</span><span class="s3">return </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== finishedWork) </span><span class="s3">return </span><span class="s1">!</span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">node = node.sibling;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">!</span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">markRootSuspended$1(root, suspendedLanes) {</span>
  <span class="s1">suspendedLanes &amp;= ~workInProgressRootPingedLanes;</span>
  <span class="s1">suspendedLanes &amp;= ~workInProgressRootInterleavedUpdatedLanes;</span>
  <span class="s1">root.suspendedLanes |= suspendedLanes;</span>
  <span class="s1">root.pingedLanes &amp;= ~suspendedLanes;</span>
  <span class="s3">for </span><span class="s1">(root = root.expirationTimes; </span><span class="s4">0 </span><span class="s1">&lt; suspendedLanes; ) {</span>
    <span class="s3">var </span><span class="s1">index$7 = </span><span class="s4">31 </span><span class="s1">- clz32(suspendedLanes),</span>
      <span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index$7;</span>
    <span class="s1">root[index$7] = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">suspendedLanes &amp;= ~lane;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">performSyncWorkOnRoot(root) {</span>
  <span class="s1">currentUpdateIsNested = nestedUpdateScheduled;</span>
  <span class="s1">nestedUpdateScheduled = !</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (executionContext &amp; </span><span class="s4">6</span><span class="s1">))</span>
    <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Should not already be working.&quot;</span><span class="s1">);</span>
  <span class="s1">flushPassiveEffects();</span>
  <span class="s3">var </span><span class="s1">lanes = getNextLanes(root, </span><span class="s4">0</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (lanes &amp; </span><span class="s4">1</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">ensureRootIsScheduled(root, now()), </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">exitStatus = renderRootSync(root, lanes);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== root.tag &amp;&amp; </span><span class="s4">2 </span><span class="s1">=== exitStatus) {</span>
    <span class="s3">var </span><span class="s1">errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);</span>
    <span class="s4">0 </span><span class="s1">!== errorRetryLanes &amp;&amp;</span>
      <span class="s1">((lanes = errorRetryLanes),</span>
      <span class="s1">(exitStatus = recoverFromConcurrentError(root, errorRetryLanes)));</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">=== exitStatus)</span>
    <span class="s3">throw </span><span class="s1">((exitStatus = workInProgressRootFatalError),</span>
    <span class="s1">prepareFreshStack(root, </span><span class="s4">0</span><span class="s1">),</span>
    <span class="s1">markRootSuspended$1(root, lanes),</span>
    <span class="s1">ensureRootIsScheduled(root, now()),</span>
    <span class="s1">exitStatus);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">6 </span><span class="s1">=== exitStatus)</span>
    <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Root did not complete. This is a bug in React.&quot;</span><span class="s1">);</span>
  <span class="s1">root.finishedWork = root.current.alternate;</span>
  <span class="s1">root.finishedLanes = lanes;</span>
  <span class="s1">commitRoot(</span>
    <span class="s1">root,</span>
    <span class="s1">workInProgressRootRecoverableErrors,</span>
    <span class="s1">workInProgressTransitions</span>
  <span class="s1">);</span>
  <span class="s1">ensureRootIsScheduled(root, now());</span>
  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">popRenderLanes() {</span>
  <span class="s1">subtreeRenderLanes = subtreeRenderLanesCursor.current;</span>
  <span class="s1">pop(subtreeRenderLanesCursor);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">prepareFreshStack(root, lanes) {</span>
  <span class="s1">root.finishedWork = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">root.finishedLanes = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">timeoutHandle = root.timeoutHandle;</span>
  <span class="s1">-</span><span class="s4">1 </span><span class="s1">!== timeoutHandle &amp;&amp;</span>
    <span class="s1">((root.timeoutHandle = -</span><span class="s4">1</span><span class="s1">), cancelTimeout(timeoutHandle));</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== workInProgress)</span>
    <span class="s3">for </span><span class="s1">(timeoutHandle = workInProgress.</span><span class="s3">return</span><span class="s1">; </span><span class="s3">null </span><span class="s1">!== timeoutHandle; ) {</span>
      <span class="s3">var </span><span class="s1">interruptedWork = timeoutHandle;</span>
      <span class="s1">popTreeContext(interruptedWork);</span>
      <span class="s3">switch </span><span class="s1">(interruptedWork.tag) {</span>
        <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
          <span class="s1">interruptedWork = interruptedWork.type.childContextTypes;</span>
          <span class="s3">null </span><span class="s1">!== interruptedWork &amp;&amp;</span>
            <span class="s3">void </span><span class="s4">0 </span><span class="s1">!== interruptedWork &amp;&amp;</span>
            <span class="s1">popContext();</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
          <span class="s1">popHostContainer();</span>
          <span class="s1">pop(didPerformWorkStackCursor);</span>
          <span class="s1">pop(contextStackCursor);</span>
          <span class="s1">resetWorkInProgressVersions();</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
          <span class="s1">popHostContext(interruptedWork);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
          <span class="s1">popHostContainer();</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">13</span><span class="s1">:</span>
          <span class="s1">pop(suspenseStackCursor);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">19</span><span class="s1">:</span>
          <span class="s1">pop(suspenseStackCursor);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">10</span><span class="s1">:</span>
          <span class="s1">popProvider(interruptedWork.type._context);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">22</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s4">23</span><span class="s1">:</span>
          <span class="s1">popRenderLanes();</span>
      <span class="s1">}</span>
      <span class="s1">timeoutHandle = timeoutHandle.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">workInProgressRoot = root;</span>
  <span class="s1">workInProgress = root = createWorkInProgress(root.current, </span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">workInProgressRootRenderLanes = subtreeRenderLanes = lanes;</span>
  <span class="s1">workInProgressRootExitStatus = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">workInProgressRootFatalError = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== concurrentQueues) {</span>
    <span class="s3">for </span><span class="s1">(lanes = </span><span class="s4">0</span><span class="s1">; lanes &lt; concurrentQueues.length; lanes++)</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">((timeoutHandle = concurrentQueues[lanes]),</span>
        <span class="s1">(interruptedWork = timeoutHandle.interleaved),</span>
        <span class="s3">null </span><span class="s1">!== interruptedWork)</span>
      <span class="s1">) {</span>
        <span class="s1">timeoutHandle.interleaved = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">firstInterleavedUpdate = interruptedWork.next,</span>
          <span class="s1">lastPendingUpdate = timeoutHandle.pending;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== lastPendingUpdate) {</span>
          <span class="s3">var </span><span class="s1">firstPendingUpdate = lastPendingUpdate.next;</span>
          <span class="s1">lastPendingUpdate.next = firstInterleavedUpdate;</span>
          <span class="s1">interruptedWork.next = firstPendingUpdate;</span>
        <span class="s1">}</span>
        <span class="s1">timeoutHandle.pending = interruptedWork;</span>
      <span class="s1">}</span>
    <span class="s1">concurrentQueues = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">root;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">handleError(root$jscomp$0, thrownValue) {</span>
  <span class="s3">do </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">erroredWork = workInProgress;</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">resetContextDependencies();</span>
      <span class="s1">ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;</span>
      <span class="s3">if </span><span class="s1">(didScheduleRenderPhaseUpdate) {</span>
        <span class="s3">for </span><span class="s1">(</span>
          <span class="s3">var </span><span class="s1">hook = currentlyRenderingFiber$1.memoizedState;</span>
          <span class="s3">null </span><span class="s1">!== hook;</span>

        <span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">queue = hook.queue;</span>
          <span class="s3">null </span><span class="s1">!== queue &amp;&amp; (queue.pending = </span><span class="s3">null</span><span class="s1">);</span>
          <span class="s1">hook = hook.next;</span>
        <span class="s1">}</span>
        <span class="s1">didScheduleRenderPhaseUpdate = !</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">renderLanes = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">workInProgressHook = currentHook = currentlyRenderingFiber$1 = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">didScheduleRenderPhaseUpdateDuringThisPass = !</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">ReactCurrentOwner$2.current = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== erroredWork || </span><span class="s3">null </span><span class="s1">=== erroredWork.</span><span class="s3">return</span><span class="s1">) {</span>
        <span class="s1">workInProgressRootExitStatus = </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">workInProgressRootFatalError = thrownValue;</span>
        <span class="s1">workInProgress = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">erroredWork.mode &amp; </span><span class="s4">2 </span><span class="s1">&amp;&amp;</span>
        <span class="s1">stopProfilerTimerIfRunningAndRecordDelta(erroredWork, !</span><span class="s4">0</span><span class="s1">);</span>
      <span class="s1">a: {</span>
        <span class="s3">var </span><span class="s1">root = root$jscomp$0,</span>
          <span class="s1">returnFiber = erroredWork.</span><span class="s3">return</span><span class="s1">,</span>
          <span class="s1">sourceFiber = erroredWork,</span>
          <span class="s1">value = thrownValue;</span>
        <span class="s1">thrownValue = workInProgressRootRenderLanes;</span>
        <span class="s1">sourceFiber.flags |= </span><span class="s4">32768</span><span class="s1">;</span>
        <span class="s1">isDevToolsPresent &amp;&amp; restorePendingUpdaters(root, thrownValue);</span>
        <span class="s3">if </span><span class="s1">(</span>
          <span class="s3">null </span><span class="s1">!== value &amp;&amp;</span>
          <span class="s2">&quot;object&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">value &amp;&amp;</span>
          <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">value.then</span>
        <span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">wakeable = value,</span>
            <span class="s1">sourceFiber$jscomp$0 = sourceFiber,</span>
            <span class="s1">tag = sourceFiber$jscomp$0.tag;</span>
          <span class="s3">if </span><span class="s1">(</span>
            <span class="s4">0 </span><span class="s1">=== (sourceFiber$jscomp$0.mode &amp; </span><span class="s4">1</span><span class="s1">) &amp;&amp;</span>
            <span class="s1">(</span><span class="s4">0 </span><span class="s1">=== tag || </span><span class="s4">11 </span><span class="s1">=== tag || </span><span class="s4">15 </span><span class="s1">=== tag)</span>
          <span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">currentSource = sourceFiber$jscomp$0.alternate;</span>
            <span class="s1">currentSource</span>
              <span class="s1">? ((sourceFiber$jscomp$0.updateQueue = currentSource.updateQueue),</span>
                <span class="s1">(sourceFiber$jscomp$0.memoizedState =</span>
                  <span class="s1">currentSource.memoizedState),</span>
                <span class="s1">(sourceFiber$jscomp$0.lanes = currentSource.lanes))</span>
              <span class="s1">: ((sourceFiber$jscomp$0.updateQueue = </span><span class="s3">null</span><span class="s1">),</span>
                <span class="s1">(sourceFiber$jscomp$0.memoizedState = </span><span class="s3">null</span><span class="s1">));</span>
          <span class="s1">}</span>
          <span class="s1">b: {</span>
            <span class="s1">sourceFiber$jscomp$0 = returnFiber;</span>
            <span class="s3">do </span><span class="s1">{</span>
              <span class="s3">var </span><span class="s1">JSCompiler_temp;</span>
              <span class="s3">if </span><span class="s1">((JSCompiler_temp = </span><span class="s4">13 </span><span class="s1">=== sourceFiber$jscomp$0.tag)) {</span>
                <span class="s3">var </span><span class="s1">nextState = sourceFiber$jscomp$0.memoizedState;</span>
                <span class="s1">JSCompiler_temp =</span>
                  <span class="s3">null </span><span class="s1">!== nextState</span>
                    <span class="s1">? </span><span class="s3">null </span><span class="s1">!== nextState.dehydrated</span>
                      <span class="s1">? !</span><span class="s4">0</span>
                      <span class="s1">: !</span><span class="s4">1</span>
                    <span class="s1">: !</span><span class="s4">0</span><span class="s1">;</span>
              <span class="s1">}</span>
              <span class="s3">if </span><span class="s1">(JSCompiler_temp) {</span>
                <span class="s3">var </span><span class="s1">suspenseBoundary = sourceFiber$jscomp$0;</span>
                <span class="s3">break </span><span class="s1">b;</span>
              <span class="s1">}</span>
              <span class="s1">sourceFiber$jscomp$0 = sourceFiber$jscomp$0.</span><span class="s3">return</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== sourceFiber$jscomp$0);</span>
            <span class="s1">suspenseBoundary = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== suspenseBoundary) {</span>
            <span class="s1">suspenseBoundary.flags &amp;= -</span><span class="s4">257</span><span class="s1">;</span>
            <span class="s1">value = suspenseBoundary;</span>
            <span class="s1">sourceFiber$jscomp$0 = thrownValue;</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (value.mode &amp; </span><span class="s4">1</span><span class="s1">))</span>
              <span class="s3">if </span><span class="s1">(value === returnFiber) value.flags |= </span><span class="s4">65536</span><span class="s1">;</span>
              <span class="s3">else </span><span class="s1">{</span>
                <span class="s1">value.flags |= </span><span class="s4">128</span><span class="s1">;</span>
                <span class="s1">sourceFiber.flags |= </span><span class="s4">131072</span><span class="s1">;</span>
                <span class="s1">sourceFiber.flags &amp;= -</span><span class="s4">52805</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">=== sourceFiber.tag)</span>
                  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== sourceFiber.alternate) sourceFiber.tag = </span><span class="s4">17</span><span class="s1">;</span>
                  <span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">var </span><span class="s1">update = createUpdate(-</span><span class="s4">1</span><span class="s1">, </span><span class="s4">1</span><span class="s1">);</span>
                    <span class="s1">update.tag = </span><span class="s4">2</span><span class="s1">;</span>
                    <span class="s1">enqueueUpdate(sourceFiber, update, </span><span class="s4">1</span><span class="s1">);</span>
                  <span class="s1">}</span>
                <span class="s1">sourceFiber.lanes |= </span><span class="s4">1</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">(value.flags |= </span><span class="s4">65536</span><span class="s1">), (value.lanes = sourceFiber$jscomp$0);</span>
            <span class="s1">suspenseBoundary.mode &amp; </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
              <span class="s1">attachPingListener(root, wakeable, thrownValue);</span>
            <span class="s1">thrownValue = suspenseBoundary;</span>
            <span class="s1">root = wakeable;</span>
            <span class="s3">var </span><span class="s1">wakeables = thrownValue.updateQueue;</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== wakeables) {</span>
              <span class="s3">var </span><span class="s1">updateQueue = </span><span class="s3">new </span><span class="s1">Set();</span>
              <span class="s1">updateQueue.add(root);</span>
              <span class="s1">thrownValue.updateQueue = updateQueue;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">wakeables.add(root);</span>
            <span class="s3">break </span><span class="s1">a;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (thrownValue &amp; </span><span class="s4">1</span><span class="s1">)) {</span>
              <span class="s1">attachPingListener(root, wakeable, thrownValue);</span>
              <span class="s1">renderDidSuspendDelayIfPossible();</span>
              <span class="s3">break </span><span class="s1">a;</span>
            <span class="s1">}</span>
            <span class="s1">value = Error(</span>
              <span class="s2">&quot;A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.&quot;</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">root = value = createCapturedValueAtFiber(value, sourceFiber);</span>
        <span class="s4">4 </span><span class="s1">!== workInProgressRootExitStatus &amp;&amp;</span>
          <span class="s1">(workInProgressRootExitStatus = </span><span class="s4">2</span><span class="s1">);</span>
        <span class="s3">null </span><span class="s1">=== workInProgressRootConcurrentErrors</span>
          <span class="s1">? (workInProgressRootConcurrentErrors = [root])</span>
          <span class="s1">: workInProgressRootConcurrentErrors.push(root);</span>
        <span class="s1">root = returnFiber;</span>
        <span class="s3">do </span><span class="s1">{</span>
          <span class="s3">switch </span><span class="s1">(root.tag) {</span>
            <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
              <span class="s1">wakeable = value;</span>
              <span class="s1">root.flags |= </span><span class="s4">65536</span><span class="s1">;</span>
              <span class="s1">thrownValue &amp;= -thrownValue;</span>
              <span class="s1">root.lanes |= thrownValue;</span>
              <span class="s3">var </span><span class="s1">update$jscomp$0 = createRootErrorUpdate(</span>
                <span class="s1">root,</span>
                <span class="s1">wakeable,</span>
                <span class="s1">thrownValue</span>
              <span class="s1">);</span>
              <span class="s1">enqueueCapturedUpdate(root, update$jscomp$0);</span>
              <span class="s3">break </span><span class="s1">a;</span>
            <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
              <span class="s1">wakeable = value;</span>
              <span class="s3">var </span><span class="s1">ctor = root.type,</span>
                <span class="s1">instance = root.stateNode;</span>
              <span class="s3">if </span><span class="s1">(</span>
                <span class="s4">0 </span><span class="s1">=== (root.flags &amp; </span><span class="s4">128</span><span class="s1">) &amp;&amp;</span>
                <span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">ctor.getDerivedStateFromError ||</span>
                  <span class="s1">(</span><span class="s3">null </span><span class="s1">!== instance &amp;&amp;</span>
                    <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.componentDidCatch &amp;&amp;</span>
                    <span class="s1">(</span><span class="s3">null </span><span class="s1">=== legacyErrorBoundariesThatAlreadyFailed ||</span>
                      <span class="s1">!legacyErrorBoundariesThatAlreadyFailed.has(instance))))</span>
              <span class="s1">) {</span>
                <span class="s1">root.flags |= </span><span class="s4">65536</span><span class="s1">;</span>
                <span class="s1">thrownValue &amp;= -thrownValue;</span>
                <span class="s1">root.lanes |= thrownValue;</span>
                <span class="s3">var </span><span class="s1">update$36 = createClassErrorUpdate(</span>
                  <span class="s1">root,</span>
                  <span class="s1">wakeable,</span>
                  <span class="s1">thrownValue</span>
                <span class="s1">);</span>
                <span class="s1">enqueueCapturedUpdate(root, update$36);</span>
                <span class="s3">break </span><span class="s1">a;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s1">root = root.</span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== root);</span>
      <span class="s1">}</span>
      <span class="s1">completeUnitOfWork(erroredWork);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(yetAnotherThrownValue) {</span>
      <span class="s1">thrownValue = yetAnotherThrownValue;</span>
      <span class="s1">workInProgress === erroredWork &amp;&amp;</span>
        <span class="s3">null </span><span class="s1">!== erroredWork &amp;&amp;</span>
        <span class="s1">(workInProgress = erroredWork = erroredWork.</span><span class="s3">return</span><span class="s1">);</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">break</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s4">1</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pushDispatcher() {</span>
  <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$2.current;</span>
  <span class="s1">ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;</span>
  <span class="s3">return null </span><span class="s1">=== prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">renderDidSuspendDelayIfPossible() {</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s4">0 </span><span class="s1">=== workInProgressRootExitStatus ||</span>
    <span class="s4">3 </span><span class="s1">=== workInProgressRootExitStatus ||</span>
    <span class="s4">2 </span><span class="s1">=== workInProgressRootExitStatus</span>
  <span class="s1">)</span>
    <span class="s1">workInProgressRootExitStatus = </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s3">null </span><span class="s1">=== workInProgressRoot ||</span>
    <span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (workInProgressRootSkippedLanes &amp; </span><span class="s4">268435455</span><span class="s1">) &amp;&amp;</span>
      <span class="s4">0 </span><span class="s1">=== (workInProgressRootInterleavedUpdatedLanes &amp; </span><span class="s4">268435455</span><span class="s1">)) ||</span>
    <span class="s1">markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">renderRootSync(root, lanes) {</span>
  <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
  <span class="s1">executionContext |= </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">prevDispatcher = pushDispatcher();</span>
  <span class="s3">if </span><span class="s1">(workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {</span>
    <span class="s3">if </span><span class="s1">(isDevToolsPresent) {</span>
      <span class="s3">var </span><span class="s1">memoizedUpdaters = root.memoizedUpdaters;</span>
      <span class="s4">0 </span><span class="s1">&lt; memoizedUpdaters.size &amp;&amp;</span>
        <span class="s1">(restorePendingUpdaters(root, workInProgressRootRenderLanes),</span>
        <span class="s1">memoizedUpdaters.clear());</span>
      <span class="s1">movePendingFibersToMemoized(root, lanes);</span>
    <span class="s1">}</span>
    <span class="s1">workInProgressTransitions = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">prepareFreshStack(root, lanes);</span>
  <span class="s1">}</span>
  <span class="s3">do</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">workLoopSync();</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(thrownValue) {</span>
      <span class="s1">handleError(root, thrownValue);</span>
    <span class="s1">}</span>
  <span class="s3">while </span><span class="s1">(</span><span class="s4">1</span><span class="s1">);</span>
  <span class="s1">resetContextDependencies();</span>
  <span class="s1">executionContext = prevExecutionContext;</span>
  <span class="s1">ReactCurrentDispatcher$2.current = prevDispatcher;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== workInProgress)</span>
    <span class="s3">throw </span><span class="s1">Error(</span>
      <span class="s2">&quot;Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">workInProgressRoot = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">workInProgressRootRenderLanes = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">workInProgressRootExitStatus;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">workLoopSync() {</span>
  <span class="s3">for </span><span class="s1">(; </span><span class="s3">null </span><span class="s1">!== workInProgress; ) performUnitOfWork(workInProgress);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">workLoopConcurrent() {</span>
  <span class="s3">for </span><span class="s1">(; </span><span class="s3">null </span><span class="s1">!== workInProgress &amp;&amp; !shouldYield(); )</span>
    <span class="s1">performUnitOfWork(workInProgress);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">performUnitOfWork(unitOfWork) {</span>
  <span class="s3">var </span><span class="s1">current = unitOfWork.alternate;</span>
  <span class="s4">0 </span><span class="s1">!== (unitOfWork.mode &amp; </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">? ((profilerStartTime = now$1()),</span>
      <span class="s4">0 </span><span class="s1">&gt; unitOfWork.actualStartTime &amp;&amp; (unitOfWork.actualStartTime = now$1()),</span>
      <span class="s1">(current = beginWork$1(current, unitOfWork, subtreeRenderLanes)),</span>
      <span class="s1">stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, !</span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">: (current = beginWork$1(current, unitOfWork, subtreeRenderLanes));</span>
  <span class="s1">unitOfWork.memoizedProps = unitOfWork.pendingProps;</span>
  <span class="s3">null </span><span class="s1">=== current</span>
    <span class="s1">? completeUnitOfWork(unitOfWork)</span>
    <span class="s1">: (workInProgress = current);</span>
  <span class="s1">ReactCurrentOwner$2.current = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">completeUnitOfWork(unitOfWork) {</span>
  <span class="s3">var </span><span class="s1">completedWork = unitOfWork;</span>
  <span class="s3">do </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">current = completedWork.alternate;</span>
    <span class="s1">unitOfWork = completedWork.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (completedWork.flags &amp; </span><span class="s4">32768</span><span class="s1">)) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (completedWork.mode &amp; </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">current = completeWork(current, completedWork, subtreeRenderLanes);</span>
      <span class="s3">else </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">fiber = completedWork;</span>
        <span class="s1">profilerStartTime = now$1();</span>
        <span class="s4">0 </span><span class="s1">&gt; fiber.actualStartTime &amp;&amp; (fiber.actualStartTime = now$1());</span>
        <span class="s1">current = completeWork(current, completedWork, subtreeRenderLanes);</span>
        <span class="s1">stopProfilerTimerIfRunningAndRecordDelta(completedWork, !</span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== current) {</span>
        <span class="s1">workInProgress = current;</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">current = unwindWork(current, completedWork);</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== current) {</span>
        <span class="s1">current.flags &amp;= </span><span class="s4">32767</span><span class="s1">;</span>
        <span class="s1">workInProgress = current;</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (completedWork.mode &amp; </span><span class="s4">2</span><span class="s1">)) {</span>
        <span class="s1">stopProfilerTimerIfRunningAndRecordDelta(completedWork, !</span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">current = completedWork.actualDuration;</span>
        <span class="s3">for </span><span class="s1">(fiber = completedWork.child; </span><span class="s3">null </span><span class="s1">!== fiber; )</span>
          <span class="s1">(current += fiber.actualDuration), (fiber = fiber.sibling);</span>
        <span class="s1">completedWork.actualDuration = current;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== unitOfWork)</span>
        <span class="s1">(unitOfWork.flags |= </span><span class="s4">32768</span><span class="s1">),</span>
          <span class="s1">(unitOfWork.subtreeFlags = </span><span class="s4">0</span><span class="s1">),</span>
          <span class="s1">(unitOfWork.deletions = </span><span class="s3">null</span><span class="s1">);</span>
      <span class="s3">else </span><span class="s1">{</span>
        <span class="s1">workInProgressRootExitStatus = </span><span class="s4">6</span><span class="s1">;</span>
        <span class="s1">workInProgress = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">completedWork = completedWork.sibling;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== completedWork) {</span>
      <span class="s1">workInProgress = completedWork;</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">workInProgress = completedWork = unitOfWork;</span>
  <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== completedWork);</span>
  <span class="s4">0 </span><span class="s1">=== workInProgressRootExitStatus &amp;&amp; (workInProgressRootExitStatus = </span><span class="s4">5</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">commitRoot(root, recoverableErrors, transitions) {</span>
  <span class="s3">var </span><span class="s1">previousUpdateLanePriority = currentUpdatePriority,</span>
    <span class="s1">prevTransition = ReactCurrentBatchConfig$2.transition;</span>
  <span class="s3">try </span><span class="s1">{</span>
    <span class="s1">(ReactCurrentBatchConfig$2.transition = </span><span class="s3">null</span><span class="s1">),</span>
      <span class="s1">(currentUpdatePriority = </span><span class="s4">1</span><span class="s1">),</span>
      <span class="s1">commitRootImpl(</span>
        <span class="s1">root,</span>
        <span class="s1">recoverableErrors,</span>
        <span class="s1">transitions,</span>
        <span class="s1">previousUpdateLanePriority</span>
      <span class="s1">);</span>
  <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
    <span class="s1">(ReactCurrentBatchConfig$2.transition = prevTransition),</span>
      <span class="s1">(currentUpdatePriority = previousUpdateLanePriority);</span>
  <span class="s1">}</span>
  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">commitRootImpl(</span>
  <span class="s1">root,</span>
  <span class="s1">recoverableErrors,</span>
  <span class="s1">transitions,</span>
  <span class="s1">renderPriorityLevel</span>
<span class="s1">) {</span>
  <span class="s3">do </span><span class="s1">flushPassiveEffects();</span>
  <span class="s3">while </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== rootWithPendingPassiveEffects);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (executionContext &amp; </span><span class="s4">6</span><span class="s1">))</span>
    <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Should not already be working.&quot;</span><span class="s1">);</span>
  <span class="s1">transitions = root.finishedWork;</span>
  <span class="s3">var </span><span class="s1">lanes = root.finishedLanes;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== transitions) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">root.finishedWork = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">root.finishedLanes = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(transitions === root.current)</span>
    <span class="s3">throw </span><span class="s1">Error(</span>
      <span class="s2">&quot;Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">root.callbackNode = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">root.callbackPriority = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">remainingLanes = transitions.lanes | transitions.childLanes;</span>
  <span class="s1">markRootFinished(root, remainingLanes);</span>
  <span class="s1">root === workInProgressRoot &amp;&amp;</span>
    <span class="s1">((workInProgress = workInProgressRoot = </span><span class="s3">null</span><span class="s1">),</span>
    <span class="s1">(workInProgressRootRenderLanes = </span><span class="s4">0</span><span class="s1">));</span>
  <span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (transitions.subtreeFlags &amp; </span><span class="s4">2064</span><span class="s1">) &amp;&amp;</span>
    <span class="s4">0 </span><span class="s1">=== (transitions.flags &amp; </span><span class="s4">2064</span><span class="s1">)) ||</span>
    <span class="s1">rootDoesHavePassiveEffects ||</span>
    <span class="s1">((rootDoesHavePassiveEffects = !</span><span class="s4">0</span><span class="s1">),</span>
    <span class="s1">scheduleCallback$1(NormalPriority, </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">flushPassiveEffects();</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}));</span>
  <span class="s1">remainingLanes = </span><span class="s4">0 </span><span class="s1">!== (transitions.flags &amp; </span><span class="s4">15990</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (transitions.subtreeFlags &amp; </span><span class="s4">15990</span><span class="s1">) || remainingLanes) {</span>
    <span class="s1">remainingLanes = ReactCurrentBatchConfig$2.transition;</span>
    <span class="s1">ReactCurrentBatchConfig$2.transition = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">previousPriority = currentUpdatePriority;</span>
    <span class="s1">currentUpdatePriority = </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
    <span class="s1">executionContext |= </span><span class="s4">4</span><span class="s1">;</span>
    <span class="s1">ReactCurrentOwner$2.current = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">commitBeforeMutationEffects(root, transitions);</span>
    <span class="s1">commitTime = now$1();</span>
    <span class="s1">commitMutationEffects(root, transitions, lanes);</span>
    <span class="s1">root.current = transitions;</span>
    <span class="s1">commitLayoutEffects(transitions, root, lanes);</span>
    <span class="s1">requestPaint();</span>
    <span class="s1">executionContext = prevExecutionContext;</span>
    <span class="s1">currentUpdatePriority = previousPriority;</span>
    <span class="s1">ReactCurrentBatchConfig$2.transition = remainingLanes;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">(root.current = transitions), (commitTime = now$1());</span>
  <span class="s1">rootDoesHavePassiveEffects &amp;&amp;</span>
    <span class="s1">((rootDoesHavePassiveEffects = !</span><span class="s4">1</span><span class="s1">),</span>
    <span class="s1">(rootWithPendingPassiveEffects = root),</span>
    <span class="s1">(pendingPassiveEffectsLanes = lanes));</span>
  <span class="s1">remainingLanes = root.pendingLanes;</span>
  <span class="s4">0 </span><span class="s1">=== remainingLanes &amp;&amp; (legacyErrorBoundariesThatAlreadyFailed = </span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">onCommitRoot(transitions.stateNode, renderPriorityLevel);</span>
  <span class="s1">isDevToolsPresent &amp;&amp; root.memoizedUpdaters.clear();</span>
  <span class="s1">ensureRootIsScheduled(root, now());</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== recoverableErrors)</span>
    <span class="s3">for </span><span class="s1">(</span>
      <span class="s1">renderPriorityLevel = root.onRecoverableError, transitions = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">transitions &lt; recoverableErrors.length;</span>
      <span class="s1">transitions++</span>
    <span class="s1">)</span>
      <span class="s1">(lanes = recoverableErrors[transitions]),</span>
        <span class="s1">renderPriorityLevel(lanes.value, {</span>
          <span class="s1">componentStack: lanes.stack,</span>
          <span class="s1">digest: lanes.digest</span>
        <span class="s1">});</span>
  <span class="s3">if </span><span class="s1">(hasUncaughtError)</span>
    <span class="s3">throw </span><span class="s1">((hasUncaughtError = !</span><span class="s4">1</span><span class="s1">),</span>
    <span class="s1">(root = firstUncaughtError),</span>
    <span class="s1">(firstUncaughtError = </span><span class="s3">null</span><span class="s1">),</span>
    <span class="s1">root);</span>
  <span class="s4">0 </span><span class="s1">!== (pendingPassiveEffectsLanes &amp; </span><span class="s4">1</span><span class="s1">) &amp;&amp;</span>
    <span class="s4">0 </span><span class="s1">!== root.tag &amp;&amp;</span>
    <span class="s1">flushPassiveEffects();</span>
  <span class="s1">remainingLanes = root.pendingLanes;</span>
  <span class="s4">0 </span><span class="s1">!== (remainingLanes &amp; </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">? ((nestedUpdateScheduled = !</span><span class="s4">0</span><span class="s1">),</span>
      <span class="s1">root === rootWithNestedUpdates</span>
        <span class="s1">? nestedUpdateCount++</span>
        <span class="s1">: ((nestedUpdateCount = </span><span class="s4">0</span><span class="s1">), (rootWithNestedUpdates = root)))</span>
    <span class="s1">: (nestedUpdateCount = </span><span class="s4">0</span><span class="s1">);</span>
  <span class="s1">flushSyncCallbacks();</span>
  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">flushPassiveEffects() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== rootWithPendingPassiveEffects) {</span>
    <span class="s3">var </span><span class="s1">renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),</span>
      <span class="s1">prevTransition = ReactCurrentBatchConfig$2.transition,</span>
      <span class="s1">previousPriority = currentUpdatePriority;</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">ReactCurrentBatchConfig$2.transition = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">currentUpdatePriority = </span><span class="s4">16 </span><span class="s1">&gt; renderPriority ? </span><span class="s4">16 </span><span class="s1">: renderPriority;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== rootWithPendingPassiveEffects)</span>
        <span class="s3">var </span><span class="s1">JSCompiler_inline_result = !</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s3">else </span><span class="s1">{</span>
        <span class="s1">renderPriority = rootWithPendingPassiveEffects;</span>
        <span class="s1">rootWithPendingPassiveEffects = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">pendingPassiveEffectsLanes = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (executionContext &amp; </span><span class="s4">6</span><span class="s1">))</span>
          <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Cannot flush passive effects while already rendering.&quot;</span><span class="s1">);</span>
        <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
        <span class="s1">executionContext |= </span><span class="s4">4</span><span class="s1">;</span>
        <span class="s3">for </span><span class="s1">(nextEffect = renderPriority.current; </span><span class="s3">null </span><span class="s1">!== nextEffect; ) {</span>
          <span class="s3">var </span><span class="s1">fiber = nextEffect,</span>
            <span class="s1">child = fiber.child;</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (nextEffect.flags &amp; </span><span class="s4">16</span><span class="s1">)) {</span>
            <span class="s3">var </span><span class="s1">deletions = fiber.deletions;</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== deletions) {</span>
              <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; deletions.length; i++) {</span>
                <span class="s3">var </span><span class="s1">fiberToDelete = deletions[i];</span>
                <span class="s3">for </span><span class="s1">(nextEffect = fiberToDelete; </span><span class="s3">null </span><span class="s1">!== nextEffect; ) {</span>
                  <span class="s3">var </span><span class="s1">fiber$jscomp$0 = nextEffect,</span>
                    <span class="s1">current = fiber$jscomp$0;</span>
                  <span class="s3">switch </span><span class="s1">(current.tag) {</span>
                    <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s3">case </span><span class="s4">11</span><span class="s1">:</span>
                    <span class="s3">case </span><span class="s4">15</span><span class="s1">:</span>
                      <span class="s1">current.mode &amp; </span><span class="s4">2</span>
                        <span class="s1">? ((passiveEffectStartTime = now$1()),</span>
                          <span class="s1">commitHookEffectListUnmount(</span><span class="s4">8</span><span class="s1">, current, fiber),</span>
                          <span class="s1">recordPassiveEffectDuration(current))</span>
                        <span class="s1">: commitHookEffectListUnmount(</span><span class="s4">8</span><span class="s1">, current, fiber);</span>
                  <span class="s1">}</span>
                  <span class="s3">var </span><span class="s1">child$jscomp$0 = fiber$jscomp$0.child;</span>
                  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== child$jscomp$0)</span>
                    <span class="s1">(child$jscomp$0.</span><span class="s3">return </span><span class="s1">= fiber$jscomp$0),</span>
                      <span class="s1">(nextEffect = child$jscomp$0);</span>
                  <span class="s3">else</span>
                    <span class="s3">for </span><span class="s1">(; </span><span class="s3">null </span><span class="s1">!== nextEffect; ) {</span>
                      <span class="s1">fiber$jscomp$0 = nextEffect;</span>
                      <span class="s3">var </span><span class="s1">sibling = fiber$jscomp$0.sibling,</span>
                        <span class="s1">returnFiber = fiber$jscomp$0.</span><span class="s3">return</span><span class="s1">;</span>
                      <span class="s1">detachFiberAfterEffects(fiber$jscomp$0);</span>
                      <span class="s3">if </span><span class="s1">(fiber$jscomp$0 === fiberToDelete) {</span>
                        <span class="s1">nextEffect = </span><span class="s3">null</span><span class="s1">;</span>
                        <span class="s3">break</span><span class="s1">;</span>
                      <span class="s1">}</span>
                      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== sibling) {</span>
                        <span class="s1">sibling.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
                        <span class="s1">nextEffect = sibling;</span>
                        <span class="s3">break</span><span class="s1">;</span>
                      <span class="s1">}</span>
                      <span class="s1">nextEffect = returnFiber;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s3">var </span><span class="s1">previousFiber = fiber.alternate;</span>
              <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== previousFiber) {</span>
                <span class="s3">var </span><span class="s1">detachedChild = previousFiber.child;</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== detachedChild) {</span>
                  <span class="s1">previousFiber.child = </span><span class="s3">null</span><span class="s1">;</span>
                  <span class="s3">do </span><span class="s1">{</span>
                    <span class="s3">var </span><span class="s1">detachedSibling = detachedChild.sibling;</span>
                    <span class="s1">detachedChild.sibling = </span><span class="s3">null</span><span class="s1">;</span>
                    <span class="s1">detachedChild = detachedSibling;</span>
                  <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== detachedChild);</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s1">nextEffect = fiber;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (fiber.subtreeFlags &amp; </span><span class="s4">2064</span><span class="s1">) &amp;&amp; </span><span class="s3">null </span><span class="s1">!== child)</span>
            <span class="s1">(child.</span><span class="s3">return </span><span class="s1">= fiber), (nextEffect = child);</span>
          <span class="s3">else</span>
            <span class="s1">b: </span><span class="s3">for </span><span class="s1">(; </span><span class="s3">null </span><span class="s1">!== nextEffect; ) {</span>
              <span class="s1">fiber = nextEffect;</span>
              <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (fiber.flags &amp; </span><span class="s4">2048</span><span class="s1">))</span>
                <span class="s3">switch </span><span class="s1">(((i = fiber), i.tag)) {</span>
                  <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
                  <span class="s3">case </span><span class="s4">11</span><span class="s1">:</span>
                  <span class="s3">case </span><span class="s4">15</span><span class="s1">:</span>
                    <span class="s1">i.mode &amp; </span><span class="s4">2</span>
                      <span class="s1">? ((passiveEffectStartTime = now$1()),</span>
                        <span class="s1">commitHookEffectListUnmount(</span><span class="s4">9</span><span class="s1">, i, i.</span><span class="s3">return</span><span class="s1">),</span>
                        <span class="s1">recordPassiveEffectDuration(i))</span>
                      <span class="s1">: commitHookEffectListUnmount(</span><span class="s4">9</span><span class="s1">, i, i.</span><span class="s3">return</span><span class="s1">);</span>
                <span class="s1">}</span>
              <span class="s3">var </span><span class="s1">sibling$jscomp$0 = fiber.sibling;</span>
              <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== sibling$jscomp$0) {</span>
                <span class="s1">sibling$jscomp$0.</span><span class="s3">return </span><span class="s1">= fiber.</span><span class="s3">return</span><span class="s1">;</span>
                <span class="s1">nextEffect = sibling$jscomp$0;</span>
                <span class="s3">break </span><span class="s1">b;</span>
              <span class="s1">}</span>
              <span class="s1">nextEffect = fiber.</span><span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">finishedWork = renderPriority.current;</span>
        <span class="s3">for </span><span class="s1">(nextEffect = finishedWork; </span><span class="s3">null </span><span class="s1">!== nextEffect; ) {</span>
          <span class="s1">child = nextEffect;</span>
          <span class="s3">var </span><span class="s1">firstChild = child.child;</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (child.subtreeFlags &amp; </span><span class="s4">2064</span><span class="s1">) &amp;&amp; </span><span class="s3">null </span><span class="s1">!== firstChild)</span>
            <span class="s1">(firstChild.</span><span class="s3">return </span><span class="s1">= child), (nextEffect = firstChild);</span>
          <span class="s3">else</span>
            <span class="s1">b: </span><span class="s3">for </span><span class="s1">(child = finishedWork; </span><span class="s3">null </span><span class="s1">!== nextEffect; ) {</span>
              <span class="s1">deletions = nextEffect;</span>
              <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (deletions.flags &amp; </span><span class="s4">2048</span><span class="s1">))</span>
                <span class="s3">try </span><span class="s1">{</span>
                  <span class="s3">switch </span><span class="s1">(((fiberToDelete = deletions), fiberToDelete.tag)) {</span>
                    <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s3">case </span><span class="s4">11</span><span class="s1">:</span>
                    <span class="s3">case </span><span class="s4">15</span><span class="s1">:</span>
                      <span class="s3">if </span><span class="s1">(fiberToDelete.mode &amp; </span><span class="s4">2</span><span class="s1">) {</span>
                        <span class="s1">passiveEffectStartTime = now$1();</span>
                        <span class="s3">try </span><span class="s1">{</span>
                          <span class="s1">commitHookEffectListMount(</span><span class="s4">9</span><span class="s1">, fiberToDelete);</span>
                        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
                          <span class="s1">recordPassiveEffectDuration(fiberToDelete);</span>
                        <span class="s1">}</span>
                      <span class="s1">} </span><span class="s3">else </span><span class="s1">commitHookEffectListMount(</span><span class="s4">9</span><span class="s1">, fiberToDelete);</span>
                  <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
                  <span class="s1">captureCommitPhaseError(deletions, deletions.</span><span class="s3">return</span><span class="s1">, error);</span>
                <span class="s1">}</span>
              <span class="s3">if </span><span class="s1">(deletions === child) {</span>
                <span class="s1">nextEffect = </span><span class="s3">null</span><span class="s1">;</span>
                <span class="s3">break </span><span class="s1">b;</span>
              <span class="s1">}</span>
              <span class="s3">var </span><span class="s1">sibling$jscomp$1 = deletions.sibling;</span>
              <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== sibling$jscomp$1) {</span>
                <span class="s1">sibling$jscomp$1.</span><span class="s3">return </span><span class="s1">= deletions.</span><span class="s3">return</span><span class="s1">;</span>
                <span class="s1">nextEffect = sibling$jscomp$1;</span>
                <span class="s3">break </span><span class="s1">b;</span>
              <span class="s1">}</span>
              <span class="s1">nextEffect = deletions.</span><span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">finishedWork = pendingPassiveProfilerEffects;</span>
        <span class="s1">pendingPassiveProfilerEffects = [];</span>
        <span class="s3">for </span><span class="s1">(firstChild = </span><span class="s4">0</span><span class="s1">; firstChild &lt; finishedWork.length; firstChild++) {</span>
          <span class="s3">var </span><span class="s1">finishedWork$jscomp$0 = finishedWork[firstChild];</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">!== (finishedWork$jscomp$0.flags &amp; </span><span class="s4">4</span><span class="s1">))</span>
            <span class="s3">switch </span><span class="s1">(finishedWork$jscomp$0.tag) {</span>
              <span class="s3">case </span><span class="s4">12</span><span class="s1">:</span>
                <span class="s3">var </span><span class="s1">passiveEffectDuration =</span>
                    <span class="s1">finishedWork$jscomp$0.stateNode.passiveEffectDuration,</span>
                  <span class="s1">_finishedWork$memoize = finishedWork$jscomp$0.memoizedProps,</span>
                  <span class="s1">id = _finishedWork$memoize.id,</span>
                  <span class="s1">onPostCommit = _finishedWork$memoize.onPostCommit;</span>
                <span class="s1">sibling$jscomp$1 = commitTime;</span>
                <span class="s3">var </span><span class="s1">phase =</span>
                  <span class="s3">null </span><span class="s1">=== finishedWork$jscomp$0.alternate ? </span><span class="s2">&quot;mount&quot; </span><span class="s1">: </span><span class="s2">&quot;update&quot;</span><span class="s1">;</span>
                <span class="s1">currentUpdateIsNested &amp;&amp; (phase = </span><span class="s2">&quot;nested-update&quot;</span><span class="s1">);</span>
                <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">onPostCommit &amp;&amp;</span>
                  <span class="s1">onPostCommit(</span>
                    <span class="s1">id,</span>
                    <span class="s1">phase,</span>
                    <span class="s1">passiveEffectDuration,</span>
                    <span class="s1">sibling$jscomp$1</span>
                  <span class="s1">);</span>
                <span class="s3">var </span><span class="s1">parentFiber = finishedWork$jscomp$0.</span><span class="s3">return</span><span class="s1">;</span>
                <span class="s1">b: </span><span class="s3">for </span><span class="s1">(; </span><span class="s3">null </span><span class="s1">!== parentFiber; ) {</span>
                  <span class="s3">switch </span><span class="s1">(parentFiber.tag) {</span>
                    <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
                      <span class="s1">parentFiber.stateNode.passiveEffectDuration += passiveEffectDuration;</span>
                      <span class="s3">break </span><span class="s1">b;</span>
                    <span class="s3">case </span><span class="s4">12</span><span class="s1">:</span>
                      <span class="s1">parentFiber.stateNode.passiveEffectDuration += passiveEffectDuration;</span>
                      <span class="s3">break </span><span class="s1">b;</span>
                  <span class="s1">}</span>
                  <span class="s1">parentFiber = parentFiber.</span><span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">executionContext = prevExecutionContext;</span>
        <span class="s1">flushSyncCallbacks();</span>
        <span class="s3">if </span><span class="s1">(</span>
          <span class="s1">injectedHook &amp;&amp;</span>
          <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">injectedHook.onPostCommitFiberRoot</span>
        <span class="s1">)</span>
          <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">injectedHook.onPostCommitFiberRoot(rendererID, renderPriority);</span>
          <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {}</span>
        <span class="s3">var </span><span class="s1">stateNode = renderPriority.current.stateNode;</span>
        <span class="s1">stateNode.effectDuration = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">stateNode.passiveEffectDuration = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">JSCompiler_inline_result = !</span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">return </span><span class="s1">JSCompiler_inline_result;</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">(currentUpdatePriority = previousPriority),</span>
        <span class="s1">(ReactCurrentBatchConfig$2.transition = prevTransition);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">enqueuePendingPassiveProfilerEffect(fiber) {</span>
  <span class="s1">pendingPassiveProfilerEffects.push(fiber);</span>
  <span class="s1">rootDoesHavePassiveEffects ||</span>
    <span class="s1">((rootDoesHavePassiveEffects = !</span><span class="s4">0</span><span class="s1">),</span>
    <span class="s1">scheduleCallback$1(NormalPriority, </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">flushPassiveEffects();</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}));</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {</span>
  <span class="s1">sourceFiber = createCapturedValueAtFiber(error, sourceFiber);</span>
  <span class="s1">sourceFiber = createRootErrorUpdate(rootFiber, sourceFiber, </span><span class="s4">1</span><span class="s1">);</span>
  <span class="s1">rootFiber = enqueueUpdate(rootFiber, sourceFiber, </span><span class="s4">1</span><span class="s1">);</span>
  <span class="s1">sourceFiber = requestEventTime();</span>
  <span class="s3">null </span><span class="s1">!== rootFiber &amp;&amp;</span>
    <span class="s1">(markRootUpdated(rootFiber, </span><span class="s4">1</span><span class="s1">, sourceFiber),</span>
    <span class="s1">ensureRootIsScheduled(rootFiber, sourceFiber));</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s4">3 </span><span class="s1">=== sourceFiber.tag)</span>
    <span class="s1">captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);</span>
  <span class="s3">else</span>
    <span class="s3">for </span><span class="s1">(</span>
      <span class="s1">nearestMountedAncestor = sourceFiber.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s3">null </span><span class="s1">!== nearestMountedAncestor;</span>

    <span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s4">3 </span><span class="s1">=== nearestMountedAncestor.tag) {</span>
        <span class="s1">captureCommitPhaseErrorOnRoot(</span>
          <span class="s1">nearestMountedAncestor,</span>
          <span class="s1">sourceFiber,</span>
          <span class="s1">error</span>
        <span class="s1">);</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">=== nearestMountedAncestor.tag) {</span>
        <span class="s3">var </span><span class="s1">instance = nearestMountedAncestor.stateNode;</span>
        <span class="s3">if </span><span class="s1">(</span>
          <span class="s2">&quot;function&quot; </span><span class="s1">===</span>
            <span class="s3">typeof </span><span class="s1">nearestMountedAncestor.type.getDerivedStateFromError ||</span>
          <span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">instance.componentDidCatch &amp;&amp;</span>
            <span class="s1">(</span><span class="s3">null </span><span class="s1">=== legacyErrorBoundariesThatAlreadyFailed ||</span>
              <span class="s1">!legacyErrorBoundariesThatAlreadyFailed.has(instance)))</span>
        <span class="s1">) {</span>
          <span class="s1">sourceFiber = createCapturedValueAtFiber(error, sourceFiber);</span>
          <span class="s1">sourceFiber = createClassErrorUpdate(</span>
            <span class="s1">nearestMountedAncestor,</span>
            <span class="s1">sourceFiber,</span>
            <span class="s4">1</span>
          <span class="s1">);</span>
          <span class="s1">nearestMountedAncestor = enqueueUpdate(</span>
            <span class="s1">nearestMountedAncestor,</span>
            <span class="s1">sourceFiber,</span>
            <span class="s4">1</span>
          <span class="s1">);</span>
          <span class="s1">sourceFiber = requestEventTime();</span>
          <span class="s3">null </span><span class="s1">!== nearestMountedAncestor &amp;&amp;</span>
            <span class="s1">(markRootUpdated(nearestMountedAncestor, </span><span class="s4">1</span><span class="s1">, sourceFiber),</span>
            <span class="s1">ensureRootIsScheduled(nearestMountedAncestor, sourceFiber));</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">nearestMountedAncestor = nearestMountedAncestor.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pingSuspendedRoot(root, wakeable, pingedLanes) {</span>
  <span class="s3">var </span><span class="s1">pingCache = root.pingCache;</span>
  <span class="s3">null </span><span class="s1">!== pingCache &amp;&amp; pingCache.</span><span class="s3">delete</span><span class="s1">(wakeable);</span>
  <span class="s1">wakeable = requestEventTime();</span>
  <span class="s1">root.pingedLanes |= root.suspendedLanes &amp; pingedLanes;</span>
  <span class="s1">workInProgressRoot === root &amp;&amp;</span>
    <span class="s1">(workInProgressRootRenderLanes &amp; pingedLanes) === pingedLanes &amp;&amp;</span>
    <span class="s1">(</span><span class="s4">4 </span><span class="s1">=== workInProgressRootExitStatus ||</span>
    <span class="s1">(</span><span class="s4">3 </span><span class="s1">=== workInProgressRootExitStatus &amp;&amp;</span>
      <span class="s1">(workInProgressRootRenderLanes &amp; </span><span class="s4">130023424</span><span class="s1">) ===</span>
        <span class="s1">workInProgressRootRenderLanes &amp;&amp;</span>
      <span class="s4">500 </span><span class="s1">&gt; now() - globalMostRecentFallbackTime)</span>
      <span class="s1">? prepareFreshStack(root, </span><span class="s4">0</span><span class="s1">)</span>
      <span class="s1">: (workInProgressRootPingedLanes |= pingedLanes));</span>
  <span class="s1">ensureRootIsScheduled(root, wakeable);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">retryTimedOutBoundary(boundaryFiber, retryLane) {</span>
  <span class="s4">0 </span><span class="s1">=== retryLane &amp;&amp;</span>
    <span class="s1">(</span><span class="s4">0 </span><span class="s1">=== (boundaryFiber.mode &amp; </span><span class="s4">1</span><span class="s1">)</span>
      <span class="s1">? (retryLane = </span><span class="s4">1</span><span class="s1">)</span>
      <span class="s1">: ((retryLane = nextRetryLane),</span>
        <span class="s1">(nextRetryLane &lt;&lt;= </span><span class="s4">1</span><span class="s1">),</span>
        <span class="s4">0 </span><span class="s1">=== (nextRetryLane &amp; </span><span class="s4">130023424</span><span class="s1">) &amp;&amp; (nextRetryLane = </span><span class="s4">4194304</span><span class="s1">)));</span>
  <span class="s3">var </span><span class="s1">eventTime = requestEventTime();</span>
  <span class="s1">boundaryFiber = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);</span>
  <span class="s3">null </span><span class="s1">!== boundaryFiber &amp;&amp;</span>
    <span class="s1">(markRootUpdated(boundaryFiber, retryLane, eventTime),</span>
    <span class="s1">ensureRootIsScheduled(boundaryFiber, eventTime));</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">retryDehydratedSuspenseBoundary(boundaryFiber) {</span>
  <span class="s3">var </span><span class="s1">suspenseState = boundaryFiber.memoizedState,</span>
    <span class="s1">retryLane = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">null </span><span class="s1">!== suspenseState &amp;&amp; (retryLane = suspenseState.retryLane);</span>
  <span class="s1">retryTimedOutBoundary(boundaryFiber, retryLane);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">resolveRetryWakeable(boundaryFiber, wakeable) {</span>
  <span class="s3">var </span><span class="s1">retryLane = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">switch </span><span class="s1">(boundaryFiber.tag) {</span>
    <span class="s3">case </span><span class="s4">13</span><span class="s1">:</span>
      <span class="s3">var </span><span class="s1">retryCache = boundaryFiber.stateNode;</span>
      <span class="s3">var </span><span class="s1">suspenseState = boundaryFiber.memoizedState;</span>
      <span class="s3">null </span><span class="s1">!== suspenseState &amp;&amp; (retryLane = suspenseState.retryLane);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">19</span><span class="s1">:</span>
      <span class="s1">retryCache = boundaryFiber.stateNode;</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">default</span><span class="s1">:</span>
      <span class="s3">throw </span><span class="s1">Error(</span>
        <span class="s2">&quot;Pinged unknown suspense boundary type. This is probably a bug in React.&quot;</span>
      <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">null </span><span class="s1">!== retryCache &amp;&amp; retryCache.</span><span class="s3">delete</span><span class="s1">(wakeable);</span>
  <span class="s1">retryTimedOutBoundary(boundaryFiber, retryLane);</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">beginWork$1;</span>
<span class="s1">beginWork$1 = </span><span class="s3">function</span><span class="s1">(current, workInProgress, renderLanes) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== current)</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">current.memoizedProps !== workInProgress.pendingProps ||</span>
      <span class="s1">didPerformWorkStackCursor.current</span>
    <span class="s1">)</span>
      <span class="s1">didReceiveUpdate = !</span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">else </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s4">0 </span><span class="s1">=== (current.lanes &amp; renderLanes) &amp;&amp;</span>
        <span class="s4">0 </span><span class="s1">=== (workInProgress.flags &amp; </span><span class="s4">128</span><span class="s1">)</span>
      <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">(</span>
          <span class="s1">(didReceiveUpdate = !</span><span class="s4">1</span><span class="s1">),</span>
          <span class="s1">attemptEarlyBailoutIfNoScheduledUpdate(</span>
            <span class="s1">current,</span>
            <span class="s1">workInProgress,</span>
            <span class="s1">renderLanes</span>
          <span class="s1">)</span>
        <span class="s1">);</span>
      <span class="s1">didReceiveUpdate = </span><span class="s4">0 </span><span class="s1">!== (current.flags &amp; </span><span class="s4">131072</span><span class="s1">) ? !</span><span class="s4">0 </span><span class="s1">: !</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s3">else </span><span class="s1">didReceiveUpdate = !</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">workInProgress.lanes = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">switch </span><span class="s1">(workInProgress.tag) {</span>
    <span class="s3">case </span><span class="s4">2</span><span class="s1">:</span>
      <span class="s3">var </span><span class="s1">Component = workInProgress.type;</span>
      <span class="s1">resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);</span>
      <span class="s1">current = workInProgress.pendingProps;</span>
      <span class="s3">var </span><span class="s1">context = getMaskedContext(</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">contextStackCursor.current</span>
      <span class="s1">);</span>
      <span class="s1">prepareToReadContext(workInProgress, renderLanes);</span>
      <span class="s1">context = renderWithHooks(</span>
        <span class="s3">null</span><span class="s1">,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">Component,</span>
        <span class="s1">current,</span>
        <span class="s1">context,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
      <span class="s1">workInProgress.flags |= </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s2">&quot;object&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">context &amp;&amp;</span>
        <span class="s3">null </span><span class="s1">!== context &amp;&amp;</span>
        <span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">context.render &amp;&amp;</span>
        <span class="s3">void </span><span class="s4">0 </span><span class="s1">=== context.$$typeof</span>
      <span class="s1">) {</span>
        <span class="s1">workInProgress.tag = </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">workInProgress.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
          <span class="s3">var </span><span class="s1">hasContext = !</span><span class="s4">0</span><span class="s1">;</span>
          <span class="s1">pushContextProvider(workInProgress);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">hasContext = !</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">workInProgress.memoizedState =</span>
          <span class="s3">null </span><span class="s1">!== context.state &amp;&amp; </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">!== context.state</span>
            <span class="s1">? context.state</span>
            <span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">initializeUpdateQueue(workInProgress);</span>
        <span class="s1">context.updater = classComponentUpdater;</span>
        <span class="s1">workInProgress.stateNode = context;</span>
        <span class="s1">context._reactInternals = workInProgress;</span>
        <span class="s1">mountClassInstance(workInProgress, Component, current, renderLanes);</span>
        <span class="s1">workInProgress = finishClassComponent(</span>
          <span class="s3">null</span><span class="s1">,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">Component,</span>
          <span class="s1">!</span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">hasContext,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else</span>
        <span class="s1">(workInProgress.tag = </span><span class="s4">0</span><span class="s1">),</span>
          <span class="s1">reconcileChildren(</span><span class="s3">null</span><span class="s1">, workInProgress, context, renderLanes),</span>
          <span class="s1">(workInProgress = workInProgress.child);</span>
      <span class="s3">return </span><span class="s1">workInProgress;</span>
    <span class="s3">case </span><span class="s4">16</span><span class="s1">:</span>
      <span class="s1">Component = workInProgress.elementType;</span>
      <span class="s1">a: {</span>
        <span class="s1">resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);</span>
        <span class="s1">current = workInProgress.pendingProps;</span>
        <span class="s1">context = Component._init;</span>
        <span class="s1">Component = context(Component._payload);</span>
        <span class="s1">workInProgress.type = Component;</span>
        <span class="s1">context = workInProgress.tag = resolveLazyComponentTag(Component);</span>
        <span class="s1">current = resolveDefaultProps(Component, current);</span>
        <span class="s3">switch </span><span class="s1">(context) {</span>
          <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">workInProgress = updateFunctionComponent(</span>
              <span class="s3">null</span><span class="s1">,</span>
              <span class="s1">workInProgress,</span>
              <span class="s1">Component,</span>
              <span class="s1">current,</span>
              <span class="s1">renderLanes</span>
            <span class="s1">);</span>
            <span class="s3">break </span><span class="s1">a;</span>
          <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">workInProgress = updateClassComponent(</span>
              <span class="s3">null</span><span class="s1">,</span>
              <span class="s1">workInProgress,</span>
              <span class="s1">Component,</span>
              <span class="s1">current,</span>
              <span class="s1">renderLanes</span>
            <span class="s1">);</span>
            <span class="s3">break </span><span class="s1">a;</span>
          <span class="s3">case </span><span class="s4">11</span><span class="s1">:</span>
            <span class="s1">workInProgress = updateForwardRef(</span>
              <span class="s3">null</span><span class="s1">,</span>
              <span class="s1">workInProgress,</span>
              <span class="s1">Component,</span>
              <span class="s1">current,</span>
              <span class="s1">renderLanes</span>
            <span class="s1">);</span>
            <span class="s3">break </span><span class="s1">a;</span>
          <span class="s3">case </span><span class="s4">14</span><span class="s1">:</span>
            <span class="s1">workInProgress = updateMemoComponent(</span>
              <span class="s3">null</span><span class="s1">,</span>
              <span class="s1">workInProgress,</span>
              <span class="s1">Component,</span>
              <span class="s1">resolveDefaultProps(Component.type, current),</span>
              <span class="s1">renderLanes</span>
            <span class="s1">);</span>
            <span class="s3">break </span><span class="s1">a;</span>
        <span class="s1">}</span>
        <span class="s3">throw </span><span class="s1">Error(</span>
          <span class="s2">&quot;Element type is invalid. Received a promise that resolves to: &quot; </span><span class="s1">+</span>
            <span class="s1">Component +</span>
            <span class="s2">&quot;. Lazy element type must resolve to a class or function.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s3">return </span><span class="s1">workInProgress;</span>
    <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(Component = workInProgress.type),</span>
        <span class="s1">(context = workInProgress.pendingProps),</span>
        <span class="s1">(context =</span>
          <span class="s1">workInProgress.elementType === Component</span>
            <span class="s1">? context</span>
            <span class="s1">: resolveDefaultProps(Component, context)),</span>
        <span class="s1">updateFunctionComponent(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">Component,</span>
          <span class="s1">context,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">)</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(Component = workInProgress.type),</span>
        <span class="s1">(context = workInProgress.pendingProps),</span>
        <span class="s1">(context =</span>
          <span class="s1">workInProgress.elementType === Component</span>
            <span class="s1">? context</span>
            <span class="s1">: resolveDefaultProps(Component, context)),</span>
        <span class="s1">updateClassComponent(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">Component,</span>
          <span class="s1">context,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">)</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
      <span class="s1">pushHostRootContext(workInProgress);</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== current)</span>
        <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Should have a current fiber. This is a bug in React.&quot;</span><span class="s1">);</span>
      <span class="s1">context = workInProgress.pendingProps;</span>
      <span class="s1">Component = workInProgress.memoizedState.element;</span>
      <span class="s1">cloneUpdateQueue(current, workInProgress);</span>
      <span class="s1">processUpdateQueue(workInProgress, context, </span><span class="s3">null</span><span class="s1">, renderLanes);</span>
      <span class="s1">context = workInProgress.memoizedState.element;</span>
      <span class="s1">context === Component</span>
        <span class="s1">? (workInProgress = bailoutOnAlreadyFinishedWork(</span>
            <span class="s1">current,</span>
            <span class="s1">workInProgress,</span>
            <span class="s1">renderLanes</span>
          <span class="s1">))</span>
        <span class="s1">: (reconcileChildren(current, workInProgress, context, renderLanes),</span>
          <span class="s1">(workInProgress = workInProgress.child));</span>
      <span class="s3">return </span><span class="s1">workInProgress;</span>
    <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">pushHostContext(workInProgress),</span>
        <span class="s1">(Component = workInProgress.pendingProps.children),</span>
        <span class="s1">markRef(current, workInProgress),</span>
        <span class="s1">reconcileChildren(current, workInProgress, Component, renderLanes),</span>
        <span class="s1">workInProgress.child</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">6</span><span class="s1">:</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">13</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">updateSuspenseComponent(current, workInProgress, renderLanes);</span>
    <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">pushHostContainer(</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">workInProgress.stateNode.containerInfo</span>
        <span class="s1">),</span>
        <span class="s1">(Component = workInProgress.pendingProps),</span>
        <span class="s3">null </span><span class="s1">=== current</span>
          <span class="s1">? (workInProgress.child = reconcileChildFibers(</span>
              <span class="s1">workInProgress,</span>
              <span class="s3">null</span><span class="s1">,</span>
              <span class="s1">Component,</span>
              <span class="s1">renderLanes</span>
            <span class="s1">))</span>
          <span class="s1">: reconcileChildren(current, workInProgress, Component, renderLanes),</span>
        <span class="s1">workInProgress.child</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">11</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(Component = workInProgress.type),</span>
        <span class="s1">(context = workInProgress.pendingProps),</span>
        <span class="s1">(context =</span>
          <span class="s1">workInProgress.elementType === Component</span>
            <span class="s1">? context</span>
            <span class="s1">: resolveDefaultProps(Component, context)),</span>
        <span class="s1">updateForwardRef(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">Component,</span>
          <span class="s1">context,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">)</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">7</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">reconcileChildren(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">workInProgress.pendingProps,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">),</span>
        <span class="s1">workInProgress.child</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">8</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">reconcileChildren(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">workInProgress.pendingProps.children,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">),</span>
        <span class="s1">workInProgress.child</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">12</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(workInProgress.flags |= </span><span class="s4">4</span><span class="s1">),</span>
        <span class="s1">(Component = workInProgress.stateNode),</span>
        <span class="s1">(Component.effectDuration = </span><span class="s4">0</span><span class="s1">),</span>
        <span class="s1">(Component.passiveEffectDuration = </span><span class="s4">0</span><span class="s1">),</span>
        <span class="s1">reconcileChildren(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">workInProgress.pendingProps.children,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">),</span>
        <span class="s1">workInProgress.child</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">10</span><span class="s1">:</span>
      <span class="s1">a: {</span>
        <span class="s1">Component = workInProgress.type._context;</span>
        <span class="s1">context = workInProgress.pendingProps;</span>
        <span class="s1">hasContext = workInProgress.memoizedProps;</span>
        <span class="s3">var </span><span class="s1">newValue = context.value;</span>
        <span class="s1">push(valueCursor, Component._currentValue);</span>
        <span class="s1">Component._currentValue = newValue;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== hasContext)</span>
          <span class="s3">if </span><span class="s1">(objectIs(hasContext.value, newValue)) {</span>
            <span class="s3">if </span><span class="s1">(</span>
              <span class="s1">hasContext.children === context.children &amp;&amp;</span>
              <span class="s1">!didPerformWorkStackCursor.current</span>
            <span class="s1">) {</span>
              <span class="s1">workInProgress = bailoutOnAlreadyFinishedWork(</span>
                <span class="s1">current,</span>
                <span class="s1">workInProgress,</span>
                <span class="s1">renderLanes</span>
              <span class="s1">);</span>
              <span class="s3">break </span><span class="s1">a;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s3">else</span>
            <span class="s3">for </span><span class="s1">(</span>
              <span class="s1">hasContext = workInProgress.child,</span>
                <span class="s3">null </span><span class="s1">!== hasContext &amp;&amp; (hasContext.</span><span class="s3">return </span><span class="s1">= workInProgress);</span>
              <span class="s3">null </span><span class="s1">!== hasContext;</span>

            <span class="s1">) {</span>
              <span class="s3">var </span><span class="s1">list = hasContext.dependencies;</span>
              <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== list) {</span>
                <span class="s1">newValue = hasContext.child;</span>
                <span class="s3">for </span><span class="s1">(</span>
                  <span class="s3">var </span><span class="s1">dependency = list.firstContext;</span>
                  <span class="s3">null </span><span class="s1">!== dependency;</span>

                <span class="s1">) {</span>
                  <span class="s3">if </span><span class="s1">(dependency.context === Component) {</span>
                    <span class="s3">if </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">=== hasContext.tag) {</span>
                      <span class="s1">dependency = createUpdate(-</span><span class="s4">1</span><span class="s1">, renderLanes &amp; -renderLanes);</span>
                      <span class="s1">dependency.tag = </span><span class="s4">2</span><span class="s1">;</span>
                      <span class="s3">var </span><span class="s1">updateQueue = hasContext.updateQueue;</span>
                      <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== updateQueue) {</span>
                        <span class="s1">updateQueue = updateQueue.shared;</span>
                        <span class="s3">var </span><span class="s1">pending = updateQueue.pending;</span>
                        <span class="s3">null </span><span class="s1">=== pending</span>
                          <span class="s1">? (dependency.next = dependency)</span>
                          <span class="s1">: ((dependency.next = pending.next),</span>
                            <span class="s1">(pending.next = dependency));</span>
                        <span class="s1">updateQueue.pending = dependency;</span>
                      <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s1">hasContext.lanes |= renderLanes;</span>
                    <span class="s1">dependency = hasContext.alternate;</span>
                    <span class="s3">null </span><span class="s1">!== dependency &amp;&amp; (dependency.lanes |= renderLanes);</span>
                    <span class="s1">scheduleContextWorkOnParentPath(</span>
                      <span class="s1">hasContext.</span><span class="s3">return</span><span class="s1">,</span>
                      <span class="s1">renderLanes,</span>
                      <span class="s1">workInProgress</span>
                    <span class="s1">);</span>
                    <span class="s1">list.lanes |= renderLanes;</span>
                    <span class="s3">break</span><span class="s1">;</span>
                  <span class="s1">}</span>
                  <span class="s1">dependency = dependency.next;</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s4">10 </span><span class="s1">=== hasContext.tag)</span>
                <span class="s1">newValue =</span>
                  <span class="s1">hasContext.type === workInProgress.type</span>
                    <span class="s1">? </span><span class="s3">null</span>
                    <span class="s1">: hasContext.child;</span>
              <span class="s3">else if </span><span class="s1">(</span><span class="s4">18 </span><span class="s1">=== hasContext.tag) {</span>
                <span class="s1">newValue = hasContext.</span><span class="s3">return</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">=== newValue)</span>
                  <span class="s3">throw </span><span class="s1">Error(</span>
                    <span class="s2">&quot;We just came from a parent so we must have had a parent. This is a bug in React.&quot;</span>
                  <span class="s1">);</span>
                <span class="s1">newValue.lanes |= renderLanes;</span>
                <span class="s1">list = newValue.alternate;</span>
                <span class="s3">null </span><span class="s1">!== list &amp;&amp; (list.lanes |= renderLanes);</span>
                <span class="s1">scheduleContextWorkOnParentPath(</span>
                  <span class="s1">newValue,</span>
                  <span class="s1">renderLanes,</span>
                  <span class="s1">workInProgress</span>
                <span class="s1">);</span>
                <span class="s1">newValue = hasContext.sibling;</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">newValue = hasContext.child;</span>
              <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== newValue) newValue.</span><span class="s3">return </span><span class="s1">= hasContext;</span>
              <span class="s3">else</span>
                <span class="s3">for </span><span class="s1">(newValue = hasContext; </span><span class="s3">null </span><span class="s1">!== newValue; ) {</span>
                  <span class="s3">if </span><span class="s1">(newValue === workInProgress) {</span>
                    <span class="s1">newValue = </span><span class="s3">null</span><span class="s1">;</span>
                    <span class="s3">break</span><span class="s1">;</span>
                  <span class="s1">}</span>
                  <span class="s1">hasContext = newValue.sibling;</span>
                  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== hasContext) {</span>
                    <span class="s1">hasContext.</span><span class="s3">return </span><span class="s1">= newValue.</span><span class="s3">return</span><span class="s1">;</span>
                    <span class="s1">newValue = hasContext;</span>
                    <span class="s3">break</span><span class="s1">;</span>
                  <span class="s1">}</span>
                  <span class="s1">newValue = newValue.</span><span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>
              <span class="s1">hasContext = newValue;</span>
            <span class="s1">}</span>
        <span class="s1">reconcileChildren(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">context.children,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">);</span>
        <span class="s1">workInProgress = workInProgress.child;</span>
      <span class="s1">}</span>
      <span class="s3">return </span><span class="s1">workInProgress;</span>
    <span class="s3">case </span><span class="s4">9</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(context = workInProgress.type),</span>
        <span class="s1">(Component = workInProgress.pendingProps.children),</span>
        <span class="s1">prepareToReadContext(workInProgress, renderLanes),</span>
        <span class="s1">(context = readContext(context)),</span>
        <span class="s1">(Component = Component(context)),</span>
        <span class="s1">(workInProgress.flags |= </span><span class="s4">1</span><span class="s1">),</span>
        <span class="s1">reconcileChildren(current, workInProgress, Component, renderLanes),</span>
        <span class="s1">workInProgress.child</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">14</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(Component = workInProgress.type),</span>
        <span class="s1">(context = resolveDefaultProps(Component, workInProgress.pendingProps)),</span>
        <span class="s1">(context = resolveDefaultProps(Component.type, context)),</span>
        <span class="s1">updateMemoComponent(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">Component,</span>
          <span class="s1">context,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">)</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">15</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">updateSimpleMemoComponent(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">workInProgress.type,</span>
        <span class="s1">workInProgress.pendingProps,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">17</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(Component = workInProgress.type),</span>
        <span class="s1">(context = workInProgress.pendingProps),</span>
        <span class="s1">(context =</span>
          <span class="s1">workInProgress.elementType === Component</span>
            <span class="s1">? context</span>
            <span class="s1">: resolveDefaultProps(Component, context)),</span>
        <span class="s1">resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress),</span>
        <span class="s1">(workInProgress.tag = </span><span class="s4">1</span><span class="s1">),</span>
        <span class="s1">isContextProvider(Component)</span>
          <span class="s1">? ((current = !</span><span class="s4">0</span><span class="s1">), pushContextProvider(workInProgress))</span>
          <span class="s1">: (current = !</span><span class="s4">1</span><span class="s1">),</span>
        <span class="s1">prepareToReadContext(workInProgress, renderLanes),</span>
        <span class="s1">constructClassInstance(workInProgress, Component, context),</span>
        <span class="s1">mountClassInstance(workInProgress, Component, context, renderLanes),</span>
        <span class="s1">finishClassComponent(</span>
          <span class="s3">null</span><span class="s1">,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">Component,</span>
          <span class="s1">!</span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">current,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">)</span>
      <span class="s1">);</span>
    <span class="s3">case </span><span class="s4">19</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">updateSuspenseListComponent(current, workInProgress, renderLanes);</span>
    <span class="s3">case </span><span class="s4">22</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">updateOffscreenComponent(current, workInProgress, renderLanes);</span>
  <span class="s1">}</span>
  <span class="s3">throw </span><span class="s1">Error(</span>
    <span class="s2">&quot;Unknown unit of work tag (&quot; </span><span class="s1">+</span>
      <span class="s1">workInProgress.tag +</span>
      <span class="s2">&quot;). This error is likely caused by a bug in React. Please file an issue.&quot;</span>
  <span class="s1">);</span>
<span class="s1">};</span>
<span class="s3">function </span><span class="s1">restorePendingUpdaters(root, lanes) {</span>
  <span class="s1">isDevToolsPresent &amp;&amp;</span>
    <span class="s1">root.memoizedUpdaters.forEach(</span><span class="s3">function</span><span class="s1">(schedulingFiber) {</span>
      <span class="s1">addFiberToLanesMap(root, schedulingFiber, lanes);</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">scheduleCallback$1(priorityLevel, callback) {</span>
  <span class="s3">return </span><span class="s1">scheduleCallback(priorityLevel, callback);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">FiberNode(tag, pendingProps, key, mode) {</span>
  <span class="s3">this</span><span class="s1">.tag = tag;</span>
  <span class="s3">this</span><span class="s1">.key = key;</span>
  <span class="s3">this</span><span class="s1">.sibling = </span><span class="s3">this</span><span class="s1">.child = </span><span class="s3">this</span><span class="s1">.</span><span class="s3">return </span><span class="s1">= </span><span class="s3">this</span><span class="s1">.stateNode = </span><span class="s3">this</span><span class="s1">.type = </span><span class="s3">this</span><span class="s1">.elementType = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.index = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.ref = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.pendingProps = pendingProps;</span>
  <span class="s3">this</span><span class="s1">.dependencies = </span><span class="s3">this</span><span class="s1">.memoizedState = </span><span class="s3">this</span><span class="s1">.updateQueue = </span><span class="s3">this</span><span class="s1">.memoizedProps = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.mode = mode;</span>
  <span class="s3">this</span><span class="s1">.subtreeFlags = </span><span class="s3">this</span><span class="s1">.flags = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.deletions = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.childLanes = </span><span class="s3">this</span><span class="s1">.lanes = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.alternate = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.actualDuration = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.actualStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.treeBaseDuration = </span><span class="s3">this</span><span class="s1">.selfBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createFiber(tag, pendingProps, key, mode) {</span>
  <span class="s3">return new </span><span class="s1">FiberNode(tag, pendingProps, key, mode);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">shouldConstruct(Component) {</span>
  <span class="s1">Component = Component.prototype;</span>
  <span class="s3">return </span><span class="s1">!(!Component || !Component.isReactComponent);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">resolveLazyComponentTag(Component) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">Component)</span>
    <span class="s3">return </span><span class="s1">shouldConstruct(Component) ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">void </span><span class="s4">0 </span><span class="s1">!== Component &amp;&amp; </span><span class="s3">null </span><span class="s1">!== Component) {</span>
    <span class="s1">Component = Component.$$typeof;</span>
    <span class="s3">if </span><span class="s1">(Component === REACT_FORWARD_REF_TYPE) </span><span class="s3">return </span><span class="s4">11</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(Component === REACT_MEMO_TYPE) </span><span class="s3">return </span><span class="s4">14</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s4">2</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createWorkInProgress(current, pendingProps) {</span>
  <span class="s3">var </span><span class="s1">workInProgress = current.alternate;</span>
  <span class="s3">null </span><span class="s1">=== workInProgress</span>
    <span class="s1">? ((workInProgress = createFiber(</span>
        <span class="s1">current.tag,</span>
        <span class="s1">pendingProps,</span>
        <span class="s1">current.key,</span>
        <span class="s1">current.mode</span>
      <span class="s1">)),</span>
      <span class="s1">(workInProgress.elementType = current.elementType),</span>
      <span class="s1">(workInProgress.type = current.type),</span>
      <span class="s1">(workInProgress.stateNode = current.stateNode),</span>
      <span class="s1">(workInProgress.alternate = current),</span>
      <span class="s1">(current.alternate = workInProgress))</span>
    <span class="s1">: ((workInProgress.pendingProps = pendingProps),</span>
      <span class="s1">(workInProgress.type = current.type),</span>
      <span class="s1">(workInProgress.flags = </span><span class="s4">0</span><span class="s1">),</span>
      <span class="s1">(workInProgress.subtreeFlags = </span><span class="s4">0</span><span class="s1">),</span>
      <span class="s1">(workInProgress.deletions = </span><span class="s3">null</span><span class="s1">),</span>
      <span class="s1">(workInProgress.actualDuration = </span><span class="s4">0</span><span class="s1">),</span>
      <span class="s1">(workInProgress.actualStartTime = -</span><span class="s4">1</span><span class="s1">));</span>
  <span class="s1">workInProgress.flags = current.flags &amp; </span><span class="s4">14680064</span><span class="s1">;</span>
  <span class="s1">workInProgress.childLanes = current.childLanes;</span>
  <span class="s1">workInProgress.lanes = current.lanes;</span>
  <span class="s1">workInProgress.child = current.child;</span>
  <span class="s1">workInProgress.memoizedProps = current.memoizedProps;</span>
  <span class="s1">workInProgress.memoizedState = current.memoizedState;</span>
  <span class="s1">workInProgress.updateQueue = current.updateQueue;</span>
  <span class="s1">pendingProps = current.dependencies;</span>
  <span class="s1">workInProgress.dependencies =</span>
    <span class="s3">null </span><span class="s1">=== pendingProps</span>
      <span class="s1">? </span><span class="s3">null</span>
      <span class="s1">: { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };</span>
  <span class="s1">workInProgress.sibling = current.sibling;</span>
  <span class="s1">workInProgress.index = current.index;</span>
  <span class="s1">workInProgress.ref = current.ref;</span>
  <span class="s1">workInProgress.selfBaseDuration = current.selfBaseDuration;</span>
  <span class="s1">workInProgress.treeBaseDuration = current.treeBaseDuration;</span>
  <span class="s3">return </span><span class="s1">workInProgress;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createFiberFromTypeAndProps(</span>
  <span class="s1">type,</span>
  <span class="s1">key,</span>
  <span class="s1">pendingProps,</span>
  <span class="s1">owner,</span>
  <span class="s1">mode,</span>
  <span class="s1">lanes</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">fiberTag = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s1">owner = type;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">type) shouldConstruct(type) &amp;&amp; (fiberTag = </span><span class="s4">1</span><span class="s1">);</span>
  <span class="s3">else if </span><span class="s1">(</span><span class="s2">&quot;string&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">type) fiberTag = </span><span class="s4">5</span><span class="s1">;</span>
  <span class="s3">else</span>
    <span class="s1">a: </span><span class="s3">switch </span><span class="s1">(type) {</span>
      <span class="s3">case </span><span class="s1">REACT_FRAGMENT_TYPE:</span>
        <span class="s3">return </span><span class="s1">createFiberFromFragment(pendingProps.children, mode, lanes, key);</span>
      <span class="s3">case </span><span class="s1">REACT_STRICT_MODE_TYPE:</span>
        <span class="s1">fiberTag = </span><span class="s4">8</span><span class="s1">;</span>
        <span class="s1">mode |= </span><span class="s4">8</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s3">case </span><span class="s1">REACT_PROFILER_TYPE:</span>
        <span class="s3">return </span><span class="s1">(</span>
          <span class="s1">(type = createFiber(</span><span class="s4">12</span><span class="s1">, pendingProps, key, mode | </span><span class="s4">2</span><span class="s1">)),</span>
          <span class="s1">(type.elementType = REACT_PROFILER_TYPE),</span>
          <span class="s1">(type.lanes = lanes),</span>
          <span class="s1">(type.stateNode = { effectDuration: </span><span class="s4">0</span><span class="s1">, passiveEffectDuration: </span><span class="s4">0 </span><span class="s1">}),</span>
          <span class="s1">type</span>
        <span class="s1">);</span>
      <span class="s3">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
        <span class="s3">return </span><span class="s1">(</span>
          <span class="s1">(type = createFiber(</span><span class="s4">13</span><span class="s1">, pendingProps, key, mode)),</span>
          <span class="s1">(type.elementType = REACT_SUSPENSE_TYPE),</span>
          <span class="s1">(type.lanes = lanes),</span>
          <span class="s1">type</span>
        <span class="s1">);</span>
      <span class="s3">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
        <span class="s3">return </span><span class="s1">(</span>
          <span class="s1">(type = createFiber(</span><span class="s4">19</span><span class="s1">, pendingProps, key, mode)),</span>
          <span class="s1">(type.elementType = REACT_SUSPENSE_LIST_TYPE),</span>
          <span class="s1">(type.lanes = lanes),</span>
          <span class="s1">type</span>
        <span class="s1">);</span>
      <span class="s3">case </span><span class="s1">REACT_OFFSCREEN_TYPE:</span>
        <span class="s3">return </span><span class="s1">createFiberFromOffscreen(pendingProps, mode, lanes, key);</span>
      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;object&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">type &amp;&amp; </span><span class="s3">null </span><span class="s1">!== type)</span>
          <span class="s3">switch </span><span class="s1">(type.$$typeof) {</span>
            <span class="s3">case </span><span class="s1">REACT_PROVIDER_TYPE:</span>
              <span class="s1">fiberTag = </span><span class="s4">10</span><span class="s1">;</span>
              <span class="s3">break </span><span class="s1">a;</span>
            <span class="s3">case </span><span class="s1">REACT_CONTEXT_TYPE:</span>
              <span class="s1">fiberTag = </span><span class="s4">9</span><span class="s1">;</span>
              <span class="s3">break </span><span class="s1">a;</span>
            <span class="s3">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
              <span class="s1">fiberTag = </span><span class="s4">11</span><span class="s1">;</span>
              <span class="s3">break </span><span class="s1">a;</span>
            <span class="s3">case </span><span class="s1">REACT_MEMO_TYPE:</span>
              <span class="s1">fiberTag = </span><span class="s4">14</span><span class="s1">;</span>
              <span class="s3">break </span><span class="s1">a;</span>
            <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE:</span>
              <span class="s1">fiberTag = </span><span class="s4">16</span><span class="s1">;</span>
              <span class="s1">owner = </span><span class="s3">null</span><span class="s1">;</span>
              <span class="s3">break </span><span class="s1">a;</span>
          <span class="s1">}</span>
        <span class="s3">throw </span><span class="s1">Error(</span>
          <span class="s2">&quot;Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: &quot; </span><span class="s1">+</span>
            <span class="s1">((</span><span class="s3">null </span><span class="s1">== type ? type : </span><span class="s3">typeof </span><span class="s1">type) + </span><span class="s2">&quot;.&quot;</span><span class="s1">)</span>
        <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">key = createFiber(fiberTag, pendingProps, key, mode);</span>
  <span class="s1">key.elementType = type;</span>
  <span class="s1">key.type = owner;</span>
  <span class="s1">key.lanes = lanes;</span>
  <span class="s3">return </span><span class="s1">key;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createFiberFromFragment(elements, mode, lanes, key) {</span>
  <span class="s1">elements = createFiber(</span><span class="s4">7</span><span class="s1">, elements, key, mode);</span>
  <span class="s1">elements.lanes = lanes;</span>
  <span class="s3">return </span><span class="s1">elements;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createFiberFromOffscreen(pendingProps, mode, lanes, key) {</span>
  <span class="s1">pendingProps = createFiber(</span><span class="s4">22</span><span class="s1">, pendingProps, key, mode);</span>
  <span class="s1">pendingProps.elementType = REACT_OFFSCREEN_TYPE;</span>
  <span class="s1">pendingProps.lanes = lanes;</span>
  <span class="s1">pendingProps.stateNode = { isHidden: !</span><span class="s4">1 </span><span class="s1">};</span>
  <span class="s3">return </span><span class="s1">pendingProps;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createFiberFromText(content, mode, lanes) {</span>
  <span class="s1">content = createFiber(</span><span class="s4">6</span><span class="s1">, content, </span><span class="s3">null</span><span class="s1">, mode);</span>
  <span class="s1">content.lanes = lanes;</span>
  <span class="s3">return </span><span class="s1">content;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createFiberFromPortal(portal, mode, lanes) {</span>
  <span class="s1">mode = createFiber(</span>
    <span class="s4">4</span><span class="s1">,</span>
    <span class="s3">null </span><span class="s1">!== portal.children ? portal.children : [],</span>
    <span class="s1">portal.key,</span>
    <span class="s1">mode</span>
  <span class="s1">);</span>
  <span class="s1">mode.lanes = lanes;</span>
  <span class="s1">mode.stateNode = {</span>
    <span class="s1">containerInfo: portal.containerInfo,</span>
    <span class="s1">pendingChildren: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">implementation: portal.implementation</span>
  <span class="s1">};</span>
  <span class="s3">return </span><span class="s1">mode;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">FiberRootNode(</span>
  <span class="s1">containerInfo,</span>
  <span class="s1">tag,</span>
  <span class="s1">hydrate,</span>
  <span class="s1">identifierPrefix,</span>
  <span class="s1">onRecoverableError</span>
<span class="s1">) {</span>
  <span class="s3">this</span><span class="s1">.tag = tag;</span>
  <span class="s3">this</span><span class="s1">.containerInfo = containerInfo;</span>
  <span class="s3">this</span><span class="s1">.finishedWork = </span><span class="s3">this</span><span class="s1">.pingCache = </span><span class="s3">this</span><span class="s1">.current = </span><span class="s3">this</span><span class="s1">.pendingChildren = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.timeoutHandle = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.callbackNode = </span><span class="s3">this</span><span class="s1">.pendingContext = </span><span class="s3">this</span><span class="s1">.context = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.callbackPriority = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.eventTimes = createLaneMap(</span><span class="s4">0</span><span class="s1">);</span>
  <span class="s3">this</span><span class="s1">.expirationTimes = createLaneMap(-</span><span class="s4">1</span><span class="s1">);</span>
  <span class="s3">this</span><span class="s1">.entangledLanes = </span><span class="s3">this</span><span class="s1">.finishedLanes = </span><span class="s3">this</span><span class="s1">.mutableReadLanes = </span><span class="s3">this</span><span class="s1">.expiredLanes = </span><span class="s3">this</span><span class="s1">.pingedLanes = </span><span class="s3">this</span><span class="s1">.suspendedLanes = </span><span class="s3">this</span><span class="s1">.pendingLanes = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.entanglements = createLaneMap(</span><span class="s4">0</span><span class="s1">);</span>
  <span class="s3">this</span><span class="s1">.identifierPrefix = identifierPrefix;</span>
  <span class="s3">this</span><span class="s1">.onRecoverableError = onRecoverableError;</span>
  <span class="s3">this</span><span class="s1">.passiveEffectDuration = </span><span class="s3">this</span><span class="s1">.effectDuration = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.memoizedUpdaters = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s1">containerInfo = </span><span class="s3">this</span><span class="s1">.pendingUpdatersLaneMap = [];</span>
  <span class="s3">for </span><span class="s1">(tag = </span><span class="s4">0</span><span class="s1">; </span><span class="s4">31 </span><span class="s1">&gt; tag; tag++) containerInfo.push(</span><span class="s3">new </span><span class="s1">Set());</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createPortal(children, containerInfo, implementation) {</span>
  <span class="s3">var </span><span class="s1">key =</span>
    <span class="s4">3 </span><span class="s1">&lt; arguments.length &amp;&amp; </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">!== arguments[</span><span class="s4">3</span><span class="s1">] ? arguments[</span><span class="s4">3</span><span class="s1">] : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">$$typeof: REACT_PORTAL_TYPE,</span>
    <span class="s1">key: </span><span class="s3">null </span><span class="s1">== key ? </span><span class="s3">null </span><span class="s1">: </span><span class="s2">&quot;&quot; </span><span class="s1">+ key,</span>
    <span class="s1">children: children,</span>
    <span class="s1">containerInfo: containerInfo,</span>
    <span class="s1">implementation: implementation</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">findHostInstance(component) {</span>
  <span class="s3">var </span><span class="s1">fiber = component._reactInternals;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">void </span><span class="s4">0 </span><span class="s1">=== fiber) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;function&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">component.render)</span>
      <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Unable to find node on an unmounted component.&quot;</span><span class="s1">);</span>
    <span class="s1">component = Object.keys(component).join(</span><span class="s2">&quot;,&quot;</span><span class="s1">);</span>
    <span class="s3">throw </span><span class="s1">Error(</span>
      <span class="s2">&quot;Argument appears to not be a ReactComponent. Keys: &quot; </span><span class="s1">+ component</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">component = findCurrentHostFiber(fiber);</span>
  <span class="s3">return null </span><span class="s1">=== component ? </span><span class="s3">null </span><span class="s1">: component.stateNode;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateContainer(element, container, parentComponent, callback) {</span>
  <span class="s3">var </span><span class="s1">current = container.current,</span>
    <span class="s1">eventTime = requestEventTime(),</span>
    <span class="s1">lane = requestUpdateLane(current);</span>
  <span class="s1">a: </span><span class="s3">if </span><span class="s1">(parentComponent) {</span>
    <span class="s1">parentComponent = parentComponent._reactInternals;</span>
    <span class="s1">b: {</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">getNearestMountedFiber(parentComponent) !== parentComponent ||</span>
        <span class="s4">1 </span><span class="s1">!== parentComponent.tag</span>
      <span class="s1">)</span>
        <span class="s3">throw </span><span class="s1">Error(</span>
          <span class="s2">&quot;Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
        <span class="s1">);</span>
      <span class="s3">var </span><span class="s1">JSCompiler_inline_result = parentComponent;</span>
      <span class="s3">do </span><span class="s1">{</span>
        <span class="s3">switch </span><span class="s1">(JSCompiler_inline_result.tag) {</span>
          <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
            <span class="s1">JSCompiler_inline_result =</span>
              <span class="s1">JSCompiler_inline_result.stateNode.context;</span>
            <span class="s3">break </span><span class="s1">b;</span>
          <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">(isContextProvider(JSCompiler_inline_result.type)) {</span>
              <span class="s1">JSCompiler_inline_result =</span>
                <span class="s1">JSCompiler_inline_result.stateNode</span>
                  <span class="s1">.__reactInternalMemoizedMergedChildContext;</span>
              <span class="s3">break </span><span class="s1">b;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">JSCompiler_inline_result = JSCompiler_inline_result.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s3">null </span><span class="s1">!== JSCompiler_inline_result);</span>
      <span class="s3">throw </span><span class="s1">Error(</span>
        <span class="s2">&quot;Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">=== parentComponent.tag) {</span>
      <span class="s3">var </span><span class="s1">Component = parentComponent.type;</span>
      <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
        <span class="s1">parentComponent = processChildContext(</span>
          <span class="s1">parentComponent,</span>
          <span class="s1">Component,</span>
          <span class="s1">JSCompiler_inline_result</span>
        <span class="s1">);</span>
        <span class="s3">break </span><span class="s1">a;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">parentComponent = JSCompiler_inline_result;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">parentComponent = emptyContextObject;</span>
  <span class="s3">null </span><span class="s1">=== container.context</span>
    <span class="s1">? (container.context = parentComponent)</span>
    <span class="s1">: (container.pendingContext = parentComponent);</span>
  <span class="s1">container = createUpdate(eventTime, lane);</span>
  <span class="s1">container.payload = { element: element };</span>
  <span class="s1">callback = </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">=== callback ? </span><span class="s3">null </span><span class="s1">: callback;</span>
  <span class="s3">null </span><span class="s1">!== callback &amp;&amp; (container.callback = callback);</span>
  <span class="s1">element = enqueueUpdate(current, container, lane);</span>
  <span class="s3">null </span><span class="s1">!== element &amp;&amp;</span>
    <span class="s1">(scheduleUpdateOnFiber(element, current, lane, eventTime),</span>
    <span class="s1">entangleTransitions(element, current, lane));</span>
  <span class="s3">return </span><span class="s1">lane;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">emptyFindFiberByHostInstance() {</span>
  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">findNodeHandle(componentOrHandle) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">== componentOrHandle) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;number&quot; </span><span class="s1">=== </span><span class="s3">typeof </span><span class="s1">componentOrHandle) </span><span class="s3">return </span><span class="s1">componentOrHandle;</span>
  <span class="s3">if </span><span class="s1">(componentOrHandle._nativeTag) </span><span class="s3">return </span><span class="s1">componentOrHandle._nativeTag;</span>
  <span class="s3">if </span><span class="s1">(componentOrHandle.canonical &amp;&amp; componentOrHandle.canonical._nativeTag)</span>
    <span class="s3">return </span><span class="s1">componentOrHandle.canonical._nativeTag;</span>
  <span class="s1">componentOrHandle = findHostInstance(componentOrHandle);</span>
  <span class="s3">return null </span><span class="s1">== componentOrHandle</span>
    <span class="s1">? componentOrHandle</span>
    <span class="s1">: componentOrHandle.canonical</span>
    <span class="s1">? componentOrHandle.canonical._nativeTag</span>
    <span class="s1">: componentOrHandle._nativeTag;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">onRecoverableError(error) {</span>
  <span class="s1">console.error(error);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">unmountComponentAtNode(containerTag) {</span>
  <span class="s3">var </span><span class="s1">root = roots.get(containerTag);</span>
  <span class="s1">root &amp;&amp;</span>
    <span class="s1">updateContainer(</span><span class="s3">null</span><span class="s1">, root, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">roots.</span><span class="s3">delete</span><span class="s1">(containerTag);</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">batchedUpdatesImpl = </span><span class="s3">function</span><span class="s1">(fn, a) {</span>
  <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
  <span class="s1">executionContext |= </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">try </span><span class="s1">{</span>
    <span class="s3">return </span><span class="s1">fn(a);</span>
  <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
    <span class="s1">(executionContext = prevExecutionContext),</span>
      <span class="s4">0 </span><span class="s1">=== executionContext &amp;&amp;</span>
        <span class="s1">((workInProgressRootRenderTargetTime = now() + </span><span class="s4">500</span><span class="s1">),</span>
        <span class="s1">includesLegacySyncCallbacks &amp;&amp; flushSyncCallbacks());</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s3">var </span><span class="s1">roots = </span><span class="s3">new </span><span class="s1">Map(),</span>
  <span class="s1">devToolsConfig$jscomp$inline_1022 = {</span>
    <span class="s1">findFiberByHostInstance: getInstanceFromTag,</span>
    <span class="s1">bundleType: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">version: </span><span class="s2">&quot;18.2.0-next-9e3b772b8-20220608&quot;</span><span class="s1">,</span>
    <span class="s1">rendererPackageName: </span><span class="s2">&quot;react-native-renderer&quot;</span><span class="s1">,</span>
    <span class="s1">rendererConfig: {</span>
      <span class="s1">getInspectorDataForViewTag: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">throw </span><span class="s1">Error(</span>
          <span class="s2">&quot;getInspectorDataForViewTag() is not available in production&quot;</span>
        <span class="s1">);</span>
      <span class="s1">},</span>
      <span class="s1">getInspectorDataForViewAtPoint: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">throw </span><span class="s1">Error(</span>
          <span class="s2">&quot;getInspectorDataForViewAtPoint() is not available in production.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}.bind(</span><span class="s3">null</span><span class="s1">, findNodeHandle)</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s3">var </span><span class="s1">internals$jscomp$inline_1310 = {</span>
  <span class="s1">bundleType: devToolsConfig$jscomp$inline_1022.bundleType,</span>
  <span class="s1">version: devToolsConfig$jscomp$inline_1022.version,</span>
  <span class="s1">rendererPackageName: devToolsConfig$jscomp$inline_1022.rendererPackageName,</span>
  <span class="s1">rendererConfig: devToolsConfig$jscomp$inline_1022.rendererConfig,</span>
  <span class="s1">overrideHookState: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">overrideHookStateDeletePath: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">overrideHookStateRenamePath: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">overrideProps: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">overridePropsDeletePath: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">overridePropsRenamePath: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">setErrorHandler: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">setSuspenseHandler: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">scheduleUpdate: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">currentDispatcherRef: ReactSharedInternals.ReactCurrentDispatcher,</span>
  <span class="s1">findHostInstanceByFiber: </span><span class="s3">function</span><span class="s1">(fiber) {</span>
    <span class="s1">fiber = findCurrentHostFiber(fiber);</span>
    <span class="s3">return null </span><span class="s1">=== fiber ? </span><span class="s3">null </span><span class="s1">: fiber.stateNode;</span>
  <span class="s1">},</span>
  <span class="s1">findFiberByHostInstance:</span>
    <span class="s1">devToolsConfig$jscomp$inline_1022.findFiberByHostInstance ||</span>
    <span class="s1">emptyFindFiberByHostInstance,</span>
  <span class="s1">findHostInstancesForRefresh: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">scheduleRefresh: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">scheduleRoot: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">setRefreshHandler: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">getCurrentFiber: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">reconcilerVersion: </span><span class="s2">&quot;18.2.0-next-9e3b772b8-20220608&quot;</span>
<span class="s1">};</span>
<span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;undefined&quot; </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__) {</span>
  <span class="s3">var </span><span class="s1">hook$jscomp$inline_1311 = __REACT_DEVTOOLS_GLOBAL_HOOK__;</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">!hook$jscomp$inline_1311.isDisabled &amp;&amp;</span>
    <span class="s1">hook$jscomp$inline_1311.supportsFiber</span>
  <span class="s1">)</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">(rendererID = hook$jscomp$inline_1311.inject(</span>
        <span class="s1">internals$jscomp$inline_1310</span>
      <span class="s1">)),</span>
        <span class="s1">(injectedHook = hook$jscomp$inline_1311);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {}</span>
<span class="s1">}</span>
<span class="s1">exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {</span>
  <span class="s1">computeComponentStackForErrorReporting: </span><span class="s3">function</span><span class="s1">(reactTag) {</span>
    <span class="s3">return </span><span class="s1">(reactTag = getInstanceFromTag(reactTag))</span>
      <span class="s1">? getStackByFiberInDevAndProd(reactTag)</span>
      <span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s1">exports.createPortal = </span><span class="s3">function</span><span class="s1">(children, containerTag) {</span>
  <span class="s3">return </span><span class="s1">createPortal(</span>
    <span class="s1">children,</span>
    <span class="s1">containerTag,</span>
    <span class="s3">null</span><span class="s1">,</span>
    <span class="s4">2 </span><span class="s1">&lt; arguments.length &amp;&amp; </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">!== arguments[</span><span class="s4">2</span><span class="s1">] ? arguments[</span><span class="s4">2</span><span class="s1">] : </span><span class="s3">null</span>
  <span class="s1">);</span>
<span class="s1">};</span>
<span class="s1">exports.dispatchCommand = </span><span class="s3">function</span><span class="s1">(handle, command, args) {</span>
  <span class="s3">null </span><span class="s1">!= handle._nativeTag &amp;&amp;</span>
    <span class="s1">(</span><span class="s3">null </span><span class="s1">!= handle._internalInstanceHandle</span>
      <span class="s1">? ((handle = handle._internalInstanceHandle.stateNode),</span>
        <span class="s3">null </span><span class="s1">!= handle &amp;&amp;</span>
          <span class="s1">nativeFabricUIManager.dispatchCommand(handle.node, command, args))</span>
      <span class="s1">: ReactNativePrivateInterface.UIManager.dispatchViewManagerCommand(</span>
          <span class="s1">handle._nativeTag,</span>
          <span class="s1">command,</span>
          <span class="s1">args</span>
        <span class="s1">));</span>
<span class="s1">};</span>
<span class="s1">exports.findHostInstance_DEPRECATED = </span><span class="s3">function</span><span class="s1">(componentOrHandle) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">null </span><span class="s1">== componentOrHandle) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(componentOrHandle._nativeTag) </span><span class="s3">return </span><span class="s1">componentOrHandle;</span>
  <span class="s3">if </span><span class="s1">(componentOrHandle.canonical &amp;&amp; componentOrHandle.canonical._nativeTag)</span>
    <span class="s3">return </span><span class="s1">componentOrHandle.canonical;</span>
  <span class="s1">componentOrHandle = findHostInstance(componentOrHandle);</span>
  <span class="s3">return null </span><span class="s1">== componentOrHandle</span>
    <span class="s1">? componentOrHandle</span>
    <span class="s1">: componentOrHandle.canonical</span>
    <span class="s1">? componentOrHandle.canonical</span>
    <span class="s1">: componentOrHandle;</span>
<span class="s1">};</span>
<span class="s1">exports.findNodeHandle = findNodeHandle;</span>
<span class="s1">exports.getInspectorDataForInstance = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">exports.render = </span><span class="s3">function</span><span class="s1">(element, containerTag, callback) {</span>
  <span class="s3">var </span><span class="s1">root = roots.get(containerTag);</span>
  <span class="s3">if </span><span class="s1">(!root) {</span>
    <span class="s1">root = </span><span class="s3">new </span><span class="s1">FiberRootNode(containerTag, </span><span class="s4">0</span><span class="s1">, !</span><span class="s4">1</span><span class="s1">, </span><span class="s2">&quot;&quot;</span><span class="s1">, onRecoverableError);</span>
    <span class="s3">var </span><span class="s1">JSCompiler_inline_result = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">isDevToolsPresent &amp;&amp; (JSCompiler_inline_result |= </span><span class="s4">2</span><span class="s1">);</span>
    <span class="s1">JSCompiler_inline_result = createFiber(</span>
      <span class="s4">3</span><span class="s1">,</span>
      <span class="s3">null</span><span class="s1">,</span>
      <span class="s3">null</span><span class="s1">,</span>
      <span class="s1">JSCompiler_inline_result</span>
    <span class="s1">);</span>
    <span class="s1">root.current = JSCompiler_inline_result;</span>
    <span class="s1">JSCompiler_inline_result.stateNode = root;</span>
    <span class="s1">JSCompiler_inline_result.memoizedState = {</span>
      <span class="s1">element: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">isDehydrated: !</span><span class="s4">1</span><span class="s1">,</span>
      <span class="s1">cache: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">transitions: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">pendingSuspenseBoundaries: </span><span class="s3">null</span>
    <span class="s1">};</span>
    <span class="s1">initializeUpdateQueue(JSCompiler_inline_result);</span>
    <span class="s1">roots.set(containerTag, root);</span>
  <span class="s1">}</span>
  <span class="s1">updateContainer(element, root, </span><span class="s3">null</span><span class="s1">, callback);</span>
  <span class="s1">a: </span><span class="s3">if </span><span class="s1">(((element = root.current), element.child))</span>
    <span class="s3">switch </span><span class="s1">(element.child.tag) {</span>
      <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
        <span class="s1">element = element.child.stateNode;</span>
        <span class="s3">break </span><span class="s1">a;</span>
      <span class="s3">default</span><span class="s1">:</span>
        <span class="s1">element = element.child.stateNode;</span>
    <span class="s1">}</span>
  <span class="s3">else </span><span class="s1">element = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">element;</span>
<span class="s1">};</span>
<span class="s1">exports.sendAccessibilityEvent = </span><span class="s3">function</span><span class="s1">(handle, eventType) {</span>
  <span class="s3">null </span><span class="s1">!= handle._nativeTag &amp;&amp;</span>
    <span class="s1">(</span><span class="s3">null </span><span class="s1">!= handle._internalInstanceHandle</span>
      <span class="s1">? ((handle = handle._internalInstanceHandle.stateNode),</span>
        <span class="s3">null </span><span class="s1">!= handle &amp;&amp;</span>
          <span class="s1">nativeFabricUIManager.sendAccessibilityEvent(handle.node, eventType))</span>
      <span class="s1">: ReactNativePrivateInterface.legacySendAccessibilityEvent(</span>
          <span class="s1">handle._nativeTag,</span>
          <span class="s1">eventType</span>
        <span class="s1">));</span>
<span class="s1">};</span>
<span class="s1">exports.unmountComponentAtNode = unmountComponentAtNode;</span>
<span class="s1">exports.unmountComponentAtNodeAndRemoveContainer = </span><span class="s3">function</span><span class="s1">(containerTag) {</span>
  <span class="s1">unmountComponentAtNode(containerTag);</span>
  <span class="s1">ReactNativePrivateInterface.UIManager.removeRootView(containerTag);</span>
<span class="s1">};</span>
<span class="s1">exports.unstable_batchedUpdates = batchedUpdates;</span>

          <span class="s0">/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */</span>
<span class="s3">if </span><span class="s1">(</span>
  <span class="s3">typeof </span><span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__ !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp;</span>
  <span class="s3">typeof </span><span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===</span>
    <span class="s2">'function'</span>
<span class="s1">) {</span>
  <span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(</span><span class="s3">new </span><span class="s1">Error());</span>
<span class="s1">}</span>
        
</pre>
</body>
</html>
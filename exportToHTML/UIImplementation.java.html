<html>
<head>
<title>UIImplementation.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
.s6 { color: #629755; font-weight: bold; font-style: italic;}
.s7 { color: #77b767; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
UIImplementation.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.uimanager</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.os.SystemClock</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.View</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.View.MeasureSpec</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.logging.FLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.infer.annotation.Assertions</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.Arguments</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.Callback</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactApplicationContext</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableArray</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.UiThreadUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.WritableArray</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.ReactConstants</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.build.ReactBuildConfig</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.modules.i18nmanager.I18nUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.debug.NotThreadSafeViewHierarchyUpdateDebugListener</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.events.EventDispatcher</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.systrace.Systrace</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.systrace.SystraceMessage</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaConstants</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaDirection</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Arrays</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Map</span><span class="s2">;</span>

<span class="s3">/**</span>
 <span class="s3">* A class that is used to receive React commands from JS and translate them into a shadow node</span>
 <span class="s3">* hierarchy that is then mapped to a native view hierarchy.</span>
 <span class="s3">*/</span>
<span class="s2">public class </span><span class="s1">UIImplementation {</span>
  <span class="s2">protected </span><span class="s1">Object uiImplementationThreadLock = </span><span class="s2">new </span><span class="s1">Object()</span><span class="s2">;</span>

  <span class="s2">protected final </span><span class="s1">EventDispatcher mEventDispatcher</span><span class="s2">;</span>
  <span class="s2">protected final </span><span class="s1">ReactApplicationContext mReactContext</span><span class="s2">;</span>
  <span class="s2">protected final </span><span class="s1">ShadowNodeRegistry mShadowNodeRegistry = </span><span class="s2">new </span><span class="s1">ShadowNodeRegistry()</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">ViewManagerRegistry mViewManagers</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">UIViewOperationQueue mOperationsQueue</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">NativeViewHierarchyOptimizer mNativeViewHierarchyOptimizer</span><span class="s2">;</span>
  <span class="s2">private final int</span><span class="s1">[] mMeasureBuffer = </span><span class="s2">new int</span><span class="s1">[</span><span class="s4">4</span><span class="s1">]</span><span class="s2">;</span>

  <span class="s2">private long </span><span class="s1">mLastCalculateLayoutTime = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">protected </span><span class="s1">@Nullable LayoutUpdateListener mLayoutUpdateListener</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* When react instance is being shutdown, there could be some pending operations queued in the JS</span>
   <span class="s3">* thread. This flag ensures view related operations are not triggered if the Catalyst instance</span>
   <span class="s3">* was destroyed.</span>
   <span class="s3">*/</span>
  <span class="s2">private volatile boolean </span><span class="s1">mViewOperationsEnabled = </span><span class="s2">true;</span>

  <span class="s3">/** Interface definition for a callback to be invoked when the layout has been updated */</span>
  <span class="s2">public interface </span><span class="s1">LayoutUpdateListener {</span>

    <span class="s3">/** Called when the layout has been updated */</span>
    <span class="s2">void </span><span class="s1">onLayoutUpdated(ReactShadowNode root)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">UIImplementation(</span>
      <span class="s1">ReactApplicationContext reactContext</span><span class="s2">,</span>
      <span class="s1">ViewManagerRegistry viewManagers</span><span class="s2">,</span>
      <span class="s1">EventDispatcher eventDispatcher</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">minTimeLeftInFrameForNonBatchedOperationMs) {</span>
    <span class="s2">this</span><span class="s1">(</span>
        <span class="s1">reactContext</span><span class="s2">,</span>
        <span class="s1">viewManagers</span><span class="s2">,</span>
        <span class="s2">new </span><span class="s1">UIViewOperationQueue(</span>
            <span class="s1">reactContext</span><span class="s2">,</span>
            <span class="s2">new </span><span class="s1">NativeViewHierarchyManager(viewManagers)</span><span class="s2">,</span>
            <span class="s1">minTimeLeftInFrameForNonBatchedOperationMs)</span><span class="s2">,</span>
        <span class="s1">eventDispatcher)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">protected </span><span class="s1">UIImplementation(</span>
      <span class="s1">ReactApplicationContext reactContext</span><span class="s2">,</span>
      <span class="s1">ViewManagerRegistry viewManagers</span><span class="s2">,</span>
      <span class="s1">UIViewOperationQueue operationsQueue</span><span class="s2">,</span>
      <span class="s1">EventDispatcher eventDispatcher) {</span>
    <span class="s1">mReactContext = reactContext</span><span class="s2">;</span>
    <span class="s1">mViewManagers = viewManagers</span><span class="s2">;</span>
    <span class="s1">mOperationsQueue = operationsQueue</span><span class="s2">;</span>
    <span class="s1">mNativeViewHierarchyOptimizer =</span>
        <span class="s2">new </span><span class="s1">NativeViewHierarchyOptimizer(mOperationsQueue</span><span class="s2">, </span><span class="s1">mShadowNodeRegistry)</span><span class="s2">;</span>
    <span class="s1">mEventDispatcher = eventDispatcher</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">protected </span><span class="s1">ReactShadowNode createRootShadowNode() {</span>
    <span class="s1">ReactShadowNode rootCSSNode = </span><span class="s2">new </span><span class="s1">ReactShadowNodeImpl()</span><span class="s2">;</span>
    <span class="s1">I18nUtil sharedI18nUtilInstance = I18nUtil.getInstance()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(sharedI18nUtilInstance.isRTL(mReactContext)) {</span>
      <span class="s1">rootCSSNode.setLayoutDirection(YogaDirection.RTL)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">rootCSSNode.setViewClassName(</span><span class="s5">&quot;Root&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">rootCSSNode</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">protected </span><span class="s1">ReactShadowNode createShadowNode(String className) {</span>
    <span class="s1">ViewManager viewManager = mViewManagers.get(className)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">viewManager.createShadowNodeInstance(mReactContext)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public final </span><span class="s1">ReactShadowNode resolveShadowNode(</span><span class="s2">int </span><span class="s1">reactTag) {</span>
    <span class="s2">return </span><span class="s1">mShadowNodeRegistry.getNode(reactTag)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">protected final </span><span class="s1">@Nullable ViewManager resolveViewManager(String className) {</span>
    <span class="s2">return </span><span class="s1">mViewManagers.getViewManagerIfExists(className)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/*package*/ </span><span class="s1">UIViewOperationQueue getUIViewOperationQueue() {</span>
    <span class="s2">return </span><span class="s1">mOperationsQueue</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Updates the styles of the {</span><span class="s6">@link </span><span class="s3">ReactShadowNode} based on the Measure specs received by</span>
   <span class="s3">* parameters.</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">updateRootView(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, int </span><span class="s1">widthMeasureSpec</span><span class="s2">, int </span><span class="s1">heightMeasureSpec) {</span>
    <span class="s1">ReactShadowNode rootCSSNode = mShadowNodeRegistry.getNode(tag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(rootCSSNode == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">FLog.w(ReactConstants.TAG</span><span class="s2">, </span><span class="s5">&quot;Tried to update non-existent root tag: &quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">updateRootView(rootCSSNode</span><span class="s2">, </span><span class="s1">widthMeasureSpec</span><span class="s2">, </span><span class="s1">heightMeasureSpec)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Updates the styles of the {</span><span class="s6">@link </span><span class="s3">ReactShadowNode} based on the Measure specs received by</span>
   <span class="s3">* parameters.</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">updateRootView(</span>
      <span class="s1">ReactShadowNode rootCSSNode</span><span class="s2">, int </span><span class="s1">widthMeasureSpec</span><span class="s2">, int </span><span class="s1">heightMeasureSpec) {</span>
    <span class="s1">rootCSSNode.setMeasureSpecs(widthMeasureSpec</span><span class="s2">, </span><span class="s1">heightMeasureSpec)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Registers a root node with a given tag, size and ThemedReactContext and adds it to a node</span>
   <span class="s3">* registry.</span>
   <span class="s3">*/</span>
  <span class="s2">public </span><span class="s1">&lt;T </span><span class="s2">extends </span><span class="s1">View&gt; </span><span class="s2">void </span><span class="s1">registerRootView(T rootView</span><span class="s2">, int </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">ThemedReactContext context) {</span>
    <span class="s2">synchronized </span><span class="s1">(uiImplementationThreadLock) {</span>
      <span class="s2">final </span><span class="s1">ReactShadowNode rootCSSNode = createRootShadowNode()</span><span class="s2">;</span>
      <span class="s1">rootCSSNode.setReactTag(tag)</span><span class="s2">; </span><span class="s0">// Thread safety needed here</span>
      <span class="s1">rootCSSNode.setThemedContext(context)</span><span class="s2">;</span>

      <span class="s1">context.runOnNativeModulesQueueThread(</span>
          <span class="s2">new </span><span class="s1">Runnable() {</span>
            <span class="s1">@Override</span>
            <span class="s2">public void </span><span class="s1">run() {</span>
              <span class="s1">mShadowNodeRegistry.addRootNode(rootCSSNode)</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">})</span><span class="s2">;</span>

      <span class="s0">// register it within NativeViewHierarchyManager</span>
      <span class="s1">mOperationsQueue.addRootView(tag</span><span class="s2">, </span><span class="s1">rootView)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** Unregisters a root node with a given tag. */</span>
  <span class="s2">public void </span><span class="s1">removeRootView(</span><span class="s2">int </span><span class="s1">rootViewTag) {</span>
    <span class="s1">removeRootShadowNode(rootViewTag)</span><span class="s2">;</span>
    <span class="s1">mOperationsQueue.enqueueRemoveRootView(rootViewTag)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Return root view num</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">@return </span><span class="s3">The num of root view</span>
   <span class="s3">*/</span>
  <span class="s2">private int </span><span class="s1">getRootViewNum() {</span>
    <span class="s2">return </span><span class="s1">mOperationsQueue.getNativeViewHierarchyManager().getRootViewNum()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Unregisters a root node with a given tag from the shadow node registry */</span>
  <span class="s2">public void </span><span class="s1">removeRootShadowNode(</span><span class="s2">int </span><span class="s1">rootViewTag) {</span>
    <span class="s2">synchronized </span><span class="s1">(uiImplementationThreadLock) {</span>
      <span class="s1">mShadowNodeRegistry.removeRootNode(rootViewTag)</span><span class="s2">; </span><span class="s0">// Thread safety needed here</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Invoked when native view that corresponds to a root node, or acts as a root view (ie. Modals)</span>
   <span class="s3">* has its size changed.</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">updateNodeSize(</span><span class="s2">int </span><span class="s1">nodeViewTag</span><span class="s2">, int </span><span class="s1">newWidth</span><span class="s2">, int </span><span class="s1">newHeight) {</span>
    <span class="s1">ReactShadowNode cssNode = mShadowNodeRegistry.getNode(nodeViewTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(cssNode == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">FLog.w(ReactConstants.TAG</span><span class="s2">, </span><span class="s5">&quot;Tried to update size of non-existent tag: &quot; </span><span class="s1">+ nodeViewTag)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">cssNode.setStyleWidth(newWidth)</span><span class="s2">;</span>
    <span class="s1">cssNode.setStyleHeight(newHeight)</span><span class="s2">;</span>

    <span class="s1">dispatchViewUpdatesIfNeeded()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setViewLocalData(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">Object data) {</span>
    <span class="s1">ReactShadowNode shadowNode = mShadowNodeRegistry.getNode(tag)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(shadowNode == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">FLog.w(ReactConstants.TAG</span><span class="s2">, </span><span class="s5">&quot;Attempt to set local data for view with unknown tag: &quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">shadowNode.setLocalData(data)</span><span class="s2">;</span>

    <span class="s1">dispatchViewUpdatesIfNeeded()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">profileNextBatch() {</span>
    <span class="s1">mOperationsQueue.profileNextBatch()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">Map&lt;String</span><span class="s2">, </span><span class="s1">Long&gt; getProfiledBatchPerfCounters() {</span>
    <span class="s2">return </span><span class="s1">mOperationsQueue.getProfiledBatchPerfCounters()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Invoked by React to create a new node with a given tag, class name and properties. */</span>
  <span class="s2">public void </span><span class="s1">createView(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">String className</span><span class="s2">, int </span><span class="s1">rootViewTag</span><span class="s2">, </span><span class="s1">ReadableMap props) {</span>
    <span class="s2">if </span><span class="s1">(!mViewOperationsEnabled) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">synchronized </span><span class="s1">(uiImplementationThreadLock) {</span>
      <span class="s1">ReactShadowNode cssNode = createShadowNode(className)</span><span class="s2">;</span>
      <span class="s1">ReactShadowNode rootNode = mShadowNodeRegistry.getNode(rootViewTag)</span><span class="s2">;</span>
      <span class="s1">Assertions.assertNotNull(rootNode</span><span class="s2">, </span><span class="s5">&quot;Root node with tag &quot; </span><span class="s1">+ rootViewTag + </span><span class="s5">&quot; doesn't exist&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">cssNode.setReactTag(tag)</span><span class="s2">; </span><span class="s0">// Thread safety needed here</span>
      <span class="s1">cssNode.setViewClassName(className)</span><span class="s2">;</span>
      <span class="s1">cssNode.setRootTag(rootNode.getReactTag())</span><span class="s2">;</span>
      <span class="s1">cssNode.setThemedContext(rootNode.getThemedContext())</span><span class="s2">;</span>

      <span class="s1">mShadowNodeRegistry.addNode(cssNode)</span><span class="s2">;</span>

      <span class="s1">ReactStylesDiffMap styles = </span><span class="s2">null;</span>
      <span class="s2">if </span><span class="s1">(props != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">styles = </span><span class="s2">new </span><span class="s1">ReactStylesDiffMap(props)</span><span class="s2">;</span>
        <span class="s1">cssNode.updateProperties(styles)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">handleCreateView(cssNode</span><span class="s2">, </span><span class="s1">rootViewTag</span><span class="s2">, </span><span class="s1">styles)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">protected void </span><span class="s1">handleCreateView(</span>
      <span class="s1">ReactShadowNode cssNode</span><span class="s2">, int </span><span class="s1">rootViewTag</span><span class="s2">, </span><span class="s1">@Nullable ReactStylesDiffMap styles) {</span>
    <span class="s2">if </span><span class="s1">(!cssNode.isVirtual()) {</span>
      <span class="s1">mNativeViewHierarchyOptimizer.handleCreateView(cssNode</span><span class="s2">, </span><span class="s1">cssNode.getThemedContext()</span><span class="s2">, </span><span class="s1">styles)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** Invoked by React to create a new node with a given tag has its properties changed. */</span>
  <span class="s2">public void </span><span class="s1">updateView(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">String className</span><span class="s2">, </span><span class="s1">ReadableMap props) {</span>
    <span class="s2">if </span><span class="s1">(!mViewOperationsEnabled) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">ViewManager viewManager = mViewManagers.get(className)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(viewManager == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span><span class="s5">&quot;Got unknown view type: &quot; </span><span class="s1">+ className)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">ReactShadowNode cssNode = mShadowNodeRegistry.getNode(tag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(cssNode == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span><span class="s5">&quot;Trying to update non-existent view with tag &quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(props != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">ReactStylesDiffMap styles = </span><span class="s2">new </span><span class="s1">ReactStylesDiffMap(props)</span><span class="s2">;</span>
      <span class="s1">cssNode.updateProperties(styles)</span><span class="s2">;</span>
      <span class="s1">handleUpdateView(cssNode</span><span class="s2">, </span><span class="s1">className</span><span class="s2">, </span><span class="s1">styles)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Used by native animated module to bypass the process of updating the values through the shadow</span>
   <span class="s3">* view hierarchy. This method will directly update native views, which means that updates for</span>
   <span class="s3">* layout-related propertied won't be handled properly. Make sure you know what you're doing</span>
   <span class="s3">* before calling this method :)</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">synchronouslyUpdateViewOnUIThread(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">ReactStylesDiffMap props) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">mOperationsQueue.getNativeViewHierarchyManager().updateProperties(tag</span><span class="s2">, </span><span class="s1">props)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">protected void </span><span class="s1">handleUpdateView(</span>
      <span class="s1">ReactShadowNode cssNode</span><span class="s2">, </span><span class="s1">String className</span><span class="s2">, </span><span class="s1">ReactStylesDiffMap styles) {</span>
    <span class="s2">if </span><span class="s1">(!cssNode.isVirtual()) {</span>
      <span class="s1">mNativeViewHierarchyOptimizer.handleUpdateView(cssNode</span><span class="s2">, </span><span class="s1">className</span><span class="s2">, </span><span class="s1">styles)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Invoked when there is a mutation in a node tree.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">tag react tag of the node we want to manage</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">indicesToRemove ordered (asc) list of indices at which view should be removed</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">viewsToAdd ordered (asc based on mIndex property) list of tag-index pairs that represent</span>
   <span class="s3">*     a view which should be added at the specified index</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">tagsToDelete list of tags corresponding to views that should be removed</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">manageChildren(</span>
      <span class="s2">int </span><span class="s1">viewTag</span><span class="s2">,</span>
      <span class="s1">@Nullable ReadableArray moveFrom</span><span class="s2">,</span>
      <span class="s1">@Nullable ReadableArray moveTo</span><span class="s2">,</span>
      <span class="s1">@Nullable ReadableArray addChildTags</span><span class="s2">,</span>
      <span class="s1">@Nullable ReadableArray addAtIndices</span><span class="s2">,</span>
      <span class="s1">@Nullable ReadableArray removeFrom) {</span>
    <span class="s2">if </span><span class="s1">(!mViewOperationsEnabled) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">synchronized </span><span class="s1">(uiImplementationThreadLock) {</span>
      <span class="s1">ReactShadowNode cssNodeToManage = mShadowNodeRegistry.getNode(viewTag)</span><span class="s2">;</span>

      <span class="s2">int </span><span class="s1">numToMove = moveFrom == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: moveFrom.size()</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">numToAdd = addChildTags == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: addChildTags.size()</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">numToRemove = removeFrom == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: removeFrom.size()</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(numToMove != </span><span class="s4">0 </span><span class="s1">&amp;&amp; (moveTo == </span><span class="s2">null </span><span class="s1">|| numToMove != moveTo.size())) {</span>
        <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span><span class="s5">&quot;Size of moveFrom != size of moveTo!&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(numToAdd != </span><span class="s4">0 </span><span class="s1">&amp;&amp; (addAtIndices == </span><span class="s2">null </span><span class="s1">|| numToAdd != addAtIndices.size())) {</span>
        <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span><span class="s5">&quot;Size of addChildTags != size of addAtIndices!&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">// We treat moves as an add and a delete</span>
      <span class="s1">ViewAtIndex[] viewsToAdd = </span><span class="s2">new </span><span class="s1">ViewAtIndex[numToMove + numToAdd]</span><span class="s2">;</span>
      <span class="s2">int</span><span class="s1">[] indicesToRemove = </span><span class="s2">new int</span><span class="s1">[numToMove + numToRemove]</span><span class="s2">;</span>
      <span class="s2">int</span><span class="s1">[] tagsToRemove = </span><span class="s2">new int</span><span class="s1">[indicesToRemove.length]</span><span class="s2">;</span>
      <span class="s2">int</span><span class="s1">[] tagsToDelete = </span><span class="s2">new int</span><span class="s1">[numToRemove]</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(numToMove &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">Assertions.assertNotNull(moveFrom)</span><span class="s2">;</span>
        <span class="s1">Assertions.assertNotNull(moveTo)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; numToMove</span><span class="s2">; </span><span class="s1">i++) {</span>
          <span class="s2">int </span><span class="s1">moveFromIndex = moveFrom.getInt(i)</span><span class="s2">;</span>
          <span class="s2">int </span><span class="s1">tagToMove = cssNodeToManage.getChildAt(moveFromIndex).getReactTag()</span><span class="s2">;</span>
          <span class="s1">viewsToAdd[i] = </span><span class="s2">new </span><span class="s1">ViewAtIndex(tagToMove</span><span class="s2">, </span><span class="s1">moveTo.getInt(i))</span><span class="s2">;</span>
          <span class="s1">indicesToRemove[i] = moveFromIndex</span><span class="s2">;</span>
          <span class="s1">tagsToRemove[i] = tagToMove</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(numToAdd &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">Assertions.assertNotNull(addChildTags)</span><span class="s2">;</span>
        <span class="s1">Assertions.assertNotNull(addAtIndices)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; numToAdd</span><span class="s2">; </span><span class="s1">i++) {</span>
          <span class="s2">int </span><span class="s1">viewTagToAdd = addChildTags.getInt(i)</span><span class="s2">;</span>
          <span class="s2">int </span><span class="s1">indexToAddAt = addAtIndices.getInt(i)</span><span class="s2">;</span>
          <span class="s1">viewsToAdd[numToMove + i] = </span><span class="s2">new </span><span class="s1">ViewAtIndex(viewTagToAdd</span><span class="s2">, </span><span class="s1">indexToAddAt)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(numToRemove &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">Assertions.assertNotNull(removeFrom)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; numToRemove</span><span class="s2">; </span><span class="s1">i++) {</span>
          <span class="s2">int </span><span class="s1">indexToRemove = removeFrom.getInt(i)</span><span class="s2">;</span>
          <span class="s2">int </span><span class="s1">tagToRemove = cssNodeToManage.getChildAt(indexToRemove).getReactTag()</span><span class="s2">;</span>
          <span class="s1">indicesToRemove[numToMove + i] = indexToRemove</span><span class="s2">;</span>
          <span class="s1">tagsToRemove[numToMove + i] = tagToRemove</span><span class="s2">;</span>
          <span class="s1">tagsToDelete[i] = tagToRemove</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">// NB: moveFrom and removeFrom are both relative to the starting state of the View's children.</span>
      <span class="s0">// moveTo and addAt are both relative to the final state of the View's children.</span>
      <span class="s0">//</span>
      <span class="s0">// 1) Sort the views to add and indices to remove by index</span>
      <span class="s0">// 2) Iterate the indices being removed from high to low and remove them. Going high to low</span>
      <span class="s0">//    makes sure we remove the correct index when there are multiple to remove.</span>
      <span class="s0">// 3) Iterate the views being added by index low to high and add them. Like the view removal,</span>
      <span class="s0">//    iteration direction is important to preserve the correct index.</span>

      <span class="s1">Arrays.sort(viewsToAdd</span><span class="s2">, </span><span class="s1">ViewAtIndex.COMPARATOR)</span><span class="s2">;</span>
      <span class="s1">Arrays.sort(indicesToRemove)</span><span class="s2">;</span>

      <span class="s0">// Apply changes to CSSNodeDEPRECATED hierarchy</span>
      <span class="s2">int </span><span class="s1">lastIndexRemoved = -</span><span class="s4">1</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = indicesToRemove.length - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i--) {</span>
        <span class="s2">int </span><span class="s1">indexToRemove = indicesToRemove[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(indexToRemove == lastIndexRemoved) {</span>
          <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
              <span class="s5">&quot;Repeated indices in Removal list for view tag: &quot; </span><span class="s1">+ viewTag)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">cssNodeToManage.removeChildAt(indicesToRemove[i])</span><span class="s2">; </span><span class="s0">// Thread safety needed here</span>

        <span class="s1">lastIndexRemoved = indicesToRemove[i]</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; viewsToAdd.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">ViewAtIndex viewAtIndex = viewsToAdd[i]</span><span class="s2">;</span>
        <span class="s1">ReactShadowNode cssNodeToAdd = mShadowNodeRegistry.getNode(viewAtIndex.mTag)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(cssNodeToAdd == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
              <span class="s5">&quot;Trying to add unknown view tag: &quot; </span><span class="s1">+ viewAtIndex.mTag)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">cssNodeToManage.addChildAt(cssNodeToAdd</span><span class="s2">, </span><span class="s1">viewAtIndex.mIndex)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">mNativeViewHierarchyOptimizer.handleManageChildren(</span>
          <span class="s1">cssNodeToManage</span><span class="s2">, </span><span class="s1">indicesToRemove</span><span class="s2">, </span><span class="s1">tagsToRemove</span><span class="s2">, </span><span class="s1">viewsToAdd</span><span class="s2">, </span><span class="s1">tagsToDelete)</span><span class="s2">;</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; tagsToDelete.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">removeShadowNode(mShadowNodeRegistry.getNode(tagsToDelete[i]))</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* An optimized version of manageChildren that is used for initial setting of child views. The</span>
   <span class="s3">* children are assumed to be in index order</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">viewTag tag of the parent</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">childrenTags tags of the children</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">setChildren(</span><span class="s2">int </span><span class="s1">viewTag</span><span class="s2">, </span><span class="s1">ReadableArray childrenTags) {</span>
    <span class="s2">if </span><span class="s1">(!mViewOperationsEnabled) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">synchronized </span><span class="s1">(uiImplementationThreadLock) {</span>
      <span class="s1">ReactShadowNode cssNodeToManage = mShadowNodeRegistry.getNode(viewTag)</span><span class="s2">;</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; childrenTags.size()</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">ReactShadowNode cssNodeToAdd = mShadowNodeRegistry.getNode(childrenTags.getInt(i))</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(cssNodeToAdd == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
              <span class="s5">&quot;Trying to add unknown view tag: &quot; </span><span class="s1">+ childrenTags.getInt(i))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">cssNodeToManage.addChildAt(cssNodeToAdd</span><span class="s2">, </span><span class="s1">i)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">mNativeViewHierarchyOptimizer.handleSetChildren(cssNodeToManage</span><span class="s2">, </span><span class="s1">childrenTags)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Replaces the View specified by oldTag with the View specified by newTag within oldTag's parent.</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">replaceExistingNonRootView(</span><span class="s2">int </span><span class="s1">oldTag</span><span class="s2">, int </span><span class="s1">newTag) {</span>
    <span class="s2">if </span><span class="s1">(mShadowNodeRegistry.isRootNode(oldTag) || mShadowNodeRegistry.isRootNode(newTag)) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span><span class="s5">&quot;Trying to add or replace a root tag!&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">ReactShadowNode oldNode = mShadowNodeRegistry.getNode(oldTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(oldNode == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span><span class="s5">&quot;Trying to replace unknown view tag: &quot; </span><span class="s1">+ oldTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">ReactShadowNode parent = oldNode.getParent()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(parent == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span><span class="s5">&quot;Node is not attached to a parent: &quot; </span><span class="s1">+ oldTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">int </span><span class="s1">oldIndex = parent.indexOf(oldNode)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(oldIndex &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalStateException(</span><span class="s5">&quot;Didn't find child tag in parent&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">WritableArray tagsToAdd = Arguments.createArray()</span><span class="s2">;</span>
    <span class="s1">tagsToAdd.pushInt(newTag)</span><span class="s2">;</span>

    <span class="s1">WritableArray addAtIndices = Arguments.createArray()</span><span class="s2">;</span>
    <span class="s1">addAtIndices.pushInt(oldIndex)</span><span class="s2">;</span>

    <span class="s1">WritableArray indicesToRemove = Arguments.createArray()</span><span class="s2">;</span>
    <span class="s1">indicesToRemove.pushInt(oldIndex)</span><span class="s2">;</span>

    <span class="s1">manageChildren(parent.getReactTag()</span><span class="s2">, null, null, </span><span class="s1">tagsToAdd</span><span class="s2">, </span><span class="s1">addAtIndices</span><span class="s2">, </span><span class="s1">indicesToRemove)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Method which takes a container tag and then releases all subviews for that container upon</span>
   <span class="s3">* receipt. TODO: The method name is incorrect and will be renamed, #6033872</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">containerTag the tag of the container for which the subviews must be removed</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">removeSubviewsFromContainerWithID(</span><span class="s2">int </span><span class="s1">containerTag) {</span>
    <span class="s1">ReactShadowNode containerNode = mShadowNodeRegistry.getNode(containerTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(containerNode == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
          <span class="s5">&quot;Trying to remove subviews of an unknown view tag: &quot; </span><span class="s1">+ containerTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">WritableArray indicesToRemove = Arguments.createArray()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">childIndex = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">childIndex &lt; containerNode.getChildCount()</span><span class="s2">; </span><span class="s1">childIndex++) {</span>
      <span class="s1">indicesToRemove.pushInt(childIndex)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">manageChildren(containerTag</span><span class="s2">, null, null, null, null, </span><span class="s1">indicesToRemove)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Find the touch target child native view in the supplied root view hierarchy, given a react</span>
   <span class="s3">* target location.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s7">&lt;p&gt;</span><span class="s3">This method is currently used only by Element Inspector DevTool.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">reactTag the tag of the root view to traverse</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">targetX target X location</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">targetY target Y location</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">callback will be called if with the identified child view react ID, and measurement</span>
   <span class="s3">*     info. If no view was found, callback will be invoked with no data.</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">findSubviewIn(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, float </span><span class="s1">targetX</span><span class="s2">, float </span><span class="s1">targetY</span><span class="s2">, </span><span class="s1">Callback callback) {</span>
    <span class="s1">mOperationsQueue.enqueueFindTargetForTouch(reactTag</span><span class="s2">, </span><span class="s1">targetX</span><span class="s2">, </span><span class="s1">targetY</span><span class="s2">, </span><span class="s1">callback)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Check if the first shadow node is the descendant of the second shadow node</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">@deprecated </span><span class="s3">This method will not be implemented in Fabric.</span>
   <span class="s3">*/</span>
  <span class="s1">@Deprecated</span>
  <span class="s2">public void </span><span class="s1">viewIsDescendantOf(</span>
      <span class="s2">final int </span><span class="s1">reactTag</span><span class="s2">, final int </span><span class="s1">ancestorReactTag</span><span class="s2">, final </span><span class="s1">Callback callback) {</span>
    <span class="s1">ReactShadowNode node = mShadowNodeRegistry.getNode(reactTag)</span><span class="s2">;</span>
    <span class="s1">ReactShadowNode ancestorNode = mShadowNodeRegistry.getNode(ancestorReactTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(node == </span><span class="s2">null </span><span class="s1">|| ancestorNode == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">callback.invoke(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">callback.invoke(node.isDescendantOf(ancestorNode))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Determines the location on screen, width, and height of the given view relative to the root</span>
   <span class="s3">* view and returns the values via an async callback.</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">measure(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">Callback callback) {</span>
    <span class="s2">if </span><span class="s1">(!mViewOperationsEnabled) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s0">// This method is called by the implementation of JS touchable interface (see Touchable.js for</span>
    <span class="s0">// more details) at the moment of touch activation. That is after user starts the gesture from</span>
    <span class="s0">// a touchable view with a given reactTag, or when user drag finger back into the press</span>
    <span class="s0">// activation area of a touchable view that have been activated before.</span>
    <span class="s1">mOperationsQueue.enqueueMeasure(reactTag</span><span class="s2">, </span><span class="s1">callback)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Determines the location on screen, width, and height of the given view relative to the device</span>
   <span class="s3">* screen and returns the values via an async callback. This is the absolute position including</span>
   <span class="s3">* things like the status bar</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">measureInWindow(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">Callback callback) {</span>
    <span class="s2">if </span><span class="s1">(!mViewOperationsEnabled) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">mOperationsQueue.enqueueMeasureInWindow(reactTag</span><span class="s2">, </span><span class="s1">callback)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Measures the view specified by tag relative to the given ancestorTag. This means that the</span>
   <span class="s3">* returned x, y are relative to the origin x, y of the ancestor view. Results are stored in the</span>
   <span class="s3">* given outputBuffer. We allow ancestor view and measured view to be the same, in which case the</span>
   <span class="s3">* position always will be (0, 0) and method will only measure the view dimensions.</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">measureLayout(</span>
      <span class="s2">int </span><span class="s1">tag</span><span class="s2">, int </span><span class="s1">ancestorTag</span><span class="s2">, </span><span class="s1">Callback errorCallback</span><span class="s2">, </span><span class="s1">Callback successCallback) {</span>
    <span class="s2">if </span><span class="s1">(!mViewOperationsEnabled) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">measureLayout(tag</span><span class="s2">, </span><span class="s1">ancestorTag</span><span class="s2">, </span><span class="s1">mMeasureBuffer)</span><span class="s2">;</span>
      <span class="s2">float </span><span class="s1">relativeX = PixelUtil.toDIPFromPixel(mMeasureBuffer[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">;</span>
      <span class="s2">float </span><span class="s1">relativeY = PixelUtil.toDIPFromPixel(mMeasureBuffer[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">;</span>
      <span class="s2">float </span><span class="s1">width = PixelUtil.toDIPFromPixel(mMeasureBuffer[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">;</span>
      <span class="s2">float </span><span class="s1">height = PixelUtil.toDIPFromPixel(mMeasureBuffer[</span><span class="s4">3</span><span class="s1">])</span><span class="s2">;</span>
      <span class="s1">successCallback.invoke(relativeX</span><span class="s2">, </span><span class="s1">relativeY</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(IllegalViewOperationException e) {</span>
      <span class="s1">errorCallback.invoke(e.getMessage())</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Like {</span><span class="s6">@link </span><span class="s3">#measure} and {</span><span class="s6">@link </span><span class="s3">#measureLayout} but measures relative to the immediate parent.</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">measureLayoutRelativeToParent(</span>
      <span class="s2">int </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">Callback errorCallback</span><span class="s2">, </span><span class="s1">Callback successCallback) {</span>
    <span class="s2">if </span><span class="s1">(!mViewOperationsEnabled) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">measureLayoutRelativeToParent(tag</span><span class="s2">, </span><span class="s1">mMeasureBuffer)</span><span class="s2">;</span>
      <span class="s2">float </span><span class="s1">relativeX = PixelUtil.toDIPFromPixel(mMeasureBuffer[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">;</span>
      <span class="s2">float </span><span class="s1">relativeY = PixelUtil.toDIPFromPixel(mMeasureBuffer[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">;</span>
      <span class="s2">float </span><span class="s1">width = PixelUtil.toDIPFromPixel(mMeasureBuffer[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">;</span>
      <span class="s2">float </span><span class="s1">height = PixelUtil.toDIPFromPixel(mMeasureBuffer[</span><span class="s4">3</span><span class="s1">])</span><span class="s2">;</span>
      <span class="s1">successCallback.invoke(relativeX</span><span class="s2">, </span><span class="s1">relativeY</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(IllegalViewOperationException e) {</span>
      <span class="s1">errorCallback.invoke(e.getMessage())</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** Invoked at the end of the transaction to commit any updates to the node hierarchy. */</span>
  <span class="s2">public void </span><span class="s1">dispatchViewUpdates(</span><span class="s2">int </span><span class="s1">batchId) {</span>
    <span class="s2">if </span><span class="s1">(getRootViewNum() &lt;= </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s0">// If there are no RootViews registered, there will be no View updates to dispatch.</span>
      <span class="s0">// This is a hack to prevent this from being called when Fabric is used everywhere.</span>
      <span class="s0">// This should no longer be necessary in Bridgeless Mode.</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">SystraceMessage.beginSection(</span>
            <span class="s1">Systrace.TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s5">&quot;UIImplementation.dispatchViewUpdates&quot;</span><span class="s1">)</span>
        <span class="s1">.arg(</span><span class="s5">&quot;batchId&quot;</span><span class="s2">, </span><span class="s1">batchId)</span>
        <span class="s1">.flush()</span><span class="s2">;</span>
    <span class="s2">final long </span><span class="s1">commitStartTime = SystemClock.uptimeMillis()</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">updateViewHierarchy()</span><span class="s2">;</span>
      <span class="s1">mNativeViewHierarchyOptimizer.onBatchComplete()</span><span class="s2">;</span>
      <span class="s1">mOperationsQueue.dispatchViewUpdates(batchId</span><span class="s2">, </span><span class="s1">commitStartTime</span><span class="s2">, </span><span class="s1">mLastCalculateLayoutTime)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">Systrace.endSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">dispatchViewUpdatesIfNeeded() {</span>
    <span class="s0">// If we are in the middle of a batch update, any additional changes</span>
    <span class="s0">// will automatically be dispatched at the end of the batch.</span>
    <span class="s0">// If we are not, we have to initiate new batch update.</span>
    <span class="s0">// As all batches are executed as a single runnable on the event queue</span>
    <span class="s0">// this should always be empty, but that calling architecture is an implementation detail.</span>
    <span class="s2">if </span><span class="s1">(mOperationsQueue.isEmpty()) {</span>
      <span class="s1">dispatchViewUpdates(-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">; </span><span class="s0">// &quot;-1&quot; means &quot;no associated batch id&quot;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">protected void </span><span class="s1">updateViewHierarchy() {</span>
    <span class="s1">Systrace.beginSection(</span>
        <span class="s1">Systrace.TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s5">&quot;UIImplementation.updateViewHierarchy&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; mShadowNodeRegistry.getRootNodeCount()</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">int </span><span class="s1">tag = mShadowNodeRegistry.getRootTag(i)</span><span class="s2">;</span>
        <span class="s1">ReactShadowNode cssRoot = mShadowNodeRegistry.getNode(tag)</span><span class="s2">;</span>

        <span class="s2">if </span><span class="s1">(cssRoot.getWidthMeasureSpec() != </span><span class="s2">null </span><span class="s1">&amp;&amp; cssRoot.getHeightMeasureSpec() != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">SystraceMessage.beginSection(</span>
                  <span class="s1">Systrace.TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">,</span>
                  <span class="s5">&quot;UIImplementation.notifyOnBeforeLayoutRecursive&quot;</span><span class="s1">)</span>
              <span class="s1">.arg(</span><span class="s5">&quot;rootTag&quot;</span><span class="s2">, </span><span class="s1">cssRoot.getReactTag())</span>
              <span class="s1">.flush()</span><span class="s2">;</span>
          <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">notifyOnBeforeLayoutRecursive(cssRoot)</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
            <span class="s1">Systrace.endSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
          <span class="s1">}</span>

          <span class="s1">calculateRootLayout(cssRoot)</span><span class="s2">;</span>
          <span class="s1">SystraceMessage.beginSection(</span>
                  <span class="s1">Systrace.TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s5">&quot;UIImplementation.applyUpdatesRecursive&quot;</span><span class="s1">)</span>
              <span class="s1">.arg(</span><span class="s5">&quot;rootTag&quot;</span><span class="s2">, </span><span class="s1">cssRoot.getReactTag())</span>
              <span class="s1">.flush()</span><span class="s2">;</span>
          <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">applyUpdatesRecursive(cssRoot</span><span class="s2">, </span><span class="s4">0f</span><span class="s2">, </span><span class="s4">0f</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
            <span class="s1">Systrace.endSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(mLayoutUpdateListener != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">mOperationsQueue.enqueueLayoutUpdateFinished(cssRoot</span><span class="s2">, </span><span class="s1">mLayoutUpdateListener)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">Systrace.endSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* LayoutAnimation API on Android is currently experimental. Therefore, it needs to be enabled</span>
   <span class="s3">* explicitly in order to avoid regression in existing application written for iOS using this API.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s7">&lt;p&gt;</span><span class="s3">Warning : This method will be removed in future version of React Native, and layout</span>
   <span class="s3">* animation will be enabled by default, so always check for its existence before invoking it.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s7">&lt;p&gt;</span><span class="s3">TODO(9139831) : remove this method once layout animation is fully stable.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">enabled whether layout animation is enabled or not</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">setLayoutAnimationEnabledExperimental(</span><span class="s2">boolean </span><span class="s1">enabled) {</span>
    <span class="s1">mOperationsQueue.enqueueSetLayoutAnimationEnabled(enabled)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Configure an animation to be used for the native layout changes, and native views creation. The</span>
   <span class="s3">* animation will only apply during the current batch operations.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s7">&lt;p&gt;</span><span class="s3">TODO(7728153) : animating view deletion is currently not supported. TODO(7613721) :</span>
   <span class="s3">* callbacks are not supported, this feature will likely be killed.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">config the configuration of the animation for view addition/removal/update.</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">success will be called when the animation completes, or when the animation get</span>
   <span class="s3">*     interrupted. In this case, callback parameter will be false.</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">error will be called if there was an error processing the animation</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">configureNextLayoutAnimation(ReadableMap config</span><span class="s2">, </span><span class="s1">Callback success) {</span>
    <span class="s1">mOperationsQueue.enqueueConfigureLayoutAnimation(config</span><span class="s2">, </span><span class="s1">success)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setJSResponder(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, boolean </span><span class="s1">blockNativeResponder) {</span>
    <span class="s1">ReactShadowNode node = mShadowNodeRegistry.getNode(reactTag)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(node == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// TODO: this should only happen when using Fabric renderer. This is a temporary approach</span>
      <span class="s0">// and it will be refactored when fabric supports JS Responder.</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">while </span><span class="s1">(node.getNativeKind() == NativeKind.NONE) {</span>
      <span class="s1">node = node.getParent()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mOperationsQueue.enqueueSetJSResponder(node.getReactTag()</span><span class="s2">, </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">blockNativeResponder)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">clearJSResponder() {</span>
    <span class="s1">mOperationsQueue.enqueueClearJSResponder()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Deprecated</span>
  <span class="s2">public void </span><span class="s1">dispatchViewManagerCommand(</span>
      <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, int </span><span class="s1">commandId</span><span class="s2">, </span><span class="s1">@Nullable ReadableArray commandArgs) {</span>
    <span class="s2">boolean </span><span class="s1">viewExists =</span>
        <span class="s1">checkOrAssertViewExists(reactTag</span><span class="s2">, </span><span class="s5">&quot;dispatchViewManagerCommand: &quot; </span><span class="s1">+ commandId)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!viewExists) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">mOperationsQueue.enqueueDispatchCommand(reactTag</span><span class="s2">, </span><span class="s1">commandId</span><span class="s2">, </span><span class="s1">commandArgs)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">dispatchViewManagerCommand(</span>
      <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">String commandId</span><span class="s2">, </span><span class="s1">@Nullable ReadableArray commandArgs) {</span>
    <span class="s2">boolean </span><span class="s1">viewExists =</span>
        <span class="s1">checkOrAssertViewExists(reactTag</span><span class="s2">, </span><span class="s5">&quot;dispatchViewManagerCommand: &quot; </span><span class="s1">+ commandId)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!viewExists) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">mOperationsQueue.enqueueDispatchCommand(reactTag</span><span class="s2">, </span><span class="s1">commandId</span><span class="s2">, </span><span class="s1">commandArgs)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Show a PopupMenu.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">reactTag the tag of the anchor view (the PopupMenu is displayed next to this view); this</span>
   <span class="s3">*     needs to be the tag of a native view (shadow views can not be anchors)</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">items the menu items as an array of strings</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">error will be called if there is an error displaying the menu</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">success will be called with the position of the selected item as the first argument, or</span>
   <span class="s3">*     no arguments if the menu is dismissed</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">showPopupMenu(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">ReadableArray items</span><span class="s2">, </span><span class="s1">Callback error</span><span class="s2">, </span><span class="s1">Callback success) {</span>
    <span class="s2">boolean </span><span class="s1">viewExists = checkOrAssertViewExists(reactTag</span><span class="s2">, </span><span class="s5">&quot;showPopupMenu&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!viewExists) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">mOperationsQueue.enqueueShowPopupMenu(reactTag</span><span class="s2">, </span><span class="s1">items</span><span class="s2">, </span><span class="s1">error</span><span class="s2">, </span><span class="s1">success)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">dismissPopupMenu() {</span>
    <span class="s1">mOperationsQueue.enqueueDismissPopupMenu()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">sendAccessibilityEvent(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, int </span><span class="s1">eventType) {</span>
    <span class="s1">mOperationsQueue.enqueueSendAccessibilityEvent(tag</span><span class="s2">, </span><span class="s1">eventType)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">onHostResume() {</span>
    <span class="s1">mOperationsQueue.resumeFrameCallback()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">onHostPause() {</span>
    <span class="s1">mOperationsQueue.pauseFrameCallback()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">onHostDestroy() {}</span>

  <span class="s2">public void </span><span class="s1">onCatalystInstanceDestroyed() {</span>
    <span class="s1">mViewOperationsEnabled = </span><span class="s2">false;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setViewHierarchyUpdateDebugListener(</span>
      <span class="s1">@Nullable NotThreadSafeViewHierarchyUpdateDebugListener listener) {</span>
    <span class="s1">mOperationsQueue.setViewHierarchyUpdateDebugListener(listener)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">protected final void </span><span class="s1">removeShadowNode(ReactShadowNode nodeToRemove) {</span>
    <span class="s1">removeShadowNodeRecursive(nodeToRemove)</span><span class="s2">;</span>
    <span class="s1">nodeToRemove.dispose()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">removeShadowNodeRecursive(ReactShadowNode nodeToRemove) {</span>
    <span class="s1">NativeViewHierarchyOptimizer.handleRemoveNode(nodeToRemove)</span><span class="s2">;</span>
    <span class="s1">mShadowNodeRegistry.removeNode(nodeToRemove.getReactTag())</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = nodeToRemove.getChildCount() - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i--) {</span>
      <span class="s1">removeShadowNodeRecursive(nodeToRemove.getChildAt(i))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">nodeToRemove.removeAndDisposeAllChildren()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">measureLayout(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, int </span><span class="s1">ancestorTag</span><span class="s2">, int</span><span class="s1">[] outputBuffer) {</span>
    <span class="s1">ReactShadowNode node = mShadowNodeRegistry.getNode(tag)</span><span class="s2">;</span>
    <span class="s1">ReactShadowNode ancestor = mShadowNodeRegistry.getNode(ancestorTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(node == </span><span class="s2">null </span><span class="s1">|| ancestor == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
          <span class="s5">&quot;Tag &quot; </span><span class="s1">+ (node == </span><span class="s2">null </span><span class="s1">? tag : ancestorTag) + </span><span class="s5">&quot; does not exist&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(node != ancestor) {</span>
      <span class="s1">ReactShadowNode currentParent = node.getParent()</span><span class="s2">;</span>
      <span class="s2">while </span><span class="s1">(currentParent != ancestor) {</span>
        <span class="s2">if </span><span class="s1">(currentParent == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
              <span class="s5">&quot;Tag &quot; </span><span class="s1">+ ancestorTag + </span><span class="s5">&quot; is not an ancestor of tag &quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">currentParent = currentParent.getParent()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">measureLayoutRelativeToVerifiedAncestor(node</span><span class="s2">, </span><span class="s1">ancestor</span><span class="s2">, </span><span class="s1">outputBuffer)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">measureLayoutRelativeToParent(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, int</span><span class="s1">[] outputBuffer) {</span>
    <span class="s1">ReactShadowNode node = mShadowNodeRegistry.getNode(tag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(node == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span><span class="s5">&quot;No native view for tag &quot; </span><span class="s1">+ tag + </span><span class="s5">&quot; exists!&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">ReactShadowNode parent = node.getParent()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(parent == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span><span class="s5">&quot;View with tag &quot; </span><span class="s1">+ tag + </span><span class="s5">&quot; doesn't have a parent!&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">measureLayoutRelativeToVerifiedAncestor(node</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">outputBuffer)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">measureLayoutRelativeToVerifiedAncestor(</span>
      <span class="s1">ReactShadowNode node</span><span class="s2">, </span><span class="s1">ReactShadowNode ancestor</span><span class="s2">, int</span><span class="s1">[] outputBuffer) {</span>
    <span class="s2">int </span><span class="s1">offsetX = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">offsetY = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(node != ancestor &amp;&amp; !node.isVirtual()) {</span>
      <span class="s1">offsetX = Math.round(node.getLayoutX())</span><span class="s2">;</span>
      <span class="s1">offsetY = Math.round(node.getLayoutY())</span><span class="s2">;</span>
      <span class="s1">ReactShadowNode current = node.getParent()</span><span class="s2">;</span>
      <span class="s2">while </span><span class="s1">(current != ancestor) {</span>
        <span class="s1">Assertions.assertNotNull(current)</span><span class="s2">;</span>
        <span class="s1">assertNodeDoesNotNeedCustomLayoutForChildren(current)</span><span class="s2">;</span>
        <span class="s1">offsetX += Math.round(current.getLayoutX())</span><span class="s2">;</span>
        <span class="s1">offsetY += Math.round(current.getLayoutY())</span><span class="s2">;</span>
        <span class="s1">current = current.getParent()</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">assertNodeDoesNotNeedCustomLayoutForChildren(ancestor)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">outputBuffer[</span><span class="s4">0</span><span class="s1">] = offsetX</span><span class="s2">;</span>
    <span class="s1">outputBuffer[</span><span class="s4">1</span><span class="s1">] = offsetY</span><span class="s2">;</span>
    <span class="s1">outputBuffer[</span><span class="s4">2</span><span class="s1">] = node.getScreenWidth()</span><span class="s2">;</span>
    <span class="s1">outputBuffer[</span><span class="s4">3</span><span class="s1">] = node.getScreenHeight()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Returns whether a view identified by the tag exists. In debug mode, this will throw whenever</span>
   <span class="s3">* the view doesn't exist. In production, it'll log a warning. Callers should use this and just</span>
   <span class="s3">* return if the view doesn't exist to avoid crashing.</span>
   <span class="s3">*/</span>
  <span class="s2">private boolean </span><span class="s1">checkOrAssertViewExists(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">String operationNameForExceptionMessage) {</span>
    <span class="s2">boolean </span><span class="s1">viewExists = mShadowNodeRegistry.getNode(reactTag) != </span><span class="s2">null;</span>
    <span class="s2">if </span><span class="s1">(viewExists) {</span>
      <span class="s2">return true;</span>
    <span class="s1">}</span>

    <span class="s1">String message =</span>
        <span class="s5">&quot;Unable to execute operation &quot;</span>
            <span class="s1">+ operationNameForExceptionMessage</span>
            <span class="s1">+ </span><span class="s5">&quot; on view with &quot;</span>
            <span class="s1">+ </span><span class="s5">&quot;tag: &quot;</span>
            <span class="s1">+ reactTag</span>
            <span class="s1">+ </span><span class="s5">&quot;, since the view does not exist&quot;</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(ReactBuildConfig.DEBUG) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(message)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">FLog.w(ReactConstants.TAG</span><span class="s2">, </span><span class="s1">message)</span><span class="s2">;</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">assertNodeDoesNotNeedCustomLayoutForChildren(ReactShadowNode node) {</span>
    <span class="s1">ViewManager viewManager = Assertions.assertNotNull(mViewManagers.get(node.getViewClass()))</span><span class="s2">;</span>
    <span class="s1">IViewManagerWithChildren viewManagerWithChildren</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(viewManager </span><span class="s2">instanceof </span><span class="s1">IViewManagerWithChildren) {</span>
      <span class="s1">viewManagerWithChildren = (IViewManagerWithChildren) viewManager</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
          <span class="s5">&quot;Trying to use view &quot;</span>
              <span class="s1">+ node.getViewClass()</span>
              <span class="s1">+ </span><span class="s5">&quot; as a parent, but its Manager doesn't extends ViewGroupManager&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(viewManagerWithChildren != </span><span class="s2">null </span><span class="s1">&amp;&amp; viewManagerWithChildren.needsCustomLayoutForChildren()) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
          <span class="s5">&quot;Trying to measure a view using measureLayout/measureLayoutRelativeToParent relative to&quot;</span>
              <span class="s1">+ </span><span class="s5">&quot; an ancestor that requires custom layout for it's children (&quot;</span>
              <span class="s1">+ node.getViewClass()</span>
              <span class="s1">+ </span><span class="s5">&quot;). Use measure instead.&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">notifyOnBeforeLayoutRecursive(ReactShadowNode cssNode) {</span>
    <span class="s2">if </span><span class="s1">(!cssNode.hasUpdates()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; cssNode.getChildCount()</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">notifyOnBeforeLayoutRecursive(cssNode.getChildAt(i))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">cssNode.onBeforeLayout(mNativeViewHierarchyOptimizer)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">protected void </span><span class="s1">calculateRootLayout(ReactShadowNode cssRoot) {</span>
    <span class="s1">SystraceMessage.beginSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s5">&quot;cssRoot.calculateLayout&quot;</span><span class="s1">)</span>
        <span class="s1">.arg(</span><span class="s5">&quot;rootTag&quot;</span><span class="s2">, </span><span class="s1">cssRoot.getReactTag())</span>
        <span class="s1">.flush()</span><span class="s2">;</span>
    <span class="s2">long </span><span class="s1">startTime = SystemClock.uptimeMillis()</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">int </span><span class="s1">widthSpec = cssRoot.getWidthMeasureSpec()</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">heightSpec = cssRoot.getHeightMeasureSpec()</span><span class="s2">;</span>
      <span class="s1">cssRoot.calculateLayout(</span>
          <span class="s1">MeasureSpec.getMode(widthSpec) == MeasureSpec.UNSPECIFIED</span>
              <span class="s1">? YogaConstants.UNDEFINED</span>
              <span class="s1">: MeasureSpec.getSize(widthSpec)</span><span class="s2">,</span>
          <span class="s1">MeasureSpec.getMode(heightSpec) == MeasureSpec.UNSPECIFIED</span>
              <span class="s1">? YogaConstants.UNDEFINED</span>
              <span class="s1">: MeasureSpec.getSize(heightSpec))</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">Systrace.endSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
      <span class="s1">mLastCalculateLayoutTime = SystemClock.uptimeMillis() - startTime</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">protected void </span><span class="s1">applyUpdatesRecursive(ReactShadowNode cssNode</span><span class="s2">, float </span><span class="s1">absoluteX</span><span class="s2">, float </span><span class="s1">absoluteY) {</span>
    <span class="s2">if </span><span class="s1">(!cssNode.hasUpdates()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">Iterable&lt;? </span><span class="s2">extends </span><span class="s1">ReactShadowNode&gt; cssChildren = cssNode.calculateLayoutOnChildren()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(cssChildren != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">for </span><span class="s1">(ReactShadowNode cssChild : cssChildren) {</span>
        <span class="s1">applyUpdatesRecursive(</span>
            <span class="s1">cssChild</span><span class="s2">, </span><span class="s1">absoluteX + cssNode.getLayoutX()</span><span class="s2">, </span><span class="s1">absoluteY + cssNode.getLayoutY())</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">int </span><span class="s1">tag = cssNode.getReactTag()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!mShadowNodeRegistry.isRootNode(tag)) {</span>
      <span class="s2">boolean </span><span class="s1">frameDidChange =</span>
          <span class="s1">cssNode.dispatchUpdates(</span>
              <span class="s1">absoluteX</span><span class="s2">, </span><span class="s1">absoluteY</span><span class="s2">, </span><span class="s1">mOperationsQueue</span><span class="s2">, </span><span class="s1">mNativeViewHierarchyOptimizer)</span><span class="s2">;</span>

      <span class="s0">// Notify JS about layout event if requested</span>
      <span class="s0">// and if the position or dimensions actually changed</span>
      <span class="s0">// (consistent with iOS).</span>
      <span class="s2">if </span><span class="s1">(frameDidChange &amp;&amp; cssNode.shouldNotifyOnLayout()) {</span>
        <span class="s1">mEventDispatcher.dispatchEvent(</span>
            <span class="s1">OnLayoutEvent.obtain(</span>
                <span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s0">/* surfaceId not used in classic renderer */</span>
                <span class="s1">tag</span><span class="s2">,</span>
                <span class="s1">cssNode.getScreenX()</span><span class="s2">,</span>
                <span class="s1">cssNode.getScreenY()</span><span class="s2">,</span>
                <span class="s1">cssNode.getScreenWidth()</span><span class="s2">,</span>
                <span class="s1">cssNode.getScreenHeight()))</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">cssNode.markUpdateSeen()</span><span class="s2">;</span>
    <span class="s1">mNativeViewHierarchyOptimizer.onViewUpdatesCompleted(cssNode)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">addUIBlock(UIBlock block) {</span>
    <span class="s1">mOperationsQueue.enqueueUIBlock(block)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">prependUIBlock(UIBlock block) {</span>
    <span class="s1">mOperationsQueue.prependUIBlock(block)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public int </span><span class="s1">resolveRootTagFromReactTag(</span><span class="s2">int </span><span class="s1">reactTag) {</span>
    <span class="s2">if </span><span class="s1">(mShadowNodeRegistry.isRootNode(reactTag)) {</span>
      <span class="s2">return </span><span class="s1">reactTag</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">ReactShadowNode node = resolveShadowNode(reactTag)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">rootTag = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(node != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">rootTag = node.getRootTag()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">FLog.w(</span>
          <span class="s1">ReactConstants.TAG</span><span class="s2">,</span>
          <span class="s5">&quot;Warning : attempted to resolve a non-existent react shadow node. reactTag=&quot; </span><span class="s1">+ reactTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">rootTag</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setLayoutUpdateListener(LayoutUpdateListener listener) {</span>
    <span class="s1">mLayoutUpdateListener = listener</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">removeLayoutUpdateListener() {</span>
    <span class="s1">mLayoutUpdateListener = </span><span class="s2">null;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
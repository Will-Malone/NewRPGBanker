<html>
<head>
<title>ReactTextView.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6a8759;}
.s6 { color: #629755; font-weight: bold; font-style: italic;}
.s7 { color: #77b767; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ReactTextView.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.views.text</span><span class="s2">;</span>

<span class="s2">import static </span><span class="s1">com.facebook.react.views.text.TextAttributeProps.UNSET</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.content.Context</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.drawable.Drawable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.os.Build</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.Layout</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.Spannable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.Spanned</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.TextUtils</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.method.LinkMovementMethod</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.util.Linkify</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.Gravity</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.MotionEvent</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.View</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.ViewGroup</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.appcompat.widget.AppCompatTextView</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.appcompat.widget.TintContextWrapper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.core.view.AccessibilityDelegateCompat</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.core.view.ViewCompat</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.customview.widget.ExploreByTouchHelper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.logging.FLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.infer.annotation.Assertions</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.Arguments</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactContext</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.WritableArray</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.WritableMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.ReactConstants</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.PixelUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactCompoundView</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.UIManagerModule</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ViewDefaults</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.common.UIManagerType</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.common.ViewUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.view.ReactViewBackgroundManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.ArrayList</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Collections</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Comparator</span><span class="s2">;</span>

<span class="s2">public class </span><span class="s1">ReactTextView </span><span class="s2">extends </span><span class="s1">AppCompatTextView </span><span class="s2">implements </span><span class="s1">ReactCompoundView {</span>

  <span class="s2">private static final </span><span class="s1">ViewGroup.LayoutParams EMPTY_LAYOUT_PARAMS =</span>
      <span class="s2">new </span><span class="s1">ViewGroup.LayoutParams(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">;</span>

  <span class="s2">private boolean </span><span class="s1">mContainsImages</span><span class="s2">;</span>
  <span class="s2">private final int </span><span class="s1">mDefaultGravityHorizontal</span><span class="s2">;</span>
  <span class="s2">private final int </span><span class="s1">mDefaultGravityVertical</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mNumberOfLines</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">TextUtils.TruncateAt mEllipsizeLocation</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mAdjustsFontSizeToFit</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mLinkifyMaskType</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mNotifyOnInlineViewLayout</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mTextIsSelectable</span><span class="s2">;</span>

  <span class="s2">private </span><span class="s1">ReactViewBackgroundManager mReactBackgroundManager</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">Spannable mSpanned</span><span class="s2">;</span>

  <span class="s2">public </span><span class="s1">ReactTextView(Context context) {</span>
    <span class="s2">super</span><span class="s1">(context)</span><span class="s2">;</span>

    <span class="s0">// Get these defaults only during the constructor - these should never be set otherwise</span>
    <span class="s1">mDefaultGravityHorizontal = getGravityHorizontal()</span><span class="s2">;</span>
    <span class="s1">mDefaultGravityVertical = getGravity() &amp; Gravity.VERTICAL_GRAVITY_MASK</span><span class="s2">;</span>

    <span class="s1">initView()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Set all default values here as opposed to in the constructor or field defaults. It is important</span>
   <span class="s4">* that these properties are set during the constructor, but also on-demand whenever an existing</span>
   <span class="s4">* ReactTextView is recycled.</span>
   <span class="s4">*/</span>
  <span class="s2">private void </span><span class="s1">initView() {</span>
    <span class="s2">if </span><span class="s1">(mReactBackgroundManager != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// make sure old background manager doesn't have any references back to this View</span>
      <span class="s1">mReactBackgroundManager.cleanup()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">mReactBackgroundManager = </span><span class="s2">new </span><span class="s1">ReactViewBackgroundManager(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s1">mNumberOfLines = ViewDefaults.NUMBER_OF_LINES</span><span class="s2">;</span>
    <span class="s1">mAdjustsFontSizeToFit = </span><span class="s2">false;</span>
    <span class="s1">mLinkifyMaskType = </span><span class="s3">0</span><span class="s2">;</span>
    <span class="s1">mNotifyOnInlineViewLayout = </span><span class="s2">false;</span>
    <span class="s1">mTextIsSelectable = </span><span class="s2">false;</span>
    <span class="s1">mEllipsizeLocation = TextUtils.TruncateAt.END</span><span class="s2">;</span>

    <span class="s1">mSpanned = </span><span class="s2">null;</span>
  <span class="s1">}</span>

  <span class="s0">/* package */ </span><span class="s2">void </span><span class="s1">recycleView() {</span>
    <span class="s0">// Set default field values</span>
    <span class="s1">initView()</span><span class="s2">;</span>

    <span class="s0">// Defaults for these fields:</span>
    <span class="s0">// https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/widget/TextView.java#L1061</span>
    <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {</span>
      <span class="s1">setBreakStrategy(Layout.BREAK_STRATEGY_SIMPLE)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">setMovementMethod(getDefaultMovementMethod())</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {</span>
      <span class="s1">setJustificationMode(Layout.JUSTIFICATION_MODE_NONE)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// reset text</span>
    <span class="s1">setLayoutParams(EMPTY_LAYOUT_PARAMS)</span><span class="s2">;</span>
    <span class="s2">super</span><span class="s1">.setText(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s0">// Call setters to ensure that any super setters are called</span>
    <span class="s1">setGravityHorizontal(mDefaultGravityHorizontal)</span><span class="s2">;</span>
    <span class="s1">setGravityVertical(mDefaultGravityVertical)</span><span class="s2">;</span>
    <span class="s1">setNumberOfLines(mNumberOfLines)</span><span class="s2">;</span>
    <span class="s1">setAdjustFontSizeToFit(mAdjustsFontSizeToFit)</span><span class="s2">;</span>
    <span class="s1">setLinkifyMask(mLinkifyMaskType)</span><span class="s2">;</span>
    <span class="s1">setTextIsSelectable(mTextIsSelectable)</span><span class="s2">;</span>

    <span class="s0">// Default true:</span>
    <span class="s0">// https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/widget/TextView.java#L9347</span>
    <span class="s1">setIncludeFontPadding(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">setEnabled(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s0">// reset data detectors</span>
    <span class="s1">setLinkifyMask(</span><span class="s3">0</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s1">setEllipsizeLocation(mEllipsizeLocation)</span><span class="s2">;</span>

    <span class="s0">// View flags - defaults are here:</span>
    <span class="s0">// https://android.googlesource.com/platform/frameworks/base/+/98e54bb941cb6feb07127b75da37833281951d52/core/java/android/view/View.java#5311</span>
    <span class="s0">//         mViewFlags = SOUND_EFFECTS_ENABLED | HAPTIC_FEEDBACK_ENABLED |</span>
    <span class="s0">// LAYOUT_DIRECTION_INHERIT;</span>
    <span class="s1">setEnabled(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {</span>
      <span class="s1">setFocusable(View.FOCUSABLE_AUTO)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {</span>
      <span class="s1">setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_NONE)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">updateView()</span><span class="s2">; </span><span class="s0">// call after changing ellipsizeLocation in particular</span>
  <span class="s1">}</span>

  <span class="s2">private static </span><span class="s1">WritableMap inlineViewJson(</span>
      <span class="s2">int </span><span class="s1">visibility</span><span class="s2">, int </span><span class="s1">index</span><span class="s2">, int </span><span class="s1">left</span><span class="s2">, int </span><span class="s1">top</span><span class="s2">, int </span><span class="s1">right</span><span class="s2">, int </span><span class="s1">bottom) {</span>
    <span class="s1">WritableMap json = Arguments.createMap()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(visibility == View.GONE) {</span>
      <span class="s1">json.putString(</span><span class="s5">&quot;visibility&quot;</span><span class="s2">, </span><span class="s5">&quot;gone&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">json.putInt(</span><span class="s5">&quot;index&quot;</span><span class="s2">, </span><span class="s1">index)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(visibility == View.VISIBLE) {</span>
      <span class="s1">json.putString(</span><span class="s5">&quot;visibility&quot;</span><span class="s2">, </span><span class="s5">&quot;visible&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">json.putInt(</span><span class="s5">&quot;index&quot;</span><span class="s2">, </span><span class="s1">index)</span><span class="s2">;</span>
      <span class="s1">json.putDouble(</span><span class="s5">&quot;left&quot;</span><span class="s2">, </span><span class="s1">PixelUtil.toDIPFromPixel(left))</span><span class="s2">;</span>
      <span class="s1">json.putDouble(</span><span class="s5">&quot;top&quot;</span><span class="s2">, </span><span class="s1">PixelUtil.toDIPFromPixel(top))</span><span class="s2">;</span>
      <span class="s1">json.putDouble(</span><span class="s5">&quot;right&quot;</span><span class="s2">, </span><span class="s1">PixelUtil.toDIPFromPixel(right))</span><span class="s2">;</span>
      <span class="s1">json.putDouble(</span><span class="s5">&quot;bottom&quot;</span><span class="s2">, </span><span class="s1">PixelUtil.toDIPFromPixel(bottom))</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">json.putString(</span><span class="s5">&quot;visibility&quot;</span><span class="s2">, </span><span class="s5">&quot;unknown&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">json.putInt(</span><span class="s5">&quot;index&quot;</span><span class="s2">, </span><span class="s1">index)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">json</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private </span><span class="s1">ReactContext getReactContext() {</span>
    <span class="s1">Context context = getContext()</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(context </span><span class="s2">instanceof </span><span class="s1">TintContextWrapper)</span>
        <span class="s1">? (ReactContext) ((TintContextWrapper) context).getBaseContext()</span>
        <span class="s1">: (ReactContext) context</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onLayout(</span>
      <span class="s2">boolean </span><span class="s1">changed</span><span class="s2">, int </span><span class="s1">textViewLeft</span><span class="s2">, int </span><span class="s1">textViewTop</span><span class="s2">, int </span><span class="s1">textViewRight</span><span class="s2">, int </span><span class="s1">textViewBottom) {</span>
    <span class="s0">// TODO T62882314: Delete this method when Fabric is fully released in OSS</span>
    <span class="s2">int </span><span class="s1">reactTag = getId()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!(getText() </span><span class="s2">instanceof </span><span class="s1">Spanned)</span>
        <span class="s1">|| ViewUtil.getUIManagerType(reactTag) == UIManagerType.FABRIC) {</span>
      <span class="s4">/**</span>
       <span class="s4">* In general, {</span><span class="s6">@link </span><span class="s4">#setText} is called via {</span><span class="s6">@link </span><span class="s4">ReactTextViewManager#updateExtraData}</span>
       <span class="s4">* before we are laid out. This ordering is a requirement because we utilize the data from</span>
       <span class="s4">* setText in onLayout.</span>
       <span class="s4">*</span>
       <span class="s4">* </span><span class="s7">&lt;p&gt;</span><span class="s4">However, it's possible for us to get an extra layout before we've received our setText</span>
       <span class="s4">* call. If this happens before the initial setText call, then getText() will have its default</span>
       <span class="s4">* value which isn't a Spanned and we need to bail out. That's fine because we'll get a</span>
       <span class="s4">* setText followed by a layout later.</span>
       <span class="s4">*</span>
       <span class="s4">* </span><span class="s7">&lt;p&gt;</span><span class="s4">The cause for the extra early layout is that an ancestor gets transitioned from a</span>
       <span class="s4">* layout-only node to a non layout-only node.</span>
       <span class="s4">*/</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">ReactContext reactContext = getReactContext()</span><span class="s2">;</span>
    <span class="s1">UIManagerModule uiManager =</span>
        <span class="s1">Assertions.assertNotNull(reactContext.getNativeModule(UIManagerModule.</span><span class="s2">class</span><span class="s1">))</span><span class="s2">;</span>

    <span class="s1">Spanned text = (Spanned) getText()</span><span class="s2">;</span>
    <span class="s1">Layout layout = getLayout()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(layout == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Text layout is calculated during pre-draw phase, so in some cases it can be empty during</span>
      <span class="s0">// layout phase, which usually happens before drawing.</span>
      <span class="s0">// The text layout is created by private {@link assumeLayout} method, which we can try to</span>
      <span class="s0">// invoke directly through reflection or indirectly through some methods that compute it</span>
      <span class="s0">// (e.g. {@link getExtendedPaddingTop}).</span>
      <span class="s0">// It is safer, however, to just early return here, as next measure/layout passes are way more</span>
      <span class="s0">// likely to have the text layout computed.</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">TextInlineViewPlaceholderSpan[] placeholders =</span>
        <span class="s1">text.getSpans(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">text.length()</span><span class="s2">, </span><span class="s1">TextInlineViewPlaceholderSpan.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">ArrayList inlineViewInfoArray =</span>
        <span class="s1">mNotifyOnInlineViewLayout ? </span><span class="s2">new </span><span class="s1">ArrayList(placeholders.length) : </span><span class="s2">null;</span>
    <span class="s2">int </span><span class="s1">textViewWidth = textViewRight - textViewLeft</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">textViewHeight = textViewBottom - textViewTop</span><span class="s2">;</span>

    <span class="s2">for </span><span class="s1">(TextInlineViewPlaceholderSpan placeholder : placeholders) {</span>
      <span class="s1">View child = uiManager.resolveView(placeholder.getReactTag())</span><span class="s2">;</span>

      <span class="s2">int </span><span class="s1">start = text.getSpanStart(placeholder)</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">line = layout.getLineForOffset(start)</span><span class="s2">;</span>
      <span class="s2">boolean </span><span class="s1">isLineTruncated = layout.getEllipsisCount(line) &gt; </span><span class="s3">0</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">( </span><span class="s0">// This truncation check works well on recent versions of Android (tested on 5.1.1 and</span>
      <span class="s0">// 6.0.1) but not on Android 4.4.4. The reason is that getEllipsisCount is buggy on</span>
      <span class="s0">// Android 4.4.4. Specifically, it incorrectly returns 0 if an inline view is the first</span>
      <span class="s0">// thing to be truncated.</span>
      <span class="s1">(isLineTruncated &amp;&amp; start &gt;= layout.getLineStart(line) + layout.getEllipsisStart(line))</span>
          <span class="s1">||</span>

          <span class="s0">// This truncation check works well on Android 4.4.4 but not on others (e.g. 6.0.1).</span>
          <span class="s0">// On Android 4.4.4, getLineEnd returns the first truncated character whereas on 6.0.1,</span>
          <span class="s0">// it appears to return the position after the last character on the line even if that</span>
          <span class="s0">// character is truncated.</span>
          <span class="s1">line &gt;= mNumberOfLines</span>
          <span class="s1">|| start &gt;= layout.getLineEnd(line)) {</span>
        <span class="s0">// On some versions of Android (e.g. 4.4.4, 5.1.1), getPrimaryHorizontal can infinite</span>
        <span class="s0">// loop when called on a character that appears after the ellipsis. Avoid this bug by</span>
        <span class="s0">// special casing the character truncation case.</span>
        <span class="s1">child.setVisibility(View.GONE)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(mNotifyOnInlineViewLayout) {</span>
          <span class="s1">inlineViewInfoArray.add(inlineViewJson(View.GONE</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">int </span><span class="s1">width = placeholder.getWidth()</span><span class="s2">;</span>
        <span class="s2">int </span><span class="s1">height = placeholder.getHeight()</span><span class="s2">;</span>

        <span class="s0">// Calculate if the direction of the placeholder character is Right-To-Left.</span>
        <span class="s2">boolean </span><span class="s1">isRtlChar = layout.isRtlCharAt(start)</span><span class="s2">;</span>

        <span class="s2">boolean </span><span class="s1">isRtlParagraph = layout.getParagraphDirection(line) == Layout.DIR_RIGHT_TO_LEFT</span><span class="s2">;</span>

        <span class="s2">int </span><span class="s1">placeholderHorizontalPosition</span><span class="s2">;</span>
        <span class="s0">// There's a bug on Samsung devices where calling getPrimaryHorizontal on</span>
        <span class="s0">// the last offset in the layout will result in an endless loop. Work around</span>
        <span class="s0">// this bug by avoiding getPrimaryHorizontal in that case.</span>
        <span class="s2">if </span><span class="s1">(start == text.length() - </span><span class="s3">1</span><span class="s1">) {</span>
          <span class="s2">boolean </span><span class="s1">endsWithNewLine =</span>
              <span class="s1">text.length() &gt; </span><span class="s3">0 </span><span class="s1">&amp;&amp; text.charAt(layout.getLineEnd(line) - </span><span class="s3">1</span><span class="s1">) == </span><span class="s5">'</span><span class="s2">\n</span><span class="s5">'</span><span class="s2">;</span>
          <span class="s2">float </span><span class="s1">lineWidth = endsWithNewLine ? layout.getLineMax(line) : layout.getLineWidth(line)</span><span class="s2">;</span>
          <span class="s1">placeholderHorizontalPosition =</span>
              <span class="s1">isRtlParagraph</span>
                  <span class="s0">// Equivalent to `layout.getLineLeft(line)` but `getLineLeft` returns incorrect</span>
                  <span class="s0">// values when the paragraph is RTL and `setSingleLine(true)`.</span>
                  <span class="s1">? textViewWidth - (</span><span class="s2">int</span><span class="s1">) lineWidth</span>
                  <span class="s1">: (</span><span class="s2">int</span><span class="s1">) layout.getLineRight(line) - width</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// The direction of the paragraph may not be exactly the direction the string is heading</span>
          <span class="s0">// in at the</span>
          <span class="s0">// position of the placeholder. So, if the direction of the character is the same as the</span>
          <span class="s0">// paragraph</span>
          <span class="s0">// use primary, secondary otherwise.</span>
          <span class="s2">boolean </span><span class="s1">characterAndParagraphDirectionMatch = isRtlParagraph == isRtlChar</span><span class="s2">;</span>

          <span class="s1">placeholderHorizontalPosition =</span>
              <span class="s1">characterAndParagraphDirectionMatch</span>
                  <span class="s1">? (</span><span class="s2">int</span><span class="s1">) layout.getPrimaryHorizontal(start)</span>
                  <span class="s1">: (</span><span class="s2">int</span><span class="s1">) layout.getSecondaryHorizontal(start)</span><span class="s2">;</span>

          <span class="s2">if </span><span class="s1">(isRtlParagraph) {</span>
            <span class="s0">// Adjust `placeholderHorizontalPosition` to work around an Android bug.</span>
            <span class="s0">// The bug is when the paragraph is RTL and `setSingleLine(true)`, some layout</span>
            <span class="s0">// methods such as `getPrimaryHorizontal`, `getSecondaryHorizontal`, and</span>
            <span class="s0">// `getLineRight` return incorrect values. Their return values seem to be off</span>
            <span class="s0">// by the same number of pixels so subtracting these values cancels out the error.</span>
            <span class="s0">//</span>
            <span class="s0">// The result is equivalent to bugless versions of</span>
            <span class="s0">// `getPrimaryHorizontal`/`getSecondaryHorizontal`.</span>
            <span class="s1">placeholderHorizontalPosition =</span>
                <span class="s1">textViewWidth - ((</span><span class="s2">int</span><span class="s1">) layout.getLineRight(line) - placeholderHorizontalPosition)</span><span class="s2">;</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(isRtlChar) {</span>
            <span class="s1">placeholderHorizontalPosition -= width</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">int </span><span class="s1">leftRelativeToTextView =</span>
            <span class="s1">isRtlChar</span>
                <span class="s1">? placeholderHorizontalPosition + getTotalPaddingRight()</span>
                <span class="s1">: placeholderHorizontalPosition + getTotalPaddingLeft()</span><span class="s2">;</span>

        <span class="s2">int </span><span class="s1">left = textViewLeft + leftRelativeToTextView</span><span class="s2">;</span>

        <span class="s0">// Vertically align the inline view to the baseline of the line of text.</span>
        <span class="s2">int </span><span class="s1">topRelativeToTextView = getTotalPaddingTop() + layout.getLineBaseline(line) - height</span><span class="s2">;</span>
        <span class="s2">int </span><span class="s1">top = textViewTop + topRelativeToTextView</span><span class="s2">;</span>

        <span class="s2">boolean </span><span class="s1">isFullyClipped =</span>
            <span class="s1">textViewWidth &lt;= leftRelativeToTextView || textViewHeight &lt;= topRelativeToTextView</span><span class="s2">;</span>
        <span class="s2">int </span><span class="s1">layoutVisibility = isFullyClipped ? View.GONE : View.VISIBLE</span><span class="s2">;</span>
        <span class="s2">int </span><span class="s1">layoutLeft = left</span><span class="s2">;</span>
        <span class="s2">int </span><span class="s1">layoutTop = top</span><span class="s2">;</span>
        <span class="s2">int </span><span class="s1">layoutRight = left + width</span><span class="s2">;</span>
        <span class="s2">int </span><span class="s1">layoutBottom = top + height</span><span class="s2">;</span>

        <span class="s0">// Keep these parameters in sync with what goes into `inlineViewInfoArray`.</span>
        <span class="s1">child.setVisibility(layoutVisibility)</span><span class="s2">;</span>
        <span class="s1">child.layout(layoutLeft</span><span class="s2">, </span><span class="s1">layoutTop</span><span class="s2">, </span><span class="s1">layoutRight</span><span class="s2">, </span><span class="s1">layoutBottom)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(mNotifyOnInlineViewLayout) {</span>
          <span class="s1">inlineViewInfoArray.add(</span>
              <span class="s1">inlineViewJson(</span>
                  <span class="s1">layoutVisibility</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">layoutLeft</span><span class="s2">, </span><span class="s1">layoutTop</span><span class="s2">, </span><span class="s1">layoutRight</span><span class="s2">, </span><span class="s1">layoutBottom))</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mNotifyOnInlineViewLayout) {</span>
      <span class="s1">Collections.sort(</span>
          <span class="s1">inlineViewInfoArray</span><span class="s2">,</span>
          <span class="s2">new </span><span class="s1">Comparator() {</span>
            <span class="s1">@Override</span>
            <span class="s2">public int </span><span class="s1">compare(Object o1</span><span class="s2">, </span><span class="s1">Object o2) {</span>
              <span class="s1">WritableMap m1 = (WritableMap) o1</span><span class="s2">;</span>
              <span class="s1">WritableMap m2 = (WritableMap) o2</span><span class="s2">;</span>
              <span class="s2">return </span><span class="s1">m1.getInt(</span><span class="s5">&quot;index&quot;</span><span class="s1">) - m2.getInt(</span><span class="s5">&quot;index&quot;</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">})</span><span class="s2">;</span>
      <span class="s1">WritableArray inlineViewInfoArray2 = Arguments.createArray()</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(Object item : inlineViewInfoArray) {</span>
        <span class="s1">inlineViewInfoArray2.pushMap((WritableMap) item)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">WritableMap event = Arguments.createMap()</span><span class="s2">;</span>
      <span class="s1">event.putArray(</span><span class="s5">&quot;inlineViews&quot;</span><span class="s2">, </span><span class="s1">inlineViewInfoArray2)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(uiManager != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">uiManager.receiveEvent(reactTag</span><span class="s2">, </span><span class="s5">&quot;topInlineViewLayout&quot;</span><span class="s2">, </span><span class="s1">event)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setText(ReactTextUpdate update) {</span>
    <span class="s1">mContainsImages = update.containsImages()</span><span class="s2">;</span>
    <span class="s0">// Android's TextView crashes when it tries to relayout if LayoutParams are</span>
    <span class="s0">// null; explicitly set the LayoutParams to prevent this crash. See:</span>
    <span class="s0">// https://github.com/facebook/react-native/pull/7011</span>
    <span class="s2">if </span><span class="s1">(getLayoutParams() == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">setLayoutParams(EMPTY_LAYOUT_PARAMS)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">Spannable spannable = update.getText()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mLinkifyMaskType &gt; </span><span class="s3">0</span><span class="s1">) {</span>
      <span class="s1">Linkify.addLinks(spannable</span><span class="s2">, </span><span class="s1">mLinkifyMaskType)</span><span class="s2">;</span>
      <span class="s1">setMovementMethod(LinkMovementMethod.getInstance())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">setText(spannable)</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">paddingLeft = update.getPaddingLeft()</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">paddingTop = update.getPaddingTop()</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">paddingRight = update.getPaddingRight()</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">paddingBottom = update.getPaddingBottom()</span><span class="s2">;</span>

    <span class="s0">// In Fabric padding is set by the update of Layout Metrics and not as part of the &quot;setText&quot;</span>
    <span class="s0">// operation</span>
    <span class="s0">// TODO T56559197: remove this condition when we migrate 100% to Fabric</span>
    <span class="s2">if </span><span class="s1">(paddingLeft != UNSET</span>
        <span class="s1">&amp;&amp; paddingBottom != UNSET</span>
        <span class="s1">&amp;&amp; paddingRight != UNSET</span>
        <span class="s1">&amp;&amp; paddingBottom != UNSET) {</span>

      <span class="s1">setPadding(</span>
          <span class="s1">(</span><span class="s2">int</span><span class="s1">) Math.floor(paddingLeft)</span><span class="s2">,</span>
          <span class="s1">(</span><span class="s2">int</span><span class="s1">) Math.floor(paddingTop)</span><span class="s2">,</span>
          <span class="s1">(</span><span class="s2">int</span><span class="s1">) Math.floor(paddingRight)</span><span class="s2">,</span>
          <span class="s1">(</span><span class="s2">int</span><span class="s1">) Math.floor(paddingBottom))</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">int </span><span class="s1">nextTextAlign = update.getTextAlign()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(nextTextAlign != getGravityHorizontal()) {</span>
      <span class="s1">setGravityHorizontal(nextTextAlign)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {</span>
      <span class="s2">if </span><span class="s1">(getBreakStrategy() != update.getTextBreakStrategy()) {</span>
        <span class="s1">setBreakStrategy(update.getTextBreakStrategy())</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {</span>
      <span class="s2">if </span><span class="s1">(getJustificationMode() != update.getJustificationMode()) {</span>
        <span class="s1">setJustificationMode(update.getJustificationMode())</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// Ensure onLayout is called so the inline views can be repositioned.</span>
    <span class="s1">requestLayout()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public int </span><span class="s1">reactTagForTouch(</span><span class="s2">float </span><span class="s1">touchX</span><span class="s2">, float </span><span class="s1">touchY) {</span>
    <span class="s1">CharSequence text = getText()</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">target = getId()</span><span class="s2">;</span>

    <span class="s2">int </span><span class="s1">x = (</span><span class="s2">int</span><span class="s1">) touchX</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">y = (</span><span class="s2">int</span><span class="s1">) touchY</span><span class="s2">;</span>

    <span class="s1">Layout layout = getLayout()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(layout == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// If the layout is null, the view hasn't been properly laid out yet. Therefore, we can't find</span>
      <span class="s0">// the exact text tag that has been touched, and the correct tag to return is the default one.</span>
      <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">int </span><span class="s1">line = layout.getLineForVertical(y)</span><span class="s2">;</span>

    <span class="s2">int </span><span class="s1">lineStartX = (</span><span class="s2">int</span><span class="s1">) layout.getLineLeft(line)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">lineEndX = (</span><span class="s2">int</span><span class="s1">) layout.getLineRight(line)</span><span class="s2">;</span>

    <span class="s0">// TODO(5966918): Consider extending touchable area for text spans by some DP constant</span>
    <span class="s2">if </span><span class="s1">(text </span><span class="s2">instanceof </span><span class="s1">Spanned &amp;&amp; x &gt;= lineStartX &amp;&amp; x &lt;= lineEndX) {</span>
      <span class="s1">Spanned spannedText = (Spanned) text</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">index = -</span><span class="s3">1</span><span class="s2">;</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">index = layout.getOffsetForHorizontal(line</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(ArrayIndexOutOfBoundsException e) {</span>
        <span class="s0">// https://issuetracker.google.com/issues/113348914</span>
        <span class="s1">FLog.e(ReactConstants.TAG</span><span class="s2">, </span><span class="s5">&quot;Crash in HorizontalMeasurementProvider: &quot; </span><span class="s1">+ e.getMessage())</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">// We choose the most inner span (shortest) containing character at the given index</span>
      <span class="s0">// if no such span can be found we will send the textview's react id as a touch handler</span>
      <span class="s0">// In case when there are more than one spans with same length we choose the last one</span>
      <span class="s0">// from the spans[] array, since it correspond to the most inner react element</span>
      <span class="s1">ReactTagSpan[] spans = spannedText.getSpans(index</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">ReactTagSpan.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(spans != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">int </span><span class="s1">targetSpanTextLength = text.length()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s3">0</span><span class="s2">; </span><span class="s1">i &lt; spans.length</span><span class="s2">; </span><span class="s1">i++) {</span>
          <span class="s2">int </span><span class="s1">spanStart = spannedText.getSpanStart(spans[i])</span><span class="s2">;</span>
          <span class="s2">int </span><span class="s1">spanEnd = spannedText.getSpanEnd(spans[i])</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(spanEnd &gt;= index &amp;&amp; (spanEnd - spanStart) &lt;= targetSpanTextLength) {</span>
            <span class="s1">target = spans[i].getReactTag()</span><span class="s2">;</span>
            <span class="s1">targetSpanTextLength = (spanEnd - spanStart)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected boolean </span><span class="s1">verifyDrawable(Drawable drawable) {</span>
    <span class="s2">if </span><span class="s1">(mContainsImages &amp;&amp; getText() </span><span class="s2">instanceof </span><span class="s1">Spanned) {</span>
      <span class="s1">Spanned text = (Spanned) getText()</span><span class="s2">;</span>
      <span class="s1">TextInlineImageSpan[] spans = text.getSpans(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">text.length()</span><span class="s2">, </span><span class="s1">TextInlineImageSpan.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(TextInlineImageSpan span : spans) {</span>
        <span class="s2">if </span><span class="s1">(span.getDrawable() == drawable) {</span>
          <span class="s2">return true;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return super</span><span class="s1">.verifyDrawable(drawable)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">invalidateDrawable(Drawable drawable) {</span>
    <span class="s2">if </span><span class="s1">(mContainsImages &amp;&amp; getText() </span><span class="s2">instanceof </span><span class="s1">Spanned) {</span>
      <span class="s1">Spanned text = (Spanned) getText()</span><span class="s2">;</span>
      <span class="s1">TextInlineImageSpan[] spans = text.getSpans(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">text.length()</span><span class="s2">, </span><span class="s1">TextInlineImageSpan.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(TextInlineImageSpan span : spans) {</span>
        <span class="s2">if </span><span class="s1">(span.getDrawable() == drawable) {</span>
          <span class="s1">invalidate()</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">super</span><span class="s1">.invalidateDrawable(drawable)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onDetachedFromWindow() {</span>
    <span class="s2">super</span><span class="s1">.onDetachedFromWindow()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mContainsImages &amp;&amp; getText() </span><span class="s2">instanceof </span><span class="s1">Spanned) {</span>
      <span class="s1">Spanned text = (Spanned) getText()</span><span class="s2">;</span>
      <span class="s1">TextInlineImageSpan[] spans = text.getSpans(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">text.length()</span><span class="s2">, </span><span class="s1">TextInlineImageSpan.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(TextInlineImageSpan span : spans) {</span>
        <span class="s1">span.onDetachedFromWindow()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onStartTemporaryDetach() {</span>
    <span class="s2">super</span><span class="s1">.onStartTemporaryDetach()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mContainsImages &amp;&amp; getText() </span><span class="s2">instanceof </span><span class="s1">Spanned) {</span>
      <span class="s1">Spanned text = (Spanned) getText()</span><span class="s2">;</span>
      <span class="s1">TextInlineImageSpan[] spans = text.getSpans(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">text.length()</span><span class="s2">, </span><span class="s1">TextInlineImageSpan.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(TextInlineImageSpan span : spans) {</span>
        <span class="s1">span.onStartTemporaryDetach()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setTextIsSelectable(</span><span class="s2">boolean </span><span class="s1">selectable) {</span>
    <span class="s1">mTextIsSelectable = selectable</span><span class="s2">;</span>
    <span class="s2">super</span><span class="s1">.setTextIsSelectable(selectable)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onAttachedToWindow() {</span>
    <span class="s2">super</span><span class="s1">.onAttachedToWindow()</span><span class="s2">;</span>
    <span class="s1">setTextIsSelectable(mTextIsSelectable)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mContainsImages &amp;&amp; getText() </span><span class="s2">instanceof </span><span class="s1">Spanned) {</span>
      <span class="s1">Spanned text = (Spanned) getText()</span><span class="s2">;</span>
      <span class="s1">TextInlineImageSpan[] spans = text.getSpans(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">text.length()</span><span class="s2">, </span><span class="s1">TextInlineImageSpan.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(TextInlineImageSpan span : spans) {</span>
        <span class="s1">span.onAttachedToWindow()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onFinishTemporaryDetach() {</span>
    <span class="s2">super</span><span class="s1">.onFinishTemporaryDetach()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mContainsImages &amp;&amp; getText() </span><span class="s2">instanceof </span><span class="s1">Spanned) {</span>
      <span class="s1">Spanned text = (Spanned) getText()</span><span class="s2">;</span>
      <span class="s1">TextInlineImageSpan[] spans = text.getSpans(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">text.length()</span><span class="s2">, </span><span class="s1">TextInlineImageSpan.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(TextInlineImageSpan span : spans) {</span>
        <span class="s1">span.onFinishTemporaryDetach()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">hasOverlappingRendering() {</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>

  <span class="s0">/* package */ </span><span class="s2">int </span><span class="s1">getGravityHorizontal() {</span>
    <span class="s2">return </span><span class="s1">getGravity()</span>
        <span class="s1">&amp; (Gravity.HORIZONTAL_GRAVITY_MASK | Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/* package */ </span><span class="s2">void </span><span class="s1">setGravityHorizontal(</span><span class="s2">int </span><span class="s1">gravityHorizontal) {</span>
    <span class="s2">if </span><span class="s1">(gravityHorizontal == </span><span class="s3">0</span><span class="s1">) {</span>
      <span class="s1">gravityHorizontal = mDefaultGravityHorizontal</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">setGravity(</span>
        <span class="s1">(getGravity()</span>
                <span class="s1">&amp; ~Gravity.HORIZONTAL_GRAVITY_MASK</span>
                <span class="s1">&amp; ~Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK)</span>
            <span class="s1">| gravityHorizontal)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/* package */ </span><span class="s2">void </span><span class="s1">setGravityVertical(</span><span class="s2">int </span><span class="s1">gravityVertical) {</span>
    <span class="s2">if </span><span class="s1">(gravityVertical == </span><span class="s3">0</span><span class="s1">) {</span>
      <span class="s1">gravityVertical = mDefaultGravityVertical</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">setGravity((getGravity() &amp; ~Gravity.VERTICAL_GRAVITY_MASK) | gravityVertical)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setNumberOfLines(</span><span class="s2">int </span><span class="s1">numberOfLines) {</span>
    <span class="s1">mNumberOfLines = numberOfLines == </span><span class="s3">0 </span><span class="s1">? ViewDefaults.NUMBER_OF_LINES : numberOfLines</span><span class="s2">;</span>
    <span class="s1">setSingleLine(mNumberOfLines == </span><span class="s3">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">setMaxLines(mNumberOfLines)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setAdjustFontSizeToFit(</span><span class="s2">boolean </span><span class="s1">adjustsFontSizeToFit) {</span>
    <span class="s1">mAdjustsFontSizeToFit = adjustsFontSizeToFit</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setEllipsizeLocation(TextUtils.TruncateAt ellipsizeLocation) {</span>
    <span class="s1">mEllipsizeLocation = ellipsizeLocation</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setNotifyOnInlineViewLayout(</span><span class="s2">boolean </span><span class="s1">notifyOnInlineViewLayout) {</span>
    <span class="s1">mNotifyOnInlineViewLayout = notifyOnInlineViewLayout</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">updateView() {</span>
    <span class="s1">@Nullable</span>
    <span class="s1">TextUtils.TruncateAt ellipsizeLocation =</span>
        <span class="s1">mNumberOfLines == ViewDefaults.NUMBER_OF_LINES || mAdjustsFontSizeToFit</span>
            <span class="s1">? </span><span class="s2">null</span>
            <span class="s1">: mEllipsizeLocation</span><span class="s2">;</span>
    <span class="s1">setEllipsize(ellipsizeLocation)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setBackgroundColor(</span><span class="s2">int </span><span class="s1">color) {</span>
    <span class="s1">mReactBackgroundManager.setBackgroundColor(color)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderWidth(</span><span class="s2">int </span><span class="s1">position</span><span class="s2">, float </span><span class="s1">width) {</span>
    <span class="s1">mReactBackgroundManager.setBorderWidth(position</span><span class="s2">, </span><span class="s1">width)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderColor(</span><span class="s2">int </span><span class="s1">position</span><span class="s2">, float </span><span class="s1">color</span><span class="s2">, float </span><span class="s1">alpha) {</span>
    <span class="s1">mReactBackgroundManager.setBorderColor(position</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">alpha)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderRadius(</span><span class="s2">float </span><span class="s1">borderRadius) {</span>
    <span class="s1">mReactBackgroundManager.setBorderRadius(borderRadius)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderRadius(</span><span class="s2">float </span><span class="s1">borderRadius</span><span class="s2">, int </span><span class="s1">position) {</span>
    <span class="s1">mReactBackgroundManager.setBorderRadius(borderRadius</span><span class="s2">, </span><span class="s1">position)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderStyle(@Nullable String style) {</span>
    <span class="s1">mReactBackgroundManager.setBorderStyle(style)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setSpanned(Spannable spanned) {</span>
    <span class="s1">mSpanned = spanned</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">Spannable getSpanned() {</span>
    <span class="s2">return </span><span class="s1">mSpanned</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setLinkifyMask(</span><span class="s2">int </span><span class="s1">mask) {</span>
    <span class="s1">mLinkifyMaskType = mask</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected boolean </span><span class="s1">dispatchHoverEvent(MotionEvent event) {</span>
    <span class="s0">// if this view has an accessibility delegate set, and that delegate supports virtual view</span>
    <span class="s0">// children (used for links), pass the hover event along to it so that touching and holding on</span>
    <span class="s0">// this text will properly move focus to the virtual children.</span>
    <span class="s2">if </span><span class="s1">(ViewCompat.hasAccessibilityDelegate(</span><span class="s2">this</span><span class="s1">)) {</span>
      <span class="s1">AccessibilityDelegateCompat delegate = ViewCompat.getAccessibilityDelegate(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(delegate </span><span class="s2">instanceof </span><span class="s1">ExploreByTouchHelper) {</span>
        <span class="s2">return </span><span class="s1">((ExploreByTouchHelper) delegate).dispatchHoverEvent(event)</span>
            <span class="s1">|| </span><span class="s2">super</span><span class="s1">.dispatchHoverEvent(event)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return super</span><span class="s1">.dispatchHoverEvent(event)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
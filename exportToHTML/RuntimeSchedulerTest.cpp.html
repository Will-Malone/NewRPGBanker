<html>
<head>
<title>RuntimeSchedulerTest.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RuntimeSchedulerTest.cpp</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#include </span><span class="s3">&lt;gtest/gtest.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;hermes/hermes.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;jsi/jsi.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;react/renderer/runtimescheduler/RuntimeScheduler.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;memory&gt;</span>

<span class="s2">#include </span><span class="s3">&quot;StubClock.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;StubErrorUtils.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;StubQueue.h&quot;</span>

<span class="s4">namespace </span><span class="s1">facebook::react {</span>

<span class="s4">using namespace </span><span class="s1">std::chrono_literals</span><span class="s4">;</span>

<span class="s4">class </span><span class="s1">RuntimeSchedulerTest : </span><span class="s4">public </span><span class="s1">testing::Test {</span>
 <span class="s4">protected</span><span class="s1">:</span>
  <span class="s4">void </span><span class="s1">SetUp() override {</span>
    <span class="s1">hostFunctionCallCount_ = </span><span class="s5">0</span><span class="s4">;</span>
    <span class="s1">runtime_ = facebook::hermes::makeHermesRuntime()</span><span class="s4">;</span>
    <span class="s1">stubErrorUtils_ = StubErrorUtils::createAndInstallIfNeeded(*runtime_)</span><span class="s4">;</span>
    <span class="s1">stubQueue_ = std::make_unique&lt;StubQueue&gt;()</span><span class="s4">;</span>

    <span class="s1">RuntimeExecutor runtimeExecutor =</span>
        <span class="s1">[</span><span class="s4">this</span><span class="s1">](</span>
            <span class="s1">std::function&lt;</span><span class="s4">void</span><span class="s1">(facebook::jsi::Runtime &amp; runtime)&gt; &amp;&amp;callback) {</span>
          <span class="s1">stubQueue_-&gt;runOnQueue([</span><span class="s4">this, </span><span class="s1">callback = std::move(callback)]() {</span>
            <span class="s1">callback(*runtime_)</span><span class="s4">;</span>
          <span class="s1">})</span><span class="s4">;</span>
        <span class="s1">}</span><span class="s4">;</span>

    <span class="s1">stubClock_ = std::make_unique&lt;StubClock&gt;(StubClock())</span><span class="s4">;</span>

    <span class="s4">auto </span><span class="s1">stubNow = [</span><span class="s4">this</span><span class="s1">]() -&gt; RuntimeSchedulerTimePoint {</span>
      <span class="s4">return </span><span class="s1">stubClock_-&gt;getNow()</span><span class="s4">;</span>
    <span class="s1">}</span><span class="s4">;</span>

    <span class="s1">runtimeScheduler_ =</span>
        <span class="s1">std::make_unique&lt;RuntimeScheduler&gt;(runtimeExecutor</span><span class="s4">, </span><span class="s1">stubNow)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">jsi::Function createHostFunctionFromLambda(</span>
      <span class="s1">std::function&lt;jsi::Value(</span><span class="s4">bool</span><span class="s1">)&gt; callback) {</span>
    <span class="s4">return </span><span class="s1">jsi::Function::createFromHostFunction(</span>
        <span class="s1">*runtime_</span><span class="s4">,</span>
        <span class="s1">jsi::PropNameID::forUtf8(*runtime_</span><span class="s4">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s4">,</span>
        <span class="s5">3</span><span class="s4">,</span>
        <span class="s1">[</span><span class="s4">this, </span><span class="s1">callback = std::move(callback)](</span>
            <span class="s1">jsi::Runtime &amp; </span><span class="s0">/*unused*/</span><span class="s4">,</span>
            <span class="s1">jsi::Value </span><span class="s4">const </span><span class="s1">&amp; </span><span class="s0">/*unused*/</span><span class="s4">,</span>
            <span class="s1">jsi::Value </span><span class="s4">const </span><span class="s1">*arguments</span><span class="s4">,</span>
            <span class="s1">size_t </span><span class="s0">/*unused*/</span><span class="s1">) -&gt; jsi::Value {</span>
          <span class="s1">++hostFunctionCallCount_</span><span class="s4">;</span>
          <span class="s4">auto </span><span class="s1">didUserCallbackTimeout = arguments[</span><span class="s5">0</span><span class="s1">].getBool()</span><span class="s4">;</span>
          <span class="s4">return </span><span class="s1">callback(didUserCallbackTimeout)</span><span class="s4">;</span>
        <span class="s1">})</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">uint hostFunctionCallCount_{}</span><span class="s4">;</span>

  <span class="s1">std::unique_ptr&lt;facebook::hermes::HermesRuntime&gt; runtime_</span><span class="s4">;</span>
  <span class="s1">std::unique_ptr&lt;StubClock&gt; stubClock_</span><span class="s4">;</span>
  <span class="s1">std::unique_ptr&lt;StubQueue&gt; stubQueue_</span><span class="s4">;</span>
  <span class="s1">std::unique_ptr&lt;RuntimeScheduler&gt; runtimeScheduler_</span><span class="s4">;</span>
  <span class="s1">std::shared_ptr&lt;StubErrorUtils&gt; stubErrorUtils_</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">now) {</span>
  <span class="s1">stubClock_-&gt;setTimePoint(</span><span class="s5">1</span><span class="s1">ms)</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(runtimeScheduler_-&gt;now()</span><span class="s4">, </span><span class="s1">RuntimeSchedulerTimePoint(</span><span class="s5">1</span><span class="s1">ms))</span><span class="s4">;</span>

  <span class="s1">stubClock_-&gt;advanceTimeBy(</span><span class="s5">10</span><span class="s1">ms)</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(runtimeScheduler_-&gt;now()</span><span class="s4">, </span><span class="s1">RuntimeSchedulerTimePoint(</span><span class="s5">11</span><span class="s1">ms))</span><span class="s4">;</span>

  <span class="s1">stubClock_-&gt;advanceTimeBy(</span><span class="s5">6</span><span class="s1">s)</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(runtimeScheduler_-&gt;now()</span><span class="s4">, </span><span class="s1">RuntimeSchedulerTimePoint(</span><span class="s5">6011</span><span class="s1">ms))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">getShouldYield) {</span>
  <span class="s0">// Always returns false for now.</span>
  <span class="s1">EXPECT_FALSE(runtimeScheduler_-&gt;getShouldYield())</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">scheduleSingleTask) {</span>
  <span class="s4">bool </span><span class="s1">didRunTask = </span><span class="s4">false;</span>
  <span class="s4">auto </span><span class="s1">callback =</span>
      <span class="s1">createHostFunctionFromLambda([&amp;didRunTask](</span><span class="s4">bool </span><span class="s1">didUserCallbackTimeout) {</span>
        <span class="s1">didRunTask = </span><span class="s4">true;</span>
        <span class="s1">EXPECT_FALSE(didUserCallbackTimeout)</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
      <span class="s1">SchedulerPriority::NormalPriority</span><span class="s4">, </span><span class="s1">std::move(callback))</span><span class="s4">;</span>

  <span class="s1">EXPECT_FALSE(didRunTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(didRunTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">scheduleImmediatePriorityTask) {</span>
  <span class="s4">bool </span><span class="s1">didRunTask = </span><span class="s4">false;</span>
  <span class="s4">auto </span><span class="s1">callback =</span>
      <span class="s1">createHostFunctionFromLambda([&amp;didRunTask](</span><span class="s4">bool </span><span class="s1">didUserCallbackTimeout) {</span>
        <span class="s1">didRunTask = </span><span class="s4">true;</span>
        <span class="s1">EXPECT_TRUE(didUserCallbackTimeout)</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
      <span class="s1">SchedulerPriority::ImmediatePriority</span><span class="s4">, </span><span class="s1">std::move(callback))</span><span class="s4">;</span>

  <span class="s1">EXPECT_FALSE(didRunTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(didRunTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">taskExpiration) {</span>
  <span class="s4">bool </span><span class="s1">didRunTask = </span><span class="s4">false;</span>
  <span class="s4">auto </span><span class="s1">callback =</span>
      <span class="s1">createHostFunctionFromLambda([&amp;didRunTask](</span><span class="s4">bool </span><span class="s1">didUserCallbackTimeout) {</span>
        <span class="s1">didRunTask = </span><span class="s4">true;</span>
        <span class="s1">EXPECT_TRUE(didUserCallbackTimeout)</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
      <span class="s1">SchedulerPriority::NormalPriority</span><span class="s4">, </span><span class="s1">std::move(callback))</span><span class="s4">;</span>

  <span class="s0">// Task with normal priority has 5s timeout.</span>
  <span class="s1">stubClock_-&gt;advanceTimeBy(</span><span class="s5">6</span><span class="s1">s)</span><span class="s4">;</span>

  <span class="s1">EXPECT_FALSE(didRunTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(didRunTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">scheduleTwoTasksWithSamePriority) {</span>
  <span class="s1">uint firstTaskCallOrder = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">callbackOne = createHostFunctionFromLambda(</span>
      <span class="s1">[</span><span class="s4">this, </span><span class="s1">&amp;firstTaskCallOrder](</span><span class="s4">bool </span><span class="s0">/*unused*/</span><span class="s1">) {</span>
        <span class="s1">firstTaskCallOrder = hostFunctionCallCount_</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
      <span class="s1">SchedulerPriority::NormalPriority</span><span class="s4">, </span><span class="s1">std::move(callbackOne))</span><span class="s4">;</span>

  <span class="s1">uint secondTaskCallOrder</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">callbackTwo = createHostFunctionFromLambda(</span>
      <span class="s1">[</span><span class="s4">this, </span><span class="s1">&amp;secondTaskCallOrder](</span><span class="s4">bool </span><span class="s0">/*unused*/</span><span class="s1">) {</span>
        <span class="s1">secondTaskCallOrder = hostFunctionCallCount_</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
      <span class="s1">SchedulerPriority::NormalPriority</span><span class="s4">, </span><span class="s1">std::move(callbackTwo))</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(firstTaskCallOrder</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(secondTaskCallOrder</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(firstTaskCallOrder</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(secondTaskCallOrder</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(hostFunctionCallCount_</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">scheduleTwoTasksWithDifferentPriorities) {</span>
  <span class="s1">uint lowPriorityTaskCallOrder = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">callbackOne = createHostFunctionFromLambda(</span>
      <span class="s1">[</span><span class="s4">this, </span><span class="s1">&amp;lowPriorityTaskCallOrder](</span><span class="s4">bool </span><span class="s0">/*unused*/</span><span class="s1">) {</span>
        <span class="s1">lowPriorityTaskCallOrder = hostFunctionCallCount_</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
      <span class="s1">SchedulerPriority::LowPriority</span><span class="s4">, </span><span class="s1">std::move(callbackOne))</span><span class="s4">;</span>

  <span class="s1">uint userBlockingPriorityTaskCallOrder</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">callbackTwo = createHostFunctionFromLambda(</span>
      <span class="s1">[</span><span class="s4">this, </span><span class="s1">&amp;userBlockingPriorityTaskCallOrder](</span><span class="s4">bool </span><span class="s0">/*unused*/</span><span class="s1">) {</span>
        <span class="s1">userBlockingPriorityTaskCallOrder = hostFunctionCallCount_</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
      <span class="s1">SchedulerPriority::UserBlockingPriority</span><span class="s4">, </span><span class="s1">std::move(callbackTwo))</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(lowPriorityTaskCallOrder</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(userBlockingPriorityTaskCallOrder</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(lowPriorityTaskCallOrder</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(userBlockingPriorityTaskCallOrder</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(hostFunctionCallCount_</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">cancelTask) {</span>
  <span class="s4">bool </span><span class="s1">didRunTask = </span><span class="s4">false;</span>
  <span class="s4">auto </span><span class="s1">callback = createHostFunctionFromLambda([&amp;didRunTask](</span><span class="s4">bool </span><span class="s0">/*unused*/</span><span class="s1">) {</span>
    <span class="s1">didRunTask = </span><span class="s4">true;</span>
    <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">task = runtimeScheduler_-&gt;scheduleTask(</span>
      <span class="s1">SchedulerPriority::NormalPriority</span><span class="s4">, </span><span class="s1">std::move(callback))</span><span class="s4">;</span>

  <span class="s1">EXPECT_FALSE(didRunTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;cancelTask(*task)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">EXPECT_FALSE(didRunTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">continuationTask) {</span>
  <span class="s4">bool </span><span class="s1">didRunTask = </span><span class="s4">false;</span>
  <span class="s4">bool </span><span class="s1">didContinuationTask = </span><span class="s4">false;</span>

  <span class="s4">auto </span><span class="s1">callback = createHostFunctionFromLambda([&amp;](</span><span class="s4">bool </span><span class="s0">/*unused*/</span><span class="s1">) {</span>
    <span class="s1">didRunTask = </span><span class="s4">true;</span>
    <span class="s4">return </span><span class="s1">jsi::Function::createFromHostFunction(</span>
        <span class="s1">*runtime_</span><span class="s4">,</span>
        <span class="s1">jsi::PropNameID::forUtf8(*runtime_</span><span class="s4">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s4">,</span>
        <span class="s5">1</span><span class="s4">,</span>
        <span class="s1">[&amp;](jsi::Runtime &amp; </span><span class="s0">/*runtime*/</span><span class="s4">,</span>
            <span class="s1">jsi::Value </span><span class="s4">const </span><span class="s1">&amp; </span><span class="s0">/*unused*/</span><span class="s4">,</span>
            <span class="s1">jsi::Value </span><span class="s4">const </span><span class="s1">* </span><span class="s0">/*arguments*/</span><span class="s4">,</span>
            <span class="s1">size_t </span><span class="s0">/*unused*/</span><span class="s1">) </span><span class="s4">noexcept </span><span class="s1">-&gt; jsi::Value {</span>
          <span class="s1">didContinuationTask = </span><span class="s4">true;</span>
          <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
        <span class="s1">})</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">task = runtimeScheduler_-&gt;scheduleTask(</span>
      <span class="s1">SchedulerPriority::NormalPriority</span><span class="s4">, </span><span class="s1">std::move(callback))</span><span class="s4">;</span>

  <span class="s1">EXPECT_FALSE(didRunTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(didRunTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(didContinuationTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">getCurrentPriorityLevel) {</span>
  <span class="s4">auto </span><span class="s1">callback =</span>
      <span class="s1">createHostFunctionFromLambda([</span><span class="s4">this</span><span class="s1">](</span><span class="s4">bool </span><span class="s0">/*didUserCallbackTimeout*/</span><span class="s1">) {</span>
        <span class="s1">EXPECT_EQ(</span>
            <span class="s1">runtimeScheduler_-&gt;getCurrentPriorityLevel()</span><span class="s4">,</span>
            <span class="s1">SchedulerPriority::ImmediatePriority)</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(</span>
      <span class="s1">runtimeScheduler_-&gt;getCurrentPriorityLevel()</span><span class="s4">,</span>
      <span class="s1">SchedulerPriority::NormalPriority)</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
      <span class="s1">SchedulerPriority::ImmediatePriority</span><span class="s4">, </span><span class="s1">std::move(callback))</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(</span>
      <span class="s1">runtimeScheduler_-&gt;getCurrentPriorityLevel()</span><span class="s4">,</span>
      <span class="s1">SchedulerPriority::NormalPriority)</span><span class="s4">;</span>

  <span class="s1">callback =</span>
      <span class="s1">createHostFunctionFromLambda([</span><span class="s4">this</span><span class="s1">](</span><span class="s4">bool </span><span class="s0">/*didUserCallbackTimeout*/</span><span class="s1">) {</span>
        <span class="s1">EXPECT_EQ(</span>
            <span class="s1">runtimeScheduler_-&gt;getCurrentPriorityLevel()</span><span class="s4">,</span>
            <span class="s1">SchedulerPriority::IdlePriority)</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
      <span class="s1">SchedulerPriority::IdlePriority</span><span class="s4">, </span><span class="s1">std::move(callback))</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(</span>
      <span class="s1">runtimeScheduler_-&gt;getCurrentPriorityLevel()</span><span class="s4">,</span>
      <span class="s1">SchedulerPriority::NormalPriority)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">scheduleWorkWithYielding) {</span>
  <span class="s4">bool </span><span class="s1">wasCalled = </span><span class="s4">false;</span>
  <span class="s1">runtimeScheduler_-&gt;scheduleWork(</span>
      <span class="s1">[&amp;](jsi::Runtime </span><span class="s4">const </span><span class="s1">&amp; </span><span class="s0">/*unused*/</span><span class="s1">) { wasCalled = </span><span class="s4">true; </span><span class="s1">})</span><span class="s4">;</span>

  <span class="s1">EXPECT_FALSE(wasCalled)</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(runtimeScheduler_-&gt;getShouldYield())</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(wasCalled)</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(runtimeScheduler_-&gt;getShouldYield())</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">normalTaskYieldsToPlatformEvent) {</span>
  <span class="s4">bool </span><span class="s1">didRunJavaScriptTask = </span><span class="s4">false;</span>
  <span class="s4">bool </span><span class="s1">didRunPlatformWork = </span><span class="s4">false;</span>

  <span class="s4">auto </span><span class="s1">callback = createHostFunctionFromLambda([&amp;](</span><span class="s4">bool </span><span class="s0">/*unused*/</span><span class="s1">) {</span>
    <span class="s1">didRunJavaScriptTask = </span><span class="s4">true;</span>
    <span class="s1">EXPECT_TRUE(didRunPlatformWork)</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
      <span class="s1">SchedulerPriority::NormalPriority</span><span class="s4">, </span><span class="s1">std::move(callback))</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleWork([&amp;](jsi::Runtime </span><span class="s4">const </span><span class="s1">&amp; </span><span class="s0">/*unused*/</span><span class="s1">) {</span>
    <span class="s1">didRunPlatformWork = </span><span class="s4">true;</span>
    <span class="s1">EXPECT_FALSE(didRunJavaScriptTask)</span><span class="s4">;</span>
    <span class="s1">EXPECT_FALSE(runtimeScheduler_-&gt;getShouldYield())</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(runtimeScheduler_-&gt;getShouldYield())</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;flush()</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">expiredTaskDoesntYieldToPlatformEvent) {</span>
  <span class="s4">bool </span><span class="s1">didRunJavaScriptTask = </span><span class="s4">false;</span>
  <span class="s4">bool </span><span class="s1">didRunPlatformWork = </span><span class="s4">false;</span>

  <span class="s4">auto </span><span class="s1">callback = createHostFunctionFromLambda([&amp;](</span><span class="s4">bool </span><span class="s0">/*unused*/</span><span class="s1">) {</span>
    <span class="s1">didRunJavaScriptTask = </span><span class="s4">true;</span>
    <span class="s1">EXPECT_FALSE(didRunPlatformWork)</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
      <span class="s1">SchedulerPriority::NormalPriority</span><span class="s4">, </span><span class="s1">std::move(callback))</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleWork([&amp;](jsi::Runtime </span><span class="s4">const </span><span class="s1">&amp; </span><span class="s0">/*unused*/</span><span class="s1">) {</span>
    <span class="s1">didRunPlatformWork = </span><span class="s4">true;</span>
    <span class="s1">EXPECT_TRUE(didRunJavaScriptTask)</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(runtimeScheduler_-&gt;getShouldYield())</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubClock_-&gt;advanceTimeBy(</span><span class="s5">6</span><span class="s1">s)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;flush()</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">immediateTaskDoesntYieldToPlatformEvent) {</span>
  <span class="s4">bool </span><span class="s1">didRunJavaScriptTask = </span><span class="s4">false;</span>
  <span class="s4">bool </span><span class="s1">didRunPlatformWork = </span><span class="s4">false;</span>

  <span class="s4">auto </span><span class="s1">callback = createHostFunctionFromLambda([&amp;](</span><span class="s4">bool </span><span class="s0">/*unused*/</span><span class="s1">) {</span>
    <span class="s1">didRunJavaScriptTask = </span><span class="s4">true;</span>
    <span class="s1">EXPECT_FALSE(didRunPlatformWork)</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
      <span class="s1">SchedulerPriority::ImmediatePriority</span><span class="s4">, </span><span class="s1">std::move(callback))</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleWork([&amp;](jsi::Runtime </span><span class="s4">const </span><span class="s1">&amp; </span><span class="s0">/*unused*/</span><span class="s1">) {</span>
    <span class="s1">didRunPlatformWork = </span><span class="s4">true;</span>
    <span class="s1">EXPECT_TRUE(didRunJavaScriptTask)</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(runtimeScheduler_-&gt;getShouldYield())</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;flush()</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">scheduleTaskFromTask) {</span>
  <span class="s4">bool </span><span class="s1">didRunFirstTask = </span><span class="s4">false;</span>
  <span class="s4">bool </span><span class="s1">didRunSecondTask = </span><span class="s4">false;</span>
  <span class="s4">auto </span><span class="s1">firstCallback = createHostFunctionFromLambda(</span>
      <span class="s1">[</span><span class="s4">this, </span><span class="s1">&amp;didRunFirstTask</span><span class="s4">, </span><span class="s1">&amp;didRunSecondTask](</span><span class="s4">bool </span><span class="s1">didUserCallbackTimeout) {</span>
        <span class="s1">didRunFirstTask = </span><span class="s4">true;</span>
        <span class="s1">EXPECT_FALSE(didUserCallbackTimeout)</span><span class="s4">;</span>

        <span class="s4">auto </span><span class="s1">secondCallback = createHostFunctionFromLambda(</span>
            <span class="s1">[&amp;didRunSecondTask](</span><span class="s4">bool </span><span class="s1">didUserCallbackTimeout) {</span>
              <span class="s1">didRunSecondTask = </span><span class="s4">true;</span>
              <span class="s1">EXPECT_TRUE(didUserCallbackTimeout)</span><span class="s4">;</span>
              <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
            <span class="s1">})</span><span class="s4">;</span>

        <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
            <span class="s1">SchedulerPriority::ImmediatePriority</span><span class="s4">, </span><span class="s1">std::move(secondCallback))</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
      <span class="s1">SchedulerPriority::NormalPriority</span><span class="s4">, </span><span class="s1">std::move(firstCallback))</span><span class="s4">;</span>

  <span class="s1">EXPECT_FALSE(didRunFirstTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(didRunSecondTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(didRunFirstTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(didRunSecondTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">handlingError) {</span>
  <span class="s4">bool </span><span class="s1">didRunTask = </span><span class="s4">false;</span>
  <span class="s4">auto </span><span class="s1">firstCallback =</span>
      <span class="s1">createHostFunctionFromLambda([</span><span class="s4">this, </span><span class="s1">&amp;didRunTask](</span><span class="s4">bool </span><span class="s0">/*unused*/</span><span class="s1">) {</span>
        <span class="s1">didRunTask = </span><span class="s4">true;</span>
        <span class="s4">throw </span><span class="s1">jsi::JSError(*runtime_</span><span class="s4">, </span><span class="s3">&quot;Test error&quot;</span><span class="s1">)</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
      <span class="s1">SchedulerPriority::NormalPriority</span><span class="s4">, </span><span class="s1">std::move(firstCallback))</span><span class="s4">;</span>

  <span class="s1">EXPECT_FALSE(didRunTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(didRunTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubErrorUtils_-&gt;getReportFatalCallCount()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">basicSameThreadExecution) {</span>
  <span class="s4">bool </span><span class="s1">didRunSynchronousTask = </span><span class="s4">false;</span>
  <span class="s1">std::thread t1([</span><span class="s4">this, </span><span class="s1">&amp;didRunSynchronousTask]() {</span>
    <span class="s1">runtimeScheduler_-&gt;executeNowOnTheSameThread(</span>
        <span class="s1">[</span><span class="s4">this, </span><span class="s1">&amp;didRunSynchronousTask](jsi::Runtime &amp; </span><span class="s0">/*rt*/</span><span class="s1">) {</span>
          <span class="s1">EXPECT_TRUE(runtimeScheduler_-&gt;getIsSynchronous())</span><span class="s4">;</span>
          <span class="s1">didRunSynchronousTask = </span><span class="s4">true;</span>
        <span class="s1">})</span><span class="s4">;</span>
    <span class="s1">EXPECT_FALSE(runtimeScheduler_-&gt;getIsSynchronous())</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">hasTask = stubQueue_-&gt;waitForTask(</span><span class="s5">1</span><span class="s1">ms)</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(hasTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(didRunSynchronousTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">t1.join()</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(didRunSynchronousTask)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">sameThreadTaskCreatesImmediatePriorityTask) {</span>
  <span class="s4">bool </span><span class="s1">didRunSynchronousTask = </span><span class="s4">false;</span>
  <span class="s4">bool </span><span class="s1">didRunSubsequentTask = </span><span class="s4">false;</span>
  <span class="s1">std::thread t1([</span><span class="s4">this, </span><span class="s1">&amp;didRunSynchronousTask</span><span class="s4">, </span><span class="s1">&amp;didRunSubsequentTask]() {</span>
    <span class="s1">runtimeScheduler_-&gt;executeNowOnTheSameThread(</span>
        <span class="s1">[</span><span class="s4">this, </span><span class="s1">&amp;didRunSynchronousTask</span><span class="s4">, </span><span class="s1">&amp;didRunSubsequentTask](</span>
            <span class="s1">jsi::Runtime &amp;runtime) {</span>
          <span class="s1">didRunSynchronousTask = </span><span class="s4">true;</span>

          <span class="s4">auto </span><span class="s1">callback = createHostFunctionFromLambda(</span>
              <span class="s1">[&amp;didRunSubsequentTask](</span><span class="s4">bool </span><span class="s1">didUserCallbackTimeout) {</span>
                <span class="s1">didRunSubsequentTask = </span><span class="s4">true;</span>
                <span class="s1">EXPECT_TRUE(didUserCallbackTimeout)</span><span class="s4">;</span>
                <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
              <span class="s1">})</span><span class="s4">;</span>

          <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
              <span class="s1">SchedulerPriority::ImmediatePriority</span><span class="s4">, </span><span class="s1">std::move(callback))</span><span class="s4">;</span>

          <span class="s1">runtimeScheduler_-&gt;callExpiredTasks(runtime)</span><span class="s4">;</span>
        <span class="s1">})</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">hasTask = stubQueue_-&gt;waitForTask(</span><span class="s5">1</span><span class="s1">ms)</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(hasTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(didRunSynchronousTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(didRunSubsequentTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">t1.join()</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(didRunSynchronousTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(didRunSubsequentTask)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">sameThreadTaskCreatesLowPriorityTask) {</span>
  <span class="s4">bool </span><span class="s1">didRunSynchronousTask = </span><span class="s4">false;</span>
  <span class="s4">bool </span><span class="s1">didRunSubsequentTask = </span><span class="s4">false;</span>
  <span class="s1">std::thread t1([</span><span class="s4">this, </span><span class="s1">&amp;didRunSynchronousTask</span><span class="s4">, </span><span class="s1">&amp;didRunSubsequentTask]() {</span>
    <span class="s1">runtimeScheduler_-&gt;executeNowOnTheSameThread(</span>
        <span class="s1">[</span><span class="s4">this, </span><span class="s1">&amp;didRunSynchronousTask</span><span class="s4">, </span><span class="s1">&amp;didRunSubsequentTask](</span>
            <span class="s1">jsi::Runtime &amp;runtime) {</span>
          <span class="s1">didRunSynchronousTask = </span><span class="s4">true;</span>

          <span class="s4">auto </span><span class="s1">callback = createHostFunctionFromLambda(</span>
              <span class="s1">[&amp;didRunSubsequentTask](</span><span class="s4">bool </span><span class="s1">didUserCallbackTimeout) {</span>
                <span class="s1">didRunSubsequentTask = </span><span class="s4">true;</span>
                <span class="s1">EXPECT_FALSE(didUserCallbackTimeout)</span><span class="s4">;</span>
                <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
              <span class="s1">})</span><span class="s4">;</span>

          <span class="s1">runtimeScheduler_-&gt;scheduleTask(</span>
              <span class="s1">SchedulerPriority::LowPriority</span><span class="s4">, </span><span class="s1">std::move(callback))</span><span class="s4">;</span>
          <span class="s1">runtimeScheduler_-&gt;callExpiredTasks(runtime)</span><span class="s4">;</span>

          <span class="s1">EXPECT_FALSE(didRunSubsequentTask)</span><span class="s4">;</span>
        <span class="s1">})</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">hasTask = stubQueue_-&gt;waitForTask(</span><span class="s5">1</span><span class="s1">ms)</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(hasTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(didRunSynchronousTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(didRunSubsequentTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">t1.join()</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(didRunSynchronousTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(didRunSubsequentTask)</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(didRunSubsequentTask)</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_F(RuntimeSchedulerTest</span><span class="s4">, </span><span class="s1">twoThreadsRequestAccessToTheRuntime) {</span>
  <span class="s4">bool </span><span class="s1">didRunSynchronousTask = </span><span class="s4">false;</span>
  <span class="s4">bool </span><span class="s1">didRunWork = </span><span class="s4">false;</span>

  <span class="s1">runtimeScheduler_-&gt;scheduleWork(</span>
      <span class="s1">[&amp;didRunWork](jsi::Runtime &amp; </span><span class="s0">/*unused*/</span><span class="s1">) { didRunWork = </span><span class="s4">true; </span><span class="s1">})</span><span class="s4">;</span>

  <span class="s1">std::thread t1([</span><span class="s4">this, </span><span class="s1">&amp;didRunSynchronousTask]() {</span>
    <span class="s1">runtimeScheduler_-&gt;executeNowOnTheSameThread(</span>
        <span class="s1">[&amp;didRunSynchronousTask](jsi::Runtime &amp; </span><span class="s0">/*runtime*/</span><span class="s1">) {</span>
          <span class="s1">didRunSynchronousTask = </span><span class="s4">true;</span>
        <span class="s1">})</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">hasTask = stubQueue_-&gt;waitForTasks(</span><span class="s5">2</span><span class="s4">, </span><span class="s5">1</span><span class="s1">ms)</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(hasTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(didRunWork)</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(didRunSynchronousTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(runtimeScheduler_-&gt;getShouldYield())</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(didRunWork)</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(didRunSynchronousTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(runtimeScheduler_-&gt;getShouldYield())</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(stubQueue_-&gt;size()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">stubQueue_-&gt;tick()</span><span class="s4">;</span>

  <span class="s1">t1.join()</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(didRunWork)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(didRunSynchronousTask)</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(runtimeScheduler_-&gt;getShouldYield())</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">} </span><span class="s0">// namespace facebook::react</span>
</pre>
</body>
</html>
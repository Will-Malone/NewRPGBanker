<html>
<head>
<title>RCTUIManager.m</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RCTUIManager.m</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#import </span><span class="s3">&quot;RCTUIManager.h&quot;</span>

<span class="s2">#import </span><span class="s3">&lt;AVFoundation/AVFoundation.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTSurfacePresenterStub.h&gt;</span>

<span class="s2">#import </span><span class="s3">&quot;RCTAssert.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTBridge+Private.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTBridge.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTComponent.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTComponentData.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTConvert.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTDefines.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTEventDispatcherProtocol.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTLayoutAnimation.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTLayoutAnimationGroup.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTLog.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTModuleData.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTModuleMethod.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTProfile.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTRootContentView.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTRootShadowView.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTRootViewInternal.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTScrollableProtocol.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTShadowView+Internal.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTShadowView.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTSurfaceRootShadowView.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTSurfaceRootView.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTUIManagerObserverCoordinator.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTUIManagerUtils.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTUtils.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTView.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTViewManager.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;UIView+React.h&quot;</span>

<span class="s4">static void </span><span class="s1">RCTTraverseViewNodes(id&lt;RCTComponent&gt; view</span><span class="s4">, void </span><span class="s1">(^block)(id&lt;RCTComponent&gt;))</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(view.reactTag) {</span>
    <span class="s1">block(view)</span><span class="s4">;</span>

    <span class="s4">for </span><span class="s1">(id&lt;RCTComponent&gt; subview in view.reactSubviews) {</span>
      <span class="s1">RCTTraverseViewNodes(subview</span><span class="s4">, </span><span class="s1">block)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">NSString *RCTNativeIDRegistryKey(NSString *nativeID</span><span class="s4">, </span><span class="s1">NSNumber *rootTag)</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!nativeID || !rootTag) {</span>
    <span class="s4">return @</span><span class="s3">&quot;&quot;</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">[NSString stringWithFormat:</span><span class="s4">@</span><span class="s3">&quot;%@-%@&quot;</span><span class="s4">, </span><span class="s1">rootTag</span><span class="s4">, </span><span class="s1">nativeID]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">NSString *</span><span class="s4">const </span><span class="s1">RCTUIManagerWillUpdateViewsDueToContentSizeMultiplierChangeNotification =</span>
    <span class="s4">@</span><span class="s3">&quot;RCTUIManagerWillUpdateViewsDueToContentSizeMultiplierChangeNotification&quot;</span><span class="s4">;</span>

<span class="s4">@implementation </span><span class="s1">RCTUIManager {</span>
  <span class="s0">// Root views are only mutated on the shadow queue</span>
  <span class="s1">NSMutableSet&lt;NSNumber *&gt; *_rootViewTags</span><span class="s4">;</span>
  <span class="s1">NSMutableArray&lt;RCTViewManagerUIBlock&gt; *_pendingUIBlocks</span><span class="s4">;</span>

  <span class="s0">// Animation</span>
  <span class="s1">RCTLayoutAnimationGroup *_layoutAnimationGroup</span><span class="s4">; </span><span class="s0">// Main thread only</span>

  <span class="s1">NSMutableDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">RCTShadowView *&gt; *_shadowViewRegistry</span><span class="s4">; </span><span class="s0">// RCT thread only</span>
  <span class="s1">NSMutableDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *_viewRegistry</span><span class="s4">; </span><span class="s0">// Main thread only</span>
  <span class="s1">NSMapTable&lt;NSString *</span><span class="s4">, </span><span class="s1">UIView *&gt; *_nativeIDRegistry</span><span class="s4">;</span>

  <span class="s1">NSMapTable&lt;RCTShadowView *</span><span class="s4">, </span><span class="s1">NSArray&lt;NSString *&gt; *&gt; *_shadowViewsWithUpdatedProps</span><span class="s4">; </span><span class="s0">// UIManager queue only.</span>
  <span class="s1">NSHashTable&lt;RCTShadowView *&gt; *_shadowViewsWithUpdatedChildren</span><span class="s4">; </span><span class="s0">// UIManager queue only.</span>

  <span class="s0">// Keyed by viewName</span>
  <span class="s1">NSMutableDictionary *_componentDataByName</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">@synthesize </span><span class="s1">bridge = _bridge</span><span class="s4">;</span>
<span class="s4">@synthesize </span><span class="s1">moduleRegistry = _moduleRegistry</span><span class="s4">;</span>

<span class="s1">RCT_EXPORT_MODULE()</span>

<span class="s1">+ (BOOL)requiresMainQueueSetup</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)invalidate</span>
<span class="s1">{</span>
  <span class="s0">/** 
   * Called on the JS Thread since all modules are invalidated on the JS thread 
   */</span>

  <span class="s0">// This only accessed from the shadow queue</span>
  <span class="s1">_pendingUIBlocks = nil</span><span class="s4">;</span>

  <span class="s1">RCTExecuteOnMainQueue(^{</span>
    <span class="s1">RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways</span><span class="s4">, @</span><span class="s3">&quot;UIManager invalidate&quot;</span><span class="s4">, </span><span class="s1">nil)</span><span class="s4">;</span>
    <span class="s4">for </span><span class="s1">(NSNumber *rootViewTag in self-&gt;_rootViewTags) {</span>
      <span class="s1">UIView *rootView = self-&gt;_viewRegistry[rootViewTag]</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">([rootView conformsToProtocol:</span><span class="s4">@protocol</span><span class="s1">(RCTInvalidating)]) {</span>
        <span class="s1">[(id&lt;RCTInvalidating&gt;)rootView invalidate]</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">self-&gt;_rootViewTags = nil</span><span class="s4">;</span>
    <span class="s1">self-&gt;_shadowViewRegistry = nil</span><span class="s4">;</span>
    <span class="s1">self-&gt;_viewRegistry = nil</span><span class="s4">;</span>
    <span class="s1">self-&gt;_nativeIDRegistry = nil</span><span class="s4">;</span>
    <span class="s1">self-&gt;_bridge = nil</span><span class="s4">;</span>

    <span class="s1">[[NSNotificationCenter defaultCenter] removeObserver:self]</span><span class="s4">;</span>
    <span class="s1">RCT_PROFILE_END_EVENT(RCTProfileTagAlways</span><span class="s4">, @</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSMutableDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">RCTShadowView *&gt; *)shadowViewRegistry</span>
<span class="s1">{</span>
  <span class="s0">// NOTE: this method only exists so that it can be accessed by unit tests</span>
  <span class="s4">if </span><span class="s1">(!_shadowViewRegistry) {</span>
    <span class="s1">_shadowViewRegistry = [NSMutableDictionary new]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">_shadowViewRegistry</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSMutableDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *)viewRegistry</span>
<span class="s1">{</span>
  <span class="s0">// NOTE: this method only exists so that it can be accessed by unit tests</span>
  <span class="s4">if </span><span class="s1">(!_viewRegistry) {</span>
    <span class="s1">_viewRegistry = [NSMutableDictionary new]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">_viewRegistry</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSMapTable *)nativeIDRegistry</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!_nativeIDRegistry) {</span>
    <span class="s1">_nativeIDRegistry = [NSMapTable strongToWeakObjectsMapTable]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">_nativeIDRegistry</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setBridge:(RCTBridge *)bridge</span>
<span class="s1">{</span>
  <span class="s1">RCTEnforceNewArchitectureValidation(</span>
      <span class="s1">RCTNotAllowedInBridgeless</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, @</span><span class="s3">&quot;RCTUIManager must not be initialized for the new architecture&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">RCTAssert(_bridge == nil</span><span class="s4">, @</span><span class="s3">&quot;Should not re-use same UIManager instance&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">_bridge = bridge</span><span class="s4">;</span>

  <span class="s1">_shadowViewRegistry = [NSMutableDictionary new]</span><span class="s4">;</span>
  <span class="s1">_viewRegistry = [NSMutableDictionary new]</span><span class="s4">;</span>
  <span class="s1">_nativeIDRegistry = [NSMapTable strongToWeakObjectsMapTable]</span><span class="s4">;</span>

  <span class="s1">_shadowViewsWithUpdatedProps = [NSMapTable weakToStrongObjectsMapTable]</span><span class="s4">;</span>
  <span class="s1">_shadowViewsWithUpdatedChildren = [NSHashTable weakObjectsHashTable]</span><span class="s4">;</span>

  <span class="s0">// Internal resources</span>
  <span class="s1">_pendingUIBlocks = [NSMutableArray new]</span><span class="s4">;</span>
  <span class="s1">_rootViewTags = [NSMutableSet new]</span><span class="s4">;</span>

  <span class="s1">_observerCoordinator = [RCTUIManagerObserverCoordinator new]</span><span class="s4">;</span>

  <span class="s0">// Get view managers from bridge=</span>
  <span class="s1">_componentDataByName = [NSMutableDictionary new]</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(Class moduleClass in _bridge.moduleClasses) {</span>
    <span class="s4">if </span><span class="s1">([moduleClass isSubclassOfClass:[RCTViewManager </span><span class="s4">class</span><span class="s1">]]) {</span>
      <span class="s1">RCTComponentData *componentData = [[RCTComponentData alloc] initWithManagerClass:moduleClass</span>
                                                                                <span class="s1">bridge:_bridge</span>
                                                                       <span class="s1">eventDispatcher:_bridge.eventDispatcher]</span><span class="s4">;</span>
      <span class="s1">_componentDataByName[componentData.name] = componentData</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// This dispatch_async avoids a deadlock while configuring native modules</span>
  <span class="s1">dispatch_async(dispatch_get_main_queue()</span><span class="s4">, </span><span class="s1">^{</span>
    <span class="s1">[[NSNotificationCenter defaultCenter] addObserver:self</span>
                                             <span class="s4">selector</span><span class="s1">:</span><span class="s4">@selector</span><span class="s1">(didReceiveNewContentSizeMultiplier)</span>
                                                 <span class="s1">name:</span><span class="s4">@</span><span class="s3">&quot;RCTAccessibilityManagerDidUpdateMultiplierNotification&quot;</span>
                                               <span class="s1">object:[self-&gt;_bridge moduleForName:</span><span class="s4">@</span><span class="s3">&quot;AccessibilityManager&quot;</span>
                                                             <span class="s1">lazilyLoadIfNecessary:YES]]</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>
  <span class="s1">[[NSNotificationCenter defaultCenter] addObserver:self</span>
                                           <span class="s4">selector</span><span class="s1">:</span><span class="s4">@selector</span><span class="s1">(namedOrientationDidChange)</span>
                                               <span class="s1">name:UIDeviceOrientationDidChangeNotification</span>
                                             <span class="s1">object:nil]</span><span class="s4">;</span>
  <span class="s1">[RCTLayoutAnimation initializeStatics]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Event emitting</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)didReceiveNewContentSizeMultiplier</span>
<span class="s1">{</span>
  <span class="s0">// Report the event across the bridge.</span>
<span class="s2">#pragma </span><span class="s1">clang diagnostic push</span>
<span class="s2">#pragma </span><span class="s1">clang diagnostic ignored </span><span class="s3">&quot;-Wdeprecated-declarations&quot;</span>
  <span class="s1">id multiplier = [[self-&gt;_bridge moduleForName:</span><span class="s4">@</span><span class="s3">&quot;AccessibilityManager&quot;</span>
                          <span class="s1">lazilyLoadIfNecessary:YES] valueForKey:</span><span class="s4">@</span><span class="s3">&quot;multiplier&quot;</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(multiplier) {</span>
    <span class="s1">[[_moduleRegistry moduleForName:</span><span class="s3">&quot;EventDispatcher&quot;</span><span class="s1">] sendDeviceEventWithName:</span><span class="s4">@</span><span class="s3">&quot;didUpdateContentSizeMultiplier&quot;</span>
                                                                          <span class="s1">body:multiplier]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s2">#pragma </span><span class="s1">clang diagnostic pop</span>

  <span class="s1">RCTExecuteOnUIManagerQueue(^{</span>
    <span class="s1">[[NSNotificationCenter defaultCenter]</span>
        <span class="s1">postNotificationName:RCTUIManagerWillUpdateViewsDueToContentSizeMultiplierChangeNotification</span>
                      <span class="s1">object:self]</span><span class="s4">;</span>
    <span class="s1">[self setNeedsLayout]</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">// Names and coordinate system from html5 spec:</span>
<span class="s0">// https://developer.mozilla.org/en-US/docs/Web/API/Screen.orientation</span>
<span class="s0">// https://developer.mozilla.org/en-US/docs/Web/API/Screen.lockOrientation</span>
<span class="s4">static </span><span class="s1">NSDictionary *deviceOrientationEventBody(UIDeviceOrientation orientation)</span>
<span class="s1">{</span>
  <span class="s1">NSString *name</span><span class="s4">;</span>
  <span class="s1">NSNumber *degrees = </span><span class="s4">@</span><span class="s5">0</span><span class="s4">;</span>
  <span class="s1">BOOL isLandscape = NO</span><span class="s4">;</span>
  <span class="s4">switch </span><span class="s1">(orientation) {</span>
    <span class="s4">case </span><span class="s1">UIDeviceOrientationPortrait:</span>
      <span class="s1">name = </span><span class="s4">@</span><span class="s3">&quot;portrait-primary&quot;</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s4">case </span><span class="s1">UIDeviceOrientationPortraitUpsideDown:</span>
      <span class="s1">name = </span><span class="s4">@</span><span class="s3">&quot;portrait-secondary&quot;</span><span class="s4">;</span>
      <span class="s1">degrees = </span><span class="s4">@</span><span class="s5">180</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s4">case </span><span class="s1">UIDeviceOrientationLandscapeRight:</span>
      <span class="s1">name = </span><span class="s4">@</span><span class="s3">&quot;landscape-primary&quot;</span><span class="s4">;</span>
      <span class="s1">degrees = </span><span class="s4">@</span><span class="s1">-</span><span class="s5">90</span><span class="s4">;</span>
      <span class="s1">isLandscape = YES</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s4">case </span><span class="s1">UIDeviceOrientationLandscapeLeft:</span>
      <span class="s1">name = </span><span class="s4">@</span><span class="s3">&quot;landscape-secondary&quot;</span><span class="s4">;</span>
      <span class="s1">degrees = </span><span class="s4">@</span><span class="s5">90</span><span class="s4">;</span>
      <span class="s1">isLandscape = YES</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s4">case </span><span class="s1">UIDeviceOrientationFaceDown:</span>
    <span class="s4">case </span><span class="s1">UIDeviceOrientationFaceUp:</span>
    <span class="s4">case </span><span class="s1">UIDeviceOrientationUnknown:</span>
      <span class="s0">// Unsupported</span>
      <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return @</span><span class="s1">{</span>
    <span class="s4">@</span><span class="s3">&quot;name&quot; </span><span class="s1">: name</span><span class="s4">,</span>
    <span class="s4">@</span><span class="s3">&quot;rotationDegrees&quot; </span><span class="s1">: degrees</span><span class="s4">,</span>
    <span class="s4">@</span><span class="s3">&quot;isLandscape&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">(isLandscape)</span><span class="s4">,</span>
  <span class="s1">}</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)namedOrientationDidChange</span>
<span class="s1">{</span>
  <span class="s1">NSDictionary *orientationEvent = deviceOrientationEventBody([UIDevice currentDevice].orientation)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!orientationEvent) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">clang diagnostic push</span>
<span class="s2">#pragma </span><span class="s1">clang diagnostic ignored </span><span class="s3">&quot;-Wdeprecated-declarations&quot;</span>
  <span class="s1">[[_moduleRegistry moduleForName:</span><span class="s3">&quot;EventDispatcher&quot;</span><span class="s1">] sendDeviceEventWithName:</span><span class="s4">@</span><span class="s3">&quot;namedOrientationDidChange&quot;</span>
                                                                        <span class="s1">body:orientationEvent]</span><span class="s4">;</span>
<span class="s2">#pragma </span><span class="s1">clang diagnostic pop</span>
<span class="s1">}</span>

<span class="s1">- (dispatch_queue_t)methodQueue</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">RCTGetUIManagerQueue()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)registerRootViewTag:(NSNumber *)rootTag</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertUIManagerQueue()</span><span class="s4">;</span>

  <span class="s1">RCTAssert(RCTIsReactRootView(rootTag)</span><span class="s4">, @</span><span class="s3">&quot;Attempt to register rootTag (%@) which is not actually root tag.&quot;</span><span class="s4">, </span><span class="s1">rootTag)</span><span class="s4">;</span>

  <span class="s1">RCTAssert(</span>
      <span class="s1">![_rootViewTags containsObject:rootTag]</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;Attempt to register rootTag (%@) which was already registered.&quot;</span><span class="s4">,</span>
      <span class="s1">rootTag)</span><span class="s4">;</span>

  <span class="s1">[_rootViewTags addObject:rootTag]</span><span class="s4">;</span>

  <span class="s0">// Registering root shadow view</span>
  <span class="s1">RCTSurfaceRootShadowView *shadowView = [RCTSurfaceRootShadowView new]</span><span class="s4">;</span>
  <span class="s1">shadowView.reactTag = rootTag</span><span class="s4">;</span>
  <span class="s1">_shadowViewRegistry[rootTag] = shadowView</span><span class="s4">;</span>

  <span class="s0">// Registering root view</span>
  <span class="s1">RCTExecuteOnMainQueue(^{</span>
    <span class="s1">RCTSurfaceRootView *rootView = [RCTSurfaceRootView new]</span><span class="s4">;</span>
    <span class="s1">rootView.reactTag = rootTag</span><span class="s4">;</span>
    <span class="s1">self-&gt;_viewRegistry[rootTag] = rootView</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)registerRootView:(RCTRootContentView *)rootView</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertMainQueue()</span><span class="s4">;</span>

  <span class="s1">NSNumber *reactTag = rootView.reactTag</span><span class="s4">;</span>
  <span class="s1">RCTAssert(RCTIsReactRootView(reactTag)</span><span class="s4">, @</span><span class="s3">&quot;View %@ with tag #%@ is not a root view&quot;</span><span class="s4">, </span><span class="s1">rootView</span><span class="s4">, </span><span class="s1">reactTag)</span><span class="s4">;</span>

  <span class="s1">UIView *existingView = _viewRegistry[reactTag]</span><span class="s4">;</span>
  <span class="s1">RCTAssert(</span>
      <span class="s1">existingView == nil || existingView == rootView</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;Expect all root views to have unique tag. Added %@ twice&quot;</span><span class="s4">,</span>
      <span class="s1">reactTag)</span><span class="s4">;</span>

  <span class="s1">CGSize availableSize = rootView.availableSize</span><span class="s4">;</span>

  <span class="s0">// Register view</span>
  <span class="s1">_viewRegistry[reactTag] = rootView</span><span class="s4">;</span>

  <span class="s0">// Register shadow view</span>
  <span class="s1">RCTExecuteOnUIManagerQueue(^{</span>
    <span class="s4">if </span><span class="s1">(!self-&gt;_viewRegistry) {</span>
      <span class="s4">return;</span>
    <span class="s1">}</span>

    <span class="s1">RCTRootShadowView *shadowView = [RCTRootShadowView new]</span><span class="s4">;</span>
    <span class="s1">shadowView.availableSize = availableSize</span><span class="s4">;</span>
    <span class="s1">shadowView.reactTag = reactTag</span><span class="s4">;</span>
    <span class="s1">shadowView.viewName = NSStringFromClass([rootView </span><span class="s4">class</span><span class="s1">])</span><span class="s4">;</span>
    <span class="s1">self-&gt;_shadowViewRegistry[shadowView.reactTag] = shadowView</span><span class="s4">;</span>
    <span class="s1">[self-&gt;_rootViewTags addObject:reactTag]</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSString *)viewNameForReactTag:(NSNumber *)reactTag</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertUIManagerQueue()</span><span class="s4">;</span>
  <span class="s1">NSString *name = _shadowViewRegistry[reactTag].viewName</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(name) {</span>
    <span class="s4">return </span><span class="s1">name</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">__block UIView *view</span><span class="s4">;</span>
  <span class="s1">RCTUnsafeExecuteOnMainQueueSync(^{</span>
    <span class="s1">view = self-&gt;_viewRegistry[reactTag]</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>

<span class="s2">#pragma </span><span class="s1">clang diagnostic push</span>
<span class="s2">#pragma </span><span class="s1">clang diagnostic ignored </span><span class="s3">&quot;-Wundeclared-selector&quot;</span>

  <span class="s4">if </span><span class="s1">([view respondsToSelector:</span><span class="s4">@selector</span><span class="s1">(componentViewName_DO_NOT_USE_THIS_IS_BROKEN)]) {</span>
    <span class="s4">return </span><span class="s1">[view performSelector:</span><span class="s4">@selector</span><span class="s1">(componentViewName_DO_NOT_USE_THIS_IS_BROKEN)]</span><span class="s4">;</span>
  <span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">clang diagnostic pop</span>
  <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (UIView *)viewForReactTag:(NSNumber *)reactTag</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertMainQueue()</span><span class="s4">;</span>
  <span class="s1">UIView *view = [_bridge.surfacePresenter findComponentViewWithTag_DO_NOT_USE_DEPRECATED:reactTag.integerValue]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!view) {</span>
    <span class="s1">view = _viewRegistry[reactTag]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">view</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (RCTShadowView *)shadowViewForReactTag:(NSNumber *)reactTag</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertUIManagerQueue()</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">_shadowViewRegistry[reactTag]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_executeBlockWithShadowView:(</span><span class="s4">void </span><span class="s1">(^)(RCTShadowView *shadowView))block forTag:(NSNumber *)tag</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertMainQueue()</span><span class="s4">;</span>

  <span class="s1">RCTExecuteOnUIManagerQueue(^{</span>
    <span class="s1">RCTShadowView *shadowView = self-&gt;_shadowViewRegistry[tag]</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(shadowView == nil) {</span>
      <span class="s1">RCTLogInfo(</span>
          <span class="s4">@</span><span class="s3">&quot;Could not locate shadow view with tag #%@, this is probably caused by a temporary inconsistency between native views and shadow views.&quot;</span><span class="s4">,</span>
          <span class="s1">tag)</span><span class="s4">;</span>
      <span class="s4">return;</span>
    <span class="s1">}</span>

    <span class="s1">block(shadowView)</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setAvailableSize:(CGSize)availableSize forRootView:(UIView *)rootView</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertMainQueue()</span><span class="s4">;</span>
  <span class="s1">[self</span>
      <span class="s1">_executeBlockWithShadowView:^(RCTShadowView *shadowView) {</span>
        <span class="s1">RCTAssert(</span>
            <span class="s1">[shadowView isKindOfClass:[RCTRootShadowView </span><span class="s4">class</span><span class="s1">]]</span><span class="s4">, @</span><span class="s3">&quot;Located shadow view is actually not root view.&quot;</span><span class="s1">)</span><span class="s4">;</span>

        <span class="s1">RCTRootShadowView *rootShadowView = (RCTRootShadowView *)shadowView</span><span class="s4">;</span>

        <span class="s4">if </span><span class="s1">(CGSizeEqualToSize(availableSize</span><span class="s4">, </span><span class="s1">rootShadowView.availableSize)) {</span>
          <span class="s4">return;</span>
        <span class="s1">}</span>

        <span class="s1">rootShadowView.availableSize = availableSize</span><span class="s4">;</span>
        <span class="s1">[self setNeedsLayout]</span><span class="s4">;</span>
      <span class="s1">}</span>
                           <span class="s1">forTag:rootView.reactTag]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setLocalData:(NSObject *)localData forView:(UIView *)view</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertMainQueue()</span><span class="s4">;</span>
  <span class="s1">[self</span>
      <span class="s1">_executeBlockWithShadowView:^(RCTShadowView *shadowView) {</span>
        <span class="s1">shadowView.localData = localData</span><span class="s4">;</span>
        <span class="s1">[self setNeedsLayout]</span><span class="s4">;</span>
      <span class="s1">}</span>
                           <span class="s1">forTag:view.reactTag]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (UIView *)viewForNativeID:(NSString *)nativeID withRootTag:(NSNumber *)rootTag</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!nativeID || !rootTag) {</span>
    <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">UIView *view</span><span class="s4">;</span>
  <span class="s4">@synchronized</span><span class="s1">(self) {</span>
    <span class="s1">view = [_nativeIDRegistry objectForKey:RCTNativeIDRegistryKey(nativeID</span><span class="s4">, </span><span class="s1">rootTag)]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">view</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setNativeID:(NSString *)nativeID forView:(UIView *)view</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!nativeID || !view) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
  <span class="s4">__weak </span><span class="s1">RCTUIManager *weakSelf = self</span><span class="s4">;</span>
  <span class="s1">RCTExecuteOnUIManagerQueue(^{</span>
    <span class="s1">NSNumber *rootTag = [weakSelf shadowViewForReactTag:view.reactTag].rootView.reactTag</span><span class="s4">;</span>
    <span class="s4">@synchronized</span><span class="s1">(weakSelf) {</span>
      <span class="s1">[weakSelf.nativeIDRegistry setObject:view forKey:RCTNativeIDRegistryKey(nativeID</span><span class="s4">, </span><span class="s1">rootTag)]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setSize:(CGSize)size forView:(UIView *)view</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertMainQueue()</span><span class="s4">;</span>
  <span class="s1">[self</span>
      <span class="s1">_executeBlockWithShadowView:^(RCTShadowView *shadowView) {</span>
        <span class="s4">if </span><span class="s1">(CGSizeEqualToSize(size</span><span class="s4">, </span><span class="s1">shadowView.size)) {</span>
          <span class="s4">return;</span>
        <span class="s1">}</span>

        <span class="s1">shadowView.size = size</span><span class="s4">;</span>
        <span class="s1">[self setNeedsLayout]</span><span class="s4">;</span>
      <span class="s1">}</span>
                           <span class="s1">forTag:view.reactTag]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setIntrinsicContentSize:(CGSize)intrinsicContentSize forView:(UIView *)view</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertMainQueue()</span><span class="s4">;</span>
  <span class="s1">[self</span>
      <span class="s1">_executeBlockWithShadowView:^(RCTShadowView *shadowView) {</span>
        <span class="s4">if </span><span class="s1">(CGSizeEqualToSize(shadowView.intrinsicContentSize</span><span class="s4">, </span><span class="s1">intrinsicContentSize)) {</span>
          <span class="s4">return;</span>
        <span class="s1">}</span>

        <span class="s1">shadowView.intrinsicContentSize = intrinsicContentSize</span><span class="s4">;</span>
        <span class="s1">[self setNeedsLayout]</span><span class="s4">;</span>
      <span class="s1">}</span>
                           <span class="s1">forTag:view.reactTag]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Unregisters views from registries 
 */</span>
<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_purgeChildren:(NSArray&lt;id&lt;RCTComponent&gt;&gt; *)children</span>
          <span class="s1">fromRegistry:(NSMutableDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">id&lt;RCTComponent&gt;&gt; *)registry</span>
<span class="s1">{</span>
  <span class="s4">for </span><span class="s1">(id&lt;RCTComponent&gt; child in children) {</span>
    <span class="s1">RCTTraverseViewNodes(registry[child.reactTag]</span><span class="s4">, </span><span class="s1">^(id&lt;RCTComponent&gt; subview) {</span>
      <span class="s1">RCTAssert(![subview isReactRootView]</span><span class="s4">, @</span><span class="s3">&quot;Root views should not be unregistered&quot;</span><span class="s1">)</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">([subview conformsToProtocol:</span><span class="s4">@protocol</span><span class="s1">(RCTInvalidating)]) {</span>
        <span class="s1">[(id&lt;RCTInvalidating&gt;)subview invalidate]</span><span class="s4">;</span>
      <span class="s1">}</span>
      <span class="s1">[registry removeObjectForKey:subview.reactTag]</span><span class="s4">;</span>
    <span class="s1">})</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)addUIBlock:(RCTViewManagerUIBlock)block</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertUIManagerQueue()</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(!block || !_viewRegistry) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">[_pendingUIBlocks addObject:block]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)prependUIBlock:(RCTViewManagerUIBlock)block</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertUIManagerQueue()</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(!block || !_viewRegistry) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">[_pendingUIBlocks insertObject:block atIndex:</span><span class="s5">0</span><span class="s1">]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setNextLayoutAnimationGroup:(RCTLayoutAnimationGroup *)layoutAnimationGroup</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertMainQueue()</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(_layoutAnimationGroup &amp;&amp; ![_layoutAnimationGroup isEqual:layoutAnimationGroup]) {</span>
    <span class="s1">RCTLogWarn(</span>
        <span class="s4">@</span><span class="s3">&quot;Warning: Overriding previous layout animation with new one before the first began:</span><span class="s4">\n</span><span class="s3">%@ -&gt; %@.&quot;</span><span class="s4">,</span>
        <span class="s1">[_layoutAnimationGroup description]</span><span class="s4">,</span>
        <span class="s1">[layoutAnimationGroup description])</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">_layoutAnimationGroup = layoutAnimationGroup</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (RCTViewManagerUIBlock)uiBlockWithLayoutUpdateForRootView:(RCTRootShadowView *)rootShadowView</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertUIManagerQueue()</span><span class="s4">;</span>

  <span class="s1">NSHashTable&lt;RCTShadowView *&gt; *affectedShadowViews = [NSHashTable weakObjectsHashTable]</span><span class="s4">;</span>
  <span class="s1">[rootShadowView layoutWithAffectedShadowViews:affectedShadowViews]</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(!affectedShadowViews.count) {</span>
    <span class="s0">// no frame change results in no UI update block</span>
    <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">typedef struct </span><span class="s1">{</span>
    <span class="s1">CGRect frame</span><span class="s4">;</span>
    <span class="s1">UIUserInterfaceLayoutDirection layoutDirection</span><span class="s4">;</span>
    <span class="s1">BOOL isNew</span><span class="s4">;</span>
    <span class="s1">BOOL parentIsNew</span><span class="s4">;</span>
    <span class="s1">RCTDisplayType displayType</span><span class="s4">;</span>
  <span class="s1">} RCTFrameData</span><span class="s4">;</span>

  <span class="s0">// Construct arrays then hand off to main thread</span>
  <span class="s1">NSUInteger count = affectedShadowViews.count</span><span class="s4">;</span>
  <span class="s1">NSMutableArray *reactTags = [[NSMutableArray alloc] initWithCapacity:count]</span><span class="s4">;</span>
  <span class="s1">NSMutableData *framesData = [[NSMutableData alloc] initWithLength:</span><span class="s4">sizeof</span><span class="s1">(RCTFrameData) * count]</span><span class="s4">;</span>
  <span class="s1">{</span>
    <span class="s1">NSUInteger index = </span><span class="s5">0</span><span class="s4">;</span>
    <span class="s1">RCTFrameData *frameDataArray = (RCTFrameData *)framesData.mutableBytes</span><span class="s4">;</span>
    <span class="s4">for </span><span class="s1">(RCTShadowView *shadowView in affectedShadowViews) {</span>
      <span class="s1">reactTags[index] = shadowView.reactTag</span><span class="s4">;</span>
      <span class="s1">RCTLayoutMetrics layoutMetrics = shadowView.layoutMetrics</span><span class="s4">;</span>
      <span class="s1">frameDataArray[index++] = (RCTFrameData){</span>
          <span class="s1">layoutMetrics.frame</span><span class="s4">,</span>
          <span class="s1">layoutMetrics.layoutDirection</span><span class="s4">,</span>
          <span class="s1">shadowView.isNewView</span><span class="s4">,</span>
          <span class="s1">shadowView.superview.isNewView</span><span class="s4">,</span>
          <span class="s1">layoutMetrics.displayType}</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">for </span><span class="s1">(RCTShadowView *shadowView in affectedShadowViews) {</span>
    <span class="s0">// We have to do this after we build the parentsAreNew array.</span>
    <span class="s1">shadowView.newView = NO</span><span class="s4">;</span>

    <span class="s1">NSNumber *reactTag = shadowView.reactTag</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(shadowView.onLayout) {</span>
      <span class="s1">CGRect frame = shadowView.layoutMetrics.frame</span><span class="s4">;</span>
      <span class="s1">shadowView.onLayout(</span><span class="s4">@</span><span class="s1">{</span>
        <span class="s4">@</span><span class="s3">&quot;layout&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">{</span>
          <span class="s4">@</span><span class="s3">&quot;x&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">(frame.origin.x)</span><span class="s4">,</span>
          <span class="s4">@</span><span class="s3">&quot;y&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">(frame.origin.y)</span><span class="s4">,</span>
          <span class="s4">@</span><span class="s3">&quot;width&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">(frame.size.width)</span><span class="s4">,</span>
          <span class="s4">@</span><span class="s3">&quot;height&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">(frame.size.height)</span><span class="s4">,</span>
        <span class="s1">}</span><span class="s4">,</span>
      <span class="s1">})</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(RCTIsReactRootView(reactTag) &amp;&amp; [shadowView isKindOfClass:[RCTRootShadowView </span><span class="s4">class</span><span class="s1">]]) {</span>
      <span class="s1">CGSize contentSize = shadowView.layoutMetrics.frame.size</span><span class="s4">;</span>

      <span class="s1">RCTExecuteOnMainQueue(^{</span>
        <span class="s1">UIView *view = self-&gt;_viewRegistry[reactTag]</span><span class="s4">;</span>
        <span class="s1">RCTAssert(view != nil</span><span class="s4">, @</span><span class="s3">&quot;view (for ID %@) not found&quot;</span><span class="s4">, </span><span class="s1">reactTag)</span><span class="s4">;</span>

        <span class="s1">RCTRootView *rootView = (RCTRootView *)[view superview]</span><span class="s4">;</span>
        <span class="s4">if </span><span class="s1">([rootView isKindOfClass:[RCTRootView </span><span class="s4">class</span><span class="s1">]]) {</span>
          <span class="s1">rootView.intrinsicContentSize = contentSize</span><span class="s4">;</span>
        <span class="s1">}</span>
      <span class="s1">})</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Perform layout (possibly animated)</span>
  <span class="s4">return </span><span class="s1">^(__unused RCTUIManager *uiManager</span><span class="s4">, </span><span class="s1">NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *viewRegistry) {</span>
    <span class="s4">const </span><span class="s1">RCTFrameData *frameDataArray = (</span><span class="s4">const </span><span class="s1">RCTFrameData *)framesData.bytes</span><span class="s4">;</span>
    <span class="s1">RCTLayoutAnimationGroup *layoutAnimationGroup = uiManager-&gt;_layoutAnimationGroup</span><span class="s4">;</span>

    <span class="s1">__block NSUInteger completionsCalled = </span><span class="s5">0</span><span class="s4">;</span>

    <span class="s1">NSInteger index = </span><span class="s5">0</span><span class="s4">;</span>
    <span class="s4">for </span><span class="s1">(NSNumber *reactTag in reactTags) {</span>
      <span class="s1">RCTFrameData frameData = frameDataArray[index++]</span><span class="s4">;</span>

      <span class="s1">UIView *view = viewRegistry[reactTag]</span><span class="s4">;</span>
      <span class="s1">CGRect frame = frameData.frame</span><span class="s4">;</span>

      <span class="s1">UIUserInterfaceLayoutDirection layoutDirection = frameData.layoutDirection</span><span class="s4">;</span>
      <span class="s1">BOOL isNew = frameData.isNew</span><span class="s4">;</span>
      <span class="s1">RCTLayoutAnimation *updatingLayoutAnimation = isNew ? nil : layoutAnimationGroup.updatingLayoutAnimation</span><span class="s4">;</span>
      <span class="s1">BOOL shouldAnimateCreation = isNew &amp;&amp; !frameData.parentIsNew</span><span class="s4">;</span>
      <span class="s1">RCTLayoutAnimation *creatingLayoutAnimation =</span>
          <span class="s1">shouldAnimateCreation ? layoutAnimationGroup.creatingLayoutAnimation : nil</span><span class="s4">;</span>
      <span class="s1">BOOL isHidden = frameData.displayType == RCTDisplayTypeNone</span><span class="s4">;</span>

      <span class="s4">void </span><span class="s1">(^completion)(BOOL) = ^(BOOL finished) {</span>
        <span class="s1">completionsCalled++</span><span class="s4">;</span>
        <span class="s4">if </span><span class="s1">(layoutAnimationGroup.callback &amp;&amp; completionsCalled == count) {</span>
          <span class="s1">layoutAnimationGroup.callback(</span><span class="s4">@</span><span class="s1">[ </span><span class="s4">@</span><span class="s1">(finished) ])</span><span class="s4">;</span>

          <span class="s0">// It's unsafe to call this callback more than once, so we nil it out here</span>
          <span class="s0">// to make sure that doesn't happen.</span>
          <span class="s1">layoutAnimationGroup.callback = nil</span><span class="s4">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span><span class="s4">;</span>

      <span class="s4">if </span><span class="s1">(view.reactLayoutDirection != layoutDirection) {</span>
        <span class="s1">view.reactLayoutDirection = layoutDirection</span><span class="s4">;</span>
      <span class="s1">}</span>

      <span class="s4">if </span><span class="s1">(view.isHidden != isHidden) {</span>
        <span class="s1">view.hidden = isHidden</span><span class="s4">;</span>
      <span class="s1">}</span>

      <span class="s4">if </span><span class="s1">(creatingLayoutAnimation) {</span>
        <span class="s0">// Animate view creation</span>
        <span class="s1">[view reactSetFrame:frame]</span><span class="s4">;</span>

        <span class="s1">CATransform3D finalTransform = view.layer.transform</span><span class="s4">;</span>
        <span class="s1">CGFloat finalOpacity = view.layer.opacity</span><span class="s4">;</span>

        <span class="s1">NSString *</span><span class="s4">property </span><span class="s1">= creatingLayoutAnimation.</span><span class="s4">property;</span>
        <span class="s4">if </span><span class="s1">([</span><span class="s4">property </span><span class="s1">isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;scaleXY&quot;</span><span class="s1">]) {</span>
          <span class="s1">view.layer.transform = CATransform3DMakeScale(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
        <span class="s1">} </span><span class="s4">else if </span><span class="s1">([</span><span class="s4">property </span><span class="s1">isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;scaleX&quot;</span><span class="s1">]) {</span>
          <span class="s1">view.layer.transform = CATransform3DMakeScale(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
        <span class="s1">} </span><span class="s4">else if </span><span class="s1">([</span><span class="s4">property </span><span class="s1">isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;scaleY&quot;</span><span class="s1">]) {</span>
          <span class="s1">view.layer.transform = CATransform3DMakeScale(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
        <span class="s1">} </span><span class="s4">else if </span><span class="s1">([</span><span class="s4">property </span><span class="s1">isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;opacity&quot;</span><span class="s1">]) {</span>
          <span class="s1">view.layer.opacity = </span><span class="s5">0.0</span><span class="s4">;</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
          <span class="s1">RCTLogError(</span><span class="s4">@</span><span class="s3">&quot;Unsupported layout animation createConfig property %@&quot;</span><span class="s4">, </span><span class="s1">creatingLayoutAnimation.</span><span class="s4">property</span><span class="s1">)</span><span class="s4">;</span>
        <span class="s1">}</span>

        <span class="s1">[creatingLayoutAnimation</span>
              <span class="s1">performAnimations:^{</span>
                <span class="s4">if </span><span class="s1">([</span><span class="s4">property </span><span class="s1">isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;scaleX&quot;</span><span class="s1">] || [</span><span class="s4">property </span><span class="s1">isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;scaleY&quot;</span><span class="s1">] ||</span>
                    <span class="s1">[</span><span class="s4">property </span><span class="s1">isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;scaleXY&quot;</span><span class="s1">]) {</span>
                  <span class="s1">view.layer.transform = finalTransform</span><span class="s4">;</span>
                <span class="s1">} </span><span class="s4">else if </span><span class="s1">([</span><span class="s4">property </span><span class="s1">isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;opacity&quot;</span><span class="s1">]) {</span>
                  <span class="s1">view.layer.opacity = finalOpacity</span><span class="s4">;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">withCompletionBlock:completion]</span><span class="s4">;</span>

      <span class="s1">} </span><span class="s4">else if </span><span class="s1">(updatingLayoutAnimation) {</span>
        <span class="s0">// Animate view update</span>
        <span class="s1">[updatingLayoutAnimation</span>
              <span class="s1">performAnimations:^{</span>
                <span class="s1">[view reactSetFrame:frame]</span><span class="s4">;</span>
              <span class="s1">}</span>
            <span class="s1">withCompletionBlock:completion]</span><span class="s4">;</span>

      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s0">// Update without animation</span>
        <span class="s1">[view reactSetFrame:frame]</span><span class="s4">;</span>
        <span class="s1">completion(YES)</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// Clean up</span>
    <span class="s1">uiManager-&gt;_layoutAnimationGroup = nil</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * A method to be called from JS, which takes a container ID and then releases 
 * all subviews for that container upon receipt. 
 */</span>
<span class="s1">RCT_EXPORT_METHOD(removeSubviewsFromContainerWithID : (nonnull NSNumber *)containerID)</span>
<span class="s1">{</span>
  <span class="s1">RCTLogWarn(</span>
      <span class="s4">@</span><span class="s3">&quot;RCTUIManager.removeSubviewsFromContainerWithID method is deprecated and it will not be implemented in newer versions of RN (Fabric) - T47686450&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">id&lt;RCTComponent&gt; container = _shadowViewRegistry[containerID]</span><span class="s4">;</span>
  <span class="s1">RCTAssert(container != nil</span><span class="s4">, @</span><span class="s3">&quot;container view (for ID %@) not found&quot;</span><span class="s4">, </span><span class="s1">containerID)</span><span class="s4">;</span>

  <span class="s1">NSUInteger subviewsCount = [container reactSubviews].count</span><span class="s4">;</span>
  <span class="s1">NSMutableArray&lt;NSNumber *&gt; *indices = [[NSMutableArray alloc] initWithCapacity:subviewsCount]</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(NSUInteger childIndex = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">childIndex &lt; subviewsCount</span><span class="s4">; </span><span class="s1">childIndex++) {</span>
    <span class="s1">[indices addObject:</span><span class="s4">@</span><span class="s1">(childIndex)]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">[self manageChildren:containerID</span>
        <span class="s1">moveFromIndices:nil</span>
          <span class="s1">moveToIndices:nil</span>
      <span class="s1">addChildReactTags:nil</span>
           <span class="s1">addAtIndices:nil</span>
        <span class="s1">removeAtIndices:indices]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Disassociates children from container. Doesn't remove from registries. 
 * TODO: use [NSArray getObjects:buffer] to reuse same fast buffer each time. 
 * 
 * @returns Array of removed items. 
 */</span>
<span class="s1">- (NSArray&lt;id&lt;RCTComponent&gt;&gt; *)_childrenToRemoveFromContainer:(id&lt;RCTComponent&gt;)container</span>
                                                    <span class="s1">atIndices:(NSArray&lt;NSNumber *&gt; *)atIndices</span>
<span class="s1">{</span>
  <span class="s0">// If there are no indices to move or the container has no subviews don't bother</span>
  <span class="s0">// We support parents with nil subviews so long as they're all nil so this allows for this behavior</span>
  <span class="s4">if </span><span class="s1">(atIndices.count == </span><span class="s5">0 </span><span class="s1">|| [container reactSubviews].count == </span><span class="s5">0</span><span class="s1">) {</span>
    <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s0">// Construction of removed children must be done &quot;up front&quot;, before indices are disturbed by removals.</span>
  <span class="s1">NSMutableArray&lt;id&lt;RCTComponent&gt;&gt; *removedChildren = [NSMutableArray arrayWithCapacity:atIndices.count]</span><span class="s4">;</span>
  <span class="s1">RCTAssert(container != nil</span><span class="s4">, @</span><span class="s3">&quot;container view (for ID %@) not found&quot;</span><span class="s4">, </span><span class="s1">container)</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(NSNumber *indexNumber in atIndices) {</span>
    <span class="s1">NSUInteger index = indexNumber.unsignedIntegerValue</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(index &lt; [container reactSubviews].count) {</span>
      <span class="s1">[removedChildren addObject:[container reactSubviews][index]]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(removedChildren.count != atIndices.count) {</span>
    <span class="s1">NSString *message = [NSString stringWithFormat:</span><span class="s4">@</span><span class="s3">&quot;removedChildren count (%tu) was not what we expected (%tu)&quot;</span><span class="s4">,</span>
                                                   <span class="s1">removedChildren.count</span><span class="s4">,</span>
                                                   <span class="s1">atIndices.count]</span><span class="s4">;</span>
    <span class="s1">RCTFatal(RCTErrorWithMessage(message))</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">removedChildren</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_removeChildren:(NSArray&lt;id&lt;RCTComponent&gt;&gt; *)children fromContainer:(id&lt;RCTComponent&gt;)container</span>
<span class="s1">{</span>
  <span class="s4">for </span><span class="s1">(id&lt;RCTComponent&gt; removedChild in children) {</span>
    <span class="s1">[container removeReactSubview:removedChild]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Remove subviews from their parent with an animation. 
 */</span>
<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_removeChildren:(NSArray&lt;UIView *&gt; *)children</span>
          <span class="s1">fromContainer:(UIView *)container</span>
          <span class="s1">withAnimation:(RCTLayoutAnimationGroup *)animation</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertMainQueue()</span><span class="s4">;</span>
  <span class="s1">RCTLayoutAnimation *deletingLayoutAnimation = animation.deletingLayoutAnimation</span><span class="s4">;</span>

  <span class="s1">__block NSUInteger completionsCalled = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(UIView *removedChild in children) {</span>
    <span class="s4">void </span><span class="s1">(^completion)(BOOL) = ^(BOOL finished) {</span>
      <span class="s1">completionsCalled++</span><span class="s4">;</span>

      <span class="s1">[removedChild removeFromSuperview]</span><span class="s4">;</span>

      <span class="s4">if </span><span class="s1">(animation.callback &amp;&amp; completionsCalled == children.count) {</span>
        <span class="s1">animation.callback(</span><span class="s4">@</span><span class="s1">[ </span><span class="s4">@</span><span class="s1">(finished) ])</span><span class="s4">;</span>

        <span class="s0">// It's unsafe to call this callback more than once, so we nil it out here</span>
        <span class="s0">// to make sure that doesn't happen.</span>
        <span class="s1">animation.callback = nil</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s4">;</span>

    <span class="s0">// Hack: At this moment we have two contradict intents.</span>
    <span class="s0">// First one: We want to delete the view from view hierarchy.</span>
    <span class="s0">// Second one: We want to animate this view, which implies the existence of this view in the hierarchy.</span>
    <span class="s0">// So, we have to remove this view from React's view hierarchy but postpone removing from UIKit's hierarchy.</span>
    <span class="s0">// Here the problem: the default implementation of `-[UIView removeReactSubview:]` also removes the view from</span>
    <span class="s0">// UIKit's hierarchy. So, let's temporary restore the view back after removing. To do so, we have to memorize</span>
    <span class="s0">// original `superview` (which can differ from `container`) and an index of removed view.</span>
    <span class="s1">UIView *originalSuperview = removedChild.superview</span><span class="s4">;</span>
    <span class="s1">NSUInteger originalIndex = [originalSuperview.subviews indexOfObjectIdenticalTo:removedChild]</span><span class="s4">;</span>
    <span class="s1">[container removeReactSubview:removedChild]</span><span class="s4">;</span>
    <span class="s0">// Disable user interaction while the view is animating</span>
    <span class="s0">// since the view is (conceptually) deleted and not supposed to be interactive.</span>
    <span class="s1">removedChild.userInteractionEnabled = NO</span><span class="s4">;</span>
    <span class="s1">[originalSuperview insertSubview:removedChild atIndex:originalIndex]</span><span class="s4">;</span>

    <span class="s1">NSString *</span><span class="s4">property </span><span class="s1">= deletingLayoutAnimation.</span><span class="s4">property;</span>
    <span class="s1">[deletingLayoutAnimation</span>
          <span class="s1">performAnimations:^{</span>
            <span class="s4">if </span><span class="s1">([</span><span class="s4">property </span><span class="s1">isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;scaleXY&quot;</span><span class="s1">]) {</span>
              <span class="s1">removedChild.layer.transform = CATransform3DMakeScale(</span><span class="s5">0.001</span><span class="s4">, </span><span class="s5">0.001</span><span class="s4">, </span><span class="s5">0.001</span><span class="s1">)</span><span class="s4">;</span>
            <span class="s1">} </span><span class="s4">else if </span><span class="s1">([</span><span class="s4">property </span><span class="s1">isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;scaleX&quot;</span><span class="s1">]) {</span>
              <span class="s1">removedChild.layer.transform = CATransform3DMakeScale(</span><span class="s5">0.001</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">0.001</span><span class="s1">)</span><span class="s4">;</span>
            <span class="s1">} </span><span class="s4">else if </span><span class="s1">([</span><span class="s4">property </span><span class="s1">isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;scaleY&quot;</span><span class="s1">]) {</span>
              <span class="s1">removedChild.layer.transform = CATransform3DMakeScale(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">0.001</span><span class="s4">, </span><span class="s5">0.001</span><span class="s1">)</span><span class="s4">;</span>
            <span class="s1">} </span><span class="s4">else if </span><span class="s1">([</span><span class="s4">property </span><span class="s1">isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;opacity&quot;</span><span class="s1">]) {</span>
              <span class="s1">removedChild.layer.opacity = </span><span class="s5">0.0</span><span class="s4">;</span>
            <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
              <span class="s1">RCTLogError(</span><span class="s4">@</span><span class="s3">&quot;Unsupported layout animation createConfig property %@&quot;</span><span class="s4">, </span><span class="s1">deletingLayoutAnimation.</span><span class="s4">property</span><span class="s1">)</span><span class="s4">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">withCompletionBlock:completion]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_METHOD(removeRootView : (nonnull NSNumber *)rootReactTag)</span>
<span class="s1">{</span>
  <span class="s1">RCTShadowView *rootShadowView = _shadowViewRegistry[rootReactTag]</span><span class="s4">;</span>
  <span class="s1">RCTAssert(rootShadowView.superview == nil</span><span class="s4">, @</span><span class="s3">&quot;root view cannot have superview (ID %@)&quot;</span><span class="s4">, </span><span class="s1">rootReactTag)</span><span class="s4">;</span>
  <span class="s1">[self _purgeChildren:(NSArray&lt;id&lt;RCTComponent&gt;&gt; *)rootShadowView.reactSubviews</span>
          <span class="s1">fromRegistry:(NSMutableDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">id&lt;RCTComponent&gt;&gt; *)_shadowViewRegistry]</span><span class="s4">;</span>
  <span class="s1">[_shadowViewRegistry removeObjectForKey:rootReactTag]</span><span class="s4">;</span>
  <span class="s1">[_rootViewTags removeObject:rootReactTag]</span><span class="s4">;</span>

  <span class="s1">[self addUIBlock:^(RCTUIManager *uiManager</span><span class="s4">, </span><span class="s1">NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *viewRegistry) {</span>
    <span class="s1">RCTAssertMainQueue()</span><span class="s4">;</span>
    <span class="s1">UIView *rootView = viewRegistry[rootReactTag]</span><span class="s4">;</span>
    <span class="s1">[uiManager _purgeChildren:(NSArray&lt;id&lt;RCTComponent&gt;&gt; *)rootView.reactSubviews</span>
                 <span class="s1">fromRegistry:(NSMutableDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">id&lt;RCTComponent&gt;&gt; *)viewRegistry]</span><span class="s4">;</span>
    <span class="s1">[(NSMutableDictionary *)viewRegistry removeObjectForKey:rootReactTag]</span><span class="s4">;</span>
  <span class="s1">}]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_METHOD(replaceExistingNonRootView : (nonnull NSNumber *)reactTag withView : (nonnull NSNumber *)newReactTag)</span>
<span class="s1">{</span>
  <span class="s1">RCTLogWarn(</span>
      <span class="s4">@</span><span class="s3">&quot;RCTUIManager.replaceExistingNonRootView method is deprecated and it will not be implemented in newer versions of RN (Fabric) - T47686450&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">RCTShadowView *shadowView = _shadowViewRegistry[reactTag]</span><span class="s4">;</span>
  <span class="s1">RCTAssert(shadowView != nil</span><span class="s4">, @</span><span class="s3">&quot;shadowView (for ID %@) not found&quot;</span><span class="s4">, </span><span class="s1">reactTag)</span><span class="s4">;</span>

  <span class="s1">RCTShadowView *superShadowView = shadowView.superview</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!superShadowView) {</span>
    <span class="s1">RCTAssert(NO</span><span class="s4">, @</span><span class="s3">&quot;shadowView super (of ID %@) not found&quot;</span><span class="s4">, </span><span class="s1">reactTag)</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">NSUInteger indexOfView = [superShadowView.reactSubviews indexOfObjectIdenticalTo:shadowView]</span><span class="s4">;</span>
  <span class="s1">RCTAssert(indexOfView != NSNotFound</span><span class="s4">, @</span><span class="s3">&quot;View's superview doesn't claim it as subview (id %@)&quot;</span><span class="s4">, </span><span class="s1">reactTag)</span><span class="s4">;</span>
  <span class="s1">NSArray&lt;NSNumber *&gt; *removeAtIndices = </span><span class="s4">@</span><span class="s1">[ </span><span class="s4">@</span><span class="s1">(indexOfView) ]</span><span class="s4">;</span>
  <span class="s1">NSArray&lt;NSNumber *&gt; *addTags = </span><span class="s4">@</span><span class="s1">[ newReactTag ]</span><span class="s4">;</span>
  <span class="s1">[self manageChildren:superShadowView.reactTag</span>
        <span class="s1">moveFromIndices:nil</span>
          <span class="s1">moveToIndices:nil</span>
      <span class="s1">addChildReactTags:addTags</span>
           <span class="s1">addAtIndices:removeAtIndices</span>
        <span class="s1">removeAtIndices:removeAtIndices]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_METHOD(setChildren : (nonnull NSNumber *)containerTag reactTags : (NSArray&lt;NSNumber *&gt; *)reactTags)</span>
<span class="s1">{</span>
  <span class="s1">RCTSetChildren(containerTag</span><span class="s4">, </span><span class="s1">reactTags</span><span class="s4">, </span><span class="s1">(NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">id&lt;RCTComponent&gt;&gt; *)_shadowViewRegistry)</span><span class="s4">;</span>

  <span class="s1">[self addUIBlock:^(__unused RCTUIManager *uiManager</span><span class="s4">, </span><span class="s1">NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *viewRegistry) {</span>
    <span class="s1">RCTSetChildren(containerTag</span><span class="s4">, </span><span class="s1">reactTags</span><span class="s4">, </span><span class="s1">(NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">id&lt;RCTComponent&gt;&gt; *)viewRegistry)</span><span class="s4">;</span>
  <span class="s1">}]</span><span class="s4">;</span>

  <span class="s1">[self _shadowViewDidReceiveUpdatedChildren:_shadowViewRegistry[containerTag]]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static void </span><span class="s1">RCTSetChildren(</span>
    <span class="s1">NSNumber *containerTag</span><span class="s4">,</span>
    <span class="s1">NSArray&lt;NSNumber *&gt; *reactTags</span><span class="s4">,</span>
    <span class="s1">NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">id&lt;RCTComponent&gt;&gt; *registry)</span>
<span class="s1">{</span>
  <span class="s1">id&lt;RCTComponent&gt; container = registry[containerTag]</span><span class="s4">;</span>
  <span class="s1">NSInteger index = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(NSNumber *reactTag in reactTags) {</span>
    <span class="s1">id&lt;RCTComponent&gt; view = registry[reactTag]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(view) {</span>
      <span class="s1">[container insertReactSubview:view atIndex:index++]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_METHOD(manageChildren</span>
                  <span class="s1">: (nonnull NSNumber *)containerTag moveFromIndices</span>
                  <span class="s1">: (NSArray&lt;NSNumber *&gt; *)moveFromIndices moveToIndices</span>
                  <span class="s1">: (NSArray&lt;NSNumber *&gt; *)moveToIndices addChildReactTags</span>
                  <span class="s1">: (NSArray&lt;NSNumber *&gt; *)addChildReactTags addAtIndices</span>
                  <span class="s1">: (NSArray&lt;NSNumber *&gt; *)addAtIndices removeAtIndices</span>
                  <span class="s1">: (NSArray&lt;NSNumber *&gt; *)removeAtIndices)</span>
<span class="s1">{</span>
  <span class="s1">[self _manageChildren:containerTag</span>
        <span class="s1">moveFromIndices:moveFromIndices</span>
          <span class="s1">moveToIndices:moveToIndices</span>
      <span class="s1">addChildReactTags:addChildReactTags</span>
           <span class="s1">addAtIndices:addAtIndices</span>
        <span class="s1">removeAtIndices:removeAtIndices</span>
               <span class="s1">registry:(NSMutableDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">id&lt;RCTComponent&gt;&gt; *)_shadowViewRegistry]</span><span class="s4">;</span>

  <span class="s1">[self addUIBlock:^(RCTUIManager *uiManager</span><span class="s4">, </span><span class="s1">NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *viewRegistry) {</span>
    <span class="s1">[uiManager _manageChildren:containerTag</span>
               <span class="s1">moveFromIndices:moveFromIndices</span>
                 <span class="s1">moveToIndices:moveToIndices</span>
             <span class="s1">addChildReactTags:addChildReactTags</span>
                  <span class="s1">addAtIndices:addAtIndices</span>
               <span class="s1">removeAtIndices:removeAtIndices</span>
                      <span class="s1">registry:(NSMutableDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">id&lt;RCTComponent&gt;&gt; *)viewRegistry]</span><span class="s4">;</span>
  <span class="s1">}]</span><span class="s4">;</span>

  <span class="s1">[self _shadowViewDidReceiveUpdatedChildren:_shadowViewRegistry[containerTag]]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_manageChildren:(NSNumber *)containerTag</span>
        <span class="s1">moveFromIndices:(NSArray&lt;NSNumber *&gt; *)moveFromIndices</span>
          <span class="s1">moveToIndices:(NSArray&lt;NSNumber *&gt; *)moveToIndices</span>
      <span class="s1">addChildReactTags:(NSArray&lt;NSNumber *&gt; *)addChildReactTags</span>
           <span class="s1">addAtIndices:(NSArray&lt;NSNumber *&gt; *)addAtIndices</span>
        <span class="s1">removeAtIndices:(NSArray&lt;NSNumber *&gt; *)removeAtIndices</span>
               <span class="s1">registry:(NSMutableDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">id&lt;RCTComponent&gt;&gt; *)registry</span>
<span class="s1">{</span>
  <span class="s1">id&lt;RCTComponent&gt; container = registry[containerTag]</span><span class="s4">;</span>
  <span class="s1">RCTAssert(</span>
      <span class="s1">moveFromIndices.count == moveToIndices.count</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;moveFromIndices had size %tu, moveToIndices had size %tu&quot;</span><span class="s4">,</span>
      <span class="s1">moveFromIndices.count</span><span class="s4">,</span>
      <span class="s1">moveToIndices.count)</span><span class="s4">;</span>
  <span class="s1">RCTAssert(addChildReactTags.count == addAtIndices.count</span><span class="s4">, @</span><span class="s3">&quot;there should be at least one React child to add&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s0">// Removes (both permanent and temporary moves) are using &quot;before&quot; indices</span>
  <span class="s1">NSArray&lt;id&lt;RCTComponent&gt;&gt; *permanentlyRemovedChildren = [self _childrenToRemoveFromContainer:container</span>
                                                                                     <span class="s1">atIndices:removeAtIndices]</span><span class="s4">;</span>
  <span class="s1">NSArray&lt;id&lt;RCTComponent&gt;&gt; *temporarilyRemovedChildren = [self _childrenToRemoveFromContainer:container</span>
                                                                                     <span class="s1">atIndices:moveFromIndices]</span><span class="s4">;</span>

  <span class="s1">BOOL isUIViewRegistry = ((id)registry == (id)_viewRegistry)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(isUIViewRegistry &amp;&amp; _layoutAnimationGroup.deletingLayoutAnimation) {</span>
    <span class="s1">[self _removeChildren:(NSArray&lt;UIView *&gt; *)permanentlyRemovedChildren</span>
            <span class="s1">fromContainer:(UIView *)container</span>
            <span class="s1">withAnimation:_layoutAnimationGroup]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">[self _removeChildren:permanentlyRemovedChildren fromContainer:container]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">[self _removeChildren:temporarilyRemovedChildren fromContainer:container]</span><span class="s4">;</span>
  <span class="s1">[self _purgeChildren:permanentlyRemovedChildren fromRegistry:registry]</span><span class="s4">;</span>

  <span class="s0">// Figure out what to insert - merge temporary inserts and adds</span>
  <span class="s1">NSMutableDictionary *destinationsToChildrenToAdd = [NSMutableDictionary dictionary]</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(NSInteger index = </span><span class="s5">0</span><span class="s4">, </span><span class="s1">length = temporarilyRemovedChildren.count</span><span class="s4">; </span><span class="s1">index &lt; length</span><span class="s4">; </span><span class="s1">index++) {</span>
    <span class="s1">destinationsToChildrenToAdd[moveToIndices[index]] = temporarilyRemovedChildren[index]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">for </span><span class="s1">(NSInteger index = </span><span class="s5">0</span><span class="s4">, </span><span class="s1">length = addAtIndices.count</span><span class="s4">; </span><span class="s1">index &lt; length</span><span class="s4">; </span><span class="s1">index++) {</span>
    <span class="s1">id&lt;RCTComponent&gt; view = registry[addChildReactTags[index]]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(view) {</span>
      <span class="s1">destinationsToChildrenToAdd[addAtIndices[index]] = view</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">NSArray&lt;NSNumber *&gt; *sortedIndices =</span>
      <span class="s1">[destinationsToChildrenToAdd.allKeys sortedArrayUsingSelector:</span><span class="s4">@selector</span><span class="s1">(compare:)]</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(NSNumber *reactIndex in sortedIndices) {</span>
    <span class="s1">[container insertReactSubview:destinationsToChildrenToAdd[reactIndex] atIndex:reactIndex.integerValue]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_METHOD(createView</span>
                  <span class="s1">: (nonnull NSNumber *)reactTag viewName</span>
                  <span class="s1">: (NSString *)viewName rootTag</span>
                  <span class="s1">: (nonnull NSNumber *)rootTag props</span>
                  <span class="s1">: (NSDictionary *)props)</span>
<span class="s1">{</span>
  <span class="s1">RCTComponentData *componentData = _componentDataByName[viewName]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(componentData == nil) {</span>
    <span class="s1">RCTLogError(</span><span class="s4">@</span><span class="s3">&quot;No component found for view with name </span><span class="s4">\&quot;</span><span class="s3">%@</span><span class="s4">\&quot;</span><span class="s3">&quot;</span><span class="s4">, </span><span class="s1">viewName)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// Register shadow view</span>
  <span class="s1">RCTShadowView *shadowView = [componentData createShadowViewWithTag:reactTag]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(shadowView) {</span>
    <span class="s1">[componentData setProps:props forShadowView:shadowView]</span><span class="s4">;</span>
    <span class="s1">_shadowViewRegistry[reactTag] = shadowView</span><span class="s4">;</span>
    <span class="s1">RCTShadowView *rootView = _shadowViewRegistry[rootTag]</span><span class="s4">;</span>
    <span class="s1">RCTAssert(</span>
        <span class="s1">[rootView isKindOfClass:[RCTRootShadowView </span><span class="s4">class</span><span class="s1">]] || [rootView isKindOfClass:[RCTSurfaceRootShadowView </span><span class="s4">class</span><span class="s1">]]</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;Given `rootTag` (%@) does not correspond to a valid root shadow view instance.&quot;</span><span class="s4">,</span>
        <span class="s1">rootTag)</span><span class="s4">;</span>
    <span class="s1">shadowView.rootView = (RCTRootShadowView *)rootView</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// Dispatch view creation directly to the main thread instead of adding to</span>
  <span class="s0">// UIBlocks array. This way, it doesn't get deferred until after layout.</span>
  <span class="s1">__block UIView *preliminaryCreatedView = nil</span><span class="s4">;</span>

  <span class="s4">void </span><span class="s1">(^createViewBlock)(</span><span class="s4">void</span><span class="s1">) = ^{</span>
    <span class="s0">// Do nothing on the second run.</span>
    <span class="s4">if </span><span class="s1">(preliminaryCreatedView) {</span>
      <span class="s4">return;</span>
    <span class="s1">}</span>

    <span class="s1">preliminaryCreatedView = [componentData createViewWithTag:reactTag rootTag:rootTag]</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(preliminaryCreatedView) {</span>
      <span class="s1">self-&gt;_viewRegistry[reactTag] = preliminaryCreatedView</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s0">// We cannot guarantee that asynchronously scheduled block will be executed</span>
  <span class="s0">// *before* a block is added to the regular mounting process (simply because</span>
  <span class="s0">// mounting process can be managed externally while the main queue is</span>
  <span class="s0">// locked).</span>
  <span class="s0">// So, we positively dispatch it asynchronously and double check inside</span>
  <span class="s0">// the regular mounting block.</span>

  <span class="s1">RCTExecuteOnMainQueue(createViewBlock)</span><span class="s4">;</span>

  <span class="s1">[self addUIBlock:^(__unused RCTUIManager *uiManager</span><span class="s4">, </span><span class="s1">__unused NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *viewRegistry) {</span>
    <span class="s1">createViewBlock()</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(preliminaryCreatedView) {</span>
      <span class="s1">[componentData setProps:props forView:preliminaryCreatedView]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}]</span><span class="s4">;</span>

  <span class="s1">[self _shadowView:shadowView didReceiveUpdatedProps:[props allKeys]]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_METHOD(updateView</span>
                  <span class="s1">: (nonnull NSNumber *)reactTag viewName</span>
                  <span class="s1">: (NSString *)viewName </span><span class="s0">// not always reliable, use shadowView.viewName if available</span>
                      <span class="s1">props</span>
                  <span class="s1">: (NSDictionary *)props)</span>
<span class="s1">{</span>
  <span class="s1">RCTShadowView *shadowView = _shadowViewRegistry[reactTag]</span><span class="s4">;</span>
  <span class="s1">RCTComponentData *componentData = _componentDataByName[shadowView.viewName ?: viewName]</span><span class="s4">;</span>
  <span class="s1">[componentData setProps:props forShadowView:shadowView]</span><span class="s4">;</span>

  <span class="s1">[self addUIBlock:^(__unused RCTUIManager *uiManager</span><span class="s4">, </span><span class="s1">NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *viewRegistry) {</span>
    <span class="s1">UIView *view = viewRegistry[reactTag]</span><span class="s4">;</span>
    <span class="s1">[componentData setProps:props forView:view]</span><span class="s4">;</span>
  <span class="s1">}]</span><span class="s4">;</span>

  <span class="s1">[self _shadowView:shadowView didReceiveUpdatedProps:[props allKeys]]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)synchronouslyUpdateViewOnUIThread:(NSNumber *)reactTag viewName:(NSString *)viewName props:(NSDictionary *)props</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertMainQueue()</span><span class="s4">;</span>
  <span class="s1">RCTComponentData *componentData = _componentDataByName[viewName]</span><span class="s4">;</span>
  <span class="s1">UIView *view = _viewRegistry[reactTag]</span><span class="s4">;</span>
  <span class="s1">[componentData setProps:props forView:view]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_METHOD(focus : (nonnull NSNumber *)reactTag)</span>
<span class="s1">{</span>
  <span class="s1">[self addUIBlock:^(__unused RCTUIManager *uiManager</span><span class="s4">, </span><span class="s1">NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *viewRegistry) {</span>
    <span class="s1">UIView *newResponder = viewRegistry[reactTag]</span><span class="s4">;</span>
    <span class="s1">[newResponder reactFocus]</span><span class="s4">;</span>
  <span class="s1">}]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_METHOD(blur : (nonnull NSNumber *)reactTag)</span>
<span class="s1">{</span>
  <span class="s1">[self addUIBlock:^(__unused RCTUIManager *uiManager</span><span class="s4">, </span><span class="s1">NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *viewRegistry) {</span>
    <span class="s1">UIView *currentResponder = viewRegistry[reactTag]</span><span class="s4">;</span>
    <span class="s1">[currentResponder reactBlur]</span><span class="s4">;</span>
  <span class="s1">}]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_METHOD(findSubviewIn</span>
                  <span class="s1">: (nonnull NSNumber *)reactTag atPoint</span>
                  <span class="s1">: (CGPoint)point callback</span>
                  <span class="s1">: (RCTResponseSenderBlock)callback)</span>
<span class="s1">{</span>
  <span class="s1">[self addUIBlock:^(__unused RCTUIManager *uiManager</span><span class="s4">, </span><span class="s1">NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *viewRegistry) {</span>
    <span class="s1">UIView *view = viewRegistry[reactTag]</span><span class="s4">;</span>
    <span class="s1">UIView *target = [view hitTest:point withEvent:nil]</span><span class="s4">;</span>
    <span class="s1">CGRect frame = [target convertRect:target.bounds toView:view]</span><span class="s4">;</span>

    <span class="s4">while </span><span class="s1">(target.reactTag == nil &amp;&amp; target.superview != nil) {</span>
      <span class="s1">target = target.superview</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">callback(</span><span class="s4">@</span><span class="s1">[</span>
      <span class="s1">RCTNullIfNil(target.reactTag)</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">(frame.origin.x)</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">(frame.origin.y)</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">(frame.size.width)</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">(frame.size.height)</span><span class="s4">,</span>
    <span class="s1">])</span><span class="s4">;</span>
  <span class="s1">}]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_METHOD(dispatchViewManagerCommand</span>
                  <span class="s1">: (nonnull NSNumber *)reactTag commandID</span>
                  <span class="s1">: (id </span><span class="s0">/*(NSString or NSNumber) */</span><span class="s1">)commandID commandArgs</span>
                  <span class="s1">: (NSArray&lt;id&gt; *)commandArgs)</span>
<span class="s1">{</span>
  <span class="s1">RCTShadowView *shadowView = _shadowViewRegistry[reactTag]</span><span class="s4">;</span>
  <span class="s1">RCTComponentData *componentData = _componentDataByName[shadowView.viewName]</span><span class="s4">;</span>

  <span class="s0">// Achtung! Achtung!</span>
  <span class="s0">// This is a remarkably hacky and ugly workaround.</span>
  <span class="s0">// We need this only temporary for some testing. We need this hack until Fabric fully implements command-execution</span>
  <span class="s0">// pipeline. This does not affect non-Fabric apps.</span>
<span class="s2">#pragma </span><span class="s1">clang diagnostic push</span>
<span class="s2">#pragma </span><span class="s1">clang diagnostic ignored </span><span class="s3">&quot;-Wundeclared-selector&quot;</span>
  <span class="s4">if </span><span class="s1">(!componentData) {</span>
    <span class="s1">__block UIView *view</span><span class="s4">;</span>
    <span class="s1">RCTUnsafeExecuteOnMainQueueSync(^{</span>
      <span class="s1">view = self-&gt;_viewRegistry[reactTag]</span><span class="s4">;</span>
    <span class="s1">})</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">([view respondsToSelector:</span><span class="s4">@selector</span><span class="s1">(componentViewName_DO_NOT_USE_THIS_IS_BROKEN)]) {</span>
      <span class="s1">NSString *name = [view performSelector:</span><span class="s4">@selector</span><span class="s1">(componentViewName_DO_NOT_USE_THIS_IS_BROKEN)]</span><span class="s4">;</span>
      <span class="s1">componentData = _componentDataByName[[NSString stringWithFormat:</span><span class="s4">@</span><span class="s3">&quot;RCT%@&quot;</span><span class="s4">, </span><span class="s1">name]]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s2">#pragma </span><span class="s1">clang diagnostic pop</span>

  <span class="s1">Class managerClass = componentData.managerClass</span><span class="s4">;</span>
  <span class="s1">RCTModuleData *moduleData = [_bridge moduleDataForName:RCTBridgeModuleNameForClass(managerClass)]</span><span class="s4">;</span>

  <span class="s1">id&lt;RCTBridgeMethod&gt; method</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">([commandID isKindOfClass:[NSNumber </span><span class="s4">class</span><span class="s1">]]) {</span>
    <span class="s1">method = moduleData.methods[[commandID intValue]]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">([commandID isKindOfClass:[NSString </span><span class="s4">class</span><span class="s1">]]) {</span>
    <span class="s1">method = moduleData.methodsByName[commandID]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(method == nil) {</span>
      <span class="s1">RCTLogError(</span><span class="s4">@</span><span class="s3">&quot;No command found with name </span><span class="s4">\&quot;</span><span class="s3">%@</span><span class="s4">\&quot;</span><span class="s3">&quot;</span><span class="s4">, </span><span class="s1">commandID)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">RCTLogError(</span><span class="s4">@</span><span class="s3">&quot;dispatchViewManagerCommand must be called with a string or integer command&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">NSArray *args = [</span><span class="s4">@</span><span class="s1">[ reactTag ] arrayByAddingObjectsFromArray:commandArgs]</span><span class="s4">;</span>
  <span class="s1">[method invokeWithBridge:_bridge module:componentData.manager arguments:args]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)batchDidComplete</span>
<span class="s1">{</span>
  <span class="s1">[self _layoutAndMount]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Sets up animations, computes layout, creates UI mounting blocks for computed layout, 
 * runs these blocks and all other already existing blocks. 
 */</span>
<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_layoutAndMount</span>
<span class="s1">{</span>
  <span class="s1">[self _dispatchPropsDidChangeEvents]</span><span class="s4">;</span>
  <span class="s1">[self _dispatchChildrenDidChangeEvents]</span><span class="s4">;</span>

  <span class="s1">[_observerCoordinator uiManagerWillPerformLayout:self]</span><span class="s4">;</span>

  <span class="s0">// Perform layout</span>
  <span class="s4">for </span><span class="s1">(NSNumber *reactTag in _rootViewTags) {</span>
    <span class="s1">RCTRootShadowView *rootView = (RCTRootShadowView *)_shadowViewRegistry[reactTag]</span><span class="s4">;</span>
    <span class="s1">[self addUIBlock:[self uiBlockWithLayoutUpdateForRootView:rootView]]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">[_observerCoordinator uiManagerDidPerformLayout:self]</span><span class="s4">;</span>

  <span class="s1">[_observerCoordinator uiManagerWillPerformMounting:self]</span><span class="s4">;</span>

  <span class="s1">[self flushUIBlocksWithCompletion:^{</span>
    <span class="s1">[self-&gt;_observerCoordinator uiManagerDidPerformMounting:self]</span><span class="s4">;</span>
  <span class="s1">}]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)flushUIBlocksWithCompletion:(</span><span class="s4">void </span><span class="s1">(^)(</span><span class="s4">void</span><span class="s1">))completion</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertUIManagerQueue()</span><span class="s4">;</span>

  <span class="s0">// First copy the previous blocks into a temporary variable, then reset the</span>
  <span class="s0">// pending blocks to a new array. This guards against mutation while</span>
  <span class="s0">// processing the pending blocks in another thread.</span>
  <span class="s1">NSArray&lt;RCTViewManagerUIBlock&gt; *previousPendingUIBlocks = _pendingUIBlocks</span><span class="s4">;</span>
  <span class="s1">_pendingUIBlocks = [NSMutableArray new]</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(previousPendingUIBlocks.count == </span><span class="s5">0</span><span class="s1">) {</span>
    <span class="s1">completion()</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s4">__weak typeof</span><span class="s1">(self) weakSelf = self</span><span class="s4">;</span>

  <span class="s4">void </span><span class="s1">(^mountingBlock)(</span><span class="s4">void</span><span class="s1">) = ^{</span>
    <span class="s4">typeof</span><span class="s1">(self) strongSelf = weakSelf</span><span class="s4">;</span>

    <span class="s4">@try </span><span class="s1">{</span>
      <span class="s4">for </span><span class="s1">(RCTViewManagerUIBlock block in previousPendingUIBlocks) {</span>
        <span class="s1">block(strongSelf</span><span class="s4">, </span><span class="s1">strongSelf-&gt;_viewRegistry)</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s4">@catch </span><span class="s1">(NSException *exception) {</span>
      <span class="s1">RCTLogError(</span><span class="s4">@</span><span class="s3">&quot;Exception thrown while executing UI block: %@&quot;</span><span class="s4">, </span><span class="s1">exception)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">([self.observerCoordinator uiManager:self performMountingWithBlock:mountingBlock]) {</span>
    <span class="s1">completion()</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s0">// Execute the previously queued UI blocks</span>
  <span class="s1">RCTProfileBeginFlowEvent()</span><span class="s4">;</span>
  <span class="s1">RCTExecuteOnMainQueue(^{</span>
    <span class="s1">RCTProfileEndFlowEvent()</span><span class="s4">;</span>
    <span class="s1">RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways</span><span class="s4">, @</span><span class="s3">&quot;-[UIManager flushUIBlocks]&quot;</span><span class="s4">, </span><span class="s1">(</span><span class="s4">@</span><span class="s1">{</span>
                              <span class="s4">@</span><span class="s3">&quot;count&quot; </span><span class="s1">: [</span><span class="s4">@</span><span class="s1">(previousPendingUIBlocks.count) stringValue]</span><span class="s4">,</span>
                            <span class="s1">}))</span><span class="s4">;</span>

    <span class="s1">mountingBlock()</span><span class="s4">;</span>

    <span class="s1">RCT_PROFILE_END_EVENT(RCTProfileTagAlways</span><span class="s4">, @</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s4">;</span>

    <span class="s1">RCTExecuteOnUIManagerQueue(completion)</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setNeedsLayout</span>
<span class="s1">{</span>
  <span class="s0">// If there is an active batch layout will happen when batch finished, so we will wait for that.</span>
  <span class="s0">// Otherwise we immediately trigger layout.</span>
  <span class="s4">if </span><span class="s1">(![_bridge isBatchActive] &amp;&amp; ![_bridge isLoading]) {</span>
    <span class="s1">[self _layoutAndMount]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_shadowView:(RCTShadowView *)shadowView didReceiveUpdatedProps:(NSArray&lt;NSString *&gt; *)props</span>
<span class="s1">{</span>
  <span class="s0">// We collect a set with changed `shadowViews` and its changed props,</span>
  <span class="s0">// so we have to maintain this collection properly.</span>
  <span class="s1">NSArray&lt;NSString *&gt; *previousProps</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">((previousProps = [_shadowViewsWithUpdatedProps objectForKey:shadowView])) {</span>
    <span class="s0">// Merging already registered changed props and new ones.</span>
    <span class="s1">NSMutableSet *set = [NSMutableSet setWithArray:previousProps]</span><span class="s4">;</span>
    <span class="s1">[set addObjectsFromArray:props]</span><span class="s4">;</span>
    <span class="s1">props = [set allObjects]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">[_shadowViewsWithUpdatedProps setObject:props forKey:shadowView]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_shadowViewDidReceiveUpdatedChildren:(RCTShadowView *)shadowView</span>
<span class="s1">{</span>
  <span class="s1">[_shadowViewsWithUpdatedChildren addObject:shadowView]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_dispatchChildrenDidChangeEvents</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_shadowViewsWithUpdatedChildren.count == </span><span class="s5">0</span><span class="s1">) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">NSHashTable&lt;RCTShadowView *&gt; *shadowViews = _shadowViewsWithUpdatedChildren</span><span class="s4">;</span>
  <span class="s1">_shadowViewsWithUpdatedChildren = [NSHashTable weakObjectsHashTable]</span><span class="s4">;</span>

  <span class="s1">NSMutableArray *tags = [NSMutableArray arrayWithCapacity:shadowViews.count]</span><span class="s4">;</span>

  <span class="s4">for </span><span class="s1">(RCTShadowView *shadowView in shadowViews) {</span>
    <span class="s1">[shadowView didUpdateReactSubviews]</span><span class="s4">;</span>
    <span class="s1">[tags addObject:shadowView.reactTag]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">[self addUIBlock:^(__unused RCTUIManager *uiManager</span><span class="s4">, </span><span class="s1">NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *viewRegistry) {</span>
    <span class="s4">for </span><span class="s1">(NSNumber *tag in tags) {</span>
      <span class="s1">UIView&lt;RCTComponent&gt; *view = viewRegistry[tag]</span><span class="s4">;</span>
      <span class="s1">[view didUpdateReactSubviews]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_dispatchPropsDidChangeEvents</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_shadowViewsWithUpdatedProps.count == </span><span class="s5">0</span><span class="s1">) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">NSMapTable&lt;RCTShadowView *</span><span class="s4">, </span><span class="s1">NSArray&lt;NSString *&gt; *&gt; *shadowViews = _shadowViewsWithUpdatedProps</span><span class="s4">;</span>
  <span class="s1">_shadowViewsWithUpdatedProps = [NSMapTable weakToStrongObjectsMapTable]</span><span class="s4">;</span>

  <span class="s1">NSMapTable&lt;NSNumber *</span><span class="s4">, </span><span class="s1">NSArray&lt;NSString *&gt; *&gt; *tags = [NSMapTable strongToStrongObjectsMapTable]</span><span class="s4">;</span>

  <span class="s4">for </span><span class="s1">(RCTShadowView *shadowView in shadowViews) {</span>
    <span class="s1">NSArray&lt;NSString *&gt; *props = [shadowViews objectForKey:shadowView]</span><span class="s4">;</span>
    <span class="s1">[shadowView didSetProps:props]</span><span class="s4">;</span>
    <span class="s1">[tags setObject:props forKey:shadowView.reactTag]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">[self addUIBlock:^(__unused RCTUIManager *uiManager</span><span class="s4">, </span><span class="s1">NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *viewRegistry) {</span>
    <span class="s4">for </span><span class="s1">(NSNumber *tag in tags) {</span>
      <span class="s1">UIView&lt;RCTComponent&gt; *view = viewRegistry[tag]</span><span class="s4">;</span>
      <span class="s1">[view didSetProps:[tags objectForKey:tag]]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_METHOD(measure : (nonnull NSNumber *)reactTag callback : (RCTResponseSenderBlock)callback)</span>
<span class="s1">{</span>
  <span class="s1">[self addUIBlock:^(__unused RCTUIManager *uiManager</span><span class="s4">, </span><span class="s1">NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *viewRegistry) {</span>
    <span class="s1">UIView *view = viewRegistry[reactTag]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(!view) {</span>
      <span class="s0">// this view was probably collapsed out</span>
      <span class="s1">RCTLogWarn(</span><span class="s4">@</span><span class="s3">&quot;measure cannot find view with tag #%@&quot;</span><span class="s4">, </span><span class="s1">reactTag)</span><span class="s4">;</span>
      <span class="s1">callback(</span><span class="s4">@</span><span class="s1">[])</span><span class="s4">;</span>
      <span class="s4">return;</span>
    <span class="s1">}</span>

    <span class="s0">// If in a &lt;Modal&gt;, rootView will be the root of the modal container.</span>
    <span class="s1">UIView *rootView = view</span><span class="s4">;</span>
    <span class="s4">while </span><span class="s1">(rootView.superview &amp;&amp; ![rootView isReactRootView]) {</span>
      <span class="s1">rootView = rootView.superview</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s0">// By convention, all coordinates, whether they be touch coordinates, or</span>
    <span class="s0">// measurement coordinates are with respect to the root view.</span>
    <span class="s1">CGRect frame = view.frame</span><span class="s4">;</span>
    <span class="s1">CGRect globalBounds = [view convertRect:view.bounds toView:rootView]</span><span class="s4">;</span>

    <span class="s1">callback(</span><span class="s4">@</span><span class="s1">[</span>
      <span class="s4">@</span><span class="s1">(frame.origin.x)</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">(frame.origin.y)</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">(globalBounds.size.width)</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">(globalBounds.size.height)</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">(globalBounds.origin.x)</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">(globalBounds.origin.y)</span><span class="s4">,</span>
    <span class="s1">])</span><span class="s4">;</span>
  <span class="s1">}]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_METHOD(measureInWindow : (nonnull NSNumber *)reactTag callback : (RCTResponseSenderBlock)callback)</span>
<span class="s1">{</span>
  <span class="s1">[self addUIBlock:^(__unused RCTUIManager *uiManager</span><span class="s4">, </span><span class="s1">NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *viewRegistry) {</span>
    <span class="s1">UIView *view = viewRegistry[reactTag]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(!view) {</span>
      <span class="s0">// this view was probably collapsed out</span>
      <span class="s1">RCTLogWarn(</span><span class="s4">@</span><span class="s3">&quot;measure cannot find view with tag #%@&quot;</span><span class="s4">, </span><span class="s1">reactTag)</span><span class="s4">;</span>
      <span class="s1">callback(</span><span class="s4">@</span><span class="s1">[])</span><span class="s4">;</span>
      <span class="s4">return;</span>
    <span class="s1">}</span>

    <span class="s0">// Return frame coordinates in window</span>
    <span class="s1">CGRect windowFrame = [view.window convertRect:view.frame fromView:view.superview]</span><span class="s4">;</span>
    <span class="s1">callback(</span><span class="s4">@</span><span class="s1">[</span>
      <span class="s4">@</span><span class="s1">(windowFrame.origin.x)</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">(windowFrame.origin.y)</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">(windowFrame.size.width)</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">(windowFrame.size.height)</span><span class="s4">,</span>
    <span class="s1">])</span><span class="s4">;</span>
  <span class="s1">}]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Returns if the shadow view provided has the `ancestor` shadow view as 
 * an actual ancestor. 
 */</span>
<span class="s1">RCT_EXPORT_METHOD(viewIsDescendantOf</span>
                  <span class="s1">: (nonnull NSNumber *)reactTag ancestor</span>
                  <span class="s1">: (nonnull NSNumber *)ancestorReactTag callback</span>
                  <span class="s1">: (RCTResponseSenderBlock)callback)</span>
<span class="s1">{</span>
  <span class="s1">RCTShadowView *shadowView = _shadowViewRegistry[reactTag]</span><span class="s4">;</span>
  <span class="s1">RCTShadowView *ancestorShadowView = _shadowViewRegistry[ancestorReactTag]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!shadowView) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(!ancestorShadowView) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
  <span class="s1">BOOL viewIsAncestor = [shadowView viewIsDescendantOf:ancestorShadowView]</span><span class="s4">;</span>
  <span class="s1">callback(</span><span class="s4">@</span><span class="s1">[ </span><span class="s4">@</span><span class="s1">(viewIsAncestor) ])</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static void </span><span class="s1">RCTMeasureLayout(RCTShadowView *view</span><span class="s4">, </span><span class="s1">RCTShadowView *ancestor</span><span class="s4">, </span><span class="s1">RCTResponseSenderBlock callback)</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!view) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(!ancestor) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
  <span class="s1">CGRect result = [view measureLayoutRelativeToAncestor:ancestor]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(CGRectIsNull(result)) {</span>
    <span class="s1">RCTLogError(</span>
        <span class="s4">@</span><span class="s3">&quot;view %@ (tag #%@) is not a descendant of %@ (tag #%@)&quot;</span><span class="s4">, </span><span class="s1">view</span><span class="s4">, </span><span class="s1">view.reactTag</span><span class="s4">, </span><span class="s1">ancestor</span><span class="s4">, </span><span class="s1">ancestor.reactTag)</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
  <span class="s1">CGFloat leftOffset = result.origin.x</span><span class="s4">;</span>
  <span class="s1">CGFloat topOffset = result.origin.y</span><span class="s4">;</span>
  <span class="s1">CGFloat width = result.size.width</span><span class="s4">;</span>
  <span class="s1">CGFloat height = result.size.height</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(isnan(leftOffset) || isnan(topOffset) || isnan(width) || isnan(height)) {</span>
    <span class="s1">RCTLogError(</span><span class="s4">@</span><span class="s3">&quot;Attempted to measure layout but offset or dimensions were NaN&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
  <span class="s1">callback(</span><span class="s4">@</span><span class="s1">[ </span><span class="s4">@</span><span class="s1">(leftOffset)</span><span class="s4">, @</span><span class="s1">(topOffset)</span><span class="s4">, @</span><span class="s1">(width)</span><span class="s4">, @</span><span class="s1">(height) ])</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Returns the computed recursive offset layout in a dictionary form. The 
 * returned values are relative to the `ancestor` shadow view. Returns `nil`, if 
 * the `ancestor` shadow view is not actually an `ancestor`. Does not touch 
 * anything on the main UI thread. Invokes supplied callback with (x, y, width, 
 * height). 
 */</span>
<span class="s1">RCT_EXPORT_METHOD(measureLayout</span>
                  <span class="s1">: (nonnull NSNumber *)reactTag relativeTo</span>
                  <span class="s1">: (nonnull NSNumber *)ancestorReactTag errorCallback</span>
                  <span class="s1">: (__unused RCTResponseSenderBlock)errorCallback callback</span>
                  <span class="s1">: (RCTResponseSenderBlock)callback)</span>
<span class="s1">{</span>
  <span class="s1">RCTShadowView *shadowView = _shadowViewRegistry[reactTag]</span><span class="s4">;</span>
  <span class="s1">RCTShadowView *ancestorShadowView = _shadowViewRegistry[ancestorReactTag]</span><span class="s4">;</span>
  <span class="s1">RCTMeasureLayout(shadowView</span><span class="s4">, </span><span class="s1">ancestorShadowView</span><span class="s4">, </span><span class="s1">callback)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Returns the computed recursive offset layout in a dictionary form. The 
 * returned values are relative to the `ancestor` shadow view. Returns `nil`, if 
 * the `ancestor` shadow view is not actually an `ancestor`. Does not touch 
 * anything on the main UI thread. Invokes supplied callback with (x, y, width, 
 * height). 
 */</span>
<span class="s1">RCT_EXPORT_METHOD(measureLayoutRelativeToParent</span>
                  <span class="s1">: (nonnull NSNumber *)reactTag errorCallback</span>
                  <span class="s1">: (__unused RCTResponseSenderBlock)errorCallback callback</span>
                  <span class="s1">: (RCTResponseSenderBlock)callback)</span>
<span class="s1">{</span>
  <span class="s1">RCTLogWarn(</span>
      <span class="s4">@</span><span class="s3">&quot;RCTUIManager.measureLayoutRelativeToParent method is deprecated and it will not be implemented in newer versions of RN (Fabric) - T47686450&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">RCTShadowView *shadowView = _shadowViewRegistry[reactTag]</span><span class="s4">;</span>
  <span class="s1">RCTMeasureLayout(shadowView</span><span class="s4">, </span><span class="s1">shadowView.reactSuperview</span><span class="s4">, </span><span class="s1">callback)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * JS sets what *it* considers to be the responder. Later, scroll views can use 
 * this in order to determine if scrolling is appropriate. 
 */</span>
<span class="s1">RCT_EXPORT_METHOD(setJSResponder</span>
                  <span class="s1">: (nonnull NSNumber *)reactTag blockNativeResponder</span>
                  <span class="s1">: (__unused BOOL)blockNativeResponder)</span>
<span class="s1">{</span>
  <span class="s1">[self addUIBlock:^(__unused RCTUIManager *uiManager</span><span class="s4">, </span><span class="s1">NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *viewRegistry) {</span>
    <span class="s1">_jsResponder = viewRegistry[reactTag]</span><span class="s4">;</span>
    <span class="s0">// Fabric view's are not stored in viewRegistry. We avoid logging a warning in that case.</span>
    <span class="s4">if </span><span class="s1">(!_jsResponder &amp;&amp; !RCTUIManagerTypeForTagIsFabric(reactTag)) {</span>
      <span class="s1">RCTLogWarn(</span><span class="s4">@</span><span class="s3">&quot;Invalid view set to be the JS responder - tag %@&quot;</span><span class="s4">, </span><span class="s1">reactTag)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_METHOD(clearJSResponder)</span>
<span class="s1">{</span>
  <span class="s1">[self addUIBlock:^(__unused RCTUIManager *uiManager</span><span class="s4">, </span><span class="s1">__unused NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *viewRegistry) {</span>
    <span class="s1">_jsResponder = nil</span><span class="s4">;</span>
  <span class="s1">}]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">NSMutableDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">id&gt; *moduleConstantsForComponent(</span>
    <span class="s1">NSMutableDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">NSDictionary *&gt; *directEvents</span><span class="s4">,</span>
    <span class="s1">NSMutableDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">NSDictionary *&gt; *bubblingEvents</span><span class="s4">,</span>
    <span class="s1">RCTComponentData *componentData)</span>
<span class="s1">{</span>
  <span class="s1">NSMutableDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">id&gt; *moduleConstants = [NSMutableDictionary new]</span><span class="s4">;</span>

  <span class="s0">// Register which event-types this view dispatches.</span>
  <span class="s0">// React needs this for the event plugin.</span>
  <span class="s1">NSMutableDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">NSDictionary *&gt; *bubblingEventTypes = [NSMutableDictionary new]</span><span class="s4">;</span>
  <span class="s1">NSMutableDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">NSDictionary *&gt; *directEventTypes = [NSMutableDictionary new]</span><span class="s4">;</span>

  <span class="s0">// Add manager class</span>
  <span class="s1">moduleConstants[</span><span class="s4">@</span><span class="s3">&quot;Manager&quot;</span><span class="s1">] = RCTBridgeModuleNameForClass(componentData.managerClass)</span><span class="s4">;</span>

  <span class="s0">// Add native props</span>
  <span class="s1">NSDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">id&gt; *viewConfig = [componentData viewConfig]</span><span class="s4">;</span>
  <span class="s1">moduleConstants[</span><span class="s4">@</span><span class="s3">&quot;NativeProps&quot;</span><span class="s1">] = viewConfig[</span><span class="s4">@</span><span class="s3">&quot;propTypes&quot;</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s1">moduleConstants[</span><span class="s4">@</span><span class="s3">&quot;baseModuleName&quot;</span><span class="s1">] = viewConfig[</span><span class="s4">@</span><span class="s3">&quot;baseModuleName&quot;</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s1">moduleConstants[</span><span class="s4">@</span><span class="s3">&quot;bubblingEventTypes&quot;</span><span class="s1">] = bubblingEventTypes</span><span class="s4">;</span>
  <span class="s1">moduleConstants[</span><span class="s4">@</span><span class="s3">&quot;directEventTypes&quot;</span><span class="s1">] = directEventTypes</span><span class="s4">;</span>

  <span class="s0">// Add direct events</span>
  <span class="s4">for </span><span class="s1">(NSString *eventName in viewConfig[</span><span class="s4">@</span><span class="s3">&quot;directEvents&quot;</span><span class="s1">]) {</span>
    <span class="s4">if </span><span class="s1">(!directEvents[eventName]) {</span>
      <span class="s1">directEvents[eventName] = </span><span class="s4">@</span><span class="s1">{</span>
        <span class="s4">@</span><span class="s3">&quot;registrationName&quot; </span><span class="s1">: [eventName stringByReplacingCharactersInRange:(NSRange){</span><span class="s5">0</span><span class="s4">, </span><span class="s5">3</span><span class="s1">} withString:</span><span class="s4">@</span><span class="s3">&quot;on&quot;</span><span class="s1">]</span><span class="s4">,</span>
      <span class="s1">}</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s1">directEventTypes[eventName] = directEvents[eventName]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(RCT_DEBUG &amp;&amp; bubblingEvents[eventName]) {</span>
      <span class="s1">RCTLogError(</span>
          <span class="s4">@</span><span class="s3">&quot;Component '%@' re-registered bubbling event '%@' as a &quot;</span>
           <span class="s3">&quot;direct event&quot;</span><span class="s4">,</span>
          <span class="s1">componentData.name</span><span class="s4">,</span>
          <span class="s1">eventName)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Add bubbling events</span>
  <span class="s4">for </span><span class="s1">(NSString *eventName in viewConfig[</span><span class="s4">@</span><span class="s3">&quot;bubblingEvents&quot;</span><span class="s1">]) {</span>
    <span class="s4">if </span><span class="s1">(!bubblingEvents[eventName]) {</span>
      <span class="s1">NSString *bubbleName = [eventName stringByReplacingCharactersInRange:(NSRange){</span><span class="s5">0</span><span class="s4">, </span><span class="s5">3</span><span class="s1">} withString:</span><span class="s4">@</span><span class="s3">&quot;on&quot;</span><span class="s1">]</span><span class="s4">;</span>
      <span class="s1">bubblingEvents[eventName] = </span><span class="s4">@</span><span class="s1">{</span>
        <span class="s4">@</span><span class="s3">&quot;phasedRegistrationNames&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">{</span>
          <span class="s4">@</span><span class="s3">&quot;bubbled&quot; </span><span class="s1">: bubbleName</span><span class="s4">,</span>
          <span class="s4">@</span><span class="s3">&quot;captured&quot; </span><span class="s1">: [bubbleName stringByAppendingString:</span><span class="s4">@</span><span class="s3">&quot;Capture&quot;</span><span class="s1">]</span><span class="s4">,</span>
        <span class="s1">}</span>
      <span class="s1">}</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s1">bubblingEventTypes[eventName] = bubblingEvents[eventName]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(RCT_DEBUG &amp;&amp; directEvents[eventName]) {</span>
      <span class="s1">RCTLogError(</span>
          <span class="s4">@</span><span class="s3">&quot;Component '%@' re-registered direct event '%@' as a &quot;</span>
           <span class="s3">&quot;bubbling event&quot;</span><span class="s4">,</span>
          <span class="s1">componentData.name</span><span class="s4">,</span>
          <span class="s1">eventName)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Add capturing events (added as bubbling events but with the 'skipBubbling' flag)</span>
  <span class="s4">for </span><span class="s1">(NSString *eventName in viewConfig[</span><span class="s4">@</span><span class="s3">&quot;capturingEvents&quot;</span><span class="s1">]) {</span>
    <span class="s4">if </span><span class="s1">(!bubblingEvents[eventName]) {</span>
      <span class="s1">NSString *bubbleName = [eventName stringByReplacingCharactersInRange:(NSRange){</span><span class="s5">0</span><span class="s4">, </span><span class="s5">3</span><span class="s1">} withString:</span><span class="s4">@</span><span class="s3">&quot;on&quot;</span><span class="s1">]</span><span class="s4">;</span>
      <span class="s1">bubblingEvents[eventName] = </span><span class="s4">@</span><span class="s1">{</span>
        <span class="s4">@</span><span class="s3">&quot;phasedRegistrationNames&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">{</span>
          <span class="s4">@</span><span class="s3">&quot;bubbled&quot; </span><span class="s1">: bubbleName</span><span class="s4">,</span>
          <span class="s4">@</span><span class="s3">&quot;captured&quot; </span><span class="s1">: [bubbleName stringByAppendingString:</span><span class="s4">@</span><span class="s3">&quot;Capture&quot;</span><span class="s1">]</span><span class="s4">,</span>
          <span class="s4">@</span><span class="s3">&quot;skipBubbling&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">YES</span>
        <span class="s1">}</span>
      <span class="s1">}</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s1">bubblingEventTypes[eventName] = bubblingEvents[eventName]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(RCT_DEBUG &amp;&amp; directEvents[eventName]) {</span>
      <span class="s1">RCTLogError(</span>
          <span class="s4">@</span><span class="s3">&quot;Component '%@' re-registered direct event '%@' as a &quot;</span>
           <span class="s3">&quot;bubbling event&quot;</span><span class="s4">,</span>
          <span class="s1">componentData.name</span><span class="s4">,</span>
          <span class="s1">eventName)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">moduleConstants</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">id&gt; *)constantsToExport</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">[self getConstants]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">id&gt; *)getConstants</span>
<span class="s1">{</span>
  <span class="s1">NSMutableDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">NSDictionary *&gt; *constants = [NSMutableDictionary new]</span><span class="s4">;</span>
  <span class="s1">NSMutableDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">NSDictionary *&gt; *directEvents = [NSMutableDictionary new]</span><span class="s4">;</span>
  <span class="s1">NSMutableDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">NSDictionary *&gt; *bubblingEvents = [NSMutableDictionary new]</span><span class="s4">;</span>

  <span class="s1">[_componentDataByName</span>
      <span class="s1">enumerateKeysAndObjectsUsingBlock:^(NSString *name</span><span class="s4">, </span><span class="s1">RCTComponentData *componentData</span><span class="s4">, </span><span class="s1">__unused BOOL *stop) {</span>
        <span class="s1">RCTAssert(!constants[name]</span><span class="s4">, @</span><span class="s3">&quot;UIManager already has constants for %@&quot;</span><span class="s4">, </span><span class="s1">componentData.name)</span><span class="s4">;</span>
        <span class="s1">NSMutableDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">id&gt; *moduleConstants =</span>
            <span class="s1">moduleConstantsForComponent(directEvents</span><span class="s4">, </span><span class="s1">bubblingEvents</span><span class="s4">, </span><span class="s1">componentData)</span><span class="s4">;</span>
        <span class="s1">constants[name] = moduleConstants</span><span class="s4">;</span>
      <span class="s1">}]</span><span class="s4">;</span>

  <span class="s4">return </span><span class="s1">constants</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD(lazilyLoadView : (NSString *)name)</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_componentDataByName[name]) {</span>
    <span class="s4">return @</span><span class="s1">{}</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">id&lt;RCTBridgeDelegate&gt; delegate = self.bridge.delegate</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(![delegate respondsToSelector:</span><span class="s4">@selector</span><span class="s1">(bridge:didNotFindModule:)]) {</span>
    <span class="s4">return @</span><span class="s1">{}</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">NSString *moduleName = name</span><span class="s4">;</span>
  <span class="s1">BOOL result = [delegate bridge:self.bridge didNotFindModule:moduleName]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!result) {</span>
    <span class="s1">moduleName = [name stringByAppendingString:</span><span class="s4">@</span><span class="s3">&quot;Manager&quot;</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s1">result = [delegate bridge:self.bridge didNotFindModule:moduleName]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(!result) {</span>
    <span class="s4">return @</span><span class="s1">{}</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">id module = [self.bridge moduleForName:moduleName lazilyLoadIfNecessary:RCTTurboModuleEnabled()]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(module == nil) {</span>
    <span class="s0">// There is all sorts of code in this codebase that drops prefixes.</span>
    <span class="s0">//</span>
    <span class="s0">// If we didn't find a module, it's possible because it's stored under a key</span>
    <span class="s0">// which had RCT Prefixes stripped. Lets check one more time...</span>
    <span class="s1">module = [self.bridge moduleForName:RCTDropReactPrefixes(moduleName) lazilyLoadIfNecessary:RCTTurboModuleEnabled()]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(!module) {</span>
    <span class="s4">return @</span><span class="s1">{}</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">RCTComponentData *componentData = [[RCTComponentData alloc] initWithManagerClass:[module </span><span class="s4">class</span><span class="s1">]</span>
                                                                            <span class="s1">bridge:self.bridge</span>
                                                                   <span class="s1">eventDispatcher:self.bridge.eventDispatcher]</span><span class="s4">;</span>
  <span class="s1">_componentDataByName[componentData.name] = componentData</span><span class="s4">;</span>
  <span class="s1">NSMutableDictionary *directEvents = [NSMutableDictionary new]</span><span class="s4">;</span>
  <span class="s1">NSMutableDictionary *bubblingEvents = [NSMutableDictionary new]</span><span class="s4">;</span>
  <span class="s1">NSMutableDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">id&gt; *moduleConstants =</span>
      <span class="s1">moduleConstantsForComponent(directEvents</span><span class="s4">, </span><span class="s1">bubblingEvents</span><span class="s4">, </span><span class="s1">componentData)</span><span class="s4">;</span>
  <span class="s4">return @</span><span class="s1">{</span>
    <span class="s4">@</span><span class="s3">&quot;viewConfig&quot; </span><span class="s1">: moduleConstants</span><span class="s4">,</span>
  <span class="s1">}</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_METHOD(configureNextLayoutAnimation</span>
                  <span class="s1">: (NSDictionary *)config withCallback</span>
                  <span class="s1">: (RCTResponseSenderBlock)callback errorCallback</span>
                  <span class="s1">: (__unused RCTResponseSenderBlock)errorCallback)</span>
<span class="s1">{</span>
  <span class="s1">RCTLayoutAnimationGroup *layoutAnimationGroup = [[RCTLayoutAnimationGroup alloc] initWithConfig:config</span>
                                                                                         <span class="s1">callback:callback]</span><span class="s4">;</span>

  <span class="s1">[self addUIBlock:^(RCTUIManager *uiManager</span><span class="s4">, </span><span class="s1">__unused NSDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">UIView *&gt; *viewRegistry) {</span>
    <span class="s1">[uiManager setNextLayoutAnimationGroup:layoutAnimationGroup]</span><span class="s4">;</span>
  <span class="s1">}]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)rootViewForReactTag:(NSNumber *)reactTag withCompletion:(</span><span class="s4">void </span><span class="s1">(^)(UIView *view))completion</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertMainQueue()</span><span class="s4">;</span>
  <span class="s1">RCTAssert(completion != nil</span><span class="s4">, @</span><span class="s3">&quot;Attempted to resolve rootView for tag %@ without a completion block&quot;</span><span class="s4">, </span><span class="s1">reactTag)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(reactTag == nil) {</span>
    <span class="s1">completion(nil)</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">RCTExecuteOnUIManagerQueue(^{</span>
    <span class="s1">NSNumber *rootTag = [self shadowViewForReactTag:reactTag].rootView.reactTag</span><span class="s4">;</span>
    <span class="s1">RCTExecuteOnMainQueue(^{</span>
      <span class="s1">UIView *rootView = nil</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(rootTag != nil) {</span>
        <span class="s1">rootView = [self viewForReactTag:rootTag]</span><span class="s4">;</span>
      <span class="s1">}</span>
      <span class="s1">completion(rootView)</span><span class="s4">;</span>
    <span class="s1">})</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">UIView *_jsResponder</span><span class="s4">;</span>

<span class="s1">+ (UIView *)JSResponder</span>
<span class="s1">{</span>
  <span class="s1">RCTErrorNewArchitectureValidation(</span>
      <span class="s1">RCTNotAllowedInFabricWithoutLegacy</span><span class="s4">, @</span><span class="s3">&quot;RCTUIManager&quot;</span><span class="s4">, @</span><span class="s3">&quot;Please migrate this legacy surface to Fabric.&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">_jsResponder</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">@end</span>

<span class="s4">@implementation </span><span class="s1">RCTBridge (RCTUIManager)</span>

<span class="s1">- (RCTUIManager *)uiManager</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">[self moduleForClass:[RCTUIManager </span><span class="s4">class</span><span class="s1">]]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">@end</span>
</pre>
</body>
</html>
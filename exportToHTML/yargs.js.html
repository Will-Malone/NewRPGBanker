<html>
<head>
<title>yargs.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
yargs.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.isYargsInstance = exports.rebase = exports.Yargs = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s1">const command_1 = require(</span><span class="s0">&quot;./command&quot;</span><span class="s1">);</span>
<span class="s1">const common_types_1 = require(</span><span class="s0">&quot;./common-types&quot;</span><span class="s1">);</span>
<span class="s1">const yerror_1 = require(</span><span class="s0">&quot;./yerror&quot;</span><span class="s1">);</span>
<span class="s1">const usage_1 = require(</span><span class="s0">&quot;./usage&quot;</span><span class="s1">);</span>
<span class="s1">const argsert_1 = require(</span><span class="s0">&quot;./argsert&quot;</span><span class="s1">);</span>
<span class="s1">const fs = require(</span><span class="s0">&quot;fs&quot;</span><span class="s1">);</span>
<span class="s1">const completion_1 = require(</span><span class="s0">&quot;./completion&quot;</span><span class="s1">);</span>
<span class="s1">const path = require(</span><span class="s0">&quot;path&quot;</span><span class="s1">);</span>
<span class="s1">const validation_1 = require(</span><span class="s0">&quot;./validation&quot;</span><span class="s1">);</span>
<span class="s1">const obj_filter_1 = require(</span><span class="s0">&quot;./obj-filter&quot;</span><span class="s1">);</span>
<span class="s1">const apply_extends_1 = require(</span><span class="s0">&quot;./apply-extends&quot;</span><span class="s1">);</span>
<span class="s1">const middleware_1 = require(</span><span class="s0">&quot;./middleware&quot;</span><span class="s1">);</span>
<span class="s1">const processArgv = require(</span><span class="s0">&quot;./process-argv&quot;</span><span class="s1">);</span>
<span class="s1">const is_promise_1 = require(</span><span class="s0">&quot;./is-promise&quot;</span><span class="s1">);</span>
<span class="s1">const Parser = require(</span><span class="s0">&quot;yargs-parser&quot;</span><span class="s1">);</span>
<span class="s1">const y18nFactory = require(</span><span class="s0">&quot;y18n&quot;</span><span class="s1">);</span>
<span class="s1">const setBlocking = require(</span><span class="s0">&quot;set-blocking&quot;</span><span class="s1">);</span>
<span class="s1">const findUp = require(</span><span class="s0">&quot;find-up&quot;</span><span class="s1">);</span>
<span class="s1">const requireMainFilename = require(</span><span class="s0">&quot;require-main-filename&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">Yargs(processArgs = [], cwd = process.cwd(), parentRequire = require) {</span>
    <span class="s1">const self = {};</span>
    <span class="s1">let command;</span>
    <span class="s1">let completion = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">let groups = {};</span>
    <span class="s1">const globalMiddleware = [];</span>
    <span class="s1">let output = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s1">const preservedGroups = {};</span>
    <span class="s1">let usage;</span>
    <span class="s1">let validation;</span>
    <span class="s1">let handlerFinishCommand = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">const y18n = y18nFactory({</span>
        <span class="s1">directory: path.resolve(__dirname, </span><span class="s0">'../../locales'</span><span class="s1">),</span>
        <span class="s1">updateFiles: </span><span class="s2">false</span>
    <span class="s1">});</span>
    <span class="s1">self.middleware = middleware_1.globalMiddlewareFactory(globalMiddleware, self);</span>
    <span class="s1">self.scriptName = </span><span class="s2">function </span><span class="s1">(scriptName) {</span>
        <span class="s1">self.customScriptName = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">self.$0 = scriptName;</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s4">// ignore the node bin, specify this in your</span>
    <span class="s4">// bin file with #!/usr/bin/env node</span>
    <span class="s1">let default$0;</span>
    <span class="s2">if </span><span class="s1">(/\b(node|iojs|electron)(\.exe)?$/.test(process.argv[</span><span class="s3">0</span><span class="s1">])) {</span>
        <span class="s1">default$0 = process.argv.slice(</span><span class="s3">1</span><span class="s1">, </span><span class="s3">2</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">default$0 = process.argv.slice(</span><span class="s3">0</span><span class="s1">, </span><span class="s3">1</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">self.$0 = default$0</span>
        <span class="s1">.map(x =&gt; {</span>
        <span class="s1">const b = rebase(cwd, x);</span>
        <span class="s2">return </span><span class="s1">x.match(/^(\/|([a-zA-Z]:)?\\)/) &amp;&amp; b.length &lt; x.length ? b : x;</span>
    <span class="s1">})</span>
        <span class="s1">.join(</span><span class="s0">' '</span><span class="s1">).trim();</span>
    <span class="s2">if </span><span class="s1">(process.env._ !== undefined &amp;&amp; processArgv.getProcessArgvBin() === process.env._) {</span>
        <span class="s1">self.$0 = process.env._.replace(`${path.dirname(process.execPath)}/`, </span><span class="s0">''</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s4">// use context object to keep track of resets, subcommand execution, etc</span>
    <span class="s4">// submodules should modify and check the state of context as necessary</span>
    <span class="s1">const context = { resets: -</span><span class="s3">1</span><span class="s1">, commands: [], fullCommands: [], files: [] };</span>
    <span class="s1">self.getContext = () =&gt; context;</span>
    <span class="s4">// puts yargs back into an initial state. any keys</span>
    <span class="s4">// that have been set to &quot;global&quot; will not be reset</span>
    <span class="s4">// by this action.</span>
    <span class="s1">let options;</span>
    <span class="s1">self.resetOptions = self.reset = </span><span class="s2">function </span><span class="s1">resetOptions(aliases = {}) {</span>
        <span class="s1">context.resets++;</span>
        <span class="s1">options = options || {};</span>
        <span class="s4">// put yargs back into an initial state, this</span>
        <span class="s4">// logic is used to build a nested command</span>
        <span class="s4">// hierarchy.</span>
        <span class="s1">const tmpOptions = {};</span>
        <span class="s1">tmpOptions.local = options.local ? options.local : [];</span>
        <span class="s1">tmpOptions.configObjects = options.configObjects ? options.configObjects : [];</span>
        <span class="s4">// if a key has been explicitly set as local,</span>
        <span class="s4">// we should reset it before passing options to command.</span>
        <span class="s1">const localLookup = {};</span>
        <span class="s1">tmpOptions.local.forEach((l) =&gt; {</span>
            <span class="s1">localLookup[l] = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">(aliases[l] || []).forEach((a) =&gt; {</span>
                <span class="s1">localLookup[a] = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
        <span class="s4">// add all groups not set to local to preserved groups</span>
        <span class="s1">Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) =&gt; {</span>
            <span class="s1">const keys = groups[groupName].filter(key =&gt; !(key </span><span class="s2">in </span><span class="s1">localLookup));</span>
            <span class="s2">if </span><span class="s1">(keys.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">acc[groupName] = keys;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">acc;</span>
        <span class="s1">}, {}));</span>
        <span class="s4">// groups can now be reset</span>
        <span class="s1">groups = {};</span>
        <span class="s1">const arrayOptions = [</span>
            <span class="s0">'array'</span><span class="s1">, </span><span class="s0">'boolean'</span><span class="s1">, </span><span class="s0">'string'</span><span class="s1">, </span><span class="s0">'skipValidation'</span><span class="s1">,</span>
            <span class="s0">'count'</span><span class="s1">, </span><span class="s0">'normalize'</span><span class="s1">, </span><span class="s0">'number'</span><span class="s1">,</span>
            <span class="s0">'hiddenOptions'</span>
        <span class="s1">];</span>
        <span class="s1">const objectOptions = [</span>
            <span class="s0">'narg'</span><span class="s1">, </span><span class="s0">'key'</span><span class="s1">, </span><span class="s0">'alias'</span><span class="s1">, </span><span class="s0">'default'</span><span class="s1">, </span><span class="s0">'defaultDescription'</span><span class="s1">,</span>
            <span class="s0">'config'</span><span class="s1">, </span><span class="s0">'choices'</span><span class="s1">, </span><span class="s0">'demandedOptions'</span><span class="s1">, </span><span class="s0">'demandedCommands'</span><span class="s1">, </span><span class="s0">'coerce'</span><span class="s1">,</span>
            <span class="s0">'deprecatedOptions'</span>
        <span class="s1">];</span>
        <span class="s1">arrayOptions.forEach(k =&gt; {</span>
            <span class="s1">tmpOptions[k] = (options[k] || []).filter(k =&gt; !localLookup[k]);</span>
        <span class="s1">});</span>
        <span class="s1">objectOptions.forEach((k) =&gt; {</span>
            <span class="s1">tmpOptions[k] = obj_filter_1.objFilter(options[k], k =&gt; !localLookup[k]);</span>
        <span class="s1">});</span>
        <span class="s1">tmpOptions.envPrefix = options.envPrefix;</span>
        <span class="s1">options = tmpOptions;</span>
        <span class="s4">// if this is the first time being executed, create</span>
        <span class="s4">// instances of all our helpers -- otherwise just reset.</span>
        <span class="s1">usage = usage ? usage.reset(localLookup) : usage_1.usage(self, y18n);</span>
        <span class="s1">validation = validation ? validation.reset(localLookup) : validation_1.validation(self, usage, y18n);</span>
        <span class="s1">command = command ? command.reset() : command_1.command(self, usage, validation, globalMiddleware);</span>
        <span class="s2">if </span><span class="s1">(!completion)</span>
            <span class="s1">completion = completion_1.completion(self, usage, command);</span>
        <span class="s1">completionCommand = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">output = </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s1">exitError = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">hasOutput = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">self.parsed = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.resetOptions();</span>
    <span class="s4">// temporary hack: allow &quot;freezing&quot; of reset-able state for parse(msg, cb)</span>
    <span class="s1">const frozens = [];</span>
    <span class="s2">function </span><span class="s1">freeze() {</span>
        <span class="s1">frozens.push({</span>
            <span class="s1">options,</span>
            <span class="s1">configObjects: options.configObjects.slice(</span><span class="s3">0</span><span class="s1">),</span>
            <span class="s1">exitProcess,</span>
            <span class="s1">groups,</span>
            <span class="s1">strict,</span>
            <span class="s1">strictCommands,</span>
            <span class="s1">completionCommand,</span>
            <span class="s1">output,</span>
            <span class="s1">exitError,</span>
            <span class="s1">hasOutput,</span>
            <span class="s1">parsed: self.parsed,</span>
            <span class="s1">parseFn,</span>
            <span class="s1">parseContext,</span>
            <span class="s1">handlerFinishCommand</span>
        <span class="s1">});</span>
        <span class="s1">usage.freeze();</span>
        <span class="s1">validation.freeze();</span>
        <span class="s1">command.freeze();</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">unfreeze() {</span>
        <span class="s1">const frozen = frozens.pop();</span>
        <span class="s1">common_types_1.assertNotStrictEqual(frozen, undefined);</span>
        <span class="s1">let configObjects;</span>
        <span class="s1">({</span>
            <span class="s1">options,</span>
            <span class="s1">configObjects,</span>
            <span class="s1">exitProcess,</span>
            <span class="s1">groups,</span>
            <span class="s1">output,</span>
            <span class="s1">exitError,</span>
            <span class="s1">hasOutput,</span>
            <span class="s1">parsed: self.parsed,</span>
            <span class="s1">strict,</span>
            <span class="s1">strictCommands,</span>
            <span class="s1">completionCommand,</span>
            <span class="s1">parseFn,</span>
            <span class="s1">parseContext,</span>
            <span class="s1">handlerFinishCommand</span>
        <span class="s1">} = frozen);</span>
        <span class="s1">options.configObjects = configObjects;</span>
        <span class="s1">usage.unfreeze();</span>
        <span class="s1">validation.unfreeze();</span>
        <span class="s1">command.unfreeze();</span>
    <span class="s1">}</span>
    <span class="s1">self.boolean = </span><span class="s2">function </span><span class="s1">(keys) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;array|string&gt;'</span><span class="s1">, [keys], arguments.length);</span>
        <span class="s1">populateParserHintArray(</span><span class="s0">'boolean'</span><span class="s1">, keys);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.array = </span><span class="s2">function </span><span class="s1">(keys) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;array|string&gt;'</span><span class="s1">, [keys], arguments.length);</span>
        <span class="s1">populateParserHintArray(</span><span class="s0">'array'</span><span class="s1">, keys);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.number = </span><span class="s2">function </span><span class="s1">(keys) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;array|string&gt;'</span><span class="s1">, [keys], arguments.length);</span>
        <span class="s1">populateParserHintArray(</span><span class="s0">'number'</span><span class="s1">, keys);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.normalize = </span><span class="s2">function </span><span class="s1">(keys) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;array|string&gt;'</span><span class="s1">, [keys], arguments.length);</span>
        <span class="s1">populateParserHintArray(</span><span class="s0">'normalize'</span><span class="s1">, keys);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.count = </span><span class="s2">function </span><span class="s1">(keys) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;array|string&gt;'</span><span class="s1">, [keys], arguments.length);</span>
        <span class="s1">populateParserHintArray(</span><span class="s0">'count'</span><span class="s1">, keys);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.string = </span><span class="s2">function </span><span class="s1">(keys) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;array|string&gt;'</span><span class="s1">, [keys], arguments.length);</span>
        <span class="s1">populateParserHintArray(</span><span class="s0">'string'</span><span class="s1">, keys);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.requiresArg = </span><span class="s2">function </span><span class="s1">(keys) {</span>
        <span class="s4">// the 2nd paramter [number] in the argsert the assertion is mandatory</span>
        <span class="s4">// as populateParserHintSingleValueDictionary recursively calls requiresArg</span>
        <span class="s4">// with Nan as a 2nd parameter, although we ignore it</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;array|string|object&gt; [number]'</span><span class="s1">, [keys], arguments.length);</span>
        <span class="s4">// If someone configures nargs at the same time as requiresArg,</span>
        <span class="s4">// nargs should take precedent,</span>
        <span class="s4">// see: https://github.com/yargs/yargs/pull/1572</span>
        <span class="s4">// TODO: make this work with aliases, using a check similar to</span>
        <span class="s4">// checkAllAliases() in yargs-parser.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">keys === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; options.narg[keys]) {</span>
            <span class="s2">return </span><span class="s1">self;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">populateParserHintSingleValueDictionary(self.requiresArg, </span><span class="s0">'narg'</span><span class="s1">, keys, NaN);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.skipValidation = </span><span class="s2">function </span><span class="s1">(keys) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;array|string&gt;'</span><span class="s1">, [keys], arguments.length);</span>
        <span class="s1">populateParserHintArray(</span><span class="s0">'skipValidation'</span><span class="s1">, keys);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s2">function </span><span class="s1">populateParserHintArray(type, keys) {</span>
        <span class="s1">keys = [].concat(keys);</span>
        <span class="s1">keys.forEach((key) =&gt; {</span>
            <span class="s1">key = sanitizeKey(key);</span>
            <span class="s1">options[type].push(key);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">self.nargs = </span><span class="s2">function </span><span class="s1">(key, value) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;string|object|array&gt; [number]'</span><span class="s1">, [key, value], arguments.length);</span>
        <span class="s1">populateParserHintSingleValueDictionary(self.nargs, </span><span class="s0">'narg'</span><span class="s1">, key, value);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.choices = </span><span class="s2">function </span><span class="s1">(key, value) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;object|string|array&gt; [string|array]'</span><span class="s1">, [key, value], arguments.length);</span>
        <span class="s1">populateParserHintArrayDictionary(self.choices, </span><span class="s0">'choices'</span><span class="s1">, key, value);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.alias = </span><span class="s2">function </span><span class="s1">(key, value) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;object|string|array&gt; [string|array]'</span><span class="s1">, [key, value], arguments.length);</span>
        <span class="s1">populateParserHintArrayDictionary(self.alias, </span><span class="s0">'alias'</span><span class="s1">, key, value);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s4">// TODO: actually deprecate self.defaults.</span>
    <span class="s1">self.</span><span class="s2">default </span><span class="s1">= self.defaults = </span><span class="s2">function </span><span class="s1">(key, value, defaultDescription) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;object|string|array&gt; [*] [string]'</span><span class="s1">, [key, value, defaultDescription], arguments.length);</span>
        <span class="s2">if </span><span class="s1">(defaultDescription) {</span>
            <span class="s1">common_types_1.assertSingleKey(key);</span>
            <span class="s1">options.defaultDescription[key] = defaultDescription;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s1">common_types_1.assertSingleKey(key);</span>
            <span class="s2">if </span><span class="s1">(!options.defaultDescription[key])</span>
                <span class="s1">options.defaultDescription[key] = usage.functionDescription(value);</span>
            <span class="s1">value = value.call();</span>
        <span class="s1">}</span>
        <span class="s1">populateParserHintSingleValueDictionary(self.</span><span class="s2">default</span><span class="s1">, </span><span class="s0">'default'</span><span class="s1">, key, value);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.describe = </span><span class="s2">function </span><span class="s1">(key, desc) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;object|string|array&gt; [string]'</span><span class="s1">, [key, desc], arguments.length);</span>
        <span class="s1">setKey(key, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">usage.describe(key, desc);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s2">function </span><span class="s1">setKey(key, set) {</span>
        <span class="s1">populateParserHintSingleValueDictionary(setKey, </span><span class="s0">'key'</span><span class="s1">, key, set);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">demandOption(keys, msg) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;object|string|array&gt; [string]'</span><span class="s1">, [keys, msg], arguments.length);</span>
        <span class="s1">populateParserHintSingleValueDictionary(self.demandOption, </span><span class="s0">'demandedOptions'</span><span class="s1">, keys, msg);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">}</span>
    <span class="s1">self.demandOption = demandOption;</span>
    <span class="s1">self.coerce = </span><span class="s2">function </span><span class="s1">(keys, value) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;object|string|array&gt; [function]'</span><span class="s1">, [keys, value], arguments.length);</span>
        <span class="s1">populateParserHintSingleValueDictionary(self.coerce, </span><span class="s0">'coerce'</span><span class="s1">, keys, value);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s2">function </span><span class="s1">populateParserHintSingleValueDictionary(builder, type, key, value) {</span>
        <span class="s1">populateParserHintDictionary(builder, type, key, value, (type, key, value) =&gt; {</span>
            <span class="s1">options[type][key] = value;</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">populateParserHintArrayDictionary(builder, type, key, value) {</span>
        <span class="s1">populateParserHintDictionary(builder, type, key, value, (type, key, value) =&gt; {</span>
            <span class="s1">options[type][key] = (options[type][key] || []).concat(value);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">populateParserHintDictionary(builder, type, key, value, singleKeyHandler) {</span>
        <span class="s2">if </span><span class="s1">(Array.isArray(key)) {</span>
            <span class="s4">// an array of keys with one value ['x', 'y', 'z'], function parse () {}</span>
            <span class="s1">key.forEach((k) =&gt; {</span>
                <span class="s1">builder(k, value);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(((key) =&gt; </span><span class="s2">typeof </span><span class="s1">key === </span><span class="s0">'object'</span><span class="s1">)(key)) {</span>
            <span class="s4">// an object of key value pairs: {'x': parse () {}, 'y': parse() {}}</span>
            <span class="s2">for </span><span class="s1">(const k of common_types_1.objectKeys(key)) {</span>
                <span class="s1">builder(k, key[k]);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">singleKeyHandler(type, sanitizeKey(key), value);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">sanitizeKey(key) {</span>
        <span class="s2">if </span><span class="s1">(key === </span><span class="s0">'__proto__'</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s0">'___proto___'</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">key;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">deleteFromParserHintObject(optionKey) {</span>
        <span class="s4">// delete from all parsing hints:</span>
        <span class="s4">// boolean, array, key, alias, etc.</span>
        <span class="s1">common_types_1.objectKeys(options).forEach((hintKey) =&gt; {</span>
            <span class="s4">// configObjects is not a parsing hint array</span>
            <span class="s2">if </span><span class="s1">(((key) =&gt; key === </span><span class="s0">'configObjects'</span><span class="s1">)(hintKey))</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">const hint = options[hintKey];</span>
            <span class="s2">if </span><span class="s1">(Array.isArray(hint)) {</span>
                <span class="s2">if </span><span class="s1">(~hint.indexOf(optionKey))</span>
                    <span class="s1">hint.splice(hint.indexOf(optionKey), </span><span class="s3">1</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">hint === </span><span class="s0">'object'</span><span class="s1">) {</span>
                <span class="s2">delete </span><span class="s1">hint[optionKey];</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s4">// now delete the description from usage.js.</span>
        <span class="s2">delete </span><span class="s1">usage.getDescriptions()[optionKey];</span>
    <span class="s1">}</span>
    <span class="s1">self.config = </span><span class="s2">function </span><span class="s1">config(key = </span><span class="s0">'config'</span><span class="s1">, msg, parseFn) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'[object|string] [string|function] [function]'</span><span class="s1">, [key, msg, parseFn], arguments.length);</span>
        <span class="s4">// allow a config object to be provided directly.</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s2">typeof </span><span class="s1">key === </span><span class="s0">'object'</span><span class="s1">) &amp;&amp; !Array.isArray(key)) {</span>
            <span class="s1">key = apply_extends_1.applyExtends(key, cwd, self.getParserConfiguration()[</span><span class="s0">'deep-merge-config'</span><span class="s1">]);</span>
            <span class="s1">options.configObjects = (options.configObjects || []).concat(key);</span>
            <span class="s2">return </span><span class="s1">self;</span>
        <span class="s1">}</span>
        <span class="s4">// allow for a custom parsing function.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">msg === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s1">parseFn = msg;</span>
            <span class="s1">msg = undefined;</span>
        <span class="s1">}</span>
        <span class="s1">self.describe(key, msg || usage.deferY18nLookup(</span><span class="s0">'Path to JSON config file'</span><span class="s1">));</span>
        <span class="s1">(Array.isArray(key) ? key : [key]).forEach((k) =&gt; {</span>
            <span class="s1">options.config[k] = parseFn || </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.example = </span><span class="s2">function </span><span class="s1">(cmd, description) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;string|array&gt; [string]'</span><span class="s1">, [cmd, description], arguments.length);</span>
        <span class="s2">if </span><span class="s1">(Array.isArray(cmd)) {</span>
            <span class="s1">cmd.forEach((exampleParams) =&gt; self.example(...exampleParams));</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">usage.example(cmd, description);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.command = </span><span class="s2">function </span><span class="s1">(cmd, description, builder, handler, middlewares, deprecated) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;string|array|object&gt; [string|boolean] [function|object] [function] [array] [boolean|string]'</span><span class="s1">, [cmd, description, builder, handler, middlewares, deprecated], arguments.length);</span>
        <span class="s1">command.addHandler(cmd, description, builder, handler, middlewares, deprecated);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.commandDir = </span><span class="s2">function </span><span class="s1">(dir, opts) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;string&gt; [object]'</span><span class="s1">, [dir, opts], arguments.length);</span>
        <span class="s1">const req = parentRequire || require;</span>
        <span class="s1">command.addDirectory(dir, self.getContext(), req, require(</span><span class="s0">'get-caller-file'</span><span class="s1">)(), opts);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s4">// TODO: deprecate self.demand in favor of</span>
    <span class="s4">// .demandCommand() .demandOption().</span>
    <span class="s1">self.demand = self.required = self.require = </span><span class="s2">function </span><span class="s1">demand(keys, max, msg) {</span>
        <span class="s4">// you can optionally provide a 'max' key,</span>
        <span class="s4">// which will raise an exception if too many '_'</span>
        <span class="s4">// options are provided.</span>
        <span class="s2">if </span><span class="s1">(Array.isArray(max)) {</span>
            <span class="s1">max.forEach((key) =&gt; {</span>
                <span class="s1">common_types_1.assertNotStrictEqual(msg, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s1">demandOption(key, msg);</span>
            <span class="s1">});</span>
            <span class="s1">max = Infinity;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">max !== </span><span class="s0">'number'</span><span class="s1">) {</span>
            <span class="s1">msg = max;</span>
            <span class="s1">max = Infinity;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">keys === </span><span class="s0">'number'</span><span class="s1">) {</span>
            <span class="s1">common_types_1.assertNotStrictEqual(msg, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">self.demandCommand(keys, max, msg, msg);</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(Array.isArray(keys)) {</span>
            <span class="s1">keys.forEach((key) =&gt; {</span>
                <span class="s1">common_types_1.assertNotStrictEqual(msg, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s1">demandOption(key, msg);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">msg === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s1">demandOption(keys, msg);</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(msg === </span><span class="s2">true </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">msg === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
                <span class="s1">demandOption(keys);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.demandCommand = </span><span class="s2">function </span><span class="s1">demandCommand(min = </span><span class="s3">1</span><span class="s1">, max, minMsg, maxMsg) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'[number] [number|string] [string|null|undefined] [string|null|undefined]'</span><span class="s1">, [min, max, minMsg, maxMsg], arguments.length);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">max !== </span><span class="s0">'number'</span><span class="s1">) {</span>
            <span class="s1">minMsg = max;</span>
            <span class="s1">max = Infinity;</span>
        <span class="s1">}</span>
        <span class="s1">self.global(</span><span class="s0">'_'</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s1">options.demandedCommands._ = {</span>
            <span class="s1">min,</span>
            <span class="s1">max,</span>
            <span class="s1">minMsg,</span>
            <span class="s1">maxMsg</span>
        <span class="s1">};</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.getDemandedOptions = () =&gt; {</span>
        <span class="s1">argsert_1.argsert([], </span><span class="s3">0</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">options.demandedOptions;</span>
    <span class="s1">};</span>
    <span class="s1">self.getDemandedCommands = () =&gt; {</span>
        <span class="s1">argsert_1.argsert([], </span><span class="s3">0</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">options.demandedCommands;</span>
    <span class="s1">};</span>
    <span class="s1">self.deprecateOption = </span><span class="s2">function </span><span class="s1">deprecateOption(option, message) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;string&gt; [string|boolean]'</span><span class="s1">, [option, message], arguments.length);</span>
        <span class="s1">options.deprecatedOptions[option] = message;</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.getDeprecatedOptions = () =&gt; {</span>
        <span class="s1">argsert_1.argsert([], </span><span class="s3">0</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">options.deprecatedOptions;</span>
    <span class="s1">};</span>
    <span class="s1">self.implies = </span><span class="s2">function </span><span class="s1">(key, value) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;string|object&gt; [number|string|array]'</span><span class="s1">, [key, value], arguments.length);</span>
        <span class="s1">validation.implies(key, value);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.conflicts = </span><span class="s2">function </span><span class="s1">(key1, key2) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;string|object&gt; [string|array]'</span><span class="s1">, [key1, key2], arguments.length);</span>
        <span class="s1">validation.conflicts(key1, key2);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.usage = </span><span class="s2">function </span><span class="s1">(msg, description, builder, handler) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;string|null|undefined&gt; [string|boolean] [function|object] [function]'</span><span class="s1">, [msg, description, builder, handler], arguments.length);</span>
        <span class="s2">if </span><span class="s1">(description !== undefined) {</span>
            <span class="s1">common_types_1.assertNotStrictEqual(msg, </span><span class="s2">null</span><span class="s1">);</span>
            <span class="s4">// .usage() can be used as an alias for defining</span>
            <span class="s4">// a default command.</span>
            <span class="s2">if </span><span class="s1">((msg || </span><span class="s0">''</span><span class="s1">).match(/^\$0( |$)/)) {</span>
                <span class="s2">return </span><span class="s1">self.command(msg, description, builder, handler);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">throw new </span><span class="s1">yerror_1.YError(</span><span class="s0">'.usage() description must start with $0 if being used as alias for .command()'</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">usage.usage(msg);</span>
            <span class="s2">return </span><span class="s1">self;</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s1">self.epilogue = self.epilog = </span><span class="s2">function </span><span class="s1">(msg) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;string&gt;'</span><span class="s1">, [msg], arguments.length);</span>
        <span class="s1">usage.epilog(msg);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.fail = </span><span class="s2">function </span><span class="s1">(f) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;function&gt;'</span><span class="s1">, [f], arguments.length);</span>
        <span class="s1">usage.failFn(f);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.onFinishCommand = </span><span class="s2">function </span><span class="s1">(f) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;function&gt;'</span><span class="s1">, [f], arguments.length);</span>
        <span class="s1">handlerFinishCommand = f;</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.getHandlerFinishCommand = () =&gt; handlerFinishCommand;</span>
    <span class="s1">self.check = </span><span class="s2">function </span><span class="s1">(f, _global) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;function&gt; [boolean]'</span><span class="s1">, [f, _global], arguments.length);</span>
        <span class="s1">validation.check(f, _global !== </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.global = </span><span class="s2">function </span><span class="s1">global(globals, global) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;string|array&gt; [boolean]'</span><span class="s1">, [globals, global], arguments.length);</span>
        <span class="s1">globals = [].concat(globals);</span>
        <span class="s2">if </span><span class="s1">(global !== </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s1">options.local = options.local.filter(l =&gt; globals.indexOf(l) === -</span><span class="s3">1</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">globals.forEach((g) =&gt; {</span>
                <span class="s2">if </span><span class="s1">(options.local.indexOf(g) === -</span><span class="s3">1</span><span class="s1">)</span>
                    <span class="s1">options.local.push(g);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.pkgConf = </span><span class="s2">function </span><span class="s1">pkgConf(key, rootPath) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;string&gt; [string]'</span><span class="s1">, [key, rootPath], arguments.length);</span>
        <span class="s1">let conf = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s4">// prefer cwd to require-main-filename in this method</span>
        <span class="s4">// since we're looking for e.g. &quot;nyc&quot; config in nyc consumer</span>
        <span class="s4">// rather than &quot;yargs&quot; config in nyc (where nyc is the main filename)</span>
        <span class="s1">const obj = pkgUp(rootPath || cwd);</span>
        <span class="s4">// If an object exists in the key, add it to options.configObjects</span>
        <span class="s2">if </span><span class="s1">(obj[key] &amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj[key] === </span><span class="s0">'object'</span><span class="s1">) {</span>
            <span class="s1">conf = apply_extends_1.applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()[</span><span class="s0">'deep-merge-config'</span><span class="s1">]);</span>
            <span class="s1">options.configObjects = (options.configObjects || []).concat(conf);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">const pkgs = {};</span>
    <span class="s2">function </span><span class="s1">pkgUp(rootPath) {</span>
        <span class="s1">const npath = rootPath || </span><span class="s0">'*'</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(pkgs[npath])</span>
            <span class="s2">return </span><span class="s1">pkgs[npath];</span>
        <span class="s1">let obj = {};</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">let startDir = rootPath || requireMainFilename(parentRequire);</span>
            <span class="s4">// When called in an environment that lacks require.main.filename, such as a jest test runner,</span>
            <span class="s4">// startDir is already process.cwd(), and should not be shortened.</span>
            <span class="s4">// Whether or not it is _actually_ a directory (e.g., extensionless bin) is irrelevant, find-up handles it.</span>
            <span class="s2">if </span><span class="s1">(!rootPath &amp;&amp; path.extname(startDir)) {</span>
                <span class="s1">startDir = path.dirname(startDir);</span>
            <span class="s1">}</span>
            <span class="s1">const pkgJsonPath = findUp.sync(</span><span class="s0">'package.json'</span><span class="s1">, {</span>
                <span class="s1">cwd: startDir</span>
            <span class="s1">});</span>
            <span class="s1">common_types_1.assertNotStrictEqual(pkgJsonPath, undefined);</span>
            <span class="s1">obj = JSON.parse(fs.readFileSync(pkgJsonPath).toString());</span>
        <span class="s1">}</span>
        <span class="s2">catch </span><span class="s1">(noop) { }</span>
        <span class="s1">pkgs[npath] = obj || {};</span>
        <span class="s2">return </span><span class="s1">pkgs[npath];</span>
    <span class="s1">}</span>
    <span class="s1">let parseFn = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">let parseContext = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">self.parse = </span><span class="s2">function </span><span class="s1">parse(args, shortCircuit, _parseFn) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'[string|array] [function|boolean|object] [function]'</span><span class="s1">, [args, shortCircuit, _parseFn], arguments.length);</span>
        <span class="s1">freeze();</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">args === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
            <span class="s1">const argv = self._parseArgs(processArgs);</span>
            <span class="s1">const tmpParsed = self.parsed;</span>
            <span class="s1">unfreeze();</span>
            <span class="s4">// TODO: remove this compatibility hack when we release yargs@15.x:</span>
            <span class="s1">self.parsed = tmpParsed;</span>
            <span class="s2">return </span><span class="s1">argv;</span>
        <span class="s1">}</span>
        <span class="s4">// a context object can optionally be provided, this allows</span>
        <span class="s4">// additional information to be passed to a command handler.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">shortCircuit === </span><span class="s0">'object'</span><span class="s1">) {</span>
            <span class="s1">parseContext = shortCircuit;</span>
            <span class="s1">shortCircuit = _parseFn;</span>
        <span class="s1">}</span>
        <span class="s4">// by providing a function as a second argument to</span>
        <span class="s4">// parse you can capture output that would otherwise</span>
        <span class="s4">// default to printing to stdout/stderr.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">shortCircuit === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s1">parseFn = shortCircuit;</span>
            <span class="s1">shortCircuit = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// completion short-circuits the parsing process,</span>
        <span class="s4">// skipping validation, etc.</span>
        <span class="s2">if </span><span class="s1">(!shortCircuit)</span>
            <span class="s1">processArgs = args;</span>
        <span class="s2">if </span><span class="s1">(parseFn)</span>
            <span class="s1">exitProcess = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">const parsed = self._parseArgs(args, !!shortCircuit);</span>
        <span class="s1">completion.setParsed(self.parsed);</span>
        <span class="s2">if </span><span class="s1">(parseFn)</span>
            <span class="s1">parseFn(exitError, parsed, output);</span>
        <span class="s1">unfreeze();</span>
        <span class="s2">return </span><span class="s1">parsed;</span>
    <span class="s1">};</span>
    <span class="s1">self._getParseContext = () =&gt; parseContext || {};</span>
    <span class="s1">self._hasParseCallback = () =&gt; !!parseFn;</span>
    <span class="s1">self.option = self.options = </span><span class="s2">function </span><span class="s1">option(key, opt) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;string|object&gt; [object]'</span><span class="s1">, [key, opt], arguments.length);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">key === </span><span class="s0">'object'</span><span class="s1">) {</span>
            <span class="s1">Object.keys(key).forEach((k) =&gt; {</span>
                <span class="s1">self.options(k, key[k]);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">opt !== </span><span class="s0">'object'</span><span class="s1">) {</span>
                <span class="s1">opt = {};</span>
            <span class="s1">}</span>
            <span class="s1">options.key[key] = </span><span class="s2">true</span><span class="s1">; </span><span class="s4">// track manually set keys.</span>
            <span class="s2">if </span><span class="s1">(opt.alias)</span>
                <span class="s1">self.alias(key, opt.alias);</span>
            <span class="s1">const deprecate = opt.deprecate || opt.deprecated;</span>
            <span class="s2">if </span><span class="s1">(deprecate) {</span>
                <span class="s1">self.deprecateOption(key, deprecate);</span>
            <span class="s1">}</span>
            <span class="s1">const demand = opt.demand || opt.required || opt.require;</span>
            <span class="s4">// A required option can be specified via &quot;demand: true&quot;.</span>
            <span class="s2">if </span><span class="s1">(demand) {</span>
                <span class="s1">self.demand(key, demand);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.demandOption) {</span>
                <span class="s1">self.demandOption(key, </span><span class="s2">typeof </span><span class="s1">opt.demandOption === </span><span class="s0">'string' </span><span class="s1">? opt.demandOption : undefined);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.conflicts) {</span>
                <span class="s1">self.conflicts(key, opt.conflicts);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s2">in </span><span class="s1">opt) {</span>
                <span class="s1">self.</span><span class="s2">default</span><span class="s1">(key, opt.</span><span class="s2">default</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.implies !== undefined) {</span>
                <span class="s1">self.implies(key, opt.implies);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.nargs !== undefined) {</span>
                <span class="s1">self.nargs(key, opt.nargs);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.config) {</span>
                <span class="s1">self.config(key, opt.configParser);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.normalize) {</span>
                <span class="s1">self.normalize(key);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.choices) {</span>
                <span class="s1">self.choices(key, opt.choices);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.coerce) {</span>
                <span class="s1">self.coerce(key, opt.coerce);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.group) {</span>
                <span class="s1">self.group(key, opt.group);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.boolean || opt.type === </span><span class="s0">'boolean'</span><span class="s1">) {</span>
                <span class="s1">self.boolean(key);</span>
                <span class="s2">if </span><span class="s1">(opt.alias)</span>
                    <span class="s1">self.boolean(opt.alias);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.array || opt.type === </span><span class="s0">'array'</span><span class="s1">) {</span>
                <span class="s1">self.array(key);</span>
                <span class="s2">if </span><span class="s1">(opt.alias)</span>
                    <span class="s1">self.array(opt.alias);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.number || opt.type === </span><span class="s0">'number'</span><span class="s1">) {</span>
                <span class="s1">self.number(key);</span>
                <span class="s2">if </span><span class="s1">(opt.alias)</span>
                    <span class="s1">self.number(opt.alias);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.string || opt.type === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s1">self.string(key);</span>
                <span class="s2">if </span><span class="s1">(opt.alias)</span>
                    <span class="s1">self.string(opt.alias);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.count || opt.type === </span><span class="s0">'count'</span><span class="s1">) {</span>
                <span class="s1">self.count(key);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">opt.global === </span><span class="s0">'boolean'</span><span class="s1">) {</span>
                <span class="s1">self.global(key, opt.global);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.defaultDescription) {</span>
                <span class="s1">options.defaultDescription[key] = opt.defaultDescription;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.skipValidation) {</span>
                <span class="s1">self.skipValidation(key);</span>
            <span class="s1">}</span>
            <span class="s1">const desc = opt.describe || opt.description || opt.desc;</span>
            <span class="s1">self.describe(key, desc);</span>
            <span class="s2">if </span><span class="s1">(opt.hidden) {</span>
                <span class="s1">self.hide(key);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(opt.requiresArg) {</span>
                <span class="s1">self.requiresArg(key);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.getOptions = () =&gt; options;</span>
    <span class="s1">self.positional = </span><span class="s2">function </span><span class="s1">(key, opts) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;string&gt; &lt;object&gt;'</span><span class="s1">, [key, opts], arguments.length);</span>
        <span class="s2">if </span><span class="s1">(context.resets === </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s2">throw new </span><span class="s1">yerror_1.YError(</span><span class="s0">&quot;.positional() can only be called in a command's builder function&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s4">// .positional() only supports a subset of the configuration</span>
        <span class="s4">// options available to .option().</span>
        <span class="s1">const supportedOpts = [</span><span class="s0">'default'</span><span class="s1">, </span><span class="s0">'defaultDescription'</span><span class="s1">, </span><span class="s0">'implies'</span><span class="s1">, </span><span class="s0">'normalize'</span><span class="s1">,</span>
            <span class="s0">'choices'</span><span class="s1">, </span><span class="s0">'conflicts'</span><span class="s1">, </span><span class="s0">'coerce'</span><span class="s1">, </span><span class="s0">'type'</span><span class="s1">, </span><span class="s0">'describe'</span><span class="s1">,</span>
            <span class="s0">'desc'</span><span class="s1">, </span><span class="s0">'description'</span><span class="s1">, </span><span class="s0">'alias'</span><span class="s1">];</span>
        <span class="s1">opts = obj_filter_1.objFilter(opts, (k, v) =&gt; {</span>
            <span class="s1">let accept = supportedOpts.indexOf(k) !== -</span><span class="s3">1</span><span class="s1">;</span>
            <span class="s4">// type can be one of string|number|boolean.</span>
            <span class="s2">if </span><span class="s1">(k === </span><span class="s0">'type' </span><span class="s1">&amp;&amp; [</span><span class="s0">'string'</span><span class="s1">, </span><span class="s0">'number'</span><span class="s1">, </span><span class="s0">'boolean'</span><span class="s1">].indexOf(v) === -</span><span class="s3">1</span><span class="s1">)</span>
                <span class="s1">accept = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">return </span><span class="s1">accept;</span>
        <span class="s1">});</span>
        <span class="s4">// copy over any settings that can be inferred from the command string.</span>
        <span class="s1">const fullCommand = context.fullCommands[context.fullCommands.length - </span><span class="s3">1</span><span class="s1">];</span>
        <span class="s1">const parseOptions = fullCommand ? command.cmdToParseOptions(fullCommand) : {</span>
            <span class="s1">array: [],</span>
            <span class="s1">alias: {},</span>
            <span class="s2">default</span><span class="s1">: {},</span>
            <span class="s1">demand: {}</span>
        <span class="s1">};</span>
        <span class="s1">common_types_1.objectKeys(parseOptions).forEach((pk) =&gt; {</span>
            <span class="s1">const parseOption = parseOptions[pk];</span>
            <span class="s2">if </span><span class="s1">(Array.isArray(parseOption)) {</span>
                <span class="s2">if </span><span class="s1">(parseOption.indexOf(key) !== -</span><span class="s3">1</span><span class="s1">)</span>
                    <span class="s1">opts[pk] = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(parseOption[key] &amp;&amp; !(pk </span><span class="s2">in </span><span class="s1">opts))</span>
                    <span class="s1">opts[pk] = parseOption[key];</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s1">self.group(key, usage.getPositionalGroupName());</span>
        <span class="s2">return </span><span class="s1">self.option(key, opts);</span>
    <span class="s1">};</span>
    <span class="s1">self.group = </span><span class="s2">function </span><span class="s1">group(opts, groupName) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;string|array&gt; &lt;string&gt;'</span><span class="s1">, [opts, groupName], arguments.length);</span>
        <span class="s1">const existing = preservedGroups[groupName] || groups[groupName];</span>
        <span class="s2">if </span><span class="s1">(preservedGroups[groupName]) {</span>
            <span class="s4">// we now only need to track this group name in groups.</span>
            <span class="s2">delete </span><span class="s1">preservedGroups[groupName];</span>
        <span class="s1">}</span>
        <span class="s1">const seen = {};</span>
        <span class="s1">groups[groupName] = (existing || []).concat(opts).filter((key) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(seen[key])</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s2">return </span><span class="s1">(seen[key] = </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s4">// combine explicit and preserved groups. explicit groups should be first</span>
    <span class="s1">self.getGroups = () =&gt; Object.assign({}, groups, preservedGroups);</span>
    <span class="s4">// as long as options.envPrefix is not undefined,</span>
    <span class="s4">// parser will apply env vars matching prefix to argv</span>
    <span class="s1">self.env = </span><span class="s2">function </span><span class="s1">(prefix) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'[string|boolean]'</span><span class="s1">, [prefix], arguments.length);</span>
        <span class="s2">if </span><span class="s1">(prefix === </span><span class="s2">false</span><span class="s1">)</span>
            <span class="s2">delete </span><span class="s1">options.envPrefix;</span>
        <span class="s2">else</span>
            <span class="s1">options.envPrefix = prefix || </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.wrap = </span><span class="s2">function </span><span class="s1">(cols) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;number|null|undefined&gt;'</span><span class="s1">, [cols], arguments.length);</span>
        <span class="s1">usage.wrap(cols);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">let strict = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">self.strict = </span><span class="s2">function </span><span class="s1">(enabled) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'[boolean]'</span><span class="s1">, [enabled], arguments.length);</span>
        <span class="s1">strict = enabled !== </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.getStrict = () =&gt; strict;</span>
    <span class="s1">let strictCommands = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">self.strictCommands = </span><span class="s2">function </span><span class="s1">(enabled) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'[boolean]'</span><span class="s1">, [enabled], arguments.length);</span>
        <span class="s1">strictCommands = enabled !== </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.getStrictCommands = () =&gt; strictCommands;</span>
    <span class="s1">let parserConfig = {};</span>
    <span class="s1">self.parserConfiguration = </span><span class="s2">function </span><span class="s1">parserConfiguration(config) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;object&gt;'</span><span class="s1">, [config], arguments.length);</span>
        <span class="s1">parserConfig = config;</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.getParserConfiguration = () =&gt; parserConfig;</span>
    <span class="s1">self.showHelp = </span><span class="s2">function </span><span class="s1">(level) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'[string|function]'</span><span class="s1">, [level], arguments.length);</span>
        <span class="s2">if </span><span class="s1">(!self.parsed)</span>
            <span class="s1">self._parseArgs(processArgs); </span><span class="s4">// run parser, if it has not already been executed.</span>
        <span class="s2">if </span><span class="s1">(command.hasDefaultCommand()) {</span>
            <span class="s1">context.resets++; </span><span class="s4">// override the restriction on top-level positoinals.</span>
            <span class="s1">command.runDefaultBuilderOn(self);</span>
        <span class="s1">}</span>
        <span class="s1">usage.showHelp(level);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">let versionOpt = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">self.version = </span><span class="s2">function </span><span class="s1">version(opt, msg, ver) {</span>
        <span class="s1">const defaultVersionOpt = </span><span class="s0">'version'</span><span class="s1">;</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'[boolean|string] [string] [string]'</span><span class="s1">, [opt, msg, ver], arguments.length);</span>
        <span class="s4">// nuke the key previously configured</span>
        <span class="s4">// to return version #.</span>
        <span class="s2">if </span><span class="s1">(versionOpt) {</span>
            <span class="s1">deleteFromParserHintObject(versionOpt);</span>
            <span class="s1">usage.version(undefined);</span>
            <span class="s1">versionOpt = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(arguments.length === </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s1">ver = guessVersion();</span>
            <span class="s1">opt = defaultVersionOpt;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(arguments.length === </span><span class="s3">1</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(opt === </span><span class="s2">false</span><span class="s1">) { </span><span class="s4">// disable default 'version' key.</span>
                <span class="s2">return </span><span class="s1">self;</span>
            <span class="s1">}</span>
            <span class="s1">ver = opt;</span>
            <span class="s1">opt = defaultVersionOpt;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(arguments.length === </span><span class="s3">2</span><span class="s1">) {</span>
            <span class="s1">ver = msg;</span>
            <span class="s1">msg = undefined;</span>
        <span class="s1">}</span>
        <span class="s1">versionOpt = </span><span class="s2">typeof </span><span class="s1">opt === </span><span class="s0">'string' </span><span class="s1">? opt : defaultVersionOpt;</span>
        <span class="s1">msg = msg || usage.deferY18nLookup(</span><span class="s0">'Show version number'</span><span class="s1">);</span>
        <span class="s1">usage.version(ver || undefined);</span>
        <span class="s1">self.boolean(versionOpt);</span>
        <span class="s1">self.describe(versionOpt, msg);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s2">function </span><span class="s1">guessVersion() {</span>
        <span class="s1">const obj = pkgUp();</span>
        <span class="s2">return </span><span class="s1">obj.version || </span><span class="s0">'unknown'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">let helpOpt = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">self.addHelpOpt = self.help = </span><span class="s2">function </span><span class="s1">addHelpOpt(opt, msg) {</span>
        <span class="s1">const defaultHelpOpt = </span><span class="s0">'help'</span><span class="s1">;</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'[string|boolean] [string]'</span><span class="s1">, [opt, msg], arguments.length);</span>
        <span class="s4">// nuke the key previously configured</span>
        <span class="s4">// to return help.</span>
        <span class="s2">if </span><span class="s1">(helpOpt) {</span>
            <span class="s1">deleteFromParserHintObject(helpOpt);</span>
            <span class="s1">helpOpt = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(arguments.length === </span><span class="s3">1</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(opt === </span><span class="s2">false</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">self;</span>
        <span class="s1">}</span>
        <span class="s4">// use arguments, fallback to defaults for opt and msg</span>
        <span class="s1">helpOpt = </span><span class="s2">typeof </span><span class="s1">opt === </span><span class="s0">'string' </span><span class="s1">? opt : defaultHelpOpt;</span>
        <span class="s1">self.boolean(helpOpt);</span>
        <span class="s1">self.describe(helpOpt, msg || usage.deferY18nLookup(</span><span class="s0">'Show help'</span><span class="s1">));</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">const defaultShowHiddenOpt = </span><span class="s0">'show-hidden'</span><span class="s1">;</span>
    <span class="s1">options.showHiddenOpt = defaultShowHiddenOpt;</span>
    <span class="s1">self.addShowHiddenOpt = self.showHidden = </span><span class="s2">function </span><span class="s1">addShowHiddenOpt(opt, msg) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'[string|boolean] [string]'</span><span class="s1">, [opt, msg], arguments.length);</span>
        <span class="s2">if </span><span class="s1">(arguments.length === </span><span class="s3">1</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(opt === </span><span class="s2">false</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">self;</span>
        <span class="s1">}</span>
        <span class="s1">const showHiddenOpt = </span><span class="s2">typeof </span><span class="s1">opt === </span><span class="s0">'string' </span><span class="s1">? opt : defaultShowHiddenOpt;</span>
        <span class="s1">self.boolean(showHiddenOpt);</span>
        <span class="s1">self.describe(showHiddenOpt, msg || usage.deferY18nLookup(</span><span class="s0">'Show hidden options'</span><span class="s1">));</span>
        <span class="s1">options.showHiddenOpt = showHiddenOpt;</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.hide = </span><span class="s2">function </span><span class="s1">hide(key) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;string&gt;'</span><span class="s1">, [key], arguments.length);</span>
        <span class="s1">options.hiddenOptions.push(key);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.showHelpOnFail = </span><span class="s2">function </span><span class="s1">showHelpOnFail(enabled, message) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'[boolean|string] [string]'</span><span class="s1">, [enabled, message], arguments.length);</span>
        <span class="s1">usage.showHelpOnFail(enabled, message);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">exitProcess = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">self.exitProcess = </span><span class="s2">function </span><span class="s1">(enabled = </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'[boolean]'</span><span class="s1">, [enabled], arguments.length);</span>
        <span class="s1">exitProcess = enabled;</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.getExitProcess = () =&gt; exitProcess;</span>
    <span class="s2">var </span><span class="s1">completionCommand = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">self.completion = </span><span class="s2">function </span><span class="s1">(cmd, desc, fn) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'[string] [string|boolean|function] [function]'</span><span class="s1">, [cmd, desc, fn], arguments.length);</span>
        <span class="s4">// a function to execute when generating</span>
        <span class="s4">// completions can be provided as the second</span>
        <span class="s4">// or third argument to completion.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">desc === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s1">fn = desc;</span>
            <span class="s1">desc = undefined;</span>
        <span class="s1">}</span>
        <span class="s4">// register the completion command.</span>
        <span class="s1">completionCommand = cmd || completionCommand || </span><span class="s0">'completion'</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(!desc &amp;&amp; desc !== </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s1">desc = </span><span class="s0">'generate completion script'</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">self.command(completionCommand, desc);</span>
        <span class="s4">// a function can be provided</span>
        <span class="s2">if </span><span class="s1">(fn)</span>
            <span class="s1">completion.registerFunction(fn);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.showCompletionScript = </span><span class="s2">function </span><span class="s1">($0, cmd) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'[string] [string]'</span><span class="s1">, [$0, cmd], arguments.length);</span>
        <span class="s1">$0 = $0 || self.$0;</span>
        <span class="s1">_logger.log(completion.generateCompletionScript($0, cmd || completionCommand || </span><span class="s0">'completion'</span><span class="s1">));</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.getCompletion = </span><span class="s2">function </span><span class="s1">(args, done) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;array&gt; &lt;function&gt;'</span><span class="s1">, [args, done], arguments.length);</span>
        <span class="s1">completion.getCompletion(args, done);</span>
    <span class="s1">};</span>
    <span class="s1">self.locale = </span><span class="s2">function </span><span class="s1">(locale) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'[string]'</span><span class="s1">, [locale], arguments.length);</span>
        <span class="s2">if </span><span class="s1">(!locale) {</span>
            <span class="s1">guessLocale();</span>
            <span class="s2">return </span><span class="s1">y18n.getLocale();</span>
        <span class="s1">}</span>
        <span class="s1">detectLocale = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">y18n.setLocale(locale);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.updateStrings = self.updateLocale = </span><span class="s2">function </span><span class="s1">(obj) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;object&gt;'</span><span class="s1">, [obj], arguments.length);</span>
        <span class="s1">detectLocale = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">y18n.updateLocale(obj);</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">let detectLocale = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">self.detectLocale = </span><span class="s2">function </span><span class="s1">(detect) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'&lt;boolean&gt;'</span><span class="s1">, [detect], arguments.length);</span>
        <span class="s1">detectLocale = detect;</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.getDetectLocale = () =&gt; detectLocale;</span>
    <span class="s2">var </span><span class="s1">hasOutput = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">exitError = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s4">// maybe exit, always capture</span>
    <span class="s4">// context about why we wanted to exit.</span>
    <span class="s1">self.exit = (code, err) =&gt; {</span>
        <span class="s1">hasOutput = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">exitError = err;</span>
        <span class="s2">if </span><span class="s1">(exitProcess)</span>
            <span class="s1">process.exit(code);</span>
    <span class="s1">};</span>
    <span class="s4">// we use a custom logger that buffers output,</span>
    <span class="s4">// so that we can print to non-CLIs, e.g., chat-bots.</span>
    <span class="s1">const _logger = {</span>
        <span class="s1">log(...args) {</span>
            <span class="s2">if </span><span class="s1">(!self._hasParseCallback())</span>
                <span class="s1">console.log(...args);</span>
            <span class="s1">hasOutput = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(output.length)</span>
                <span class="s1">output += </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
            <span class="s1">output += args.join(</span><span class="s0">' '</span><span class="s1">);</span>
        <span class="s1">},</span>
        <span class="s1">error(...args) {</span>
            <span class="s2">if </span><span class="s1">(!self._hasParseCallback())</span>
                <span class="s1">console.error(...args);</span>
            <span class="s1">hasOutput = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(output.length)</span>
                <span class="s1">output += </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
            <span class="s1">output += args.join(</span><span class="s0">' '</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s1">self._getLoggerInstance = () =&gt; _logger;</span>
    <span class="s4">// has yargs output an error our help</span>
    <span class="s4">// message in the current execution context.</span>
    <span class="s1">self._hasOutput = () =&gt; hasOutput;</span>
    <span class="s1">self._setHasOutput = () =&gt; {</span>
        <span class="s1">hasOutput = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s1">let recommendCommands;</span>
    <span class="s1">self.recommendCommands = </span><span class="s2">function </span><span class="s1">(recommend = </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">argsert_1.argsert(</span><span class="s0">'[boolean]'</span><span class="s1">, [recommend], arguments.length);</span>
        <span class="s1">recommendCommands = recommend;</span>
        <span class="s2">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">self.getUsageInstance = () =&gt; usage;</span>
    <span class="s1">self.getValidationInstance = () =&gt; validation;</span>
    <span class="s1">self.getCommandInstance = () =&gt; command;</span>
    <span class="s1">self.terminalWidth = () =&gt; {</span>
        <span class="s1">argsert_1.argsert([], </span><span class="s3">0</span><span class="s1">);</span>
        <span class="s2">return typeof </span><span class="s1">process.stdout.columns !== </span><span class="s0">'undefined' </span><span class="s1">? process.stdout.columns : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s1">Object.defineProperty(self, </span><span class="s0">'argv'</span><span class="s1">, {</span>
        <span class="s1">get: () =&gt; self._parseArgs(processArgs),</span>
        <span class="s1">enumerable: </span><span class="s2">true</span>
    <span class="s1">});</span>
    <span class="s1">self._parseArgs = </span><span class="s2">function </span><span class="s1">parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) {</span>
        <span class="s1">let skipValidation = !!_calledFromCommand;</span>
        <span class="s1">args = args || processArgs;</span>
        <span class="s1">options.__ = y18n.__;</span>
        <span class="s1">options.configuration = self.getParserConfiguration();</span>
        <span class="s1">const populateDoubleDash = !!options.configuration[</span><span class="s0">'populate--'</span><span class="s1">];</span>
        <span class="s1">const config = Object.assign({}, options.configuration, {</span>
            <span class="s0">'populate--'</span><span class="s1">: </span><span class="s2">true</span>
        <span class="s1">});</span>
        <span class="s1">const parsed = Parser.detailed(args, Object.assign({}, options, {</span>
            <span class="s1">configuration: config</span>
        <span class="s1">}));</span>
        <span class="s1">let argv = parsed.argv;</span>
        <span class="s2">if </span><span class="s1">(parseContext)</span>
            <span class="s1">argv = Object.assign({}, argv, parseContext);</span>
        <span class="s1">const aliases = parsed.aliases;</span>
        <span class="s1">argv.$0 = self.$0;</span>
        <span class="s1">self.parsed = parsed;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">guessLocale(); </span><span class="s4">// guess locale lazily, so that it can be turned off in chain.</span>
            <span class="s4">// while building up the argv object, there</span>
            <span class="s4">// are two passes through the parser. If completion</span>
            <span class="s4">// is being performed short-circuit on the first pass.</span>
            <span class="s2">if </span><span class="s1">(shortCircuit) {</span>
                <span class="s2">return </span><span class="s1">(populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);</span>
            <span class="s1">}</span>
            <span class="s4">// if there's a handler associated with a</span>
            <span class="s4">// command defer processing to it.</span>
            <span class="s2">if </span><span class="s1">(helpOpt) {</span>
                <span class="s4">// consider any multi-char helpOpt alias as a valid help command</span>
                <span class="s4">// unless all helpOpt aliases are single-char</span>
                <span class="s4">// note that parsed.aliases is a normalized bidirectional map :)</span>
                <span class="s1">const helpCmds = [helpOpt]</span>
                    <span class="s1">.concat(aliases[helpOpt] || [])</span>
                    <span class="s1">.filter(k =&gt; k.length &gt; </span><span class="s3">1</span><span class="s1">);</span>
                <span class="s4">// check if help should trigger and strip it from _.</span>
                <span class="s2">if </span><span class="s1">(~helpCmds.indexOf(argv._[argv._.length - </span><span class="s3">1</span><span class="s1">])) {</span>
                    <span class="s1">argv._.pop();</span>
                    <span class="s1">argv[helpOpt] = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">const handlerKeys = command.getCommands();</span>
            <span class="s1">const requestCompletions = completion.completionKey </span><span class="s2">in </span><span class="s1">argv;</span>
            <span class="s1">const skipRecommendation = argv[helpOpt] || requestCompletions;</span>
            <span class="s1">const skipDefaultCommand = skipRecommendation &amp;&amp; (handlerKeys.length &gt; </span><span class="s3">1 </span><span class="s1">|| handlerKeys[</span><span class="s3">0</span><span class="s1">] !== </span><span class="s0">'$0'</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(argv._.length) {</span>
                <span class="s2">if </span><span class="s1">(handlerKeys.length) {</span>
                    <span class="s1">let firstUnknownCommand;</span>
                    <span class="s2">for </span><span class="s1">(let i = (commandIndex || </span><span class="s3">0</span><span class="s1">), cmd; argv._[i] !== undefined; i++) {</span>
                        <span class="s1">cmd = String(argv._[i]);</span>
                        <span class="s2">if </span><span class="s1">(~handlerKeys.indexOf(cmd) &amp;&amp; cmd !== completionCommand) {</span>
                            <span class="s4">// commands are executed using a recursive algorithm that executes</span>
                            <span class="s4">// the deepest command first; we keep track of the position in the</span>
                            <span class="s4">// argv._ array that is currently being executed.</span>
                            <span class="s1">const innerArgv = command.runCommand(cmd, self, parsed, i + </span><span class="s3">1</span><span class="s1">);</span>
                            <span class="s2">return </span><span class="s1">populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);</span>
                        <span class="s1">}</span>
                        <span class="s2">else if </span><span class="s1">(!firstUnknownCommand &amp;&amp; cmd !== completionCommand) {</span>
                            <span class="s1">firstUnknownCommand = cmd;</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s4">// run the default command, if defined</span>
                    <span class="s2">if </span><span class="s1">(command.hasDefaultCommand() &amp;&amp; !skipDefaultCommand) {</span>
                        <span class="s1">const innerArgv = command.runCommand(</span><span class="s2">null</span><span class="s1">, self, parsed);</span>
                        <span class="s2">return </span><span class="s1">populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);</span>
                    <span class="s1">}</span>
                    <span class="s4">// recommend a command if recommendCommands() has</span>
                    <span class="s4">// been enabled, and no commands were found to execute</span>
                    <span class="s2">if </span><span class="s1">(recommendCommands &amp;&amp; firstUnknownCommand &amp;&amp; !skipRecommendation) {</span>
                        <span class="s1">validation.recommendCommands(firstUnknownCommand, handlerKeys);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s4">// generate a completion script for adding to ~/.bashrc.</span>
                <span class="s2">if </span><span class="s1">(completionCommand &amp;&amp; ~argv._.indexOf(completionCommand) &amp;&amp; !requestCompletions) {</span>
                    <span class="s2">if </span><span class="s1">(exitProcess)</span>
                        <span class="s1">setBlocking(</span><span class="s2">true</span><span class="s1">);</span>
                    <span class="s1">self.showCompletionScript();</span>
                    <span class="s1">self.exit(</span><span class="s3">0</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(command.hasDefaultCommand() &amp;&amp; !skipDefaultCommand) {</span>
                <span class="s1">const innerArgv = command.runCommand(</span><span class="s2">null</span><span class="s1">, self, parsed);</span>
                <span class="s2">return </span><span class="s1">populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);</span>
            <span class="s1">}</span>
            <span class="s4">// we must run completions first, a user might</span>
            <span class="s4">// want to complete the --help or --version option.</span>
            <span class="s2">if </span><span class="s1">(requestCompletions) {</span>
                <span class="s2">if </span><span class="s1">(exitProcess)</span>
                    <span class="s1">setBlocking(</span><span class="s2">true</span><span class="s1">);</span>
                <span class="s4">// we allow for asynchronous completions,</span>
                <span class="s4">// e.g., loading in a list of commands from an API.</span>
                <span class="s1">args = [].concat(args);</span>
                <span class="s1">const completionArgs = args.slice(args.indexOf(`--${completion.completionKey}`) + </span><span class="s3">1</span><span class="s1">);</span>
                <span class="s1">completion.getCompletion(completionArgs, (completions) =&gt; {</span>
                    <span class="s1">;</span>
                    <span class="s1">(completions || []).forEach((completion) =&gt; {</span>
                        <span class="s1">_logger.log(completion);</span>
                    <span class="s1">});</span>
                    <span class="s1">self.exit(</span><span class="s3">0</span><span class="s1">);</span>
                <span class="s1">});</span>
                <span class="s2">return </span><span class="s1">(populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);</span>
            <span class="s1">}</span>
            <span class="s4">// Handle 'help' and 'version' options</span>
            <span class="s4">// if we haven't already output help!</span>
            <span class="s2">if </span><span class="s1">(!hasOutput) {</span>
                <span class="s1">Object.keys(argv).forEach((key) =&gt; {</span>
                    <span class="s2">if </span><span class="s1">(key === helpOpt &amp;&amp; argv[key]) {</span>
                        <span class="s2">if </span><span class="s1">(exitProcess)</span>
                            <span class="s1">setBlocking(</span><span class="s2">true</span><span class="s1">);</span>
                        <span class="s1">skipValidation = </span><span class="s2">true</span><span class="s1">;</span>
                        <span class="s1">self.showHelp(</span><span class="s0">'log'</span><span class="s1">);</span>
                        <span class="s1">self.exit(</span><span class="s3">0</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(key === versionOpt &amp;&amp; argv[key]) {</span>
                        <span class="s2">if </span><span class="s1">(exitProcess)</span>
                            <span class="s1">setBlocking(</span><span class="s2">true</span><span class="s1">);</span>
                        <span class="s1">skipValidation = </span><span class="s2">true</span><span class="s1">;</span>
                        <span class="s1">usage.showVersion();</span>
                        <span class="s1">self.exit(</span><span class="s3">0</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// Check if any of the options to skip validation were provided</span>
            <span class="s2">if </span><span class="s1">(!skipValidation &amp;&amp; options.skipValidation.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">skipValidation = Object.keys(argv).some(key =&gt; options.skipValidation.indexOf(key) &gt;= </span><span class="s3">0 </span><span class="s1">&amp;&amp; argv[key] === </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s4">// If the help or version options where used and exitProcess is false,</span>
            <span class="s4">// or if explicitly skipped, we won't run validations.</span>
            <span class="s2">if </span><span class="s1">(!skipValidation) {</span>
                <span class="s2">if </span><span class="s1">(parsed.error)</span>
                    <span class="s2">throw new </span><span class="s1">yerror_1.YError(parsed.error.message);</span>
                <span class="s4">// if we're executed via bash completion, don't</span>
                <span class="s4">// bother with validation.</span>
                <span class="s2">if </span><span class="s1">(!requestCompletions) {</span>
                    <span class="s1">self._runValidation(argv, aliases, {}, parsed.error);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">catch </span><span class="s1">(err) {</span>
            <span class="s2">if </span><span class="s1">(err </span><span class="s2">instanceof </span><span class="s1">yerror_1.YError)</span>
                <span class="s1">usage.fail(err.message, err);</span>
            <span class="s2">else</span>
                <span class="s2">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);</span>
    <span class="s1">};</span>
    <span class="s4">// to simplify the parsing of positionals in commands,</span>
    <span class="s4">// we temporarily populate '--' rather than _, with arguments</span>
    <span class="s4">// after the '--' directive. After the parse, we copy these back.</span>
    <span class="s1">self._copyDoubleDash = </span><span class="s2">function </span><span class="s1">(argv) {</span>
        <span class="s2">if </span><span class="s1">(is_promise_1.isPromise(argv) || !argv._ || !argv[</span><span class="s0">'--'</span><span class="s1">])</span>
            <span class="s2">return </span><span class="s1">argv;</span>
        <span class="s1">argv._.push.apply(argv._, argv[</span><span class="s0">'--'</span><span class="s1">]);</span>
        <span class="s4">// TODO(bcoe): refactor command parsing such that this delete is not</span>
        <span class="s4">// necessary: https://github.com/yargs/yargs/issues/1482</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">delete </span><span class="s1">argv[</span><span class="s0">'--'</span><span class="s1">];</span>
        <span class="s1">}</span>
        <span class="s2">catch </span><span class="s1">(_err) { }</span>
        <span class="s2">return </span><span class="s1">argv;</span>
    <span class="s1">};</span>
    <span class="s1">self._runValidation = </span><span class="s2">function </span><span class="s1">runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(parseErrors)</span>
            <span class="s2">throw new </span><span class="s1">yerror_1.YError(parseErrors.message);</span>
        <span class="s1">validation.nonOptionCount(argv);</span>
        <span class="s1">validation.requiredArguments(argv);</span>
        <span class="s1">let failedStrictCommands = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(strictCommands) {</span>
            <span class="s1">failedStrictCommands = validation.unknownCommands(argv);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(strict &amp;&amp; !failedStrictCommands) {</span>
            <span class="s1">validation.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);</span>
        <span class="s1">}</span>
        <span class="s1">validation.customChecks(argv, aliases);</span>
        <span class="s1">validation.limitedChoices(argv);</span>
        <span class="s1">validation.implications(argv);</span>
        <span class="s1">validation.conflicting(argv);</span>
    <span class="s1">};</span>
    <span class="s2">function </span><span class="s1">guessLocale() {</span>
        <span class="s2">if </span><span class="s1">(!detectLocale)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">const locale = process.env.LC_ALL || process.env.LC_MESSAGES || process.env.LANG || process.env.LANGUAGE || </span><span class="s0">'en_US'</span><span class="s1">;</span>
        <span class="s1">self.locale(locale.replace(/[.:].*/, </span><span class="s0">''</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s4">// an app should almost always have --version and --help,</span>
    <span class="s4">// if you *really* want to disable this use .help(false)/.version(false).</span>
    <span class="s1">self.help();</span>
    <span class="s1">self.version();</span>
    <span class="s2">return </span><span class="s1">self;</span>
<span class="s1">}</span>
<span class="s1">exports.Yargs = Yargs;</span>
<span class="s4">// rebase an absolute path to a relative one with respect to a base directory</span>
<span class="s4">// exported for tests</span>
<span class="s2">function </span><span class="s1">rebase(base, dir) {</span>
    <span class="s2">return </span><span class="s1">path.relative(base, dir);</span>
<span class="s1">}</span>
<span class="s1">exports.rebase = rebase;</span>
<span class="s2">function </span><span class="s1">isYargsInstance(y) {</span>
    <span class="s2">return </span><span class="s1">!!y &amp;&amp; (</span><span class="s2">typeof </span><span class="s1">y._parseArgs === </span><span class="s0">'function'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s1">exports.isYargsInstance = isYargsInstance;</span>
</pre>
</body>
</html>
<html>
<head>
<title>ScriptTransformer.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ScriptTransformer.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">'__esModule'</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.createScriptTransformer = createScriptTransformer;</span>
<span class="s1">exports.createTranspilingRequire = createTranspilingRequire;</span>
<span class="s2">function </span><span class="s1">_crypto() {</span>
  <span class="s1">const data = require(</span><span class="s0">'crypto'</span><span class="s1">);</span>
  <span class="s1">_crypto = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">path() {</span>
  <span class="s1">const data = _interopRequireWildcard(require(</span><span class="s0">'path'</span><span class="s1">));</span>
  <span class="s1">path = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_core() {</span>
  <span class="s1">const data = require(</span><span class="s0">'@babel/core'</span><span class="s1">);</span>
  <span class="s1">_core = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_babelPluginIstanbul() {</span>
  <span class="s1">const data = _interopRequireDefault(require(</span><span class="s0">'babel-plugin-istanbul'</span><span class="s1">));</span>
  <span class="s1">_babelPluginIstanbul = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_convertSourceMap() {</span>
  <span class="s1">const data = require(</span><span class="s0">'convert-source-map'</span><span class="s1">);</span>
  <span class="s1">_convertSourceMap = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_fastJsonStableStringify() {</span>
  <span class="s1">const data = _interopRequireDefault(require(</span><span class="s0">'fast-json-stable-stringify'</span><span class="s1">));</span>
  <span class="s1">_fastJsonStableStringify = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">fs() {</span>
  <span class="s1">const data = _interopRequireWildcard(require(</span><span class="s0">'graceful-fs'</span><span class="s1">));</span>
  <span class="s1">fs = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_pirates() {</span>
  <span class="s1">const data = require(</span><span class="s0">'pirates'</span><span class="s1">);</span>
  <span class="s1">_pirates = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_slash() {</span>
  <span class="s1">const data = _interopRequireDefault(require(</span><span class="s0">'slash'</span><span class="s1">));</span>
  <span class="s1">_slash = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_writeFileAtomic() {</span>
  <span class="s1">const data = require(</span><span class="s0">'write-file-atomic'</span><span class="s1">);</span>
  <span class="s1">_writeFileAtomic = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestHasteMap() {</span>
  <span class="s1">const data = _interopRequireDefault(require(</span><span class="s0">'jest-haste-map'</span><span class="s1">));</span>
  <span class="s1">_jestHasteMap = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestUtil() {</span>
  <span class="s1">const data = require(</span><span class="s0">'jest-util'</span><span class="s1">);</span>
  <span class="s1">_jestUtil = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">_enhanceUnexpectedTokenMessage = _interopRequireDefault(</span>
  <span class="s1">require(</span><span class="s0">'./enhanceUnexpectedTokenMessage'</span><span class="s1">)</span>
<span class="s1">);</span>
<span class="s2">var </span><span class="s1">_runtimeErrorsAndWarnings = require(</span><span class="s0">'./runtimeErrorsAndWarnings'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_shouldInstrument = _interopRequireDefault(require(</span><span class="s0">'./shouldInstrument'</span><span class="s1">));</span>
<span class="s2">function </span><span class="s1">_interopRequireDefault(obj) {</span>
  <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span><span class="s2">default</span><span class="s1">: obj};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">'function'</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
  <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
  <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function </span><span class="s1">(nodeInterop) {</span>
    <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
  <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interopRequireWildcard(obj, nodeInterop) {</span>
  <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
    <span class="s2">return </span><span class="s1">obj;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">'function'</span><span class="s1">)) {</span>
    <span class="s2">return </span><span class="s1">{</span><span class="s2">default</span><span class="s1">: obj};</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
  <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
    <span class="s2">return </span><span class="s1">cache.get(obj);</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">newObj = {};</span>
  <span class="s2">var </span><span class="s1">hasPropertyDescriptor =</span>
    <span class="s1">Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj) {</span>
    <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">'default' </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
      <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor</span>
        <span class="s1">? Object.getOwnPropertyDescriptor(obj, key)</span>
        <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
        <span class="s1">Object.defineProperty(newObj, key, desc);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">newObj[key] = obj[key];</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">newObj.</span><span class="s2">default </span><span class="s1">= obj;</span>
  <span class="s2">if </span><span class="s1">(cache) {</span>
    <span class="s1">cache.set(obj, newObj);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s3">// @ts-expect-error: should just be `require.resolve`, but the tests mess that up</span>

<span class="s3">// Use `require` to avoid TS rootDir</span>
<span class="s1">const {version: VERSION} = require(</span><span class="s0">'../package.json'</span><span class="s1">);</span>
<span class="s3">// This data structure is used to avoid recalculating some data every time that</span>
<span class="s3">// we need to transform a file. Since ScriptTransformer is instantiated for each</span>
<span class="s3">// file we need to keep this object in the local scope of this module.</span>
<span class="s1">const projectCaches = </span><span class="s2">new </span><span class="s1">Map();</span>

<span class="s3">// To reset the cache for specific changesets (rather than package version).</span>
<span class="s1">const CACHE_VERSION = </span><span class="s0">'1'</span><span class="s1">;</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">waitForPromiseWithCleanup(promise, cleanup) {</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s1">await promise;</span>
  <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
    <span class="s1">cleanup();</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">// type predicate</span>
<span class="s2">function </span><span class="s1">isTransformerFactory(t) {</span>
  <span class="s2">return typeof </span><span class="s1">t.createTransformer === </span><span class="s0">'function'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">class ScriptTransformer {</span>
  <span class="s1">_cache;</span>
  <span class="s1">_transformCache = </span><span class="s2">new </span><span class="s1">Map();</span>
  <span class="s1">_transformsAreLoaded = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">constructor(_config, _cacheFS) {</span>
    <span class="s2">this</span><span class="s1">._config = _config;</span>
    <span class="s2">this</span><span class="s1">._cacheFS = _cacheFS;</span>
    <span class="s1">const configString = (</span><span class="s4">0</span><span class="s1">, _fastJsonStableStringify().</span><span class="s2">default</span><span class="s1">)(</span><span class="s2">this</span><span class="s1">._config);</span>
    <span class="s1">let projectCache = projectCaches.get(configString);</span>
    <span class="s2">if </span><span class="s1">(!projectCache) {</span>
      <span class="s1">projectCache = {</span>
        <span class="s1">configString,</span>
        <span class="s1">ignorePatternsRegExp: calcIgnorePatternRegExp(</span><span class="s2">this</span><span class="s1">._config),</span>
        <span class="s1">transformRegExp: calcTransformRegExp(</span><span class="s2">this</span><span class="s1">._config),</span>
        <span class="s1">transformedFiles: </span><span class="s2">new </span><span class="s1">Map()</span>
      <span class="s1">};</span>
      <span class="s1">projectCaches.set(configString, projectCache);</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">._cache = projectCache;</span>
  <span class="s1">}</span>
  <span class="s1">_buildCacheKeyFromFileInfo(</span>
    <span class="s1">fileData,</span>
    <span class="s1">filename,</span>
    <span class="s1">transformOptions,</span>
    <span class="s1">transformerCacheKey</span>
  <span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(transformerCacheKey != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _crypto().createHash)(</span><span class="s0">'sha1'</span><span class="s1">)</span>
        <span class="s1">.update(transformerCacheKey)</span>
        <span class="s1">.update(CACHE_VERSION)</span>
        <span class="s1">.digest(</span><span class="s0">'hex'</span><span class="s1">)</span>
        <span class="s1">.substring(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">32</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _crypto().createHash)(</span><span class="s0">'sha1'</span><span class="s1">)</span>
      <span class="s1">.update(fileData)</span>
      <span class="s1">.update(transformOptions.configString)</span>
      <span class="s1">.update(transformOptions.instrument ? </span><span class="s0">'instrument' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">)</span>
      <span class="s1">.update(filename)</span>
      <span class="s1">.update(CACHE_VERSION)</span>
      <span class="s1">.digest(</span><span class="s0">'hex'</span><span class="s1">)</span>
      <span class="s1">.substring(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">32</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">_buildTransformCacheKey(pattern, filepath) {</span>
    <span class="s2">return </span><span class="s1">pattern + filepath;</span>
  <span class="s1">}</span>
  <span class="s1">_getCacheKey(fileData, filename, options) {</span>
    <span class="s1">const configString = </span><span class="s2">this</span><span class="s1">._cache.configString;</span>
    <span class="s1">const {transformer, transformerConfig = {}} =</span>
      <span class="s2">this</span><span class="s1">._getTransformer(filename) ?? {};</span>
    <span class="s1">let transformerCacheKey = undefined;</span>
    <span class="s1">const transformOptions = {</span>
      <span class="s1">...options,</span>
      <span class="s1">cacheFS: </span><span class="s2">this</span><span class="s1">._cacheFS,</span>
      <span class="s1">config: </span><span class="s2">this</span><span class="s1">._config,</span>
      <span class="s1">configString,</span>
      <span class="s1">transformerConfig</span>
    <span class="s1">};</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">transformer?.getCacheKey === </span><span class="s0">'function'</span><span class="s1">) {</span>
      <span class="s1">transformerCacheKey = transformer.getCacheKey(</span>
        <span class="s1">fileData,</span>
        <span class="s1">filename,</span>
        <span class="s1">transformOptions</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">._buildCacheKeyFromFileInfo(</span>
      <span class="s1">fileData,</span>
      <span class="s1">filename,</span>
      <span class="s1">transformOptions,</span>
      <span class="s1">transformerCacheKey</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">async _getCacheKeyAsync(fileData, filename, options) {</span>
    <span class="s1">const configString = </span><span class="s2">this</span><span class="s1">._cache.configString;</span>
    <span class="s1">const {transformer, transformerConfig = {}} =</span>
      <span class="s2">this</span><span class="s1">._getTransformer(filename) ?? {};</span>
    <span class="s1">let transformerCacheKey = undefined;</span>
    <span class="s1">const transformOptions = {</span>
      <span class="s1">...options,</span>
      <span class="s1">cacheFS: </span><span class="s2">this</span><span class="s1">._cacheFS,</span>
      <span class="s1">config: </span><span class="s2">this</span><span class="s1">._config,</span>
      <span class="s1">configString,</span>
      <span class="s1">transformerConfig</span>
    <span class="s1">};</span>
    <span class="s2">if </span><span class="s1">(transformer) {</span>
      <span class="s1">const getCacheKey =</span>
        <span class="s1">transformer.getCacheKeyAsync ?? transformer.getCacheKey;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">getCacheKey === </span><span class="s0">'function'</span><span class="s1">) {</span>
        <span class="s1">transformerCacheKey = await getCacheKey(</span>
          <span class="s1">fileData,</span>
          <span class="s1">filename,</span>
          <span class="s1">transformOptions</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">._buildCacheKeyFromFileInfo(</span>
      <span class="s1">fileData,</span>
      <span class="s1">filename,</span>
      <span class="s1">transformOptions,</span>
      <span class="s1">transformerCacheKey</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">_createCachedFilename(filename, cacheKey) {</span>
    <span class="s1">const HasteMapClass = _jestHasteMap().</span><span class="s2">default</span><span class="s1">.getStatic(</span><span class="s2">this</span><span class="s1">._config);</span>
    <span class="s1">const baseCacheDir = HasteMapClass.getCacheFilePath(</span>
      <span class="s2">this</span><span class="s1">._config.cacheDirectory,</span>
      <span class="s1">`jest-transform-cache-${</span><span class="s2">this</span><span class="s1">._config.id}`,</span>
      <span class="s1">VERSION</span>
    <span class="s1">);</span>
    <span class="s3">// Create sub folders based on the cacheKey to avoid creating one</span>
    <span class="s3">// directory with many files.</span>
    <span class="s1">const cacheDir = path().join(baseCacheDir, cacheKey[</span><span class="s4">0</span><span class="s1">] + cacheKey[</span><span class="s4">1</span><span class="s1">]);</span>
    <span class="s1">const cacheFilenamePrefix = path()</span>
      <span class="s1">.basename(filename, path().extname(filename))</span>
      <span class="s1">.replace(/\W/g, </span><span class="s0">''</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _slash().</span><span class="s2">default</span><span class="s1">)(</span>
      <span class="s1">path().join(cacheDir, `${cacheFilenamePrefix}_${cacheKey}`)</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">_getFileCachePath(filename, content, options) {</span>
    <span class="s1">const cacheKey = </span><span class="s2">this</span><span class="s1">._getCacheKey(content, filename, options);</span>
    <span class="s2">return this</span><span class="s1">._createCachedFilename(filename, cacheKey);</span>
  <span class="s1">}</span>
  <span class="s1">async _getFileCachePathAsync(filename, content, options) {</span>
    <span class="s1">const cacheKey = await </span><span class="s2">this</span><span class="s1">._getCacheKeyAsync(content, filename, options);</span>
    <span class="s2">return this</span><span class="s1">._createCachedFilename(filename, cacheKey);</span>
  <span class="s1">}</span>
  <span class="s1">_getTransformPatternAndPath(filename) {</span>
    <span class="s1">const transformEntry = </span><span class="s2">this</span><span class="s1">._cache.transformRegExp;</span>
    <span class="s2">if </span><span class="s1">(transformEntry == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; transformEntry.length; i++) {</span>
      <span class="s1">const [transformRegExp, transformPath] = transformEntry[i];</span>
      <span class="s2">if </span><span class="s1">(transformRegExp.test(filename)) {</span>
        <span class="s2">return </span><span class="s1">[transformRegExp.source, transformPath];</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">undefined;</span>
  <span class="s1">}</span>
  <span class="s1">_getTransformPath(filename) {</span>
    <span class="s1">const transformInfo = </span><span class="s2">this</span><span class="s1">._getTransformPatternAndPath(filename);</span>
    <span class="s2">if </span><span class="s1">(!Array.isArray(transformInfo)) {</span>
      <span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">transformInfo[</span><span class="s4">1</span><span class="s1">];</span>
  <span class="s1">}</span>
  <span class="s1">async loadTransformers() {</span>
    <span class="s1">await Promise.all(</span>
      <span class="s2">this</span><span class="s1">._config.transform.map(</span>
        <span class="s1">async ([transformPattern, transformPath, transformerConfig], i) =&gt; {</span>
          <span class="s1">let transformer = await (</span><span class="s4">0</span><span class="s1">, _jestUtil().requireOrImportModule)(</span>
            <span class="s1">transformPath</span>
          <span class="s1">);</span>
          <span class="s2">if </span><span class="s1">(transformer == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span>
              <span class="s1">(</span><span class="s4">0</span><span class="s1">, _runtimeErrorsAndWarnings.makeInvalidTransformerError)(</span>
                <span class="s1">transformPath</span>
              <span class="s1">)</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(isTransformerFactory(transformer)) {</span>
            <span class="s1">transformer = await transformer.createTransformer(</span>
              <span class="s1">transformerConfig</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(</span>
            <span class="s2">typeof </span><span class="s1">transformer.process !== </span><span class="s0">'function' </span><span class="s1">&amp;&amp;</span>
            <span class="s2">typeof </span><span class="s1">transformer.processAsync !== </span><span class="s0">'function'</span>
          <span class="s1">) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span>
              <span class="s1">(</span><span class="s4">0</span><span class="s1">, _runtimeErrorsAndWarnings.makeInvalidTransformerError)(</span>
                <span class="s1">transformPath</span>
              <span class="s1">)</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s1">const res = {</span>
            <span class="s1">transformer,</span>
            <span class="s1">transformerConfig</span>
          <span class="s1">};</span>
          <span class="s1">const transformCacheKey = </span><span class="s2">this</span><span class="s1">._buildTransformCacheKey(</span>
            <span class="s2">this</span><span class="s1">._cache.transformRegExp?.[i]?.[</span><span class="s4">0</span><span class="s1">].source ??</span>
              <span class="s2">new </span><span class="s1">RegExp(transformPattern).source,</span>
            <span class="s1">transformPath</span>
          <span class="s1">);</span>
          <span class="s2">this</span><span class="s1">._transformCache.set(transformCacheKey, res);</span>
        <span class="s1">}</span>
      <span class="s1">)</span>
    <span class="s1">);</span>
    <span class="s2">this</span><span class="s1">._transformsAreLoaded = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">_getTransformer(filename) {</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">._transformsAreLoaded) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span>
        <span class="s0">'Jest: Transformers have not been loaded yet - make sure to run `loadTransformers` and wait for it to complete before starting to transform files'</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._config.transform.length === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const transformPatternAndPath = </span><span class="s2">this</span><span class="s1">._getTransformPatternAndPath(filename);</span>
    <span class="s2">if </span><span class="s1">(!Array.isArray(transformPatternAndPath)) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const [transformPattern, transformPath] = transformPatternAndPath;</span>
    <span class="s1">const transformCacheKey = </span><span class="s2">this</span><span class="s1">._buildTransformCacheKey(</span>
      <span class="s1">transformPattern,</span>
      <span class="s1">transformPath</span>
    <span class="s1">);</span>
    <span class="s1">const transformer = </span><span class="s2">this</span><span class="s1">._transformCache.get(transformCacheKey);</span>
    <span class="s2">if </span><span class="s1">(transformer !== undefined) {</span>
      <span class="s2">return </span><span class="s1">transformer;</span>
    <span class="s1">}</span>
    <span class="s2">throw new </span><span class="s1">Error(</span>
      <span class="s1">`Jest was unable to load the transformer defined </span><span class="s2">for </span><span class="s1">${filename}. This is a bug </span><span class="s2">in </span><span class="s1">Jest, please open up an issue`</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">_instrumentFile(filename, input, canMapToInput, options) {</span>
    <span class="s1">const inputCode = </span><span class="s2">typeof </span><span class="s1">input === </span><span class="s0">'string' </span><span class="s1">? input : input.code;</span>
    <span class="s1">const inputMap = </span><span class="s2">typeof </span><span class="s1">input === </span><span class="s0">'string' </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: input.map;</span>
    <span class="s1">const result = (</span><span class="s4">0</span><span class="s1">, _core().transformSync)(inputCode, {</span>
      <span class="s1">auxiliaryCommentBefore: </span><span class="s0">' istanbul ignore next '</span><span class="s1">,</span>
      <span class="s1">babelrc: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">caller: {</span>
        <span class="s1">name: </span><span class="s0">'@jest/transform'</span><span class="s1">,</span>
        <span class="s1">supportsDynamicImport: options.supportsDynamicImport,</span>
        <span class="s1">supportsExportNamespaceFrom: options.supportsExportNamespaceFrom,</span>
        <span class="s1">supportsStaticESM: options.supportsStaticESM,</span>
        <span class="s1">supportsTopLevelAwait: options.supportsTopLevelAwait</span>
      <span class="s1">},</span>
      <span class="s1">configFile: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">filename,</span>
      <span class="s1">plugins: [</span>
        <span class="s1">[</span>
          <span class="s1">_babelPluginIstanbul().</span><span class="s2">default</span><span class="s1">,</span>
          <span class="s1">{</span>
            <span class="s1">compact: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s3">// files outside `cwd` will not be instrumented</span>
            <span class="s1">cwd: </span><span class="s2">this</span><span class="s1">._config.rootDir,</span>
            <span class="s1">exclude: [],</span>
            <span class="s1">extension: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">inputSourceMap: inputMap,</span>
            <span class="s1">useInlineSourceMaps: </span><span class="s2">false</span>
          <span class="s1">}</span>
        <span class="s1">]</span>
      <span class="s1">],</span>
      <span class="s1">sourceMaps: canMapToInput ? </span><span class="s0">'both' </span><span class="s1">: </span><span class="s2">false</span>
    <span class="s1">});</span>
    <span class="s2">if </span><span class="s1">(result?.code != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">input;</span>
  <span class="s1">}</span>
  <span class="s1">_buildTransformResult(</span>
    <span class="s1">filename,</span>
    <span class="s1">cacheFilePath,</span>
    <span class="s1">content,</span>
    <span class="s1">transformer,</span>
    <span class="s1">shouldCallTransform,</span>
    <span class="s1">options,</span>
    <span class="s1">processed,</span>
    <span class="s1">sourceMapPath</span>
  <span class="s1">) {</span>
    <span class="s1">let transformed = {</span>
      <span class="s1">code: content,</span>
      <span class="s1">map: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">if </span><span class="s1">(transformer &amp;&amp; shouldCallTransform) {</span>
      <span class="s2">if </span><span class="s1">(processed != </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">processed.code === </span><span class="s0">'string'</span><span class="s1">) {</span>
        <span class="s1">transformed = processed;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">const transformPath = </span><span class="s2">this</span><span class="s1">._getTransformPath(filename);</span>
        <span class="s1">invariant(transformPath);</span>
        <span class="s2">throw new </span><span class="s1">Error(</span>
          <span class="s1">(</span><span class="s4">0</span><span class="s1">, _runtimeErrorsAndWarnings.makeInvalidReturnValueError)(</span>
            <span class="s1">transformPath</span>
          <span class="s1">)</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(transformed.map == </span><span class="s2">null </span><span class="s1">|| transformed.map === </span><span class="s0">''</span><span class="s1">) {</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s3">//Could be a potential freeze here.</span>
        <span class="s3">//See: https://github.com/facebook/jest/pull/5177#discussion_r158883570</span>
        <span class="s1">const inlineSourceMap = (</span><span class="s4">0</span><span class="s1">, _convertSourceMap().fromSource)(</span>
          <span class="s1">transformed.code</span>
        <span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(inlineSourceMap) {</span>
          <span class="s1">transformed.map = inlineSourceMap.toObject();</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">{</span>
        <span class="s1">const transformPath = </span><span class="s2">this</span><span class="s1">._getTransformPath(filename);</span>
        <span class="s1">invariant(transformPath);</span>
        <span class="s1">console.warn(</span>
          <span class="s1">(</span><span class="s4">0</span><span class="s1">, _runtimeErrorsAndWarnings.makeInvalidSourceMapWarning)(</span>
            <span class="s1">filename,</span>
            <span class="s1">transformPath</span>
          <span class="s1">)</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">// That means that the transform has a custom instrumentation</span>
    <span class="s3">// logic and will handle it based on `config.collectCoverage` option</span>
    <span class="s1">const transformWillInstrument =</span>
      <span class="s1">shouldCallTransform &amp;&amp; transformer &amp;&amp; transformer.canInstrument;</span>

    <span class="s3">// Apply instrumentation to the code if necessary, keeping the instrumented code and new map</span>
    <span class="s1">let map = transformed.map;</span>
    <span class="s1">let code;</span>
    <span class="s2">if </span><span class="s1">(transformWillInstrument !== </span><span class="s2">true </span><span class="s1">&amp;&amp; options.instrument) {</span>
      <span class="s3">/** 
       * We can map the original source code to the instrumented code ONLY if 
       * - the process of transforming the code produced a source map e.g. ts-jest 
       * - we did not transform the source code 
       * 
       * Otherwise we cannot make any statements about how the instrumented code corresponds to the original code, 
       * and we should NOT emit any source maps 
       * 
       */</span>
      <span class="s1">const shouldEmitSourceMaps =</span>
        <span class="s1">(transformer != </span><span class="s2">null </span><span class="s1">&amp;&amp; map != </span><span class="s2">null</span><span class="s1">) || transformer == </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">const instrumented = </span><span class="s2">this</span><span class="s1">._instrumentFile(</span>
        <span class="s1">filename,</span>
        <span class="s1">transformed,</span>
        <span class="s1">shouldEmitSourceMaps,</span>
        <span class="s1">options</span>
      <span class="s1">);</span>
      <span class="s1">code =</span>
        <span class="s2">typeof </span><span class="s1">instrumented === </span><span class="s0">'string' </span><span class="s1">? instrumented : instrumented.code;</span>
      <span class="s1">map = </span><span class="s2">typeof </span><span class="s1">instrumented === </span><span class="s0">'string' </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: instrumented.map;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">code = transformed.code;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(map != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">const sourceMapContent =</span>
        <span class="s2">typeof </span><span class="s1">map === </span><span class="s0">'string' </span><span class="s1">? map : JSON.stringify(map);</span>
      <span class="s1">invariant(sourceMapPath, </span><span class="s0">'We should always have default sourceMapPath'</span><span class="s1">);</span>
      <span class="s1">writeCacheFile(sourceMapPath, sourceMapContent);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">sourceMapPath = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">writeCodeCacheFile(cacheFilePath, code);</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">code,</span>
      <span class="s1">originalCode: content,</span>
      <span class="s1">sourceMapPath</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s1">transformSource(filepath, content, options) {</span>
    <span class="s1">const filename = (</span><span class="s4">0</span><span class="s1">, _jestUtil().tryRealpath)(filepath);</span>
    <span class="s1">const {transformer, transformerConfig = {}} =</span>
      <span class="s2">this</span><span class="s1">._getTransformer(filename) ?? {};</span>
    <span class="s1">const cacheFilePath = </span><span class="s2">this</span><span class="s1">._getFileCachePath(filename, content, options);</span>
    <span class="s1">const sourceMapPath = `${cacheFilePath}.map`;</span>
    <span class="s3">// Ignore cache if `config.cache` is set (--no-cache)</span>
    <span class="s1">const code = </span><span class="s2">this</span><span class="s1">._config.cache ? readCodeCacheFile(cacheFilePath) : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(code != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s3">// This is broken: we return the code, and a path for the source map</span>
      <span class="s3">// directly from the cache. But, nothing ensures the source map actually</span>
      <span class="s3">// matches that source code. They could have gotten out-of-sync in case</span>
      <span class="s3">// two separate processes write concurrently to the same cache files.</span>
      <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code,</span>
        <span class="s1">originalCode: content,</span>
        <span class="s1">sourceMapPath</span>
      <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">let processed = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">let shouldCallTransform = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(transformer &amp;&amp; </span><span class="s2">this</span><span class="s1">.shouldTransform(filename)) {</span>
      <span class="s1">shouldCallTransform = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">assertSyncTransformer(transformer, </span><span class="s2">this</span><span class="s1">._getTransformPath(filename));</span>
      <span class="s1">processed = transformer.process(content, filename, {</span>
        <span class="s1">...options,</span>
        <span class="s1">cacheFS: </span><span class="s2">this</span><span class="s1">._cacheFS,</span>
        <span class="s1">config: </span><span class="s2">this</span><span class="s1">._config,</span>
        <span class="s1">configString: </span><span class="s2">this</span><span class="s1">._cache.configString,</span>
        <span class="s1">transformerConfig</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _jestUtil().createDirectory)(path().dirname(cacheFilePath));</span>
    <span class="s2">return this</span><span class="s1">._buildTransformResult(</span>
      <span class="s1">filename,</span>
      <span class="s1">cacheFilePath,</span>
      <span class="s1">content,</span>
      <span class="s1">transformer,</span>
      <span class="s1">shouldCallTransform,</span>
      <span class="s1">options,</span>
      <span class="s1">processed,</span>
      <span class="s1">sourceMapPath</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">async transformSourceAsync(filepath, content, options) {</span>
    <span class="s1">const filename = (</span><span class="s4">0</span><span class="s1">, _jestUtil().tryRealpath)(filepath);</span>
    <span class="s1">const {transformer, transformerConfig = {}} =</span>
      <span class="s2">this</span><span class="s1">._getTransformer(filename) ?? {};</span>
    <span class="s1">const cacheFilePath = await </span><span class="s2">this</span><span class="s1">._getFileCachePathAsync(</span>
      <span class="s1">filename,</span>
      <span class="s1">content,</span>
      <span class="s1">options</span>
    <span class="s1">);</span>
    <span class="s1">const sourceMapPath = `${cacheFilePath}.map`;</span>
    <span class="s3">// Ignore cache if `config.cache` is set (--no-cache)</span>
    <span class="s1">const code = </span><span class="s2">this</span><span class="s1">._config.cache ? readCodeCacheFile(cacheFilePath) : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(code != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s3">// This is broken: we return the code, and a path for the source map</span>
      <span class="s3">// directly from the cache. But, nothing ensures the source map actually</span>
      <span class="s3">// matches that source code. They could have gotten out-of-sync in case</span>
      <span class="s3">// two separate processes write concurrently to the same cache files.</span>
      <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code,</span>
        <span class="s1">originalCode: content,</span>
        <span class="s1">sourceMapPath</span>
      <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">let processed = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">let shouldCallTransform = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(transformer &amp;&amp; </span><span class="s2">this</span><span class="s1">.shouldTransform(filename)) {</span>
      <span class="s1">shouldCallTransform = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">const process = transformer.processAsync ?? transformer.process;</span>

      <span class="s3">// This is probably dead code since `_getTransformerAsync` already asserts this</span>
      <span class="s1">invariant(</span>
        <span class="s2">typeof </span><span class="s1">process === </span><span class="s0">'function'</span><span class="s1">,</span>
        <span class="s0">'A transformer must always export either a `process` or `processAsync`'</span>
      <span class="s1">);</span>
      <span class="s1">processed = await process(content, filename, {</span>
        <span class="s1">...options,</span>
        <span class="s1">cacheFS: </span><span class="s2">this</span><span class="s1">._cacheFS,</span>
        <span class="s1">config: </span><span class="s2">this</span><span class="s1">._config,</span>
        <span class="s1">configString: </span><span class="s2">this</span><span class="s1">._cache.configString,</span>
        <span class="s1">transformerConfig</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _jestUtil().createDirectory)(path().dirname(cacheFilePath));</span>
    <span class="s2">return this</span><span class="s1">._buildTransformResult(</span>
      <span class="s1">filename,</span>
      <span class="s1">cacheFilePath,</span>
      <span class="s1">content,</span>
      <span class="s1">transformer,</span>
      <span class="s1">shouldCallTransform,</span>
      <span class="s1">options,</span>
      <span class="s1">processed,</span>
      <span class="s1">sourceMapPath</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">async _transformAndBuildScriptAsync(</span>
    <span class="s1">filename,</span>
    <span class="s1">options,</span>
    <span class="s1">transformOptions,</span>
    <span class="s1">fileSource</span>
  <span class="s1">) {</span>
    <span class="s1">const {isInternalModule} = options;</span>
    <span class="s1">let fileContent = fileSource ?? </span><span class="s2">this</span><span class="s1">._cacheFS.get(filename);</span>
    <span class="s2">if </span><span class="s1">(fileContent == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">fileContent = fs().readFileSync(filename, </span><span class="s0">'utf8'</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">._cacheFS.set(filename, fileContent);</span>
    <span class="s1">}</span>
    <span class="s1">const content = stripShebang(fileContent);</span>
    <span class="s1">let code = content;</span>
    <span class="s1">let sourceMapPath = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">const willTransform =</span>
      <span class="s1">isInternalModule !== </span><span class="s2">true </span><span class="s1">&amp;&amp;</span>
      <span class="s1">(transformOptions.instrument || </span><span class="s2">this</span><span class="s1">.shouldTransform(filename));</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(willTransform) {</span>
        <span class="s1">const transformedSource = await </span><span class="s2">this</span><span class="s1">.transformSourceAsync(</span>
          <span class="s1">filename,</span>
          <span class="s1">content,</span>
          <span class="s1">transformOptions</span>
        <span class="s1">);</span>
        <span class="s1">code = transformedSource.code;</span>
        <span class="s1">sourceMapPath = transformedSource.sourceMapPath;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code,</span>
        <span class="s1">originalCode: content,</span>
        <span class="s1">sourceMapPath</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
      <span class="s2">if </span><span class="s1">(!(e </span><span class="s2">instanceof </span><span class="s1">Error)) {</span>
        <span class="s2">throw </span><span class="s1">e;</span>
      <span class="s1">}</span>
      <span class="s2">throw </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _enhanceUnexpectedTokenMessage.</span><span class="s2">default</span><span class="s1">)(e);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_transformAndBuildScript(filename, options, transformOptions, fileSource) {</span>
    <span class="s1">const {isInternalModule} = options;</span>
    <span class="s1">let fileContent = fileSource ?? </span><span class="s2">this</span><span class="s1">._cacheFS.get(filename);</span>
    <span class="s2">if </span><span class="s1">(fileContent == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">fileContent = fs().readFileSync(filename, </span><span class="s0">'utf8'</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">._cacheFS.set(filename, fileContent);</span>
    <span class="s1">}</span>
    <span class="s1">const content = stripShebang(fileContent);</span>
    <span class="s1">let code = content;</span>
    <span class="s1">let sourceMapPath = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">const willTransform =</span>
      <span class="s1">isInternalModule !== </span><span class="s2">true </span><span class="s1">&amp;&amp;</span>
      <span class="s1">(transformOptions.instrument || </span><span class="s2">this</span><span class="s1">.shouldTransform(filename));</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(willTransform) {</span>
        <span class="s1">const transformedSource = </span><span class="s2">this</span><span class="s1">.transformSource(</span>
          <span class="s1">filename,</span>
          <span class="s1">content,</span>
          <span class="s1">transformOptions</span>
        <span class="s1">);</span>
        <span class="s1">code = transformedSource.code;</span>
        <span class="s1">sourceMapPath = transformedSource.sourceMapPath;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code,</span>
        <span class="s1">originalCode: content,</span>
        <span class="s1">sourceMapPath</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
      <span class="s2">if </span><span class="s1">(!(e </span><span class="s2">instanceof </span><span class="s1">Error)) {</span>
        <span class="s2">throw </span><span class="s1">e;</span>
      <span class="s1">}</span>
      <span class="s2">throw </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _enhanceUnexpectedTokenMessage.</span><span class="s2">default</span><span class="s1">)(e);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">async transformAsync(filename, options, fileSource) {</span>
    <span class="s1">const instrument =</span>
      <span class="s1">options.coverageProvider === </span><span class="s0">'babel' </span><span class="s1">&amp;&amp;</span>
      <span class="s1">(</span><span class="s4">0</span><span class="s1">, _shouldInstrument.</span><span class="s2">default</span><span class="s1">)(filename, options, </span><span class="s2">this</span><span class="s1">._config);</span>
    <span class="s1">const scriptCacheKey = getScriptCacheKey(filename, instrument);</span>
    <span class="s1">let result = </span><span class="s2">this</span><span class="s1">._cache.transformedFiles.get(scriptCacheKey);</span>
    <span class="s2">if </span><span class="s1">(result) {</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s1">result = await </span><span class="s2">this</span><span class="s1">._transformAndBuildScriptAsync(</span>
      <span class="s1">filename,</span>
      <span class="s1">options,</span>
      <span class="s1">{</span>
        <span class="s1">...options,</span>
        <span class="s1">instrument</span>
      <span class="s1">},</span>
      <span class="s1">fileSource</span>
    <span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(scriptCacheKey) {</span>
      <span class="s2">this</span><span class="s1">._cache.transformedFiles.set(scriptCacheKey, result);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>
  <span class="s1">transform(filename, options, fileSource) {</span>
    <span class="s1">const instrument =</span>
      <span class="s1">options.coverageProvider === </span><span class="s0">'babel' </span><span class="s1">&amp;&amp;</span>
      <span class="s1">(</span><span class="s4">0</span><span class="s1">, _shouldInstrument.</span><span class="s2">default</span><span class="s1">)(filename, options, </span><span class="s2">this</span><span class="s1">._config);</span>
    <span class="s1">const scriptCacheKey = getScriptCacheKey(filename, instrument);</span>
    <span class="s1">let result = </span><span class="s2">this</span><span class="s1">._cache.transformedFiles.get(scriptCacheKey);</span>
    <span class="s2">if </span><span class="s1">(result) {</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s1">result = </span><span class="s2">this</span><span class="s1">._transformAndBuildScript(</span>
      <span class="s1">filename,</span>
      <span class="s1">options,</span>
      <span class="s1">{</span>
        <span class="s1">...options,</span>
        <span class="s1">instrument</span>
      <span class="s1">},</span>
      <span class="s1">fileSource</span>
    <span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(scriptCacheKey) {</span>
      <span class="s2">this</span><span class="s1">._cache.transformedFiles.set(scriptCacheKey, result);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>
  <span class="s1">transformJson(filename, options, fileSource) {</span>
    <span class="s1">const {isInternalModule} = options;</span>
    <span class="s1">const willTransform =</span>
      <span class="s1">isInternalModule !== </span><span class="s2">true </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.shouldTransform(filename);</span>
    <span class="s2">if </span><span class="s1">(willTransform) {</span>
      <span class="s1">const {code: transformedJsonSource} = </span><span class="s2">this</span><span class="s1">.transformSource(</span>
        <span class="s1">filename,</span>
        <span class="s1">fileSource,</span>
        <span class="s1">{</span>
          <span class="s1">...options,</span>
          <span class="s1">instrument: </span><span class="s2">false</span>
        <span class="s1">}</span>
      <span class="s1">);</span>
      <span class="s2">return </span><span class="s1">transformedJsonSource;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">fileSource;</span>
  <span class="s1">}</span>
  <span class="s1">async requireAndTranspileModule(</span>
    <span class="s1">moduleName,</span>
    <span class="s1">callback,</span>
    <span class="s1">options = {</span>
      <span class="s1">applyInteropRequireDefault: </span><span class="s2">true</span><span class="s1">,</span>
      <span class="s1">instrument: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">supportsDynamicImport: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">supportsExportNamespaceFrom: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">supportsStaticESM: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">supportsTopLevelAwait: </span><span class="s2">false</span>
    <span class="s1">}</span>
  <span class="s1">) {</span>
    <span class="s1">let transforming = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">const {applyInteropRequireDefault, ...transformOptions} = options;</span>
    <span class="s1">const revertHook = (</span><span class="s4">0</span><span class="s1">, _pirates().addHook)(</span>
      <span class="s1">(code, filename) =&gt; {</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s1">transforming = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s2">return </span><span class="s1">(</span>
            <span class="s2">this</span><span class="s1">.transformSource(filename, code, transformOptions).code || code</span>
          <span class="s1">);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">transforming = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">{</span>
        <span class="s3">// Exclude `mjs` extension when addHook because pirates don't support hijack es module</span>
        <span class="s1">exts: </span><span class="s2">this</span><span class="s1">._config.moduleFileExtensions</span>
          <span class="s1">.filter(ext =&gt; ext !== </span><span class="s0">'mjs'</span><span class="s1">)</span>
          <span class="s1">.map(ext =&gt; `.${ext}`),</span>
        <span class="s1">ignoreNodeModules: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">matcher: filename =&gt; {</span>
          <span class="s2">if </span><span class="s1">(transforming) {</span>
            <span class="s3">// Don't transform any dependency required by the transformer itself</span>
            <span class="s2">return false</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s2">return this</span><span class="s1">.shouldTransform(filename);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">);</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">const module = await (</span><span class="s4">0</span><span class="s1">, _jestUtil().requireOrImportModule)(</span>
        <span class="s1">moduleName,</span>
        <span class="s1">applyInteropRequireDefault</span>
      <span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(!callback) {</span>
        <span class="s1">revertHook();</span>
        <span class="s2">return </span><span class="s1">module;</span>
      <span class="s1">}</span>
      <span class="s1">const cbResult = callback(module);</span>
      <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _jestUtil().isPromise)(cbResult)) {</span>
        <span class="s2">return </span><span class="s1">await waitForPromiseWithCleanup(cbResult, revertHook).then(</span>
          <span class="s1">() =&gt; module</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">module;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">revertHook();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">shouldTransform(filename) {</span>
    <span class="s1">const ignoreRegexp = </span><span class="s2">this</span><span class="s1">._cache.ignorePatternsRegExp;</span>
    <span class="s1">const isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">return this</span><span class="s1">._config.transform.length !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; !isIgnored;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">// TODO: do we need to define the generics twice?</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">createTranspilingRequire(config) {</span>
  <span class="s1">const transformer = await createScriptTransformer(config);</span>
  <span class="s2">return </span><span class="s1">async </span><span class="s2">function </span><span class="s1">requireAndTranspileModule(</span>
    <span class="s1">resolverPath,</span>
    <span class="s1">applyInteropRequireDefault = </span><span class="s2">false</span>
  <span class="s1">) {</span>
    <span class="s1">const transpiledModule = await transformer.requireAndTranspileModule(</span>
      <span class="s1">resolverPath,</span>
      <span class="s3">// eslint-disable-next-line @typescript-eslint/no-empty-function</span>
      <span class="s1">() =&gt; {},</span>
      <span class="s1">{</span>
        <span class="s1">applyInteropRequireDefault,</span>
        <span class="s1">instrument: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">supportsDynamicImport: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s3">// this might be true, depending on node version.</span>
        <span class="s1">supportsExportNamespaceFrom: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">supportsStaticESM: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">supportsTopLevelAwait: </span><span class="s2">false</span>
      <span class="s1">}</span>
    <span class="s1">);</span>
    <span class="s2">return </span><span class="s1">transpiledModule;</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">const removeFile = path =&gt; {</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s1">fs().unlinkSync(path);</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">{}</span>
<span class="s1">};</span>
<span class="s1">const stripShebang = content =&gt; {</span>
  <span class="s3">// If the file data starts with a shebang remove it. Leaves the empty line</span>
  <span class="s3">// to keep stack trace line numbers correct.</span>
  <span class="s2">if </span><span class="s1">(content.startsWith(</span><span class="s0">'#!'</span><span class="s1">)) {</span>
    <span class="s2">return </span><span class="s1">content.replace(/^#!.*/, </span><span class="s0">''</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">return </span><span class="s1">content;</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s3">/** 
 * This is like `writeCacheFile` but with an additional sanity checksum. We 
 * cannot use the same technique for source maps because we expose source map 
 * cache file paths directly to callsites, with the expectation they can read 
 * it right away. This is not a great system, because source map cache file 
 * could get corrupted, out-of-sync, etc. 
 */</span>
<span class="s2">function </span><span class="s1">writeCodeCacheFile(cachePath, code) {</span>
  <span class="s1">const checksum = (</span><span class="s4">0</span><span class="s1">, _crypto().createHash)(</span><span class="s0">'sha1'</span><span class="s1">)</span>
    <span class="s1">.update(code)</span>
    <span class="s1">.digest(</span><span class="s0">'hex'</span><span class="s1">)</span>
    <span class="s1">.substring(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">32</span><span class="s1">);</span>
  <span class="s1">writeCacheFile(cachePath, `${checksum}\n${code}`);</span>
<span class="s1">}</span>

<span class="s3">/** 
 * Read counterpart of `writeCodeCacheFile`. We verify that the content of the 
 * file matches the checksum, in case some kind of corruption happened. This 
 * could happen if an older version of `jest-runtime` writes non-atomically to 
 * the same cache, for example. 
 */</span>
<span class="s2">function </span><span class="s1">readCodeCacheFile(cachePath) {</span>
  <span class="s1">const content = readCacheFile(cachePath);</span>
  <span class="s2">if </span><span class="s1">(content == </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">const code = content.substring(</span><span class="s4">33</span><span class="s1">);</span>
  <span class="s1">const checksum = (</span><span class="s4">0</span><span class="s1">, _crypto().createHash)(</span><span class="s0">'sha1'</span><span class="s1">)</span>
    <span class="s1">.update(code)</span>
    <span class="s1">.digest(</span><span class="s0">'hex'</span><span class="s1">)</span>
    <span class="s1">.substring(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">32</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(checksum === content.substring(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">32</span><span class="s1">)) {</span>
    <span class="s2">return </span><span class="s1">code;</span>
  <span class="s1">}</span>
  <span class="s2">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">/** 
 * Writing to the cache atomically relies on 'rename' being atomic on most 
 * file systems. Doing atomic write reduces the risk of corruption by avoiding 
 * two processes to write to the same file at the same time. It also reduces 
 * the risk of reading a file that's being overwritten at the same time. 
 */</span>
<span class="s1">const writeCacheFile = (cachePath, fileData) =&gt; {</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _writeFileAtomic().sync)(cachePath, fileData, {</span>
      <span class="s1">encoding: </span><span class="s0">'utf8'</span><span class="s1">,</span>
      <span class="s1">fsync: </span><span class="s2">false</span>
    <span class="s1">});</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
    <span class="s2">if </span><span class="s1">(!(e </span><span class="s2">instanceof </span><span class="s1">Error)) {</span>
      <span class="s2">throw </span><span class="s1">e;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(cacheWriteErrorSafeToIgnore(e, cachePath)) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">e.message = `jest: failed to cache transform results </span><span class="s2">in</span><span class="s1">: ${cachePath}\nFailure message: ${e.message}`;</span>
    <span class="s1">removeFile(cachePath);</span>
    <span class="s2">throw </span><span class="s1">e;</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s3">/** 
 * On Windows, renames are not atomic, leading to EPERM exceptions when two 
 * processes attempt to rename to the same target file at the same time. 
 * If the target file exists we can be reasonably sure another process has 
 * legitimately won a cache write race and ignore the error. 
 */</span>
<span class="s1">const cacheWriteErrorSafeToIgnore = (e, cachePath) =&gt;</span>
  <span class="s1">process.platform === </span><span class="s0">'win32' </span><span class="s1">&amp;&amp;</span>
  <span class="s1">e.code === </span><span class="s0">'EPERM' </span><span class="s1">&amp;&amp;</span>
  <span class="s1">fs().existsSync(cachePath);</span>
<span class="s1">const readCacheFile = cachePath =&gt; {</span>
  <span class="s2">if </span><span class="s1">(!fs().existsSync(cachePath)) {</span>
    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">let fileData;</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s1">fileData = fs().readFileSync(cachePath, </span><span class="s0">'utf8'</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
    <span class="s2">if </span><span class="s1">(!(e </span><span class="s2">instanceof </span><span class="s1">Error)) {</span>
      <span class="s2">throw </span><span class="s1">e;</span>
    <span class="s1">}</span>
    <span class="s3">// on windows write-file-atomic is not atomic which can</span>
    <span class="s3">// result in this error</span>
    <span class="s2">if </span><span class="s1">(e.code === </span><span class="s0">'ENOENT' </span><span class="s1">&amp;&amp; process.platform === </span><span class="s0">'win32'</span><span class="s1">) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">e.message = `jest: failed to read cache file: ${cachePath}\nFailure message: ${e.message}`;</span>
    <span class="s1">removeFile(cachePath);</span>
    <span class="s2">throw </span><span class="s1">e;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(fileData == </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s3">// We must have somehow created the file but failed to write to it,</span>
    <span class="s3">// let's delete it and retry.</span>
    <span class="s1">removeFile(cachePath);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">fileData;</span>
<span class="s1">};</span>
<span class="s1">const getScriptCacheKey = (filename, instrument) =&gt; {</span>
  <span class="s1">const mtime = fs().statSync(filename).mtime;</span>
  <span class="s2">return </span><span class="s1">`${filename}_${mtime.getTime()}${instrument ? </span><span class="s0">'_instrumented' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}`;</span>
<span class="s1">};</span>
<span class="s1">const calcIgnorePatternRegExp = config =&gt; {</span>
  <span class="s2">if </span><span class="s1">(</span>
    <span class="s1">config.transformIgnorePatterns == </span><span class="s2">null </span><span class="s1">||</span>
    <span class="s1">config.transformIgnorePatterns.length === </span><span class="s4">0</span>
  <span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">undefined;</span>
  <span class="s1">}</span>
  <span class="s2">return new </span><span class="s1">RegExp(config.transformIgnorePatterns.join(</span><span class="s0">'|'</span><span class="s1">));</span>
<span class="s1">};</span>
<span class="s1">const calcTransformRegExp = config =&gt; {</span>
  <span class="s2">if </span><span class="s1">(!config.transform.length) {</span>
    <span class="s2">return </span><span class="s1">undefined;</span>
  <span class="s1">}</span>
  <span class="s1">const transformRegexp = [];</span>
  <span class="s2">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; config.transform.length; i++) {</span>
    <span class="s1">transformRegexp.push([</span>
      <span class="s2">new </span><span class="s1">RegExp(config.transform[i][</span><span class="s4">0</span><span class="s1">]),</span>
      <span class="s1">config.transform[i][</span><span class="s4">1</span><span class="s1">],</span>
      <span class="s1">config.transform[i][</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">]);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">transformRegexp;</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">invariant(condition, message) {</span>
  <span class="s2">if </span><span class="s1">(condition == </span><span class="s2">null </span><span class="s1">|| condition === </span><span class="s2">false </span><span class="s1">|| condition === </span><span class="s0">''</span><span class="s1">) {</span>
    <span class="s2">throw new </span><span class="s1">Error(message);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">assertSyncTransformer(transformer, name) {</span>
  <span class="s1">invariant(name);</span>
  <span class="s1">invariant(</span>
    <span class="s2">typeof </span><span class="s1">transformer.process === </span><span class="s0">'function'</span><span class="s1">,</span>
    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _runtimeErrorsAndWarnings.makeInvalidSyncTransformerError)(name)</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">createScriptTransformer(config, cacheFS = </span><span class="s2">new </span><span class="s1">Map()) {</span>
  <span class="s1">const transformer = </span><span class="s2">new </span><span class="s1">ScriptTransformer(config, cacheFS);</span>
  <span class="s1">await transformer.loadTransformers();</span>
  <span class="s2">return </span><span class="s1">transformer;</span>
<span class="s1">}</span>
</pre>
</body>
</html>
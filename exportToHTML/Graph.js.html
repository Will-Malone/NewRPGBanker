<html>
<head>
<title>Graph.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Graph.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span><span class="s1">,</span>
<span class="s1">});</span>
<span class="s1">exports.Graph = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">_CountingSet = _interopRequireDefault(require(</span><span class="s0">&quot;../lib/CountingSet&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_contextModule = require(</span><span class="s0">&quot;../lib/contextModule&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">path = _interopRequireWildcard(require(</span><span class="s0">&quot;path&quot;</span><span class="s1">));</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
  <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
  <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function </span><span class="s1">(nodeInterop) {</span>
    <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
  <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interopRequireWildcard(obj, nodeInterop) {</span>
  <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
    <span class="s2">return </span><span class="s1">obj;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">)) {</span>
    <span class="s2">return </span><span class="s1">{ </span><span class="s2">default</span><span class="s1">: obj };</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
  <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
    <span class="s2">return </span><span class="s1">cache.get(obj);</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">newObj = {};</span>
  <span class="s2">var </span><span class="s1">hasPropertyDescriptor =</span>
    <span class="s1">Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj) {</span>
    <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
      <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor</span>
        <span class="s1">? Object.getOwnPropertyDescriptor(obj, key)</span>
        <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
        <span class="s1">Object.defineProperty(newObj, key, desc);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">newObj[key] = obj[key];</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">newObj.</span><span class="s2">default </span><span class="s1">= obj;</span>
  <span class="s2">if </span><span class="s1">(cache) {</span>
    <span class="s1">cache.set(obj, newObj);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interopRequireDefault(obj) {</span>
  <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">default</span><span class="s1">: obj };</span>
<span class="s1">}</span>
<span class="s4">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 * 
 * @format 
 * @oncall react_native 
 */</span>

<span class="s4">/** 
 * Portions of this code are based on the Synchronous Cycle Collection 
 * algorithm described in: 
 * 
 * David F. Bacon and V. T. Rajan. 2001. Concurrent Cycle Collection in 
 * Reference Counted Systems. In Proceedings of the 15th European Conference on 
 * Object-Oriented Programming (ECOOP '01). Springer-Verlag, Berlin, 
 * Heidelberg, 207â€“235. 
 * 
 * Notable differences from the algorithm in the paper: 
 * 1. Our implementation uses the inverseDependencies set (which we already 
 *    have to maintain) instead of a separate refcount variable. A module's 
 *    reference count is equal to the size of its inverseDependencies set, plus 
 *    1 if it's an entry point of the graph. 
 * 2. We keep the &quot;root buffer&quot; (possibleCycleRoots) free of duplicates by 
 *    making it a Set, instead of storing a &quot;buffered&quot; flag on each node. 
 * 3. On top of tracking edges between nodes, we also count references between 
 *    nodes and entries in the importBundleNodes set. 
 */</span>

<span class="s1">const invariant = require(</span><span class="s0">&quot;invariant&quot;</span><span class="s1">);</span>
<span class="s1">const nullthrows = require(</span><span class="s0">&quot;nullthrows&quot;</span><span class="s1">);</span>

<span class="s4">// TODO: Convert to a Flow enum</span>

<span class="s2">function </span><span class="s1">getInternalOptions({ transform, resolve, onProgress, lazy, shallow }) {</span>
  <span class="s1">let numProcessed = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s1">let total = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">lazy,</span>
    <span class="s1">transform,</span>
    <span class="s1">resolve,</span>
    <span class="s1">onDependencyAdd: () =&gt; onProgress &amp;&amp; onProgress(numProcessed, ++total),</span>
    <span class="s1">onDependencyAdded: () =&gt; onProgress &amp;&amp; onProgress(++numProcessed, total),</span>
    <span class="s1">shallow,</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">class Graph {</span>
  <span class="s1">dependencies = </span><span class="s2">new </span><span class="s1">Map();</span>
  <span class="s1">#importBundleNodes = </span><span class="s2">new </span><span class="s1">Map();</span>

  <span class="s4">/// GC state for nodes in the graph (this.dependencies)</span>
  <span class="s1">#gc = {</span>
    <span class="s1">color: </span><span class="s2">new </span><span class="s1">Map(),</span>
    <span class="s1">possibleCycleRoots: </span><span class="s2">new </span><span class="s1">Set(),</span>
  <span class="s1">};</span>

  <span class="s4">/** Resolved context parameters from `require.context`. */</span>
  <span class="s1">#resolvedContexts = </span><span class="s2">new </span><span class="s1">Map();</span>
  <span class="s1">constructor(options) {</span>
    <span class="s2">this</span><span class="s1">.entryPoints = options.entryPoints;</span>
    <span class="s2">this</span><span class="s1">.transformOptions = options.transformOptions;</span>
  <span class="s1">}</span>

  <span class="s4">/** 
   * Dependency Traversal logic for the Delta Bundler. This method calculates 
   * the modules that should be included in the bundle by traversing the 
   * dependency graph. 
   * Instead of traversing the whole graph each time, it just calculates the 
   * difference between runs by only traversing the added/removed dependencies. 
   * To do so, it uses the passed graph dependencies and it mutates it. 
   * The paths parameter contains the absolute paths of the root files that the 
   * method should traverse. Normally, these paths should be the modified files 
   * since the last traversal. 
   */</span>
  <span class="s1">async traverseDependencies(paths, options) {</span>
    <span class="s1">const delta = {</span>
      <span class="s1">added: </span><span class="s2">new </span><span class="s1">Set(),</span>
      <span class="s1">modified: </span><span class="s2">new </span><span class="s1">Set(),</span>
      <span class="s1">deleted: </span><span class="s2">new </span><span class="s1">Set(),</span>
      <span class="s1">earlyInverseDependencies: </span><span class="s2">new </span><span class="s1">Map(),</span>
    <span class="s1">};</span>
    <span class="s1">const internalOptions = getInternalOptions(options);</span>

    <span class="s4">// Record the paths that are part of the dependency graph before we start</span>
    <span class="s4">// traversing - we'll use this to ensure we don't report modules modified</span>
    <span class="s4">// that only exist as part of the graph mid-traversal, and to eliminate</span>
    <span class="s4">// modules that end up in the same state that they started from the delta.</span>
    <span class="s1">const originalModules = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s2">for </span><span class="s1">(const path of paths) {</span>
      <span class="s1">const originalModule = </span><span class="s2">this</span><span class="s1">.dependencies.get(path);</span>
      <span class="s2">if </span><span class="s1">(originalModule) {</span>
        <span class="s1">originalModules.set(path, originalModule);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(const [path] of originalModules) {</span>
      <span class="s4">// Traverse over modules that are part of the dependency graph.</span>
      <span class="s4">//</span>
      <span class="s4">// Note: A given path may not be part of the graph *at this time*, in</span>
      <span class="s4">// particular it may have been removed since we started traversing, but</span>
      <span class="s4">// in that case the path will be visited if and when we add it back to</span>
      <span class="s4">// the graph in a subsequent iteration.</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.dependencies.has(path)) {</span>
        <span class="s1">await </span><span class="s2">this</span><span class="s1">._traverseDependenciesForSingleFile(</span>
          <span class="s1">path,</span>
          <span class="s1">delta,</span>
          <span class="s1">internalOptions</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">._collectCycles(delta);</span>
    <span class="s1">const added = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s2">for </span><span class="s1">(const path of delta.added) {</span>
      <span class="s1">added.set(path, nullthrows(</span><span class="s2">this</span><span class="s1">.dependencies.get(path)));</span>
    <span class="s1">}</span>
    <span class="s1">const modified = </span><span class="s2">new </span><span class="s1">Map();</span>

    <span class="s4">// A path in delta.modified has been processed during this traversal,</span>
    <span class="s4">// but may not actually differ, may be new, or may have been deleted after</span>
    <span class="s4">// processing. The actually-modified modules are the intersection of</span>
    <span class="s4">// delta.modified with the pre-existing paths, minus modules deleted.</span>
    <span class="s2">for </span><span class="s1">(const [path, originalModule] of originalModules) {</span>
      <span class="s1">invariant(</span>
        <span class="s1">!delta.added.has(path),</span>
        <span class="s0">&quot;delta.added has %s, but this path was already in the graph.&quot;</span><span class="s1">,</span>
        <span class="s1">path</span>
      <span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(delta.modified.has(path)) {</span>
        <span class="s4">// It's expected that a module may be both modified and subsequently</span>
        <span class="s4">// deleted - we'll only return it as deleted.</span>
        <span class="s2">if </span><span class="s1">(!delta.deleted.has(path)) {</span>
          <span class="s4">// If a module existed before and has not been deleted, it must be</span>
          <span class="s4">// in the dependencies map.</span>
          <span class="s1">const newModule = nullthrows(</span><span class="s2">this</span><span class="s1">.dependencies.get(path));</span>
          <span class="s2">if </span><span class="s1">(</span>
            <span class="s4">// Module.dependencies is mutable, so it's not obviously the case</span>
            <span class="s4">// that referential equality implies no modification. However, we</span>
            <span class="s4">// only mutate dependencies in two cases:</span>
            <span class="s4">// 1. Within _processModule. In that case, we always mutate a new</span>
            <span class="s4">//    module and set a new reference in this.dependencies.</span>
            <span class="s4">// 2. During _releaseModule, when recursively removing</span>
            <span class="s4">//    dependencies. In that case, we immediately discard the module</span>
            <span class="s4">//    object.</span>
            <span class="s4">// TODO: Refactor for more explicit immutability</span>
            <span class="s1">newModule !== originalModule ||</span>
            <span class="s1">transfromOutputMayDiffer(newModule, originalModule) ||</span>
            <span class="s4">// $FlowFixMe[incompatible-call]</span>
            <span class="s1">!allDependenciesEqual(newModule, originalModule)</span>
          <span class="s1">) {</span>
            <span class="s1">modified.set(path, newModule);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">added,</span>
      <span class="s1">modified,</span>
      <span class="s1">deleted: delta.deleted,</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s1">async initialTraverseDependencies(options) {</span>
    <span class="s1">const delta = {</span>
      <span class="s1">added: </span><span class="s2">new </span><span class="s1">Set(),</span>
      <span class="s1">modified: </span><span class="s2">new </span><span class="s1">Set(),</span>
      <span class="s1">deleted: </span><span class="s2">new </span><span class="s1">Set(),</span>
      <span class="s1">earlyInverseDependencies: </span><span class="s2">new </span><span class="s1">Map(),</span>
    <span class="s1">};</span>
    <span class="s1">const internalOptions = getInternalOptions(options);</span>
    <span class="s1">invariant(</span>
      <span class="s2">this</span><span class="s1">.dependencies.size === </span><span class="s3">0</span><span class="s1">,</span>
      <span class="s0">&quot;initialTraverseDependencies called on nonempty graph&quot;</span>
    <span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.#gc.color.clear();</span>
    <span class="s2">this</span><span class="s1">.#gc.possibleCycleRoots.clear();</span>
    <span class="s2">this</span><span class="s1">.#importBundleNodes.clear();</span>
    <span class="s2">for </span><span class="s1">(const path of </span><span class="s2">this</span><span class="s1">.entryPoints) {</span>
      <span class="s4">// Each entry point implicitly has a refcount of 1, so mark them all black.</span>
      <span class="s2">this</span><span class="s1">.#gc.color.set(path, </span><span class="s0">&quot;black&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">await Promise.all(</span>
      <span class="s1">[...</span><span class="s2">this</span><span class="s1">.entryPoints].map((path) =&gt;</span>
        <span class="s2">this</span><span class="s1">._traverseDependenciesForSingleFile(path, delta, internalOptions)</span>
      <span class="s1">)</span>
    <span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.reorderGraph({</span>
      <span class="s1">shallow: options.shallow,</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">added: </span><span class="s2">this</span><span class="s1">.dependencies,</span>
      <span class="s1">modified: </span><span class="s2">new </span><span class="s1">Map(),</span>
      <span class="s1">deleted: </span><span class="s2">new </span><span class="s1">Set(),</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s1">async _traverseDependenciesForSingleFile(path, delta, options) {</span>
    <span class="s1">options.onDependencyAdd();</span>
    <span class="s1">await </span><span class="s2">this</span><span class="s1">._processModule(path, delta, options);</span>
    <span class="s1">options.onDependencyAdded();</span>
  <span class="s1">}</span>
  <span class="s1">async _processModule(path, delta, options) {</span>
    <span class="s1">const resolvedContext = </span><span class="s2">this</span><span class="s1">.#resolvedContexts.get(path);</span>

    <span class="s4">// Transform the file via the given option.</span>
    <span class="s4">// TODO: Unbind the transform method from options</span>
    <span class="s1">const result = await options.transform(path, resolvedContext);</span>

    <span class="s4">// Get the absolute path of all sub-dependencies (some of them could have been</span>
    <span class="s4">// moved but maintain the same relative path).</span>
    <span class="s1">const currentDependencies = </span><span class="s2">this</span><span class="s1">._resolveDependencies(</span>
      <span class="s1">path,</span>
      <span class="s1">result.dependencies,</span>
      <span class="s1">options</span>
    <span class="s1">);</span>
    <span class="s1">const previousModule = </span><span class="s2">this</span><span class="s1">.dependencies.get(path);</span>
    <span class="s1">const previousDependencies = previousModule?.dependencies ?? </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s1">const nextModule = {</span>
      <span class="s1">...(previousModule ?? {</span>
        <span class="s1">inverseDependencies:</span>
          <span class="s1">delta.earlyInverseDependencies.get(path) ??</span>
          <span class="s2">new </span><span class="s1">_CountingSet.</span><span class="s2">default</span><span class="s1">(),</span>
        <span class="s1">path,</span>
      <span class="s1">}),</span>
      <span class="s1">dependencies: </span><span class="s2">new </span><span class="s1">Map(previousDependencies),</span>
      <span class="s1">getSource: result.getSource,</span>
      <span class="s1">output: result.output,</span>
      <span class="s1">unstable_transformResultKey: result.unstable_transformResultKey,</span>
    <span class="s1">};</span>

    <span class="s4">// Update the module information.</span>
    <span class="s2">this</span><span class="s1">.dependencies.set(nextModule.path, nextModule);</span>

    <span class="s4">// Diff dependencies (1/2): remove dependencies that have changed or been removed.</span>
    <span class="s1">let dependenciesRemoved = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">for </span><span class="s1">(const [key, prevDependency] of previousDependencies) {</span>
      <span class="s1">const curDependency = currentDependencies.get(key);</span>
      <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">!curDependency ||</span>
        <span class="s1">!dependenciesEqual(prevDependency, curDependency, options)</span>
      <span class="s1">) {</span>
        <span class="s1">dependenciesRemoved = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">._removeDependency(nextModule, key, prevDependency, delta, options);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">// Diff dependencies (2/2): add dependencies that have changed or been added.</span>
    <span class="s1">const addDependencyPromises = [];</span>
    <span class="s2">for </span><span class="s1">(const [key, curDependency] of currentDependencies) {</span>
      <span class="s1">const prevDependency = previousDependencies.get(key);</span>
      <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">!prevDependency ||</span>
        <span class="s1">!dependenciesEqual(prevDependency, curDependency, options)</span>
      <span class="s1">) {</span>
        <span class="s1">addDependencyPromises.push(</span>
          <span class="s2">this</span><span class="s1">._addDependency(nextModule, key, curDependency, delta, options)</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s1">previousModule &amp;&amp;</span>
      <span class="s1">!transfromOutputMayDiffer(previousModule, nextModule) &amp;&amp;</span>
      <span class="s1">!dependenciesRemoved &amp;&amp;</span>
      <span class="s1">addDependencyPromises.length === </span><span class="s3">0</span>
    <span class="s1">) {</span>
      <span class="s4">// We have not operated on nextModule, so restore previousModule</span>
      <span class="s4">// to aid diffing.</span>
      <span class="s2">this</span><span class="s1">.dependencies.set(previousModule.path, previousModule);</span>
      <span class="s2">return </span><span class="s1">previousModule;</span>
    <span class="s1">}</span>
    <span class="s1">delta.modified.add(path);</span>
    <span class="s1">await Promise.all(addDependencyPromises);</span>

    <span class="s4">// Replace dependencies with the correctly-ordered version. As long as all</span>
    <span class="s4">// the above promises have resolved, this will be the same map but without</span>
    <span class="s4">// the added nondeterminism of promise resolution order. Because this</span>
    <span class="s4">// assignment does not add or remove edges, it does NOT invalidate any of the</span>
    <span class="s4">// garbage collection state.</span>

    <span class="s4">// Catch obvious errors with a cheap assertion.</span>
    <span class="s1">invariant(</span>
      <span class="s1">nextModule.dependencies.size === currentDependencies.size,</span>
      <span class="s0">&quot;Failed to add the correct dependencies&quot;</span>
    <span class="s1">);</span>
    <span class="s1">nextModule.dependencies = currentDependencies;</span>
    <span class="s2">return </span><span class="s1">nextModule;</span>
  <span class="s1">}</span>
  <span class="s1">async _addDependency(parentModule, key, dependency, delta, options) {</span>
    <span class="s1">const path = dependency.absolutePath;</span>

    <span class="s4">// The module may already exist, in which case we just need to update some</span>
    <span class="s4">// bookkeeping instead of adding a new node to the graph.</span>
    <span class="s1">let module = </span><span class="s2">this</span><span class="s1">.dependencies.get(path);</span>
    <span class="s2">if </span><span class="s1">(options.shallow) {</span>
      <span class="s4">// Don't add a node for the module if the graph is shallow (single-module).</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(dependency.data.data.asyncType === </span><span class="s0">&quot;weak&quot;</span><span class="s1">) {</span>
      <span class="s4">// Exclude weak dependencies from the bundle.</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(options.lazy &amp;&amp; dependency.data.data.asyncType != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s4">// Don't add a node for the module if we are traversing async dependencies</span>
      <span class="s4">// lazily (and this is an async dependency). Instead, record it in</span>
      <span class="s4">// importBundleNodes.</span>
      <span class="s2">this</span><span class="s1">._incrementImportBundleReference(dependency, parentModule);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(!module) {</span>
        <span class="s4">// Add a new node to the graph.</span>
        <span class="s1">const earlyInverseDependencies =</span>
          <span class="s1">delta.earlyInverseDependencies.get(path);</span>
        <span class="s2">if </span><span class="s1">(earlyInverseDependencies) {</span>
          <span class="s4">// This module is being transformed at the moment in parallel, so we</span>
          <span class="s4">// should only mark its parent as an inverse dependency.</span>
          <span class="s1">earlyInverseDependencies.add(parentModule.path);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(delta.deleted.has(path)) {</span>
            <span class="s4">// Mark the addition by clearing a prior deletion.</span>
            <span class="s1">delta.deleted.</span><span class="s2">delete</span><span class="s1">(path);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s4">// Mark the addition in the added set.</span>
            <span class="s1">delta.added.add(path);</span>
          <span class="s1">}</span>
          <span class="s1">delta.earlyInverseDependencies.set(path, </span><span class="s2">new </span><span class="s1">_CountingSet.</span><span class="s2">default</span><span class="s1">());</span>
          <span class="s1">options.onDependencyAdd();</span>
          <span class="s1">module = await </span><span class="s2">this</span><span class="s1">._processModule(path, delta, options);</span>
          <span class="s1">options.onDependencyAdded();</span>
          <span class="s2">this</span><span class="s1">.dependencies.set(module.path, module);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(module) {</span>
        <span class="s4">// We either added a new node to the graph, or we're updating an existing one.</span>
        <span class="s1">module.inverseDependencies.add(parentModule.path);</span>
        <span class="s2">this</span><span class="s1">._markModuleInUse(module);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">// Always update the parent's dependency map.</span>
    <span class="s4">// This means the parent's dependencies can get desynced from</span>
    <span class="s4">// inverseDependencies and the other fields in the case of lazy edges.</span>
    <span class="s4">// Not an optimal representation :(</span>
    <span class="s1">parentModule.dependencies.set(key, dependency);</span>
  <span class="s1">}</span>
  <span class="s1">_removeDependency(parentModule, key, dependency, delta, options) {</span>
    <span class="s1">parentModule.dependencies.</span><span class="s2">delete</span><span class="s1">(key);</span>
    <span class="s1">const { absolutePath } = dependency;</span>
    <span class="s2">if </span><span class="s1">(dependency.data.data.asyncType === </span><span class="s0">&quot;weak&quot;</span><span class="s1">) {</span>
      <span class="s4">// Weak dependencies are excluded from the bundle.</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(options.lazy &amp;&amp; dependency.data.data.asyncType != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">._decrementImportBundleReference(dependency, parentModule);</span>
    <span class="s1">}</span>
    <span class="s1">const module = </span><span class="s2">this</span><span class="s1">.dependencies.get(absolutePath);</span>
    <span class="s2">if </span><span class="s1">(!module) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">module.inverseDependencies.</span><span class="s2">delete</span><span class="s1">(parentModule.path);</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s1">module.inverseDependencies.size &gt; </span><span class="s3">0 </span><span class="s1">||</span>
      <span class="s2">this</span><span class="s1">.entryPoints.has(absolutePath)</span>
    <span class="s1">) {</span>
      <span class="s4">// The reference count has decreased, but not to zero.</span>
      <span class="s4">// NOTE: Each entry point implicitly has a refcount of 1.</span>
      <span class="s2">this</span><span class="s1">._markAsPossibleCycleRoot(module);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s4">// The reference count has decreased to zero.</span>
      <span class="s2">this</span><span class="s1">._releaseModule(module, delta, options);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">/** 
   * Collect a list of context modules which include a given file. 
   */</span>
  <span class="s1">markModifiedContextModules(filePath, modifiedPaths) {</span>
    <span class="s2">for </span><span class="s1">(const [absolutePath, context] of </span><span class="s2">this</span><span class="s1">.#resolvedContexts) {</span>
      <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">!modifiedPaths.has(absolutePath) &amp;&amp;</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _contextModule.fileMatchesContext)(filePath, context)</span>
      <span class="s1">) {</span>
        <span class="s1">modifiedPaths.add(absolutePath);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">/** 
   * Gets the list of modules affected by the deletion of a given file. The 
   * caller is expected to mark these modules as modified in the next call to 
   * traverseDependencies. Note that the list may contain duplicates. 
   */</span>
  <span class="s1">*getModifiedModulesForDeletedPath(filePath) {</span>
    <span class="s1">yield* </span><span class="s2">this</span><span class="s1">.dependencies.get(filePath)?.inverseDependencies ?? [];</span>
    <span class="s1">yield* </span><span class="s2">this</span><span class="s1">.#importBundleNodes.get(filePath)?.inverseDependencies ?? [];</span>
  <span class="s1">}</span>
  <span class="s1">_resolveDependencies(parentPath, dependencies, options) {</span>
    <span class="s1">const maybeResolvedDeps = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s2">for </span><span class="s1">(const dep of dependencies) {</span>
      <span class="s1">let resolvedDep;</span>

      <span class="s4">// `require.context`</span>
      <span class="s1">const { contextParams } = dep.data;</span>
      <span class="s2">if </span><span class="s1">(contextParams) {</span>
        <span class="s4">// Ensure the filepath has uniqueness applied to ensure multiple `require.context`</span>
        <span class="s4">// statements can be used to target the same file with different properties.</span>
        <span class="s1">const from = path.join(parentPath, </span><span class="s0">&quot;..&quot;</span><span class="s1">, dep.name);</span>
        <span class="s1">const absolutePath = (</span><span class="s3">0</span><span class="s1">, _contextModule.deriveAbsolutePathFromContext)(</span>
          <span class="s1">from,</span>
          <span class="s1">contextParams</span>
        <span class="s1">);</span>
        <span class="s1">const resolvedContext = {</span>
          <span class="s1">from,</span>
          <span class="s1">mode: contextParams.mode,</span>
          <span class="s1">recursive: contextParams.recursive,</span>
          <span class="s1">filter: </span><span class="s2">new </span><span class="s1">RegExp(</span>
            <span class="s1">contextParams.filter.pattern,</span>
            <span class="s1">contextParams.filter.flags</span>
          <span class="s1">),</span>
        <span class="s1">};</span>
        <span class="s2">this</span><span class="s1">.#resolvedContexts.set(absolutePath, resolvedContext);</span>
        <span class="s1">resolvedDep = {</span>
          <span class="s1">absolutePath,</span>
          <span class="s1">data: dep,</span>
        <span class="s1">};</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s1">resolvedDep = {</span>
            <span class="s1">absolutePath: options.resolve(parentPath, dep.name).filePath,</span>
            <span class="s1">data: dep,</span>
          <span class="s1">};</span>

          <span class="s4">// This dependency may have existed previously as a require.context -</span>
          <span class="s4">// clean it up.</span>
          <span class="s2">this</span><span class="s1">.#resolvedContexts.</span><span class="s2">delete</span><span class="s1">(resolvedDep.absolutePath);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
          <span class="s4">// Ignore unavailable optional dependencies. They are guarded</span>
          <span class="s4">// with a try-catch block and will be handled during runtime.</span>
          <span class="s2">if </span><span class="s1">(dep.data.isOptional !== </span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s2">throw </span><span class="s1">error;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">const key = dep.data.key;</span>
      <span class="s2">if </span><span class="s1">(maybeResolvedDeps.has(key)) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span>
          <span class="s1">`resolveDependencies: Found duplicate dependency key </span><span class="s0">'${key}' </span><span class="s2">in </span><span class="s1">${parentPath}`</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s1">maybeResolvedDeps.set(key, resolvedDep);</span>
    <span class="s1">}</span>
    <span class="s1">const resolvedDeps = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s4">// Return just the dependencies we successfully resolved.</span>
    <span class="s4">// FIXME: This has a bad bug affecting all dependencies *after* an unresolved</span>
    <span class="s4">// optional dependency. We'll need to propagate the nulls all the way to the</span>
    <span class="s4">// serializer and the require() runtime to keep the dependency map from being</span>
    <span class="s4">// desynced from the contents of the module.</span>
    <span class="s2">for </span><span class="s1">(const [key, resolvedDep] of maybeResolvedDeps) {</span>
      <span class="s2">if </span><span class="s1">(resolvedDep) {</span>
        <span class="s1">resolvedDeps.set(key, resolvedDep);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">resolvedDeps;</span>
  <span class="s1">}</span>

  <span class="s4">/** 
   * Re-traverse the dependency graph in DFS order to reorder the modules and 
   * guarantee the same order between runs. This method mutates the passed graph. 
   */</span>
  <span class="s1">reorderGraph(options) {</span>
    <span class="s1">const orderedDependencies = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s2">this</span><span class="s1">.entryPoints.forEach((entryPoint) =&gt; {</span>
      <span class="s1">const mainModule = </span><span class="s2">this</span><span class="s1">.dependencies.get(entryPoint);</span>
      <span class="s2">if </span><span class="s1">(!mainModule) {</span>
        <span class="s2">throw new </span><span class="s1">ReferenceError(</span>
          <span class="s0">&quot;Module not registered in graph: &quot; </span><span class="s1">+ entryPoint</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">._reorderDependencies(mainModule, orderedDependencies, options);</span>
    <span class="s1">});</span>
    <span class="s2">this</span><span class="s1">.dependencies.clear();</span>
    <span class="s2">for </span><span class="s1">(const [key, dep] of orderedDependencies) {</span>
      <span class="s2">this</span><span class="s1">.dependencies.set(key, dep);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_reorderDependencies(module, orderedDependencies, options) {</span>
    <span class="s2">if </span><span class="s1">(module.path) {</span>
      <span class="s2">if </span><span class="s1">(orderedDependencies.has(module.path)) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">orderedDependencies.set(module.path, module);</span>
    <span class="s1">}</span>
    <span class="s1">module.dependencies.forEach((dependency) =&gt; {</span>
      <span class="s1">const path = dependency.absolutePath;</span>
      <span class="s1">const childModule = </span><span class="s2">this</span><span class="s1">.dependencies.get(path);</span>
      <span class="s2">if </span><span class="s1">(!childModule) {</span>
        <span class="s2">if </span><span class="s1">(dependency.data.data.asyncType != </span><span class="s2">null </span><span class="s1">|| options.shallow) {</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">throw new </span><span class="s1">ReferenceError(</span><span class="s0">&quot;Module not registered in graph: &quot; </span><span class="s1">+ path);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">._reorderDependencies(childModule, orderedDependencies, options);</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s4">/** Garbage collection functions */</span>

  <span class="s4">// Add an entry to importBundleNodes (or record an inverse dependency of an existing one)</span>
  <span class="s1">_incrementImportBundleReference(dependency, parentModule) {</span>
    <span class="s1">const { absolutePath } = dependency;</span>
    <span class="s1">const importBundleNode = </span><span class="s2">this</span><span class="s1">.#importBundleNodes.get(absolutePath) ?? {</span>
      <span class="s1">inverseDependencies: </span><span class="s2">new </span><span class="s1">_CountingSet.</span><span class="s2">default</span><span class="s1">(),</span>
    <span class="s1">};</span>
    <span class="s1">importBundleNode.inverseDependencies.add(parentModule.path);</span>
    <span class="s2">this</span><span class="s1">.#importBundleNodes.set(absolutePath, importBundleNode);</span>
  <span class="s1">}</span>

  <span class="s4">// Decrease the reference count of an entry in importBundleNodes (and delete it if necessary)</span>
  <span class="s1">_decrementImportBundleReference(dependency, parentModule) {</span>
    <span class="s1">const { absolutePath } = dependency;</span>
    <span class="s1">const importBundleNode = nullthrows(</span>
      <span class="s2">this</span><span class="s1">.#importBundleNodes.get(absolutePath)</span>
    <span class="s1">);</span>
    <span class="s1">invariant(</span>
      <span class="s1">importBundleNode.inverseDependencies.has(parentModule.path),</span>
      <span class="s0">&quot;lazy: import bundle inverse references&quot;</span>
    <span class="s1">);</span>
    <span class="s1">importBundleNode.inverseDependencies.</span><span class="s2">delete</span><span class="s1">(parentModule.path);</span>
    <span class="s2">if </span><span class="s1">(importBundleNode.inverseDependencies.size === </span><span class="s3">0</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.#importBundleNodes.</span><span class="s2">delete</span><span class="s1">(absolutePath);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">// Mark a module as in use (ref count &gt;= 1)</span>
  <span class="s1">_markModuleInUse(module) {</span>
    <span class="s2">this</span><span class="s1">.#gc.color.set(module.path, </span><span class="s0">&quot;black&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s4">// Delete an unreachable module (and its outbound edges) from the graph</span>
  <span class="s4">// immediately.</span>
  <span class="s4">// Called when the reference count of a module has reached 0.</span>
  <span class="s1">_releaseModule(module, delta, options) {</span>
    <span class="s2">for </span><span class="s1">(const [key, dependency] of module.dependencies) {</span>
      <span class="s2">this</span><span class="s1">._removeDependency(module, key, dependency, delta, options);</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.#gc.color.set(module.path, </span><span class="s0">&quot;black&quot;</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">._freeModule(module, delta);</span>
  <span class="s1">}</span>

  <span class="s4">// Delete an unreachable module from the graph.</span>
  <span class="s1">_freeModule(module, delta) {</span>
    <span class="s2">if </span><span class="s1">(delta.added.has(module.path)) {</span>
      <span class="s4">// Mark the deletion by clearing a prior addition.</span>
      <span class="s1">delta.added.</span><span class="s2">delete</span><span class="s1">(module.path);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s4">// Mark the deletion in the deleted set.</span>
      <span class="s1">delta.deleted.add(module.path);</span>
    <span class="s1">}</span>

    <span class="s4">// This module is not used anywhere else! We can clear it from the bundle.</span>
    <span class="s4">// Clean up all the state associated with this module in order to correctly</span>
    <span class="s4">// re-add it if we encounter it again.</span>
    <span class="s2">this</span><span class="s1">.dependencies.</span><span class="s2">delete</span><span class="s1">(module.path);</span>
    <span class="s1">delta.earlyInverseDependencies.</span><span class="s2">delete</span><span class="s1">(module.path);</span>
    <span class="s2">this</span><span class="s1">.#gc.possibleCycleRoots.</span><span class="s2">delete</span><span class="s1">(module.path);</span>
    <span class="s2">this</span><span class="s1">.#gc.color.</span><span class="s2">delete</span><span class="s1">(module.path);</span>
    <span class="s2">this</span><span class="s1">.#resolvedContexts.</span><span class="s2">delete</span><span class="s1">(module.path);</span>
  <span class="s1">}</span>

  <span class="s4">// Mark a module as a possible cycle root</span>
  <span class="s1">_markAsPossibleCycleRoot(module) {</span>
    <span class="s2">if </span><span class="s1">(nullthrows(</span><span class="s2">this</span><span class="s1">.#gc.color.get(module.path)) !== </span><span class="s0">&quot;purple&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.#gc.color.set(module.path, </span><span class="s0">&quot;purple&quot;</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.#gc.possibleCycleRoots.add(module.path);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">// Collect any unreachable cycles in the graph.</span>
  <span class="s1">_collectCycles(delta) {</span>
    <span class="s4">// Mark recursively from roots (trial deletion)</span>
    <span class="s2">for </span><span class="s1">(const path of </span><span class="s2">this</span><span class="s1">.#gc.possibleCycleRoots) {</span>
      <span class="s1">const module = nullthrows(</span><span class="s2">this</span><span class="s1">.dependencies.get(path));</span>
      <span class="s1">const color = nullthrows(</span><span class="s2">this</span><span class="s1">.#gc.color.get(path));</span>
      <span class="s2">if </span><span class="s1">(color === </span><span class="s0">&quot;purple&quot;</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">._markGray(module);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.#gc.possibleCycleRoots.</span><span class="s2">delete</span><span class="s1">(path);</span>
        <span class="s2">if </span><span class="s1">(</span>
          <span class="s1">color === </span><span class="s0">&quot;black&quot; </span><span class="s1">&amp;&amp;</span>
          <span class="s1">module.inverseDependencies.size === </span><span class="s3">0 </span><span class="s1">&amp;&amp;</span>
          <span class="s1">!</span><span class="s2">this</span><span class="s1">.entryPoints.has(path)</span>
        <span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">._freeModule(module, delta);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// Scan recursively from roots (undo unsuccessful trial deletions)</span>
    <span class="s2">for </span><span class="s1">(const path of </span><span class="s2">this</span><span class="s1">.#gc.possibleCycleRoots) {</span>
      <span class="s1">const module = nullthrows(</span><span class="s2">this</span><span class="s1">.dependencies.get(path));</span>
      <span class="s2">this</span><span class="s1">._scan(module);</span>
    <span class="s1">}</span>
    <span class="s4">// Collect recursively from roots (free unreachable cycles)</span>
    <span class="s2">for </span><span class="s1">(const path of </span><span class="s2">this</span><span class="s1">.#gc.possibleCycleRoots) {</span>
      <span class="s2">this</span><span class="s1">.#gc.possibleCycleRoots.</span><span class="s2">delete</span><span class="s1">(path);</span>
      <span class="s1">const module = nullthrows(</span><span class="s2">this</span><span class="s1">.dependencies.get(path));</span>
      <span class="s2">this</span><span class="s1">._collectWhite(module, delta);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_markGray(module) {</span>
    <span class="s1">const color = nullthrows(</span><span class="s2">this</span><span class="s1">.#gc.color.get(module.path));</span>
    <span class="s2">if </span><span class="s1">(color !== </span><span class="s0">&quot;gray&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.#gc.color.set(module.path, </span><span class="s0">&quot;gray&quot;</span><span class="s1">);</span>
      <span class="s2">for </span><span class="s1">(const dependency of module.dependencies.values()) {</span>
        <span class="s1">const childModule = nullthrows(</span>
          <span class="s2">this</span><span class="s1">.dependencies.get(dependency.absolutePath)</span>
        <span class="s1">);</span>
        <span class="s4">// The inverse dependency will be restored during the scan phase if this module remains live.</span>
        <span class="s1">childModule.inverseDependencies.</span><span class="s2">delete</span><span class="s1">(module.path);</span>
        <span class="s2">this</span><span class="s1">._markGray(childModule);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_scan(module) {</span>
    <span class="s1">const color = nullthrows(</span><span class="s2">this</span><span class="s1">.#gc.color.get(module.path));</span>
    <span class="s2">if </span><span class="s1">(color === </span><span class="s0">&quot;gray&quot;</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">module.inverseDependencies.size &gt; </span><span class="s3">0 </span><span class="s1">||</span>
        <span class="s2">this</span><span class="s1">.entryPoints.has(module.path)</span>
      <span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">._scanBlack(module);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.#gc.color.set(module.path, </span><span class="s0">&quot;white&quot;</span><span class="s1">);</span>
        <span class="s2">for </span><span class="s1">(const dependency of module.dependencies.values()) {</span>
          <span class="s1">const childModule = nullthrows(</span>
            <span class="s2">this</span><span class="s1">.dependencies.get(dependency.absolutePath)</span>
          <span class="s1">);</span>
          <span class="s2">this</span><span class="s1">._scan(childModule);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_scanBlack(module) {</span>
    <span class="s2">this</span><span class="s1">.#gc.color.set(module.path, </span><span class="s0">&quot;black&quot;</span><span class="s1">);</span>
    <span class="s2">for </span><span class="s1">(const dependency of module.dependencies.values()) {</span>
      <span class="s1">const childModule = nullthrows(</span>
        <span class="s2">this</span><span class="s1">.dependencies.get(dependency.absolutePath)</span>
      <span class="s1">);</span>
      <span class="s4">// The inverse dependency must have been deleted during the mark phase.</span>
      <span class="s1">childModule.inverseDependencies.add(module.path);</span>
      <span class="s1">const childColor = nullthrows(</span><span class="s2">this</span><span class="s1">.#gc.color.get(childModule.path));</span>
      <span class="s2">if </span><span class="s1">(childColor !== </span><span class="s0">&quot;black&quot;</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">._scanBlack(childModule);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_collectWhite(module, delta) {</span>
    <span class="s1">const color = nullthrows(</span><span class="s2">this</span><span class="s1">.#gc.color.get(module.path));</span>
    <span class="s2">if </span><span class="s1">(color === </span><span class="s0">&quot;white&quot; </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.#gc.possibleCycleRoots.has(module.path)) {</span>
      <span class="s2">this</span><span class="s1">.#gc.color.set(module.path, </span><span class="s0">&quot;black&quot;</span><span class="s1">);</span>
      <span class="s2">for </span><span class="s1">(const dependency of module.dependencies.values()) {</span>
        <span class="s1">const childModule = </span><span class="s2">this</span><span class="s1">.dependencies.get(dependency.absolutePath);</span>
        <span class="s4">// The child may already have been collected.</span>
        <span class="s2">if </span><span class="s1">(childModule) {</span>
          <span class="s2">this</span><span class="s1">._collectWhite(childModule, delta);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">._freeModule(module, delta);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">/** End of garbage collection functions */</span>
<span class="s1">}</span>
<span class="s1">exports.Graph = Graph;</span>
<span class="s2">function </span><span class="s1">dependenciesEqual(a, b, options) {</span>
  <span class="s2">return </span><span class="s1">(</span>
    <span class="s1">a === b ||</span>
    <span class="s1">(a.absolutePath === b.absolutePath &amp;&amp;</span>
      <span class="s1">(!options.lazy || a.data.data.asyncType === b.data.data.asyncType) &amp;&amp;</span>
      <span class="s1">contextParamsEqual(a.data.data.contextParams, b.data.data.contextParams))</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">allDependenciesEqual(a, b, options) {</span>
  <span class="s2">if </span><span class="s1">(a.dependencies.size !== b.dependencies.size) {</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">for </span><span class="s1">(const [key, depA] of a.dependencies) {</span>
    <span class="s1">const depB = b.dependencies.get(key);</span>
    <span class="s2">if </span><span class="s1">(!depB || !dependenciesEqual(depA, depB, options)) {</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">contextParamsEqual(a, b) {</span>
  <span class="s2">return </span><span class="s1">(</span>
    <span class="s1">a === b ||</span>
    <span class="s1">(a == </span><span class="s2">null </span><span class="s1">&amp;&amp; b == </span><span class="s2">null</span><span class="s1">) ||</span>
    <span class="s1">(a != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
      <span class="s1">b != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
      <span class="s1">a.recursive === b.recursive &amp;&amp;</span>
      <span class="s1">a.filter.pattern === b.filter.pattern &amp;&amp;</span>
      <span class="s1">a.filter.flags === b.filter.flags &amp;&amp;</span>
      <span class="s1">a.mode === b.mode)</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">transfromOutputMayDiffer(a, b) {</span>
  <span class="s2">return </span><span class="s1">(</span>
    <span class="s1">a.unstable_transformResultKey == </span><span class="s2">null </span><span class="s1">||</span>
    <span class="s1">a.unstable_transformResultKey !== b.unstable_transformResultKey</span>
  <span class="s1">);</span>
<span class="s1">}</span>
</pre>
</body>
</html>
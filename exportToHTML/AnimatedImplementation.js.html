<html>
<head>
<title>AnimatedImplementation.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
AnimatedImplementation.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 * @flow 
 * @format 
 */</span>

<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s1">import type {EventConfig, Mapping} from </span><span class="s2">'./AnimatedEvent'</span><span class="s1">;</span>
<span class="s1">import type {</span>
  <span class="s1">AnimationConfig,</span>
  <span class="s1">EndCallback,</span>
  <span class="s1">EndResult,</span>
<span class="s1">} from </span><span class="s2">'./animations/Animation'</span><span class="s1">;</span>
<span class="s1">import type {DecayAnimationConfig} from </span><span class="s2">'./animations/DecayAnimation'</span><span class="s1">;</span>
<span class="s1">import type {SpringAnimationConfig} from </span><span class="s2">'./animations/SpringAnimation'</span><span class="s1">;</span>
<span class="s1">import type {TimingAnimationConfig} from </span><span class="s2">'./animations/TimingAnimation'</span><span class="s1">;</span>

<span class="s1">import {AnimatedEvent, attachNativeEvent} from </span><span class="s2">'./AnimatedEvent'</span><span class="s1">;</span>
<span class="s1">import DecayAnimation from </span><span class="s2">'./animations/DecayAnimation'</span><span class="s1">;</span>
<span class="s1">import SpringAnimation from </span><span class="s2">'./animations/SpringAnimation'</span><span class="s1">;</span>
<span class="s1">import TimingAnimation from </span><span class="s2">'./animations/TimingAnimation'</span><span class="s1">;</span>
<span class="s1">import createAnimatedComponent from </span><span class="s2">'./createAnimatedComponent'</span><span class="s1">;</span>
<span class="s1">import AnimatedAddition from </span><span class="s2">'./nodes/AnimatedAddition'</span><span class="s1">;</span>
<span class="s1">import AnimatedColor from </span><span class="s2">'./nodes/AnimatedColor'</span><span class="s1">;</span>
<span class="s1">import AnimatedDiffClamp from </span><span class="s2">'./nodes/AnimatedDiffClamp'</span><span class="s1">;</span>
<span class="s1">import AnimatedDivision from </span><span class="s2">'./nodes/AnimatedDivision'</span><span class="s1">;</span>
<span class="s1">import AnimatedInterpolation from </span><span class="s2">'./nodes/AnimatedInterpolation'</span><span class="s1">;</span>
<span class="s1">import AnimatedModulo from </span><span class="s2">'./nodes/AnimatedModulo'</span><span class="s1">;</span>
<span class="s1">import AnimatedMultiplication from </span><span class="s2">'./nodes/AnimatedMultiplication'</span><span class="s1">;</span>
<span class="s1">import AnimatedNode from </span><span class="s2">'./nodes/AnimatedNode'</span><span class="s1">;</span>
<span class="s1">import AnimatedSubtraction from </span><span class="s2">'./nodes/AnimatedSubtraction'</span><span class="s1">;</span>
<span class="s1">import AnimatedTracking from </span><span class="s2">'./nodes/AnimatedTracking'</span><span class="s1">;</span>
<span class="s1">import AnimatedValue from </span><span class="s2">'./nodes/AnimatedValue'</span><span class="s1">;</span>
<span class="s1">import AnimatedValueXY from </span><span class="s2">'./nodes/AnimatedValueXY'</span><span class="s1">;</span>

<span class="s1">export type CompositeAnimation = {</span>
  <span class="s1">start: (callback?: ?EndCallback) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">stop: () =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">reset: () =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">_startNativeLoop: (iterations?: number) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">_isUsingNativeDriver: () =&gt; boolean,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s1">const add = </span><span class="s3">function </span><span class="s1">(</span>
  <span class="s1">a: AnimatedNode | number,</span>
  <span class="s1">b: AnimatedNode | number,</span>
<span class="s1">): AnimatedAddition {</span>
  <span class="s3">return new </span><span class="s1">AnimatedAddition(a, b);</span>
<span class="s1">};</span>

<span class="s1">const subtract = </span><span class="s3">function </span><span class="s1">(</span>
  <span class="s1">a: AnimatedNode | number,</span>
  <span class="s1">b: AnimatedNode | number,</span>
<span class="s1">): AnimatedSubtraction {</span>
  <span class="s3">return new </span><span class="s1">AnimatedSubtraction(a, b);</span>
<span class="s1">};</span>

<span class="s1">const divide = </span><span class="s3">function </span><span class="s1">(</span>
  <span class="s1">a: AnimatedNode | number,</span>
  <span class="s1">b: AnimatedNode | number,</span>
<span class="s1">): AnimatedDivision {</span>
  <span class="s3">return new </span><span class="s1">AnimatedDivision(a, b);</span>
<span class="s1">};</span>

<span class="s1">const multiply = </span><span class="s3">function </span><span class="s1">(</span>
  <span class="s1">a: AnimatedNode | number,</span>
  <span class="s1">b: AnimatedNode | number,</span>
<span class="s1">): AnimatedMultiplication {</span>
  <span class="s3">return new </span><span class="s1">AnimatedMultiplication(a, b);</span>
<span class="s1">};</span>

<span class="s1">const modulo = </span><span class="s3">function </span><span class="s1">(a: AnimatedNode, modulus: number): AnimatedModulo {</span>
  <span class="s3">return new </span><span class="s1">AnimatedModulo(a, modulus);</span>
<span class="s1">};</span>

<span class="s1">const diffClamp = </span><span class="s3">function </span><span class="s1">(</span>
  <span class="s1">a: AnimatedNode,</span>
  <span class="s1">min: number,</span>
  <span class="s1">max: number,</span>
<span class="s1">): AnimatedDiffClamp {</span>
  <span class="s3">return new </span><span class="s1">AnimatedDiffClamp(a, min, max);</span>
<span class="s1">};</span>

<span class="s1">const _combineCallbacks = </span><span class="s3">function </span><span class="s1">(</span>
  <span class="s1">callback: ?EndCallback,</span>
  <span class="s1">config: $ReadOnly&lt;{...AnimationConfig, ...}&gt;,</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(callback &amp;&amp; config.onComplete) {</span>
    <span class="s3">return </span><span class="s1">(...args: Array&lt;EndResult&gt;) =&gt; {</span>
      <span class="s1">config.onComplete &amp;&amp; config.onComplete(...args);</span>
      <span class="s1">callback &amp;&amp; callback(...args);</span>
    <span class="s1">};</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">return </span><span class="s1">callback || config.onComplete;</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">const maybeVectorAnim = </span><span class="s3">function </span><span class="s1">(</span>
  <span class="s1">value: AnimatedValue | AnimatedValueXY | AnimatedColor,</span>
  <span class="s1">config: Object,</span>
  <span class="s1">anim: (value: AnimatedValue, config: Object) =&gt; CompositeAnimation,</span>
<span class="s1">): ?CompositeAnimation {</span>
  <span class="s3">if </span><span class="s1">(value </span><span class="s3">instanceof </span><span class="s1">AnimatedValueXY) {</span>
    <span class="s1">const configX = {...config};</span>
    <span class="s1">const configY = {...config};</span>
    <span class="s3">for </span><span class="s1">(const key </span><span class="s3">in </span><span class="s1">config) {</span>
      <span class="s1">const {x, y} = config[key];</span>
      <span class="s3">if </span><span class="s1">(x !== undefined &amp;&amp; y !== undefined) {</span>
        <span class="s1">configX[key] = x;</span>
        <span class="s1">configY[key] = y;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">const aX = anim((value: AnimatedValueXY).x, configX);</span>
    <span class="s1">const aY = anim((value: AnimatedValueXY).y, configY);</span>
    <span class="s0">// We use `stopTogether: false` here because otherwise tracking will break</span>
    <span class="s0">// because the second animation will get stopped before it can update.</span>
    <span class="s3">return </span><span class="s1">parallel([aX, aY], {stopTogether: </span><span class="s3">false</span><span class="s1">});</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(value </span><span class="s3">instanceof </span><span class="s1">AnimatedColor) {</span>
    <span class="s1">const configR = {...config};</span>
    <span class="s1">const configG = {...config};</span>
    <span class="s1">const configB = {...config};</span>
    <span class="s1">const configA = {...config};</span>
    <span class="s3">for </span><span class="s1">(const key </span><span class="s3">in </span><span class="s1">config) {</span>
      <span class="s1">const {r, g, b, a} = config[key];</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">r !== undefined &amp;&amp;</span>
        <span class="s1">g !== undefined &amp;&amp;</span>
        <span class="s1">b !== undefined &amp;&amp;</span>
        <span class="s1">a !== undefined</span>
      <span class="s1">) {</span>
        <span class="s1">configR[key] = r;</span>
        <span class="s1">configG[key] = g;</span>
        <span class="s1">configB[key] = b;</span>
        <span class="s1">configA[key] = a;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">const aR = anim((value: AnimatedColor).r, configR);</span>
    <span class="s1">const aG = anim((value: AnimatedColor).g, configG);</span>
    <span class="s1">const aB = anim((value: AnimatedColor).b, configB);</span>
    <span class="s1">const aA = anim((value: AnimatedColor).a, configA);</span>
    <span class="s0">// We use `stopTogether: false` here because otherwise tracking will break</span>
    <span class="s0">// because the second animation will get stopped before it can update.</span>
    <span class="s3">return </span><span class="s1">parallel([aR, aG, aB, aA], {stopTogether: </span><span class="s3">false</span><span class="s1">});</span>
  <span class="s1">}</span>
  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s1">const spring = </span><span class="s3">function </span><span class="s1">(</span>
  <span class="s1">value: AnimatedValue | AnimatedValueXY | AnimatedColor,</span>
  <span class="s1">config: SpringAnimationConfig,</span>
<span class="s1">): CompositeAnimation {</span>
  <span class="s1">const start = </span><span class="s3">function </span><span class="s1">(</span>
    <span class="s1">animatedValue: AnimatedValue | AnimatedValueXY | AnimatedColor,</span>
    <span class="s1">configuration: SpringAnimationConfig,</span>
    <span class="s1">callback?: ?EndCallback,</span>
  <span class="s1">): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s1">callback = _combineCallbacks(callback, configuration);</span>
    <span class="s1">const singleValue: any = animatedValue;</span>
    <span class="s1">const singleConfig: any = configuration;</span>
    <span class="s1">singleValue.stopTracking();</span>
    <span class="s3">if </span><span class="s1">(configuration.toValue </span><span class="s3">instanceof </span><span class="s1">AnimatedNode) {</span>
      <span class="s1">singleValue.track(</span>
        <span class="s3">new </span><span class="s1">AnimatedTracking(</span>
          <span class="s1">singleValue,</span>
          <span class="s1">configuration.toValue,</span>
          <span class="s1">SpringAnimation,</span>
          <span class="s1">singleConfig,</span>
          <span class="s1">callback,</span>
        <span class="s1">),</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">singleValue.animate(</span><span class="s3">new </span><span class="s1">SpringAnimation(singleConfig), callback);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s3">return </span><span class="s1">(</span>
    <span class="s1">maybeVectorAnim(value, config, spring) || {</span>
      <span class="s1">start: </span><span class="s3">function </span><span class="s1">(callback?: ?EndCallback): </span><span class="s3">void </span><span class="s1">{</span>
        <span class="s1">start(value, config, callback);</span>
      <span class="s1">},</span>

      <span class="s1">stop: </span><span class="s3">function </span><span class="s1">(): </span><span class="s3">void </span><span class="s1">{</span>
        <span class="s1">value.stopAnimation();</span>
      <span class="s1">},</span>

      <span class="s1">reset: </span><span class="s3">function </span><span class="s1">(): </span><span class="s3">void </span><span class="s1">{</span>
        <span class="s1">value.resetAnimation();</span>
      <span class="s1">},</span>

      <span class="s1">_startNativeLoop: </span><span class="s3">function </span><span class="s1">(iterations?: number): </span><span class="s3">void </span><span class="s1">{</span>
        <span class="s1">const singleConfig = {...config, iterations};</span>
        <span class="s1">start(value, singleConfig);</span>
      <span class="s1">},</span>

      <span class="s1">_isUsingNativeDriver: </span><span class="s3">function </span><span class="s1">(): boolean {</span>
        <span class="s3">return </span><span class="s1">config.useNativeDriver || </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">},</span>
    <span class="s1">}</span>
  <span class="s1">);</span>
<span class="s1">};</span>

<span class="s1">const timing = </span><span class="s3">function </span><span class="s1">(</span>
  <span class="s1">value: AnimatedValue | AnimatedValueXY | AnimatedColor,</span>
  <span class="s1">config: TimingAnimationConfig,</span>
<span class="s1">): CompositeAnimation {</span>
  <span class="s1">const start = </span><span class="s3">function </span><span class="s1">(</span>
    <span class="s1">animatedValue: AnimatedValue | AnimatedValueXY | AnimatedColor,</span>
    <span class="s1">configuration: TimingAnimationConfig,</span>
    <span class="s1">callback?: ?EndCallback,</span>
  <span class="s1">): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s1">callback = _combineCallbacks(callback, configuration);</span>
    <span class="s1">const singleValue: any = animatedValue;</span>
    <span class="s1">const singleConfig: any = configuration;</span>
    <span class="s1">singleValue.stopTracking();</span>
    <span class="s3">if </span><span class="s1">(configuration.toValue </span><span class="s3">instanceof </span><span class="s1">AnimatedNode) {</span>
      <span class="s1">singleValue.track(</span>
        <span class="s3">new </span><span class="s1">AnimatedTracking(</span>
          <span class="s1">singleValue,</span>
          <span class="s1">configuration.toValue,</span>
          <span class="s1">TimingAnimation,</span>
          <span class="s1">singleConfig,</span>
          <span class="s1">callback,</span>
        <span class="s1">),</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">singleValue.animate(</span><span class="s3">new </span><span class="s1">TimingAnimation(singleConfig), callback);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">return </span><span class="s1">(</span>
    <span class="s1">maybeVectorAnim(value, config, timing) || {</span>
      <span class="s1">start: </span><span class="s3">function </span><span class="s1">(callback?: ?EndCallback): </span><span class="s3">void </span><span class="s1">{</span>
        <span class="s1">start(value, config, callback);</span>
      <span class="s1">},</span>

      <span class="s1">stop: </span><span class="s3">function </span><span class="s1">(): </span><span class="s3">void </span><span class="s1">{</span>
        <span class="s1">value.stopAnimation();</span>
      <span class="s1">},</span>

      <span class="s1">reset: </span><span class="s3">function </span><span class="s1">(): </span><span class="s3">void </span><span class="s1">{</span>
        <span class="s1">value.resetAnimation();</span>
      <span class="s1">},</span>

      <span class="s1">_startNativeLoop: </span><span class="s3">function </span><span class="s1">(iterations?: number): </span><span class="s3">void </span><span class="s1">{</span>
        <span class="s1">const singleConfig = {...config, iterations};</span>
        <span class="s1">start(value, singleConfig);</span>
      <span class="s1">},</span>

      <span class="s1">_isUsingNativeDriver: </span><span class="s3">function </span><span class="s1">(): boolean {</span>
        <span class="s3">return </span><span class="s1">config.useNativeDriver || </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">},</span>
    <span class="s1">}</span>
  <span class="s1">);</span>
<span class="s1">};</span>

<span class="s1">const decay = </span><span class="s3">function </span><span class="s1">(</span>
  <span class="s1">value: AnimatedValue | AnimatedValueXY | AnimatedColor,</span>
  <span class="s1">config: DecayAnimationConfig,</span>
<span class="s1">): CompositeAnimation {</span>
  <span class="s1">const start = </span><span class="s3">function </span><span class="s1">(</span>
    <span class="s1">animatedValue: AnimatedValue | AnimatedValueXY | AnimatedColor,</span>
    <span class="s1">configuration: DecayAnimationConfig,</span>
    <span class="s1">callback?: ?EndCallback,</span>
  <span class="s1">): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s1">callback = _combineCallbacks(callback, configuration);</span>
    <span class="s1">const singleValue: any = animatedValue;</span>
    <span class="s1">const singleConfig: any = configuration;</span>
    <span class="s1">singleValue.stopTracking();</span>
    <span class="s1">singleValue.animate(</span><span class="s3">new </span><span class="s1">DecayAnimation(singleConfig), callback);</span>
  <span class="s1">};</span>

  <span class="s3">return </span><span class="s1">(</span>
    <span class="s1">maybeVectorAnim(value, config, decay) || {</span>
      <span class="s1">start: </span><span class="s3">function </span><span class="s1">(callback?: ?EndCallback): </span><span class="s3">void </span><span class="s1">{</span>
        <span class="s1">start(value, config, callback);</span>
      <span class="s1">},</span>

      <span class="s1">stop: </span><span class="s3">function </span><span class="s1">(): </span><span class="s3">void </span><span class="s1">{</span>
        <span class="s1">value.stopAnimation();</span>
      <span class="s1">},</span>

      <span class="s1">reset: </span><span class="s3">function </span><span class="s1">(): </span><span class="s3">void </span><span class="s1">{</span>
        <span class="s1">value.resetAnimation();</span>
      <span class="s1">},</span>

      <span class="s1">_startNativeLoop: </span><span class="s3">function </span><span class="s1">(iterations?: number): </span><span class="s3">void </span><span class="s1">{</span>
        <span class="s1">const singleConfig = {...config, iterations};</span>
        <span class="s1">start(value, singleConfig);</span>
      <span class="s1">},</span>

      <span class="s1">_isUsingNativeDriver: </span><span class="s3">function </span><span class="s1">(): boolean {</span>
        <span class="s3">return </span><span class="s1">config.useNativeDriver || </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">},</span>
    <span class="s1">}</span>
  <span class="s1">);</span>
<span class="s1">};</span>

<span class="s1">const sequence = </span><span class="s3">function </span><span class="s1">(</span>
  <span class="s1">animations: Array&lt;CompositeAnimation&gt;,</span>
<span class="s1">): CompositeAnimation {</span>
  <span class="s1">let current = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">start: </span><span class="s3">function </span><span class="s1">(callback?: ?EndCallback) {</span>
      <span class="s1">const onComplete = </span><span class="s3">function </span><span class="s1">(result: EndResult) {</span>
        <span class="s3">if </span><span class="s1">(!result.finished) {</span>
          <span class="s1">callback &amp;&amp; callback(result);</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">current++;</span>

        <span class="s3">if </span><span class="s1">(current === animations.length) {</span>
          <span class="s1">callback &amp;&amp; callback(result);</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">animations[current].start(onComplete);</span>
      <span class="s1">};</span>

      <span class="s3">if </span><span class="s1">(animations.length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">callback &amp;&amp; callback({finished: </span><span class="s3">true</span><span class="s1">});</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">animations[current].start(onComplete);</span>
      <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s1">stop: </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">if </span><span class="s1">(current &lt; animations.length) {</span>
        <span class="s1">animations[current].stop();</span>
      <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s1">reset: </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s1">animations.forEach((animation, idx) =&gt; {</span>
        <span class="s3">if </span><span class="s1">(idx &lt;= current) {</span>
          <span class="s1">animation.reset();</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
      <span class="s1">current = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">},</span>

    <span class="s1">_startNativeLoop: </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">'Loops run using the native driver cannot contain Animated.sequence animations'</span><span class="s1">,</span>
      <span class="s1">);</span>
    <span class="s1">},</span>

    <span class="s1">_isUsingNativeDriver: </span><span class="s3">function </span><span class="s1">(): boolean {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">},</span>
  <span class="s1">};</span>
<span class="s1">};</span>

<span class="s1">type ParallelConfig = {</span>
  <span class="s0">// If one is stopped, stop all.  default: true</span>
  <span class="s1">stopTogether?: boolean,</span>
  <span class="s1">...</span>
<span class="s1">};</span>
<span class="s1">const parallel = </span><span class="s3">function </span><span class="s1">(</span>
  <span class="s1">animations: Array&lt;CompositeAnimation&gt;,</span>
  <span class="s1">config?: ?ParallelConfig,</span>
<span class="s1">): CompositeAnimation {</span>
  <span class="s1">let doneCount = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s0">// Make sure we only call stop() at most once for each animation</span>
  <span class="s1">const hasEnded: {[number]: boolean} = {};</span>
  <span class="s1">const stopTogether = !(config &amp;&amp; config.stopTogether === </span><span class="s3">false</span><span class="s1">);</span>

  <span class="s1">const result = {</span>
    <span class="s1">start: </span><span class="s3">function </span><span class="s1">(callback?: ?EndCallback) {</span>
      <span class="s3">if </span><span class="s1">(doneCount === animations.length) {</span>
        <span class="s1">callback &amp;&amp; callback({finished: </span><span class="s3">true</span><span class="s1">});</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">animations.forEach((animation, idx) =&gt; {</span>
        <span class="s1">const cb = </span><span class="s3">function </span><span class="s1">(endResult: EndResult | {finished: boolean}) {</span>
          <span class="s1">hasEnded[idx] = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">doneCount++;</span>
          <span class="s3">if </span><span class="s1">(doneCount === animations.length) {</span>
            <span class="s1">doneCount = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">callback &amp;&amp; callback(endResult);</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(!endResult.finished &amp;&amp; stopTogether) {</span>
            <span class="s1">result.stop();</span>
          <span class="s1">}</span>
        <span class="s1">};</span>

        <span class="s3">if </span><span class="s1">(!animation) {</span>
          <span class="s1">cb({finished: </span><span class="s3">true</span><span class="s1">});</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">animation.start(cb);</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">},</span>

    <span class="s1">stop: </span><span class="s3">function </span><span class="s1">(): </span><span class="s3">void </span><span class="s1">{</span>
      <span class="s1">animations.forEach((animation, idx) =&gt; {</span>
        <span class="s1">!hasEnded[idx] &amp;&amp; animation.stop();</span>
        <span class="s1">hasEnded[idx] = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">});</span>
    <span class="s1">},</span>

    <span class="s1">reset: </span><span class="s3">function </span><span class="s1">(): </span><span class="s3">void </span><span class="s1">{</span>
      <span class="s1">animations.forEach((animation, idx) =&gt; {</span>
        <span class="s1">animation.reset();</span>
        <span class="s1">hasEnded[idx] = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">doneCount = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">});</span>
    <span class="s1">},</span>

    <span class="s1">_startNativeLoop: </span><span class="s3">function </span><span class="s1">(): empty {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">'Loops run using the native driver cannot contain Animated.parallel animations'</span><span class="s1">,</span>
      <span class="s1">);</span>
    <span class="s1">},</span>

    <span class="s1">_isUsingNativeDriver: </span><span class="s3">function </span><span class="s1">(): boolean {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">},</span>
  <span class="s1">};</span>

  <span class="s3">return </span><span class="s1">result;</span>
<span class="s1">};</span>

<span class="s1">const delay = </span><span class="s3">function </span><span class="s1">(time: number): CompositeAnimation {</span>
  <span class="s0">// Would be nice to make a specialized implementation</span>
  <span class="s3">return </span><span class="s1">timing(</span><span class="s3">new </span><span class="s1">AnimatedValue(</span><span class="s4">0</span><span class="s1">), {</span>
    <span class="s1">toValue: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">delay: time,</span>
    <span class="s1">duration: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">useNativeDriver: </span><span class="s3">false</span><span class="s1">,</span>
  <span class="s1">});</span>
<span class="s1">};</span>

<span class="s1">const stagger = </span><span class="s3">function </span><span class="s1">(</span>
  <span class="s1">time: number,</span>
  <span class="s1">animations: Array&lt;CompositeAnimation&gt;,</span>
<span class="s1">): CompositeAnimation {</span>
  <span class="s3">return </span><span class="s1">parallel(</span>
    <span class="s1">animations.map((animation, i) =&gt; {</span>
      <span class="s3">return </span><span class="s1">sequence([delay(time * i), animation]);</span>
    <span class="s1">}),</span>
  <span class="s1">);</span>
<span class="s1">};</span>

<span class="s1">type LoopAnimationConfig = {</span>
  <span class="s1">iterations: number,</span>
  <span class="s1">resetBeforeIteration?: boolean,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s1">const loop = </span><span class="s3">function </span><span class="s1">(</span>
  <span class="s1">animation: CompositeAnimation,</span>
  <span class="s0">// $FlowFixMe[prop-missing]</span>
  <span class="s1">{iterations = -</span><span class="s4">1</span><span class="s1">, resetBeforeIteration = </span><span class="s3">true</span><span class="s1">}: LoopAnimationConfig = {},</span>
<span class="s1">): CompositeAnimation {</span>
  <span class="s1">let isFinished = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">let iterationsSoFar = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">start: </span><span class="s3">function </span><span class="s1">(callback?: ?EndCallback) {</span>
      <span class="s1">const restart = </span><span class="s3">function </span><span class="s1">(result: EndResult = {finished: </span><span class="s3">true</span><span class="s1">}): </span><span class="s3">void </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(</span>
          <span class="s1">isFinished ||</span>
          <span class="s1">iterationsSoFar === iterations ||</span>
          <span class="s1">result.finished === </span><span class="s3">false</span>
        <span class="s1">) {</span>
          <span class="s1">callback &amp;&amp; callback(result);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">iterationsSoFar++;</span>
          <span class="s1">resetBeforeIteration &amp;&amp; animation.reset();</span>
          <span class="s1">animation.start(restart);</span>
        <span class="s1">}</span>
      <span class="s1">};</span>
      <span class="s3">if </span><span class="s1">(!animation || iterations === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">callback &amp;&amp; callback({finished: </span><span class="s3">true</span><span class="s1">});</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(animation._isUsingNativeDriver()) {</span>
          <span class="s1">animation._startNativeLoop(iterations);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">restart(); </span><span class="s0">// Start looping recursively on the js thread</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s1">stop: </span><span class="s3">function </span><span class="s1">(): </span><span class="s3">void </span><span class="s1">{</span>
      <span class="s1">isFinished = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">animation.stop();</span>
    <span class="s1">},</span>

    <span class="s1">reset: </span><span class="s3">function </span><span class="s1">(): </span><span class="s3">void </span><span class="s1">{</span>
      <span class="s1">iterationsSoFar = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">isFinished = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">animation.reset();</span>
    <span class="s1">},</span>

    <span class="s1">_startNativeLoop: </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">'Loops run using the native driver cannot contain Animated.loop animations'</span><span class="s1">,</span>
      <span class="s1">);</span>
    <span class="s1">},</span>

    <span class="s1">_isUsingNativeDriver: </span><span class="s3">function </span><span class="s1">(): boolean {</span>
      <span class="s3">return </span><span class="s1">animation._isUsingNativeDriver();</span>
    <span class="s1">},</span>
  <span class="s1">};</span>
<span class="s1">};</span>

<span class="s3">function </span><span class="s1">forkEvent(</span>
  <span class="s1">event: ?AnimatedEvent | ?Function,</span>
  <span class="s1">listener: Function,</span>
<span class="s1">): AnimatedEvent | Function {</span>
  <span class="s3">if </span><span class="s1">(!event) {</span>
    <span class="s3">return </span><span class="s1">listener;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(event </span><span class="s3">instanceof </span><span class="s1">AnimatedEvent) {</span>
    <span class="s1">event.__addListener(listener);</span>
    <span class="s3">return </span><span class="s1">event;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">return </span><span class="s1">(...args) =&gt; {</span>
      <span class="s3">typeof </span><span class="s1">event === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; event(...args);</span>
      <span class="s1">listener(...args);</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">unforkEvent(</span>
  <span class="s1">event: ?AnimatedEvent | ?Function,</span>
  <span class="s1">listener: Function,</span>
<span class="s1">): </span><span class="s3">void </span><span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(event &amp;&amp; event </span><span class="s3">instanceof </span><span class="s1">AnimatedEvent) {</span>
    <span class="s1">event.__removeListener(listener);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">const event = </span><span class="s3">function </span><span class="s1">(</span>
  <span class="s1">argMapping: $ReadOnlyArray&lt;?Mapping&gt;,</span>
  <span class="s1">config: EventConfig,</span>
<span class="s1">): any {</span>
  <span class="s1">const animatedEvent = </span><span class="s3">new </span><span class="s1">AnimatedEvent(argMapping, config);</span>
  <span class="s3">if </span><span class="s1">(animatedEvent.__isNative) {</span>
    <span class="s3">return </span><span class="s1">animatedEvent;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">return </span><span class="s1">animatedEvent.__getHandler();</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s0">// All types of animated nodes that represent scalar numbers and can be interpolated (etc)</span>
<span class="s1">type AnimatedNumeric =</span>
  <span class="s1">| AnimatedAddition</span>
  <span class="s1">| AnimatedDiffClamp</span>
  <span class="s1">| AnimatedDivision</span>
  <span class="s1">| AnimatedInterpolation&lt;number&gt;</span>
  <span class="s1">| AnimatedModulo</span>
  <span class="s1">| AnimatedMultiplication</span>
  <span class="s1">| AnimatedSubtraction</span>
  <span class="s1">| AnimatedValue;</span>

<span class="s1">export type {AnimatedNumeric as Numeric};</span>

<span class="s0">/** 
 * The `Animated` library is designed to make animations fluid, powerful, and 
 * easy to build and maintain. `Animated` focuses on declarative relationships 
 * between inputs and outputs, with configurable transforms in between, and 
 * simple `start`/`stop` methods to control time-based animation execution. 
 * If additional transforms are added, be sure to include them in 
 * AnimatedMock.js as well. 
 * 
 * See https://reactnative.dev/docs/animated 
 */</span>
<span class="s1">export </span><span class="s3">default </span><span class="s1">{</span>
  <span class="s0">/** 
   * Standard value class for driving animations.  Typically initialized with 
   * `new Animated.Value(0);` 
   * 
   * See https://reactnative.dev/docs/animated#value 
   */</span>
  <span class="s1">Value: AnimatedValue,</span>
  <span class="s0">/** 
   * 2D value class for driving 2D animations, such as pan gestures. 
   * 
   * See https://reactnative.dev/docs/animatedvaluexy 
   */</span>
  <span class="s1">ValueXY: AnimatedValueXY,</span>
  <span class="s0">/** 
   * Value class for driving color animations. 
   */</span>
  <span class="s1">Color: AnimatedColor,</span>
  <span class="s0">/** 
   * Exported to use the Interpolation type in flow. 
   * 
   * See https://reactnative.dev/docs/animated#interpolation 
   */</span>
  <span class="s1">Interpolation: AnimatedInterpolation,</span>
  <span class="s0">/** 
   * Exported for ease of type checking. All animated values derive from this 
   * class. 
   * 
   * See https://reactnative.dev/docs/animated#node 
   */</span>
  <span class="s1">Node: AnimatedNode,</span>

  <span class="s0">/** 
   * Animates a value from an initial velocity to zero based on a decay 
   * coefficient. 
   * 
   * See https://reactnative.dev/docs/animated#decay 
   */</span>
  <span class="s1">decay,</span>
  <span class="s0">/** 
   * Animates a value along a timed easing curve. The Easing module has tons of 
   * predefined curves, or you can use your own function. 
   * 
   * See https://reactnative.dev/docs/animated#timing 
   */</span>
  <span class="s1">timing,</span>
  <span class="s0">/** 
   * Animates a value according to an analytical spring model based on 
   * damped harmonic oscillation. 
   * 
   * See https://reactnative.dev/docs/animated#spring 
   */</span>
  <span class="s1">spring,</span>

  <span class="s0">/** 
   * Creates a new Animated value composed from two Animated values added 
   * together. 
   * 
   * See https://reactnative.dev/docs/animated#add 
   */</span>
  <span class="s1">add,</span>

  <span class="s0">/** 
   * Creates a new Animated value composed by subtracting the second Animated 
   * value from the first Animated value. 
   * 
   * See https://reactnative.dev/docs/animated#subtract 
   */</span>
  <span class="s1">subtract,</span>

  <span class="s0">/** 
   * Creates a new Animated value composed by dividing the first Animated value 
   * by the second Animated value. 
   * 
   * See https://reactnative.dev/docs/animated#divide 
   */</span>
  <span class="s1">divide,</span>

  <span class="s0">/** 
   * Creates a new Animated value composed from two Animated values multiplied 
   * together. 
   * 
   * See https://reactnative.dev/docs/animated#multiply 
   */</span>
  <span class="s1">multiply,</span>

  <span class="s0">/** 
   * Creates a new Animated value that is the (non-negative) modulo of the 
   * provided Animated value. 
   * 
   * See https://reactnative.dev/docs/animated#modulo 
   */</span>
  <span class="s1">modulo,</span>

  <span class="s0">/** 
   * Create a new Animated value that is limited between 2 values. It uses the 
   * difference between the last value so even if the value is far from the 
   * bounds it will start changing when the value starts getting closer again. 
   * 
   * See https://reactnative.dev/docs/animated#diffclamp 
   */</span>
  <span class="s1">diffClamp,</span>

  <span class="s0">/** 
   * Starts an animation after the given delay. 
   * 
   * See https://reactnative.dev/docs/animated#delay 
   */</span>
  <span class="s1">delay,</span>
  <span class="s0">/** 
   * Starts an array of animations in order, waiting for each to complete 
   * before starting the next. If the current running animation is stopped, no 
   * following animations will be started. 
   * 
   * See https://reactnative.dev/docs/animated#sequence 
   */</span>
  <span class="s1">sequence,</span>
  <span class="s0">/** 
   * Starts an array of animations all at the same time. By default, if one 
   * of the animations is stopped, they will all be stopped. You can override 
   * this with the `stopTogether` flag. 
   * 
   * See https://reactnative.dev/docs/animated#parallel 
   */</span>
  <span class="s1">parallel,</span>
  <span class="s0">/** 
   * Array of animations may run in parallel (overlap), but are started in 
   * sequence with successive delays.  Nice for doing trailing effects. 
   * 
   * See https://reactnative.dev/docs/animated#stagger 
   */</span>
  <span class="s1">stagger,</span>
  <span class="s0">/** 
   * Loops a given animation continuously, so that each time it reaches the 
   * end, it resets and begins again from the start. 
   * 
   * See https://reactnative.dev/docs/animated#loop 
   */</span>
  <span class="s1">loop,</span>

  <span class="s0">/** 
   * Takes an array of mappings and extracts values from each arg accordingly, 
   * then calls `setValue` on the mapped outputs. 
   * 
   * See https://reactnative.dev/docs/animated#event 
   */</span>
  <span class="s1">event,</span>

  <span class="s0">/** 
   * Make any React component Animatable.  Used to create `Animated.View`, etc. 
   * 
   * See https://reactnative.dev/docs/animated#createanimatedcomponent 
   */</span>
  <span class="s1">createAnimatedComponent,</span>

  <span class="s0">/** 
   * Imperative API to attach an animated value to an event on a view. Prefer 
   * using `Animated.event` with `useNativeDrive: true` if possible. 
   * 
   * See https://reactnative.dev/docs/animated#attachnativeevent 
   */</span>
  <span class="s1">attachNativeEvent,</span>

  <span class="s0">/** 
   * Advanced imperative API for snooping on animated events that are passed in 
   * through props. Use values directly where possible. 
   * 
   * See https://reactnative.dev/docs/animated#forkevent 
   */</span>
  <span class="s1">forkEvent,</span>
  <span class="s1">unforkEvent,</span>

  <span class="s0">/** 
   * Expose Event class, so it can be used as a type for type checkers. 
   */</span>
  <span class="s1">Event: AnimatedEvent,</span>
<span class="s1">};</span>
</pre>
</body>
</html>
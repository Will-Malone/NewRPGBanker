<html>
<head>
<title>_stream_readable.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_stream_readable.js</font>
</center></td></tr></table>
<pre><span class="s0">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s0">//</span>
<span class="s0">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s0">// copy of this software and associated documentation files (the</span>
<span class="s0">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s0">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s0">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s0">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s0">// following conditions:</span>
<span class="s0">//</span>
<span class="s0">// The above copyright notice and this permission notice shall be included</span>
<span class="s0">// in all copies or substantial portions of the Software.</span>
<span class="s0">//</span>
<span class="s0">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s0">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s0">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s0">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s0">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s0">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s0">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s1">module.exports = Readable;</span>

<span class="s0">/*&lt;replacement&gt;*/</span>
<span class="s3">var </span><span class="s1">Duplex;</span>
<span class="s0">/*&lt;/replacement&gt;*/</span>

<span class="s1">Readable.ReadableState = ReadableState;</span>

<span class="s0">/*&lt;replacement&gt;*/</span>
<span class="s3">var </span><span class="s1">EE = require(</span><span class="s2">'events'</span><span class="s1">).EventEmitter;</span>
<span class="s3">var </span><span class="s1">EElistenerCount = </span><span class="s3">function </span><span class="s1">EElistenerCount(emitter, type) {</span>
  <span class="s3">return </span><span class="s1">emitter.listeners(type).length;</span>
<span class="s1">};</span>
<span class="s0">/*&lt;/replacement&gt;*/</span>

<span class="s0">/*&lt;replacement&gt;*/</span>
<span class="s3">var </span><span class="s1">Stream = require(</span><span class="s2">'./internal/streams/stream'</span><span class="s1">);</span>
<span class="s0">/*&lt;/replacement&gt;*/</span>

<span class="s3">var </span><span class="s1">Buffer = require(</span><span class="s2">'buffer'</span><span class="s1">).Buffer;</span>
<span class="s3">var </span><span class="s1">OurUint8Array = (</span><span class="s3">typeof </span><span class="s1">global !== </span><span class="s2">'undefined' </span><span class="s1">? global : </span><span class="s3">typeof </span><span class="s1">window !== </span><span class="s2">'undefined' </span><span class="s1">? window : </span><span class="s3">typeof </span><span class="s1">self !== </span><span class="s2">'undefined' </span><span class="s1">? self : {}).Uint8Array || </span><span class="s3">function </span><span class="s1">() {};</span>
<span class="s3">function </span><span class="s1">_uint8ArrayToBuffer(chunk) {</span>
  <span class="s3">return </span><span class="s1">Buffer.from(chunk);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">_isUint8Array(obj) {</span>
  <span class="s3">return </span><span class="s1">Buffer.isBuffer(obj) || obj </span><span class="s3">instanceof </span><span class="s1">OurUint8Array;</span>
<span class="s1">}</span>

<span class="s0">/*&lt;replacement&gt;*/</span>
<span class="s3">var </span><span class="s1">debugUtil = require(</span><span class="s2">'util'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">debug;</span>
<span class="s3">if </span><span class="s1">(debugUtil &amp;&amp; debugUtil.debuglog) {</span>
  <span class="s1">debug = debugUtil.debuglog(</span><span class="s2">'stream'</span><span class="s1">);</span>
<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
  <span class="s1">debug = </span><span class="s3">function </span><span class="s1">debug() {};</span>
<span class="s1">}</span>
<span class="s0">/*&lt;/replacement&gt;*/</span>

<span class="s3">var </span><span class="s1">BufferList = require(</span><span class="s2">'./internal/streams/buffer_list'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">destroyImpl = require(</span><span class="s2">'./internal/streams/destroy'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">_require = require(</span><span class="s2">'./internal/streams/state'</span><span class="s1">),</span>
  <span class="s1">getHighWaterMark = _require.getHighWaterMark;</span>
<span class="s3">var </span><span class="s1">_require$codes = require(</span><span class="s2">'../errors'</span><span class="s1">).codes,</span>
  <span class="s1">ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,</span>
  <span class="s1">ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,</span>
  <span class="s1">ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,</span>
  <span class="s1">ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;</span>

<span class="s0">// Lazy loaded to improve the startup performance.</span>
<span class="s3">var </span><span class="s1">StringDecoder;</span>
<span class="s3">var </span><span class="s1">createReadableStreamAsyncIterator;</span>
<span class="s3">var </span><span class="s1">from;</span>
<span class="s1">require(</span><span class="s2">'inherits'</span><span class="s1">)(Readable, Stream);</span>
<span class="s3">var </span><span class="s1">errorOrDestroy = destroyImpl.errorOrDestroy;</span>
<span class="s3">var </span><span class="s1">kProxyEvents = [</span><span class="s2">'error'</span><span class="s1">, </span><span class="s2">'close'</span><span class="s1">, </span><span class="s2">'destroy'</span><span class="s1">, </span><span class="s2">'pause'</span><span class="s1">, </span><span class="s2">'resume'</span><span class="s1">];</span>
<span class="s3">function </span><span class="s1">prependListener(emitter, event, fn) {</span>
  <span class="s0">// Sadly this is not cacheable as some libraries bundle their own</span>
  <span class="s0">// event emitter implementation with them.</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">emitter.prependListener === </span><span class="s2">'function'</span><span class="s1">) </span><span class="s3">return </span><span class="s1">emitter.prependListener(event, fn);</span>

  <span class="s0">// This is a hack to make sure that our error handler is attached before any</span>
  <span class="s0">// userland ones.  NEVER DO THIS. This is here only because this code needs</span>
  <span class="s0">// to continue to work with older versions of Node.js that do not include</span>
  <span class="s0">// the prependListener() method. The goal is to eventually remove this hack.</span>
  <span class="s3">if </span><span class="s1">(!emitter._events || !emitter._events[event]) emitter.on(event, fn);</span><span class="s3">else if </span><span class="s1">(Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);</span><span class="s3">else </span><span class="s1">emitter._events[event] = [fn, emitter._events[event]];</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">ReadableState(options, stream, isDuplex) {</span>
  <span class="s1">Duplex = Duplex || require(</span><span class="s2">'./_stream_duplex'</span><span class="s1">);</span>
  <span class="s1">options = options || {};</span>

  <span class="s0">// Duplex streams are both readable and writable, but share</span>
  <span class="s0">// the same options object.</span>
  <span class="s0">// However, some cases require setting options to different</span>
  <span class="s0">// values for the readable and the writable sides of the duplex stream.</span>
  <span class="s0">// These options can be provided separately as readableXXX and writableXXX.</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">isDuplex !== </span><span class="s2">'boolean'</span><span class="s1">) isDuplex = stream </span><span class="s3">instanceof </span><span class="s1">Duplex;</span>

  <span class="s0">// object stream flag. Used to make read(n) ignore n and to</span>
  <span class="s0">// make all the buffer merging and length checks go away</span>
  <span class="s3">this</span><span class="s1">.objectMode = !!options.objectMode;</span>
  <span class="s3">if </span><span class="s1">(isDuplex) </span><span class="s3">this</span><span class="s1">.objectMode = </span><span class="s3">this</span><span class="s1">.objectMode || !!options.readableObjectMode;</span>

  <span class="s0">// the point at which it stops calling _read() to fill the buffer</span>
  <span class="s0">// Note: 0 is a valid value, means &quot;don't call _read preemptively ever&quot;</span>
  <span class="s3">this</span><span class="s1">.highWaterMark = getHighWaterMark(</span><span class="s3">this</span><span class="s1">, options, </span><span class="s2">'readableHighWaterMark'</span><span class="s1">, isDuplex);</span>

  <span class="s0">// A linked list is used to store data chunks instead of an array because the</span>
  <span class="s0">// linked list can remove elements from the beginning faster than</span>
  <span class="s0">// array.shift()</span>
  <span class="s3">this</span><span class="s1">.buffer = </span><span class="s3">new </span><span class="s1">BufferList();</span>
  <span class="s3">this</span><span class="s1">.length = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.pipes = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.pipesCount = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.flowing = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.ended = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.endEmitted = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.reading = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s0">// a flag to be able to tell if the event 'readable'/'data' is emitted</span>
  <span class="s0">// immediately, or on a later tick.  We set this to true at first, because</span>
  <span class="s0">// any actions that shouldn't happen until &quot;later&quot; should generally also</span>
  <span class="s0">// not happen before the first read call.</span>
  <span class="s3">this</span><span class="s1">.sync = </span><span class="s3">true</span><span class="s1">;</span>

  <span class="s0">// whenever we return null, then we set a flag to say</span>
  <span class="s0">// that we're awaiting a 'readable' event emission.</span>
  <span class="s3">this</span><span class="s1">.needReadable = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.emittedReadable = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.readableListening = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.resumeScheduled = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.paused = </span><span class="s3">true</span><span class="s1">;</span>

  <span class="s0">// Should close be emitted on destroy. Defaults to true.</span>
  <span class="s3">this</span><span class="s1">.emitClose = options.emitClose !== </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s0">// Should .destroy() be called after 'end' (and potentially 'finish')</span>
  <span class="s3">this</span><span class="s1">.autoDestroy = !!options.autoDestroy;</span>

  <span class="s0">// has it been destroyed</span>
  <span class="s3">this</span><span class="s1">.destroyed = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s0">// Crypto is kind of old and crusty.  Historically, its default string</span>
  <span class="s0">// encoding is 'binary' so we have to make this configurable.</span>
  <span class="s0">// Everything else in the universe uses 'utf8', though.</span>
  <span class="s3">this</span><span class="s1">.defaultEncoding = options.defaultEncoding || </span><span class="s2">'utf8'</span><span class="s1">;</span>

  <span class="s0">// the number of writers that are awaiting a drain event in .pipe()s</span>
  <span class="s3">this</span><span class="s1">.awaitDrain = </span><span class="s4">0</span><span class="s1">;</span>

  <span class="s0">// if true, a maybeReadMore has been scheduled</span>
  <span class="s3">this</span><span class="s1">.readingMore = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.decoder = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.encoding = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(options.encoding) {</span>
    <span class="s3">if </span><span class="s1">(!StringDecoder) StringDecoder = require(</span><span class="s2">'string_decoder/'</span><span class="s1">).StringDecoder;</span>
    <span class="s3">this</span><span class="s1">.decoder = </span><span class="s3">new </span><span class="s1">StringDecoder(options.encoding);</span>
    <span class="s3">this</span><span class="s1">.encoding = options.encoding;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">Readable(options) {</span>
  <span class="s1">Duplex = Duplex || require(</span><span class="s2">'./_stream_duplex'</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(!(</span><span class="s3">this instanceof </span><span class="s1">Readable)) </span><span class="s3">return new </span><span class="s1">Readable(options);</span>

  <span class="s0">// Checking for a Stream.Duplex instance is faster here instead of inside</span>
  <span class="s0">// the ReadableState constructor, at least with V8 6.5</span>
  <span class="s3">var </span><span class="s1">isDuplex = </span><span class="s3">this instanceof </span><span class="s1">Duplex;</span>
  <span class="s3">this</span><span class="s1">._readableState = </span><span class="s3">new </span><span class="s1">ReadableState(options, </span><span class="s3">this</span><span class="s1">, isDuplex);</span>

  <span class="s0">// legacy</span>
  <span class="s3">this</span><span class="s1">.readable = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(options) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">options.read === </span><span class="s2">'function'</span><span class="s1">) </span><span class="s3">this</span><span class="s1">._read = options.read;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">options.destroy === </span><span class="s2">'function'</span><span class="s1">) </span><span class="s3">this</span><span class="s1">._destroy = options.destroy;</span>
  <span class="s1">}</span>
  <span class="s1">Stream.call(</span><span class="s3">this</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s1">Object.defineProperty(Readable.prototype, </span><span class="s2">'destroyed'</span><span class="s1">, {</span>
  <span class="s0">// making it explicit this property is not enumerable</span>
  <span class="s0">// because otherwise some prototype manipulation in</span>
  <span class="s0">// userland will fail</span>
  <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
  <span class="s1">get: </span><span class="s3">function </span><span class="s1">get() {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._readableState === undefined) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return this</span><span class="s1">._readableState.destroyed;</span>
  <span class="s1">},</span>
  <span class="s1">set: </span><span class="s3">function </span><span class="s1">set(value) {</span>
    <span class="s0">// we ignore the value if the stream</span>
    <span class="s0">// has not been initialized yet</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">._readableState) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// backward compatibility, the user is explicitly</span>
    <span class="s0">// managing destroyed</span>
    <span class="s3">this</span><span class="s1">._readableState.destroyed = value;</span>
  <span class="s1">}</span>
<span class="s1">});</span>
<span class="s1">Readable.prototype.destroy = destroyImpl.destroy;</span>
<span class="s1">Readable.prototype._undestroy = destroyImpl.undestroy;</span>
<span class="s1">Readable.prototype._destroy = </span><span class="s3">function </span><span class="s1">(err, cb) {</span>
  <span class="s1">cb(err);</span>
<span class="s1">};</span>

<span class="s0">// Manually shove something into the read() buffer.</span>
<span class="s0">// This returns true if the highWaterMark has not been hit yet,</span>
<span class="s0">// similar to how Writable.write() returns true if you should</span>
<span class="s0">// write() some more.</span>
<span class="s1">Readable.prototype.push = </span><span class="s3">function </span><span class="s1">(chunk, encoding) {</span>
  <span class="s3">var </span><span class="s1">state = </span><span class="s3">this</span><span class="s1">._readableState;</span>
  <span class="s3">var </span><span class="s1">skipChunkCheck;</span>
  <span class="s3">if </span><span class="s1">(!state.objectMode) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">chunk === </span><span class="s2">'string'</span><span class="s1">) {</span>
      <span class="s1">encoding = encoding || state.defaultEncoding;</span>
      <span class="s3">if </span><span class="s1">(encoding !== state.encoding) {</span>
        <span class="s1">chunk = Buffer.from(chunk, encoding);</span>
        <span class="s1">encoding = </span><span class="s2">''</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">skipChunkCheck = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">skipChunkCheck = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">readableAddChunk(</span><span class="s3">this</span><span class="s1">, chunk, encoding, </span><span class="s3">false</span><span class="s1">, skipChunkCheck);</span>
<span class="s1">};</span>

<span class="s0">// Unshift should *always* be something directly out of read()</span>
<span class="s1">Readable.prototype.unshift = </span><span class="s3">function </span><span class="s1">(chunk) {</span>
  <span class="s3">return </span><span class="s1">readableAddChunk(</span><span class="s3">this</span><span class="s1">, chunk, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">true</span><span class="s1">, </span><span class="s3">false</span><span class="s1">);</span>
<span class="s1">};</span>
<span class="s3">function </span><span class="s1">readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {</span>
  <span class="s1">debug(</span><span class="s2">'readableAddChunk'</span><span class="s1">, chunk);</span>
  <span class="s3">var </span><span class="s1">state = stream._readableState;</span>
  <span class="s3">if </span><span class="s1">(chunk === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">state.reading = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">onEofChunk(stream, state);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">er;</span>
    <span class="s3">if </span><span class="s1">(!skipChunkCheck) er = chunkInvalid(state, chunk);</span>
    <span class="s3">if </span><span class="s1">(er) {</span>
      <span class="s1">errorOrDestroy(stream, er);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(state.objectMode || chunk &amp;&amp; chunk.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">chunk !== </span><span class="s2">'string' </span><span class="s1">&amp;&amp; !state.objectMode &amp;&amp; Object.getPrototypeOf(chunk) !== Buffer.prototype) {</span>
        <span class="s1">chunk = _uint8ArrayToBuffer(chunk);</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(addToFront) {</span>
        <span class="s3">if </span><span class="s1">(state.endEmitted) errorOrDestroy(stream, </span><span class="s3">new </span><span class="s1">ERR_STREAM_UNSHIFT_AFTER_END_EVENT());</span><span class="s3">else </span><span class="s1">addChunk(stream, state, chunk, </span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(state.ended) {</span>
        <span class="s1">errorOrDestroy(stream, </span><span class="s3">new </span><span class="s1">ERR_STREAM_PUSH_AFTER_EOF());</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(state.destroyed) {</span>
        <span class="s3">return false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">state.reading = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(state.decoder &amp;&amp; !encoding) {</span>
          <span class="s1">chunk = state.decoder.write(chunk);</span>
          <span class="s3">if </span><span class="s1">(state.objectMode || chunk.length !== </span><span class="s4">0</span><span class="s1">) addChunk(stream, state, chunk, </span><span class="s3">false</span><span class="s1">);</span><span class="s3">else </span><span class="s1">maybeReadMore(stream, state);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">addChunk(stream, state, chunk, </span><span class="s3">false</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!addToFront) {</span>
      <span class="s1">state.reading = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">maybeReadMore(stream, state);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// We can push more data if we are below the highWaterMark.</span>
  <span class="s0">// Also, if we have no data yet, we can stand some more bytes.</span>
  <span class="s0">// This is to work around cases where hwm=0, such as the repl.</span>
  <span class="s3">return </span><span class="s1">!state.ended &amp;&amp; (state.length &lt; state.highWaterMark || state.length === </span><span class="s4">0</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">addChunk(stream, state, chunk, addToFront) {</span>
  <span class="s3">if </span><span class="s1">(state.flowing &amp;&amp; state.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; !state.sync) {</span>
    <span class="s1">state.awaitDrain = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">stream.emit(</span><span class="s2">'data'</span><span class="s1">, chunk);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// update the buffer info.</span>
    <span class="s1">state.length += state.objectMode ? </span><span class="s4">1 </span><span class="s1">: chunk.length;</span>
    <span class="s3">if </span><span class="s1">(addToFront) state.buffer.unshift(chunk);</span><span class="s3">else </span><span class="s1">state.buffer.push(chunk);</span>
    <span class="s3">if </span><span class="s1">(state.needReadable) emitReadable(stream);</span>
  <span class="s1">}</span>
  <span class="s1">maybeReadMore(stream, state);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">chunkInvalid(state, chunk) {</span>
  <span class="s3">var </span><span class="s1">er;</span>
  <span class="s3">if </span><span class="s1">(!_isUint8Array(chunk) &amp;&amp; </span><span class="s3">typeof </span><span class="s1">chunk !== </span><span class="s2">'string' </span><span class="s1">&amp;&amp; chunk !== undefined &amp;&amp; !state.objectMode) {</span>
    <span class="s1">er = </span><span class="s3">new </span><span class="s1">ERR_INVALID_ARG_TYPE(</span><span class="s2">'chunk'</span><span class="s1">, [</span><span class="s2">'string'</span><span class="s1">, </span><span class="s2">'Buffer'</span><span class="s1">, </span><span class="s2">'Uint8Array'</span><span class="s1">], chunk);</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">er;</span>
<span class="s1">}</span>
<span class="s1">Readable.prototype.isPaused = </span><span class="s3">function </span><span class="s1">() {</span>
  <span class="s3">return this</span><span class="s1">._readableState.flowing === </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s0">// backwards compatibility.</span>
<span class="s1">Readable.prototype.setEncoding = </span><span class="s3">function </span><span class="s1">(enc) {</span>
  <span class="s3">if </span><span class="s1">(!StringDecoder) StringDecoder = require(</span><span class="s2">'string_decoder/'</span><span class="s1">).StringDecoder;</span>
  <span class="s3">var </span><span class="s1">decoder = </span><span class="s3">new </span><span class="s1">StringDecoder(enc);</span>
  <span class="s3">this</span><span class="s1">._readableState.decoder = decoder;</span>
  <span class="s0">// If setEncoding(null), decoder.encoding equals utf8</span>
  <span class="s3">this</span><span class="s1">._readableState.encoding = </span><span class="s3">this</span><span class="s1">._readableState.decoder.encoding;</span>

  <span class="s0">// Iterate over current buffer to convert already stored Buffers:</span>
  <span class="s3">var </span><span class="s1">p = </span><span class="s3">this</span><span class="s1">._readableState.buffer.head;</span>
  <span class="s3">var </span><span class="s1">content = </span><span class="s2">''</span><span class="s1">;</span>
  <span class="s3">while </span><span class="s1">(p !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">content += decoder.write(p.data);</span>
    <span class="s1">p = p.next;</span>
  <span class="s1">}</span>
  <span class="s3">this</span><span class="s1">._readableState.buffer.clear();</span>
  <span class="s3">if </span><span class="s1">(content !== </span><span class="s2">''</span><span class="s1">) </span><span class="s3">this</span><span class="s1">._readableState.buffer.push(content);</span>
  <span class="s3">this</span><span class="s1">._readableState.length = content.length;</span>
  <span class="s3">return this</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s0">// Don't raise the hwm &gt; 1GB</span>
<span class="s3">var </span><span class="s1">MAX_HWM = </span><span class="s4">0</span><span class="s1">x40000000;</span>
<span class="s3">function </span><span class="s1">computeNewHighWaterMark(n) {</span>
  <span class="s3">if </span><span class="s1">(n &gt;= MAX_HWM) {</span>
    <span class="s0">// TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.</span>
    <span class="s1">n = MAX_HWM;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// Get the next highest power of 2 to prevent increasing hwm excessively in</span>
    <span class="s0">// tiny amounts</span>
    <span class="s1">n--;</span>
    <span class="s1">n |= n &gt;&gt;&gt; </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">n |= n &gt;&gt;&gt; </span><span class="s4">2</span><span class="s1">;</span>
    <span class="s1">n |= n &gt;&gt;&gt; </span><span class="s4">4</span><span class="s1">;</span>
    <span class="s1">n |= n &gt;&gt;&gt; </span><span class="s4">8</span><span class="s1">;</span>
    <span class="s1">n |= n &gt;&gt;&gt; </span><span class="s4">16</span><span class="s1">;</span>
    <span class="s1">n++;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">n;</span>
<span class="s1">}</span>

<span class="s0">// This function is designed to be inlinable, so please take care when making</span>
<span class="s0">// changes to the function body.</span>
<span class="s3">function </span><span class="s1">howMuchToRead(n, state) {</span>
  <span class="s3">if </span><span class="s1">(n &lt;= </span><span class="s4">0 </span><span class="s1">|| state.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; state.ended) </span><span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(state.objectMode) </span><span class="s3">return </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(n !== n) {</span>
    <span class="s0">// Only flow one buffer at a time</span>
    <span class="s3">if </span><span class="s1">(state.flowing &amp;&amp; state.length) </span><span class="s3">return </span><span class="s1">state.buffer.head.data.length;</span><span class="s3">else return </span><span class="s1">state.length;</span>
  <span class="s1">}</span>
  <span class="s0">// If we're asking for more than the current hwm, then raise the hwm.</span>
  <span class="s3">if </span><span class="s1">(n &gt; state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);</span>
  <span class="s3">if </span><span class="s1">(n &lt;= state.length) </span><span class="s3">return </span><span class="s1">n;</span>
  <span class="s0">// Don't have enough</span>
  <span class="s3">if </span><span class="s1">(!state.ended) {</span>
    <span class="s1">state.needReadable = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">state.length;</span>
<span class="s1">}</span>

<span class="s0">// you can override either this method, or the async _read(n) below.</span>
<span class="s1">Readable.prototype.read = </span><span class="s3">function </span><span class="s1">(n) {</span>
  <span class="s1">debug(</span><span class="s2">'read'</span><span class="s1">, n);</span>
  <span class="s1">n = parseInt(n, </span><span class="s4">10</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">state = </span><span class="s3">this</span><span class="s1">._readableState;</span>
  <span class="s3">var </span><span class="s1">nOrig = n;</span>
  <span class="s3">if </span><span class="s1">(n !== </span><span class="s4">0</span><span class="s1">) state.emittedReadable = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s0">// if we're doing read(0) to trigger a readable event, but we</span>
  <span class="s0">// already have a bunch of data in the buffer, then just trigger</span>
  <span class="s0">// the 'readable' event and move on.</span>
  <span class="s3">if </span><span class="s1">(n === </span><span class="s4">0 </span><span class="s1">&amp;&amp; state.needReadable &amp;&amp; ((state.highWaterMark !== </span><span class="s4">0 </span><span class="s1">? state.length &gt;= state.highWaterMark : state.length &gt; </span><span class="s4">0</span><span class="s1">) || state.ended)) {</span>
    <span class="s1">debug(</span><span class="s2">'read: emitReadable'</span><span class="s1">, state.length, state.ended);</span>
    <span class="s3">if </span><span class="s1">(state.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; state.ended) endReadable(</span><span class="s3">this</span><span class="s1">);</span><span class="s3">else </span><span class="s1">emitReadable(</span><span class="s3">this</span><span class="s1">);</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">n = howMuchToRead(n, state);</span>

  <span class="s0">// if we've ended, and we're now clear, then finish it up.</span>
  <span class="s3">if </span><span class="s1">(n === </span><span class="s4">0 </span><span class="s1">&amp;&amp; state.ended) {</span>
    <span class="s3">if </span><span class="s1">(state.length === </span><span class="s4">0</span><span class="s1">) endReadable(</span><span class="s3">this</span><span class="s1">);</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// All the actual chunk generation logic needs to be</span>
  <span class="s0">// *below* the call to _read.  The reason is that in certain</span>
  <span class="s0">// synthetic stream cases, such as passthrough streams, _read</span>
  <span class="s0">// may be a completely synchronous operation which may change</span>
  <span class="s0">// the state of the read buffer, providing enough data when</span>
  <span class="s0">// before there was *not* enough.</span>
  <span class="s0">//</span>
  <span class="s0">// So, the steps are:</span>
  <span class="s0">// 1. Figure out what the state of things will be after we do</span>
  <span class="s0">// a read from the buffer.</span>
  <span class="s0">//</span>
  <span class="s0">// 2. If that resulting state will trigger a _read, then call _read.</span>
  <span class="s0">// Note that this may be asynchronous, or synchronous.  Yes, it is</span>
  <span class="s0">// deeply ugly to write APIs this way, but that still doesn't mean</span>
  <span class="s0">// that the Readable class should behave improperly, as streams are</span>
  <span class="s0">// designed to be sync/async agnostic.</span>
  <span class="s0">// Take note if the _read call is sync or async (ie, if the read call</span>
  <span class="s0">// has returned yet), so that we know whether or not it's safe to emit</span>
  <span class="s0">// 'readable' etc.</span>
  <span class="s0">//</span>
  <span class="s0">// 3. Actually pull the requested chunks out of the buffer and return.</span>

  <span class="s0">// if we need a readable event, then we need to do some reading.</span>
  <span class="s3">var </span><span class="s1">doRead = state.needReadable;</span>
  <span class="s1">debug(</span><span class="s2">'need readable'</span><span class="s1">, doRead);</span>

  <span class="s0">// if we currently have less than the highWaterMark, then also read some</span>
  <span class="s3">if </span><span class="s1">(state.length === </span><span class="s4">0 </span><span class="s1">|| state.length - n &lt; state.highWaterMark) {</span>
    <span class="s1">doRead = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">debug(</span><span class="s2">'length less than watermark'</span><span class="s1">, doRead);</span>
  <span class="s1">}</span>

  <span class="s0">// however, if we've ended, then there's no point, and if we're already</span>
  <span class="s0">// reading, then it's unnecessary.</span>
  <span class="s3">if </span><span class="s1">(state.ended || state.reading) {</span>
    <span class="s1">doRead = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">debug(</span><span class="s2">'reading or ended'</span><span class="s1">, doRead);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(doRead) {</span>
    <span class="s1">debug(</span><span class="s2">'do read'</span><span class="s1">);</span>
    <span class="s1">state.reading = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">state.sync = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s0">// if the length is currently zero, then we *need* a readable event.</span>
    <span class="s3">if </span><span class="s1">(state.length === </span><span class="s4">0</span><span class="s1">) state.needReadable = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s0">// call internal read method</span>
    <span class="s3">this</span><span class="s1">._read(state.highWaterMark);</span>
    <span class="s1">state.sync = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s0">// If _read pushed data synchronously, then `reading` will be false,</span>
    <span class="s0">// and we need to re-evaluate how much data we can return to the user.</span>
    <span class="s3">if </span><span class="s1">(!state.reading) n = howMuchToRead(nOrig, state);</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">ret;</span>
  <span class="s3">if </span><span class="s1">(n &gt; </span><span class="s4">0</span><span class="s1">) ret = fromList(n, state);</span><span class="s3">else </span><span class="s1">ret = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(ret === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">state.needReadable = state.length &lt;= state.highWaterMark;</span>
    <span class="s1">n = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">state.length -= n;</span>
    <span class="s1">state.awaitDrain = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(state.length === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s0">// If we have nothing in the buffer, then we want to know</span>
    <span class="s0">// as soon as we *do* get something into the buffer.</span>
    <span class="s3">if </span><span class="s1">(!state.ended) state.needReadable = </span><span class="s3">true</span><span class="s1">;</span>

    <span class="s0">// If we tried to read() past the EOF, then emit end on the next tick.</span>
    <span class="s3">if </span><span class="s1">(nOrig !== n &amp;&amp; state.ended) endReadable(</span><span class="s3">this</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(ret !== </span><span class="s3">null</span><span class="s1">) </span><span class="s3">this</span><span class="s1">.emit(</span><span class="s2">'data'</span><span class="s1">, ret);</span>
  <span class="s3">return </span><span class="s1">ret;</span>
<span class="s1">};</span>
<span class="s3">function </span><span class="s1">onEofChunk(stream, state) {</span>
  <span class="s1">debug(</span><span class="s2">'onEofChunk'</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(state.ended) </span><span class="s3">return</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(state.decoder) {</span>
    <span class="s3">var </span><span class="s1">chunk = state.decoder.end();</span>
    <span class="s3">if </span><span class="s1">(chunk &amp;&amp; chunk.length) {</span>
      <span class="s1">state.buffer.push(chunk);</span>
      <span class="s1">state.length += state.objectMode ? </span><span class="s4">1 </span><span class="s1">: chunk.length;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">state.ended = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(state.sync) {</span>
    <span class="s0">// if we are sync, wait until next tick to emit the data.</span>
    <span class="s0">// Otherwise we risk emitting data in the flow()</span>
    <span class="s0">// the readable code triggers during a read() call</span>
    <span class="s1">emitReadable(stream);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// emit 'readable' now to make sure it gets picked up.</span>
    <span class="s1">state.needReadable = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(!state.emittedReadable) {</span>
      <span class="s1">state.emittedReadable = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">emitReadable_(stream);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">// Don't emit readable right away in sync mode, because this can trigger</span>
<span class="s0">// another read() call =&gt; stack overflow.  This way, it might trigger</span>
<span class="s0">// a nextTick recursion warning, but that's not so bad.</span>
<span class="s3">function </span><span class="s1">emitReadable(stream) {</span>
  <span class="s3">var </span><span class="s1">state = stream._readableState;</span>
  <span class="s1">debug(</span><span class="s2">'emitReadable'</span><span class="s1">, state.needReadable, state.emittedReadable);</span>
  <span class="s1">state.needReadable = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(!state.emittedReadable) {</span>
    <span class="s1">debug(</span><span class="s2">'emitReadable'</span><span class="s1">, state.flowing);</span>
    <span class="s1">state.emittedReadable = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">process.nextTick(emitReadable_, stream);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">emitReadable_(stream) {</span>
  <span class="s3">var </span><span class="s1">state = stream._readableState;</span>
  <span class="s1">debug(</span><span class="s2">'emitReadable_'</span><span class="s1">, state.destroyed, state.length, state.ended);</span>
  <span class="s3">if </span><span class="s1">(!state.destroyed &amp;&amp; (state.length || state.ended)) {</span>
    <span class="s1">stream.emit(</span><span class="s2">'readable'</span><span class="s1">);</span>
    <span class="s1">state.emittedReadable = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// The stream needs another readable event if</span>
  <span class="s0">// 1. It is not flowing, as the flow mechanism will take</span>
  <span class="s0">//    care of it.</span>
  <span class="s0">// 2. It is not ended.</span>
  <span class="s0">// 3. It is below the highWaterMark, so we can schedule</span>
  <span class="s0">//    another readable later.</span>
  <span class="s1">state.needReadable = !state.flowing &amp;&amp; !state.ended &amp;&amp; state.length &lt;= state.highWaterMark;</span>
  <span class="s1">flow(stream);</span>
<span class="s1">}</span>

<span class="s0">// at this point, the user has presumably seen the 'readable' event,</span>
<span class="s0">// and called read() to consume some data.  that may have triggered</span>
<span class="s0">// in turn another _read(n) call, in which case reading = true if</span>
<span class="s0">// it's in progress.</span>
<span class="s0">// However, if we're not ended, or reading, and the length &lt; hwm,</span>
<span class="s0">// then go ahead and try to read some more preemptively.</span>
<span class="s3">function </span><span class="s1">maybeReadMore(stream, state) {</span>
  <span class="s3">if </span><span class="s1">(!state.readingMore) {</span>
    <span class="s1">state.readingMore = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">process.nextTick(maybeReadMore_, stream, state);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">maybeReadMore_(stream, state) {</span>
  <span class="s0">// Attempt to read more data if we should.</span>
  <span class="s0">//</span>
  <span class="s0">// The conditions for reading more data are (one of):</span>
  <span class="s0">// - Not enough data buffered (state.length &lt; state.highWaterMark). The loop</span>
  <span class="s0">//   is responsible for filling the buffer with enough data if such data</span>
  <span class="s0">//   is available. If highWaterMark is 0 and we are not in the flowing mode</span>
  <span class="s0">//   we should _not_ attempt to buffer any extra data. We'll get more data</span>
  <span class="s0">//   when the stream consumer calls read() instead.</span>
  <span class="s0">// - No data in the buffer, and the stream is in flowing mode. In this mode</span>
  <span class="s0">//   the loop below is responsible for ensuring read() is called. Failing to</span>
  <span class="s0">//   call read here would abort the flow and there's no other mechanism for</span>
  <span class="s0">//   continuing the flow if the stream consumer has just subscribed to the</span>
  <span class="s0">//   'data' event.</span>
  <span class="s0">//</span>
  <span class="s0">// In addition to the above conditions to keep reading data, the following</span>
  <span class="s0">// conditions prevent the data from being read:</span>
  <span class="s0">// - The stream has ended (state.ended).</span>
  <span class="s0">// - There is already a pending 'read' operation (state.reading). This is a</span>
  <span class="s0">//   case where the the stream has called the implementation defined _read()</span>
  <span class="s0">//   method, but they are processing the call asynchronously and have _not_</span>
  <span class="s0">//   called push() with new data. In this case we skip performing more</span>
  <span class="s0">//   read()s. The execution ends in this method again after the _read() ends</span>
  <span class="s0">//   up calling push() with more data.</span>
  <span class="s3">while </span><span class="s1">(!state.reading &amp;&amp; !state.ended &amp;&amp; (state.length &lt; state.highWaterMark || state.flowing &amp;&amp; state.length === </span><span class="s4">0</span><span class="s1">)) {</span>
    <span class="s3">var </span><span class="s1">len = state.length;</span>
    <span class="s1">debug(</span><span class="s2">'maybeReadMore read 0'</span><span class="s1">);</span>
    <span class="s1">stream.read(</span><span class="s4">0</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(len === state.length)</span>
      <span class="s0">// didn't get any data, stop spinning.</span>
      <span class="s3">break</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">state.readingMore = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">// abstract method.  to be overridden in specific implementation classes.</span>
<span class="s0">// call cb(er, data) where data is &lt;= n in length.</span>
<span class="s0">// for virtual (non-string, non-buffer) streams, &quot;length&quot; is somewhat</span>
<span class="s0">// arbitrary, and perhaps not very meaningful.</span>
<span class="s1">Readable.prototype._read = </span><span class="s3">function </span><span class="s1">(n) {</span>
  <span class="s1">errorOrDestroy(</span><span class="s3">this</span><span class="s1">, </span><span class="s3">new </span><span class="s1">ERR_METHOD_NOT_IMPLEMENTED(</span><span class="s2">'_read()'</span><span class="s1">));</span>
<span class="s1">};</span>
<span class="s1">Readable.prototype.pipe = </span><span class="s3">function </span><span class="s1">(dest, pipeOpts) {</span>
  <span class="s3">var </span><span class="s1">src = </span><span class="s3">this</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">state = </span><span class="s3">this</span><span class="s1">._readableState;</span>
  <span class="s3">switch </span><span class="s1">(state.pipesCount) {</span>
    <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
      <span class="s1">state.pipes = dest;</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
      <span class="s1">state.pipes = [state.pipes, dest];</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">default</span><span class="s1">:</span>
      <span class="s1">state.pipes.push(dest);</span>
      <span class="s3">break</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">state.pipesCount += </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">debug(</span><span class="s2">'pipe count=%d opts=%j'</span><span class="s1">, state.pipesCount, pipeOpts);</span>
  <span class="s3">var </span><span class="s1">doEnd = (!pipeOpts || pipeOpts.end !== </span><span class="s3">false</span><span class="s1">) &amp;&amp; dest !== process.stdout &amp;&amp; dest !== process.stderr;</span>
  <span class="s3">var </span><span class="s1">endFn = doEnd ? onend : unpipe;</span>
  <span class="s3">if </span><span class="s1">(state.endEmitted) process.nextTick(endFn);</span><span class="s3">else </span><span class="s1">src.once(</span><span class="s2">'end'</span><span class="s1">, endFn);</span>
  <span class="s1">dest.on(</span><span class="s2">'unpipe'</span><span class="s1">, onunpipe);</span>
  <span class="s3">function </span><span class="s1">onunpipe(readable, unpipeInfo) {</span>
    <span class="s1">debug(</span><span class="s2">'onunpipe'</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(readable === src) {</span>
      <span class="s3">if </span><span class="s1">(unpipeInfo &amp;&amp; unpipeInfo.hasUnpiped === </span><span class="s3">false</span><span class="s1">) {</span>
        <span class="s1">unpipeInfo.hasUnpiped = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">cleanup();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">onend() {</span>
    <span class="s1">debug(</span><span class="s2">'onend'</span><span class="s1">);</span>
    <span class="s1">dest.end();</span>
  <span class="s1">}</span>

  <span class="s0">// when the dest drains, it reduces the awaitDrain counter</span>
  <span class="s0">// on the source.  This would be more elegant with a .once()</span>
  <span class="s0">// handler in flow(), but adding and removing repeatedly is</span>
  <span class="s0">// too slow.</span>
  <span class="s3">var </span><span class="s1">ondrain = pipeOnDrain(src);</span>
  <span class="s1">dest.on(</span><span class="s2">'drain'</span><span class="s1">, ondrain);</span>
  <span class="s3">var </span><span class="s1">cleanedUp = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">function </span><span class="s1">cleanup() {</span>
    <span class="s1">debug(</span><span class="s2">'cleanup'</span><span class="s1">);</span>
    <span class="s0">// cleanup event handlers once the pipe is broken</span>
    <span class="s1">dest.removeListener(</span><span class="s2">'close'</span><span class="s1">, onclose);</span>
    <span class="s1">dest.removeListener(</span><span class="s2">'finish'</span><span class="s1">, onfinish);</span>
    <span class="s1">dest.removeListener(</span><span class="s2">'drain'</span><span class="s1">, ondrain);</span>
    <span class="s1">dest.removeListener(</span><span class="s2">'error'</span><span class="s1">, onerror);</span>
    <span class="s1">dest.removeListener(</span><span class="s2">'unpipe'</span><span class="s1">, onunpipe);</span>
    <span class="s1">src.removeListener(</span><span class="s2">'end'</span><span class="s1">, onend);</span>
    <span class="s1">src.removeListener(</span><span class="s2">'end'</span><span class="s1">, unpipe);</span>
    <span class="s1">src.removeListener(</span><span class="s2">'data'</span><span class="s1">, ondata);</span>
    <span class="s1">cleanedUp = </span><span class="s3">true</span><span class="s1">;</span>

    <span class="s0">// if the reader is waiting for a drain event from this</span>
    <span class="s0">// specific writer, then it would cause it to never start</span>
    <span class="s0">// flowing again.</span>
    <span class="s0">// So, if this is awaiting a drain, then we just call it now.</span>
    <span class="s0">// If we don't know, then assume that we are waiting for one.</span>
    <span class="s3">if </span><span class="s1">(state.awaitDrain &amp;&amp; (!dest._writableState || dest._writableState.needDrain)) ondrain();</span>
  <span class="s1">}</span>
  <span class="s1">src.on(</span><span class="s2">'data'</span><span class="s1">, ondata);</span>
  <span class="s3">function </span><span class="s1">ondata(chunk) {</span>
    <span class="s1">debug(</span><span class="s2">'ondata'</span><span class="s1">);</span>
    <span class="s3">var </span><span class="s1">ret = dest.write(chunk);</span>
    <span class="s1">debug(</span><span class="s2">'dest.write'</span><span class="s1">, ret);</span>
    <span class="s3">if </span><span class="s1">(ret === </span><span class="s3">false</span><span class="s1">) {</span>
      <span class="s0">// If the user unpiped during `dest.write()`, it is possible</span>
      <span class="s0">// to get stuck in a permanently paused state if that write</span>
      <span class="s0">// also returned false.</span>
      <span class="s0">// =&gt; Check whether `dest` is still a piping destination.</span>
      <span class="s3">if </span><span class="s1">((state.pipesCount === </span><span class="s4">1 </span><span class="s1">&amp;&amp; state.pipes === dest || state.pipesCount &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; indexOf(state.pipes, dest) !== -</span><span class="s4">1</span><span class="s1">) &amp;&amp; !cleanedUp) {</span>
        <span class="s1">debug(</span><span class="s2">'false write response, pause'</span><span class="s1">, state.awaitDrain);</span>
        <span class="s1">state.awaitDrain++;</span>
      <span class="s1">}</span>
      <span class="s1">src.pause();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// if the dest has an error, then stop piping into it.</span>
  <span class="s0">// however, don't suppress the throwing behavior for this.</span>
  <span class="s3">function </span><span class="s1">onerror(er) {</span>
    <span class="s1">debug(</span><span class="s2">'onerror'</span><span class="s1">, er);</span>
    <span class="s1">unpipe();</span>
    <span class="s1">dest.removeListener(</span><span class="s2">'error'</span><span class="s1">, onerror);</span>
    <span class="s3">if </span><span class="s1">(EElistenerCount(dest, </span><span class="s2">'error'</span><span class="s1">) === </span><span class="s4">0</span><span class="s1">) errorOrDestroy(dest, er);</span>
  <span class="s1">}</span>

  <span class="s0">// Make sure our error handler is attached before userland ones.</span>
  <span class="s1">prependListener(dest, </span><span class="s2">'error'</span><span class="s1">, onerror);</span>

  <span class="s0">// Both close and finish should trigger unpipe, but only once.</span>
  <span class="s3">function </span><span class="s1">onclose() {</span>
    <span class="s1">dest.removeListener(</span><span class="s2">'finish'</span><span class="s1">, onfinish);</span>
    <span class="s1">unpipe();</span>
  <span class="s1">}</span>
  <span class="s1">dest.once(</span><span class="s2">'close'</span><span class="s1">, onclose);</span>
  <span class="s3">function </span><span class="s1">onfinish() {</span>
    <span class="s1">debug(</span><span class="s2">'onfinish'</span><span class="s1">);</span>
    <span class="s1">dest.removeListener(</span><span class="s2">'close'</span><span class="s1">, onclose);</span>
    <span class="s1">unpipe();</span>
  <span class="s1">}</span>
  <span class="s1">dest.once(</span><span class="s2">'finish'</span><span class="s1">, onfinish);</span>
  <span class="s3">function </span><span class="s1">unpipe() {</span>
    <span class="s1">debug(</span><span class="s2">'unpipe'</span><span class="s1">);</span>
    <span class="s1">src.unpipe(dest);</span>
  <span class="s1">}</span>

  <span class="s0">// tell the dest that it's being piped to</span>
  <span class="s1">dest.emit(</span><span class="s2">'pipe'</span><span class="s1">, src);</span>

  <span class="s0">// start the flow if it hasn't been started already.</span>
  <span class="s3">if </span><span class="s1">(!state.flowing) {</span>
    <span class="s1">debug(</span><span class="s2">'pipe resume'</span><span class="s1">);</span>
    <span class="s1">src.resume();</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">dest;</span>
<span class="s1">};</span>
<span class="s3">function </span><span class="s1">pipeOnDrain(src) {</span>
  <span class="s3">return function </span><span class="s1">pipeOnDrainFunctionResult() {</span>
    <span class="s3">var </span><span class="s1">state = src._readableState;</span>
    <span class="s1">debug(</span><span class="s2">'pipeOnDrain'</span><span class="s1">, state.awaitDrain);</span>
    <span class="s3">if </span><span class="s1">(state.awaitDrain) state.awaitDrain--;</span>
    <span class="s3">if </span><span class="s1">(state.awaitDrain === </span><span class="s4">0 </span><span class="s1">&amp;&amp; EElistenerCount(src, </span><span class="s2">'data'</span><span class="s1">)) {</span>
      <span class="s1">state.flowing = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">flow(src);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">Readable.prototype.unpipe = </span><span class="s3">function </span><span class="s1">(dest) {</span>
  <span class="s3">var </span><span class="s1">state = </span><span class="s3">this</span><span class="s1">._readableState;</span>
  <span class="s3">var </span><span class="s1">unpipeInfo = {</span>
    <span class="s1">hasUnpiped: </span><span class="s3">false</span>
  <span class="s1">};</span>

  <span class="s0">// if we're not piping anywhere, then do nothing.</span>
  <span class="s3">if </span><span class="s1">(state.pipesCount === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return this</span><span class="s1">;</span>

  <span class="s0">// just one destination.  most common case.</span>
  <span class="s3">if </span><span class="s1">(state.pipesCount === </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s0">// passed in one, but it's not the right one.</span>
    <span class="s3">if </span><span class="s1">(dest &amp;&amp; dest !== state.pipes) </span><span class="s3">return this</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(!dest) dest = state.pipes;</span>

    <span class="s0">// got a match.</span>
    <span class="s1">state.pipes = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">state.pipesCount = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">state.flowing = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(dest) dest.emit(</span><span class="s2">'unpipe'</span><span class="s1">, </span><span class="s3">this</span><span class="s1">, unpipeInfo);</span>
    <span class="s3">return this</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// slow case. multiple pipe destinations.</span>

  <span class="s3">if </span><span class="s1">(!dest) {</span>
    <span class="s0">// remove all.</span>
    <span class="s3">var </span><span class="s1">dests = state.pipes;</span>
    <span class="s3">var </span><span class="s1">len = state.pipesCount;</span>
    <span class="s1">state.pipes = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">state.pipesCount = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">state.flowing = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; len; i++) dests[i].emit(</span><span class="s2">'unpipe'</span><span class="s1">, </span><span class="s3">this</span><span class="s1">, {</span>
      <span class="s1">hasUnpiped: </span><span class="s3">false</span>
    <span class="s1">});</span>
    <span class="s3">return this</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// try to find the right one.</span>
  <span class="s3">var </span><span class="s1">index = indexOf(state.pipes, dest);</span>
  <span class="s3">if </span><span class="s1">(index === -</span><span class="s4">1</span><span class="s1">) </span><span class="s3">return this</span><span class="s1">;</span>
  <span class="s1">state.pipes.splice(index, </span><span class="s4">1</span><span class="s1">);</span>
  <span class="s1">state.pipesCount -= </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(state.pipesCount === </span><span class="s4">1</span><span class="s1">) state.pipes = state.pipes[</span><span class="s4">0</span><span class="s1">];</span>
  <span class="s1">dest.emit(</span><span class="s2">'unpipe'</span><span class="s1">, </span><span class="s3">this</span><span class="s1">, unpipeInfo);</span>
  <span class="s3">return this</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s0">// set up data events if they are asked for</span>
<span class="s0">// Ensure readable listeners eventually get something</span>
<span class="s1">Readable.prototype.on = </span><span class="s3">function </span><span class="s1">(ev, fn) {</span>
  <span class="s3">var </span><span class="s1">res = Stream.prototype.on.call(</span><span class="s3">this</span><span class="s1">, ev, fn);</span>
  <span class="s3">var </span><span class="s1">state = </span><span class="s3">this</span><span class="s1">._readableState;</span>
  <span class="s3">if </span><span class="s1">(ev === </span><span class="s2">'data'</span><span class="s1">) {</span>
    <span class="s0">// update readableListening so that resume() may be a no-op</span>
    <span class="s0">// a few lines down. This is needed to support once('readable').</span>
    <span class="s1">state.readableListening = </span><span class="s3">this</span><span class="s1">.listenerCount(</span><span class="s2">'readable'</span><span class="s1">) &gt; </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s0">// Try start flowing on next tick if stream isn't explicitly paused</span>
    <span class="s3">if </span><span class="s1">(state.flowing !== </span><span class="s3">false</span><span class="s1">) </span><span class="s3">this</span><span class="s1">.resume();</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(ev === </span><span class="s2">'readable'</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(!state.endEmitted &amp;&amp; !state.readableListening) {</span>
      <span class="s1">state.readableListening = state.needReadable = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">state.flowing = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">state.emittedReadable = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">debug(</span><span class="s2">'on readable'</span><span class="s1">, state.length, state.reading);</span>
      <span class="s3">if </span><span class="s1">(state.length) {</span>
        <span class="s1">emitReadable(</span><span class="s3">this</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!state.reading) {</span>
        <span class="s1">process.nextTick(nReadingNextTick, </span><span class="s3">this</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">res;</span>
<span class="s1">};</span>
<span class="s1">Readable.prototype.addListener = Readable.prototype.on;</span>
<span class="s1">Readable.prototype.removeListener = </span><span class="s3">function </span><span class="s1">(ev, fn) {</span>
  <span class="s3">var </span><span class="s1">res = Stream.prototype.removeListener.call(</span><span class="s3">this</span><span class="s1">, ev, fn);</span>
  <span class="s3">if </span><span class="s1">(ev === </span><span class="s2">'readable'</span><span class="s1">) {</span>
    <span class="s0">// We need to check if there is someone still listening to</span>
    <span class="s0">// readable and reset the state. However this needs to happen</span>
    <span class="s0">// after readable has been emitted but before I/O (nextTick) to</span>
    <span class="s0">// support once('readable', fn) cycles. This means that calling</span>
    <span class="s0">// resume within the same tick will have no</span>
    <span class="s0">// effect.</span>
    <span class="s1">process.nextTick(updateReadableListening, </span><span class="s3">this</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">res;</span>
<span class="s1">};</span>
<span class="s1">Readable.prototype.removeAllListeners = </span><span class="s3">function </span><span class="s1">(ev) {</span>
  <span class="s3">var </span><span class="s1">res = Stream.prototype.removeAllListeners.apply(</span><span class="s3">this</span><span class="s1">, arguments);</span>
  <span class="s3">if </span><span class="s1">(ev === </span><span class="s2">'readable' </span><span class="s1">|| ev === undefined) {</span>
    <span class="s0">// We need to check if there is someone still listening to</span>
    <span class="s0">// readable and reset the state. However this needs to happen</span>
    <span class="s0">// after readable has been emitted but before I/O (nextTick) to</span>
    <span class="s0">// support once('readable', fn) cycles. This means that calling</span>
    <span class="s0">// resume within the same tick will have no</span>
    <span class="s0">// effect.</span>
    <span class="s1">process.nextTick(updateReadableListening, </span><span class="s3">this</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">res;</span>
<span class="s1">};</span>
<span class="s3">function </span><span class="s1">updateReadableListening(self) {</span>
  <span class="s3">var </span><span class="s1">state = self._readableState;</span>
  <span class="s1">state.readableListening = self.listenerCount(</span><span class="s2">'readable'</span><span class="s1">) &gt; </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(state.resumeScheduled &amp;&amp; !state.paused) {</span>
    <span class="s0">// flowing needs to be set to true now, otherwise</span>
    <span class="s0">// the upcoming resume will not flow.</span>
    <span class="s1">state.flowing = </span><span class="s3">true</span><span class="s1">;</span>

    <span class="s0">// crude way to check if we should resume</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(self.listenerCount(</span><span class="s2">'data'</span><span class="s1">) &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">self.resume();</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">nReadingNextTick(self) {</span>
  <span class="s1">debug(</span><span class="s2">'readable nexttick read 0'</span><span class="s1">);</span>
  <span class="s1">self.read(</span><span class="s4">0</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s0">// pause() and resume() are remnants of the legacy readable stream API</span>
<span class="s0">// If the user uses them, then switch into old mode.</span>
<span class="s1">Readable.prototype.resume = </span><span class="s3">function </span><span class="s1">() {</span>
  <span class="s3">var </span><span class="s1">state = </span><span class="s3">this</span><span class="s1">._readableState;</span>
  <span class="s3">if </span><span class="s1">(!state.flowing) {</span>
    <span class="s1">debug(</span><span class="s2">'resume'</span><span class="s1">);</span>
    <span class="s0">// we flow only if there is no one listening</span>
    <span class="s0">// for readable, but we still have to call</span>
    <span class="s0">// resume()</span>
    <span class="s1">state.flowing = !state.readableListening;</span>
    <span class="s1">resume(</span><span class="s3">this</span><span class="s1">, state);</span>
  <span class="s1">}</span>
  <span class="s1">state.paused = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">return this</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s3">function </span><span class="s1">resume(stream, state) {</span>
  <span class="s3">if </span><span class="s1">(!state.resumeScheduled) {</span>
    <span class="s1">state.resumeScheduled = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">process.nextTick(resume_, stream, state);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">resume_(stream, state) {</span>
  <span class="s1">debug(</span><span class="s2">'resume'</span><span class="s1">, state.reading);</span>
  <span class="s3">if </span><span class="s1">(!state.reading) {</span>
    <span class="s1">stream.read(</span><span class="s4">0</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">state.resumeScheduled = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">stream.emit(</span><span class="s2">'resume'</span><span class="s1">);</span>
  <span class="s1">flow(stream);</span>
  <span class="s3">if </span><span class="s1">(state.flowing &amp;&amp; !state.reading) stream.read(</span><span class="s4">0</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s1">Readable.prototype.pause = </span><span class="s3">function </span><span class="s1">() {</span>
  <span class="s1">debug(</span><span class="s2">'call pause flowing=%j'</span><span class="s1">, </span><span class="s3">this</span><span class="s1">._readableState.flowing);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._readableState.flowing !== </span><span class="s3">false</span><span class="s1">) {</span>
    <span class="s1">debug(</span><span class="s2">'pause'</span><span class="s1">);</span>
    <span class="s3">this</span><span class="s1">._readableState.flowing = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.emit(</span><span class="s2">'pause'</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">this</span><span class="s1">._readableState.paused = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s3">return this</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s3">function </span><span class="s1">flow(stream) {</span>
  <span class="s3">var </span><span class="s1">state = stream._readableState;</span>
  <span class="s1">debug(</span><span class="s2">'flow'</span><span class="s1">, state.flowing);</span>
  <span class="s3">while </span><span class="s1">(state.flowing &amp;&amp; stream.read() !== </span><span class="s3">null</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s0">// wrap an old-style stream as the async data source.</span>
<span class="s0">// This is *not* part of the readable stream interface.</span>
<span class="s0">// It is an ugly unfortunate mess of history.</span>
<span class="s1">Readable.prototype.wrap = </span><span class="s3">function </span><span class="s1">(stream) {</span>
  <span class="s3">var </span><span class="s1">_this = </span><span class="s3">this</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">state = </span><span class="s3">this</span><span class="s1">._readableState;</span>
  <span class="s3">var </span><span class="s1">paused = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">stream.on(</span><span class="s2">'end'</span><span class="s1">, </span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s1">debug(</span><span class="s2">'wrapped end'</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(state.decoder &amp;&amp; !state.ended) {</span>
      <span class="s3">var </span><span class="s1">chunk = state.decoder.end();</span>
      <span class="s3">if </span><span class="s1">(chunk &amp;&amp; chunk.length) _this.push(chunk);</span>
    <span class="s1">}</span>
    <span class="s1">_this.push(</span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">});</span>
  <span class="s1">stream.on(</span><span class="s2">'data'</span><span class="s1">, </span><span class="s3">function </span><span class="s1">(chunk) {</span>
    <span class="s1">debug(</span><span class="s2">'wrapped data'</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(state.decoder) chunk = state.decoder.write(chunk);</span>

    <span class="s0">// don't skip over falsy values in objectMode</span>
    <span class="s3">if </span><span class="s1">(state.objectMode &amp;&amp; (chunk === </span><span class="s3">null </span><span class="s1">|| chunk === undefined)) </span><span class="s3">return</span><span class="s1">;</span><span class="s3">else if </span><span class="s1">(!state.objectMode &amp;&amp; (!chunk || !chunk.length)) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">ret = _this.push(chunk);</span>
    <span class="s3">if </span><span class="s1">(!ret) {</span>
      <span class="s1">paused = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">stream.pause();</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s0">// proxy all the other methods.</span>
  <span class="s0">// important when wrapping filters and duplexes.</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i </span><span class="s3">in </span><span class="s1">stream) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">[i] === undefined &amp;&amp; </span><span class="s3">typeof </span><span class="s1">stream[i] === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">[i] = </span><span class="s3">function </span><span class="s1">methodWrap(method) {</span>
        <span class="s3">return function </span><span class="s1">methodWrapReturnFunction() {</span>
          <span class="s3">return </span><span class="s1">stream[method].apply(stream, arguments);</span>
        <span class="s1">};</span>
      <span class="s1">}(i);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// proxy certain important events.</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">n = </span><span class="s4">0</span><span class="s1">; n &lt; kProxyEvents.length; n++) {</span>
    <span class="s1">stream.on(kProxyEvents[n], </span><span class="s3">this</span><span class="s1">.emit.bind(</span><span class="s3">this</span><span class="s1">, kProxyEvents[n]));</span>
  <span class="s1">}</span>

  <span class="s0">// when we try to consume some more bytes, simply unpause the</span>
  <span class="s0">// underlying stream.</span>
  <span class="s3">this</span><span class="s1">._read = </span><span class="s3">function </span><span class="s1">(n) {</span>
    <span class="s1">debug(</span><span class="s2">'wrapped _read'</span><span class="s1">, n);</span>
    <span class="s3">if </span><span class="s1">(paused) {</span>
      <span class="s1">paused = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">stream.resume();</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s3">return this</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Symbol === </span><span class="s2">'function'</span><span class="s1">) {</span>
  <span class="s1">Readable.prototype[Symbol.asyncIterator] = </span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s3">if </span><span class="s1">(createReadableStreamAsyncIterator === undefined) {</span>
      <span class="s1">createReadableStreamAsyncIterator = require(</span><span class="s2">'./internal/streams/async_iterator'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">createReadableStreamAsyncIterator(</span><span class="s3">this</span><span class="s1">);</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">Object.defineProperty(Readable.prototype, </span><span class="s2">'readableHighWaterMark'</span><span class="s1">, {</span>
  <span class="s0">// making it explicit this property is not enumerable</span>
  <span class="s0">// because otherwise some prototype manipulation in</span>
  <span class="s0">// userland will fail</span>
  <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
  <span class="s1">get: </span><span class="s3">function </span><span class="s1">get() {</span>
    <span class="s3">return this</span><span class="s1">._readableState.highWaterMark;</span>
  <span class="s1">}</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(Readable.prototype, </span><span class="s2">'readableBuffer'</span><span class="s1">, {</span>
  <span class="s0">// making it explicit this property is not enumerable</span>
  <span class="s0">// because otherwise some prototype manipulation in</span>
  <span class="s0">// userland will fail</span>
  <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
  <span class="s1">get: </span><span class="s3">function </span><span class="s1">get() {</span>
    <span class="s3">return this</span><span class="s1">._readableState &amp;&amp; </span><span class="s3">this</span><span class="s1">._readableState.buffer;</span>
  <span class="s1">}</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(Readable.prototype, </span><span class="s2">'readableFlowing'</span><span class="s1">, {</span>
  <span class="s0">// making it explicit this property is not enumerable</span>
  <span class="s0">// because otherwise some prototype manipulation in</span>
  <span class="s0">// userland will fail</span>
  <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
  <span class="s1">get: </span><span class="s3">function </span><span class="s1">get() {</span>
    <span class="s3">return this</span><span class="s1">._readableState.flowing;</span>
  <span class="s1">},</span>
  <span class="s1">set: </span><span class="s3">function </span><span class="s1">set(state) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._readableState) {</span>
      <span class="s3">this</span><span class="s1">._readableState.flowing = state;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">});</span>

<span class="s0">// exposed for testing purposes only.</span>
<span class="s1">Readable._fromList = fromList;</span>
<span class="s1">Object.defineProperty(Readable.prototype, </span><span class="s2">'readableLength'</span><span class="s1">, {</span>
  <span class="s0">// making it explicit this property is not enumerable</span>
  <span class="s0">// because otherwise some prototype manipulation in</span>
  <span class="s0">// userland will fail</span>
  <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
  <span class="s1">get: </span><span class="s3">function </span><span class="s1">get() {</span>
    <span class="s3">return this</span><span class="s1">._readableState.length;</span>
  <span class="s1">}</span>
<span class="s1">});</span>

<span class="s0">// Pluck off n bytes from an array of buffers.</span>
<span class="s0">// Length is the combined lengths of all the buffers in the list.</span>
<span class="s0">// This function is designed to be inlinable, so please take care when making</span>
<span class="s0">// changes to the function body.</span>
<span class="s3">function </span><span class="s1">fromList(n, state) {</span>
  <span class="s0">// nothing buffered</span>
  <span class="s3">if </span><span class="s1">(state.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ret;</span>
  <span class="s3">if </span><span class="s1">(state.objectMode) ret = state.buffer.shift();</span><span class="s3">else if </span><span class="s1">(!n || n &gt;= state.length) {</span>
    <span class="s0">// read it all, truncate the list</span>
    <span class="s3">if </span><span class="s1">(state.decoder) ret = state.buffer.join(</span><span class="s2">''</span><span class="s1">);</span><span class="s3">else if </span><span class="s1">(state.buffer.length === </span><span class="s4">1</span><span class="s1">) ret = state.buffer.first();</span><span class="s3">else </span><span class="s1">ret = state.buffer.concat(state.length);</span>
    <span class="s1">state.buffer.clear();</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// read part of list</span>
    <span class="s1">ret = state.buffer.consume(n, state.decoder);</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">ret;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">endReadable(stream) {</span>
  <span class="s3">var </span><span class="s1">state = stream._readableState;</span>
  <span class="s1">debug(</span><span class="s2">'endReadable'</span><span class="s1">, state.endEmitted);</span>
  <span class="s3">if </span><span class="s1">(!state.endEmitted) {</span>
    <span class="s1">state.ended = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">process.nextTick(endReadableNT, state, stream);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">endReadableNT(state, stream) {</span>
  <span class="s1">debug(</span><span class="s2">'endReadableNT'</span><span class="s1">, state.endEmitted, state.length);</span>

  <span class="s0">// Check that we didn't get one last unshift.</span>
  <span class="s3">if </span><span class="s1">(!state.endEmitted &amp;&amp; state.length === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">state.endEmitted = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">stream.readable = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">stream.emit(</span><span class="s2">'end'</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(state.autoDestroy) {</span>
      <span class="s0">// In case of duplex streams we need a way to detect</span>
      <span class="s0">// if the writable side is ready for autoDestroy as well</span>
      <span class="s3">var </span><span class="s1">wState = stream._writableState;</span>
      <span class="s3">if </span><span class="s1">(!wState || wState.autoDestroy &amp;&amp; wState.finished) {</span>
        <span class="s1">stream.destroy();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Symbol === </span><span class="s2">'function'</span><span class="s1">) {</span>
  <span class="s1">Readable.from = </span><span class="s3">function </span><span class="s1">(iterable, opts) {</span>
    <span class="s3">if </span><span class="s1">(from === undefined) {</span>
      <span class="s1">from = require(</span><span class="s2">'./internal/streams/from'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">from(Readable, iterable, opts);</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">indexOf(xs, x) {</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, l = xs.length; i &lt; l; i++) {</span>
    <span class="s3">if </span><span class="s1">(xs[i] === x) </span><span class="s3">return </span><span class="s1">i;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span></pre>
</body>
</html>
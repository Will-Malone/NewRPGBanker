<html>
<head>
<title>NativeViewHierarchyManager.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #629755; font-weight: bold; font-style: italic;}
.s5 { color: #77b767; font-style: italic;}
.s6 { color: #6a8759;}
.s7 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
NativeViewHierarchyManager.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.uimanager</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.graphics.Matrix</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Rect</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.RectF</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.util.SparseArray</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.util.SparseBooleanArray</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.Menu</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.MenuItem</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.View</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.ViewGroup</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.ViewParent</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.widget.PopupMenu</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.logging.FLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.R</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.Callback</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.JSApplicationIllegalArgumentException</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactContext</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableArray</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.RetryableMountingLayerException</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.SoftAssertions</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.UiThreadUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.build.ReactBuildConfig</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.touch.JSResponderHandler</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.layoutanimation.LayoutAnimationController</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.layoutanimation.LayoutAnimationListener</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.systrace.Systrace</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.systrace.SystraceMessage</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.HashMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.HashSet</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Set</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">javax.annotation.concurrent.NotThreadSafe</span><span class="s2">;</span>

<span class="s3">/**</span>
 <span class="s3">* Delegate of {</span><span class="s4">@link </span><span class="s3">UIManagerModule} that owns the native view hierarchy and mapping between</span>
 <span class="s3">* native view names used in JS and corresponding instances of {</span><span class="s4">@link </span><span class="s3">ViewManager}. The {</span><span class="s4">@link</span>
 <span class="s3">* UIManagerModule} communicates with this class by it's public interface methods:</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">&lt;ul&gt;</span>
 <span class="s3">*   </span><span class="s5">&lt;li&gt;</span><span class="s3">{</span><span class="s4">@link </span><span class="s3">#updateProperties}</span>
 <span class="s3">*   </span><span class="s5">&lt;li&gt;</span><span class="s3">{</span><span class="s4">@link </span><span class="s3">#updateLayout}</span>
 <span class="s3">*   </span><span class="s5">&lt;li&gt;</span><span class="s3">{</span><span class="s4">@link </span><span class="s3">#createView}</span>
 <span class="s3">*   </span><span class="s5">&lt;li&gt;</span><span class="s3">{</span><span class="s4">@link </span><span class="s3">#manageChildren}</span>
 <span class="s3">* </span><span class="s5">&lt;/ul&gt;</span>
 <span class="s3">*</span>
 <span class="s3">* executing all the scheduled UI operations at the end of JS batch.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">NB: All native view management methods listed above must be called from the UI thread.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">The {</span><span class="s4">@link </span><span class="s3">ReactContext} instance that is passed to views that this manager creates differs</span>
 <span class="s3">* from the one that we pass as a constructor. Instead we wrap the provided instance of {</span><span class="s4">@link</span>
 <span class="s3">* ReactContext} in an instance of {</span><span class="s4">@link </span><span class="s3">ThemedReactContext} that additionally provide a correct</span>
 <span class="s3">* theme based on the root view for a view tree that we attach newly created view to. Therefore this</span>
 <span class="s3">* view manager will create a copy of {</span><span class="s4">@link </span><span class="s3">ThemedReactContext} that wraps the instance of {</span><span class="s4">@link</span>
 <span class="s3">* ReactContext} for each root view added to the manager (see {</span><span class="s4">@link </span><span class="s3">#addRootView}).</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">TODO(5483031): Only dispatch updates when shadow views have changed</span>
 <span class="s3">*/</span>
<span class="s1">@NotThreadSafe</span>
<span class="s2">public class </span><span class="s1">NativeViewHierarchyManager {</span>

  <span class="s2">private static final </span><span class="s1">String TAG = NativeViewHierarchyManager.</span><span class="s2">class</span><span class="s1">.getSimpleName()</span><span class="s2">;</span>
  <span class="s2">private final boolean </span><span class="s1">DEBUG_MODE = ReactBuildConfig.DEBUG &amp;&amp; </span><span class="s2">false;</span>

  <span class="s2">private final </span><span class="s1">SparseArray&lt;View&gt; mTagsToViews</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">SparseArray&lt;ViewManager&gt; mTagsToViewManagers</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">SparseBooleanArray mRootTags</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">ViewManagerRegistry mViewManagers</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">JSResponderHandler mJSResponderHandler = </span><span class="s2">new </span><span class="s1">JSResponderHandler()</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">RootViewManager mRootViewManager</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">LayoutAnimationController mLayoutAnimator = </span><span class="s2">new </span><span class="s1">LayoutAnimationController()</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">RectF mBoundingBox = </span><span class="s2">new </span><span class="s1">RectF()</span><span class="s2">;</span>

  <span class="s2">private boolean </span><span class="s1">mLayoutAnimationEnabled</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">PopupMenu mPopupMenu</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">HashMap&lt;Integer</span><span class="s2">, </span><span class="s1">Set&lt;Integer&gt;&gt; mPendingDeletionsForTag</span><span class="s2">;</span>

  <span class="s2">public </span><span class="s1">NativeViewHierarchyManager(ViewManagerRegistry viewManagers) {</span>
    <span class="s2">this</span><span class="s1">(viewManagers</span><span class="s2">, new </span><span class="s1">RootViewManager())</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">NativeViewHierarchyManager(ViewManagerRegistry viewManagers</span><span class="s2">, </span><span class="s1">RootViewManager manager) {</span>
    <span class="s1">mViewManagers = viewManagers</span><span class="s2">;</span>
    <span class="s1">mTagsToViews = </span><span class="s2">new </span><span class="s1">SparseArray&lt;&gt;()</span><span class="s2">;</span>
    <span class="s1">mTagsToViewManagers = </span><span class="s2">new </span><span class="s1">SparseArray&lt;&gt;()</span><span class="s2">;</span>
    <span class="s1">mRootTags = </span><span class="s2">new </span><span class="s1">SparseBooleanArray()</span><span class="s2">;</span>
    <span class="s1">mRootViewManager = manager</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public final synchronized </span><span class="s1">View resolveView(</span><span class="s2">int </span><span class="s1">tag) {</span>
    <span class="s1">View view = mTagsToViews.get(tag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(view == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
          <span class="s6">&quot;Trying to resolve view with tag &quot; </span><span class="s1">+ tag + </span><span class="s6">&quot; which doesn't exist&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">view</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public final synchronized </span><span class="s1">ViewManager resolveViewManager(</span><span class="s2">int </span><span class="s1">tag) {</span>
    <span class="s1">ViewManager viewManager = mTagsToViewManagers.get(tag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(viewManager == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
          <span class="s6">&quot;ViewManager for tag &quot; </span><span class="s1">+ tag + </span><span class="s6">&quot; could not be found.</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">viewManager</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setLayoutAnimationEnabled(</span><span class="s2">boolean </span><span class="s1">enabled) {</span>
    <span class="s1">mLayoutAnimationEnabled = enabled</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public synchronized void </span><span class="s1">updateInstanceHandle(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, long </span><span class="s1">instanceHandle) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">updateInstanceHandle(resolveView(tag)</span><span class="s2">, </span><span class="s1">instanceHandle)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(IllegalViewOperationException e) {</span>
      <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s6">&quot;Unable to update properties for view tag &quot; </span><span class="s1">+ tag</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public synchronized void </span><span class="s1">updateProperties(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">ReactStylesDiffMap props) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.d(TAG</span><span class="s2">, </span><span class="s6">&quot;updateProperties[%d]: %s&quot;</span><span class="s2">, </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">props.toString())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">ViewManager viewManager = resolveViewManager(tag)</span><span class="s2">;</span>
      <span class="s1">View viewToUpdate = resolveView(tag)</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(props != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">viewManager.updateProperties(viewToUpdate</span><span class="s2">, </span><span class="s1">props)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(IllegalViewOperationException e) {</span>
      <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s6">&quot;Unable to update properties for view tag &quot; </span><span class="s1">+ tag</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public synchronized void </span><span class="s1">updateViewExtraData(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">Object extraData) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.d(TAG</span><span class="s2">, </span><span class="s6">&quot;updateViewExtraData[%d]: %s&quot;</span><span class="s2">, </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">extraData.toString())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s1">ViewManager viewManager = resolveViewManager(tag)</span><span class="s2">;</span>
    <span class="s1">View viewToUpdate = resolveView(tag)</span><span class="s2">;</span>
    <span class="s1">viewManager.updateExtraData(viewToUpdate</span><span class="s2">, </span><span class="s1">extraData)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public synchronized void </span><span class="s1">updateLayout(</span>
      <span class="s2">int </span><span class="s1">parentTag</span><span class="s2">, int </span><span class="s1">tag</span><span class="s2">, int </span><span class="s1">x</span><span class="s2">, int </span><span class="s1">y</span><span class="s2">, int </span><span class="s1">width</span><span class="s2">, int </span><span class="s1">height) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.d(TAG</span><span class="s2">, </span><span class="s6">&quot;updateLayout[%d]-&gt;[%d]: %d %d %d %d&quot;</span><span class="s2">, </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">parentTag</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">SystraceMessage.beginSection(</span>
            <span class="s1">Systrace.TRACE_TAG_REACT_VIEW</span><span class="s2">, </span><span class="s6">&quot;NativeViewHierarchyManager_updateLayout&quot;</span><span class="s1">)</span>
        <span class="s1">.arg(</span><span class="s6">&quot;parentTag&quot;</span><span class="s2">, </span><span class="s1">parentTag)</span>
        <span class="s1">.arg(</span><span class="s6">&quot;tag&quot;</span><span class="s2">, </span><span class="s1">tag)</span>
        <span class="s1">.flush()</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">View viewToUpdate = resolveView(tag)</span><span class="s2">;</span>

      <span class="s0">// Even though we have exact dimensions, we still call measure because some platform views</span>
      <span class="s0">// (e.g.</span>
      <span class="s0">// Switch) assume that method will always be called before onLayout and onDraw. They use it to</span>
      <span class="s0">// calculate and cache information used in the draw pass. For most views, onMeasure can be</span>
      <span class="s0">// stubbed out to only call setMeasuredDimensions. For ViewGroups, onLayout should be stubbed</span>
      <span class="s0">// out to not recursively call layout on its children: React Native already handles doing</span>
      <span class="s0">// that.</span>
      <span class="s0">//</span>
      <span class="s0">// Also, note measure and layout need to be called *after* all View properties have been</span>
      <span class="s0">// updated</span>
      <span class="s0">// because of caching and calculation that may occur in onMeasure and onLayout. Layout</span>
      <span class="s0">// operations should also follow the native view hierarchy and go top to bottom for</span>
      <span class="s0">// consistency</span>
      <span class="s0">// with standard layout passes (some views may depend on this).</span>

      <span class="s1">viewToUpdate.measure(</span>
          <span class="s1">View.MeasureSpec.makeMeasureSpec(width</span><span class="s2">, </span><span class="s1">View.MeasureSpec.EXACTLY)</span><span class="s2">,</span>
          <span class="s1">View.MeasureSpec.makeMeasureSpec(height</span><span class="s2">, </span><span class="s1">View.MeasureSpec.EXACTLY))</span><span class="s2">;</span>

      <span class="s0">// We update the layout of the ReactRootView when there is a change in the layout of its</span>
      <span class="s0">// child.</span>
      <span class="s0">// This is required to re-measure the size of the native View container (usually a</span>
      <span class="s0">// FrameLayout) that is configured with layout_height = WRAP_CONTENT or layout_width =</span>
      <span class="s0">// WRAP_CONTENT</span>
      <span class="s0">//</span>
      <span class="s0">// This code is going to be executed ONLY when there is a change in the size of the Root</span>
      <span class="s0">// View defined in the js side. Changes in the layout of inner views will not trigger an</span>
      <span class="s0">// update</span>
      <span class="s0">// on the layout of the Root View.</span>
      <span class="s1">ViewParent parent = viewToUpdate.getParent()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(parent </span><span class="s2">instanceof </span><span class="s1">RootView) {</span>
        <span class="s1">parent.requestLayout()</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">// Check if the parent of the view has to layout the view, or the child has to lay itself out.</span>
      <span class="s2">if </span><span class="s1">(!mRootTags.get(parentTag)) {</span>
        <span class="s1">ViewManager parentViewManager = mTagsToViewManagers.get(parentTag)</span><span class="s2">;</span>
        <span class="s1">IViewManagerWithChildren parentViewManagerWithChildren</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(parentViewManager </span><span class="s2">instanceof </span><span class="s1">IViewManagerWithChildren) {</span>
          <span class="s1">parentViewManagerWithChildren = (IViewManagerWithChildren) parentViewManager</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
              <span class="s6">&quot;Trying to use view with tag &quot;</span>
                  <span class="s1">+ parentTag</span>
                  <span class="s1">+ </span><span class="s6">&quot; as a parent, but its Manager doesn't implement IViewManagerWithChildren&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(parentViewManagerWithChildren != </span><span class="s2">null</span>
            <span class="s1">&amp;&amp; !parentViewManagerWithChildren.needsCustomLayoutForChildren()) {</span>
          <span class="s1">updateLayout(viewToUpdate</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">updateLayout(viewToUpdate</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">Systrace.endSection(Systrace.TRACE_TAG_REACT_VIEW)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">updateInstanceHandle(View viewToUpdate</span><span class="s2">, long </span><span class="s1">instanceHandle) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">viewToUpdate.setTag(R.id.view_tag_instance_handle</span><span class="s2">, </span><span class="s1">instanceHandle)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Nullable</span>
  <span class="s2">public long </span><span class="s1">getInstanceHandle(</span><span class="s2">int </span><span class="s1">reactTag) {</span>
    <span class="s1">View view = mTagsToViews.get(reactTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(view == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span><span class="s6">&quot;Unable to find view for tag: &quot; </span><span class="s1">+ reactTag)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">Long instanceHandle = (Long) view.getTag(R.id.view_tag_instance_handle)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(instanceHandle == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span><span class="s6">&quot;Unable to find instanceHandle for tag: &quot; </span><span class="s1">+ reactTag)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">instanceHandle</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">updateLayout(View viewToUpdate</span><span class="s2">, int </span><span class="s1">x</span><span class="s2">, int </span><span class="s1">y</span><span class="s2">, int </span><span class="s1">width</span><span class="s2">, int </span><span class="s1">height) {</span>
    <span class="s2">if </span><span class="s1">(mLayoutAnimationEnabled &amp;&amp; mLayoutAnimator.shouldAnimateLayout(viewToUpdate)) {</span>
      <span class="s1">mLayoutAnimator.applyLayoutUpdate(viewToUpdate</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">viewToUpdate.layout(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">x + width</span><span class="s2">, </span><span class="s1">y + height)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public synchronized void </span><span class="s1">createView(</span>
      <span class="s1">ThemedReactContext themedContext</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">tag</span><span class="s2">,</span>
      <span class="s1">String className</span><span class="s2">,</span>
      <span class="s1">@Nullable ReactStylesDiffMap initialProps) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.d(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s6">&quot;createView[%d]: %s %s&quot;</span><span class="s2">,</span>
          <span class="s1">tag</span><span class="s2">,</span>
          <span class="s1">className</span><span class="s2">,</span>
          <span class="s1">(initialProps != </span><span class="s2">null </span><span class="s1">? initialProps.toString() : </span><span class="s6">&quot;&lt;null&gt;&quot;</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">SystraceMessage.beginSection(</span>
            <span class="s1">Systrace.TRACE_TAG_REACT_VIEW</span><span class="s2">, </span><span class="s6">&quot;NativeViewHierarchyManager_createView&quot;</span><span class="s1">)</span>
        <span class="s1">.arg(</span><span class="s6">&quot;tag&quot;</span><span class="s2">, </span><span class="s1">tag)</span>
        <span class="s1">.arg(</span><span class="s6">&quot;className&quot;</span><span class="s2">, </span><span class="s1">className)</span>
        <span class="s1">.flush()</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">ViewManager viewManager = mViewManagers.get(className)</span><span class="s2">;</span>

      <span class="s1">View view =</span>
          <span class="s1">viewManager.createView(tag</span><span class="s2">, </span><span class="s1">themedContext</span><span class="s2">, </span><span class="s1">initialProps</span><span class="s2">, null, </span><span class="s1">mJSResponderHandler)</span><span class="s2">;</span>
      <span class="s1">mTagsToViews.put(tag</span><span class="s2">, </span><span class="s1">view)</span><span class="s2">;</span>
      <span class="s1">mTagsToViewManagers.put(tag</span><span class="s2">, </span><span class="s1">viewManager)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">Systrace.endSection(Systrace.TRACE_TAG_REACT_VIEW)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private static </span><span class="s1">String constructManageChildrenErrorMessage(</span>
      <span class="s1">ViewGroup viewToManage</span><span class="s2">,</span>
      <span class="s1">ViewGroupManager viewManager</span><span class="s2">,</span>
      <span class="s1">@Nullable </span><span class="s2">int</span><span class="s1">[] indicesToRemove</span><span class="s2">,</span>
      <span class="s1">@Nullable ViewAtIndex[] viewsToAdd</span><span class="s2">,</span>
      <span class="s1">@Nullable </span><span class="s2">int</span><span class="s1">[] tagsToDelete) {</span>
    <span class="s1">StringBuilder stringBuilder = </span><span class="s2">new </span><span class="s1">StringBuilder()</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">null </span><span class="s1">!= viewToManage) {</span>
      <span class="s1">stringBuilder.append(</span>
          <span class="s6">&quot;View tag:&quot;</span>
              <span class="s1">+ viewToManage.getId()</span>
              <span class="s1">+ </span><span class="s6">&quot; View Type:&quot;</span>
              <span class="s1">+ viewToManage.getClass().toString()</span>
              <span class="s1">+ </span><span class="s6">&quot;</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">stringBuilder.append(</span><span class="s6">&quot;  children(&quot; </span><span class="s1">+ viewManager.getChildCount(viewToManage) + </span><span class="s6">&quot;): [</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">index = </span><span class="s7">0</span><span class="s2">; </span><span class="s1">viewManager.getChildAt(viewToManage</span><span class="s2">, </span><span class="s1">index) != </span><span class="s2">null; </span><span class="s1">index += </span><span class="s7">16</span><span class="s1">) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">innerOffset = </span><span class="s7">0</span><span class="s2">;</span>
            <span class="s1">viewManager.getChildAt(viewToManage</span><span class="s2">, </span><span class="s1">index + innerOffset) != </span><span class="s2">null </span><span class="s1">&amp;&amp; innerOffset &lt; </span><span class="s7">16</span><span class="s2">;</span>
            <span class="s1">innerOffset++) {</span>
          <span class="s1">stringBuilder.append(</span>
              <span class="s1">viewManager.getChildAt(viewToManage</span><span class="s2">, </span><span class="s1">index + innerOffset).getId() + </span><span class="s6">&quot;,&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">stringBuilder.append(</span><span class="s6">&quot;</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">stringBuilder.append(</span><span class="s6">&quot; ],</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(indicesToRemove != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">stringBuilder.append(</span><span class="s6">&quot;  indicesToRemove(&quot; </span><span class="s1">+ indicesToRemove.length + </span><span class="s6">&quot;): [</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">index = </span><span class="s7">0</span><span class="s2">; </span><span class="s1">index &lt; indicesToRemove.length</span><span class="s2">; </span><span class="s1">index += </span><span class="s7">16</span><span class="s1">) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">innerOffset = </span><span class="s7">0</span><span class="s2">;</span>
            <span class="s1">((index + innerOffset) &lt; indicesToRemove.length) &amp;&amp; innerOffset &lt; </span><span class="s7">16</span><span class="s2">;</span>
            <span class="s1">innerOffset++) {</span>
          <span class="s1">stringBuilder.append(indicesToRemove[index + innerOffset] + </span><span class="s6">&quot;,&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">stringBuilder.append(</span><span class="s6">&quot;</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">stringBuilder.append(</span><span class="s6">&quot; ],</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(viewsToAdd != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">stringBuilder.append(</span><span class="s6">&quot;  viewsToAdd(&quot; </span><span class="s1">+ viewsToAdd.length + </span><span class="s6">&quot;): [</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">index = </span><span class="s7">0</span><span class="s2">; </span><span class="s1">index &lt; viewsToAdd.length</span><span class="s2">; </span><span class="s1">index += </span><span class="s7">16</span><span class="s1">) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">innerOffset = </span><span class="s7">0</span><span class="s2">;</span>
            <span class="s1">((index + innerOffset) &lt; viewsToAdd.length) &amp;&amp; innerOffset &lt; </span><span class="s7">16</span><span class="s2">;</span>
            <span class="s1">innerOffset++) {</span>
          <span class="s1">stringBuilder.append(</span>
              <span class="s6">&quot;[&quot;</span>
                  <span class="s1">+ viewsToAdd[index + innerOffset].mIndex</span>
                  <span class="s1">+ </span><span class="s6">&quot;,&quot;</span>
                  <span class="s1">+ viewsToAdd[index + innerOffset].mTag</span>
                  <span class="s1">+ </span><span class="s6">&quot;],&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">stringBuilder.append(</span><span class="s6">&quot;</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">stringBuilder.append(</span><span class="s6">&quot; ],</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(tagsToDelete != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">stringBuilder.append(</span><span class="s6">&quot;  tagsToDelete(&quot; </span><span class="s1">+ tagsToDelete.length + </span><span class="s6">&quot;): [</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">index = </span><span class="s7">0</span><span class="s2">; </span><span class="s1">index &lt; tagsToDelete.length</span><span class="s2">; </span><span class="s1">index += </span><span class="s7">16</span><span class="s1">) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">innerOffset = </span><span class="s7">0</span><span class="s2">;</span>
            <span class="s1">((index + innerOffset) &lt; tagsToDelete.length) &amp;&amp; innerOffset &lt; </span><span class="s7">16</span><span class="s2">;</span>
            <span class="s1">innerOffset++) {</span>
          <span class="s1">stringBuilder.append(tagsToDelete[index + innerOffset] + </span><span class="s6">&quot;,&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">stringBuilder.append(</span><span class="s6">&quot;</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">stringBuilder.append(</span><span class="s6">&quot; ]</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">stringBuilder.toString()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private </span><span class="s1">Set&lt;Integer&gt; getPendingDeletionsForTag(</span><span class="s2">int </span><span class="s1">tag) {</span>
    <span class="s2">if </span><span class="s1">(mPendingDeletionsForTag == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mPendingDeletionsForTag = </span><span class="s2">new </span><span class="s1">HashMap&lt;&gt;()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!mPendingDeletionsForTag.containsKey(tag)) {</span>
      <span class="s1">mPendingDeletionsForTag.put(tag</span><span class="s2">, new </span><span class="s1">HashSet&lt;Integer&gt;())</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">mPendingDeletionsForTag.get(tag)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">tag react tag of the node we want to manage</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">indicesToRemove ordered (asc) list of indices at which view should be removed</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">viewsToAdd ordered (asc based on mIndex property) list of tag-index pairs that represent</span>
   <span class="s3">*     a view which should be added at the specified index</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">tagsToDelete list of tags corresponding to views that should be removed</span>
   <span class="s3">*/</span>
  <span class="s2">public synchronized void </span><span class="s1">manageChildren(</span>
      <span class="s2">final int </span><span class="s1">tag</span><span class="s2">,</span>
      <span class="s1">@Nullable </span><span class="s2">int</span><span class="s1">[] indicesToRemove</span><span class="s2">,</span>
      <span class="s1">@Nullable ViewAtIndex[] viewsToAdd</span><span class="s2">,</span>
      <span class="s1">@Nullable </span><span class="s2">int</span><span class="s1">[] tagsToDelete) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.d(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s6">&quot;createView[%d]: %s %s %s&quot;</span><span class="s2">,</span>
          <span class="s1">tag</span><span class="s2">,</span>
          <span class="s1">(indicesToRemove != </span><span class="s2">null </span><span class="s1">? indicesToRemove.toString() : </span><span class="s6">&quot;&lt;null&gt;&quot;</span><span class="s1">)</span><span class="s2">,</span>
          <span class="s1">(viewsToAdd != </span><span class="s2">null </span><span class="s1">? viewsToAdd.toString() : </span><span class="s6">&quot;&lt;null&gt;&quot;</span><span class="s1">)</span><span class="s2">,</span>
          <span class="s1">(tagsToDelete != </span><span class="s2">null </span><span class="s1">? tagsToDelete.toString() : </span><span class="s6">&quot;&lt;null&gt;&quot;</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s2">final </span><span class="s1">Set&lt;Integer&gt; pendingDeletionTags = getPendingDeletionsForTag(tag)</span><span class="s2">;</span>
    <span class="s2">final </span><span class="s1">ViewGroup viewToManage = (ViewGroup) mTagsToViews.get(tag)</span><span class="s2">;</span>
    <span class="s2">final </span><span class="s1">ViewGroupManager viewManager = (ViewGroupManager) resolveViewManager(tag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(viewToManage == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
          <span class="s6">&quot;Trying to manageChildren view with tag &quot;</span>
              <span class="s1">+ tag</span>
              <span class="s1">+ </span><span class="s6">&quot; which doesn't exist</span><span class="s2">\n </span><span class="s6">detail: &quot;</span>
              <span class="s1">+ constructManageChildrenErrorMessage(</span>
                  <span class="s1">viewToManage</span><span class="s2">, </span><span class="s1">viewManager</span><span class="s2">, </span><span class="s1">indicesToRemove</span><span class="s2">, </span><span class="s1">viewsToAdd</span><span class="s2">, </span><span class="s1">tagsToDelete))</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">int </span><span class="s1">lastIndexToRemove = viewManager.getChildCount(viewToManage)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(indicesToRemove != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = indicesToRemove.length - </span><span class="s7">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s7">0</span><span class="s2">; </span><span class="s1">i--) {</span>
        <span class="s2">int </span><span class="s1">indexToRemove = indicesToRemove[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(indexToRemove &lt; </span><span class="s7">0</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
              <span class="s6">&quot;Trying to remove a negative view index:&quot;</span>
                  <span class="s1">+ indexToRemove</span>
                  <span class="s1">+ </span><span class="s6">&quot; view tag: &quot;</span>
                  <span class="s1">+ tag</span>
                  <span class="s1">+ </span><span class="s6">&quot;</span><span class="s2">\n </span><span class="s6">detail: &quot;</span>
                  <span class="s1">+ constructManageChildrenErrorMessage(</span>
                      <span class="s1">viewToManage</span><span class="s2">, </span><span class="s1">viewManager</span><span class="s2">, </span><span class="s1">indicesToRemove</span><span class="s2">, </span><span class="s1">viewsToAdd</span><span class="s2">, </span><span class="s1">tagsToDelete))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(viewManager.getChildAt(viewToManage</span><span class="s2">, </span><span class="s1">indexToRemove) == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(mRootTags.get(tag) &amp;&amp; viewManager.getChildCount(viewToManage) == </span><span class="s7">0</span><span class="s1">) {</span>
            <span class="s0">// This root node has already been removed (likely due to a threading issue caused by</span>
            <span class="s0">// async js execution). Ignore this root removal.</span>
            <span class="s2">return;</span>
          <span class="s1">}</span>
          <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
              <span class="s6">&quot;Trying to remove a view index above child &quot;</span>
                  <span class="s1">+ </span><span class="s6">&quot;count &quot;</span>
                  <span class="s1">+ indexToRemove</span>
                  <span class="s1">+ </span><span class="s6">&quot; view tag: &quot;</span>
                  <span class="s1">+ tag</span>
                  <span class="s1">+ </span><span class="s6">&quot;</span><span class="s2">\n </span><span class="s6">detail: &quot;</span>
                  <span class="s1">+ constructManageChildrenErrorMessage(</span>
                      <span class="s1">viewToManage</span><span class="s2">, </span><span class="s1">viewManager</span><span class="s2">, </span><span class="s1">indicesToRemove</span><span class="s2">, </span><span class="s1">viewsToAdd</span><span class="s2">, </span><span class="s1">tagsToDelete))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(indexToRemove &gt;= lastIndexToRemove) {</span>
          <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
              <span class="s6">&quot;Trying to remove an out of order view index:&quot;</span>
                  <span class="s1">+ indexToRemove</span>
                  <span class="s1">+ </span><span class="s6">&quot; view tag: &quot;</span>
                  <span class="s1">+ tag</span>
                  <span class="s1">+ </span><span class="s6">&quot;</span><span class="s2">\n </span><span class="s6">detail: &quot;</span>
                  <span class="s1">+ constructManageChildrenErrorMessage(</span>
                      <span class="s1">viewToManage</span><span class="s2">, </span><span class="s1">viewManager</span><span class="s2">, </span><span class="s1">indicesToRemove</span><span class="s2">, </span><span class="s1">viewsToAdd</span><span class="s2">, </span><span class="s1">tagsToDelete))</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s1">View viewToRemove = viewManager.getChildAt(viewToManage</span><span class="s2">, </span><span class="s1">indexToRemove)</span><span class="s2">;</span>

        <span class="s2">if </span><span class="s1">(mLayoutAnimationEnabled</span>
            <span class="s1">&amp;&amp; mLayoutAnimator.shouldAnimateLayout(viewToRemove)</span>
            <span class="s1">&amp;&amp; arrayContains(tagsToDelete</span><span class="s2">, </span><span class="s1">viewToRemove.getId())) {</span>
          <span class="s0">// The view will be removed and dropped by the 'delete' layout animation</span>
          <span class="s0">// instead, so do nothing</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">viewManager.removeViewAt(viewToManage</span><span class="s2">, </span><span class="s1">indexToRemove)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s1">lastIndexToRemove = indexToRemove</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(tagsToDelete != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s7">0</span><span class="s2">; </span><span class="s1">i &lt; tagsToDelete.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">int </span><span class="s1">tagToDelete = tagsToDelete[i]</span><span class="s2">;</span>
        <span class="s2">final </span><span class="s1">View viewToDestroy = mTagsToViews.get(tagToDelete)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(viewToDestroy == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
              <span class="s6">&quot;Trying to destroy unknown view tag: &quot;</span>
                  <span class="s1">+ tagToDelete</span>
                  <span class="s1">+ </span><span class="s6">&quot;</span><span class="s2">\n </span><span class="s6">detail: &quot;</span>
                  <span class="s1">+ constructManageChildrenErrorMessage(</span>
                      <span class="s1">viewToManage</span><span class="s2">, </span><span class="s1">viewManager</span><span class="s2">, </span><span class="s1">indicesToRemove</span><span class="s2">, </span><span class="s1">viewsToAdd</span><span class="s2">, </span><span class="s1">tagsToDelete))</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(mLayoutAnimationEnabled &amp;&amp; mLayoutAnimator.shouldAnimateLayout(viewToDestroy)) {</span>
          <span class="s1">pendingDeletionTags.add(tagToDelete)</span><span class="s2">;</span>
          <span class="s1">mLayoutAnimator.deleteView(</span>
              <span class="s1">viewToDestroy</span><span class="s2">,</span>
              <span class="s2">new </span><span class="s1">LayoutAnimationListener() {</span>
                <span class="s1">@Override</span>
                <span class="s2">public void </span><span class="s1">onAnimationEnd() {</span>
                  <span class="s0">// This should be called only on the UI thread, because</span>
                  <span class="s0">// onAnimationEnd is called (indirectly) by Android View Animation.</span>
                  <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

                  <span class="s1">viewManager.removeView(viewToManage</span><span class="s2">, </span><span class="s1">viewToDestroy)</span><span class="s2">;</span>
                  <span class="s1">dropView(viewToDestroy)</span><span class="s2">;</span>
                  <span class="s1">pendingDeletionTags.remove(viewToDestroy.getId())</span><span class="s2">;</span>
                  <span class="s2">if </span><span class="s1">(pendingDeletionTags.isEmpty()) {</span>
                    <span class="s1">mPendingDeletionsForTag.remove(tag)</span><span class="s2">;</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
              <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">dropView(viewToDestroy)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(viewsToAdd != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s7">0</span><span class="s2">; </span><span class="s1">i &lt; viewsToAdd.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">ViewAtIndex viewAtIndex = viewsToAdd[i]</span><span class="s2">;</span>
        <span class="s1">View viewToAdd = mTagsToViews.get(viewAtIndex.mTag)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(viewToAdd == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
              <span class="s6">&quot;Trying to add unknown view tag: &quot;</span>
                  <span class="s1">+ viewAtIndex.mTag</span>
                  <span class="s1">+ </span><span class="s6">&quot;</span><span class="s2">\n </span><span class="s6">detail: &quot;</span>
                  <span class="s1">+ constructManageChildrenErrorMessage(</span>
                      <span class="s1">viewToManage</span><span class="s2">, </span><span class="s1">viewManager</span><span class="s2">, </span><span class="s1">indicesToRemove</span><span class="s2">, </span><span class="s1">viewsToAdd</span><span class="s2">, </span><span class="s1">tagsToDelete))</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">int </span><span class="s1">normalizedIndex = viewAtIndex.mIndex</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!pendingDeletionTags.isEmpty()) {</span>
          <span class="s1">normalizedIndex = </span><span class="s7">0</span><span class="s2">;</span>
          <span class="s2">int </span><span class="s1">counter = </span><span class="s7">0</span><span class="s2">;</span>
          <span class="s2">while </span><span class="s1">(normalizedIndex &lt; viewToManage.getChildCount()) {</span>
            <span class="s2">if </span><span class="s1">(counter == viewAtIndex.mIndex) {</span>
              <span class="s2">break;</span>
            <span class="s1">}</span>
            <span class="s1">View v = viewToManage.getChildAt(normalizedIndex)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!pendingDeletionTags.contains(v.getId())) {</span>
              <span class="s1">counter++</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">normalizedIndex++</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">viewManager.addView(viewToManage</span><span class="s2">, </span><span class="s1">viewToAdd</span><span class="s2">, </span><span class="s1">normalizedIndex)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(pendingDeletionTags.isEmpty()) {</span>
      <span class="s1">mPendingDeletionsForTag.remove(tag)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private boolean </span><span class="s1">arrayContains(@Nullable </span><span class="s2">int</span><span class="s1">[] array</span><span class="s2">, int </span><span class="s1">ele) {</span>
    <span class="s2">if </span><span class="s1">(array == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">curEle : array) {</span>
      <span class="s2">if </span><span class="s1">(curEle == ele) {</span>
        <span class="s2">return true;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Simplified version of constructManageChildrenErrorMessage that only deals with adding children</span>
   <span class="s3">* views</span>
   <span class="s3">*/</span>
  <span class="s2">private static </span><span class="s1">String constructSetChildrenErrorMessage(</span>
      <span class="s1">ViewGroup viewToManage</span><span class="s2">, </span><span class="s1">ViewGroupManager viewManager</span><span class="s2">, </span><span class="s1">ReadableArray childrenTags) {</span>
    <span class="s1">ViewAtIndex[] viewsToAdd = </span><span class="s2">new </span><span class="s1">ViewAtIndex[childrenTags.size()]</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s7">0</span><span class="s2">; </span><span class="s1">i &lt; childrenTags.size()</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">viewsToAdd[i] = </span><span class="s2">new </span><span class="s1">ViewAtIndex(childrenTags.getInt(i)</span><span class="s2">, </span><span class="s1">i)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">constructManageChildrenErrorMessage(viewToManage</span><span class="s2">, </span><span class="s1">viewManager</span><span class="s2">, null, </span><span class="s1">viewsToAdd</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Simplified version of manageChildren that only deals with adding children views */</span>
  <span class="s2">public synchronized void </span><span class="s1">setChildren(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">ReadableArray childrenTags) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.d(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s6">&quot;setChildren[%d]: %s&quot;</span><span class="s2">,</span>
          <span class="s1">tag</span><span class="s2">,</span>
          <span class="s1">(childrenTags != </span><span class="s2">null </span><span class="s1">? childrenTags.toString() : </span><span class="s6">&quot;&lt;null&gt;&quot;</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">ViewGroup viewToManage = (ViewGroup) mTagsToViews.get(tag)</span><span class="s2">;</span>
    <span class="s1">ViewGroupManager viewManager = (ViewGroupManager) resolveViewManager(tag)</span><span class="s2">;</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s7">0</span><span class="s2">; </span><span class="s1">i &lt; childrenTags.size()</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">View viewToAdd = mTagsToViews.get(childrenTags.getInt(i))</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(viewToAdd == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
            <span class="s6">&quot;Trying to add unknown view tag: &quot;</span>
                <span class="s1">+ childrenTags.getInt(i)</span>
                <span class="s1">+ </span><span class="s6">&quot;</span><span class="s2">\n </span><span class="s6">detail: &quot;</span>
                <span class="s1">+ constructSetChildrenErrorMessage(viewToManage</span><span class="s2">, </span><span class="s1">viewManager</span><span class="s2">, </span><span class="s1">childrenTags))</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">viewManager.addView(viewToManage</span><span class="s2">, </span><span class="s1">viewToAdd</span><span class="s2">, </span><span class="s1">i)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** See {</span><span class="s4">@link </span><span class="s3">UIManagerModule#addRootView}. */</span>
  <span class="s2">public synchronized void </span><span class="s1">addRootView(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">View view) {</span>
    <span class="s1">addRootViewGroup(tag</span><span class="s2">, </span><span class="s1">view)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">protected final synchronized void </span><span class="s1">addRootViewGroup(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">View view) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.d(TAG</span><span class="s2">, </span><span class="s6">&quot;addRootViewGroup[%d]: %s&quot;</span><span class="s2">, </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">(view != </span><span class="s2">null </span><span class="s1">? view.toString() : </span><span class="s6">&quot;&lt;null&gt;&quot;</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(view.getId() != View.NO_ID) {</span>
      <span class="s1">FLog.e(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s6">&quot;Trying to add a root view with an explicit id (&quot;</span>
              <span class="s1">+ view.getId()</span>
              <span class="s1">+ </span><span class="s6">&quot;) already &quot;</span>
              <span class="s1">+ </span><span class="s6">&quot;set. React Native uses the id field to track react tags and will overwrite this field. &quot;</span>
              <span class="s1">+ </span><span class="s6">&quot;If that is fine, explicitly overwrite the id field to View.NO_ID before calling &quot;</span>
              <span class="s1">+ </span><span class="s6">&quot;addRootView.&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">mTagsToViews.put(tag</span><span class="s2">, </span><span class="s1">view)</span><span class="s2">;</span>
    <span class="s1">mTagsToViewManagers.put(tag</span><span class="s2">, </span><span class="s1">mRootViewManager)</span><span class="s2">;</span>
    <span class="s1">mRootTags.put(tag</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">view.setId(tag)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Releases all references to given native View. */</span>
  <span class="s2">protected synchronized void </span><span class="s1">dropView(View view) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.d(TAG</span><span class="s2">, </span><span class="s6">&quot;dropView[%d]&quot;</span><span class="s2">, </span><span class="s1">(view != </span><span class="s2">null </span><span class="s1">? view.getId() : -</span><span class="s7">1</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(view == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Ignore this drop operation when view is null.</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(mTagsToViewManagers.get(view.getId()) == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// This view has already been dropped (likely due to a threading issue caused by async js</span>
      <span class="s0">// execution). Ignore this drop operation.</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!mRootTags.get(view.getId())) {</span>
      <span class="s0">// For non-root views we notify viewmanager with {@link ViewManager#onDropInstance}</span>
      <span class="s1">resolveViewManager(view.getId()).onDropViewInstance(view)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">ViewManager viewManager = mTagsToViewManagers.get(view.getId())</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(view </span><span class="s2">instanceof </span><span class="s1">ViewGroup &amp;&amp; viewManager </span><span class="s2">instanceof </span><span class="s1">ViewGroupManager) {</span>
      <span class="s1">ViewGroup viewGroup = (ViewGroup) view</span><span class="s2">;</span>
      <span class="s1">ViewGroupManager viewGroupManager = (ViewGroupManager) viewManager</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = viewGroupManager.getChildCount(viewGroup) - </span><span class="s7">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s7">0</span><span class="s2">; </span><span class="s1">i--) {</span>
        <span class="s1">View child = viewGroupManager.getChildAt(viewGroup</span><span class="s2">, </span><span class="s1">i)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(child == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s6">&quot;Unable to drop null child view&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(mTagsToViews.get(child.getId()) != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">dropView(child)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">viewGroupManager.removeAllViews(viewGroup)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mTagsToViews.remove(view.getId())</span><span class="s2">;</span>
    <span class="s1">mTagsToViewManagers.remove(view.getId())</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public synchronized void </span><span class="s1">removeRootView(</span><span class="s2">int </span><span class="s1">rootViewTag) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.d(TAG</span><span class="s2">, </span><span class="s6">&quot;removeRootView[%d]&quot;</span><span class="s2">, </span><span class="s1">rootViewTag)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!mRootTags.get(rootViewTag)) {</span>
      <span class="s1">SoftAssertions.assertUnreachable(</span>
          <span class="s6">&quot;View with tag &quot; </span><span class="s1">+ rootViewTag + </span><span class="s6">&quot; is not registered as a root view&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">View rootView = mTagsToViews.get(rootViewTag)</span><span class="s2">;</span>
    <span class="s1">dropView(rootView)</span><span class="s2">;</span>
    <span class="s1">mRootTags.delete(rootViewTag)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Return root view num</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">The num of root view</span>
   <span class="s3">*/</span>
  <span class="s2">public synchronized int </span><span class="s1">getRootViewNum() {</span>
    <span class="s2">return </span><span class="s1">mRootTags.size()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Returns true on success, false on failure. If successful, after calling, output buffer will be</span>
   <span class="s3">* {x, y, width, height}.</span>
   <span class="s3">*/</span>
  <span class="s2">public synchronized void </span><span class="s1">measure(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, int</span><span class="s1">[] outputBuffer) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.d(TAG</span><span class="s2">, </span><span class="s6">&quot;measure[%d]&quot;</span><span class="s2">, </span><span class="s1">tag)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">View v = mTagsToViews.get(tag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(v == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">NoSuchNativeViewException(</span><span class="s6">&quot;No native view for &quot; </span><span class="s1">+ tag + </span><span class="s6">&quot; currently exists&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">View rootView = (View) RootViewUtil.getRootView(v)</span><span class="s2">;</span>
    <span class="s0">// It is possible that the RootView can't be found because this view is no longer on the screen</span>
    <span class="s0">// and has been removed by clipping</span>
    <span class="s2">if </span><span class="s1">(rootView == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">NoSuchNativeViewException(</span><span class="s6">&quot;Native view &quot; </span><span class="s1">+ tag + </span><span class="s6">&quot; is no longer on screen&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">computeBoundingBox(rootView</span><span class="s2">, </span><span class="s1">outputBuffer)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">rootX = outputBuffer[</span><span class="s7">0</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">rootY = outputBuffer[</span><span class="s7">1</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">computeBoundingBox(v</span><span class="s2">, </span><span class="s1">outputBuffer)</span><span class="s2">;</span>
    <span class="s1">outputBuffer[</span><span class="s7">0</span><span class="s1">] -= rootX</span><span class="s2">;</span>
    <span class="s1">outputBuffer[</span><span class="s7">1</span><span class="s1">] -= rootY</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">computeBoundingBox(View view</span><span class="s2">, int</span><span class="s1">[] outputBuffer) {</span>
    <span class="s1">mBoundingBox.set(</span><span class="s7">0</span><span class="s2">, </span><span class="s7">0</span><span class="s2">, </span><span class="s1">view.getWidth()</span><span class="s2">, </span><span class="s1">view.getHeight())</span><span class="s2">;</span>
    <span class="s1">mapRectFromViewToWindowCoords(view</span><span class="s2">, </span><span class="s1">mBoundingBox)</span><span class="s2">;</span>

    <span class="s1">outputBuffer[</span><span class="s7">0</span><span class="s1">] = Math.round(mBoundingBox.left)</span><span class="s2">;</span>
    <span class="s1">outputBuffer[</span><span class="s7">1</span><span class="s1">] = Math.round(mBoundingBox.top)</span><span class="s2">;</span>
    <span class="s1">outputBuffer[</span><span class="s7">2</span><span class="s1">] = Math.round(mBoundingBox.right - mBoundingBox.left)</span><span class="s2">;</span>
    <span class="s1">outputBuffer[</span><span class="s7">3</span><span class="s1">] = Math.round(mBoundingBox.bottom - mBoundingBox.top)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">mapRectFromViewToWindowCoords(View view</span><span class="s2">, </span><span class="s1">RectF rect) {</span>
    <span class="s1">Matrix matrix = view.getMatrix()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!matrix.isIdentity()) {</span>
      <span class="s1">matrix.mapRect(rect)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">rect.offset(view.getLeft()</span><span class="s2">, </span><span class="s1">view.getTop())</span><span class="s2">;</span>

    <span class="s1">ViewParent parent = view.getParent()</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(parent </span><span class="s2">instanceof </span><span class="s1">View) {</span>
      <span class="s1">View parentView = (View) parent</span><span class="s2">;</span>

      <span class="s1">rect.offset(-parentView.getScrollX()</span><span class="s2">, </span><span class="s1">-parentView.getScrollY())</span><span class="s2">;</span>

      <span class="s1">matrix = parentView.getMatrix()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!matrix.isIdentity()) {</span>
        <span class="s1">matrix.mapRect(rect)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">rect.offset(parentView.getLeft()</span><span class="s2">, </span><span class="s1">parentView.getTop())</span><span class="s2">;</span>

      <span class="s1">parent = parentView.getParent()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Returns the coordinates of a view relative to the window (not just the RootView which is what</span>
   <span class="s3">* measure will return)</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">tag - the tag for the view</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">outputBuffer - output buffer that contains [x,y,width,height] of the view in coordinates</span>
   <span class="s3">*     relative to the device window</span>
   <span class="s3">*/</span>
  <span class="s2">public synchronized void </span><span class="s1">measureInWindow(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, int</span><span class="s1">[] outputBuffer) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.d(TAG</span><span class="s2">, </span><span class="s6">&quot;measureInWindow[%d]&quot;</span><span class="s2">, </span><span class="s1">tag)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">View v = mTagsToViews.get(tag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(v == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">NoSuchNativeViewException(</span><span class="s6">&quot;No native view for &quot; </span><span class="s1">+ tag + </span><span class="s6">&quot; currently exists&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">v.getLocationOnScreen(outputBuffer)</span><span class="s2">;</span>

    <span class="s0">// we need to subtract visibleWindowCoords - to subtract possible window insets, split screen or</span>
    <span class="s0">// multi window</span>
    <span class="s1">Rect visibleWindowFrame = </span><span class="s2">new </span><span class="s1">Rect()</span><span class="s2">;</span>
    <span class="s1">v.getWindowVisibleDisplayFrame(visibleWindowFrame)</span><span class="s2">;</span>
    <span class="s1">outputBuffer[</span><span class="s7">0</span><span class="s1">] = outputBuffer[</span><span class="s7">0</span><span class="s1">] - visibleWindowFrame.left</span><span class="s2">;</span>
    <span class="s1">outputBuffer[</span><span class="s7">1</span><span class="s1">] = outputBuffer[</span><span class="s7">1</span><span class="s1">] - visibleWindowFrame.top</span><span class="s2">;</span>

    <span class="s0">// outputBuffer[0,1] already contain what we want</span>
    <span class="s1">outputBuffer[</span><span class="s7">2</span><span class="s1">] = v.getWidth()</span><span class="s2">;</span>
    <span class="s1">outputBuffer[</span><span class="s7">3</span><span class="s1">] = v.getHeight()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public synchronized int </span><span class="s1">findTargetTagForTouch(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, float </span><span class="s1">touchX</span><span class="s2">, float </span><span class="s1">touchY) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.d(TAG</span><span class="s2">, </span><span class="s6">&quot;findTargetTagForTouch[%d]: %f %f&quot;</span><span class="s2">, </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">touchX</span><span class="s2">, </span><span class="s1">touchY)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">View view = mTagsToViews.get(reactTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(view == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">JSApplicationIllegalArgumentException(</span><span class="s6">&quot;Could not find view with tag &quot; </span><span class="s1">+ reactTag)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">TouchTargetHelper.findTargetTagForTouch(touchX</span><span class="s2">, </span><span class="s1">touchY</span><span class="s2">, </span><span class="s1">(ViewGroup) view)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public synchronized void </span><span class="s1">setJSResponder(</span>
      <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, int </span><span class="s1">initialReactTag</span><span class="s2">, boolean </span><span class="s1">blockNativeResponder) {</span>
    <span class="s2">if </span><span class="s1">(!blockNativeResponder) {</span>
      <span class="s1">mJSResponderHandler.setJSResponder(initialReactTag</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">View view = mTagsToViews.get(reactTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(initialReactTag != reactTag &amp;&amp; view </span><span class="s2">instanceof </span><span class="s1">ViewParent) {</span>
      <span class="s0">// In this case, initialReactTag corresponds to a virtual/layout-only View, and we already</span>
      <span class="s0">// have a parent of that View in reactTag, so we can use it.</span>
      <span class="s1">mJSResponderHandler.setJSResponder(initialReactTag</span><span class="s2">, </span><span class="s1">(ViewParent) view)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mRootTags.get(reactTag)) {</span>
      <span class="s1">SoftAssertions.assertUnreachable(</span>
          <span class="s6">&quot;Cannot block native responder on &quot; </span><span class="s1">+ reactTag + </span><span class="s6">&quot; that is a root view&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mJSResponderHandler.setJSResponder(initialReactTag</span><span class="s2">, </span><span class="s1">view.getParent())</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">clearJSResponder() {</span>
    <span class="s1">mJSResponderHandler.clearJSResponder()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">void </span><span class="s1">configureLayoutAnimation(</span><span class="s2">final </span><span class="s1">ReadableMap config</span><span class="s2">, final </span><span class="s1">Callback onAnimationComplete) {</span>
    <span class="s1">mLayoutAnimator.initializeFromConfig(config</span><span class="s2">, </span><span class="s1">onAnimationComplete)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">void </span><span class="s1">clearLayoutAnimation() {</span>
    <span class="s1">mLayoutAnimator.reset()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Deprecated</span>
  <span class="s2">public synchronized void </span><span class="s1">dispatchCommand(</span>
      <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, int </span><span class="s1">commandId</span><span class="s2">, </span><span class="s1">@Nullable ReadableArray args) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.d(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s6">&quot;dispatchCommand[%d]: %d %s&quot;</span><span class="s2">,</span>
          <span class="s1">reactTag</span><span class="s2">,</span>
          <span class="s1">commandId</span><span class="s2">,</span>
          <span class="s1">(args != </span><span class="s2">null </span><span class="s1">? args.toString() : </span><span class="s6">&quot;&lt;null&gt;&quot;</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">View view = mTagsToViews.get(reactTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(view == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">RetryableMountingLayerException(</span>
          <span class="s6">&quot;Trying to send command to a non-existing view with tag [&quot;</span>
              <span class="s1">+ reactTag</span>
              <span class="s1">+ </span><span class="s6">&quot;] and command &quot;</span>
              <span class="s1">+ commandId)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">ViewManager viewManager = resolveViewManager(reactTag)</span><span class="s2">;</span>
    <span class="s1">viewManager.receiveCommand(view</span><span class="s2">, </span><span class="s1">commandId</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public synchronized void </span><span class="s1">dispatchCommand(</span>
      <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">String commandId</span><span class="s2">, </span><span class="s1">@Nullable ReadableArray args) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.d(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s6">&quot;dispatchCommand[%d]: %s %s&quot;</span><span class="s2">,</span>
          <span class="s1">reactTag</span><span class="s2">,</span>
          <span class="s1">commandId</span><span class="s2">,</span>
          <span class="s1">(args != </span><span class="s2">null </span><span class="s1">? args.toString() : </span><span class="s6">&quot;&lt;null&gt;&quot;</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">View view = mTagsToViews.get(reactTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(view == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">RetryableMountingLayerException(</span>
          <span class="s6">&quot;Trying to send command to a non-existing view with tag [&quot;</span>
              <span class="s1">+ reactTag</span>
              <span class="s1">+ </span><span class="s6">&quot;] and command &quot;</span>
              <span class="s1">+ commandId)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">ViewManager viewManager = resolveViewManager(reactTag)</span><span class="s2">;</span>
    <span class="s1">ViewManagerDelegate delegate = viewManager.getDelegate()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(delegate != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">delegate.receiveCommand(view</span><span class="s2">, </span><span class="s1">commandId</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">viewManager.receiveCommand(view</span><span class="s2">, </span><span class="s1">commandId</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Show a {</span><span class="s4">@link </span><span class="s3">PopupMenu}.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">reactTag the tag of the anchor view (the PopupMenu is displayed next to this view); this</span>
   <span class="s3">*     needs to be the tag of a native view (shadow views can not be anchors)</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">items the menu items as an array of strings</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">success will be called with the position of the selected item as the first argument, or</span>
   <span class="s3">*     no arguments if the menu is dismissed</span>
   <span class="s3">*/</span>
  <span class="s2">public synchronized void </span><span class="s1">showPopupMenu(</span>
      <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">ReadableArray items</span><span class="s2">, </span><span class="s1">Callback success</span><span class="s2">, </span><span class="s1">Callback error) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">View anchor = mTagsToViews.get(reactTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(anchor == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">error.invoke(</span><span class="s6">&quot;Can't display popup. Could not find view with tag &quot; </span><span class="s1">+ reactTag)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">mPopupMenu = </span><span class="s2">new </span><span class="s1">PopupMenu(getReactContextForView(reactTag)</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>

    <span class="s1">Menu menu = mPopupMenu.getMenu()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s7">0</span><span class="s2">; </span><span class="s1">i &lt; items.size()</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">menu.add(Menu.NONE</span><span class="s2">, </span><span class="s1">Menu.NONE</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">items.getString(i))</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">PopupMenuCallbackHandler handler = </span><span class="s2">new </span><span class="s1">PopupMenuCallbackHandler(success)</span><span class="s2">;</span>
    <span class="s1">mPopupMenu.setOnMenuItemClickListener(handler)</span><span class="s2">;</span>
    <span class="s1">mPopupMenu.setOnDismissListener(handler)</span><span class="s2">;</span>

    <span class="s1">mPopupMenu.show()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Dismiss the last opened PopupMenu {</span><span class="s4">@link </span><span class="s3">PopupMenu}. */</span>
  <span class="s2">public void </span><span class="s1">dismissPopupMenu() {</span>
    <span class="s2">if </span><span class="s1">(mPopupMenu != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mPopupMenu.dismiss()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private static class </span><span class="s1">PopupMenuCallbackHandler</span>
      <span class="s2">implements </span><span class="s1">PopupMenu.OnMenuItemClickListener</span><span class="s2">, </span><span class="s1">PopupMenu.OnDismissListener {</span>

    <span class="s2">final </span><span class="s1">Callback mSuccess</span><span class="s2">;</span>
    <span class="s2">boolean </span><span class="s1">mConsumed = </span><span class="s2">false;</span>

    <span class="s2">private </span><span class="s1">PopupMenuCallbackHandler(Callback success) {</span>
      <span class="s1">mSuccess = success</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s2">public void </span><span class="s1">onDismiss(PopupMenu menu) {</span>
      <span class="s2">if </span><span class="s1">(!mConsumed) {</span>
        <span class="s1">mSuccess.invoke(UIManagerModuleConstants.ACTION_DISMISSED)</span><span class="s2">;</span>
        <span class="s1">mConsumed = </span><span class="s2">true;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s2">public boolean </span><span class="s1">onMenuItemClick(MenuItem item) {</span>
      <span class="s2">if </span><span class="s1">(!mConsumed) {</span>
        <span class="s1">mSuccess.invoke(UIManagerModuleConstants.ACTION_ITEM_SELECTED</span><span class="s2">, </span><span class="s1">item.getOrder())</span><span class="s2">;</span>
        <span class="s1">mConsumed = </span><span class="s2">true;</span>
        <span class="s2">return true;</span>
      <span class="s1">}</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">Themed React context for view with a given {</span><span class="s4">@param </span><span class="s3">reactTag} - it gets the context</span>
   <span class="s3">*     directly from the view using {</span><span class="s4">@link </span><span class="s3">View#getContext}.</span>
   <span class="s3">*/</span>
  <span class="s2">private </span><span class="s1">ThemedReactContext getReactContextForView(</span><span class="s2">int </span><span class="s1">reactTag) {</span>
    <span class="s1">View view = mTagsToViews.get(reactTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(view == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">JSApplicationIllegalArgumentException(</span><span class="s6">&quot;Could not find view with tag &quot; </span><span class="s1">+ reactTag)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">(ThemedReactContext) view.getContext()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">sendAccessibilityEvent(</span><span class="s2">int </span><span class="s1">tag</span><span class="s2">, int </span><span class="s1">eventType) {</span>
    <span class="s1">View view = mTagsToViews.get(tag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(view == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">JSApplicationIllegalArgumentException(</span><span class="s6">&quot;Could not find view with tag &quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">view.sendAccessibilityEvent(eventType)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
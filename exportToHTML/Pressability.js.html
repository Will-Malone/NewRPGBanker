<html>
<head>
<title>Pressability.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Pressability.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 * @flow strict-local 
 * @format 
 */</span>

<span class="s1">import type {HostComponent} from </span><span class="s2">'../Renderer/shims/ReactNativeTypes'</span><span class="s1">;</span>
<span class="s1">import type {</span>
  <span class="s1">BlurEvent,</span>
  <span class="s1">FocusEvent,</span>
  <span class="s1">MouseEvent,</span>
  <span class="s1">PressEvent,</span>
<span class="s1">} from </span><span class="s2">'../Types/CoreEventTypes'</span><span class="s1">;</span>

<span class="s1">import SoundManager from </span><span class="s2">'../Components/Sound/SoundManager'</span><span class="s1">;</span>
<span class="s1">import ReactNativeFeatureFlags from </span><span class="s2">'../ReactNative/ReactNativeFeatureFlags'</span><span class="s1">;</span>
<span class="s1">import UIManager from </span><span class="s2">'../ReactNative/UIManager'</span><span class="s1">;</span>
<span class="s1">import {type RectOrSize, normalizeRect} from </span><span class="s2">'../StyleSheet/Rect'</span><span class="s1">;</span>
<span class="s1">import {type PointerEvent} from </span><span class="s2">'../Types/CoreEventTypes'</span><span class="s1">;</span>
<span class="s1">import Platform from </span><span class="s2">'../Utilities/Platform'</span><span class="s1">;</span>
<span class="s1">import {isHoverEnabled} from </span><span class="s2">'./HoverState'</span><span class="s1">;</span>
<span class="s1">import PressabilityPerformanceEventEmitter from </span><span class="s2">'./PressabilityPerformanceEventEmitter.js'</span><span class="s1">;</span>
<span class="s1">import {type PressabilityTouchSignal as TouchSignal} from </span><span class="s2">'./PressabilityTypes.js'</span><span class="s1">;</span>
<span class="s1">import invariant from </span><span class="s2">'invariant'</span><span class="s1">;</span>
<span class="s1">import * as React from </span><span class="s2">'react'</span><span class="s1">;</span>

<span class="s1">export type PressabilityConfig = $ReadOnly&lt;{|</span>
  <span class="s0">/** 
   * Whether a press gesture can be interrupted by a parent gesture such as a 
   * scroll event. Defaults to true. 
   */</span>
  <span class="s1">cancelable?: ?boolean,</span>

  <span class="s0">/** 
   * Whether to disable initialization of the press gesture. 
   */</span>
  <span class="s1">disabled?: ?boolean,</span>

  <span class="s0">/** 
   * Amount to extend the `VisualRect` by to create `HitRect`. 
   */</span>
  <span class="s1">hitSlop?: ?RectOrSize,</span>

  <span class="s0">/** 
   * Amount to extend the `HitRect` by to create `PressRect`. 
   */</span>
  <span class="s1">pressRectOffset?: ?RectOrSize,</span>

  <span class="s0">/** 
   * Whether to disable the systemm sound when `onPress` fires on Android. 
   **/</span>
  <span class="s1">android_disableSound?: ?boolean,</span>

  <span class="s0">/** 
   * Duration to wait after hover in before calling `onHoverIn`. 
   */</span>
  <span class="s1">delayHoverIn?: ?number,</span>

  <span class="s0">/** 
   * Duration to wait after hover out before calling `onHoverOut`. 
   */</span>
  <span class="s1">delayHoverOut?: ?number,</span>

  <span class="s0">/** 
   * Duration (in addition to `delayPressIn`) after which a press gesture is 
   * considered a long press gesture. Defaults to 500 (milliseconds). 
   */</span>
  <span class="s1">delayLongPress?: ?number,</span>

  <span class="s0">/** 
   * Duration to wait after press down before calling `onPressIn`. 
   */</span>
  <span class="s1">delayPressIn?: ?number,</span>

  <span class="s0">/** 
   * Duration to wait after letting up before calling `onPressOut`. 
   */</span>
  <span class="s1">delayPressOut?: ?number,</span>

  <span class="s0">/** 
   * Minimum duration to wait between calling `onPressIn` and `onPressOut`. 
   */</span>
  <span class="s1">minPressDuration?: ?number,</span>

  <span class="s0">/** 
   * Called after the element loses focus. 
   */</span>
  <span class="s1">onBlur?: ?(event: BlurEvent) =&gt; mixed,</span>

  <span class="s0">/** 
   * Called after the element is focused. 
   */</span>
  <span class="s1">onFocus?: ?(event: FocusEvent) =&gt; mixed,</span>

  <span class="s0">/** 
   * Called when the hover is activated to provide visual feedback. 
   */</span>
  <span class="s1">onHoverIn?: ?(event: MouseEvent) =&gt; mixed,</span>

  <span class="s0">/** 
   * Called when the hover is deactivated to undo visual feedback. 
   */</span>
  <span class="s1">onHoverOut?: ?(event: MouseEvent) =&gt; mixed,</span>

  <span class="s0">/** 
   * Called when a long press gesture has been triggered. 
   */</span>
  <span class="s1">onLongPress?: ?(event: PressEvent) =&gt; mixed,</span>

  <span class="s0">/** 
   * Called when a press gesture has been triggered. 
   */</span>
  <span class="s1">onPress?: ?(event: PressEvent) =&gt; mixed,</span>

  <span class="s0">/** 
   * Called when the press is activated to provide visual feedback. 
   */</span>
  <span class="s1">onPressIn?: ?(event: PressEvent) =&gt; mixed,</span>

  <span class="s0">/** 
   * Called when the press location moves. (This should rarely be used.) 
   */</span>
  <span class="s1">onPressMove?: ?(event: PressEvent) =&gt; mixed,</span>

  <span class="s0">/** 
   * Called when the press is deactivated to undo visual feedback. 
   */</span>
  <span class="s1">onPressOut?: ?(event: PressEvent) =&gt; mixed,</span>

  <span class="s0">/** 
   * Returns whether a long press gesture should cancel the press gesture. 
   * Defaults to true. 
   */</span>
  <span class="s1">onLongPressShouldCancelPress_DEPRECATED?: ?() =&gt; boolean,</span>

  <span class="s0">/** 
   * If `cancelable` is set, this will be ignored. 
   * 
   * Returns whether to yield to a lock termination request (e.g. if a native 
   * scroll gesture attempts to steal the responder lock). 
   */</span>
  <span class="s1">onResponderTerminationRequest_DEPRECATED?: ?() =&gt; boolean,</span>

  <span class="s0">/** 
   * If `disabled` is set, this will be ignored. 
   * 
   * Returns whether to start a press gesture. 
   * 
   * @deprecated 
   */</span>
  <span class="s1">onStartShouldSetResponder_DEPRECATED?: ?() =&gt; boolean,</span>
<span class="s1">|}&gt;;</span>

<span class="s1">export type EventHandlers = $ReadOnly&lt;{|</span>
  <span class="s1">onBlur: (event: BlurEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">onClick: (event: PressEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">onFocus: (event: FocusEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">onMouseEnter?: (event: MouseEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">onMouseLeave?: (event: MouseEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">onPointerEnter?: (event: PointerEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">onPointerLeave?: (event: PointerEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">onResponderGrant: (event: PressEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">onResponderMove: (event: PressEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">onResponderRelease: (event: PressEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">onResponderTerminate: (event: PressEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">onResponderTerminationRequest: () =&gt; boolean,</span>
  <span class="s1">onStartShouldSetResponder: () =&gt; boolean,</span>
<span class="s1">|}&gt;;</span>

<span class="s1">type TouchState =</span>
  <span class="s1">| </span><span class="s2">'NOT_RESPONDER'</span>
  <span class="s1">| </span><span class="s2">'RESPONDER_INACTIVE_PRESS_IN'</span>
  <span class="s1">| </span><span class="s2">'RESPONDER_INACTIVE_PRESS_OUT'</span>
  <span class="s1">| </span><span class="s2">'RESPONDER_ACTIVE_PRESS_IN'</span>
  <span class="s1">| </span><span class="s2">'RESPONDER_ACTIVE_PRESS_OUT'</span>
  <span class="s1">| </span><span class="s2">'RESPONDER_ACTIVE_LONG_PRESS_IN'</span>
  <span class="s1">| </span><span class="s2">'RESPONDER_ACTIVE_LONG_PRESS_OUT'</span>
  <span class="s1">| </span><span class="s2">'ERROR'</span><span class="s1">;</span>

<span class="s1">const Transitions = Object.freeze({</span>
  <span class="s1">NOT_RESPONDER: {</span>
    <span class="s1">DELAY: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_GRANT: </span><span class="s2">'RESPONDER_INACTIVE_PRESS_IN'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_RELEASE: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_TERMINATED: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
    <span class="s1">ENTER_PRESS_RECT: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
    <span class="s1">LEAVE_PRESS_RECT: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
    <span class="s1">LONG_PRESS_DETECTED: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
  <span class="s1">},</span>
  <span class="s1">RESPONDER_INACTIVE_PRESS_IN: {</span>
    <span class="s1">DELAY: </span><span class="s2">'RESPONDER_ACTIVE_PRESS_IN'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_GRANT: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_RELEASE: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_TERMINATED: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">ENTER_PRESS_RECT: </span><span class="s2">'RESPONDER_INACTIVE_PRESS_IN'</span><span class="s1">,</span>
    <span class="s1">LEAVE_PRESS_RECT: </span><span class="s2">'RESPONDER_INACTIVE_PRESS_OUT'</span><span class="s1">,</span>
    <span class="s1">LONG_PRESS_DETECTED: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
  <span class="s1">},</span>
  <span class="s1">RESPONDER_INACTIVE_PRESS_OUT: {</span>
    <span class="s1">DELAY: </span><span class="s2">'RESPONDER_ACTIVE_PRESS_OUT'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_GRANT: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_RELEASE: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_TERMINATED: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">ENTER_PRESS_RECT: </span><span class="s2">'RESPONDER_INACTIVE_PRESS_IN'</span><span class="s1">,</span>
    <span class="s1">LEAVE_PRESS_RECT: </span><span class="s2">'RESPONDER_INACTIVE_PRESS_OUT'</span><span class="s1">,</span>
    <span class="s1">LONG_PRESS_DETECTED: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
  <span class="s1">},</span>
  <span class="s1">RESPONDER_ACTIVE_PRESS_IN: {</span>
    <span class="s1">DELAY: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_GRANT: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_RELEASE: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_TERMINATED: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">ENTER_PRESS_RECT: </span><span class="s2">'RESPONDER_ACTIVE_PRESS_IN'</span><span class="s1">,</span>
    <span class="s1">LEAVE_PRESS_RECT: </span><span class="s2">'RESPONDER_ACTIVE_PRESS_OUT'</span><span class="s1">,</span>
    <span class="s1">LONG_PRESS_DETECTED: </span><span class="s2">'RESPONDER_ACTIVE_LONG_PRESS_IN'</span><span class="s1">,</span>
  <span class="s1">},</span>
  <span class="s1">RESPONDER_ACTIVE_PRESS_OUT: {</span>
    <span class="s1">DELAY: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_GRANT: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_RELEASE: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_TERMINATED: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">ENTER_PRESS_RECT: </span><span class="s2">'RESPONDER_ACTIVE_PRESS_IN'</span><span class="s1">,</span>
    <span class="s1">LEAVE_PRESS_RECT: </span><span class="s2">'RESPONDER_ACTIVE_PRESS_OUT'</span><span class="s1">,</span>
    <span class="s1">LONG_PRESS_DETECTED: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
  <span class="s1">},</span>
  <span class="s1">RESPONDER_ACTIVE_LONG_PRESS_IN: {</span>
    <span class="s1">DELAY: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_GRANT: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_RELEASE: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_TERMINATED: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">ENTER_PRESS_RECT: </span><span class="s2">'RESPONDER_ACTIVE_LONG_PRESS_IN'</span><span class="s1">,</span>
    <span class="s1">LEAVE_PRESS_RECT: </span><span class="s2">'RESPONDER_ACTIVE_LONG_PRESS_OUT'</span><span class="s1">,</span>
    <span class="s1">LONG_PRESS_DETECTED: </span><span class="s2">'RESPONDER_ACTIVE_LONG_PRESS_IN'</span><span class="s1">,</span>
  <span class="s1">},</span>
  <span class="s1">RESPONDER_ACTIVE_LONG_PRESS_OUT: {</span>
    <span class="s1">DELAY: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_GRANT: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_RELEASE: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_TERMINATED: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">ENTER_PRESS_RECT: </span><span class="s2">'RESPONDER_ACTIVE_LONG_PRESS_IN'</span><span class="s1">,</span>
    <span class="s1">LEAVE_PRESS_RECT: </span><span class="s2">'RESPONDER_ACTIVE_LONG_PRESS_OUT'</span><span class="s1">,</span>
    <span class="s1">LONG_PRESS_DETECTED: </span><span class="s2">'ERROR'</span><span class="s1">,</span>
  <span class="s1">},</span>
  <span class="s1">ERROR: {</span>
    <span class="s1">DELAY: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_GRANT: </span><span class="s2">'RESPONDER_INACTIVE_PRESS_IN'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_RELEASE: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">RESPONDER_TERMINATED: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">ENTER_PRESS_RECT: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">LEAVE_PRESS_RECT: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
    <span class="s1">LONG_PRESS_DETECTED: </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">,</span>
  <span class="s1">},</span>
<span class="s1">});</span>

<span class="s1">const isActiveSignal = (signal: TouchState) =&gt;</span>
  <span class="s1">signal === </span><span class="s2">'RESPONDER_ACTIVE_PRESS_IN' </span><span class="s1">||</span>
  <span class="s1">signal === </span><span class="s2">'RESPONDER_ACTIVE_LONG_PRESS_IN'</span><span class="s1">;</span>

<span class="s1">const isActivationSignal = (signal: TouchState) =&gt;</span>
  <span class="s1">signal === </span><span class="s2">'RESPONDER_ACTIVE_PRESS_OUT' </span><span class="s1">||</span>
  <span class="s1">signal === </span><span class="s2">'RESPONDER_ACTIVE_PRESS_IN'</span><span class="s1">;</span>

<span class="s1">const isPressInSignal = (signal: TouchState) =&gt;</span>
  <span class="s1">signal === </span><span class="s2">'RESPONDER_INACTIVE_PRESS_IN' </span><span class="s1">||</span>
  <span class="s1">signal === </span><span class="s2">'RESPONDER_ACTIVE_PRESS_IN' </span><span class="s1">||</span>
  <span class="s1">signal === </span><span class="s2">'RESPONDER_ACTIVE_LONG_PRESS_IN'</span><span class="s1">;</span>

<span class="s1">const isTerminalSignal = (signal: TouchSignal) =&gt;</span>
  <span class="s1">signal === </span><span class="s2">'RESPONDER_TERMINATED' </span><span class="s1">|| signal === </span><span class="s2">'RESPONDER_RELEASE'</span><span class="s1">;</span>

<span class="s1">const DEFAULT_LONG_PRESS_DELAY_MS = </span><span class="s4">500</span><span class="s1">;</span>
<span class="s1">const DEFAULT_PRESS_RECT_OFFSETS = {</span>
  <span class="s1">bottom: </span><span class="s4">30</span><span class="s1">,</span>
  <span class="s1">left: </span><span class="s4">20</span><span class="s1">,</span>
  <span class="s1">right: </span><span class="s4">20</span><span class="s1">,</span>
  <span class="s1">top: </span><span class="s4">20</span><span class="s1">,</span>
<span class="s1">};</span>
<span class="s1">const DEFAULT_MIN_PRESS_DURATION = </span><span class="s4">130</span><span class="s1">;</span>

<span class="s1">const DEFAULT_LONG_PRESS_DEACTIVATION_DISTANCE = </span><span class="s4">10</span><span class="s1">;</span>
<span class="s1">let longPressDeactivationDistance = DEFAULT_LONG_PRESS_DEACTIVATION_DISTANCE;</span>
<span class="s0">/** 
 * Pressability implements press handling capabilities. 
 * 
 * =========================== Pressability Tutorial =========================== 
 * 
 * The `Pressability` class helps you create press interactions by analyzing the 
 * geometry of elements and observing when another responder (e.g. ScrollView) 
 * has stolen the touch lock. It offers hooks for your component to provide 
 * interaction feedback to the user: 
 * 
 * - When a press has activated (e.g. highlight an element) 
 * - When a press has deactivated (e.g. un-highlight an element) 
 * - When a press sould trigger an action, meaning it activated and deactivated 
 *   while within the geometry of the element without the lock being stolen. 
 * 
 * A high quality interaction isn't as simple as you might think. There should 
 * be a slight delay before activation. Moving your finger beyond an element's 
 * bounds should trigger deactivation, but moving the same finger back within an 
 * element's bounds should trigger reactivation. 
 * 
 * In order to use `Pressability`, do the following: 
 * 
 * 1. Instantiate `Pressability` and store it on your component's state. 
 * 
 *    state = { 
 *      pressability: new Pressability({ 
 *        // ... 
 *      }), 
 *    }; 
 * 
 * 2. Choose the rendered component who should collect the press events. On that 
 *    element, spread `pressability.getEventHandlers()` into its props. 
 * 
 *    return ( 
 *      &lt;View {...this.state.pressability.getEventHandlers()} /&gt; 
 *    ); 
 * 
 * 3. Reset `Pressability` when your component unmounts. 
 * 
 *    componentWillUnmount() { 
 *      this.state.pressability.reset(); 
 *    } 
 * 
 * ==================== Pressability Implementation Details ==================== 
 * 
 * `Pressability` only assumes that there exists a `HitRect` node. The `PressRect` 
 * is an abstract box that is extended beyond the `HitRect`. 
 * 
 * # Geometry 
 * 
 *  ┌────────────────────────┐ 
 *  │  ┌──────────────────┐  │ - Presses start anywhere within `HitRect`, which 
 *  │  │  ┌────────────┐  │  │   is expanded via the prop `hitSlop`. 
 *  │  │  │ VisualRect │  │  │ 
 *  │  │  └────────────┘  │  │ - When pressed down for sufficient amount of time 
 *  │  │    HitRect       │  │   before letting up, `VisualRect` activates for 
 *  │  └──────────────────┘  │   as long as the press stays within `PressRect`. 
 *  │       PressRect    o   │ 
 *  └────────────────────│───┘ 
 *          Out Region   └────── `PressRect`, which is expanded via the prop 
 *                               `pressRectOffset`, allows presses to move 
 *                               beyond `HitRect` while maintaining activation 
 *                               and being eligible for a &quot;press&quot;. 
 * 
 * # State Machine 
 * 
 * ┌───────────────┐ ◀──── RESPONDER_RELEASE 
 * │ NOT_RESPONDER │ 
 * └───┬───────────┘ ◀──── RESPONDER_TERMINATED 
 *     │ 
 *     │ RESPONDER_GRANT (HitRect) 
 *     │ 
 *     ▼ 
 * ┌─────────────────────┐          ┌───────────────────┐              ┌───────────────────┐ 
 * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │  T + DELAY   │ RESPONDER_ACTIVE_ │ 
 * │ PRESS_IN            ├────────▶ │ PRESS_IN          ├────────────▶ │ LONG_PRESS_IN     │ 
 * └─┬───────────────────┘          └─┬─────────────────┘              └─┬─────────────────┘ 
 *   │           ▲                    │           ▲                      │           ▲ 
 *   │LEAVE_     │                    │LEAVE_     │                      │LEAVE_     │ 
 *   │PRESS_RECT │ENTER_              │PRESS_RECT │ENTER_                │PRESS_RECT │ENTER_ 
 *   │           │PRESS_RECT          │           │PRESS_RECT            │           │PRESS_RECT 
 *   ▼           │                    ▼           │                      ▼           │ 
 * ┌─────────────┴───────┐          ┌─────────────┴─────┐              ┌─────────────┴─────┐ 
 * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │              │ RESPONDER_ACTIVE_ │ 
 * │ PRESS_OUT           ├────────▶ │ PRESS_OUT         │              │ LONG_PRESS_OUT    │ 
 * └─────────────────────┘          └───────────────────┘              └───────────────────┘ 
 * 
 * T + DELAY =&gt; LONG_PRESS_DELAY + DELAY 
 * 
 * Not drawn are the side effects of each transition. The most important side 
 * effect is the invocation of `onPress` and `onLongPress` that occur when a 
 * responder is release while in the &quot;press in&quot; states. 
 */</span>
<span class="s1">export </span><span class="s3">default </span><span class="s1">class Pressability {</span>
  <span class="s1">_config: PressabilityConfig;</span>
  <span class="s1">_eventHandlers: ?EventHandlers = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">_hoverInDelayTimeout: ?TimeoutID = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">_hoverOutDelayTimeout: ?TimeoutID = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">_isHovered: boolean = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">_longPressDelayTimeout: ?TimeoutID = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">_pressDelayTimeout: ?TimeoutID = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">_pressOutDelayTimeout: ?TimeoutID = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">_responderID: ?number | React.ElementRef&lt;HostComponent&lt;mixed&gt;&gt; = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">_responderRegion: ?$ReadOnly&lt;{|</span>
    <span class="s1">bottom: number,</span>
    <span class="s1">left: number,</span>
    <span class="s1">right: number,</span>
    <span class="s1">top: number,</span>
  <span class="s1">|}&gt; = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">_touchActivatePosition: ?$ReadOnly&lt;{|</span>
    <span class="s1">pageX: number,</span>
    <span class="s1">pageY: number,</span>
  <span class="s1">|}&gt;;</span>
  <span class="s1">_touchActivateTime: ?number;</span>
  <span class="s1">_touchState: TouchState = </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">;</span>

  <span class="s1">constructor(config: PressabilityConfig) {</span>
    <span class="s3">this</span><span class="s1">.configure(config);</span>
  <span class="s1">}</span>

  <span class="s1">configure(config: PressabilityConfig): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">this</span><span class="s1">._config = config;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Resets any pending timers. This should be called on unmount. 
   */</span>
  <span class="s1">reset(): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">this</span><span class="s1">._cancelHoverInDelayTimeout();</span>
    <span class="s3">this</span><span class="s1">._cancelHoverOutDelayTimeout();</span>
    <span class="s3">this</span><span class="s1">._cancelLongPressDelayTimeout();</span>
    <span class="s3">this</span><span class="s1">._cancelPressDelayTimeout();</span>
    <span class="s3">this</span><span class="s1">._cancelPressOutDelayTimeout();</span>

    <span class="s0">// Ensure that, if any async event handlers are fired after unmount</span>
    <span class="s0">// due to a race, we don't call any configured callbacks.</span>
    <span class="s3">this</span><span class="s1">._config = Object.freeze({});</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Returns a set of props to spread into the interactive element. 
   */</span>
  <span class="s1">getEventHandlers(): EventHandlers {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._eventHandlers == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">._eventHandlers = </span><span class="s3">this</span><span class="s1">._createEventHandlers();</span>
    <span class="s1">}</span>
    <span class="s3">return this</span><span class="s1">._eventHandlers;</span>
  <span class="s1">}</span>

  <span class="s1">static setLongPressDeactivationDistance(distance: number): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s1">longPressDeactivationDistance = distance;</span>
  <span class="s1">}</span>

  <span class="s1">_createEventHandlers(): EventHandlers {</span>
    <span class="s1">const focusEventHandlers = {</span>
      <span class="s1">onBlur: (event: BlurEvent): </span><span class="s3">void </span><span class="s1">=&gt; {</span>
        <span class="s1">const {onBlur} = </span><span class="s3">this</span><span class="s1">._config;</span>
        <span class="s3">if </span><span class="s1">(onBlur != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">onBlur(event);</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">onFocus: (event: FocusEvent): </span><span class="s3">void </span><span class="s1">=&gt; {</span>
        <span class="s1">const {onFocus} = </span><span class="s3">this</span><span class="s1">._config;</span>
        <span class="s3">if </span><span class="s1">(onFocus != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">onFocus(event);</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
    <span class="s1">};</span>

    <span class="s1">const responderEventHandlers = {</span>
      <span class="s1">onStartShouldSetResponder: (): boolean =&gt; {</span>
        <span class="s1">const {disabled} = </span><span class="s3">this</span><span class="s1">._config;</span>
        <span class="s3">if </span><span class="s1">(disabled == </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">const {onStartShouldSetResponder_DEPRECATED} = </span><span class="s3">this</span><span class="s1">._config;</span>
          <span class="s3">return </span><span class="s1">onStartShouldSetResponder_DEPRECATED == </span><span class="s3">null</span>
            <span class="s1">? </span><span class="s3">true</span>
            <span class="s1">: onStartShouldSetResponder_DEPRECATED();</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">!disabled;</span>
      <span class="s1">},</span>

      <span class="s1">onResponderGrant: (event: PressEvent): </span><span class="s3">void </span><span class="s1">=&gt; {</span>
        <span class="s1">event.persist();</span>

        <span class="s3">this</span><span class="s1">._cancelPressOutDelayTimeout();</span>

        <span class="s3">this</span><span class="s1">._responderID = event.currentTarget;</span>
        <span class="s3">this</span><span class="s1">._touchState = </span><span class="s2">'NOT_RESPONDER'</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">._receiveSignal(</span><span class="s2">'RESPONDER_GRANT'</span><span class="s1">, event);</span>

        <span class="s1">const delayPressIn = normalizeDelay(</span><span class="s3">this</span><span class="s1">._config.delayPressIn);</span>
        <span class="s3">if </span><span class="s1">(delayPressIn &gt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s3">this</span><span class="s1">._pressDelayTimeout = setTimeout(() =&gt; {</span>
            <span class="s3">this</span><span class="s1">._receiveSignal(</span><span class="s2">'DELAY'</span><span class="s1">, event);</span>
          <span class="s1">}, delayPressIn);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">this</span><span class="s1">._receiveSignal(</span><span class="s2">'DELAY'</span><span class="s1">, event);</span>
        <span class="s1">}</span>

        <span class="s1">const delayLongPress = normalizeDelay(</span>
          <span class="s3">this</span><span class="s1">._config.delayLongPress,</span>
          <span class="s4">10</span><span class="s1">,</span>
          <span class="s1">DEFAULT_LONG_PRESS_DELAY_MS - delayPressIn,</span>
        <span class="s1">);</span>
        <span class="s3">this</span><span class="s1">._longPressDelayTimeout = setTimeout(() =&gt; {</span>
          <span class="s3">this</span><span class="s1">._handleLongPress(event);</span>
        <span class="s1">}, delayLongPress + delayPressIn);</span>
      <span class="s1">},</span>

      <span class="s1">onResponderMove: (event: PressEvent): </span><span class="s3">void </span><span class="s1">=&gt; {</span>
        <span class="s1">const {onPressMove} = </span><span class="s3">this</span><span class="s1">._config;</span>
        <span class="s3">if </span><span class="s1">(onPressMove != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">onPressMove(event);</span>
        <span class="s1">}</span>

        <span class="s0">// Region may not have finished being measured, yet.</span>
        <span class="s1">const responderRegion = </span><span class="s3">this</span><span class="s1">._responderRegion;</span>
        <span class="s3">if </span><span class="s1">(responderRegion == </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">const touch = getTouchFromPressEvent(event);</span>
        <span class="s3">if </span><span class="s1">(touch == </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">this</span><span class="s1">._cancelLongPressDelayTimeout();</span>
          <span class="s3">this</span><span class="s1">._receiveSignal(</span><span class="s2">'LEAVE_PRESS_RECT'</span><span class="s1">, event);</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._touchActivatePosition != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">const deltaX = </span><span class="s3">this</span><span class="s1">._touchActivatePosition.pageX - touch.pageX;</span>
          <span class="s1">const deltaY = </span><span class="s3">this</span><span class="s1">._touchActivatePosition.pageY - touch.pageY;</span>
          <span class="s3">if </span><span class="s1">(Math.hypot(deltaX, deltaY) &gt; longPressDeactivationDistance) {</span>
            <span class="s3">this</span><span class="s1">._cancelLongPressDelayTimeout();</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._isTouchWithinResponderRegion(touch, responderRegion)) {</span>
          <span class="s3">this</span><span class="s1">._receiveSignal(</span><span class="s2">'ENTER_PRESS_RECT'</span><span class="s1">, event);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">this</span><span class="s1">._cancelLongPressDelayTimeout();</span>
          <span class="s3">this</span><span class="s1">._receiveSignal(</span><span class="s2">'LEAVE_PRESS_RECT'</span><span class="s1">, event);</span>
        <span class="s1">}</span>
      <span class="s1">},</span>

      <span class="s1">onResponderRelease: (event: PressEvent): </span><span class="s3">void </span><span class="s1">=&gt; {</span>
        <span class="s3">this</span><span class="s1">._receiveSignal(</span><span class="s2">'RESPONDER_RELEASE'</span><span class="s1">, event);</span>
      <span class="s1">},</span>

      <span class="s1">onResponderTerminate: (event: PressEvent): </span><span class="s3">void </span><span class="s1">=&gt; {</span>
        <span class="s3">this</span><span class="s1">._receiveSignal(</span><span class="s2">'RESPONDER_TERMINATED'</span><span class="s1">, event);</span>
      <span class="s1">},</span>

      <span class="s1">onResponderTerminationRequest: (): boolean =&gt; {</span>
        <span class="s1">const {cancelable} = </span><span class="s3">this</span><span class="s1">._config;</span>
        <span class="s3">if </span><span class="s1">(cancelable == </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">const {onResponderTerminationRequest_DEPRECATED} = </span><span class="s3">this</span><span class="s1">._config;</span>
          <span class="s3">return </span><span class="s1">onResponderTerminationRequest_DEPRECATED == </span><span class="s3">null</span>
            <span class="s1">? </span><span class="s3">true</span>
            <span class="s1">: onResponderTerminationRequest_DEPRECATED();</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">cancelable;</span>
      <span class="s1">},</span>

      <span class="s1">onClick: (event: PressEvent): </span><span class="s3">void </span><span class="s1">=&gt; {</span>
        <span class="s1">const {onPress, disabled} = </span><span class="s3">this</span><span class="s1">._config;</span>
        <span class="s3">if </span><span class="s1">(onPress != </span><span class="s3">null </span><span class="s1">&amp;&amp; disabled !== </span><span class="s3">true</span><span class="s1">) {</span>
          <span class="s1">onPress(event);</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
    <span class="s1">};</span>

    <span class="s3">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s2">'test'</span><span class="s1">) {</span>
      <span class="s0">// We are setting this in order to find this node in ReactNativeTestTools</span>
      <span class="s0">// $FlowFixMe[prop-missing]</span>
      <span class="s1">responderEventHandlers.onStartShouldSetResponder.testOnly_pressabilityConfig =</span>
        <span class="s1">() =&gt; </span><span class="s3">this</span><span class="s1">._config;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">ReactNativeFeatureFlags.shouldPressibilityUseW3CPointerEventsForHover()</span>
    <span class="s1">) {</span>
      <span class="s1">const hoverPointerEvents = {</span>
        <span class="s1">onPointerEnter: (undefined: </span><span class="s3">void </span><span class="s1">| (PointerEvent =&gt; </span><span class="s3">void</span><span class="s1">)),</span>
        <span class="s1">onPointerLeave: (undefined: </span><span class="s3">void </span><span class="s1">| (PointerEvent =&gt; </span><span class="s3">void</span><span class="s1">)),</span>
      <span class="s1">};</span>
      <span class="s1">const {onHoverIn, onHoverOut} = </span><span class="s3">this</span><span class="s1">._config;</span>
      <span class="s3">if </span><span class="s1">(onHoverIn != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">hoverPointerEvents.onPointerEnter = (event: PointerEvent) =&gt; {</span>
          <span class="s3">this</span><span class="s1">._isHovered = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s3">this</span><span class="s1">._cancelHoverOutDelayTimeout();</span>
          <span class="s3">if </span><span class="s1">(onHoverIn != </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">const delayHoverIn = normalizeDelay(</span><span class="s3">this</span><span class="s1">._config.delayHoverIn);</span>
            <span class="s3">if </span><span class="s1">(delayHoverIn &gt; </span><span class="s4">0</span><span class="s1">) {</span>
              <span class="s1">event.persist();</span>
              <span class="s3">this</span><span class="s1">._hoverInDelayTimeout = setTimeout(() =&gt; {</span>
                <span class="s1">onHoverIn(convertPointerEventToMouseEvent(event));</span>
              <span class="s1">}, delayHoverIn);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s1">onHoverIn(convertPointerEventToMouseEvent(event));</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">};</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(onHoverOut != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">hoverPointerEvents.onPointerLeave = (event: PointerEvent) =&gt; {</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._isHovered) {</span>
            <span class="s3">this</span><span class="s1">._isHovered = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">this</span><span class="s1">._cancelHoverInDelayTimeout();</span>
            <span class="s3">if </span><span class="s1">(onHoverOut != </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">const delayHoverOut = normalizeDelay(</span><span class="s3">this</span><span class="s1">._config.delayHoverOut);</span>
              <span class="s3">if </span><span class="s1">(delayHoverOut &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">event.persist();</span>
                <span class="s3">this</span><span class="s1">._hoverOutDelayTimeout = setTimeout(() =&gt; {</span>
                  <span class="s1">onHoverOut(convertPointerEventToMouseEvent(event));</span>
                <span class="s1">}, delayHoverOut);</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">onHoverOut(convertPointerEventToMouseEvent(event));</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">};</span>
      <span class="s1">}</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">...focusEventHandlers,</span>
        <span class="s1">...responderEventHandlers,</span>
        <span class="s1">...hoverPointerEvents,</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">const mouseEventHandlers =</span>
        <span class="s1">Platform.OS === </span><span class="s2">'ios' </span><span class="s1">|| Platform.OS === </span><span class="s2">'android'</span>
          <span class="s1">? </span><span class="s3">null</span>
          <span class="s1">: {</span>
              <span class="s1">onMouseEnter: (event: MouseEvent): </span><span class="s3">void </span><span class="s1">=&gt; {</span>
                <span class="s3">if </span><span class="s1">(isHoverEnabled()) {</span>
                  <span class="s3">this</span><span class="s1">._isHovered = </span><span class="s3">true</span><span class="s1">;</span>
                  <span class="s3">this</span><span class="s1">._cancelHoverOutDelayTimeout();</span>
                  <span class="s1">const {onHoverIn} = </span><span class="s3">this</span><span class="s1">._config;</span>
                  <span class="s3">if </span><span class="s1">(onHoverIn != </span><span class="s3">null</span><span class="s1">) {</span>
                    <span class="s1">const delayHoverIn = normalizeDelay(</span>
                      <span class="s3">this</span><span class="s1">._config.delayHoverIn,</span>
                    <span class="s1">);</span>
                    <span class="s3">if </span><span class="s1">(delayHoverIn &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                      <span class="s1">event.persist();</span>
                      <span class="s3">this</span><span class="s1">._hoverInDelayTimeout = setTimeout(() =&gt; {</span>
                        <span class="s1">onHoverIn(event);</span>
                      <span class="s1">}, delayHoverIn);</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                      <span class="s1">onHoverIn(event);</span>
                    <span class="s1">}</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
              <span class="s1">},</span>

              <span class="s1">onMouseLeave: (event: MouseEvent): </span><span class="s3">void </span><span class="s1">=&gt; {</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._isHovered) {</span>
                  <span class="s3">this</span><span class="s1">._isHovered = </span><span class="s3">false</span><span class="s1">;</span>
                  <span class="s3">this</span><span class="s1">._cancelHoverInDelayTimeout();</span>
                  <span class="s1">const {onHoverOut} = </span><span class="s3">this</span><span class="s1">._config;</span>
                  <span class="s3">if </span><span class="s1">(onHoverOut != </span><span class="s3">null</span><span class="s1">) {</span>
                    <span class="s1">const delayHoverOut = normalizeDelay(</span>
                      <span class="s3">this</span><span class="s1">._config.delayHoverOut,</span>
                    <span class="s1">);</span>
                    <span class="s3">if </span><span class="s1">(delayHoverOut &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                      <span class="s1">event.persist();</span>
                      <span class="s3">this</span><span class="s1">._hoverInDelayTimeout = setTimeout(() =&gt; {</span>
                        <span class="s1">onHoverOut(event);</span>
                      <span class="s1">}, delayHoverOut);</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                      <span class="s1">onHoverOut(event);</span>
                    <span class="s1">}</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
              <span class="s1">},</span>
            <span class="s1">};</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">...focusEventHandlers,</span>
        <span class="s1">...responderEventHandlers,</span>
        <span class="s1">...mouseEventHandlers,</span>
      <span class="s1">};</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Receives a state machine signal, performs side effects of the transition 
   * and stores the new state. Validates the transition as well. 
   */</span>
  <span class="s1">_receiveSignal(signal: TouchSignal, event: PressEvent): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s0">// Especially on iOS, not all events have timestamps associated.</span>
    <span class="s0">// For telemetry purposes, this doesn't matter too much, as long as *some* do.</span>
    <span class="s0">// Since the native timestamp is integral for logging telemetry, just skip</span>
    <span class="s0">// events if they don't have a timestamp attached.</span>
    <span class="s3">if </span><span class="s1">(event.nativeEvent.timestamp != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">PressabilityPerformanceEventEmitter.emitEvent(() =&gt; {</span>
        <span class="s3">return </span><span class="s1">{</span>
          <span class="s1">signal,</span>
          <span class="s1">nativeTimestamp: event.nativeEvent.timestamp,</span>
        <span class="s1">};</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s1">const prevState = </span><span class="s3">this</span><span class="s1">._touchState;</span>
    <span class="s1">const nextState = Transitions[prevState]?.[signal];</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._responderID == </span><span class="s3">null </span><span class="s1">&amp;&amp; signal === </span><span class="s2">'RESPONDER_RELEASE'</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">invariant(</span>
      <span class="s1">nextState != </span><span class="s3">null </span><span class="s1">&amp;&amp; nextState !== </span><span class="s2">'ERROR'</span><span class="s1">,</span>
      <span class="s2">'Pressability: Invalid signal `%s` for state `%s` on responder: %s'</span><span class="s1">,</span>
      <span class="s1">signal,</span>
      <span class="s1">prevState,</span>
      <span class="s3">typeof this</span><span class="s1">._responderID === </span><span class="s2">'number'</span>
        <span class="s1">? </span><span class="s3">this</span><span class="s1">._responderID</span>
        <span class="s1">: </span><span class="s2">'&lt;&lt;host component&gt;&gt;'</span><span class="s1">,</span>
    <span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(prevState !== nextState) {</span>
      <span class="s3">this</span><span class="s1">._performTransitionSideEffects(prevState, nextState, signal, event);</span>
      <span class="s3">this</span><span class="s1">._touchState = nextState;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Performs a transition between touchable states and identify any activations 
   * or deactivations (and callback invocations). 
   */</span>
  <span class="s1">_performTransitionSideEffects(</span>
    <span class="s1">prevState: TouchState,</span>
    <span class="s1">nextState: TouchState,</span>
    <span class="s1">signal: TouchSignal,</span>
    <span class="s1">event: PressEvent,</span>
  <span class="s1">): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(isTerminalSignal(signal)) {</span>
      <span class="s3">this</span><span class="s1">._touchActivatePosition = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">._cancelLongPressDelayTimeout();</span>
    <span class="s1">}</span>

    <span class="s1">const isInitialTransition =</span>
      <span class="s1">prevState === </span><span class="s2">'NOT_RESPONDER' </span><span class="s1">&amp;&amp;</span>
      <span class="s1">nextState === </span><span class="s2">'RESPONDER_INACTIVE_PRESS_IN'</span><span class="s1">;</span>

    <span class="s1">const isActivationTransition =</span>
      <span class="s1">!isActivationSignal(prevState) &amp;&amp; isActivationSignal(nextState);</span>

    <span class="s3">if </span><span class="s1">(isInitialTransition || isActivationTransition) {</span>
      <span class="s3">this</span><span class="s1">._measureResponderRegion();</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(isPressInSignal(prevState) &amp;&amp; signal === </span><span class="s2">'LONG_PRESS_DETECTED'</span><span class="s1">) {</span>
      <span class="s1">const {onLongPress} = </span><span class="s3">this</span><span class="s1">._config;</span>
      <span class="s3">if </span><span class="s1">(onLongPress != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">onLongPress(event);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">const isPrevActive = isActiveSignal(prevState);</span>
    <span class="s1">const isNextActive = isActiveSignal(nextState);</span>

    <span class="s3">if </span><span class="s1">(!isPrevActive &amp;&amp; isNextActive) {</span>
      <span class="s3">this</span><span class="s1">._activate(event);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isPrevActive &amp;&amp; !isNextActive) {</span>
      <span class="s3">this</span><span class="s1">._deactivate(event);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(isPressInSignal(prevState) &amp;&amp; signal === </span><span class="s2">'RESPONDER_RELEASE'</span><span class="s1">) {</span>
      <span class="s0">// If we never activated (due to delays), activate and deactivate now.</span>
      <span class="s3">if </span><span class="s1">(!isNextActive &amp;&amp; !isPrevActive) {</span>
        <span class="s3">this</span><span class="s1">._activate(event);</span>
        <span class="s3">this</span><span class="s1">._deactivate(event);</span>
      <span class="s1">}</span>
      <span class="s1">const {onLongPress, onPress, android_disableSound} = </span><span class="s3">this</span><span class="s1">._config;</span>
      <span class="s3">if </span><span class="s1">(onPress != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">const isPressCanceledByLongPress =</span>
          <span class="s1">onLongPress != </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
          <span class="s1">prevState === </span><span class="s2">'RESPONDER_ACTIVE_LONG_PRESS_IN' </span><span class="s1">&amp;&amp;</span>
          <span class="s3">this</span><span class="s1">._shouldLongPressCancelPress();</span>
        <span class="s3">if </span><span class="s1">(!isPressCanceledByLongPress) {</span>
          <span class="s3">if </span><span class="s1">(Platform.OS === </span><span class="s2">'android' </span><span class="s1">&amp;&amp; android_disableSound !== </span><span class="s3">true</span><span class="s1">) {</span>
            <span class="s1">SoundManager.playTouchSound();</span>
          <span class="s1">}</span>
          <span class="s1">onPress(event);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">this</span><span class="s1">._cancelPressDelayTimeout();</span>
  <span class="s1">}</span>

  <span class="s1">_activate(event: PressEvent): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s1">const {onPressIn} = </span><span class="s3">this</span><span class="s1">._config;</span>
    <span class="s1">const {pageX, pageY} = getTouchFromPressEvent(event);</span>
    <span class="s3">this</span><span class="s1">._touchActivatePosition = {pageX, pageY};</span>
    <span class="s3">this</span><span class="s1">._touchActivateTime = Date.now();</span>
    <span class="s3">if </span><span class="s1">(onPressIn != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">onPressIn(event);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">_deactivate(event: PressEvent): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s1">const {onPressOut} = </span><span class="s3">this</span><span class="s1">._config;</span>
    <span class="s3">if </span><span class="s1">(onPressOut != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">const minPressDuration = normalizeDelay(</span>
        <span class="s3">this</span><span class="s1">._config.minPressDuration,</span>
        <span class="s4">0</span><span class="s1">,</span>
        <span class="s1">DEFAULT_MIN_PRESS_DURATION,</span>
      <span class="s1">);</span>
      <span class="s1">const pressDuration = Date.now() - (</span><span class="s3">this</span><span class="s1">._touchActivateTime ?? </span><span class="s4">0</span><span class="s1">);</span>
      <span class="s1">const delayPressOut = Math.max(</span>
        <span class="s1">minPressDuration - pressDuration,</span>
        <span class="s1">normalizeDelay(</span><span class="s3">this</span><span class="s1">._config.delayPressOut),</span>
      <span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(delayPressOut &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">event.persist();</span>
        <span class="s3">this</span><span class="s1">._pressOutDelayTimeout = setTimeout(() =&gt; {</span>
          <span class="s1">onPressOut(event);</span>
        <span class="s1">}, delayPressOut);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">onPressOut(event);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">this</span><span class="s1">._touchActivateTime = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">_measureResponderRegion(): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._responderID == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof this</span><span class="s1">._responderID === </span><span class="s2">'number'</span><span class="s1">) {</span>
      <span class="s1">UIManager.measure(</span><span class="s3">this</span><span class="s1">._responderID, </span><span class="s3">this</span><span class="s1">._measureCallback);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">this</span><span class="s1">._responderID.measure(</span><span class="s3">this</span><span class="s1">._measureCallback);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">_measureCallback = (</span>
    <span class="s1">left: number,</span>
    <span class="s1">top: number,</span>
    <span class="s1">width: number,</span>
    <span class="s1">height: number,</span>
    <span class="s1">pageX: number,</span>
    <span class="s1">pageY: number,</span>
  <span class="s1">) =&gt; {</span>
    <span class="s3">if </span><span class="s1">(!left &amp;&amp; !top &amp;&amp; !width &amp;&amp; !height &amp;&amp; !pageX &amp;&amp; !pageY) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">this</span><span class="s1">._responderRegion = {</span>
      <span class="s1">bottom: pageY + height,</span>
      <span class="s1">left: pageX,</span>
      <span class="s1">right: pageX + width,</span>
      <span class="s1">top: pageY,</span>
    <span class="s1">};</span>
  <span class="s1">};</span>

  <span class="s1">_isTouchWithinResponderRegion(</span>
    <span class="s1">touch: $PropertyType&lt;PressEvent, </span><span class="s2">'nativeEvent'</span><span class="s1">&gt;,</span>
    <span class="s1">responderRegion: $ReadOnly&lt;{|</span>
      <span class="s1">bottom: number,</span>
      <span class="s1">left: number,</span>
      <span class="s1">right: number,</span>
      <span class="s1">top: number,</span>
    <span class="s1">|}&gt;,</span>
  <span class="s1">): boolean {</span>
    <span class="s1">const hitSlop = normalizeRect(</span><span class="s3">this</span><span class="s1">._config.hitSlop);</span>
    <span class="s1">const pressRectOffset = normalizeRect(</span><span class="s3">this</span><span class="s1">._config.pressRectOffset);</span>

    <span class="s1">let regionBottom = responderRegion.bottom;</span>
    <span class="s1">let regionLeft = responderRegion.left;</span>
    <span class="s1">let regionRight = responderRegion.right;</span>
    <span class="s1">let regionTop = responderRegion.top;</span>

    <span class="s3">if </span><span class="s1">(hitSlop != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(hitSlop.bottom != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">regionBottom += hitSlop.bottom;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(hitSlop.left != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">regionLeft -= hitSlop.left;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(hitSlop.right != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">regionRight += hitSlop.right;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(hitSlop.top != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">regionTop -= hitSlop.top;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">regionBottom +=</span>
      <span class="s1">pressRectOffset?.bottom ?? DEFAULT_PRESS_RECT_OFFSETS.bottom;</span>
    <span class="s1">regionLeft -= pressRectOffset?.left ?? DEFAULT_PRESS_RECT_OFFSETS.left;</span>
    <span class="s1">regionRight += pressRectOffset?.right ?? DEFAULT_PRESS_RECT_OFFSETS.right;</span>
    <span class="s1">regionTop -= pressRectOffset?.top ?? DEFAULT_PRESS_RECT_OFFSETS.top;</span>

    <span class="s3">return </span><span class="s1">(</span>
      <span class="s1">touch.pageX &gt; regionLeft &amp;&amp;</span>
      <span class="s1">touch.pageX &lt; regionRight &amp;&amp;</span>
      <span class="s1">touch.pageY &gt; regionTop &amp;&amp;</span>
      <span class="s1">touch.pageY &lt; regionBottom</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">_handleLongPress(event: PressEvent): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">this</span><span class="s1">._touchState === </span><span class="s2">'RESPONDER_ACTIVE_PRESS_IN' </span><span class="s1">||</span>
      <span class="s3">this</span><span class="s1">._touchState === </span><span class="s2">'RESPONDER_ACTIVE_LONG_PRESS_IN'</span>
    <span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">._receiveSignal(</span><span class="s2">'LONG_PRESS_DETECTED'</span><span class="s1">, event);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">_shouldLongPressCancelPress(): boolean {</span>
    <span class="s3">return </span><span class="s1">(</span>
      <span class="s3">this</span><span class="s1">._config.onLongPressShouldCancelPress_DEPRECATED == </span><span class="s3">null </span><span class="s1">||</span>
      <span class="s3">this</span><span class="s1">._config.onLongPressShouldCancelPress_DEPRECATED()</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">_cancelHoverInDelayTimeout(): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._hoverInDelayTimeout != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">clearTimeout(</span><span class="s3">this</span><span class="s1">._hoverInDelayTimeout);</span>
      <span class="s3">this</span><span class="s1">._hoverInDelayTimeout = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">_cancelHoverOutDelayTimeout(): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._hoverOutDelayTimeout != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">clearTimeout(</span><span class="s3">this</span><span class="s1">._hoverOutDelayTimeout);</span>
      <span class="s3">this</span><span class="s1">._hoverOutDelayTimeout = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">_cancelLongPressDelayTimeout(): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._longPressDelayTimeout != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">clearTimeout(</span><span class="s3">this</span><span class="s1">._longPressDelayTimeout);</span>
      <span class="s3">this</span><span class="s1">._longPressDelayTimeout = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">_cancelPressDelayTimeout(): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._pressDelayTimeout != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">clearTimeout(</span><span class="s3">this</span><span class="s1">._pressDelayTimeout);</span>
      <span class="s3">this</span><span class="s1">._pressDelayTimeout = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">_cancelPressOutDelayTimeout(): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._pressOutDelayTimeout != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">clearTimeout(</span><span class="s3">this</span><span class="s1">._pressOutDelayTimeout);</span>
      <span class="s3">this</span><span class="s1">._pressOutDelayTimeout = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">normalizeDelay(</span>
  <span class="s1">delay: ?number,</span>
  <span class="s1">min: number = </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s1">fallback: number = </span><span class="s4">0</span><span class="s1">,</span>
<span class="s1">): number {</span>
  <span class="s3">return </span><span class="s1">Math.max(min, delay ?? fallback);</span>
<span class="s1">}</span>

<span class="s1">const getTouchFromPressEvent = (event: PressEvent) =&gt; {</span>
  <span class="s1">const {changedTouches, touches} = event.nativeEvent;</span>

  <span class="s3">if </span><span class="s1">(touches != </span><span class="s3">null </span><span class="s1">&amp;&amp; touches.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">touches[</span><span class="s4">0</span><span class="s1">];</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(changedTouches != </span><span class="s3">null </span><span class="s1">&amp;&amp; changedTouches.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">changedTouches[</span><span class="s4">0</span><span class="s1">];</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">event.nativeEvent;</span>
<span class="s1">};</span>

<span class="s3">function </span><span class="s1">convertPointerEventToMouseEvent(input: PointerEvent): MouseEvent {</span>
  <span class="s1">const {clientX, clientY} = input.nativeEvent;</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">...input,</span>
    <span class="s1">nativeEvent: {</span>
      <span class="s1">clientX,</span>
      <span class="s1">clientY,</span>
      <span class="s1">pageX: clientX,</span>
      <span class="s1">pageY: clientY,</span>
      <span class="s1">timestamp: input.timeStamp,</span>
    <span class="s1">},</span>
  <span class="s1">};</span>
<span class="s1">}</span>
</pre>
</body>
</html>
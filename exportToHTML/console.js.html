<html>
<head>
<title>console.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
console.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 * @polyfill 
 * @nolint 
 * @format 
 */</span>

<span class="s0">/* eslint-disable no-shadow, eqeqeq, curly, no-unused-vars, no-void, no-control-regex  */</span>

<span class="s0">/** 
 * This pipes all of our console logging functions to native logging so that 
 * JavaScript errors in required modules show up in Xcode via NSLog. 
 */</span>
<span class="s1">const inspect = (</span><span class="s2">function </span><span class="s1">() {</span>
  <span class="s0">// Copyright Joyent, Inc. and other Node contributors.</span>
  <span class="s0">//</span>
  <span class="s0">// Permission is hereby granted, free of charge, to any person obtaining a</span>
  <span class="s0">// copy of this software and associated documentation files (the</span>
  <span class="s0">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
  <span class="s0">// without limitation the rights to use, copy, modify, merge, publish,</span>
  <span class="s0">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
  <span class="s0">// persons to whom the Software is furnished to do so, subject to the</span>
  <span class="s0">// following conditions:</span>
  <span class="s0">//</span>
  <span class="s0">// The above copyright notice and this permission notice shall be included</span>
  <span class="s0">// in all copies or substantial portions of the Software.</span>
  <span class="s0">//</span>
  <span class="s0">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
  <span class="s0">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
  <span class="s0">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
  <span class="s0">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
  <span class="s0">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
  <span class="s0">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
  <span class="s0">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
  <span class="s0">//</span>
  <span class="s0">// https://github.com/joyent/node/blob/master/lib/util.js</span>

  <span class="s2">function </span><span class="s1">inspect(obj, opts) {</span>
    <span class="s2">var </span><span class="s1">ctx = {</span>
      <span class="s1">seen: [],</span>
      <span class="s1">formatValueCalls: </span><span class="s3">0</span><span class="s1">,</span>
      <span class="s1">stylize: stylizeNoColor,</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">formatValue(ctx, obj, opts.depth);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">stylizeNoColor(str, styleType) {</span>
    <span class="s2">return </span><span class="s1">str;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">arrayToHash(array) {</span>
    <span class="s2">var </span><span class="s1">hash = {};</span>

    <span class="s1">array.forEach(</span><span class="s2">function </span><span class="s1">(val, idx) {</span>
      <span class="s1">hash[val] = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">});</span>

    <span class="s2">return </span><span class="s1">hash;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">formatValue(ctx, value, recurseTimes) {</span>
    <span class="s1">ctx.formatValueCalls++;</span>
    <span class="s2">if </span><span class="s1">(ctx.formatValueCalls &gt; </span><span class="s3">200</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">`[TOO BIG formatValueCalls ${ctx.formatValueCalls} exceeded limit of </span><span class="s3">200</span><span class="s1">]`;</span>
    <span class="s1">}</span>

    <span class="s0">// Primitive types cannot have properties</span>
    <span class="s2">var </span><span class="s1">primitive = formatPrimitive(ctx, value);</span>
    <span class="s2">if </span><span class="s1">(primitive) {</span>
      <span class="s2">return </span><span class="s1">primitive;</span>
    <span class="s1">}</span>

    <span class="s0">// Look up the keys of the object.</span>
    <span class="s2">var </span><span class="s1">keys = Object.keys(value);</span>
    <span class="s2">var </span><span class="s1">visibleKeys = arrayToHash(keys);</span>

    <span class="s0">// IE doesn't make error fields non-enumerable</span>
    <span class="s0">// http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s1">isError(value) &amp;&amp;</span>
      <span class="s1">(keys.indexOf(</span><span class="s4">'message'</span><span class="s1">) &gt;= </span><span class="s3">0 </span><span class="s1">|| keys.indexOf(</span><span class="s4">'description'</span><span class="s1">) &gt;= </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">formatError(value);</span>
    <span class="s1">}</span>

    <span class="s0">// Some type of object without properties can be shortcutted.</span>
    <span class="s2">if </span><span class="s1">(keys.length === </span><span class="s3">0</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(isFunction(value)) {</span>
        <span class="s2">var </span><span class="s1">name = value.name ? </span><span class="s4">': ' </span><span class="s1">+ value.name : </span><span class="s4">''</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">ctx.stylize(</span><span class="s4">'[Function' </span><span class="s1">+ name + </span><span class="s4">']'</span><span class="s1">, </span><span class="s4">'special'</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isRegExp(value)) {</span>
        <span class="s2">return </span><span class="s1">ctx.stylize(RegExp.prototype.toString.call(value), </span><span class="s4">'regexp'</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isDate(value)) {</span>
        <span class="s2">return </span><span class="s1">ctx.stylize(Date.prototype.toString.call(value), </span><span class="s4">'date'</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isError(value)) {</span>
        <span class="s2">return </span><span class="s1">formatError(value);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">base = </span><span class="s4">''</span><span class="s1">,</span>
      <span class="s1">array = </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">braces = [</span><span class="s4">'{'</span><span class="s1">, </span><span class="s4">'}'</span><span class="s1">];</span>

    <span class="s0">// Make Array say that they are Array</span>
    <span class="s2">if </span><span class="s1">(isArray(value)) {</span>
      <span class="s1">array = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">braces = [</span><span class="s4">'['</span><span class="s1">, </span><span class="s4">']'</span><span class="s1">];</span>
    <span class="s1">}</span>

    <span class="s0">// Make functions say that they are functions</span>
    <span class="s2">if </span><span class="s1">(isFunction(value)) {</span>
      <span class="s2">var </span><span class="s1">n = value.name ? </span><span class="s4">': ' </span><span class="s1">+ value.name : </span><span class="s4">''</span><span class="s1">;</span>
      <span class="s1">base = </span><span class="s4">' [Function' </span><span class="s1">+ n + </span><span class="s4">']'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// Make RegExps say that they are RegExps</span>
    <span class="s2">if </span><span class="s1">(isRegExp(value)) {</span>
      <span class="s1">base = </span><span class="s4">' ' </span><span class="s1">+ RegExp.prototype.toString.call(value);</span>
    <span class="s1">}</span>

    <span class="s0">// Make dates with properties first say the date</span>
    <span class="s2">if </span><span class="s1">(isDate(value)) {</span>
      <span class="s1">base = </span><span class="s4">' ' </span><span class="s1">+ Date.prototype.toUTCString.call(value);</span>
    <span class="s1">}</span>

    <span class="s0">// Make error with message first say the error</span>
    <span class="s2">if </span><span class="s1">(isError(value)) {</span>
      <span class="s1">base = </span><span class="s4">' ' </span><span class="s1">+ formatError(value);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(keys.length === </span><span class="s3">0 </span><span class="s1">&amp;&amp; (!array || value.length == </span><span class="s3">0</span><span class="s1">)) {</span>
      <span class="s2">return </span><span class="s1">braces[</span><span class="s3">0</span><span class="s1">] + base + braces[</span><span class="s3">1</span><span class="s1">];</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(recurseTimes &lt; </span><span class="s3">0</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(isRegExp(value)) {</span>
        <span class="s2">return </span><span class="s1">ctx.stylize(RegExp.prototype.toString.call(value), </span><span class="s4">'regexp'</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">ctx.stylize(</span><span class="s4">'[Object]'</span><span class="s1">, </span><span class="s4">'special'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">ctx.seen.push(value);</span>

    <span class="s2">var </span><span class="s1">output;</span>
    <span class="s2">if </span><span class="s1">(array) {</span>
      <span class="s1">output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">output = keys.map(</span><span class="s2">function </span><span class="s1">(key) {</span>
        <span class="s2">return </span><span class="s1">formatProperty(</span>
          <span class="s1">ctx,</span>
          <span class="s1">value,</span>
          <span class="s1">recurseTimes,</span>
          <span class="s1">visibleKeys,</span>
          <span class="s1">key,</span>
          <span class="s1">array,</span>
        <span class="s1">);</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s1">ctx.seen.pop();</span>

    <span class="s2">return </span><span class="s1">reduceToSingleString(output, base, braces);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">formatPrimitive(ctx, value) {</span>
    <span class="s2">if </span><span class="s1">(isUndefined(value)) </span><span class="s2">return </span><span class="s1">ctx.stylize(</span><span class="s4">'undefined'</span><span class="s1">, </span><span class="s4">'undefined'</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(isString(value)) {</span>
      <span class="s2">var </span><span class="s1">simple =</span>
        <span class="s4">&quot;'&quot; </span><span class="s1">+</span>
        <span class="s1">JSON.stringify(value)</span>
          <span class="s1">.replace(/^</span><span class="s4">&quot;|&quot;</span><span class="s1">$/g, </span><span class="s4">''</span><span class="s1">)</span>
          <span class="s1">.replace(/</span><span class="s4">'/g, &quot;</span><span class="s5">\\</span><span class="s4">'&quot;)</span>
          <span class="s1">.replace(/\\</span><span class="s4">&quot;/g, '&quot;') +</span>
        <span class="s4">&quot;'&quot;</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">ctx.stylize(simple, </span><span class="s4">'string'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isNumber(value)) </span><span class="s2">return </span><span class="s1">ctx.stylize(</span><span class="s4">'' </span><span class="s1">+ value, </span><span class="s4">'number'</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(isBoolean(value)) </span><span class="s2">return </span><span class="s1">ctx.stylize(</span><span class="s4">'' </span><span class="s1">+ value, </span><span class="s4">'boolean'</span><span class="s1">);</span>
    <span class="s0">// For some reason typeof null is &quot;object&quot;, so special case here.</span>
    <span class="s2">if </span><span class="s1">(isNull(value)) </span><span class="s2">return </span><span class="s1">ctx.stylize(</span><span class="s4">'null'</span><span class="s1">, </span><span class="s4">'null'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">formatError(value) {</span>
    <span class="s2">return </span><span class="s4">'[' </span><span class="s1">+ Error.prototype.toString.call(value) + </span><span class="s4">']'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">formatArray(ctx, value, recurseTimes, visibleKeys, keys) {</span>
    <span class="s2">var </span><span class="s1">output = [];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">, l = value.length; i &lt; l; ++i) {</span>
      <span class="s2">if </span><span class="s1">(hasOwnProperty(value, String(i))) {</span>
        <span class="s1">output.push(</span>
          <span class="s1">formatProperty(</span>
            <span class="s1">ctx,</span>
            <span class="s1">value,</span>
            <span class="s1">recurseTimes,</span>
            <span class="s1">visibleKeys,</span>
            <span class="s1">String(i),</span>
            <span class="s2">true</span><span class="s1">,</span>
          <span class="s1">),</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">output.push(</span><span class="s4">''</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">keys.forEach(</span><span class="s2">function </span><span class="s1">(key) {</span>
      <span class="s2">if </span><span class="s1">(!key.match(/^\d+$/)) {</span>
        <span class="s1">output.push(</span>
          <span class="s1">formatProperty(ctx, value, recurseTimes, visibleKeys, key, </span><span class="s2">true</span><span class="s1">),</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">output;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {</span>
    <span class="s2">var </span><span class="s1">name, str, desc;</span>
    <span class="s1">desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};</span>
    <span class="s2">if </span><span class="s1">(desc.get) {</span>
      <span class="s2">if </span><span class="s1">(desc.set) {</span>
        <span class="s1">str = ctx.stylize(</span><span class="s4">'[Getter/Setter]'</span><span class="s1">, </span><span class="s4">'special'</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">str = ctx.stylize(</span><span class="s4">'[Getter]'</span><span class="s1">, </span><span class="s4">'special'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(desc.set) {</span>
        <span class="s1">str = ctx.stylize(</span><span class="s4">'[Setter]'</span><span class="s1">, </span><span class="s4">'special'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!hasOwnProperty(visibleKeys, key)) {</span>
      <span class="s1">name = </span><span class="s4">'[' </span><span class="s1">+ key + </span><span class="s4">']'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!str) {</span>
      <span class="s2">if </span><span class="s1">(ctx.seen.indexOf(desc.value) &lt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(isNull(recurseTimes)) {</span>
          <span class="s1">str = formatValue(ctx, desc.value, </span><span class="s2">null</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">str = formatValue(ctx, desc.value, recurseTimes - </span><span class="s3">1</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(str.indexOf(</span><span class="s4">'</span><span class="s5">\n</span><span class="s4">'</span><span class="s1">) &gt; -</span><span class="s3">1</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(array) {</span>
            <span class="s1">str = str</span>
              <span class="s1">.split(</span><span class="s4">'</span><span class="s5">\n</span><span class="s4">'</span><span class="s1">)</span>
              <span class="s1">.map(</span><span class="s2">function </span><span class="s1">(line) {</span>
                <span class="s2">return </span><span class="s4">'  ' </span><span class="s1">+ line;</span>
              <span class="s1">})</span>
              <span class="s1">.join(</span><span class="s4">'</span><span class="s5">\n</span><span class="s4">'</span><span class="s1">)</span>
              <span class="s1">.substr(</span><span class="s3">2</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">str =</span>
              <span class="s4">'</span><span class="s5">\n</span><span class="s4">' </span><span class="s1">+</span>
              <span class="s1">str</span>
                <span class="s1">.split(</span><span class="s4">'</span><span class="s5">\n</span><span class="s4">'</span><span class="s1">)</span>
                <span class="s1">.map(</span><span class="s2">function </span><span class="s1">(line) {</span>
                  <span class="s2">return </span><span class="s4">'   ' </span><span class="s1">+ line;</span>
                <span class="s1">})</span>
                <span class="s1">.join(</span><span class="s4">'</span><span class="s5">\n</span><span class="s4">'</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">str = ctx.stylize(</span><span class="s4">'[Circular]'</span><span class="s1">, </span><span class="s4">'special'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isUndefined(name)) {</span>
      <span class="s2">if </span><span class="s1">(array &amp;&amp; key.match(/^\d+$/)) {</span>
        <span class="s2">return </span><span class="s1">str;</span>
      <span class="s1">}</span>
      <span class="s1">name = JSON.stringify(</span><span class="s4">'' </span><span class="s1">+ key);</span>
      <span class="s2">if </span><span class="s1">(name.match(/^</span><span class="s4">&quot;([a-zA-Z_][a-zA-Z_0-9]*)&quot;</span><span class="s1">$/)) {</span>
        <span class="s1">name = name.substr(</span><span class="s3">1</span><span class="s1">, name.length - </span><span class="s3">2</span><span class="s1">);</span>
        <span class="s1">name = ctx.stylize(name, </span><span class="s4">'name'</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">name = name</span>
          <span class="s1">.replace(/</span><span class="s4">'/g, &quot;</span><span class="s5">\\</span><span class="s4">'&quot;)</span>
          <span class="s1">.replace(/\\</span><span class="s4">&quot;/g, '&quot;')</span>
          <span class="s1">.replace(/(^</span><span class="s4">&quot;|&quot;</span><span class="s1">$)/g, </span><span class="s4">&quot;'&quot;</span><span class="s1">);</span>
        <span class="s1">name = ctx.stylize(name, </span><span class="s4">'string'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">name + </span><span class="s4">': ' </span><span class="s1">+ str;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">reduceToSingleString(output, base, braces) {</span>
    <span class="s2">var </span><span class="s1">numLinesEst = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">length = output.reduce(</span><span class="s2">function </span><span class="s1">(prev, cur) {</span>
      <span class="s1">numLinesEst++;</span>
      <span class="s2">if </span><span class="s1">(cur.indexOf(</span><span class="s4">'</span><span class="s5">\n</span><span class="s4">'</span><span class="s1">) &gt;= </span><span class="s3">0</span><span class="s1">) numLinesEst++;</span>
      <span class="s2">return </span><span class="s1">prev + cur.replace(/\u001b\[\d\d?m/g, </span><span class="s4">''</span><span class="s1">).length + </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s1">}, </span><span class="s3">0</span><span class="s1">);</span>

    <span class="s2">if </span><span class="s1">(length &gt; </span><span class="s3">60</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">braces[</span><span class="s3">0</span><span class="s1">] +</span>
        <span class="s1">(base === </span><span class="s4">'' </span><span class="s1">? </span><span class="s4">'' </span><span class="s1">: base + </span><span class="s4">'</span><span class="s5">\n </span><span class="s4">'</span><span class="s1">) +</span>
        <span class="s4">' ' </span><span class="s1">+</span>
        <span class="s1">output.join(</span><span class="s4">',</span><span class="s5">\n  </span><span class="s4">'</span><span class="s1">) +</span>
        <span class="s4">' ' </span><span class="s1">+</span>
        <span class="s1">braces[</span><span class="s3">1</span><span class="s1">]</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">braces[</span><span class="s3">0</span><span class="s1">] + base + </span><span class="s4">' ' </span><span class="s1">+ output.join(</span><span class="s4">', '</span><span class="s1">) + </span><span class="s4">' ' </span><span class="s1">+ braces[</span><span class="s3">1</span><span class="s1">];</span>
  <span class="s1">}</span>

  <span class="s0">// NOTE: These type checking functions intentionally don't use `instanceof`</span>
  <span class="s0">// because it is fragile and can be easily faked with `Object.create()`.</span>
  <span class="s2">function </span><span class="s1">isArray(ar) {</span>
    <span class="s2">return </span><span class="s1">Array.isArray(ar);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isBoolean(arg) {</span>
    <span class="s2">return typeof </span><span class="s1">arg === </span><span class="s4">'boolean'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isNull(arg) {</span>
    <span class="s2">return </span><span class="s1">arg === </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isNullOrUndefined(arg) {</span>
    <span class="s2">return </span><span class="s1">arg == </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isNumber(arg) {</span>
    <span class="s2">return typeof </span><span class="s1">arg === </span><span class="s4">'number'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isString(arg) {</span>
    <span class="s2">return typeof </span><span class="s1">arg === </span><span class="s4">'string'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isSymbol(arg) {</span>
    <span class="s2">return typeof </span><span class="s1">arg === </span><span class="s4">'symbol'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isUndefined(arg) {</span>
    <span class="s2">return </span><span class="s1">arg === </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isRegExp(re) {</span>
    <span class="s2">return </span><span class="s1">isObject(re) &amp;&amp; objectToString(re) === </span><span class="s4">'[object RegExp]'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isObject(arg) {</span>
    <span class="s2">return typeof </span><span class="s1">arg === </span><span class="s4">'object' </span><span class="s1">&amp;&amp; arg !== </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isDate(d) {</span>
    <span class="s2">return </span><span class="s1">isObject(d) &amp;&amp; objectToString(d) === </span><span class="s4">'[object Date]'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isError(e) {</span>
    <span class="s2">return </span><span class="s1">(</span>
      <span class="s1">isObject(e) &amp;&amp;</span>
      <span class="s1">(objectToString(e) === </span><span class="s4">'[object Error]' </span><span class="s1">|| e </span><span class="s2">instanceof </span><span class="s1">Error)</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isFunction(arg) {</span>
    <span class="s2">return typeof </span><span class="s1">arg === </span><span class="s4">'function'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">objectToString(o) {</span>
    <span class="s2">return </span><span class="s1">Object.prototype.toString.call(o);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">hasOwnProperty(obj, prop) {</span>
    <span class="s2">return </span><span class="s1">Object.prototype.hasOwnProperty.call(obj, prop);</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">inspect;</span>
<span class="s1">})();</span>

<span class="s1">const OBJECT_COLUMN_NAME = </span><span class="s4">'(index)'</span><span class="s1">;</span>
<span class="s1">const LOG_LEVELS = {</span>
  <span class="s1">trace: </span><span class="s3">0</span><span class="s1">,</span>
  <span class="s1">info: </span><span class="s3">1</span><span class="s1">,</span>
  <span class="s1">warn: </span><span class="s3">2</span><span class="s1">,</span>
  <span class="s1">error: </span><span class="s3">3</span><span class="s1">,</span>
<span class="s1">};</span>
<span class="s1">const INSPECTOR_LEVELS = [];</span>
<span class="s1">INSPECTOR_LEVELS[LOG_LEVELS.trace] = </span><span class="s4">'debug'</span><span class="s1">;</span>
<span class="s1">INSPECTOR_LEVELS[LOG_LEVELS.info] = </span><span class="s4">'log'</span><span class="s1">;</span>
<span class="s1">INSPECTOR_LEVELS[LOG_LEVELS.warn] = </span><span class="s4">'warning'</span><span class="s1">;</span>
<span class="s1">INSPECTOR_LEVELS[LOG_LEVELS.error] = </span><span class="s4">'error'</span><span class="s1">;</span>

<span class="s0">// Strip the inner function in getNativeLogFunction(), if in dev also</span>
<span class="s0">// strip method printing to originalConsole.</span>
<span class="s1">const INSPECTOR_FRAMES_TO_SKIP = __DEV__ ? </span><span class="s3">2 </span><span class="s1">: </span><span class="s3">1</span><span class="s1">;</span>

<span class="s2">function </span><span class="s1">getNativeLogFunction(level) {</span>
  <span class="s2">return function </span><span class="s1">() {</span>
    <span class="s1">let str;</span>
    <span class="s2">if </span><span class="s1">(arguments.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">arguments[</span><span class="s3">0</span><span class="s1">] === </span><span class="s4">'string'</span><span class="s1">) {</span>
      <span class="s1">str = arguments[</span><span class="s3">0</span><span class="s1">];</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">str = Array.prototype.map</span>
        <span class="s1">.call(arguments, </span><span class="s2">function </span><span class="s1">(arg) {</span>
          <span class="s2">return </span><span class="s1">inspect(arg, {depth: </span><span class="s3">10</span><span class="s1">});</span>
        <span class="s1">})</span>
        <span class="s1">.join(</span><span class="s4">', '</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">// TRICKY</span>
    <span class="s0">// If more than one argument is provided, the code above collapses them all</span>
    <span class="s0">// into a single formatted string. This transform wraps string arguments in</span>
    <span class="s0">// single quotes (e.g. &quot;foo&quot; -&gt; &quot;'foo'&quot;) which then breaks the &quot;Warning:&quot;</span>
    <span class="s0">// check below. So it's important that we look at the first argument, rather</span>
    <span class="s0">// than the formatted argument string.</span>
    <span class="s1">const firstArg = arguments[</span><span class="s3">0</span><span class="s1">];</span>

    <span class="s1">let logLevel = level;</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s2">typeof </span><span class="s1">firstArg === </span><span class="s4">'string' </span><span class="s1">&amp;&amp;</span>
      <span class="s1">firstArg.slice(</span><span class="s3">0</span><span class="s1">, </span><span class="s3">9</span><span class="s1">) === </span><span class="s4">'Warning: ' </span><span class="s1">&amp;&amp;</span>
      <span class="s1">logLevel &gt;= LOG_LEVELS.error</span>
    <span class="s1">) {</span>
      <span class="s0">// React warnings use console.error so that a stack trace is shown,</span>
      <span class="s0">// but we don't (currently) want these to show a redbox</span>
      <span class="s0">// (Note: Logic duplicated in ExceptionsManager.js.)</span>
      <span class="s1">logLevel = LOG_LEVELS.warn;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(global.__inspectorLog) {</span>
      <span class="s1">global.__inspectorLog(</span>
        <span class="s1">INSPECTOR_LEVELS[logLevel],</span>
        <span class="s1">str,</span>
        <span class="s1">[].slice.call(arguments),</span>
        <span class="s1">INSPECTOR_FRAMES_TO_SKIP,</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(groupStack.length) {</span>
      <span class="s1">str = groupFormat(</span><span class="s4">''</span><span class="s1">, str);</span>
    <span class="s1">}</span>
    <span class="s1">global.nativeLoggingHook(str, logLevel);</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">repeat(element, n) {</span>
  <span class="s2">return </span><span class="s1">Array.apply(</span><span class="s2">null</span><span class="s1">, Array(n)).map(</span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">element;</span>
  <span class="s1">});</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">consoleTablePolyfill(rows) {</span>
  <span class="s0">// convert object -&gt; array</span>
  <span class="s2">if </span><span class="s1">(!Array.isArray(rows)) {</span>
    <span class="s2">var </span><span class="s1">data = rows;</span>
    <span class="s1">rows = [];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">data) {</span>
      <span class="s2">if </span><span class="s1">(data.hasOwnProperty(key)) {</span>
        <span class="s2">var </span><span class="s1">row = data[key];</span>
        <span class="s1">row[OBJECT_COLUMN_NAME] = key;</span>
        <span class="s1">rows.push(row);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(rows.length === </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s1">global.nativeLoggingHook(</span><span class="s4">''</span><span class="s1">, LOG_LEVELS.info);</span>
    <span class="s2">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">columns = Object.keys(rows[</span><span class="s3">0</span><span class="s1">]).sort();</span>
  <span class="s2">var </span><span class="s1">stringRows = [];</span>
  <span class="s2">var </span><span class="s1">columnWidths = [];</span>

  <span class="s0">// Convert each cell to a string. Also</span>
  <span class="s0">// figure out max cell width for each column</span>
  <span class="s1">columns.forEach(</span><span class="s2">function </span><span class="s1">(k, i) {</span>
    <span class="s1">columnWidths[i] = k.length;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">j = </span><span class="s3">0</span><span class="s1">; j &lt; rows.length; j++) {</span>
      <span class="s2">var </span><span class="s1">cellStr = (rows[j][k] || </span><span class="s4">'?'</span><span class="s1">).toString();</span>
      <span class="s1">stringRows[j] = stringRows[j] || [];</span>
      <span class="s1">stringRows[j][i] = cellStr;</span>
      <span class="s1">columnWidths[i] = Math.max(columnWidths[i], cellStr.length);</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s0">// Join all elements in the row into a single string with | separators</span>
  <span class="s0">// (appends extra spaces to each cell to make separators  | aligned)</span>
  <span class="s2">function </span><span class="s1">joinRow(row, space) {</span>
    <span class="s2">var </span><span class="s1">cells = row.map(</span><span class="s2">function </span><span class="s1">(cell, i) {</span>
      <span class="s2">var </span><span class="s1">extraSpaces = repeat(</span><span class="s4">' '</span><span class="s1">, columnWidths[i] - cell.length).join(</span><span class="s4">''</span><span class="s1">);</span>
      <span class="s2">return </span><span class="s1">cell + extraSpaces;</span>
    <span class="s1">});</span>
    <span class="s1">space = space || </span><span class="s4">' '</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">cells.join(space + </span><span class="s4">'|' </span><span class="s1">+ space);</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">separators = columnWidths.map(</span><span class="s2">function </span><span class="s1">(columnWidth) {</span>
    <span class="s2">return </span><span class="s1">repeat(</span><span class="s4">'-'</span><span class="s1">, columnWidth).join(</span><span class="s4">''</span><span class="s1">);</span>
  <span class="s1">});</span>
  <span class="s2">var </span><span class="s1">separatorRow = joinRow(separators, </span><span class="s4">'-'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">header = joinRow(columns);</span>
  <span class="s2">var </span><span class="s1">table = [header, separatorRow];</span>

  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; rows.length; i++) {</span>
    <span class="s1">table.push(joinRow(stringRows[i]));</span>
  <span class="s1">}</span>

  <span class="s0">// Notice extra empty line at the beginning.</span>
  <span class="s0">// Native logging hook adds &quot;RCTLog &gt;&quot; at the front of every</span>
  <span class="s0">// logged string, which would shift the header and screw up</span>
  <span class="s0">// the table</span>
  <span class="s1">global.nativeLoggingHook(</span><span class="s4">'</span><span class="s5">\n</span><span class="s4">' </span><span class="s1">+ table.join(</span><span class="s4">'</span><span class="s5">\n</span><span class="s4">'</span><span class="s1">), LOG_LEVELS.info);</span>
<span class="s1">}</span>

<span class="s1">const GROUP_PAD = </span><span class="s4">'</span><span class="s5">\u2502</span><span class="s4">'</span><span class="s1">; </span><span class="s0">// Box light vertical</span>
<span class="s1">const GROUP_OPEN = </span><span class="s4">'</span><span class="s5">\u2510</span><span class="s4">'</span><span class="s1">; </span><span class="s0">// Box light down+left</span>
<span class="s1">const GROUP_CLOSE = </span><span class="s4">'</span><span class="s5">\u2518</span><span class="s4">'</span><span class="s1">; </span><span class="s0">// Box light up+left</span>

<span class="s1">const groupStack = [];</span>

<span class="s2">function </span><span class="s1">groupFormat(prefix, msg) {</span>
  <span class="s0">// Insert group formatting before the console message</span>
  <span class="s2">return </span><span class="s1">groupStack.join(</span><span class="s4">''</span><span class="s1">) + prefix + </span><span class="s4">' ' </span><span class="s1">+ (msg || </span><span class="s4">''</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">consoleGroupPolyfill(label) {</span>
  <span class="s1">global.nativeLoggingHook(groupFormat(GROUP_OPEN, label), LOG_LEVELS.info);</span>
  <span class="s1">groupStack.push(GROUP_PAD);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">consoleGroupCollapsedPolyfill(label) {</span>
  <span class="s1">global.nativeLoggingHook(groupFormat(GROUP_CLOSE, label), LOG_LEVELS.info);</span>
  <span class="s1">groupStack.push(GROUP_PAD);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">consoleGroupEndPolyfill() {</span>
  <span class="s1">groupStack.pop();</span>
  <span class="s1">global.nativeLoggingHook(groupFormat(GROUP_CLOSE), LOG_LEVELS.info);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">consoleAssertPolyfill(expression, label) {</span>
  <span class="s2">if </span><span class="s1">(!expression) {</span>
    <span class="s1">global.nativeLoggingHook(</span><span class="s4">'Assertion failed: ' </span><span class="s1">+ label, LOG_LEVELS.error);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">if </span><span class="s1">(global.nativeLoggingHook) {</span>
  <span class="s1">const originalConsole = global.console;</span>
  <span class="s0">// Preserve the original `console` as `originalConsole`</span>
  <span class="s2">if </span><span class="s1">(__DEV__ &amp;&amp; originalConsole) {</span>
    <span class="s1">const descriptor = Object.getOwnPropertyDescriptor(global, </span><span class="s4">'console'</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(descriptor) {</span>
      <span class="s1">Object.defineProperty(global, </span><span class="s4">'originalConsole'</span><span class="s1">, descriptor);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">global.console = {</span>
    <span class="s1">error: getNativeLogFunction(LOG_LEVELS.error),</span>
    <span class="s1">info: getNativeLogFunction(LOG_LEVELS.info),</span>
    <span class="s1">log: getNativeLogFunction(LOG_LEVELS.info),</span>
    <span class="s1">warn: getNativeLogFunction(LOG_LEVELS.warn),</span>
    <span class="s1">trace: getNativeLogFunction(LOG_LEVELS.trace),</span>
    <span class="s1">debug: getNativeLogFunction(LOG_LEVELS.trace),</span>
    <span class="s1">table: consoleTablePolyfill,</span>
    <span class="s1">group: consoleGroupPolyfill,</span>
    <span class="s1">groupEnd: consoleGroupEndPolyfill,</span>
    <span class="s1">groupCollapsed: consoleGroupCollapsedPolyfill,</span>
    <span class="s1">assert: consoleAssertPolyfill,</span>
  <span class="s1">};</span>

  <span class="s1">Object.defineProperty(console, </span><span class="s4">'_isPolyfilled'</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
  <span class="s1">});</span>

  <span class="s0">// If available, also call the original `console` method since that is</span>
  <span class="s0">// sometimes useful. Ex: on OS X, this will let you see rich output in</span>
  <span class="s0">// the Safari Web Inspector console.</span>
  <span class="s2">if </span><span class="s1">(__DEV__ &amp;&amp; originalConsole) {</span>
    <span class="s1">Object.keys(console).forEach(methodName =&gt; {</span>
      <span class="s1">const reactNativeMethod = console[methodName];</span>
      <span class="s2">if </span><span class="s1">(originalConsole[methodName]) {</span>
        <span class="s1">console[methodName] = </span><span class="s2">function </span><span class="s1">() {</span>
          <span class="s1">originalConsole[methodName](...arguments);</span>
          <span class="s1">reactNativeMethod.apply(console, arguments);</span>
        <span class="s1">};</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s0">// The following methods are not supported by this polyfill but</span>
    <span class="s0">// we still should pass them to original console if they are</span>
    <span class="s0">// supported by it.</span>
    <span class="s1">[</span><span class="s4">'clear'</span><span class="s1">, </span><span class="s4">'dir'</span><span class="s1">, </span><span class="s4">'dirxml'</span><span class="s1">, </span><span class="s4">'profile'</span><span class="s1">, </span><span class="s4">'profileEnd'</span><span class="s1">].forEach(methodName =&gt; {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">originalConsole[methodName] === </span><span class="s4">'function'</span><span class="s1">) {</span>
        <span class="s1">console[methodName] = </span><span class="s2">function </span><span class="s1">() {</span>
          <span class="s1">originalConsole[methodName](...arguments);</span>
        <span class="s1">};</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s2">else if </span><span class="s1">(!global.console) {</span>
  <span class="s2">function </span><span class="s1">stub() {}</span>
  <span class="s1">const log = global.print || stub;</span>

  <span class="s1">global.console = {</span>
    <span class="s1">debug: log,</span>
    <span class="s1">error: log,</span>
    <span class="s1">info: log,</span>
    <span class="s1">log: log,</span>
    <span class="s1">trace: log,</span>
    <span class="s1">warn: log,</span>
    <span class="s1">assert(expression, label) {</span>
      <span class="s2">if </span><span class="s1">(!expression) {</span>
        <span class="s1">log(</span><span class="s4">'Assertion failed: ' </span><span class="s1">+ label);</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">clear: stub,</span>
    <span class="s1">dir: stub,</span>
    <span class="s1">dirxml: stub,</span>
    <span class="s1">group: stub,</span>
    <span class="s1">groupCollapsed: stub,</span>
    <span class="s1">groupEnd: stub,</span>
    <span class="s1">profile: stub,</span>
    <span class="s1">profileEnd: stub,</span>
    <span class="s1">table: stub,</span>
  <span class="s1">};</span>

  <span class="s1">Object.defineProperty(console, </span><span class="s4">'_isPolyfilled'</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
  <span class="s1">});</span>
<span class="s1">}</span>
</pre>
</body>
</html>
<html>
<head>
<title>transform.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
transform.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperSkipTransparentExpressionWrappers&quot;</span><span class="s0">,</span><span class="s1">&quot;_util&quot;</span><span class="s0">,</span><span class="s1">&quot;isSimpleMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;skipTransparentExprWrapperNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;needsMemoize&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;optionalPath&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptionalMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptionalCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;childPath&quot;</span><span class="s0">,</span><span class="s1">&quot;skipTransparentExprWrappers&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;NULLISH_CHECK&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;NULLISH_CHECK_NO_DDA&quot;</span><span class="s0">,</span><span class="s1">&quot;NULLISH_CHECK_NEG&quot;</span><span class="s0">,</span><span class="s1">&quot;NULLISH_CHECK_NO_DDA_NEG&quot;</span><span class="s0">,</span><span class="s1">&quot;transformOptionalChain&quot;</span><span class="s0">,</span><span class="s1">&quot;pureGetters&quot;</span><span class="s0">,</span><span class="s1">&quot;noDocumentAll&quot;</span><span class="s0">,</span><span class="s1">&quot;replacementPath&quot;</span><span class="s0">,</span><span class="s1">&quot;ifNullish&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapLast&quot;</span><span class="s0">,</span><span class="s1">&quot;isPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;optionals&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;checks&quot;</span><span class="s0">,</span><span class="s1">&quot;tmpVar&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;isCall&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;chainWithTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;chain&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;check&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;numericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifierBasedOnNode&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;memoized&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeGenerateMemoised&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;ifNullishBoolean&quot;</span><span class="s0">,</span><span class="s1">&quot;isBooleanLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;ifNullishFalse&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;tpl&quot;</span><span class="s0">,</span><span class="s1">&quot;logicalOp&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;expr&quot;</span><span class="s0">,</span><span class="s1">&quot;logicalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;conditionalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;transform&quot;</span><span class="s0">,</span><span class="s1">&quot;assumptions&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeWrapped&quot;</span><span class="s0">,</span><span class="s1">&quot;findOutermostTransparentParent&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;booleanLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;replacement&quot;</span><span class="s0">,</span><span class="s1">&quot;_baseRef&quot;</span><span class="s0">,</span><span class="s1">&quot;baseRef&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;willPathCastToBoolean&quot;</span><span class="s0">,</span><span class="s1">&quot;buildUndefinedNode&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/transform.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { types as t, template } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">skipTransparentExprWrapperNodes,</span><span class="s3">\n  </span><span class="s1">skipTransparentExprWrappers,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-skip-transparent-expression-wrappers</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { willPathCastToBoolean, findOutermostTransparentParent } from </span><span class="s3">\&quot;</span><span class="s1">./util</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">function isSimpleMemberExpression(</span><span class="s3">\n  </span><span class="s1">expression: t.Expression | t.Super,</span><span class="s3">\n</span><span class="s1">): expression is t.Identifier | t.Super | t.MemberExpression {</span><span class="s3">\n  </span><span class="s1">expression = skipTransparentExprWrapperNodes(expression);</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">t.isIdentifier(expression) ||</span><span class="s3">\n    </span><span class="s1">t.isSuper(expression) ||</span><span class="s3">\n    </span><span class="s1">(t.isMemberExpression(expression) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!expression.computed &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isSimpleMemberExpression(expression.object))</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Test if a given optional chain `path` needs to be memoized</span><span class="s3">\n </span><span class="s1">* @param {NodePath} path</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function needsMemoize(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.OptionalCallExpression | t.OptionalMemberExpression&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let optionalPath: NodePath = path;</span><span class="s3">\n  </span><span class="s1">const { scope } = path;</span><span class="s3">\n  </span><span class="s1">while (</span><span class="s3">\n    </span><span class="s1">optionalPath.isOptionalMemberExpression() ||</span><span class="s3">\n    </span><span class="s1">optionalPath.isOptionalCallExpression()</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const { node } = optionalPath;</span><span class="s3">\n    </span><span class="s1">const childPath = skipTransparentExprWrappers(</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error isOptionalMemberExpression does not work with NodePath union</span><span class="s3">\n      </span><span class="s1">optionalPath.isOptionalMemberExpression()</span><span class="s3">\n        </span><span class="s1">? optionalPath.get(</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">: optionalPath.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (node.optional) {</span><span class="s3">\n      </span><span class="s1">return !scope.isStatic(childPath.node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">optionalPath = childPath;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const NULLISH_CHECK = template.expression(</span><span class="s3">\n  </span><span class="s1">`%%check%% === null || %%ref%% === void 0`,</span><span class="s3">\n</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const NULLISH_CHECK_NO_DDA = template.expression(`%%check%% == null`);</span><span class="s3">\n</span><span class="s1">const NULLISH_CHECK_NEG = template.expression(</span><span class="s3">\n  </span><span class="s1">`%%check%% !== null &amp;&amp; %%ref%% !== void 0`,</span><span class="s3">\n</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const NULLISH_CHECK_NO_DDA_NEG = template.expression(`%%check%% != null`);</span><span class="s3">\n\n</span><span class="s1">interface OptionalChainAssumptions {</span><span class="s3">\n  </span><span class="s1">pureGetters: boolean;</span><span class="s3">\n  </span><span class="s1">noDocumentAll: boolean;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function transformOptionalChain(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.OptionalCallExpression | t.OptionalMemberExpression&gt;,</span><span class="s3">\n  </span><span class="s1">{ pureGetters, noDocumentAll }: OptionalChainAssumptions,</span><span class="s3">\n  </span><span class="s1">replacementPath: NodePath&lt;t.Expression&gt;,</span><span class="s3">\n  </span><span class="s1">ifNullish: t.Expression,</span><span class="s3">\n  </span><span class="s1">wrapLast?: (value: t.Expression) =&gt; t.Expression,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { scope } = path;</span><span class="s3">\n\n  </span><span class="s1">// Replace `function (a, x = a.b?.c) {}` to `function (a, x = (() =&gt; a.b?.c)() ){}`</span><span class="s3">\n  </span><span class="s1">// so the temporary variable can be injected in correct scope</span><span class="s3">\n  </span><span class="s1">if (scope.path.isPattern() &amp;&amp; needsMemoize(path)) {</span><span class="s3">\n    </span><span class="s1">replacementPath.replaceWith(</span><span class="s3">\n      </span><span class="s1">template.expression.ast`(() =&gt; ${replacementPath.node})()`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">// The injected optional chain will be queued and eventually transformed when visited</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const optionals = [];</span><span class="s3">\n\n  </span><span class="s1">let optionalPath = path;</span><span class="s3">\n  </span><span class="s1">while (</span><span class="s3">\n    </span><span class="s1">optionalPath.isOptionalMemberExpression() ||</span><span class="s3">\n    </span><span class="s1">optionalPath.isOptionalCallExpression()</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const { node } = optionalPath;</span><span class="s3">\n    </span><span class="s1">if (node.optional) {</span><span class="s3">\n      </span><span class="s1">optionals.push(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error isOptionalMemberExpression does not work with NodePath union</span><span class="s3">\n    </span><span class="s1">if (optionalPath.isOptionalMemberExpression()) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) avoid changing more type</span><span class="s3">\n      </span><span class="s1">optionalPath.node.type = </span><span class="s3">\&quot;</span><span class="s1">MemberExpression</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s3">\n      </span><span class="s1">optionalPath = skipTransparentExprWrappers(optionalPath.get(</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">} else if (optionalPath.isOptionalCallExpression()) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) avoid changing more type</span><span class="s3">\n      </span><span class="s1">optionalPath.node.type = </span><span class="s3">\&quot;</span><span class="s1">CallExpression</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s3">\n      </span><span class="s1">optionalPath = skipTransparentExprWrappers(optionalPath.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (optionals.length === 0) {</span><span class="s3">\n    </span><span class="s1">// Malformed AST: there was an OptionalMemberExpression node</span><span class="s3">\n    </span><span class="s1">// with no actual optional elements.</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const checks = [];</span><span class="s3">\n\n  </span><span class="s1">let tmpVar;</span><span class="s3">\n\n  </span><span class="s1">for (let i = optionals.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n    </span><span class="s1">const node = optionals[i] as unknown as</span><span class="s3">\n      </span><span class="s1">| t.MemberExpression</span><span class="s3">\n      </span><span class="s1">| t.CallExpression;</span><span class="s3">\n\n    </span><span class="s1">const isCall = t.isCallExpression(node);</span><span class="s3">\n\n    </span><span class="s1">const chainWithTypes = isCall</span><span class="s3">\n      </span><span class="s1">? // V8 intrinsics must not be an optional call</span><span class="s3">\n        </span><span class="s1">(node.callee as t.Expression)</span><span class="s3">\n      </span><span class="s1">: node.object;</span><span class="s3">\n    </span><span class="s1">const chain = skipTransparentExprWrapperNodes(chainWithTypes);</span><span class="s3">\n\n    </span><span class="s1">let ref;</span><span class="s3">\n    </span><span class="s1">let check;</span><span class="s3">\n    </span><span class="s1">if (isCall &amp;&amp; t.isIdentifier(chain, { name: </span><span class="s3">\&quot;</span><span class="s1">eval</span><span class="s3">\&quot; </span><span class="s1">})) {</span><span class="s3">\n      </span><span class="s1">check = ref = chain;</span><span class="s3">\n      </span><span class="s1">// `eval?.()` is an indirect eval call transformed to `(0,eval)()`</span><span class="s3">\n      </span><span class="s1">node.callee = t.sequenceExpression([t.numericLiteral(0), ref]);</span><span class="s3">\n    </span><span class="s1">} else if (pureGetters &amp;&amp; isCall &amp;&amp; isSimpleMemberExpression(chain)) {</span><span class="s3">\n      </span><span class="s1">// If we assume getters are pure (avoiding a Function#call) and we are at the call,</span><span class="s3">\n      </span><span class="s1">// we can avoid a needless memoize. We only do this if the callee is a simple member</span><span class="s3">\n      </span><span class="s1">// expression, to avoid multiple calls to nested call expressions.</span><span class="s3">\n      </span><span class="s1">check = ref = node.callee;</span><span class="s3">\n    </span><span class="s1">} else if (scope.isStatic(chain)) {</span><span class="s3">\n      </span><span class="s1">check = ref = chainWithTypes;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// We cannot re-use the tmpVar for calls, because we need to</span><span class="s3">\n      </span><span class="s1">// store both the method and the receiver.</span><span class="s3">\n      </span><span class="s1">if (!tmpVar || isCall) {</span><span class="s3">\n        </span><span class="s1">tmpVar = scope.generateUidIdentifierBasedOnNode(chain);</span><span class="s3">\n        </span><span class="s1">scope.push({ id: t.cloneNode(tmpVar) });</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">ref = tmpVar;</span><span class="s3">\n      </span><span class="s1">check = t.assignmentExpression(</span><span class="s3">\n        \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">t.cloneNode(tmpVar),</span><span class="s3">\n        </span><span class="s1">// Here `chainWithTypes` MUST NOT be cloned because it could be</span><span class="s3">\n        </span><span class="s1">// updated when generating the memoised context of a call</span><span class="s3">\n        </span><span class="s1">// expression. It must be an Expression when `ref` is an identifier</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion</span><span class="s3">\n        </span><span class="s1">chainWithTypes as t.Expression,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">isCall ? (node.callee = ref) : (node.object = ref);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Ensure call expressions have the proper `this`</span><span class="s3">\n    </span><span class="s1">// `foo.bar()` has context `foo`.</span><span class="s3">\n    </span><span class="s1">if (isCall &amp;&amp; t.isMemberExpression(chain)) {</span><span class="s3">\n      </span><span class="s1">if (pureGetters &amp;&amp; isSimpleMemberExpression(chain)) {</span><span class="s3">\n        </span><span class="s1">// To avoid a Function#call, we can instead re-grab the property from the context object.</span><span class="s3">\n        </span><span class="s1">// `a.?b.?()` translates roughly to `_a.b != null &amp;&amp; _a.b()`</span><span class="s3">\n        </span><span class="s1">node.callee = chainWithTypes;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Otherwise, we need to memoize the context object, and change the call into a Function#call.</span><span class="s3">\n        </span><span class="s1">// `a.?b.?()` translates roughly to `(_b = _a.b) != null &amp;&amp; _b.call(_a)`</span><span class="s3">\n        </span><span class="s1">const { object } = chain;</span><span class="s3">\n        </span><span class="s1">let context: t.Expression;</span><span class="s3">\n        </span><span class="s1">if (t.isSuper(object)) {</span><span class="s3">\n          </span><span class="s1">context = t.thisExpression();</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const memoized = scope.maybeGenerateMemoised(object);</span><span class="s3">\n          </span><span class="s1">if (memoized) {</span><span class="s3">\n            </span><span class="s1">context = memoized;</span><span class="s3">\n            </span><span class="s1">chain.object = t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, memoized, object);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">context = object;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">node.arguments.unshift(t.cloneNode(context));</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error node.callee can not be an V8IntrinsicIdentifier: V8 intrinsic is disallowed in optional chain</span><span class="s3">\n        </span><span class="s1">node.callee = t.memberExpression(node.callee, t.identifier(</span><span class="s3">\&quot;</span><span class="s1">call</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const data = { check: t.cloneNode(check), ref: t.cloneNode(ref) };</span><span class="s3">\n    </span><span class="s1">// We make `ref` non-enumerable, so that @babel/template doesn't throw</span><span class="s3">\n    </span><span class="s1">// in the noDocumentAll template if it's not used.</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(data, </span><span class="s3">\&quot;</span><span class="s1">ref</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: false });</span><span class="s3">\n    </span><span class="s1">checks.push(data);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let result = replacementPath.node;</span><span class="s3">\n  </span><span class="s1">if (wrapLast) result = wrapLast(result);</span><span class="s3">\n\n  </span><span class="s1">const ifNullishBoolean = t.isBooleanLiteral(ifNullish);</span><span class="s3">\n  </span><span class="s1">const ifNullishFalse = ifNullishBoolean &amp;&amp; ifNullish.value === false;</span><span class="s3">\n\n  </span><span class="s1">// prettier-ignore</span><span class="s3">\n  </span><span class="s1">const tpl = ifNullishFalse</span><span class="s3">\n    </span><span class="s1">? (noDocumentAll ? NULLISH_CHECK_NO_DDA_NEG : NULLISH_CHECK_NEG)</span><span class="s3">\n    </span><span class="s1">: (noDocumentAll ? NULLISH_CHECK_NO_DDA : NULLISH_CHECK);</span><span class="s3">\n  </span><span class="s1">const logicalOp = ifNullishFalse ? </span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">||</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n  </span><span class="s1">const check = checks</span><span class="s3">\n    </span><span class="s1">.map(tpl)</span><span class="s3">\n    </span><span class="s1">.reduce((expr, check) =&gt; t.logicalExpression(logicalOp, expr, check));</span><span class="s3">\n\n  </span><span class="s1">replacementPath.replaceWith(</span><span class="s3">\n    </span><span class="s1">ifNullishBoolean</span><span class="s3">\n      </span><span class="s1">? t.logicalExpression(logicalOp, check, result)</span><span class="s3">\n      </span><span class="s1">: t.conditionalExpression(check, ifNullish, result),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function transform(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.OptionalCallExpression | t.OptionalMemberExpression&gt;,</span><span class="s3">\n  </span><span class="s1">assumptions: OptionalChainAssumptions,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { scope } = path;</span><span class="s3">\n\n  </span><span class="s1">// maybeWrapped points to the outermost transparent expression wrapper</span><span class="s3">\n  </span><span class="s1">// or the path itself</span><span class="s3">\n  </span><span class="s1">const maybeWrapped = findOutermostTransparentParent(path);</span><span class="s3">\n  </span><span class="s1">const { parentPath } = maybeWrapped;</span><span class="s3">\n\n  </span><span class="s1">if (parentPath.isUnaryExpression({ operator: </span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot; </span><span class="s1">})) {</span><span class="s3">\n    </span><span class="s1">transformOptionalChain(</span><span class="s3">\n      </span><span class="s1">path,</span><span class="s3">\n      </span><span class="s1">assumptions,</span><span class="s3">\n      </span><span class="s1">parentPath,</span><span class="s3">\n      </span><span class="s1">t.booleanLiteral(true),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">let wrapLast;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">parentPath.isCallExpression({ callee: maybeWrapped.node }) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// note that the first condition must implies that `path.optional` is `true`,</span><span class="s3">\n      </span><span class="s1">// otherwise the parentPath should be an OptionalCallExpression</span><span class="s3">\n      </span><span class="s1">path.isOptionalMemberExpression()</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Ensure (a?.b)() has proper `this`</span><span class="s3">\n      </span><span class="s1">wrapLast = (replacement: t.MemberExpression) =&gt; {</span><span class="s3">\n        </span><span class="s1">// `(a?.b)()` to `(a == null ? undefined : a.b.bind(a))()`</span><span class="s3">\n        </span><span class="s1">// object must not be Super as super?.foo is invalid</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion</span><span class="s3">\n        </span><span class="s1">const object = skipTransparentExprWrapperNodes(</span><span class="s3">\n          </span><span class="s1">replacement.object,</span><span class="s3">\n        </span><span class="s1">) as t.Expression;</span><span class="s3">\n        </span><span class="s1">let baseRef: t.Expression;</span><span class="s3">\n        </span><span class="s1">if (!assumptions.pureGetters || !isSimpleMemberExpression(object)) {</span><span class="s3">\n          </span><span class="s1">// memoize the context object when getters are not always pure</span><span class="s3">\n          </span><span class="s1">// or the object is not a simple member expression</span><span class="s3">\n          </span><span class="s1">// `(a?.b.c)()` to `(a == null ? undefined : (_a$b = a.b).c.bind(_a$b))()`</span><span class="s3">\n          </span><span class="s1">baseRef = scope.maybeGenerateMemoised(object);</span><span class="s3">\n          </span><span class="s1">if (baseRef) {</span><span class="s3">\n            </span><span class="s1">replacement.object = t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, baseRef, object);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return t.callExpression(</span><span class="s3">\n          </span><span class="s1">t.memberExpression(replacement, t.identifier(</span><span class="s3">\&quot;</span><span class="s1">bind</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n          </span><span class="s1">[t.cloneNode(baseRef ?? object)],</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">transformOptionalChain(</span><span class="s3">\n      </span><span class="s1">path,</span><span class="s3">\n      </span><span class="s1">assumptions,</span><span class="s3">\n      </span><span class="s1">path,</span><span class="s3">\n      </span><span class="s1">willPathCastToBoolean(maybeWrapped)</span><span class="s3">\n        </span><span class="s1">? t.booleanLiteral(false)</span><span class="s3">\n        </span><span class="s1">: scope.buildUndefinedNode(),</span><span class="s3">\n      </span><span class="s1">wrapLast,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>
<html>
<head>
<title>DrawerLayout.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
DrawerLayout.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">React = _interopRequireWildcard(require(</span><span class="s0">&quot;react&quot;</span><span class="s1">));</span>

<span class="s2">var </span><span class="s1">_invariant = _interopRequireDefault(require(</span><span class="s0">&quot;invariant&quot;</span><span class="s1">));</span>

<span class="s2">var </span><span class="s1">_reactNative = require(</span><span class="s0">&quot;react-native&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_PanGestureHandler = require(</span><span class="s0">&quot;../handlers/PanGestureHandler&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_TapGestureHandler = require(</span><span class="s0">&quot;../handlers/TapGestureHandler&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_State = require(</span><span class="s0">&quot;../State&quot;</span><span class="s1">);</span>

<span class="s2">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">default</span><span class="s1">: obj }; }</span>

<span class="s2">function </span><span class="s1">_getRequireWildcardCache() { </span><span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">; </span><span class="s2">var </span><span class="s1">cache = </span><span class="s2">new </span><span class="s1">WeakMap(); _getRequireWildcardCache = </span><span class="s2">function </span><span class="s1">() { </span><span class="s2">return </span><span class="s1">cache; }; </span><span class="s2">return </span><span class="s1">cache; }</span>

<span class="s2">function </span><span class="s1">_interopRequireWildcard(obj) { </span><span class="s2">if </span><span class="s1">(obj &amp;&amp; obj.__esModule) { </span><span class="s2">return </span><span class="s1">obj; } </span><span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">{ </span><span class="s2">default</span><span class="s1">: obj }; } </span><span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(); </span><span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) { </span><span class="s2">return </span><span class="s1">cache.get(obj); } </span><span class="s2">var </span><span class="s1">newObj = {}; </span><span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor; </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj) { </span><span class="s2">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(obj, key)) { </span><span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">; </span><span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } </span><span class="s2">else </span><span class="s1">{ newObj[key] = obj[key]; } } } newObj.</span><span class="s2">default </span><span class="s1">= obj; </span><span class="s2">if </span><span class="s1">(cache) { cache.set(obj, newObj); } </span><span class="s2">return </span><span class="s1">newObj; }</span>

<span class="s2">function </span><span class="s1">_defineProperty(obj, key, value) { </span><span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">obj) { Object.defineProperty(obj, key, { value: value, enumerable: </span><span class="s2">true</span><span class="s1">, configurable: </span><span class="s2">true</span><span class="s1">, writable: </span><span class="s2">true </span><span class="s1">}); } </span><span class="s2">else </span><span class="s1">{ obj[key] = value; } </span><span class="s2">return </span><span class="s1">obj; }</span>

<span class="s1">const DRAG_TOSS = </span><span class="s3">0.05</span><span class="s1">;</span>
<span class="s1">const IDLE = </span><span class="s0">'Idle'</span><span class="s1">;</span>
<span class="s1">const DRAGGING = </span><span class="s0">'Dragging'</span><span class="s1">;</span>
<span class="s1">const SETTLING = </span><span class="s0">'Settling'</span><span class="s1">;</span>

<span class="s1">class DrawerLayout extends React.Component {</span>
  <span class="s1">constructor(_props) {</span>
    <span class="s1">super(_props);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;openValue&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s3">0</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;onGestureEvent&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s3">0</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;accessibilityIsModalView&quot;</span><span class="s1">, </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createRef());</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;pointerEventsView&quot;</span><span class="s1">, </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createRef());</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;panGestureHandler&quot;</span><span class="s1">, </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createRef());</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;drawerShown&quot;</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;updateAnimatedEvent&quot;</span><span class="s1">, (props, state) =&gt; {</span>
      <span class="s4">// Event definition is based on</span>
      <span class="s1">const {</span>
        <span class="s1">drawerPosition,</span>
        <span class="s1">drawerWidth,</span>
        <span class="s1">drawerType</span>
      <span class="s1">} = props;</span>
      <span class="s1">const {</span>
        <span class="s1">dragX: dragXValue,</span>
        <span class="s1">touchX: touchXValue,</span>
        <span class="s1">drawerTranslation,</span>
        <span class="s1">containerWidth</span>
      <span class="s1">} = state;</span>
      <span class="s1">let dragX = dragXValue;</span>
      <span class="s1">let touchX = touchXValue;</span>

      <span class="s2">if </span><span class="s1">(drawerPosition !== </span><span class="s0">'left'</span><span class="s1">) {</span>
        <span class="s4">// Most of the code is written in a way to handle left-side drawer. In</span>
        <span class="s4">// order to handle right-side drawer the only thing we need to do is to</span>
        <span class="s4">// reverse events coming from gesture handler in a way they emulate</span>
        <span class="s4">// left-side drawer gestures. E.g. dragX is simply -dragX, and touchX is</span>
        <span class="s4">// calulcated by subtracing real touchX from the width of the container</span>
        <span class="s4">// (such that when touch happens at the right edge the value is simply 0)</span>
        <span class="s1">dragX = _reactNative.Animated.multiply(</span><span class="s2">new </span><span class="s1">_reactNative.Animated.Value(-</span><span class="s3">1</span><span class="s1">), dragXValue); </span><span class="s4">// TODO(TS): (for all &quot;as&quot; in this file) make sure we can map this</span>

        <span class="s1">touchX = _reactNative.Animated.add(</span><span class="s2">new </span><span class="s1">_reactNative.Animated.Value(containerWidth), _reactNative.Animated.multiply(</span><span class="s2">new </span><span class="s1">_reactNative.Animated.Value(-</span><span class="s3">1</span><span class="s1">), touchXValue)); </span><span class="s4">// TODO(TS): make sure we can map this;</span>

        <span class="s1">touchXValue.setValue(containerWidth);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">touchXValue.setValue(</span><span class="s3">0</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s4">// While closing the drawer when user starts gesture outside of its area (in greyed</span>
      <span class="s4">// out part of the window), we want the drawer to follow only once finger reaches the</span>
      <span class="s4">// edge of the drawer.</span>
      <span class="s4">// E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by</span>
      <span class="s4">// dots. The touch gesture starts at '*' and moves left, touch path is indicated by</span>
      <span class="s4">// an arrow pointing left</span>
      <span class="s4">// 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+</span>
      <span class="s4">//    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|</span>
      <span class="s4">//    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|</span>
      <span class="s4">//    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|</span>
      <span class="s4">//    |XXXXXXXX|......|    |XXXXXXXX|.&lt;-*..|    |XXXXXXXX|&lt;--*..|    |XXXXX|&lt;-----*..|</span>
      <span class="s4">//    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|</span>
      <span class="s4">//    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|</span>
      <span class="s4">//    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|</span>
      <span class="s4">//    +---------------+    +---------------+    +---------------+    +---------------+</span>
      <span class="s4">//</span>
      <span class="s4">// For the above to work properly we define animated value that will keep</span>
      <span class="s4">// start position of the gesture. Then we use that value to calculate how</span>
      <span class="s4">// much we need to subtract from the dragX. If the gesture started on the</span>
      <span class="s4">// greyed out area we take the distance from the edge of the drawer to the</span>
      <span class="s4">// start position. Otherwise we don't subtract at all and the drawer be</span>
      <span class="s4">// pulled back as soon as you start the pan.</span>
      <span class="s4">//</span>
      <span class="s4">// This is used only when drawerType is &quot;front&quot;</span>
      <span class="s4">//</span>


      <span class="s1">let translationX = dragX;</span>

      <span class="s2">if </span><span class="s1">(drawerType === </span><span class="s0">'front'</span><span class="s1">) {</span>
        <span class="s1">const startPositionX = _reactNative.Animated.add(touchX, _reactNative.Animated.multiply(</span><span class="s2">new </span><span class="s1">_reactNative.Animated.Value(-</span><span class="s3">1</span><span class="s1">), dragX));</span>

        <span class="s1">const dragOffsetFromOnStartPosition = startPositionX.interpolate({</span>
          <span class="s1">inputRange: [drawerWidth - </span><span class="s3">1</span><span class="s1">, drawerWidth, drawerWidth + </span><span class="s3">1</span><span class="s1">],</span>
          <span class="s1">outputRange: [</span><span class="s3">0</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">});</span>
        <span class="s1">translationX = _reactNative.Animated.add(dragX, dragOffsetFromOnStartPosition); </span><span class="s4">// TODO: as above</span>
      <span class="s1">}</span>

      <span class="s2">this</span><span class="s1">.openValue = _reactNative.Animated.add(translationX, drawerTranslation).interpolate({</span>
        <span class="s1">inputRange: [</span><span class="s3">0</span><span class="s1">, drawerWidth],</span>
        <span class="s1">outputRange: [</span><span class="s3">0</span><span class="s1">, </span><span class="s3">1</span><span class="s1">],</span>
        <span class="s1">extrapolate: </span><span class="s0">'clamp'</span>
      <span class="s1">});</span>
      <span class="s1">const gestureOptions = {</span>
        <span class="s1">useNativeDriver: props.useNativeAnimations</span>
      <span class="s1">};</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.props.onDrawerSlide) {</span>
        <span class="s1">gestureOptions.listener = ev =&gt; {</span>
          <span class="s2">var </span><span class="s1">_this$props$onDrawerS, _this$props;</span>

          <span class="s1">const translationX = Math.floor(Math.abs(ev.nativeEvent.translationX));</span>
          <span class="s1">const position = translationX / </span><span class="s2">this</span><span class="s1">.state.containerWidth;</span>
          <span class="s1">(_this$props$onDrawerS = (_this$props = </span><span class="s2">this</span><span class="s1">.props).onDrawerSlide) === </span><span class="s2">null </span><span class="s1">|| _this$props$onDrawerS === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this$props$onDrawerS.call(_this$props, position);</span>
        <span class="s1">};</span>
      <span class="s1">}</span>

      <span class="s2">this</span><span class="s1">.onGestureEvent = _reactNative.Animated.event([{</span>
        <span class="s1">nativeEvent: {</span>
          <span class="s1">translationX: dragXValue,</span>
          <span class="s1">x: touchXValue</span>
        <span class="s1">}</span>
      <span class="s1">}], gestureOptions);</span>
    <span class="s1">});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;handleContainerLayout&quot;</span><span class="s1">, ({</span>
      <span class="s1">nativeEvent</span>
    <span class="s1">}) =&gt; {</span>
      <span class="s2">this</span><span class="s1">.setState({</span>
        <span class="s1">containerWidth: nativeEvent.layout.width</span>
      <span class="s1">});</span>
    <span class="s1">});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;emitStateChanged&quot;</span><span class="s1">, (newState, drawerWillShow) =&gt; {</span>
      <span class="s2">var </span><span class="s1">_this$props$onDrawerS2, _this$props2;</span>

      <span class="s1">(_this$props$onDrawerS2 = (_this$props2 = </span><span class="s2">this</span><span class="s1">.props).onDrawerStateChanged) === </span><span class="s2">null </span><span class="s1">|| _this$props$onDrawerS2 === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this$props$onDrawerS2.call(_this$props2, newState, drawerWillShow);</span>
    <span class="s1">});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;openingHandlerStateChange&quot;</span><span class="s1">, ({</span>
      <span class="s1">nativeEvent</span>
    <span class="s1">}) =&gt; {</span>
      <span class="s2">if </span><span class="s1">(nativeEvent.oldState === _State.State.ACTIVE) {</span>
        <span class="s2">this</span><span class="s1">.handleRelease({</span>
          <span class="s1">nativeEvent</span>
        <span class="s1">});</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(nativeEvent.state === _State.State.ACTIVE) {</span>
        <span class="s2">this</span><span class="s1">.emitStateChanged(DRAGGING, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.setState({</span>
          <span class="s1">drawerState: DRAGGING</span>
        <span class="s1">});</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.props.keyboardDismissMode === </span><span class="s0">'on-drag'</span><span class="s1">) {</span>
          <span class="s1">_reactNative.Keyboard.dismiss();</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.props.hideStatusBar) {</span>
          <span class="s1">_reactNative.StatusBar.setHidden(</span><span class="s2">true</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.props.statusBarAnimation || </span><span class="s0">'slide'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;onTapHandlerStateChange&quot;</span><span class="s1">, ({</span>
      <span class="s1">nativeEvent</span>
    <span class="s1">}) =&gt; {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.drawerShown &amp;&amp; nativeEvent.oldState === _State.State.ACTIVE &amp;&amp; </span><span class="s2">this</span><span class="s1">.props.drawerLockMode !== </span><span class="s0">'locked-open'</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.closeDrawer();</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;handleRelease&quot;</span><span class="s1">, ({</span>
      <span class="s1">nativeEvent</span>
    <span class="s1">}) =&gt; {</span>
      <span class="s1">const {</span>
        <span class="s1">drawerWidth,</span>
        <span class="s1">drawerPosition,</span>
        <span class="s1">drawerType</span>
      <span class="s1">} = </span><span class="s2">this</span><span class="s1">.props;</span>
      <span class="s1">const {</span>
        <span class="s1">containerWidth</span>
      <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
      <span class="s1">let {</span>
        <span class="s1">translationX: dragX,</span>
        <span class="s1">velocityX,</span>
        <span class="s1">x: touchX</span>
      <span class="s1">} = nativeEvent;</span>

      <span class="s2">if </span><span class="s1">(drawerPosition !== </span><span class="s0">'left'</span><span class="s1">) {</span>
        <span class="s4">// See description in _updateAnimatedEvent about why events are flipped</span>
        <span class="s4">// for right-side drawer</span>
        <span class="s1">dragX = -dragX;</span>
        <span class="s1">touchX = containerWidth - touchX;</span>
        <span class="s1">velocityX = -velocityX;</span>
      <span class="s1">}</span>

      <span class="s1">const gestureStartX = touchX - dragX;</span>
      <span class="s1">let dragOffsetBasedOnStart = </span><span class="s3">0</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(drawerType === </span><span class="s0">'front'</span><span class="s1">) {</span>
        <span class="s1">dragOffsetBasedOnStart = gestureStartX &gt; drawerWidth ? gestureStartX - drawerWidth : </span><span class="s3">0</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">const startOffsetX = dragX + dragOffsetBasedOnStart + (</span><span class="s2">this</span><span class="s1">.drawerShown ? drawerWidth : </span><span class="s3">0</span><span class="s1">);</span>
      <span class="s1">const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;</span>
      <span class="s1">const shouldOpen = projOffsetX &gt; drawerWidth / </span><span class="s3">2</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(shouldOpen) {</span>
        <span class="s2">this</span><span class="s1">.animateDrawer(startOffsetX, drawerWidth, velocityX);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.animateDrawer(startOffsetX, </span><span class="s3">0</span><span class="s1">, velocityX);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;updateShowing&quot;</span><span class="s1">, showing =&gt; {</span>
      <span class="s2">var </span><span class="s1">_this$accessibilityIs, _this$pointerEventsVi, _this$panGestureHandl;</span>

      <span class="s2">this</span><span class="s1">.drawerShown = showing;</span>
      <span class="s1">(_this$accessibilityIs = </span><span class="s2">this</span><span class="s1">.accessibilityIsModalView.current) === </span><span class="s2">null </span><span class="s1">|| _this$accessibilityIs === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this$accessibilityIs.setNativeProps({</span>
        <span class="s1">accessibilityViewIsModal: showing</span>
      <span class="s1">});</span>
      <span class="s1">(_this$pointerEventsVi = </span><span class="s2">this</span><span class="s1">.pointerEventsView.current) === </span><span class="s2">null </span><span class="s1">|| _this$pointerEventsVi === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this$pointerEventsVi.setNativeProps({</span>
        <span class="s1">pointerEvents: showing ? </span><span class="s0">'auto' </span><span class="s1">: </span><span class="s0">'none'</span>
      <span class="s1">});</span>
      <span class="s1">const {</span>
        <span class="s1">drawerPosition,</span>
        <span class="s1">minSwipeDistance,</span>
        <span class="s1">edgeWidth</span>
      <span class="s1">} = </span><span class="s2">this</span><span class="s1">.props;</span>
      <span class="s1">const fromLeft = drawerPosition === </span><span class="s0">'left'</span><span class="s1">; </span><span class="s4">// gestureOrientation is 1 if the expected gesture is from left to right and</span>
      <span class="s4">// -1 otherwise e.g. when drawer is on the left and is closed we expect left</span>
      <span class="s4">// to right gesture, thus orientation will be 1.</span>

      <span class="s1">const gestureOrientation = (fromLeft ? </span><span class="s3">1 </span><span class="s1">: -</span><span class="s3">1</span><span class="s1">) * (</span><span class="s2">this</span><span class="s1">.drawerShown ? -</span><span class="s3">1 </span><span class="s1">: </span><span class="s3">1</span><span class="s1">); </span><span class="s4">// When drawer is closed we want the hitSlop to be horizontally shorter than</span>
      <span class="s4">// the container size by the value of SLOP. This will make it only activate</span>
      <span class="s4">// when gesture happens not further than SLOP away from the edge</span>

      <span class="s1">const hitSlop = fromLeft ? {</span>
        <span class="s1">left: </span><span class="s3">0</span><span class="s1">,</span>
        <span class="s1">width: showing ? undefined : edgeWidth</span>
      <span class="s1">} : {</span>
        <span class="s1">right: </span><span class="s3">0</span><span class="s1">,</span>
        <span class="s1">width: showing ? undefined : edgeWidth</span>
      <span class="s1">}; </span><span class="s4">// @ts-ignore internal API, maybe could be fixed in handler types</span>

      <span class="s1">(_this$panGestureHandl = </span><span class="s2">this</span><span class="s1">.panGestureHandler.current) === </span><span class="s2">null </span><span class="s1">|| _this$panGestureHandl === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this$panGestureHandl.setNativeProps({</span>
        <span class="s1">hitSlop,</span>
        <span class="s1">activeOffsetX: gestureOrientation * minSwipeDistance</span>
      <span class="s1">});</span>
    <span class="s1">});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;animateDrawer&quot;</span><span class="s1">, (fromValue, toValue, velocity, speed) =&gt; {</span>
      <span class="s2">this</span><span class="s1">.state.dragX.setValue(</span><span class="s3">0</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.state.touchX.setValue(</span><span class="s2">this</span><span class="s1">.props.drawerPosition === </span><span class="s0">'left' </span><span class="s1">? </span><span class="s3">0 </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.state.containerWidth);</span>

      <span class="s2">if </span><span class="s1">(fromValue != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">let nextFramePosition = fromValue;</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.props.useNativeAnimations) {</span>
          <span class="s4">// When using native driver, we predict the next position of the</span>
          <span class="s4">// animation because it takes one frame of a roundtrip to pass RELEASE</span>
          <span class="s4">// event from native driver to JS before we can start animating. Without</span>
          <span class="s4">// it, it is more noticable that the frame is dropped.</span>
          <span class="s2">if </span><span class="s1">(fromValue &lt; toValue &amp;&amp; velocity &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s1">nextFramePosition = Math.min(fromValue + velocity / </span><span class="s3">60.0</span><span class="s1">, toValue);</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(fromValue &gt; toValue &amp;&amp; velocity &lt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s1">nextFramePosition = Math.max(fromValue + velocity / </span><span class="s3">60.0</span><span class="s1">, toValue);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">this</span><span class="s1">.state.drawerTranslation.setValue(nextFramePosition);</span>
      <span class="s1">}</span>

      <span class="s1">const willShow = toValue !== </span><span class="s3">0</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.updateShowing(willShow);</span>
      <span class="s2">this</span><span class="s1">.emitStateChanged(SETTLING, willShow);</span>
      <span class="s2">this</span><span class="s1">.setState({</span>
        <span class="s1">drawerState: SETTLING</span>
      <span class="s1">});</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.props.hideStatusBar) {</span>
        <span class="s1">_reactNative.StatusBar.setHidden(willShow, </span><span class="s2">this</span><span class="s1">.props.statusBarAnimation || </span><span class="s0">'slide'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">_reactNative.Animated.spring(</span><span class="s2">this</span><span class="s1">.state.drawerTranslation, {</span>
        <span class="s1">velocity,</span>
        <span class="s1">bounciness: </span><span class="s3">0</span><span class="s1">,</span>
        <span class="s1">toValue,</span>
        <span class="s1">useNativeDriver: </span><span class="s2">this</span><span class="s1">.props.useNativeAnimations,</span>
        <span class="s1">speed: speed !== </span><span class="s2">null </span><span class="s1">&amp;&amp; speed !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? speed : undefined</span>
      <span class="s1">}).start(({</span>
        <span class="s1">finished</span>
      <span class="s1">}) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(finished) {</span>
          <span class="s2">this</span><span class="s1">.emitStateChanged(IDLE, willShow);</span>
          <span class="s2">this</span><span class="s1">.setState({</span>
            <span class="s1">drawerOpened: willShow</span>
          <span class="s1">});</span>

          <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.state.drawerState !== DRAGGING) {</span>
            <span class="s4">// it's possilbe that user started drag while the drawer</span>
            <span class="s4">// was settling, don't override state in this case</span>
            <span class="s2">this</span><span class="s1">.setState({</span>
              <span class="s1">drawerState: IDLE</span>
            <span class="s1">});</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(willShow) {</span>
            <span class="s2">var </span><span class="s1">_this$props$onDrawerO, _this$props3;</span>

            <span class="s1">(_this$props$onDrawerO = (_this$props3 = </span><span class="s2">this</span><span class="s1">.props).onDrawerOpen) === </span><span class="s2">null </span><span class="s1">|| _this$props$onDrawerO === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this$props$onDrawerO.call(_this$props3);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">var </span><span class="s1">_this$props$onDrawerC, _this$props4;</span>

            <span class="s1">(_this$props$onDrawerC = (_this$props4 = </span><span class="s2">this</span><span class="s1">.props).onDrawerClose) === </span><span class="s2">null </span><span class="s1">|| _this$props$onDrawerC === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this$props$onDrawerC.call(_this$props4);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;openDrawer&quot;</span><span class="s1">, (options = {}) =&gt; {</span>
      <span class="s2">this</span><span class="s1">.animateDrawer( </span><span class="s4">// TODO: decide if it should be null or undefined is the proper value</span>
      <span class="s1">undefined, </span><span class="s2">this</span><span class="s1">.props.drawerWidth, options.velocity ? options.velocity : </span><span class="s3">0</span><span class="s1">, options.speed); </span><span class="s4">// We need to force the update, otherwise the overlay is not rerendered and</span>
      <span class="s4">// it would not be clickable</span>

      <span class="s2">this</span><span class="s1">.forceUpdate();</span>
    <span class="s1">});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;closeDrawer&quot;</span><span class="s1">, (options = {}) =&gt; {</span>
      <span class="s4">// TODO: decide if it should be null or undefined is the proper value</span>
      <span class="s2">this</span><span class="s1">.animateDrawer(undefined, </span><span class="s3">0</span><span class="s1">, options.velocity ? options.velocity : </span><span class="s3">0</span><span class="s1">, options.speed); </span><span class="s4">// We need to force the update, otherwise the overlay is not rerendered and</span>
      <span class="s4">// it would be still clickable</span>

      <span class="s2">this</span><span class="s1">.forceUpdate();</span>
    <span class="s1">});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;renderOverlay&quot;</span><span class="s1">, () =&gt; {</span>
      <span class="s4">/* Overlay styles */</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _invariant.</span><span class="s2">default</span><span class="s1">)(</span><span class="s2">this</span><span class="s1">.openValue, </span><span class="s0">'should be set'</span><span class="s1">);</span>
      <span class="s1">let overlayOpacity;</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.state.drawerState !== IDLE) {</span>
        <span class="s1">overlayOpacity = </span><span class="s2">this</span><span class="s1">.openValue;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">overlayOpacity = </span><span class="s2">this</span><span class="s1">.state.drawerOpened ? </span><span class="s3">1 </span><span class="s1">: </span><span class="s3">0</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">const dynamicOverlayStyles = {</span>
        <span class="s1">opacity: overlayOpacity,</span>
        <span class="s1">backgroundColor: </span><span class="s2">this</span><span class="s1">.props.overlayColor</span>
      <span class="s1">};</span>
      <span class="s2">return </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_TapGestureHandler.TapGestureHandler, {</span>
        <span class="s1">onHandlerStateChange: </span><span class="s2">this</span><span class="s1">.onTapHandlerStateChange</span>
      <span class="s1">}, </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_reactNative.Animated.View, {</span>
        <span class="s1">pointerEvents: </span><span class="s2">this</span><span class="s1">.drawerShown ? </span><span class="s0">'auto' </span><span class="s1">: </span><span class="s0">'none'</span><span class="s1">,</span>
        <span class="s1">ref: </span><span class="s2">this</span><span class="s1">.pointerEventsView,</span>
        <span class="s1">style: [styles.overlay, dynamicOverlayStyles]</span>
      <span class="s1">}));</span>
    <span class="s1">});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;renderDrawer&quot;</span><span class="s1">, () =&gt; {</span>
      <span class="s1">const {</span>
        <span class="s1">drawerBackgroundColor,</span>
        <span class="s1">drawerWidth,</span>
        <span class="s1">drawerPosition,</span>
        <span class="s1">drawerType,</span>
        <span class="s1">drawerContainerStyle,</span>
        <span class="s1">contentContainerStyle</span>
      <span class="s1">} = </span><span class="s2">this</span><span class="s1">.props;</span>
      <span class="s1">const fromLeft = drawerPosition === </span><span class="s0">'left'</span><span class="s1">;</span>
      <span class="s1">const drawerSlide = drawerType !== </span><span class="s0">'back'</span><span class="s1">;</span>
      <span class="s1">const containerSlide = drawerType !== </span><span class="s0">'front'</span><span class="s1">; </span><span class="s4">// we rely on row and row-reverse flex directions to position the drawer</span>
      <span class="s4">// properly. Apparently for RTL these are flipped which requires us to use</span>
      <span class="s4">// the opposite setting for the drawer to appear from left or right</span>
      <span class="s4">// according to the drawerPosition prop</span>

      <span class="s1">const reverseContentDirection = _reactNative.I18nManager.isRTL ? fromLeft : !fromLeft;</span>
      <span class="s1">const dynamicDrawerStyles = {</span>
        <span class="s1">backgroundColor: drawerBackgroundColor,</span>
        <span class="s1">width: drawerWidth</span>
      <span class="s1">};</span>
      <span class="s1">const openValue = </span><span class="s2">this</span><span class="s1">.openValue;</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _invariant.</span><span class="s2">default</span><span class="s1">)(openValue, </span><span class="s0">'should be set'</span><span class="s1">);</span>
      <span class="s1">let containerStyles;</span>

      <span class="s2">if </span><span class="s1">(containerSlide) {</span>
        <span class="s1">const containerTranslateX = openValue.interpolate({</span>
          <span class="s1">inputRange: [</span><span class="s3">0</span><span class="s1">, </span><span class="s3">1</span><span class="s1">],</span>
          <span class="s1">outputRange: fromLeft ? [</span><span class="s3">0</span><span class="s1">, drawerWidth] : [</span><span class="s3">0</span><span class="s1">, -drawerWidth],</span>
          <span class="s1">extrapolate: </span><span class="s0">'clamp'</span>
        <span class="s1">});</span>
        <span class="s1">containerStyles = {</span>
          <span class="s1">transform: [{</span>
            <span class="s1">translateX: containerTranslateX</span>
          <span class="s1">}]</span>
        <span class="s1">};</span>
      <span class="s1">}</span>

      <span class="s1">let drawerTranslateX = </span><span class="s3">0</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(drawerSlide) {</span>
        <span class="s1">const closedDrawerOffset = fromLeft ? -drawerWidth : drawerWidth;</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.state.drawerState !== IDLE) {</span>
          <span class="s1">drawerTranslateX = openValue.interpolate({</span>
            <span class="s1">inputRange: [</span><span class="s3">0</span><span class="s1">, </span><span class="s3">1</span><span class="s1">],</span>
            <span class="s1">outputRange: [closedDrawerOffset, </span><span class="s3">0</span><span class="s1">],</span>
            <span class="s1">extrapolate: </span><span class="s0">'clamp'</span>
          <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">drawerTranslateX = </span><span class="s2">this</span><span class="s1">.state.drawerOpened ? </span><span class="s3">0 </span><span class="s1">: closedDrawerOffset;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">const drawerStyles = {</span>
        <span class="s1">transform: [{</span>
          <span class="s1">translateX: drawerTranslateX</span>
        <span class="s1">}],</span>
        <span class="s1">flexDirection: reverseContentDirection ? </span><span class="s0">'row-reverse' </span><span class="s1">: </span><span class="s0">'row'</span>
      <span class="s1">};</span>
      <span class="s2">return </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_reactNative.Animated.View, {</span>
        <span class="s1">style: styles.main,</span>
        <span class="s1">onLayout: </span><span class="s2">this</span><span class="s1">.handleContainerLayout</span>
      <span class="s1">}, </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_reactNative.Animated.View, {</span>
        <span class="s1">style: [drawerType === </span><span class="s0">'front' </span><span class="s1">? styles.containerOnBack : styles.containerInFront, containerStyles, contentContainerStyle],</span>
        <span class="s1">importantForAccessibility: </span><span class="s2">this</span><span class="s1">.drawerShown ? </span><span class="s0">'no-hide-descendants' </span><span class="s1">: </span><span class="s0">'yes'</span>
      <span class="s1">}, </span><span class="s2">typeof this</span><span class="s1">.props.children === </span><span class="s0">'function' </span><span class="s1">? </span><span class="s2">this</span><span class="s1">.props.children(</span><span class="s2">this</span><span class="s1">.openValue) : </span><span class="s2">this</span><span class="s1">.props.children, </span><span class="s2">this</span><span class="s1">.renderOverlay()), </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_reactNative.Animated.View, {</span>
        <span class="s1">pointerEvents: </span><span class="s0">&quot;box-none&quot;</span><span class="s1">,</span>
        <span class="s1">ref: </span><span class="s2">this</span><span class="s1">.accessibilityIsModalView,</span>
        <span class="s1">accessibilityViewIsModal: </span><span class="s2">this</span><span class="s1">.drawerShown,</span>
        <span class="s1">style: [styles.drawerContainer, drawerStyles, drawerContainerStyle]</span>
      <span class="s1">}, </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_reactNative.View, {</span>
        <span class="s1">style: dynamicDrawerStyles</span>
      <span class="s1">}, </span><span class="s2">this</span><span class="s1">.props.renderNavigationView(</span><span class="s2">this</span><span class="s1">.openValue))));</span>
    <span class="s1">});</span>

    <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;setPanGestureRef&quot;</span><span class="s1">, ref =&gt; {</span>
      <span class="s2">var </span><span class="s1">_this$props$onGesture, _this$props5;</span>

      <span class="s4">// TODO(TS): make sure it is OK taken from</span>
      <span class="s4">// https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065#issuecomment-596081842</span>
      <span class="s2">this</span><span class="s1">.panGestureHandler.current = ref;</span>
      <span class="s1">(_this$props$onGesture = (_this$props5 = </span><span class="s2">this</span><span class="s1">.props).onGestureRef) === </span><span class="s2">null </span><span class="s1">|| _this$props$onGesture === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this$props$onGesture.call(_this$props5, ref);</span>
    <span class="s1">});</span>

    <span class="s1">const _dragX = </span><span class="s2">new </span><span class="s1">_reactNative.Animated.Value(</span><span class="s3">0</span><span class="s1">);</span>

    <span class="s1">const _touchX = </span><span class="s2">new </span><span class="s1">_reactNative.Animated.Value(</span><span class="s3">0</span><span class="s1">);</span>

    <span class="s1">const _drawerTranslation = </span><span class="s2">new </span><span class="s1">_reactNative.Animated.Value(</span><span class="s3">0</span><span class="s1">);</span>

    <span class="s2">this</span><span class="s1">.state = {</span>
      <span class="s1">dragX: _dragX,</span>
      <span class="s1">touchX: _touchX,</span>
      <span class="s1">drawerTranslation: _drawerTranslation,</span>
      <span class="s1">containerWidth: </span><span class="s3">0</span><span class="s1">,</span>
      <span class="s1">drawerState: IDLE,</span>
      <span class="s1">drawerOpened: </span><span class="s2">false</span>
    <span class="s1">};</span>
    <span class="s2">this</span><span class="s1">.updateAnimatedEvent(_props, </span><span class="s2">this</span><span class="s1">.state);</span>
  <span class="s1">}</span>

  <span class="s1">shouldComponentUpdate(props, state) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.props.drawerPosition !== props.drawerPosition || </span><span class="s2">this</span><span class="s1">.props.drawerWidth !== props.drawerWidth || </span><span class="s2">this</span><span class="s1">.props.drawerType !== props.drawerType || </span><span class="s2">this</span><span class="s1">.state.containerWidth !== state.containerWidth) {</span>
      <span class="s2">this</span><span class="s1">.updateAnimatedEvent(props, state);</span>
    <span class="s1">}</span>

    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">render() {</span>
    <span class="s1">const {</span>
      <span class="s1">drawerPosition,</span>
      <span class="s1">drawerLockMode,</span>
      <span class="s1">edgeWidth,</span>
      <span class="s1">minSwipeDistance</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.props;</span>
    <span class="s1">const fromLeft = drawerPosition === </span><span class="s0">'left'</span><span class="s1">; </span><span class="s4">// gestureOrientation is 1 if the expected gesture is from left to right and</span>
    <span class="s4">// -1 otherwise e.g. when drawer is on the left and is closed we expect left</span>
    <span class="s4">// to right gesture, thus orientation will be 1.</span>

    <span class="s1">const gestureOrientation = (fromLeft ? </span><span class="s3">1 </span><span class="s1">: -</span><span class="s3">1</span><span class="s1">) * (</span><span class="s2">this</span><span class="s1">.drawerShown ? -</span><span class="s3">1 </span><span class="s1">: </span><span class="s3">1</span><span class="s1">); </span><span class="s4">// When drawer is closed we want the hitSlop to be horizontally shorter than</span>
    <span class="s4">// the container size by the value of SLOP. This will make it only activate</span>
    <span class="s4">// when gesture happens not further than SLOP away from the edge</span>

    <span class="s1">const hitSlop = fromLeft ? {</span>
      <span class="s1">left: </span><span class="s3">0</span><span class="s1">,</span>
      <span class="s1">width: </span><span class="s2">this</span><span class="s1">.drawerShown ? undefined : edgeWidth</span>
    <span class="s1">} : {</span>
      <span class="s1">right: </span><span class="s3">0</span><span class="s1">,</span>
      <span class="s1">width: </span><span class="s2">this</span><span class="s1">.drawerShown ? undefined : edgeWidth</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_PanGestureHandler.PanGestureHandler </span><span class="s4">// @ts-ignore could be fixed in handler types</span>
    <span class="s1">, {</span>
      <span class="s1">userSelect: </span><span class="s2">this</span><span class="s1">.props.userSelect,</span>
      <span class="s1">ref: </span><span class="s2">this</span><span class="s1">.setPanGestureRef,</span>
      <span class="s1">hitSlop: hitSlop,</span>
      <span class="s1">activeOffsetX: gestureOrientation * minSwipeDistance,</span>
      <span class="s1">failOffsetY: [-</span><span class="s3">15</span><span class="s1">, </span><span class="s3">15</span><span class="s1">],</span>
      <span class="s1">onGestureEvent: </span><span class="s2">this</span><span class="s1">.onGestureEvent,</span>
      <span class="s1">onHandlerStateChange: </span><span class="s2">this</span><span class="s1">.openingHandlerStateChange,</span>
      <span class="s1">enableTrackpadTwoFingerGesture: </span><span class="s2">this</span><span class="s1">.props.enableTrackpadTwoFingerGesture,</span>
      <span class="s1">enabled: drawerLockMode !== </span><span class="s0">'locked-closed' </span><span class="s1">&amp;&amp; drawerLockMode !== </span><span class="s0">'locked-open'</span>
    <span class="s1">}, </span><span class="s2">this</span><span class="s1">.renderDrawer());</span>
  <span class="s1">}</span>

<span class="s1">}</span>

<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= DrawerLayout;</span>

<span class="s1">_defineProperty(DrawerLayout, </span><span class="s0">&quot;defaultProps&quot;</span><span class="s1">, {</span>
  <span class="s1">drawerWidth: </span><span class="s3">200</span><span class="s1">,</span>
  <span class="s1">drawerPosition: </span><span class="s0">'left'</span><span class="s1">,</span>
  <span class="s1">useNativeAnimations: </span><span class="s2">true</span><span class="s1">,</span>
  <span class="s1">drawerType: </span><span class="s0">'front'</span><span class="s1">,</span>
  <span class="s1">edgeWidth: </span><span class="s3">20</span><span class="s1">,</span>
  <span class="s1">minSwipeDistance: </span><span class="s3">3</span><span class="s1">,</span>
  <span class="s1">overlayColor: </span><span class="s0">'rgba(0, 0, 0, 0.7)'</span><span class="s1">,</span>
  <span class="s1">drawerLockMode: </span><span class="s0">'unlocked'</span><span class="s1">,</span>
  <span class="s1">enableTrackpadTwoFingerGesture: </span><span class="s2">false</span>
<span class="s1">});</span>

<span class="s1">_defineProperty(DrawerLayout, </span><span class="s0">&quot;positions&quot;</span><span class="s1">, {</span>
  <span class="s1">Left: </span><span class="s0">'left'</span><span class="s1">,</span>
  <span class="s1">Right: </span><span class="s0">'right'</span>
<span class="s1">});</span>

<span class="s1">const styles = _reactNative.StyleSheet.create({</span>
  <span class="s1">drawerContainer: { ..._reactNative.StyleSheet.absoluteFillObject,</span>
    <span class="s1">zIndex: </span><span class="s3">1001</span><span class="s1">,</span>
    <span class="s1">flexDirection: </span><span class="s0">'row'</span>
  <span class="s1">},</span>
  <span class="s1">containerInFront: { ..._reactNative.StyleSheet.absoluteFillObject,</span>
    <span class="s1">zIndex: </span><span class="s3">1002</span>
  <span class="s1">},</span>
  <span class="s1">containerOnBack: { ..._reactNative.StyleSheet.absoluteFillObject</span>
  <span class="s1">},</span>
  <span class="s1">main: {</span>
    <span class="s1">flex: </span><span class="s3">1</span><span class="s1">,</span>
    <span class="s1">zIndex: </span><span class="s3">0</span><span class="s1">,</span>
    <span class="s1">overflow: </span><span class="s0">'hidden'</span>
  <span class="s1">},</span>
  <span class="s1">overlay: { ..._reactNative.StyleSheet.absoluteFillObject,</span>
    <span class="s1">zIndex: </span><span class="s3">1000</span>
  <span class="s1">}</span>
<span class="s1">});</span>
<span class="s4">//# sourceMappingURL=DrawerLayout.js.map</span></pre>
</body>
</html>
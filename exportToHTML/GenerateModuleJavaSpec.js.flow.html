<html>
<head>
<title>GenerateModuleJavaSpec.js.flow</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
GenerateModuleJavaSpec.js.flow</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Copyright (c) Meta Platforms, Inc. and affiliates.</span>
 <span class="s0">*</span>
 <span class="s0">* This source code is licensed under the MIT license found in the</span>
 <span class="s0">* LICENSE file in the root directory of this source tree.</span>
 <span class="s0">*</span>
 <span class="s0">* @flow strict</span>
 <span class="s0">* @format</span>
 <span class="s0">*/</span>

<span class="s0">'use strict';</span>

<span class="s0">import type {</span>
  <span class="s0">Nullable,</span>
  <span class="s0">NamedShape,</span>
  <span class="s0">SchemaType,</span>
  <span class="s0">NativeModulePropertyShape,</span>
  <span class="s0">NativeModuleReturnTypeAnnotation,</span>
  <span class="s0">NativeModuleFunctionTypeAnnotation,</span>
  <span class="s0">NativeModuleParamTypeAnnotation,</span>
<span class="s0">} from '../../CodegenSchema';</span>

<span class="s0">import type {AliasResolver} from './Utils';</span>
<span class="s0">const {createAliasResolver, getModules} = require('./Utils');</span>
<span class="s0">const {unwrapNullable} = require('../../parsers/parsers-commons');</span>

<span class="s0">type FilesOutput = Map&lt;string, string&gt;;</span>

<span class="s0">function FileTemplate(</span>
  <span class="s0">config: $ReadOnly&lt;{</span>
    <span class="s0">packageName: string,</span>
    <span class="s0">className: string,</span>
    <span class="s0">jsName: string,</span>
    <span class="s0">methods: string,</span>
    <span class="s0">imports: string,</span>
  <span class="s0">}&gt;,</span>
<span class="s0">): string {</span>
  <span class="s0">const {packageName, className, jsName, methods, imports} = config;</span>
  <span class="s0">return `</span>
<span class="s0">/**</span>
 <span class="s0">* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).</span>
 <span class="s0">*</span>
 <span class="s0">* Do not edit this file as changes may cause incorrect behavior and will be lost</span>
 <span class="s0">* once the code is regenerated.</span>
 <span class="s0">*</span>
 <span class="s0">* ${'@'}generated by codegen project: GenerateModuleJavaSpec.js</span>
 <span class="s0">*</span>
 <span class="s0">* ${'@'}nolint</span>
 <span class="s0">*/</span>

<span class="s0">package ${packageName};</span>

<span class="s0">${imports}</span>

<span class="s0">public abstract class ${className} extends ReactContextBaseJavaModule implements ReactModuleWithSpec, TurboModule {</span>
  <span class="s0">public static final String NAME = &quot;${jsName}&quot;;</span>

  <span class="s0">public ${className}(ReactApplicationContext reactContext) {</span>
    <span class="s0">super(reactContext);</span>
  <span class="s0">}</span>

  <span class="s0">@Override</span>
  <span class="s0">public @Nonnull String getName() {</span>
    <span class="s0">return NAME;</span>
  <span class="s0">}</span>

<span class="s0">${methods}</span>
<span class="s0">}</span>
<span class="s0">`;</span>
<span class="s0">}</span>

<span class="s0">function MethodTemplate(</span>
  <span class="s0">config: $ReadOnly&lt;{</span>
    <span class="s0">abstract: boolean,</span>
    <span class="s0">methodBody: ?string,</span>
    <span class="s0">methodJavaAnnotation: string,</span>
    <span class="s0">methodName: string,</span>
    <span class="s0">translatedReturnType: string,</span>
    <span class="s0">traversedArgs: Array&lt;string&gt;,</span>
  <span class="s0">}&gt;,</span>
<span class="s0">): string {</span>
  <span class="s0">const {</span>
    <span class="s0">abstract,</span>
    <span class="s0">methodBody,</span>
    <span class="s0">methodJavaAnnotation,</span>
    <span class="s0">methodName,</span>
    <span class="s0">translatedReturnType,</span>
    <span class="s0">traversedArgs,</span>
  <span class="s0">} = config;</span>
  <span class="s0">const methodQualifier = abstract ? 'abstract ' : '';</span>
  <span class="s0">const methodClosing = abstract</span>
    <span class="s0">? ';'</span>
    <span class="s0">: methodBody != null &amp;&amp; methodBody.length &gt; 0</span>
    <span class="s0">? ` { ${methodBody} }`</span>
    <span class="s0">: ' {}';</span>
  <span class="s0">return `  ${methodJavaAnnotation}</span>
  <span class="s0">public ${methodQualifier}${translatedReturnType} ${methodName}(${traversedArgs.join(</span>
    <span class="s0">', ',</span>
  <span class="s0">)})${methodClosing}`;</span>
<span class="s0">}</span>

<span class="s0">type Param = NamedShape&lt;Nullable&lt;NativeModuleParamTypeAnnotation&gt;&gt;;</span>

<span class="s0">function translateFunctionParamToJavaType(</span>
  <span class="s0">param: Param,</span>
  <span class="s0">createErrorMessage: (typeName: string) =&gt; string,</span>
  <span class="s0">resolveAlias: AliasResolver,</span>
  <span class="s0">imports: Set&lt;string&gt;,</span>
<span class="s0">): string {</span>
  <span class="s0">const {optional, typeAnnotation: nullableTypeAnnotation} = param;</span>
  <span class="s0">const [typeAnnotation, nullable] =</span>
    <span class="s0">unwrapNullable&lt;NativeModuleParamTypeAnnotation&gt;(nullableTypeAnnotation);</span>
  <span class="s0">const isRequired = !optional &amp;&amp; !nullable;</span>

  <span class="s0">function wrapNullable(javaType: string, nullableType?: string) {</span>
    <span class="s0">if (!isRequired) {</span>
      <span class="s0">imports.add('javax.annotation.Nullable');</span>
      <span class="s0">return `@Nullable ${nullableType ?? javaType}`;</span>
    <span class="s0">}</span>
    <span class="s0">return javaType;</span>
  <span class="s0">}</span>

  <span class="s0">// FIXME: support class alias for args</span>
  <span class="s0">let realTypeAnnotation = typeAnnotation;</span>
  <span class="s0">if (realTypeAnnotation.type === 'TypeAliasTypeAnnotation') {</span>
    <span class="s0">realTypeAnnotation = resolveAlias(realTypeAnnotation.name);</span>
  <span class="s0">}</span>

  <span class="s0">switch (realTypeAnnotation.type) {</span>
    <span class="s0">case 'ReservedTypeAnnotation':</span>
      <span class="s0">switch (realTypeAnnotation.name) {</span>
        <span class="s0">case 'RootTag':</span>
          <span class="s0">return wrapNullable('double', 'Double');</span>
        <span class="s0">default:</span>
          <span class="s0">(realTypeAnnotation.name: empty);</span>
          <span class="s0">throw new Error(createErrorMessage(realTypeAnnotation.name));</span>
      <span class="s0">}</span>
    <span class="s0">case 'StringTypeAnnotation':</span>
      <span class="s0">return wrapNullable('String');</span>
    <span class="s0">case 'NumberTypeAnnotation':</span>
      <span class="s0">return wrapNullable('double', 'Double');</span>
    <span class="s0">case 'FloatTypeAnnotation':</span>
      <span class="s0">return wrapNullable('double', 'Double');</span>
    <span class="s0">case 'DoubleTypeAnnotation':</span>
      <span class="s0">return wrapNullable('double', 'Double');</span>
    <span class="s0">case 'Int32TypeAnnotation':</span>
      <span class="s0">return wrapNullable('double', 'Double');</span>
    <span class="s0">case 'BooleanTypeAnnotation':</span>
      <span class="s0">return wrapNullable('boolean', 'Boolean');</span>
    <span class="s0">case 'EnumDeclaration':</span>
      <span class="s0">switch (realTypeAnnotation.memberType) {</span>
        <span class="s0">case 'NumberTypeAnnotation':</span>
          <span class="s0">return wrapNullable('double', 'Double');</span>
        <span class="s0">case 'StringTypeAnnotation':</span>
          <span class="s0">return wrapNullable('String');</span>
        <span class="s0">default:</span>
          <span class="s0">throw new Error(createErrorMessage(realTypeAnnotation.type));</span>
      <span class="s0">}</span>
    <span class="s0">case 'UnionTypeAnnotation':</span>
      <span class="s0">switch (typeAnnotation.memberType) {</span>
        <span class="s0">case 'NumberTypeAnnotation':</span>
          <span class="s0">return wrapNullable('double', 'Double');</span>
        <span class="s0">case 'ObjectTypeAnnotation':</span>
          <span class="s0">imports.add('com.facebook.react.bridge.ReadableMap');</span>
          <span class="s0">return wrapNullable('ReadableMap');</span>
        <span class="s0">case 'StringTypeAnnotation':</span>
          <span class="s0">return wrapNullable('String');</span>
        <span class="s0">default:</span>
          <span class="s0">throw new Error(</span>
            <span class="s0">`Unsupported union member returning value, found: ${realTypeAnnotation.memberType}&quot;`,</span>
          <span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">case 'ObjectTypeAnnotation':</span>
      <span class="s0">imports.add('com.facebook.react.bridge.ReadableMap');</span>
      <span class="s0">return wrapNullable('ReadableMap');</span>
    <span class="s0">case 'GenericObjectTypeAnnotation':</span>
      <span class="s0">// Treat this the same as ObjectTypeAnnotation for now.</span>
      <span class="s0">imports.add('com.facebook.react.bridge.ReadableMap');</span>
      <span class="s0">return wrapNullable('ReadableMap');</span>
    <span class="s0">case 'ArrayTypeAnnotation':</span>
      <span class="s0">imports.add('com.facebook.react.bridge.ReadableArray');</span>
      <span class="s0">return wrapNullable('ReadableArray');</span>
    <span class="s0">case 'FunctionTypeAnnotation':</span>
      <span class="s0">imports.add('com.facebook.react.bridge.Callback');</span>
      <span class="s0">return wrapNullable('Callback');</span>
    <span class="s0">default:</span>
      <span class="s0">(realTypeAnnotation.type: 'MixedTypeAnnotation');</span>
      <span class="s0">throw new Error(createErrorMessage(realTypeAnnotation.type));</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">function translateFunctionReturnTypeToJavaType(</span>
  <span class="s0">nullableReturnTypeAnnotation: Nullable&lt;NativeModuleReturnTypeAnnotation&gt;,</span>
  <span class="s0">createErrorMessage: (typeName: string) =&gt; string,</span>
  <span class="s0">resolveAlias: AliasResolver,</span>
  <span class="s0">imports: Set&lt;string&gt;,</span>
<span class="s0">): string {</span>
  <span class="s0">const [returnTypeAnnotation, nullable] =</span>
    <span class="s0">unwrapNullable&lt;NativeModuleReturnTypeAnnotation&gt;(</span>
      <span class="s0">nullableReturnTypeAnnotation,</span>
    <span class="s0">);</span>

  <span class="s0">function wrapNullable(javaType: string, nullableType?: string) {</span>
    <span class="s0">if (nullable) {</span>
      <span class="s0">imports.add('javax.annotation.Nullable');</span>
      <span class="s0">return `@Nullable ${nullableType ?? javaType}`;</span>
    <span class="s0">}</span>
    <span class="s0">return javaType;</span>
  <span class="s0">}</span>

  <span class="s0">// FIXME: support class alias for args</span>
  <span class="s0">let realTypeAnnotation = returnTypeAnnotation;</span>
  <span class="s0">if (realTypeAnnotation.type === 'TypeAliasTypeAnnotation') {</span>
    <span class="s0">realTypeAnnotation = resolveAlias(realTypeAnnotation.name);</span>
  <span class="s0">}</span>

  <span class="s0">switch (realTypeAnnotation.type) {</span>
    <span class="s0">case 'ReservedTypeAnnotation':</span>
      <span class="s0">switch (realTypeAnnotation.name) {</span>
        <span class="s0">case 'RootTag':</span>
          <span class="s0">return wrapNullable('double', 'Double');</span>
        <span class="s0">default:</span>
          <span class="s0">(realTypeAnnotation.name: empty);</span>
          <span class="s0">throw new Error(createErrorMessage(realTypeAnnotation.name));</span>
      <span class="s0">}</span>
    <span class="s0">case 'VoidTypeAnnotation':</span>
      <span class="s0">return 'void';</span>
    <span class="s0">case 'PromiseTypeAnnotation':</span>
      <span class="s0">return 'void';</span>
    <span class="s0">case 'StringTypeAnnotation':</span>
      <span class="s0">return wrapNullable('String');</span>
    <span class="s0">case 'NumberTypeAnnotation':</span>
      <span class="s0">return wrapNullable('double', 'Double');</span>
    <span class="s0">case 'FloatTypeAnnotation':</span>
      <span class="s0">return wrapNullable('double', 'Double');</span>
    <span class="s0">case 'DoubleTypeAnnotation':</span>
      <span class="s0">return wrapNullable('double', 'Double');</span>
    <span class="s0">case 'Int32TypeAnnotation':</span>
      <span class="s0">return wrapNullable('double', 'Double');</span>
    <span class="s0">case 'BooleanTypeAnnotation':</span>
      <span class="s0">return wrapNullable('boolean', 'Boolean');</span>
    <span class="s0">case 'EnumDeclaration':</span>
      <span class="s0">switch (realTypeAnnotation.memberType) {</span>
        <span class="s0">case 'NumberTypeAnnotation':</span>
          <span class="s0">return wrapNullable('double', 'Double');</span>
        <span class="s0">case 'StringTypeAnnotation':</span>
          <span class="s0">return wrapNullable('String');</span>
        <span class="s0">default:</span>
          <span class="s0">throw new Error(createErrorMessage(realTypeAnnotation.type));</span>
      <span class="s0">}</span>
    <span class="s0">case 'UnionTypeAnnotation':</span>
      <span class="s0">switch (realTypeAnnotation.memberType) {</span>
        <span class="s0">case 'NumberTypeAnnotation':</span>
          <span class="s0">return wrapNullable('double', 'Double');</span>
        <span class="s0">case 'ObjectTypeAnnotation':</span>
          <span class="s0">imports.add('com.facebook.react.bridge.WritableMap');</span>
          <span class="s0">return wrapNullable('WritableMap');</span>
        <span class="s0">case 'StringTypeAnnotation':</span>
          <span class="s0">return wrapNullable('String');</span>
        <span class="s0">default:</span>
          <span class="s0">throw new Error(</span>
            <span class="s0">`Unsupported union member returning value, found: ${realTypeAnnotation.memberType}&quot;`,</span>
          <span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">case 'ObjectTypeAnnotation':</span>
      <span class="s0">imports.add('com.facebook.react.bridge.WritableMap');</span>
      <span class="s0">return wrapNullable('WritableMap');</span>
    <span class="s0">case 'GenericObjectTypeAnnotation':</span>
      <span class="s0">imports.add('com.facebook.react.bridge.WritableMap');</span>
      <span class="s0">return wrapNullable('WritableMap');</span>
    <span class="s0">case 'ArrayTypeAnnotation':</span>
      <span class="s0">imports.add('com.facebook.react.bridge.WritableArray');</span>
      <span class="s0">return wrapNullable('WritableArray');</span>
    <span class="s0">default:</span>
      <span class="s0">(realTypeAnnotation.type: 'MixedTypeAnnotation');</span>
      <span class="s0">throw new Error(createErrorMessage(realTypeAnnotation.type));</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">function getFalsyReturnStatementFromReturnType(</span>
  <span class="s0">nullableReturnTypeAnnotation: Nullable&lt;NativeModuleReturnTypeAnnotation&gt;,</span>
  <span class="s0">createErrorMessage: (typeName: string) =&gt; string,</span>
  <span class="s0">resolveAlias: AliasResolver,</span>
<span class="s0">): string {</span>
  <span class="s0">const [returnTypeAnnotation, nullable] =</span>
    <span class="s0">unwrapNullable&lt;NativeModuleReturnTypeAnnotation&gt;(</span>
      <span class="s0">nullableReturnTypeAnnotation,</span>
    <span class="s0">);</span>

  <span class="s0">let realTypeAnnotation = returnTypeAnnotation;</span>
  <span class="s0">if (realTypeAnnotation.type === 'TypeAliasTypeAnnotation') {</span>
    <span class="s0">realTypeAnnotation = resolveAlias(realTypeAnnotation.name);</span>
  <span class="s0">}</span>

  <span class="s0">switch (realTypeAnnotation.type) {</span>
    <span class="s0">case 'ReservedTypeAnnotation':</span>
      <span class="s0">switch (realTypeAnnotation.name) {</span>
        <span class="s0">case 'RootTag':</span>
          <span class="s0">return 'return 0.0;';</span>
        <span class="s0">default:</span>
          <span class="s0">(realTypeAnnotation.name: empty);</span>
          <span class="s0">throw new Error(createErrorMessage(realTypeAnnotation.name));</span>
      <span class="s0">}</span>
    <span class="s0">case 'VoidTypeAnnotation':</span>
      <span class="s0">return '';</span>
    <span class="s0">case 'PromiseTypeAnnotation':</span>
      <span class="s0">return '';</span>
    <span class="s0">case 'NumberTypeAnnotation':</span>
      <span class="s0">return nullable ? 'return null;' : 'return 0;';</span>
    <span class="s0">case 'FloatTypeAnnotation':</span>
      <span class="s0">return nullable ? 'return null;' : 'return 0.0;';</span>
    <span class="s0">case 'DoubleTypeAnnotation':</span>
      <span class="s0">return nullable ? 'return null;' : 'return 0.0;';</span>
    <span class="s0">case 'Int32TypeAnnotation':</span>
      <span class="s0">return nullable ? 'return null;' : 'return 0;';</span>
    <span class="s0">case 'BooleanTypeAnnotation':</span>
      <span class="s0">return nullable ? 'return null;' : 'return false;';</span>
    <span class="s0">case 'EnumDeclaration':</span>
      <span class="s0">switch (realTypeAnnotation.memberType) {</span>
        <span class="s0">case 'NumberTypeAnnotation':</span>
          <span class="s0">return nullable ? 'return null;' : 'return 0;';</span>
        <span class="s0">case 'StringTypeAnnotation':</span>
          <span class="s0">return nullable ? 'return null;' : 'return &quot;&quot;;';</span>
        <span class="s0">default:</span>
          <span class="s0">throw new Error(createErrorMessage(realTypeAnnotation.type));</span>
      <span class="s0">}</span>
    <span class="s0">case 'UnionTypeAnnotation':</span>
      <span class="s0">switch (realTypeAnnotation.memberType) {</span>
        <span class="s0">case 'NumberTypeAnnotation':</span>
          <span class="s0">return nullable ? 'return null;' : 'return 0;';</span>
        <span class="s0">case 'ObjectTypeAnnotation':</span>
          <span class="s0">return 'return null;';</span>
        <span class="s0">case 'StringTypeAnnotation':</span>
          <span class="s0">return nullable ? 'return null;' : 'return &quot;&quot;;';</span>
        <span class="s0">default:</span>
          <span class="s0">throw new Error(</span>
            <span class="s0">`Unsupported union member returning value, found: ${realTypeAnnotation.memberType}&quot;`,</span>
          <span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">case 'StringTypeAnnotation':</span>
      <span class="s0">return nullable ? 'return null;' : 'return &quot;&quot;;';</span>
    <span class="s0">case 'ObjectTypeAnnotation':</span>
      <span class="s0">return 'return null;';</span>
    <span class="s0">case 'GenericObjectTypeAnnotation':</span>
      <span class="s0">return 'return null;';</span>
    <span class="s0">case 'ArrayTypeAnnotation':</span>
      <span class="s0">return 'return null;';</span>
    <span class="s0">default:</span>
      <span class="s0">(realTypeAnnotation.type: 'MixedTypeAnnotation');</span>
      <span class="s0">throw new Error(createErrorMessage(realTypeAnnotation.type));</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">// Build special-cased runtime check for getConstants().</span>
<span class="s0">function buildGetConstantsMethod(</span>
  <span class="s0">method: NativeModulePropertyShape,</span>
  <span class="s0">imports: Set&lt;string&gt;,</span>
<span class="s0">): string {</span>
  <span class="s0">const [methodTypeAnnotation] =</span>
    <span class="s0">unwrapNullable&lt;NativeModuleFunctionTypeAnnotation&gt;(method.typeAnnotation);</span>
  <span class="s0">if (</span>
    <span class="s0">methodTypeAnnotation.returnTypeAnnotation.type === 'ObjectTypeAnnotation'</span>
  <span class="s0">) {</span>
    <span class="s0">const requiredProps = [];</span>
    <span class="s0">const optionalProps = [];</span>
    <span class="s0">const rawProperties =</span>
      <span class="s0">methodTypeAnnotation.returnTypeAnnotation.properties || [];</span>
    <span class="s0">rawProperties.forEach(p =&gt; {</span>
      <span class="s0">if (p.optional || p.typeAnnotation.type === 'NullableTypeAnnotation') {</span>
        <span class="s0">optionalProps.push(p.name);</span>
      <span class="s0">} else {</span>
        <span class="s0">requiredProps.push(p.name);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">if (requiredProps.length === 0 &amp;&amp; optionalProps.length === 0) {</span>
      <span class="s0">// Nothing to validate during runtime.</span>
      <span class="s0">return '';</span>
    <span class="s0">}</span>

    <span class="s0">imports.add('com.facebook.react.common.build.ReactBuildConfig');</span>
    <span class="s0">imports.add('java.util.Arrays');</span>
    <span class="s0">imports.add('java.util.HashSet');</span>
    <span class="s0">imports.add('java.util.Map');</span>
    <span class="s0">imports.add('java.util.Set');</span>
    <span class="s0">imports.add('javax.annotation.Nullable');</span>

    <span class="s0">const requiredPropsFragment =</span>
      <span class="s0">requiredProps.length &gt; 0</span>
        <span class="s0">? `Arrays.asList(</span>
          <span class="s0">${requiredProps</span>
            <span class="s0">.sort()</span>
            <span class="s0">.map(p =&gt; `&quot;${p}&quot;`)</span>
            <span class="s0">.join(',\n          ')}</span>
      <span class="s0">)`</span>
        <span class="s0">: '';</span>
    <span class="s0">const optionalPropsFragment =</span>
      <span class="s0">optionalProps.length &gt; 0</span>
        <span class="s0">? `Arrays.asList(</span>
          <span class="s0">${optionalProps</span>
            <span class="s0">.sort()</span>
            <span class="s0">.map(p =&gt; `&quot;${p}&quot;`)</span>
            <span class="s0">.join(',\n          ')}</span>
      <span class="s0">)`</span>
        <span class="s0">: '';</span>

    <span class="s0">return `  protected abstract Map&lt;String, Object&gt; getTypedExportedConstants();</span>

  <span class="s0">@Override</span>
  <span class="s0">@DoNotStrip</span>
  <span class="s0">public final @Nullable Map&lt;String, Object&gt; getConstants() {</span>
    <span class="s0">Map&lt;String, Object&gt; constants = getTypedExportedConstants();</span>
    <span class="s0">if (ReactBuildConfig.DEBUG || ReactBuildConfig.IS_INTERNAL_BUILD) {</span>
      <span class="s0">Set&lt;String&gt; obligatoryFlowConstants = new HashSet&lt;&gt;(${requiredPropsFragment});</span>
      <span class="s0">Set&lt;String&gt; optionalFlowConstants = new HashSet&lt;&gt;(${optionalPropsFragment});</span>
      <span class="s0">Set&lt;String&gt; undeclaredConstants = new HashSet&lt;&gt;(constants.keySet());</span>
      <span class="s0">undeclaredConstants.removeAll(obligatoryFlowConstants);</span>
      <span class="s0">undeclaredConstants.removeAll(optionalFlowConstants);</span>
      <span class="s0">if (!undeclaredConstants.isEmpty()) {</span>
        <span class="s0">throw new IllegalStateException(String.format(&quot;Native Module Flow doesn't declare constants: %s&quot;, undeclaredConstants));</span>
      <span class="s0">}</span>
      <span class="s0">undeclaredConstants = obligatoryFlowConstants;</span>
      <span class="s0">undeclaredConstants.removeAll(constants.keySet());</span>
      <span class="s0">if (!undeclaredConstants.isEmpty()) {</span>
        <span class="s0">throw new IllegalStateException(String.format(&quot;Native Module doesn't fill in constants: %s&quot;, undeclaredConstants));</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">return constants;</span>
  <span class="s0">}`;</span>
  <span class="s0">}</span>

  <span class="s0">return '';</span>
<span class="s0">}</span>

<span class="s0">module.exports = {</span>
  <span class="s0">generate(</span>
    <span class="s0">libraryName: string,</span>
    <span class="s0">schema: SchemaType,</span>
    <span class="s0">packageName?: string,</span>
    <span class="s0">assumeNonnull: boolean = false,</span>
  <span class="s0">): FilesOutput {</span>
    <span class="s0">const files = new Map&lt;string, string&gt;();</span>
    <span class="s0">const nativeModules = getModules(schema);</span>

    <span class="s0">const normalizedPackageName =</span>
      <span class="s0">packageName == null ? 'com.facebook.fbreact.specs' : packageName;</span>
    <span class="s0">const outputDir = `java/${normalizedPackageName.replace(/\./g, '/')}`;</span>

    <span class="s0">Object.keys(nativeModules).forEach(hasteModuleName =&gt; {</span>
      <span class="s0">const {</span>
        <span class="s0">aliasMap,</span>
        <span class="s0">excludedPlatforms,</span>
        <span class="s0">moduleName,</span>
        <span class="s0">spec: {properties},</span>
      <span class="s0">} = nativeModules[hasteModuleName];</span>
      <span class="s0">if (excludedPlatforms != null &amp;&amp; excludedPlatforms.includes('android')) {</span>
        <span class="s0">return;</span>
      <span class="s0">}</span>
      <span class="s0">const resolveAlias = createAliasResolver(aliasMap);</span>
      <span class="s0">const className = `${hasteModuleName}Spec`;</span>

      <span class="s0">const imports: Set&lt;string&gt; = new Set([</span>
        <span class="s0">// Always required.</span>
        <span class="s0">'com.facebook.react.bridge.ReactApplicationContext',</span>
        <span class="s0">'com.facebook.react.bridge.ReactContextBaseJavaModule',</span>
        <span class="s0">'com.facebook.react.bridge.ReactMethod',</span>
        <span class="s0">'com.facebook.react.bridge.ReactModuleWithSpec',</span>
        <span class="s0">'com.facebook.react.turbomodule.core.interfaces.TurboModule',</span>
        <span class="s0">'com.facebook.proguard.annotations.DoNotStrip',</span>
        <span class="s0">'javax.annotation.Nonnull',</span>
      <span class="s0">]);</span>

      <span class="s0">const methods = properties.map(method =&gt; {</span>
        <span class="s0">if (method.name === 'getConstants') {</span>
          <span class="s0">return buildGetConstantsMethod(method, imports);</span>
        <span class="s0">}</span>

        <span class="s0">const [methodTypeAnnotation] =</span>
          <span class="s0">unwrapNullable&lt;NativeModuleFunctionTypeAnnotation&gt;(</span>
            <span class="s0">method.typeAnnotation,</span>
          <span class="s0">);</span>

        <span class="s0">// Handle return type</span>
        <span class="s0">const translatedReturnType = translateFunctionReturnTypeToJavaType(</span>
          <span class="s0">methodTypeAnnotation.returnTypeAnnotation,</span>
          <span class="s0">typeName =&gt;</span>
            <span class="s0">`Unsupported return type for method ${method.name}. Found: ${typeName}`,</span>
          <span class="s0">resolveAlias,</span>
          <span class="s0">imports,</span>
        <span class="s0">);</span>
        <span class="s0">const returningPromise =</span>
          <span class="s0">methodTypeAnnotation.returnTypeAnnotation.type ===</span>
          <span class="s0">'PromiseTypeAnnotation';</span>
        <span class="s0">const isSyncMethod =</span>
          <span class="s0">methodTypeAnnotation.returnTypeAnnotation.type !==</span>
            <span class="s0">'VoidTypeAnnotation' &amp;&amp; !returningPromise;</span>

        <span class="s0">// Handle method args</span>
        <span class="s0">const traversedArgs = methodTypeAnnotation.params.map(param =&gt; {</span>
          <span class="s0">const translatedParam = translateFunctionParamToJavaType(</span>
            <span class="s0">param,</span>
            <span class="s0">typeName =&gt;</span>
              <span class="s0">`Unsupported type for param &quot;${param.name}&quot; in ${method.name}. Found: ${typeName}`,</span>
            <span class="s0">resolveAlias,</span>
            <span class="s0">imports,</span>
          <span class="s0">);</span>
          <span class="s0">return `${translatedParam} ${param.name}`;</span>
        <span class="s0">});</span>

        <span class="s0">if (returningPromise) {</span>
          <span class="s0">// Promise return type requires an extra arg at the end.</span>
          <span class="s0">imports.add('com.facebook.react.bridge.Promise');</span>
          <span class="s0">traversedArgs.push('Promise promise');</span>
        <span class="s0">}</span>

        <span class="s0">const methodJavaAnnotation = `@ReactMethod${</span>
          <span class="s0">isSyncMethod ? '(isBlockingSynchronousMethod = true)' : ''</span>
        <span class="s0">}\n  @DoNotStrip`;</span>
        <span class="s0">const methodBody = method.optional</span>
          <span class="s0">? getFalsyReturnStatementFromReturnType(</span>
              <span class="s0">methodTypeAnnotation.returnTypeAnnotation,</span>
              <span class="s0">typeName =&gt;</span>
                <span class="s0">`Cannot build falsy return statement for return type for method ${method.name}. Found: ${typeName}`,</span>
              <span class="s0">resolveAlias,</span>
            <span class="s0">)</span>
          <span class="s0">: null;</span>
        <span class="s0">return MethodTemplate({</span>
          <span class="s0">abstract: !method.optional,</span>
          <span class="s0">methodBody,</span>
          <span class="s0">methodJavaAnnotation,</span>
          <span class="s0">methodName: method.name,</span>
          <span class="s0">translatedReturnType,</span>
          <span class="s0">traversedArgs,</span>
        <span class="s0">});</span>
      <span class="s0">});</span>

      <span class="s0">files.set(</span>
        <span class="s0">`${outputDir}/${className}.java`,</span>
        <span class="s0">FileTemplate({</span>
          <span class="s0">packageName: normalizedPackageName,</span>
          <span class="s0">className,</span>
          <span class="s0">jsName: moduleName,</span>
          <span class="s0">methods: methods.filter(Boolean).join('\n\n'),</span>
          <span class="s0">imports: Array.from(imports)</span>
            <span class="s0">.sort()</span>
            <span class="s0">.map(p =&gt; `import ${p};`)</span>
            <span class="s0">.join('\n'),</span>
        <span class="s0">}),</span>
      <span class="s0">);</span>
    <span class="s0">});</span>

    <span class="s0">return files;</span>
  <span class="s0">},</span>
<span class="s0">};</span>
</pre>
</body>
</html>
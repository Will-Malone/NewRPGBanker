<html>
<head>
<title>fields.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #4646f1;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fields.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.buildCheckInRHS = buildCheckInRHS;</span>
<span class="s1">exports.buildFieldsInitNodes = buildFieldsInitNodes;</span>
<span class="s1">exports.buildPrivateNamesMap = buildPrivateNamesMap;</span>
<span class="s1">exports.buildPrivateNamesNodes = buildPrivateNamesNodes;</span>
<span class="s1">exports.transformPrivateNamesUsage = transformPrivateNamesUsage;</span>
<span class="s2">var </span><span class="s1">_core = require(</span><span class="s0">&quot;@babel/core&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_helperReplaceSupers = require(</span><span class="s0">&quot;@babel/helper-replace-supers&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_helperEnvironmentVisitor = require(</span><span class="s0">&quot;@babel/helper-environment-visitor&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_helperMemberExpressionToFunctions = require(</span><span class="s0">&quot;@babel/helper-member-expression-to-functions&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_helperOptimiseCallExpression = require(</span><span class="s0">&quot;@babel/helper-optimise-call-expression&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_helperAnnotateAsPure = require(</span><span class="s0">&quot;@babel/helper-annotate-as-pure&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_helperSkipTransparentExpressionWrappers = require(</span><span class="s0">&quot;@babel/helper-skip-transparent-expression-wrappers&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">ts = require(</span><span class="s0">&quot;./typescript&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">buildPrivateNamesMap(props) {</span>
  <span class="s1">const privateNamesMap = </span><span class="s2">new </span><span class="s1">Map();</span>
  <span class="s2">for </span><span class="s1">(const prop of props) {</span>
    <span class="s2">if </span><span class="s1">(prop.isPrivate()) {</span>
      <span class="s1">const {</span>
        <span class="s1">name</span>
      <span class="s1">} = prop.node.key.id;</span>
      <span class="s1">const update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {</span>
        <span class="s1">id: prop.scope.generateUidIdentifier(name),</span>
        <span class="s1">static: prop.node.static,</span>
        <span class="s1">method: !prop.isProperty()</span>
      <span class="s1">};</span>
      <span class="s2">if </span><span class="s1">(prop.isClassPrivateMethod()) {</span>
        <span class="s2">if </span><span class="s1">(prop.node.kind === </span><span class="s0">&quot;get&quot;</span><span class="s1">) {</span>
          <span class="s1">update.getId = prop.scope.generateUidIdentifier(`get_${name}`);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(prop.node.kind === </span><span class="s0">&quot;set&quot;</span><span class="s1">) {</span>
          <span class="s1">update.setId = prop.scope.generateUidIdentifier(`set_${name}`);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(prop.node.kind === </span><span class="s0">&quot;method&quot;</span><span class="s1">) {</span>
          <span class="s1">update.methodId = prop.scope.generateUidIdentifier(name);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">privateNamesMap.set(name, update);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">privateNamesMap;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildPrivateNamesNodes(privateNamesMap, privateFieldsAsProperties, privateFieldsAsSymbols, state) {</span>
  <span class="s1">const initNodes = [];</span>
  <span class="s2">for </span><span class="s1">(const [name, value] of privateNamesMap) {</span>
    <span class="s1">const {</span>
      <span class="s1">static: isStatic,</span>
      <span class="s1">method: isMethod,</span>
      <span class="s1">getId,</span>
      <span class="s1">setId</span>
    <span class="s1">} = value;</span>
    <span class="s1">const isAccessor = getId || setId;</span>
    <span class="s1">const id = _core.types.cloneNode(value.id);</span>
    <span class="s1">let init;</span>
    <span class="s2">if </span><span class="s1">(privateFieldsAsProperties) {</span>
      <span class="s1">init = _core.types.callExpression(state.addHelper(</span><span class="s0">&quot;classPrivateFieldLooseKey&quot;</span><span class="s1">), [_core.types.stringLiteral(name)]);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(privateFieldsAsSymbols) {</span>
      <span class="s1">init = _core.types.callExpression(_core.types.identifier(</span><span class="s0">&quot;Symbol&quot;</span><span class="s1">), [_core.types.stringLiteral(name)]);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!isStatic) {</span>
      <span class="s1">init = _core.types.newExpression(_core.types.identifier(!isMethod || isAccessor ? </span><span class="s0">&quot;WeakMap&quot; </span><span class="s1">: </span><span class="s0">&quot;WeakSet&quot;</span><span class="s1">), []);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(init) {</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _helperAnnotateAsPure.</span><span class="s2">default</span><span class="s1">)(init);</span>
      <span class="s1">initNodes.push(_core.template.statement.ast`</span><span class="s2">var </span><span class="s1">${id} = ${init}`);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">initNodes;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">privateNameVisitorFactory(visitor) {</span>
  <span class="s1">const nestedVisitor = _core.traverse.visitors.merge([Object.assign({}, visitor), _helperEnvironmentVisitor.</span><span class="s2">default</span><span class="s1">]);</span>
  <span class="s1">const privateNameVisitor = Object.assign({}, visitor, {</span>
    <span class="s1">Class(path) {</span>
      <span class="s1">const {</span>
        <span class="s1">privateNamesMap</span>
      <span class="s1">} = </span><span class="s2">this</span><span class="s1">;</span>
      <span class="s1">const body = path.get(</span><span class="s0">&quot;body.body&quot;</span><span class="s1">);</span>
      <span class="s1">const visiblePrivateNames = </span><span class="s2">new </span><span class="s1">Map(privateNamesMap);</span>
      <span class="s1">const redeclared = [];</span>
      <span class="s2">for </span><span class="s1">(const prop of body) {</span>
        <span class="s2">if </span><span class="s1">(!prop.isPrivate()) </span><span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">const {</span>
          <span class="s1">name</span>
        <span class="s1">} = prop.node.key.id;</span>
        <span class="s1">visiblePrivateNames.</span><span class="s2">delete</span><span class="s1">(name);</span>
        <span class="s1">redeclared.push(name);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!redeclared.length) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">path.get(</span><span class="s0">&quot;body&quot;</span><span class="s1">).traverse(nestedVisitor, Object.assign({}, </span><span class="s2">this</span><span class="s1">, {</span>
        <span class="s1">redeclared</span>
      <span class="s1">}));</span>
      <span class="s1">path.traverse(privateNameVisitor, Object.assign({}, </span><span class="s2">this</span><span class="s1">, {</span>
        <span class="s1">privateNamesMap: visiblePrivateNames</span>
      <span class="s1">}));</span>
      <span class="s1">path.skipKey(</span><span class="s0">&quot;body&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">});</span>
  <span class="s2">return </span><span class="s1">privateNameVisitor;</span>
<span class="s1">}</span>
<span class="s1">const privateNameVisitor = privateNameVisitorFactory({</span>
  <span class="s1">PrivateName(path, {</span>
    <span class="s1">noDocumentAll</span>
  <span class="s1">}) {</span>
    <span class="s1">const {</span>
      <span class="s1">privateNamesMap,</span>
      <span class="s1">redeclared</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">;</span>
    <span class="s1">const {</span>
      <span class="s1">node,</span>
      <span class="s1">parentPath</span>
    <span class="s1">} = path;</span>
    <span class="s2">if </span><span class="s1">(!parentPath.isMemberExpression({</span>
      <span class="s1">property: node</span>
    <span class="s1">}) &amp;&amp; !parentPath.isOptionalMemberExpression({</span>
      <span class="s1">property: node</span>
    <span class="s1">})) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const {</span>
      <span class="s1">name</span>
    <span class="s1">} = node.id;</span>
    <span class="s2">if </span><span class="s1">(!privateNamesMap.has(name)) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(redeclared &amp;&amp; redeclared.includes(name)) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.handle(parentPath, noDocumentAll);</span>
  <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">unshadow(name, scope, innerBinding) {</span>
  <span class="s2">while </span><span class="s1">((_scope = scope) != </span><span class="s2">null </span><span class="s1">&amp;&amp; _scope.hasBinding(name) &amp;&amp; !scope.bindingIdentifierEquals(name, innerBinding)) {</span>
    <span class="s2">var </span><span class="s1">_scope;</span>
    <span class="s1">scope.rename(name);</span>
    <span class="s1">scope = scope.parent;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildCheckInRHS(rhs, file, inRHSIsObject) {</span>
  <span class="s2">if </span><span class="s1">(inRHSIsObject || !(file.availableHelper != </span><span class="s2">null </span><span class="s1">&amp;&amp; file.availableHelper(</span><span class="s0">&quot;checkInRHS&quot;</span><span class="s1">))) </span><span class="s2">return </span><span class="s1">rhs;</span>
  <span class="s2">return </span><span class="s1">_core.types.callExpression(file.addHelper(</span><span class="s0">&quot;checkInRHS&quot;</span><span class="s1">), [rhs]);</span>
<span class="s1">}</span>
<span class="s1">const privateInVisitor = privateNameVisitorFactory({</span>
  <span class="s1">BinaryExpression(path, {</span>
    <span class="s1">file</span>
  <span class="s1">}) {</span>
    <span class="s1">const {</span>
      <span class="s1">operator,</span>
      <span class="s1">left,</span>
      <span class="s1">right</span>
    <span class="s1">} = path.node;</span>
    <span class="s2">if </span><span class="s1">(operator !== </span><span class="s0">&quot;in&quot;</span><span class="s1">) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(!_core.types.isPrivateName(left)) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">const {</span>
      <span class="s1">privateFieldsAsProperties,</span>
      <span class="s1">privateNamesMap,</span>
      <span class="s1">redeclared</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">;</span>
    <span class="s1">const {</span>
      <span class="s1">name</span>
    <span class="s1">} = left.id;</span>
    <span class="s2">if </span><span class="s1">(!privateNamesMap.has(name)) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(redeclared &amp;&amp; redeclared.includes(name)) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">unshadow(</span><span class="s2">this</span><span class="s1">.classRef.name, path.scope, </span><span class="s2">this</span><span class="s1">.innerBinding);</span>
    <span class="s2">if </span><span class="s1">(privateFieldsAsProperties) {</span>
      <span class="s1">const {</span>
        <span class="s1">id</span>
      <span class="s1">} = privateNamesMap.get(name);</span>
      <span class="s1">path.replaceWith(_core.template.expression.ast`</span>
        <span class="s1">Object.prototype.hasOwnProperty.call(${buildCheckInRHS(right, file)}, ${_core.types.cloneNode(id)})</span>
      <span class="s1">`);</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const {</span>
      <span class="s1">id,</span>
      <span class="s1">static: isStatic</span>
    <span class="s1">} = privateNamesMap.get(name);</span>
    <span class="s2">if </span><span class="s1">(isStatic) {</span>
      <span class="s1">path.replaceWith(_core.template.expression.ast`${buildCheckInRHS(right, file)} === ${_core.types.cloneNode(</span><span class="s2">this</span><span class="s1">.classRef)}`);</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">path.replaceWith(_core.template.expression.ast`${_core.types.cloneNode(id)}.has(${buildCheckInRHS(right, file)})`);</span>
  <span class="s1">}</span>
<span class="s1">});</span>
<span class="s1">const privateNameHandlerSpec = {</span>
  <span class="s1">memoise(member, count) {</span>
    <span class="s1">const {</span>
      <span class="s1">scope</span>
    <span class="s1">} = member;</span>
    <span class="s1">const {</span>
      <span class="s1">object</span>
    <span class="s1">} = member.node;</span>
    <span class="s1">const memo = scope.maybeGenerateMemoised(object);</span>
    <span class="s2">if </span><span class="s1">(!memo) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.memoiser.set(object, memo, count);</span>
  <span class="s1">},</span>
  <span class="s1">receiver(member) {</span>
    <span class="s1">const {</span>
      <span class="s1">object</span>
    <span class="s1">} = member.node;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.memoiser.has(object)) {</span>
      <span class="s2">return </span><span class="s1">_core.types.cloneNode(</span><span class="s2">this</span><span class="s1">.memoiser.get(object));</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">_core.types.cloneNode(object);</span>
  <span class="s1">},</span>
  <span class="s1">get(member) {</span>
    <span class="s1">const {</span>
      <span class="s1">classRef,</span>
      <span class="s1">privateNamesMap,</span>
      <span class="s1">file,</span>
      <span class="s1">innerBinding</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">;</span>
    <span class="s1">const {</span>
      <span class="s1">name</span>
    <span class="s1">} = member.node.property.id;</span>
    <span class="s1">const {</span>
      <span class="s1">id,</span>
      <span class="s1">static: isStatic,</span>
      <span class="s1">method: isMethod,</span>
      <span class="s1">methodId,</span>
      <span class="s1">getId,</span>
      <span class="s1">setId</span>
    <span class="s1">} = privateNamesMap.get(name);</span>
    <span class="s1">const isAccessor = getId || setId;</span>
    <span class="s2">if </span><span class="s1">(isStatic) {</span>
      <span class="s1">const helperName = isMethod &amp;&amp; !isAccessor ? </span><span class="s0">&quot;classStaticPrivateMethodGet&quot; </span><span class="s1">: </span><span class="s0">&quot;classStaticPrivateFieldSpecGet&quot;</span><span class="s1">;</span>
      <span class="s1">unshadow(classRef.name, member.scope, innerBinding);</span>
      <span class="s2">return </span><span class="s1">_core.types.callExpression(file.addHelper(helperName), [</span><span class="s2">this</span><span class="s1">.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isMethod) {</span>
      <span class="s2">if </span><span class="s1">(isAccessor) {</span>
        <span class="s2">if </span><span class="s1">(!getId &amp;&amp; setId) {</span>
          <span class="s2">if </span><span class="s1">(file.availableHelper(</span><span class="s0">&quot;writeOnlyError&quot;</span><span class="s1">)) {</span>
            <span class="s2">return </span><span class="s1">_core.types.sequenceExpression([</span><span class="s2">this</span><span class="s1">.receiver(member), _core.types.callExpression(file.addHelper(</span><span class="s0">&quot;writeOnlyError&quot;</span><span class="s1">), [_core.types.stringLiteral(`#${name}`)])]);</span>
          <span class="s1">}</span>
          <span class="s1">console.warn(`@babel/helpers is outdated, update it to silence </span><span class="s2">this </span><span class="s1">warning.`);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">_core.types.callExpression(file.addHelper(</span><span class="s0">&quot;classPrivateFieldGet&quot;</span><span class="s1">), [</span><span class="s2">this</span><span class="s1">.receiver(member), _core.types.cloneNode(id)]);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">_core.types.callExpression(file.addHelper(</span><span class="s0">&quot;classPrivateMethodGet&quot;</span><span class="s1">), [</span><span class="s2">this</span><span class="s1">.receiver(member), _core.types.cloneNode(id), _core.types.cloneNode(methodId)]);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">_core.types.callExpression(file.addHelper(</span><span class="s0">&quot;classPrivateFieldGet&quot;</span><span class="s1">), [</span><span class="s2">this</span><span class="s1">.receiver(member), _core.types.cloneNode(id)]);</span>
  <span class="s1">},</span>
  <span class="s1">boundGet(member) {</span>
    <span class="s2">this</span><span class="s1">.memoise(member, </span><span class="s3">1</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">_core.types.callExpression(_core.types.memberExpression(</span><span class="s2">this</span><span class="s1">.get(member), _core.types.identifier(</span><span class="s0">&quot;bind&quot;</span><span class="s1">)), [</span><span class="s2">this</span><span class="s1">.receiver(member)]);</span>
  <span class="s1">},</span>
  <span class="s1">set(member, value) {</span>
    <span class="s1">const {</span>
      <span class="s1">classRef,</span>
      <span class="s1">privateNamesMap,</span>
      <span class="s1">file</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">;</span>
    <span class="s1">const {</span>
      <span class="s1">name</span>
    <span class="s1">} = member.node.property.id;</span>
    <span class="s1">const {</span>
      <span class="s1">id,</span>
      <span class="s1">static: isStatic,</span>
      <span class="s1">method: isMethod,</span>
      <span class="s1">setId,</span>
      <span class="s1">getId</span>
    <span class="s1">} = privateNamesMap.get(name);</span>
    <span class="s1">const isAccessor = getId || setId;</span>
    <span class="s2">if </span><span class="s1">(isStatic) {</span>
      <span class="s1">const helperName = isMethod &amp;&amp; !isAccessor ? </span><span class="s0">&quot;classStaticPrivateMethodSet&quot; </span><span class="s1">: </span><span class="s0">&quot;classStaticPrivateFieldSpecSet&quot;</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">_core.types.callExpression(file.addHelper(helperName), [</span><span class="s2">this</span><span class="s1">.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id), value]);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isMethod) {</span>
      <span class="s2">if </span><span class="s1">(setId) {</span>
        <span class="s2">return </span><span class="s1">_core.types.callExpression(file.addHelper(</span><span class="s0">&quot;classPrivateFieldSet&quot;</span><span class="s1">), [</span><span class="s2">this</span><span class="s1">.receiver(member), _core.types.cloneNode(id), value]);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">_core.types.sequenceExpression([</span><span class="s2">this</span><span class="s1">.receiver(member), value, _core.types.callExpression(file.addHelper(</span><span class="s0">&quot;readOnlyError&quot;</span><span class="s1">), [_core.types.stringLiteral(`#${name}`)])]);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">_core.types.callExpression(file.addHelper(</span><span class="s0">&quot;classPrivateFieldSet&quot;</span><span class="s1">), [</span><span class="s2">this</span><span class="s1">.receiver(member), _core.types.cloneNode(id), value]);</span>
  <span class="s1">},</span>
  <span class="s1">destructureSet(member) {</span>
    <span class="s1">const {</span>
      <span class="s1">classRef,</span>
      <span class="s1">privateNamesMap,</span>
      <span class="s1">file</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">;</span>
    <span class="s1">const {</span>
      <span class="s1">name</span>
    <span class="s1">} = member.node.property.id;</span>
    <span class="s1">const {</span>
      <span class="s1">id,</span>
      <span class="s1">static: isStatic</span>
    <span class="s1">} = privateNamesMap.get(name);</span>
    <span class="s2">if </span><span class="s1">(isStatic) {</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">helper = file.addHelper(</span><span class="s0">&quot;classStaticPrivateFieldDestructureSet&quot;</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(_unused) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;Babel can not transpile `[C.#p] = [0]` with @babel/helpers &lt; 7.13.10, </span><span class="s4">\n</span><span class="s0">&quot; </span><span class="s1">+ </span><span class="s0">&quot;please update @babel/helpers to the latest version.&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">_core.types.memberExpression(_core.types.callExpression(helper, [</span><span class="s2">this</span><span class="s1">.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]), _core.types.identifier(</span><span class="s0">&quot;value&quot;</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">_core.types.memberExpression(_core.types.callExpression(file.addHelper(</span><span class="s0">&quot;classPrivateFieldDestructureSet&quot;</span><span class="s1">), [</span><span class="s2">this</span><span class="s1">.receiver(member), _core.types.cloneNode(id)]), _core.types.identifier(</span><span class="s0">&quot;value&quot;</span><span class="s1">));</span>
  <span class="s1">},</span>
  <span class="s1">call(member, args) {</span>
    <span class="s2">this</span><span class="s1">.memoise(member, </span><span class="s3">1</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _helperOptimiseCallExpression.</span><span class="s2">default</span><span class="s1">)(</span><span class="s2">this</span><span class="s1">.get(member), </span><span class="s2">this</span><span class="s1">.receiver(member), args, </span><span class="s2">false</span><span class="s1">);</span>
  <span class="s1">},</span>
  <span class="s1">optionalCall(member, args) {</span>
    <span class="s2">this</span><span class="s1">.memoise(member, </span><span class="s3">1</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _helperOptimiseCallExpression.</span><span class="s2">default</span><span class="s1">)(</span><span class="s2">this</span><span class="s1">.get(member), </span><span class="s2">this</span><span class="s1">.receiver(member), args, </span><span class="s2">true</span><span class="s1">);</span>
  <span class="s1">},</span>
  <span class="s2">delete</span><span class="s1">() {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;Internal Babel error: deleting private elements is a parsing error.&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s1">const privateNameHandlerLoose = {</span>
  <span class="s1">get(member) {</span>
    <span class="s1">const {</span>
      <span class="s1">privateNamesMap,</span>
      <span class="s1">file</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">;</span>
    <span class="s1">const {</span>
      <span class="s1">object</span>
    <span class="s1">} = member.node;</span>
    <span class="s1">const {</span>
      <span class="s1">name</span>
    <span class="s1">} = member.node.property.id;</span>
    <span class="s2">return </span><span class="s1">_core.template.expression`BASE(REF, PROP)[PROP]`({</span>
      <span class="s1">BASE: file.addHelper(</span><span class="s0">&quot;classPrivateFieldLooseBase&quot;</span><span class="s1">),</span>
      <span class="s1">REF: _core.types.cloneNode(object),</span>
      <span class="s1">PROP: _core.types.cloneNode(privateNamesMap.get(name).id)</span>
    <span class="s1">});</span>
  <span class="s1">},</span>
  <span class="s1">set() {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;private name handler with loose = true don't need set()&quot;</span><span class="s1">);</span>
  <span class="s1">},</span>
  <span class="s1">boundGet(member) {</span>
    <span class="s2">return </span><span class="s1">_core.types.callExpression(_core.types.memberExpression(</span><span class="s2">this</span><span class="s1">.get(member), _core.types.identifier(</span><span class="s0">&quot;bind&quot;</span><span class="s1">)), [_core.types.cloneNode(member.node.object)]);</span>
  <span class="s1">},</span>
  <span class="s1">simpleSet(member) {</span>
    <span class="s2">return this</span><span class="s1">.get(member);</span>
  <span class="s1">},</span>
  <span class="s1">destructureSet(member) {</span>
    <span class="s2">return this</span><span class="s1">.get(member);</span>
  <span class="s1">},</span>
  <span class="s1">call(member, args) {</span>
    <span class="s2">return </span><span class="s1">_core.types.callExpression(</span><span class="s2">this</span><span class="s1">.get(member), args);</span>
  <span class="s1">},</span>
  <span class="s1">optionalCall(member, args) {</span>
    <span class="s2">return </span><span class="s1">_core.types.optionalCallExpression(</span><span class="s2">this</span><span class="s1">.get(member), args, </span><span class="s2">true</span><span class="s1">);</span>
  <span class="s1">},</span>
  <span class="s2">delete</span><span class="s1">() {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;Internal Babel error: deleting private elements is a parsing error.&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">transformPrivateNamesUsage(ref, path, privateNamesMap, {</span>
  <span class="s1">privateFieldsAsProperties,</span>
  <span class="s1">noDocumentAll,</span>
  <span class="s1">innerBinding</span>
<span class="s1">}, state) {</span>
  <span class="s2">if </span><span class="s1">(!privateNamesMap.size) </span><span class="s2">return</span><span class="s1">;</span>
  <span class="s1">const body = path.get(</span><span class="s0">&quot;body&quot;</span><span class="s1">);</span>
  <span class="s1">const handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;</span>
  <span class="s1">(</span><span class="s3">0</span><span class="s1">, _helperMemberExpressionToFunctions.</span><span class="s2">default</span><span class="s1">)(body, privateNameVisitor, Object.assign({</span>
    <span class="s1">privateNamesMap,</span>
    <span class="s1">classRef: ref,</span>
    <span class="s1">file: state</span>
  <span class="s1">}, handler, {</span>
    <span class="s1">noDocumentAll,</span>
    <span class="s1">innerBinding</span>
  <span class="s1">}));</span>
  <span class="s1">body.traverse(privateInVisitor, {</span>
    <span class="s1">privateNamesMap,</span>
    <span class="s1">classRef: ref,</span>
    <span class="s1">file: state,</span>
    <span class="s1">privateFieldsAsProperties,</span>
    <span class="s1">innerBinding</span>
  <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {</span>
  <span class="s1">const {</span>
    <span class="s1">id</span>
  <span class="s1">} = privateNamesMap.get(prop.node.key.id.name);</span>
  <span class="s1">const value = prop.node.value || prop.scope.buildUndefinedNode();</span>
  <span class="s2">return </span><span class="s1">inheritPropComments(_core.template.statement.ast`</span>
      <span class="s1">Object.defineProperty(${ref}, ${_core.types.cloneNode(id)}, {</span>
        <span class="s5">// configurable is false by default</span>
        <span class="s5">// enumerable is false by default</span>
        <span class="s1">writable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">value: ${value}</span>
      <span class="s1">});</span>
    <span class="s1">`, prop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap, state) {</span>
  <span class="s1">const {</span>
    <span class="s1">id</span>
  <span class="s1">} = privateNamesMap.get(prop.node.key.id.name);</span>
  <span class="s1">const value = prop.node.value || prop.scope.buildUndefinedNode();</span>
  <span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!state.availableHelper(</span><span class="s0">&quot;classPrivateFieldInitSpec&quot;</span><span class="s1">)) {</span>
      <span class="s2">return </span><span class="s1">inheritPropComments(_core.template.statement.ast`${_core.types.cloneNode(id)}.set(${ref}, {</span>
          <span class="s5">// configurable is always false for private elements</span>
          <span class="s5">// enumerable is always false for private elements</span>
          <span class="s1">writable: </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s1">value: ${value},</span>
        <span class="s1">})`, prop);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">const helper = state.addHelper(</span><span class="s0">&quot;classPrivateFieldInitSpec&quot;</span><span class="s1">);</span>
  <span class="s2">return </span><span class="s1">inheritPropComments(_core.template.statement.ast`${helper}(</span>
      <span class="s1">${_core.types.thisExpression()},</span>
      <span class="s1">${_core.types.cloneNode(id)},</span>
      <span class="s1">{</span>
        <span class="s1">writable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">value: ${value}</span>
      <span class="s1">},</span>
    <span class="s1">)`, prop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {</span>
  <span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span>
  <span class="s1">const {</span>
    <span class="s1">id,</span>
    <span class="s1">getId,</span>
    <span class="s1">setId,</span>
    <span class="s1">initAdded</span>
  <span class="s1">} = privateName;</span>
  <span class="s1">const isAccessor = getId || setId;</span>
  <span class="s2">if </span><span class="s1">(!prop.isProperty() &amp;&amp; (initAdded || !isAccessor)) </span><span class="s2">return</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(isAccessor) {</span>
    <span class="s1">privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {</span>
      <span class="s1">initAdded: </span><span class="s2">true</span>
    <span class="s1">}));</span>
    <span class="s2">return </span><span class="s1">inheritPropComments(_core.template.statement.ast`</span>
        <span class="s2">var </span><span class="s1">${_core.types.cloneNode(id)} = {</span>
          <span class="s5">// configurable is false by default</span>
          <span class="s5">// enumerable is false by default</span>
          <span class="s5">// writable is false by default</span>
          <span class="s1">get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},</span>
          <span class="s1">set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}</span>
        <span class="s1">}</span>
      <span class="s1">`, prop);</span>
  <span class="s1">}</span>
  <span class="s1">const value = prop.node.value || prop.scope.buildUndefinedNode();</span>
  <span class="s2">return </span><span class="s1">inheritPropComments(_core.template.statement.ast`</span>
      <span class="s2">var </span><span class="s1">${_core.types.cloneNode(id)} = {</span>
        <span class="s5">// configurable is false by default</span>
        <span class="s5">// enumerable is false by default</span>
        <span class="s1">writable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">value: ${value}</span>
      <span class="s1">};</span>
    <span class="s1">`, prop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {</span>
  <span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span>
  <span class="s1">const {</span>
    <span class="s1">methodId,</span>
    <span class="s1">id,</span>
    <span class="s1">getId,</span>
    <span class="s1">setId,</span>
    <span class="s1">initAdded</span>
  <span class="s1">} = privateName;</span>
  <span class="s2">if </span><span class="s1">(initAdded) </span><span class="s2">return</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(methodId) {</span>
    <span class="s2">return </span><span class="s1">inheritPropComments(_core.template.statement.ast`</span>
        <span class="s1">Object.defineProperty(${ref}, ${id}, {</span>
          <span class="s5">// configurable is false by default</span>
          <span class="s5">// enumerable is false by default</span>
          <span class="s5">// writable is false by default</span>
          <span class="s1">value: ${methodId.name}</span>
        <span class="s1">});</span>
      <span class="s1">`, prop);</span>
  <span class="s1">}</span>
  <span class="s1">const isAccessor = getId || setId;</span>
  <span class="s2">if </span><span class="s1">(isAccessor) {</span>
    <span class="s1">privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {</span>
      <span class="s1">initAdded: </span><span class="s2">true</span>
    <span class="s1">}));</span>
    <span class="s2">return </span><span class="s1">inheritPropComments(_core.template.statement.ast`</span>
        <span class="s1">Object.defineProperty(${ref}, ${id}, {</span>
          <span class="s5">// configurable is false by default</span>
          <span class="s5">// enumerable is false by default</span>
          <span class="s5">// writable is false by default</span>
          <span class="s1">get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},</span>
          <span class="s1">set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}</span>
        <span class="s1">});</span>
      <span class="s1">`, prop);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap, state) {</span>
  <span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span>
  <span class="s1">const {</span>
    <span class="s1">getId,</span>
    <span class="s1">setId,</span>
    <span class="s1">initAdded</span>
  <span class="s1">} = privateName;</span>
  <span class="s2">if </span><span class="s1">(initAdded) </span><span class="s2">return</span><span class="s1">;</span>
  <span class="s1">const isAccessor = getId || setId;</span>
  <span class="s2">if </span><span class="s1">(isAccessor) {</span>
    <span class="s2">return </span><span class="s1">buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state) {</span>
  <span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span>
  <span class="s1">const {</span>
    <span class="s1">id,</span>
    <span class="s1">getId,</span>
    <span class="s1">setId</span>
  <span class="s1">} = privateName;</span>
  <span class="s1">privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {</span>
    <span class="s1">initAdded: </span><span class="s2">true</span>
  <span class="s1">}));</span>
  <span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!state.availableHelper(</span><span class="s0">&quot;classPrivateFieldInitSpec&quot;</span><span class="s1">)) {</span>
      <span class="s2">return </span><span class="s1">inheritPropComments(_core.template.statement.ast`</span>
          <span class="s1">${id}.set(${ref}, {</span>
            <span class="s1">get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},</span>
            <span class="s1">set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}</span>
          <span class="s1">});</span>
        <span class="s1">`, prop);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">const helper = state.addHelper(</span><span class="s0">&quot;classPrivateFieldInitSpec&quot;</span><span class="s1">);</span>
  <span class="s2">return </span><span class="s1">inheritPropComments(_core.template.statement.ast`${helper}(</span>
      <span class="s1">${_core.types.thisExpression()},</span>
      <span class="s1">${_core.types.cloneNode(id)},</span>
      <span class="s1">{</span>
        <span class="s1">get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},</span>
        <span class="s1">set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}</span>
      <span class="s1">},</span>
    <span class="s1">)`, prop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state) {</span>
  <span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span>
  <span class="s1">const {</span>
    <span class="s1">id</span>
  <span class="s1">} = privateName;</span>
  <span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!state.availableHelper(</span><span class="s0">&quot;classPrivateMethodInitSpec&quot;</span><span class="s1">)) {</span>
      <span class="s2">return </span><span class="s1">inheritPropComments(_core.template.statement.ast`${id}.add(${ref})`, prop);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">const helper = state.addHelper(</span><span class="s0">&quot;classPrivateMethodInitSpec&quot;</span><span class="s1">);</span>
  <span class="s2">return </span><span class="s1">inheritPropComments(_core.template.statement.ast`${helper}(</span>
      <span class="s1">${_core.types.thisExpression()},</span>
      <span class="s1">${_core.types.cloneNode(id)}</span>
    <span class="s1">)`, prop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildPublicFieldInitLoose(ref, prop) {</span>
  <span class="s1">const {</span>
    <span class="s1">key,</span>
    <span class="s1">computed</span>
  <span class="s1">} = prop.node;</span>
  <span class="s1">const value = prop.node.value || prop.scope.buildUndefinedNode();</span>
  <span class="s2">return </span><span class="s1">inheritPropComments(_core.types.expressionStatement(_core.types.assignmentExpression(</span><span class="s0">&quot;=&quot;</span><span class="s1">, _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value)), prop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildPublicFieldInitSpec(ref, prop, state) {</span>
  <span class="s1">const {</span>
    <span class="s1">key,</span>
    <span class="s1">computed</span>
  <span class="s1">} = prop.node;</span>
  <span class="s1">const value = prop.node.value || prop.scope.buildUndefinedNode();</span>
  <span class="s2">return </span><span class="s1">inheritPropComments(_core.types.expressionStatement(_core.types.callExpression(state.addHelper(</span><span class="s0">&quot;defineProperty&quot;</span><span class="s1">), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value])), prop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {</span>
  <span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span>
  <span class="s1">const {</span>
    <span class="s1">id,</span>
    <span class="s1">methodId,</span>
    <span class="s1">getId,</span>
    <span class="s1">setId,</span>
    <span class="s1">initAdded</span>
  <span class="s1">} = privateName;</span>
  <span class="s2">if </span><span class="s1">(initAdded) </span><span class="s2">return</span><span class="s1">;</span>
  <span class="s1">const isAccessor = getId || setId;</span>
  <span class="s2">if </span><span class="s1">(isAccessor) {</span>
    <span class="s1">privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {</span>
      <span class="s1">initAdded: </span><span class="s2">true</span>
    <span class="s1">}));</span>
    <span class="s2">return </span><span class="s1">inheritPropComments(_core.template.statement.ast`</span>
        <span class="s1">Object.defineProperty(${ref}, ${id}, {</span>
          <span class="s5">// configurable is false by default</span>
          <span class="s5">// enumerable is false by default</span>
          <span class="s5">// writable is false by default</span>
          <span class="s1">get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},</span>
          <span class="s1">set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}</span>
        <span class="s1">})</span>
      <span class="s1">`, prop);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">inheritPropComments(_core.template.statement.ast`</span>
      <span class="s1">Object.defineProperty(${ref}, ${id}, {</span>
        <span class="s5">// configurable is false by default</span>
        <span class="s5">// enumerable is false by default</span>
        <span class="s5">// writable is false by default</span>
        <span class="s1">value: ${methodId.name}</span>
      <span class="s1">});</span>
    <span class="s1">`, prop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span>
  <span class="s1">const {</span>
    <span class="s1">id,</span>
    <span class="s1">methodId,</span>
    <span class="s1">getId,</span>
    <span class="s1">setId,</span>
    <span class="s1">getterDeclared,</span>
    <span class="s1">setterDeclared,</span>
    <span class="s1">static: isStatic</span>
  <span class="s1">} = privateName;</span>
  <span class="s1">const {</span>
    <span class="s1">params,</span>
    <span class="s1">body,</span>
    <span class="s1">generator,</span>
    <span class="s1">async</span>
  <span class="s1">} = prop.node;</span>
  <span class="s1">const isGetter = getId &amp;&amp; !getterDeclared &amp;&amp; params.length === </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s1">const isSetter = setId &amp;&amp; !setterDeclared &amp;&amp; params.length &gt; </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s1">let declId = methodId;</span>
  <span class="s2">if </span><span class="s1">(isGetter) {</span>
    <span class="s1">privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {</span>
      <span class="s1">getterDeclared: </span><span class="s2">true</span>
    <span class="s1">}));</span>
    <span class="s1">declId = getId;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isSetter) {</span>
    <span class="s1">privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {</span>
      <span class="s1">setterDeclared: </span><span class="s2">true</span>
    <span class="s1">}));</span>
    <span class="s1">declId = setId;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isStatic &amp;&amp; !privateFieldsAsProperties) {</span>
    <span class="s1">declId = id;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">inheritPropComments(_core.types.functionDeclaration(_core.types.cloneNode(declId), params, body, generator, async), prop);</span>
<span class="s1">}</span>
<span class="s1">const thisContextVisitor = _core.traverse.visitors.merge([{</span>
  <span class="s1">UnaryExpression(path) {</span>
    <span class="s1">const {</span>
      <span class="s1">node</span>
    <span class="s1">} = path;</span>
    <span class="s2">if </span><span class="s1">(node.operator === </span><span class="s0">&quot;delete&quot;</span><span class="s1">) {</span>
      <span class="s1">const argument = (</span><span class="s3">0</span><span class="s1">, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes)(node.argument);</span>
      <span class="s2">if </span><span class="s1">(_core.types.isThisExpression(argument)) {</span>
        <span class="s1">path.replaceWith(_core.types.booleanLiteral(</span><span class="s2">true</span><span class="s1">));</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">},</span>
  <span class="s1">ThisExpression(path, state) {</span>
    <span class="s1">state.needsClassRef = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">path.replaceWith(_core.types.cloneNode(state.classRef));</span>
  <span class="s1">},</span>
  <span class="s1">MetaProperty(path) {</span>
    <span class="s1">const {</span>
      <span class="s1">node,</span>
      <span class="s1">scope</span>
    <span class="s1">} = path;</span>
    <span class="s2">if </span><span class="s1">(node.meta.name === </span><span class="s0">&quot;new&quot; </span><span class="s1">&amp;&amp; node.property.name === </span><span class="s0">&quot;target&quot;</span><span class="s1">) {</span>
      <span class="s1">path.replaceWith(scope.buildUndefinedNode());</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}, _helperEnvironmentVisitor.</span><span class="s2">default</span><span class="s1">]);</span>
<span class="s1">const innerReferencesVisitor = {</span>
  <span class="s1">ReferencedIdentifier(path, state) {</span>
    <span class="s2">if </span><span class="s1">(path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)) {</span>
      <span class="s1">state.needsClassRef = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">path.node.name = state.classRef.name;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">replaceThisContext(path, ref, getSuperRef, file, isStaticBlock, constantSuper, innerBindingRef) {</span>
  <span class="s2">var </span><span class="s1">_state$classRef;</span>
  <span class="s1">const state = {</span>
    <span class="s1">classRef: ref,</span>
    <span class="s1">needsClassRef: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">innerBinding: innerBindingRef</span>
  <span class="s1">};</span>
  <span class="s1">const replacer = </span><span class="s2">new </span><span class="s1">_helperReplaceSupers.</span><span class="s2">default</span><span class="s1">({</span>
    <span class="s1">methodPath: path,</span>
    <span class="s1">constantSuper,</span>
    <span class="s1">file,</span>
    <span class="s1">refToPreserve: ref,</span>
    <span class="s1">getSuperRef,</span>
    <span class="s1">getObjectRef() {</span>
      <span class="s1">state.needsClassRef = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">_core.types.isStaticBlock != </span><span class="s2">null </span><span class="s1">&amp;&amp; _core.types.isStaticBlock(path.node) || path.node.static ? ref : _core.types.memberExpression(ref, _core.types.identifier(</span><span class="s0">&quot;prototype&quot;</span><span class="s1">));</span>
    <span class="s1">}</span>
  <span class="s1">});</span>
  <span class="s1">replacer.replace();</span>
  <span class="s2">if </span><span class="s1">(isStaticBlock || path.isProperty()) {</span>
    <span class="s1">path.traverse(thisContextVisitor, state);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(innerBindingRef != </span><span class="s2">null </span><span class="s1">&amp;&amp; (_state$classRef = state.classRef) != </span><span class="s2">null </span><span class="s1">&amp;&amp; _state$classRef.name &amp;&amp; state.classRef.name !== (innerBindingRef == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: innerBindingRef.name)) {</span>
    <span class="s1">path.traverse(innerReferencesVisitor, state);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">state.needsClassRef;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isNameOrLength({</span>
  <span class="s1">key,</span>
  <span class="s1">computed</span>
<span class="s1">}) {</span>
  <span class="s2">if </span><span class="s1">(key.type === </span><span class="s0">&quot;Identifier&quot;</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">!computed &amp;&amp; (key.name === </span><span class="s0">&quot;name&quot; </span><span class="s1">|| key.name === </span><span class="s0">&quot;length&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(key.type === </span><span class="s0">&quot;StringLiteral&quot;</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">key.value === </span><span class="s0">&quot;name&quot; </span><span class="s1">|| key.value === </span><span class="s0">&quot;length&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">inheritPropComments(node, prop) {</span>
  <span class="s1">_core.types.inheritLeadingComments(node, prop.node);</span>
  <span class="s1">_core.types.inheritInnerComments(node, prop.node);</span>
  <span class="s2">return </span><span class="s1">node;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildFieldsInitNodes(ref, superRef, props, privateNamesMap, state, setPublicClassFields, privateFieldsAsProperties, constantSuper, innerBindingRef) {</span>
  <span class="s1">let needsClassRef = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">let injectSuperRef;</span>
  <span class="s1">const staticNodes = [];</span>
  <span class="s1">const instanceNodes = [];</span>
  <span class="s1">const pureStaticNodes = [];</span>
  <span class="s1">const getSuperRef = _core.types.isIdentifier(superRef) ? () =&gt; superRef : () =&gt; {</span>
    <span class="s2">var </span><span class="s1">_injectSuperRef;</span>
    <span class="s1">(_injectSuperRef = injectSuperRef) != </span><span class="s2">null </span><span class="s1">? _injectSuperRef : injectSuperRef = props[</span><span class="s3">0</span><span class="s1">].scope.generateUidIdentifierBasedOnNode(superRef);</span>
    <span class="s2">return </span><span class="s1">injectSuperRef;</span>
  <span class="s1">};</span>
  <span class="s2">for </span><span class="s1">(const prop of props) {</span>
    <span class="s1">prop.isClassProperty() &amp;&amp; ts.assertFieldTransformed(prop);</span>
    <span class="s1">const isStatic = !(_core.types.isStaticBlock != </span><span class="s2">null </span><span class="s1">&amp;&amp; _core.types.isStaticBlock(prop.node)) &amp;&amp; prop.node.static;</span>
    <span class="s1">const isInstance = !isStatic;</span>
    <span class="s1">const isPrivate = prop.isPrivate();</span>
    <span class="s1">const isPublic = !isPrivate;</span>
    <span class="s1">const isField = prop.isProperty();</span>
    <span class="s1">const isMethod = !isField;</span>
    <span class="s1">const isStaticBlock = prop.isStaticBlock == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: prop.isStaticBlock();</span>
    <span class="s2">if </span><span class="s1">(isStatic || isMethod &amp;&amp; isPrivate || isStaticBlock) {</span>
      <span class="s1">const replaced = replaceThisContext(prop, ref, getSuperRef, state, isStaticBlock, constantSuper, innerBindingRef);</span>
      <span class="s1">needsClassRef = needsClassRef || replaced;</span>
    <span class="s1">}</span>
    <span class="s2">switch </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s2">case </span><span class="s1">isStaticBlock:</span>
        <span class="s1">{</span>
          <span class="s1">const blockBody = prop.node.body;</span>
          <span class="s2">if </span><span class="s1">(blockBody.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp; _core.types.isExpressionStatement(blockBody[</span><span class="s3">0</span><span class="s1">])) {</span>
            <span class="s1">staticNodes.push(inheritPropComments(blockBody[</span><span class="s3">0</span><span class="s1">], prop));</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">staticNodes.push(_core.types.inheritsComments(_core.template.statement.ast`(() =&gt; { ${blockBody} })()`, prop.node));</span>
          <span class="s1">}</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s1">isStatic &amp;&amp; isPrivate &amp;&amp; isField &amp;&amp; privateFieldsAsProperties:</span>
        <span class="s1">needsClassRef = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s1">isStatic &amp;&amp; isPrivate &amp;&amp; isField &amp;&amp; !privateFieldsAsProperties:</span>
        <span class="s1">needsClassRef = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s1">isStatic &amp;&amp; isPublic &amp;&amp; isField &amp;&amp; setPublicClassFields:</span>
        <span class="s2">if </span><span class="s1">(!isNameOrLength(prop.node)) {</span>
          <span class="s1">needsClassRef = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s1">staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s1">isStatic &amp;&amp; isPublic &amp;&amp; isField &amp;&amp; !setPublicClassFields:</span>
        <span class="s1">needsClassRef = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, state));</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s1">isInstance &amp;&amp; isPrivate &amp;&amp; isField &amp;&amp; privateFieldsAsProperties:</span>
        <span class="s1">instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s1">isInstance &amp;&amp; isPrivate &amp;&amp; isField &amp;&amp; !privateFieldsAsProperties:</span>
        <span class="s1">instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap, state));</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s1">isInstance &amp;&amp; isPrivate &amp;&amp; isMethod &amp;&amp; privateFieldsAsProperties:</span>
        <span class="s1">instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap));</span>
        <span class="s1">pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s1">isInstance &amp;&amp; isPrivate &amp;&amp; isMethod &amp;&amp; !privateFieldsAsProperties:</span>
        <span class="s1">instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap, state));</span>
        <span class="s1">pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s1">isStatic &amp;&amp; isPrivate &amp;&amp; isMethod &amp;&amp; !privateFieldsAsProperties:</span>
        <span class="s1">needsClassRef = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">staticNodes.unshift(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));</span>
        <span class="s1">pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s1">isStatic &amp;&amp; isPrivate &amp;&amp; isMethod &amp;&amp; privateFieldsAsProperties:</span>
        <span class="s1">needsClassRef = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">staticNodes.unshift(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, state, privateNamesMap));</span>
        <span class="s1">pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s1">isInstance &amp;&amp; isPublic &amp;&amp; isField &amp;&amp; setPublicClassFields:</span>
        <span class="s1">instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s1">isInstance &amp;&amp; isPublic &amp;&amp; isField &amp;&amp; !setPublicClassFields:</span>
        <span class="s1">instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, state));</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;Unreachable.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">staticNodes: staticNodes.filter(Boolean),</span>
    <span class="s1">instanceNodes: instanceNodes.filter(Boolean),</span>
    <span class="s1">pureStaticNodes: pureStaticNodes.filter(Boolean),</span>
    <span class="s1">wrapClass(path) {</span>
      <span class="s2">for </span><span class="s1">(const prop of props) {</span>
        <span class="s1">prop.node.leadingComments = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">prop.remove();</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(injectSuperRef) {</span>
        <span class="s1">path.scope.push({</span>
          <span class="s1">id: _core.types.cloneNode(injectSuperRef)</span>
        <span class="s1">});</span>
        <span class="s1">path.set(</span><span class="s0">&quot;superClass&quot;</span><span class="s1">, _core.types.assignmentExpression(</span><span class="s0">&quot;=&quot;</span><span class="s1">, injectSuperRef, path.node.superClass));</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!needsClassRef) </span><span class="s2">return </span><span class="s1">path;</span>
      <span class="s2">if </span><span class="s1">(path.isClassExpression()) {</span>
        <span class="s1">path.scope.push({</span>
          <span class="s1">id: ref</span>
        <span class="s1">});</span>
        <span class="s1">path.replaceWith(_core.types.assignmentExpression(</span><span class="s0">&quot;=&quot;</span><span class="s1">, _core.types.cloneNode(ref), path.node));</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!path.node.id) {</span>
        <span class="s1">path.node.id = ref;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">path;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s5">//# sourceMappingURL=fields.js.map</span>
</pre>
</body>
</html>
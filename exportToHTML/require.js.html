<html>
<head>
<title>require.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
require.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 * 
 * @format 
 * @oncall react_native 
 * @polyfill 
 */</span>

<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s0">/* eslint-disable no-bitwise */</span>
<span class="s0">// A simpler $ArrayLike&lt;T&gt;. Not iterable and doesn't have a `length`.</span>
<span class="s0">// This is compatible with actual arrays as well as with objects that look like</span>
<span class="s0">// {0: 'value', 1: '...'}</span>
<span class="s1">global.__r = metroRequire;</span>
<span class="s1">global[`${__METRO_GLOBAL_PREFIX__}__d`] = define;</span>
<span class="s1">global.__c = clear;</span>
<span class="s1">global.__registerSegment = registerSegment;</span>
<span class="s3">var </span><span class="s1">modules = clear();</span>

<span class="s0">// Don't use a Symbol here, it would pull in an extra polyfill with all sorts of</span>
<span class="s0">// additional stuff (e.g. Array.from).</span>
<span class="s1">const EMPTY = {};</span>
<span class="s1">const CYCLE_DETECTED = {};</span>
<span class="s1">const { hasOwnProperty } = {};</span>
<span class="s3">if </span><span class="s1">(__DEV__) {</span>
  <span class="s1">global.$RefreshReg$ = () =&gt; {};</span>
  <span class="s1">global.$RefreshSig$ = () =&gt; (type) =&gt; type;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">clear() {</span>
  <span class="s1">modules = Object.create(</span><span class="s3">null</span><span class="s1">);</span>

  <span class="s0">// We return modules here so that we can assign an initial value to modules</span>
  <span class="s0">// when defining it. Otherwise, we would have to do &quot;let modules = null&quot;,</span>
  <span class="s0">// which will force us to add &quot;nullthrows&quot; everywhere.</span>
  <span class="s3">return </span><span class="s1">modules;</span>
<span class="s1">}</span>
<span class="s3">if </span><span class="s1">(__DEV__) {</span>
  <span class="s3">var </span><span class="s1">verboseNamesToModuleIds = Object.create(</span><span class="s3">null</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">initializingModuleIds = [];</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">define(factory, moduleId, dependencyMap) {</span>
  <span class="s3">if </span><span class="s1">(modules[moduleId] != </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(__DEV__) {</span>
      <span class="s0">// (We take `inverseDependencies` from `arguments` to avoid an unused</span>
      <span class="s0">// named parameter in `define` in production.</span>
      <span class="s1">const inverseDependencies = arguments[</span><span class="s4">4</span><span class="s1">];</span>

      <span class="s0">// If the module has already been defined and the define method has been</span>
      <span class="s0">// called with inverseDependencies, we can hot reload it.</span>
      <span class="s3">if </span><span class="s1">(inverseDependencies) {</span>
        <span class="s1">global.__accept(moduleId, factory, dependencyMap, inverseDependencies);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// prevent repeated calls to `global.nativeRequire` to overwrite modules</span>
    <span class="s0">// that are already loaded</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">const mod = {</span>
    <span class="s1">dependencyMap,</span>
    <span class="s1">factory,</span>
    <span class="s1">hasError: </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">importedAll: EMPTY,</span>
    <span class="s1">importedDefault: EMPTY,</span>
    <span class="s1">isInitialized: </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">publicModule: {</span>
      <span class="s1">exports: {},</span>
    <span class="s1">},</span>
  <span class="s1">};</span>
  <span class="s1">modules[moduleId] = mod;</span>
  <span class="s3">if </span><span class="s1">(__DEV__) {</span>
    <span class="s0">// HMR</span>
    <span class="s1">mod.hot = createHotReloadingObject();</span>

    <span class="s0">// DEBUGGABLE MODULES NAMES</span>
    <span class="s0">// we take `verboseName` from `arguments` to avoid an unused named parameter</span>
    <span class="s0">// in `define` in production.</span>
    <span class="s1">const verboseName = arguments[</span><span class="s4">3</span><span class="s1">];</span>
    <span class="s3">if </span><span class="s1">(verboseName) {</span>
      <span class="s1">mod.verboseName = verboseName;</span>
      <span class="s1">verboseNamesToModuleIds[verboseName] = moduleId;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">metroRequire(moduleId) {</span>
  <span class="s3">if </span><span class="s1">(__DEV__ &amp;&amp; </span><span class="s3">typeof </span><span class="s1">moduleId === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
    <span class="s1">const verboseName = moduleId;</span>
    <span class="s1">moduleId = verboseNamesToModuleIds[verboseName];</span>
    <span class="s3">if </span><span class="s1">(moduleId == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(`Unknown named module: </span><span class="s2">&quot;${verboseName}&quot;</span><span class="s1">`);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">console.warn(</span>
        <span class="s1">`Requiring module </span><span class="s2">&quot;${verboseName}&quot; </span><span class="s1">by name is only supported </span><span class="s3">for </span><span class="s1">` +</span>
          <span class="s2">&quot;debugging purposes and will BREAK IN PRODUCTION!&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">//$FlowFixMe: at this point we know that moduleId is a number</span>
  <span class="s1">const moduleIdReallyIsNumber = moduleId;</span>
  <span class="s3">if </span><span class="s1">(__DEV__) {</span>
    <span class="s1">const initializingIndex = initializingModuleIds.indexOf(</span>
      <span class="s1">moduleIdReallyIsNumber</span>
    <span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(initializingIndex !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">const cycle = initializingModuleIds</span>
        <span class="s1">.slice(initializingIndex)</span>
        <span class="s1">.map((id) =&gt; (modules[id] ? modules[id].verboseName : </span><span class="s2">&quot;[unknown]&quot;</span><span class="s1">));</span>
      <span class="s3">if </span><span class="s1">(shouldPrintRequireCycle(cycle)) {</span>
        <span class="s1">cycle.push(cycle[</span><span class="s4">0</span><span class="s1">]); </span><span class="s0">// We want to print A -&gt; B -&gt; A:</span>
        <span class="s1">console.warn(</span>
          <span class="s1">`Require cycle: ${cycle.join(</span><span class="s2">&quot; -&gt; &quot;</span><span class="s1">)}\n\n` +</span>
            <span class="s2">&quot;Require cycles are allowed, but can result in uninitialized values. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;Consider refactoring to remove the need for a cycle.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">const module = modules[moduleIdReallyIsNumber];</span>
  <span class="s3">return </span><span class="s1">module &amp;&amp; module.isInitialized</span>
    <span class="s1">? module.publicModule.exports</span>
    <span class="s1">: guardedLoadModule(moduleIdReallyIsNumber, module);</span>
<span class="s1">}</span>

<span class="s0">// We print require cycles unless they match a pattern in the</span>
<span class="s0">// `requireCycleIgnorePatterns` configuration.</span>
<span class="s3">function </span><span class="s1">shouldPrintRequireCycle(modules) {</span>
  <span class="s1">const regExps =</span>
    <span class="s1">global[__METRO_GLOBAL_PREFIX__ + </span><span class="s2">&quot;__requireCycleIgnorePatterns&quot;</span><span class="s1">];</span>
  <span class="s3">if </span><span class="s1">(!Array.isArray(regExps)) {</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">const isIgnored = (module) =&gt;</span>
    <span class="s1">module != </span><span class="s3">null </span><span class="s1">&amp;&amp; regExps.some((regExp) =&gt; regExp.test(module));</span>

  <span class="s0">// Print the cycle unless any part of it is ignored</span>
  <span class="s3">return </span><span class="s1">modules.every((module) =&gt; !isIgnored(module));</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">metroImportDefault(moduleId) {</span>
  <span class="s3">if </span><span class="s1">(__DEV__ &amp;&amp; </span><span class="s3">typeof </span><span class="s1">moduleId === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
    <span class="s1">const verboseName = moduleId;</span>
    <span class="s1">moduleId = verboseNamesToModuleIds[verboseName];</span>
  <span class="s1">}</span>

  <span class="s0">//$FlowFixMe: at this point we know that moduleId is a number</span>
  <span class="s1">const moduleIdReallyIsNumber = moduleId;</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">modules[moduleIdReallyIsNumber] &amp;&amp;</span>
    <span class="s1">modules[moduleIdReallyIsNumber].importedDefault !== EMPTY</span>
  <span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">modules[moduleIdReallyIsNumber].importedDefault;</span>
  <span class="s1">}</span>
  <span class="s1">const exports = metroRequire(moduleIdReallyIsNumber);</span>
  <span class="s1">const importedDefault =</span>
    <span class="s1">exports &amp;&amp; exports.__esModule ? exports.</span><span class="s3">default </span><span class="s1">: exports;</span>

  <span class="s0">// $FlowFixMe The metroRequire call above will throw if modules[id] is null</span>
  <span class="s3">return </span><span class="s1">(modules[moduleIdReallyIsNumber].importedDefault = importedDefault);</span>
<span class="s1">}</span>
<span class="s1">metroRequire.importDefault = metroImportDefault;</span>
<span class="s3">function </span><span class="s1">metroImportAll(moduleId) {</span>
  <span class="s3">if </span><span class="s1">(__DEV__ &amp;&amp; </span><span class="s3">typeof </span><span class="s1">moduleId === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
    <span class="s1">const verboseName = moduleId;</span>
    <span class="s1">moduleId = verboseNamesToModuleIds[verboseName];</span>
  <span class="s1">}</span>

  <span class="s0">//$FlowFixMe: at this point we know that moduleId is a number</span>
  <span class="s1">const moduleIdReallyIsNumber = moduleId;</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">modules[moduleIdReallyIsNumber] &amp;&amp;</span>
    <span class="s1">modules[moduleIdReallyIsNumber].importedAll !== EMPTY</span>
  <span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">modules[moduleIdReallyIsNumber].importedAll;</span>
  <span class="s1">}</span>
  <span class="s1">const exports = metroRequire(moduleIdReallyIsNumber);</span>
  <span class="s1">let importedAll;</span>
  <span class="s3">if </span><span class="s1">(exports &amp;&amp; exports.__esModule) {</span>
    <span class="s1">importedAll = exports;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">importedAll = {};</span>

    <span class="s0">// Refrain from using Object.assign, it has to work in ES3 environments.</span>
    <span class="s3">if </span><span class="s1">(exports) {</span>
      <span class="s3">for </span><span class="s1">(const key </span><span class="s3">in </span><span class="s1">exports) {</span>
        <span class="s3">if </span><span class="s1">(hasOwnProperty.call(exports, key)) {</span>
          <span class="s1">importedAll[key] = exports[key];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">importedAll.</span><span class="s3">default </span><span class="s1">= exports;</span>
  <span class="s1">}</span>

  <span class="s0">// $FlowFixMe The metroRequire call above will throw if modules[id] is null</span>
  <span class="s3">return </span><span class="s1">(modules[moduleIdReallyIsNumber].importedAll = importedAll);</span>
<span class="s1">}</span>
<span class="s1">metroRequire.importAll = metroImportAll;</span>

<span class="s0">// The `require.context()` syntax is never executed in the runtime because it is converted</span>
<span class="s0">// to `require()` in `metro/src/ModuleGraph/worker/collectDependencies.js` after collecting</span>
<span class="s0">// dependencies. If the feature flag is not enabled then the conversion never takes place and this error is thrown (development only).</span>
<span class="s1">metroRequire.context = </span><span class="s3">function </span><span class="s1">fallbackRequireContext() {</span>
  <span class="s3">if </span><span class="s1">(__DEV__) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;The experimental Metro feature `require.context` is not enabled in your project.</span><span class="s5">\n</span><span class="s2">This can be enabled by setting the `transformer.unstable_allowRequireContext` property to `true` in your Metro configuration.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">throw new </span><span class="s1">Error(</span>
    <span class="s2">&quot;The experimental Metro feature `require.context` is not enabled in your project.&quot;</span>
  <span class="s1">);</span>
<span class="s1">};</span>

<span class="s0">// `require.resolveWeak()` is a compile-time primitive (see collectDependencies.js)</span>
<span class="s1">metroRequire.resolveWeak = </span><span class="s3">function </span><span class="s1">fallbackRequireResolveWeak() {</span>
  <span class="s3">if </span><span class="s1">(__DEV__) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;require.resolveWeak cannot be called dynamically. Ensure you are using the same version of `metro` and `metro-runtime`.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;require.resolveWeak cannot be called dynamically.&quot;</span><span class="s1">);</span>
<span class="s1">};</span>
<span class="s1">let inGuard = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">guardedLoadModule(moduleId, module) {</span>
  <span class="s3">if </span><span class="s1">(!inGuard &amp;&amp; global.ErrorUtils) {</span>
    <span class="s1">inGuard = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">let returnValue;</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">returnValue = loadModuleImplementation(moduleId, module);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
      <span class="s0">// TODO: (moti) T48204692 Type this use of ErrorUtils.</span>
      <span class="s1">global.ErrorUtils.reportFatalError(e);</span>
    <span class="s1">}</span>
    <span class="s1">inGuard = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">returnValue;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">return </span><span class="s1">loadModuleImplementation(moduleId, module);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">const ID_MASK_SHIFT = </span><span class="s4">16</span><span class="s1">;</span>
<span class="s1">const LOCAL_ID_MASK = ~</span><span class="s4">0 </span><span class="s1">&gt;&gt;&gt; ID_MASK_SHIFT;</span>
<span class="s3">function </span><span class="s1">unpackModuleId(moduleId) {</span>
  <span class="s1">const segmentId = moduleId &gt;&gt;&gt; ID_MASK_SHIFT;</span>
  <span class="s1">const localId = moduleId &amp; LOCAL_ID_MASK;</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">segmentId,</span>
    <span class="s1">localId,</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">metroRequire.unpackModuleId = unpackModuleId;</span>
<span class="s3">function </span><span class="s1">packModuleId(value) {</span>
  <span class="s3">return </span><span class="s1">(value.segmentId &lt;&lt; ID_MASK_SHIFT) + value.localId;</span>
<span class="s1">}</span>
<span class="s1">metroRequire.packModuleId = packModuleId;</span>
<span class="s1">const moduleDefinersBySegmentID = [];</span>
<span class="s1">const definingSegmentByModuleID = </span><span class="s3">new </span><span class="s1">Map();</span>
<span class="s3">function </span><span class="s1">registerSegment(segmentId, moduleDefiner, moduleIds) {</span>
  <span class="s1">moduleDefinersBySegmentID[segmentId] = moduleDefiner;</span>
  <span class="s3">if </span><span class="s1">(__DEV__) {</span>
    <span class="s3">if </span><span class="s1">(segmentId === </span><span class="s4">0 </span><span class="s1">&amp;&amp; moduleIds) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">&quot;registerSegment: Expected moduleIds to be null for main segment&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(segmentId !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; !moduleIds) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">&quot;registerSegment: Expected moduleIds to be passed for segment #&quot; </span><span class="s1">+</span>
          <span class="s1">segmentId</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(moduleIds) {</span>
    <span class="s1">moduleIds.forEach((moduleId) =&gt; {</span>
      <span class="s3">if </span><span class="s1">(!modules[moduleId] &amp;&amp; !definingSegmentByModuleID.has(moduleId)) {</span>
        <span class="s1">definingSegmentByModuleID.set(moduleId, segmentId);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">loadModuleImplementation(moduleId, module) {</span>
  <span class="s3">if </span><span class="s1">(!module &amp;&amp; moduleDefinersBySegmentID.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">const segmentId = definingSegmentByModuleID.get(moduleId) ?? </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">const definer = moduleDefinersBySegmentID[segmentId];</span>
    <span class="s3">if </span><span class="s1">(definer != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">definer(moduleId);</span>
      <span class="s1">module = modules[moduleId];</span>
      <span class="s1">definingSegmentByModuleID.</span><span class="s3">delete</span><span class="s1">(moduleId);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">const nativeRequire = global.nativeRequire;</span>
  <span class="s3">if </span><span class="s1">(!module &amp;&amp; nativeRequire) {</span>
    <span class="s1">const { segmentId, localId } = unpackModuleId(moduleId);</span>
    <span class="s1">nativeRequire(localId, segmentId);</span>
    <span class="s1">module = modules[moduleId];</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(!module) {</span>
    <span class="s3">throw </span><span class="s1">unknownModuleError(moduleId);</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(module.hasError) {</span>
    <span class="s3">throw </span><span class="s1">module.error;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(__DEV__) {</span>
    <span class="s3">var </span><span class="s1">Systrace = requireSystrace();</span>
    <span class="s3">var </span><span class="s1">Refresh = requireRefresh();</span>
  <span class="s1">}</span>

  <span class="s0">// We must optimistically mark module as initialized before running the</span>
  <span class="s0">// factory to keep any require cycles inside the factory from causing an</span>
  <span class="s0">// infinite require loop.</span>
  <span class="s1">module.isInitialized = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s1">const { factory, dependencyMap } = module;</span>
  <span class="s3">if </span><span class="s1">(__DEV__) {</span>
    <span class="s1">initializingModuleIds.push(moduleId);</span>
  <span class="s1">}</span>
  <span class="s3">try </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(__DEV__) {</span>
      <span class="s0">// $FlowIgnore: we know that __DEV__ is const and `Systrace` exists</span>
      <span class="s1">Systrace.beginEvent(</span><span class="s2">&quot;JS_require_&quot; </span><span class="s1">+ (module.verboseName || moduleId));</span>
    <span class="s1">}</span>
    <span class="s1">const moduleObject = module.publicModule;</span>
    <span class="s3">if </span><span class="s1">(__DEV__) {</span>
      <span class="s1">moduleObject.hot = module.hot;</span>
      <span class="s3">var </span><span class="s1">prevRefreshReg = global.$RefreshReg$;</span>
      <span class="s3">var </span><span class="s1">prevRefreshSig = global.$RefreshSig$;</span>
      <span class="s3">if </span><span class="s1">(Refresh != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">const RefreshRuntime = Refresh;</span>
        <span class="s1">global.$RefreshReg$ = (type, id) =&gt; {</span>
          <span class="s1">RefreshRuntime.register(type, moduleId + </span><span class="s2">&quot; &quot; </span><span class="s1">+ id);</span>
        <span class="s1">};</span>
        <span class="s1">global.$RefreshSig$ =</span>
          <span class="s1">RefreshRuntime.createSignatureFunctionForTransform;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">moduleObject.id = moduleId;</span>

    <span class="s0">// keep args in sync with with defineModuleCode in</span>
    <span class="s0">// metro/src/Resolver/index.js</span>
    <span class="s0">// and metro/src/ModuleGraph/worker.js</span>
    <span class="s1">factory(</span>
      <span class="s1">global,</span>
      <span class="s1">metroRequire,</span>
      <span class="s1">metroImportDefault,</span>
      <span class="s1">metroImportAll,</span>
      <span class="s1">moduleObject,</span>
      <span class="s1">moduleObject.exports,</span>
      <span class="s1">dependencyMap</span>
    <span class="s1">);</span>

    <span class="s0">// avoid removing factory in DEV mode as it breaks HMR</span>
    <span class="s3">if </span><span class="s1">(!__DEV__) {</span>
      <span class="s0">// $FlowFixMe: This is only sound because we never access `factory` again</span>
      <span class="s1">module.factory = undefined;</span>
      <span class="s1">module.dependencyMap = undefined;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(__DEV__) {</span>
      <span class="s0">// $FlowIgnore: we know that __DEV__ is const and `Systrace` exists</span>
      <span class="s1">Systrace.endEvent();</span>
      <span class="s3">if </span><span class="s1">(Refresh != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">registerExportsForReactRefresh(Refresh, moduleObject.exports, moduleId);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">moduleObject.exports;</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
    <span class="s1">module.hasError = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">module.error = e;</span>
    <span class="s1">module.isInitialized = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">module.publicModule.exports = undefined;</span>
    <span class="s3">throw </span><span class="s1">e;</span>
  <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(__DEV__) {</span>
      <span class="s3">if </span><span class="s1">(initializingModuleIds.pop() !== moduleId) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span>
          <span class="s2">&quot;initializingModuleIds is corrupt; something is terribly wrong&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s1">global.$RefreshReg$ = prevRefreshReg;</span>
      <span class="s1">global.$RefreshSig$ = prevRefreshSig;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">unknownModuleError(id) {</span>
  <span class="s1">let message = </span><span class="s2">'Requiring unknown module &quot;' </span><span class="s1">+ id + </span><span class="s2">'&quot;.'</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(__DEV__) {</span>
    <span class="s1">message +=</span>
      <span class="s2">&quot; If you are sure the module exists, try restarting Metro. &quot; </span><span class="s1">+</span>
      <span class="s2">&quot;You may also want to run `yarn` or `npm install`.&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">Error(message);</span>
<span class="s1">}</span>
<span class="s3">if </span><span class="s1">(__DEV__) {</span>
  <span class="s0">// $FlowFixMe[prop-missing]</span>
  <span class="s1">metroRequire.Systrace = {</span>
    <span class="s1">beginEvent: () =&gt; {},</span>
    <span class="s1">endEvent: () =&gt; {},</span>
  <span class="s1">};</span>
  <span class="s0">// $FlowFixMe[prop-missing]</span>
  <span class="s1">metroRequire.getModules = () =&gt; {</span>
    <span class="s3">return </span><span class="s1">modules;</span>
  <span class="s1">};</span>

  <span class="s0">// HOT MODULE RELOADING</span>
  <span class="s3">var </span><span class="s1">createHotReloadingObject = </span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s1">const hot = {</span>
      <span class="s1">_acceptCallback: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">_disposeCallback: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">_didAccept: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">accept: (callback) =&gt; {</span>
        <span class="s1">hot._didAccept = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">hot._acceptCallback = callback;</span>
      <span class="s1">},</span>
      <span class="s1">dispose: (callback) =&gt; {</span>
        <span class="s1">hot._disposeCallback = callback;</span>
      <span class="s1">},</span>
    <span class="s1">};</span>
    <span class="s3">return </span><span class="s1">hot;</span>
  <span class="s1">};</span>
  <span class="s1">let reactRefreshTimeout = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">const metroHotUpdateModule = </span><span class="s3">function </span><span class="s1">(</span>
    <span class="s1">id,</span>
    <span class="s1">factory,</span>
    <span class="s1">dependencyMap,</span>
    <span class="s1">inverseDependencies</span>
  <span class="s1">) {</span>
    <span class="s1">const mod = modules[id];</span>
    <span class="s3">if </span><span class="s1">(!mod) {</span>
      <span class="s3">if </span><span class="s1">(factory) {</span>
        <span class="s0">// New modules are going to be handled by the define() method.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">throw </span><span class="s1">unknownModuleError(id);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(!mod.hasError &amp;&amp; !mod.isInitialized) {</span>
      <span class="s0">// The module hasn't actually been executed yet,</span>
      <span class="s0">// so we can always safely replace it.</span>
      <span class="s1">mod.factory = factory;</span>
      <span class="s1">mod.dependencyMap = dependencyMap;</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const Refresh = requireRefresh();</span>
    <span class="s1">const refreshBoundaryIDs = </span><span class="s3">new </span><span class="s1">Set();</span>

    <span class="s0">// In this loop, we will traverse the dependency tree upwards from the</span>
    <span class="s0">// changed module. Updates &quot;bubble&quot; up to the closest accepted parent.</span>
    <span class="s0">//</span>
    <span class="s0">// If we reach the module root and nothing along the way accepted the update,</span>
    <span class="s0">// we know hot reload is going to fail. In that case we return false.</span>
    <span class="s0">//</span>
    <span class="s0">// The main purpose of this loop is to figure out whether it's safe to apply</span>
    <span class="s0">// a hot update. It is only safe when the update was accepted somewhere</span>
    <span class="s0">// along the way upwards for each of its parent dependency module chains.</span>
    <span class="s0">//</span>
    <span class="s0">// We perform a topological sort because we may discover the same</span>
    <span class="s0">// module more than once in the list of things to re-execute, and</span>
    <span class="s0">// we want to execute modules before modules that depend on them.</span>
    <span class="s0">//</span>
    <span class="s0">// If we didn't have this check, we'd risk re-evaluating modules that</span>
    <span class="s0">// have side effects and lead to confusing and meaningless crashes.</span>

    <span class="s1">let didBailOut = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">let updatedModuleIDs;</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">updatedModuleIDs = topologicalSort(</span>
        <span class="s1">[id],</span>
        <span class="s0">// Start with the changed module and go upwards</span>
        <span class="s1">(pendingID) =&gt; {</span>
          <span class="s1">const pendingModule = modules[pendingID];</span>
          <span class="s3">if </span><span class="s1">(pendingModule == </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// Nothing to do.</span>
            <span class="s3">return </span><span class="s1">[];</span>
          <span class="s1">}</span>
          <span class="s1">const pendingHot = pendingModule.hot;</span>
          <span class="s3">if </span><span class="s1">(pendingHot == </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">throw new </span><span class="s1">Error(</span>
              <span class="s2">&quot;[Refresh] Expected module.hot to always exist in DEV.&quot;</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s0">// A module can be accepted manually from within itself.</span>
          <span class="s1">let canAccept = pendingHot._didAccept;</span>
          <span class="s3">if </span><span class="s1">(!canAccept &amp;&amp; Refresh != </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// Or React Refresh may mark it accepted based on exports.</span>
            <span class="s1">const isBoundary = isReactRefreshBoundary(</span>
              <span class="s1">Refresh,</span>
              <span class="s1">pendingModule.publicModule.exports</span>
            <span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(isBoundary) {</span>
              <span class="s1">canAccept = </span><span class="s3">true</span><span class="s1">;</span>
              <span class="s1">refreshBoundaryIDs.add(pendingID);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s3">if </span><span class="s1">(canAccept) {</span>
            <span class="s0">// Don't look at parents.</span>
            <span class="s3">return </span><span class="s1">[];</span>
          <span class="s1">}</span>
          <span class="s0">// If we bubble through the roof, there is no way to do a hot update.</span>
          <span class="s0">// Bail out altogether. This is the failure case.</span>
          <span class="s1">const parentIDs = inverseDependencies[pendingID];</span>
          <span class="s3">if </span><span class="s1">(parentIDs.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s0">// Reload the app because the hot reload can't succeed.</span>
            <span class="s0">// This should work both on web and React Native.</span>
            <span class="s1">performFullRefresh(</span><span class="s2">&quot;No root boundary&quot;</span><span class="s1">, {</span>
              <span class="s1">source: mod,</span>
              <span class="s1">failed: pendingModule,</span>
            <span class="s1">});</span>
            <span class="s1">didBailOut = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s3">return </span><span class="s1">[];</span>
          <span class="s1">}</span>
          <span class="s0">// This module can't handle the update but maybe all its parents can?</span>
          <span class="s0">// Put them all in the queue to run the same set of checks.</span>
          <span class="s3">return </span><span class="s1">parentIDs;</span>
        <span class="s1">},</span>
        <span class="s1">() =&gt; didBailOut </span><span class="s0">// Should we stop?</span>
      <span class="s1">).reverse();</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
      <span class="s3">if </span><span class="s1">(e === CYCLE_DETECTED) {</span>
        <span class="s1">performFullRefresh(</span><span class="s2">&quot;Dependency cycle&quot;</span><span class="s1">, {</span>
          <span class="s1">source: mod,</span>
        <span class="s1">});</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">throw </span><span class="s1">e;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(didBailOut) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// If we reached here, it is likely that hot reload will be successful.</span>
    <span class="s0">// Run the actual factories.</span>
    <span class="s1">const seenModuleIDs = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; updatedModuleIDs.length; i++) {</span>
      <span class="s1">const updatedID = updatedModuleIDs[i];</span>
      <span class="s3">if </span><span class="s1">(seenModuleIDs.has(updatedID)) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">seenModuleIDs.add(updatedID);</span>
      <span class="s1">const updatedMod = modules[updatedID];</span>
      <span class="s3">if </span><span class="s1">(updatedMod == </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;[Refresh] Expected to find the updated module.&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s1">const prevExports = updatedMod.publicModule.exports;</span>
      <span class="s1">const didError = runUpdatedModule(</span>
        <span class="s1">updatedID,</span>
        <span class="s1">updatedID === id ? factory : undefined,</span>
        <span class="s1">updatedID === id ? dependencyMap : undefined</span>
      <span class="s1">);</span>
      <span class="s1">const nextExports = updatedMod.publicModule.exports;</span>
      <span class="s3">if </span><span class="s1">(didError) {</span>
        <span class="s0">// The user was shown a redbox about module initialization.</span>
        <span class="s0">// There's nothing for us to do here until it's fixed.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(refreshBoundaryIDs.has(updatedID)) {</span>
        <span class="s0">// Since we just executed the code for it, it's possible</span>
        <span class="s0">// that the new exports make it ineligible for being a boundary.</span>
        <span class="s1">const isNoLongerABoundary = !isReactRefreshBoundary(</span>
          <span class="s1">Refresh,</span>
          <span class="s1">nextExports</span>
        <span class="s1">);</span>
        <span class="s0">// It can also become ineligible if its exports are incompatible</span>
        <span class="s0">// with the previous exports.</span>
        <span class="s0">// For example, if you add/remove/change exports, we'll want</span>
        <span class="s0">// to re-execute the importing modules, and force those components</span>
        <span class="s0">// to re-render. Similarly, if you convert a class component</span>
        <span class="s0">// to a function, we want to invalidate the boundary.</span>
        <span class="s1">const didInvalidate = shouldInvalidateReactRefreshBoundary(</span>
          <span class="s1">Refresh,</span>
          <span class="s1">prevExports,</span>
          <span class="s1">nextExports</span>
        <span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(isNoLongerABoundary || didInvalidate) {</span>
          <span class="s0">// We'll be conservative. The only case in which we won't do a full</span>
          <span class="s0">// reload is if all parent modules are also refresh boundaries.</span>
          <span class="s0">// In that case we'll add them to the current queue.</span>
          <span class="s1">const parentIDs = inverseDependencies[updatedID];</span>
          <span class="s3">if </span><span class="s1">(parentIDs.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s0">// Looks like we bubbled to the root. Can't recover from that.</span>
            <span class="s1">performFullRefresh(</span>
              <span class="s1">isNoLongerABoundary</span>
                <span class="s1">? </span><span class="s2">&quot;No longer a boundary&quot;</span>
                <span class="s1">: </span><span class="s2">&quot;Invalidated boundary&quot;</span><span class="s1">,</span>
              <span class="s1">{</span>
                <span class="s1">source: mod,</span>
                <span class="s1">failed: updatedMod,</span>
              <span class="s1">}</span>
            <span class="s1">);</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s0">// Schedule all parent refresh boundaries to re-run in this loop.</span>
          <span class="s3">for </span><span class="s1">(let j = </span><span class="s4">0</span><span class="s1">; j &lt; parentIDs.length; j++) {</span>
            <span class="s1">const parentID = parentIDs[j];</span>
            <span class="s1">const parentMod = modules[parentID];</span>
            <span class="s3">if </span><span class="s1">(parentMod == </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;[Refresh] Expected to find parent module.&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">const canAcceptParent = isReactRefreshBoundary(</span>
              <span class="s1">Refresh,</span>
              <span class="s1">parentMod.publicModule.exports</span>
            <span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(canAcceptParent) {</span>
              <span class="s0">// All parents will have to re-run too.</span>
              <span class="s1">refreshBoundaryIDs.add(parentID);</span>
              <span class="s1">updatedModuleIDs.push(parentID);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s1">performFullRefresh(</span><span class="s2">&quot;Invalidated boundary&quot;</span><span class="s1">, {</span>
                <span class="s1">source: mod,</span>
                <span class="s1">failed: parentMod,</span>
              <span class="s1">});</span>
              <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(Refresh != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Debounce a little in case there are multiple updates queued up.</span>
      <span class="s0">// This is also useful because __accept may be called multiple times.</span>
      <span class="s3">if </span><span class="s1">(reactRefreshTimeout == </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">reactRefreshTimeout = setTimeout(() =&gt; {</span>
          <span class="s1">reactRefreshTimeout = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s0">// Update React components.</span>
          <span class="s1">Refresh.performReactRefresh();</span>
        <span class="s1">}, </span><span class="s4">30</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s1">const topologicalSort = </span><span class="s3">function </span><span class="s1">(roots, getEdges, earlyStop) {</span>
    <span class="s1">const result = [];</span>
    <span class="s1">const visited = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">const stack = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s3">function </span><span class="s1">traverseDependentNodes(node) {</span>
      <span class="s3">if </span><span class="s1">(stack.has(node)) {</span>
        <span class="s3">throw </span><span class="s1">CYCLE_DETECTED;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(visited.has(node)) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">visited.add(node);</span>
      <span class="s1">stack.add(node);</span>
      <span class="s1">const dependentNodes = getEdges(node);</span>
      <span class="s3">if </span><span class="s1">(earlyStop(node)) {</span>
        <span class="s1">stack.</span><span class="s3">delete</span><span class="s1">(node);</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">dependentNodes.forEach((dependent) =&gt; {</span>
        <span class="s1">traverseDependentNodes(dependent);</span>
      <span class="s1">});</span>
      <span class="s1">stack.</span><span class="s3">delete</span><span class="s1">(node);</span>
      <span class="s1">result.push(node);</span>
    <span class="s1">}</span>
    <span class="s1">roots.forEach((root) =&gt; {</span>
      <span class="s1">traverseDependentNodes(root);</span>
    <span class="s1">});</span>
    <span class="s3">return </span><span class="s1">result;</span>
  <span class="s1">};</span>
  <span class="s1">const runUpdatedModule = </span><span class="s3">function </span><span class="s1">(id, factory, dependencyMap) {</span>
    <span class="s1">const mod = modules[id];</span>
    <span class="s3">if </span><span class="s1">(mod == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;[Refresh] Expected to find the module.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">const { hot } = mod;</span>
    <span class="s3">if </span><span class="s1">(!hot) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;[Refresh] Expected module.hot to always exist in DEV.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(hot._disposeCallback) {</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">hot._disposeCallback();</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s1">console.error(</span>
          <span class="s1">`Error </span><span class="s3">while </span><span class="s1">calling dispose handler </span><span class="s3">for </span><span class="s1">module ${id}: `,</span>
          <span class="s1">error</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(factory) {</span>
      <span class="s1">mod.factory = factory;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(dependencyMap) {</span>
      <span class="s1">mod.dependencyMap = dependencyMap;</span>
    <span class="s1">}</span>
    <span class="s1">mod.hasError = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">mod.error = undefined;</span>
    <span class="s1">mod.importedAll = EMPTY;</span>
    <span class="s1">mod.importedDefault = EMPTY;</span>
    <span class="s1">mod.isInitialized = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">const prevExports = mod.publicModule.exports;</span>
    <span class="s1">mod.publicModule.exports = {};</span>
    <span class="s1">hot._didAccept = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">hot._acceptCallback = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">hot._disposeCallback = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">metroRequire(id);</span>
    <span class="s3">if </span><span class="s1">(mod.hasError) {</span>
      <span class="s0">// This error has already been reported via a redbox.</span>
      <span class="s0">// We know it's likely a typo or some mistake that was just introduced.</span>
      <span class="s0">// Our goal now is to keep the rest of the application working so that by</span>
      <span class="s0">// the time user fixes the error, the app isn't completely destroyed</span>
      <span class="s0">// underneath the redbox. So we'll revert the module object to the last</span>
      <span class="s0">// successful export and stop propagating this update.</span>
      <span class="s1">mod.hasError = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">mod.isInitialized = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">mod.error = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">mod.publicModule.exports = prevExports;</span>
      <span class="s0">// We errored. Stop the update.</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(hot._acceptCallback) {</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">hot._acceptCallback();</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s1">console.error(</span>
          <span class="s1">`Error </span><span class="s3">while </span><span class="s1">calling accept handler </span><span class="s3">for </span><span class="s1">module ${id}: `,</span>
          <span class="s1">error</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">// No error.</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">};</span>
  <span class="s1">const performFullRefresh = (reason, modules) =&gt; {</span>
    <span class="s0">/* global window */</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">typeof </span><span class="s1">window !== </span><span class="s2">&quot;undefined&quot; </span><span class="s1">&amp;&amp;</span>
      <span class="s1">window.location != </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
      <span class="s3">typeof </span><span class="s1">window.location.reload === </span><span class="s2">&quot;function&quot;</span>
    <span class="s1">) {</span>
      <span class="s1">window.location.reload();</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">const Refresh = requireRefresh();</span>
      <span class="s3">if </span><span class="s1">(Refresh != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">const sourceName = modules.source?.verboseName ?? </span><span class="s2">&quot;unknown&quot;</span><span class="s1">;</span>
        <span class="s1">const failedName = modules.failed?.verboseName ?? </span><span class="s2">&quot;unknown&quot;</span><span class="s1">;</span>
        <span class="s1">Refresh.performFullRefresh(</span>
          <span class="s1">`Fast Refresh - ${reason} &lt;${sourceName}&gt; &lt;${failedName}&gt;`</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">console.warn(</span><span class="s2">&quot;Could not reload the application after an edit.&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s0">// Modules that only export components become React Refresh boundaries.</span>
  <span class="s3">var </span><span class="s1">isReactRefreshBoundary = </span><span class="s3">function </span><span class="s1">(Refresh, moduleExports) {</span>
    <span class="s3">if </span><span class="s1">(Refresh.isLikelyComponentType(moduleExports)) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(moduleExports == </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">moduleExports !== </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
      <span class="s0">// Exit if we can't iterate over exports.</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">let hasExports = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">let areAllExportsComponents = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">for </span><span class="s1">(const key </span><span class="s3">in </span><span class="s1">moduleExports) {</span>
      <span class="s1">hasExports = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s1">(key === </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const desc = Object.getOwnPropertyDescriptor(moduleExports, key);</span>
      <span class="s3">if </span><span class="s1">(desc &amp;&amp; desc.get) {</span>
        <span class="s0">// Don't invoke getters as they may have side effects.</span>
        <span class="s3">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const exportValue = moduleExports[key];</span>
      <span class="s3">if </span><span class="s1">(!Refresh.isLikelyComponentType(exportValue)) {</span>
        <span class="s1">areAllExportsComponents = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">hasExports &amp;&amp; areAllExportsComponents;</span>
  <span class="s1">};</span>
  <span class="s3">var </span><span class="s1">shouldInvalidateReactRefreshBoundary = (</span>
    <span class="s1">Refresh,</span>
    <span class="s1">prevExports,</span>
    <span class="s1">nextExports</span>
  <span class="s1">) =&gt; {</span>
    <span class="s1">const prevSignature = getRefreshBoundarySignature(Refresh, prevExports);</span>
    <span class="s1">const nextSignature = getRefreshBoundarySignature(Refresh, nextExports);</span>
    <span class="s3">if </span><span class="s1">(prevSignature.length !== nextSignature.length) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; nextSignature.length; i++) {</span>
      <span class="s3">if </span><span class="s1">(prevSignature[i] !== nextSignature[i]) {</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">};</span>

  <span class="s0">// When this signature changes, it's unsafe to stop at this refresh boundary.</span>
  <span class="s3">var </span><span class="s1">getRefreshBoundarySignature = (Refresh, moduleExports) =&gt; {</span>
    <span class="s1">const signature = [];</span>
    <span class="s1">signature.push(Refresh.getFamilyByType(moduleExports));</span>
    <span class="s3">if </span><span class="s1">(moduleExports == </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">moduleExports !== </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
      <span class="s0">// Exit if we can't iterate over exports.</span>
      <span class="s0">// (This is important for legacy environments.)</span>
      <span class="s3">return </span><span class="s1">signature;</span>
    <span class="s1">}</span>
    <span class="s3">for </span><span class="s1">(const key </span><span class="s3">in </span><span class="s1">moduleExports) {</span>
      <span class="s3">if </span><span class="s1">(key === </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const desc = Object.getOwnPropertyDescriptor(moduleExports, key);</span>
      <span class="s3">if </span><span class="s1">(desc &amp;&amp; desc.get) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const exportValue = moduleExports[key];</span>
      <span class="s1">signature.push(key);</span>
      <span class="s1">signature.push(Refresh.getFamilyByType(exportValue));</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">signature;</span>
  <span class="s1">};</span>
  <span class="s3">var </span><span class="s1">registerExportsForReactRefresh = (Refresh, moduleExports, moduleID) =&gt; {</span>
    <span class="s1">Refresh.register(moduleExports, moduleID + </span><span class="s2">&quot; %exports%&quot;</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(moduleExports == </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">moduleExports !== </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
      <span class="s0">// Exit if we can't iterate over exports.</span>
      <span class="s0">// (This is important for legacy environments.)</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">for </span><span class="s1">(const key </span><span class="s3">in </span><span class="s1">moduleExports) {</span>
      <span class="s1">const desc = Object.getOwnPropertyDescriptor(moduleExports, key);</span>
      <span class="s3">if </span><span class="s1">(desc &amp;&amp; desc.get) {</span>
        <span class="s0">// Don't invoke getters as they may have side effects.</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const exportValue = moduleExports[key];</span>
      <span class="s1">const typeID = moduleID + </span><span class="s2">&quot; %exports% &quot; </span><span class="s1">+ key;</span>
      <span class="s1">Refresh.register(exportValue, typeID);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s1">global.__accept = metroHotUpdateModule;</span>
<span class="s1">}</span>
<span class="s3">if </span><span class="s1">(__DEV__) {</span>
  <span class="s0">// The metro require polyfill can not have module dependencies.</span>
  <span class="s0">// The Systrace and ReactRefresh dependencies are, therefore, made publicly</span>
  <span class="s0">// available. Ideally, the dependency would be inversed in a way that</span>
  <span class="s0">// Systrace / ReactRefresh could integrate into Metro rather than</span>
  <span class="s0">// having to make them publicly available.</span>

  <span class="s3">var </span><span class="s1">requireSystrace = </span><span class="s3">function </span><span class="s1">requireSystrace() {</span>
    <span class="s3">return </span><span class="s1">(</span>
      <span class="s0">// $FlowFixMe[prop-missing]</span>
      <span class="s1">global[__METRO_GLOBAL_PREFIX__ + </span><span class="s2">&quot;__SYSTRACE&quot;</span><span class="s1">] || metroRequire.Systrace</span>
    <span class="s1">);</span>
  <span class="s1">};</span>
  <span class="s3">var </span><span class="s1">requireRefresh = </span><span class="s3">function </span><span class="s1">requireRefresh() {</span>
    <span class="s3">return </span><span class="s1">(</span>
      <span class="s0">// $FlowFixMe[prop-missing]</span>
      <span class="s1">global[__METRO_GLOBAL_PREFIX__ + </span><span class="s2">&quot;__ReactRefresh&quot;</span><span class="s1">] || metroRequire.Refresh</span>
    <span class="s1">);</span>
  <span class="s1">};</span>
<span class="s1">}</span>
</pre>
</body>
</html>
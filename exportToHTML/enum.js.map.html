<html>
<head>
<title>enum.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
enum.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_assert&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperAnnotateAsPure&quot;</span><span class="s0">,</span><span class="s1">&quot;ENUMS&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;buildEnumWrapper&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;transpileEnum&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;declare&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;fill&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;isPure&quot;</span><span class="s0">,</span><span class="s1">&quot;enumFill&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;isGlobal&quot;</span><span class="s0">,</span><span class="s1">&quot;isProgram&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;isSeen&quot;</span><span class="s0">,</span><span class="s1">&quot;seen&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;objectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;logicalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;ID&quot;</span><span class="s0">,</span><span class="s1">&quot;enumIIFE&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;INIT&quot;</span><span class="s0">,</span><span class="s1">&quot;annotateAsPure&quot;</span><span class="s0">,</span><span class="s1">&quot;toReplace&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;registerDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;getBindingIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;getData&quot;</span><span class="s0">,</span><span class="s1">&quot;setData&quot;</span><span class="s0">,</span><span class="s1">&quot;buildStringAssignment&quot;</span><span class="s0">,</span><span class="s1">&quot;buildNumericAssignment&quot;</span><span class="s0">,</span><span class="s1">&quot;buildEnumMember&quot;</span><span class="s0">,</span><span class="s1">&quot;isString&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;enumValues&quot;</span><span class="s0">,</span><span class="s1">&quot;x&quot;</span><span class="s0">,</span><span class="s1">&quot;translateEnumValues&quot;</span><span class="s0">,</span><span class="s1">&quot;assignments&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;memberName&quot;</span><span class="s0">,</span><span class="s1">&quot;memberValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isStringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;ENUM&quot;</span><span class="s0">,</span><span class="s1">&quot;NAME&quot;</span><span class="s0">,</span><span class="s1">&quot;VALUE&quot;</span><span class="s0">,</span><span class="s1">&quot;ASSIGNMENTS&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;expr&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;skip&quot;</span><span class="s0">,</span><span class="s1">&quot;enumSelfReferenceVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;constValue&quot;</span><span class="s0">,</span><span class="s1">&quot;lastName&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;memberPath&quot;</span><span class="s0">,</span><span class="s1">&quot;member&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;initializerPath&quot;</span><span class="s0">,</span><span class="s1">&quot;initializer&quot;</span><span class="s0">,</span><span class="s1">&quot;computeConstantValue&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;numericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;assert&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;lastRef&quot;</span><span class="s0">,</span><span class="s1">&quot;binaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;prevMembers&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;evaluate&quot;</span><span class="s0">,</span><span class="s1">&quot;evaluateRef&quot;</span><span class="s0">,</span><span class="s1">&quot;evalUnaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;evalBinaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;quasis&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;cooked&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingInitPath&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;pow&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/enum.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { template, types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import assert from </span><span class="s3">\&quot;</span><span class="s1">assert</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import annotateAsPure from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-annotate-as-pure</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">type t = typeof t;</span><span class="s3">\n\n</span><span class="s1">const ENUMS = new WeakMap&lt;t.Identifier, PreviousEnumMembers&gt;();</span><span class="s3">\n\n</span><span class="s1">const buildEnumWrapper = template.expression(</span><span class="s3">\n  </span><span class="s1">`</span><span class="s3">\n    </span><span class="s1">(function (ID) {</span><span class="s3">\n      </span><span class="s1">ASSIGNMENTS;</span><span class="s3">\n      </span><span class="s1">return ID;</span><span class="s3">\n    </span><span class="s1">})(INIT)</span><span class="s3">\n  </span><span class="s1">`,</span><span class="s3">\n</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">export default function transpileEnum(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.TSEnumDeclaration&gt;,</span><span class="s3">\n  </span><span class="s1">t: t,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { node, parentPath } = path;</span><span class="s3">\n\n  </span><span class="s1">if (node.declare) {</span><span class="s3">\n    </span><span class="s1">path.remove();</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const name = node.id.name;</span><span class="s3">\n  </span><span class="s1">const { fill, data, isPure } = enumFill(path, t, node.id);</span><span class="s3">\n\n  </span><span class="s1">switch (parentPath.type) {</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">BlockStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Program</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n      </span><span class="s1">// todo: Consider exclude program with import/export</span><span class="s3">\n      </span><span class="s1">// &amp;&amp; !path.parent.body.some(n =&gt; t.isImportDeclaration(n) || t.isExportDeclaration(n));</span><span class="s3">\n      </span><span class="s1">const isGlobal = t.isProgram(path.parent);</span><span class="s3">\n      </span><span class="s1">const isSeen = seen(parentPath);</span><span class="s3">\n\n      </span><span class="s1">let init: t.Expression = t.objectExpression([]);</span><span class="s3">\n      </span><span class="s1">if (isSeen || isGlobal) {</span><span class="s3">\n        </span><span class="s1">init = t.logicalExpression(</span><span class="s3">\&quot;</span><span class="s1">||</span><span class="s3">\&quot;</span><span class="s1">, t.cloneNode(fill.ID), init);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const enumIIFE = buildEnumWrapper({ ...fill, INIT: init });</span><span class="s3">\n      </span><span class="s1">if (isPure) annotateAsPure(enumIIFE);</span><span class="s3">\n\n      </span><span class="s1">if (isSeen) {</span><span class="s3">\n        </span><span class="s1">const toReplace = parentPath.isExportDeclaration() ? parentPath : path;</span><span class="s3">\n        </span><span class="s1">toReplace.replaceWith(</span><span class="s3">\n          </span><span class="s1">t.expressionStatement(</span><span class="s3">\n            </span><span class="s1">t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, t.cloneNode(node.id), enumIIFE),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">path.scope.registerDeclaration(</span><span class="s3">\n          </span><span class="s1">path.replaceWith(</span><span class="s3">\n            </span><span class="s1">t.variableDeclaration(isGlobal ? </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n              </span><span class="s1">t.variableDeclarator(node.id, enumIIFE),</span><span class="s3">\n            </span><span class="s1">]),</span><span class="s3">\n          </span><span class="s1">)[0],</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">ENUMS.set(path.scope.getBindingIdentifier(name), data);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">throw new Error(`Unexpected enum parent '${path.parent.type}`);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function seen(parentPath: NodePath&lt;t.Node&gt;): boolean {</span><span class="s3">\n    </span><span class="s1">if (parentPath.isExportDeclaration()) {</span><span class="s3">\n      </span><span class="s1">return seen(parentPath.parentPath);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (parentPath.getData(name)) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">parentPath.setData(name, true);</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const buildStringAssignment = template(`</span><span class="s3">\n  </span><span class="s1">ENUM[</span><span class="s3">\&quot;</span><span class="s1">NAME</span><span class="s3">\&quot;</span><span class="s1">] = VALUE;</span><span class="s3">\n</span><span class="s1">`);</span><span class="s3">\n\n</span><span class="s1">const buildNumericAssignment = template(`</span><span class="s3">\n  </span><span class="s1">ENUM[ENUM[</span><span class="s3">\&quot;</span><span class="s1">NAME</span><span class="s3">\&quot;</span><span class="s1">] = VALUE] = </span><span class="s3">\&quot;</span><span class="s1">NAME</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">`);</span><span class="s3">\n\n</span><span class="s1">const buildEnumMember = (isString: boolean, options: Record&lt;string, unknown&gt;) =&gt;</span><span class="s3">\n  </span><span class="s1">(isString ? buildStringAssignment : buildNumericAssignment)(options);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generates the statement that fills in the variable declared by the enum.</span><span class="s3">\n </span><span class="s1">* `(function (E) { ... assignments ... })(E || (E = {}));`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function enumFill(path: NodePath&lt;t.TSEnumDeclaration&gt;, t: t, id: t.Identifier) {</span><span class="s3">\n  </span><span class="s1">const { enumValues: x, data, isPure } = translateEnumValues(path, t);</span><span class="s3">\n  </span><span class="s1">const assignments = x.map(([memberName, memberValue]) =&gt;</span><span class="s3">\n    </span><span class="s1">buildEnumMember(t.isStringLiteral(memberValue), {</span><span class="s3">\n      </span><span class="s1">ENUM: t.cloneNode(id),</span><span class="s3">\n      </span><span class="s1">NAME: memberName,</span><span class="s3">\n      </span><span class="s1">VALUE: memberValue,</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">fill: {</span><span class="s3">\n      </span><span class="s1">ID: t.cloneNode(id),</span><span class="s3">\n      </span><span class="s1">ASSIGNMENTS: assignments,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">data,</span><span class="s3">\n    </span><span class="s1">isPure,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Maps the name of an enum member to its value.</span><span class="s3">\n </span><span class="s1">* We keep track of the previous enum members so you can write code like:</span><span class="s3">\n </span><span class="s1">*   enum E {</span><span class="s3">\n </span><span class="s1">*     X = 1 &lt;&lt; 0,</span><span class="s3">\n </span><span class="s1">*     Y = 1 &lt;&lt; 1,</span><span class="s3">\n </span><span class="s1">*     Z = X | Y,</span><span class="s3">\n </span><span class="s1">*   }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">type PreviousEnumMembers = Map&lt;string, number | string&gt;;</span><span class="s3">\n\n</span><span class="s1">type EnumSelfReferenceVisitorState = {</span><span class="s3">\n  </span><span class="s1">seen: PreviousEnumMembers;</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.TSEnumDeclaration&gt;;</span><span class="s3">\n  </span><span class="s1">t: t;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function ReferencedIdentifier(</span><span class="s3">\n  </span><span class="s1">expr: NodePath&lt;t.Identifier&gt;,</span><span class="s3">\n  </span><span class="s1">state: EnumSelfReferenceVisitorState,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { seen, path, t } = state;</span><span class="s3">\n  </span><span class="s1">const name = expr.node.name;</span><span class="s3">\n  </span><span class="s1">if (seen.has(name) &amp;&amp; !expr.scope.hasOwnBinding(name)) {</span><span class="s3">\n    </span><span class="s1">expr.replaceWith(</span><span class="s3">\n      </span><span class="s1">t.memberExpression(t.cloneNode(path.node.id), t.cloneNode(expr.node)),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">expr.skip();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const enumSelfReferenceVisitor = {</span><span class="s3">\n  </span><span class="s1">ReferencedIdentifier,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function translateEnumValues(path: NodePath&lt;t.TSEnumDeclaration&gt;, t: t) {</span><span class="s3">\n  </span><span class="s1">const seen: PreviousEnumMembers = new Map();</span><span class="s3">\n  </span><span class="s1">// Start at -1 so the first enum member is its increment, 0.</span><span class="s3">\n  </span><span class="s1">let constValue: number | string | undefined = -1;</span><span class="s3">\n  </span><span class="s1">let lastName: string;</span><span class="s3">\n  </span><span class="s1">let isPure = true;</span><span class="s3">\n\n  </span><span class="s1">const enumValues: Array&lt;[name: string, value: t.Expression]&gt; = path</span><span class="s3">\n    </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">members</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">.map(memberPath =&gt; {</span><span class="s3">\n      </span><span class="s1">const member = memberPath.node;</span><span class="s3">\n      </span><span class="s1">const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;</span><span class="s3">\n      </span><span class="s1">const initializerPath = memberPath.get(</span><span class="s3">\&quot;</span><span class="s1">initializer</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const initializer = member.initializer;</span><span class="s3">\n      </span><span class="s1">let value: t.Expression;</span><span class="s3">\n      </span><span class="s1">if (initializer) {</span><span class="s3">\n        </span><span class="s1">constValue = computeConstantValue(initializerPath, seen);</span><span class="s3">\n        </span><span class="s1">if (constValue !== undefined) {</span><span class="s3">\n          </span><span class="s1">seen.set(name, constValue);</span><span class="s3">\n          </span><span class="s1">if (typeof constValue === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">value = t.numericLiteral(constValue);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">assert(typeof constValue === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">value = t.stringLiteral(constValue);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">isPure &amp;&amp;= initializerPath.isPure();</span><span class="s3">\n\n          </span><span class="s1">if (initializerPath.isReferencedIdentifier()) {</span><span class="s3">\n            </span><span class="s1">ReferencedIdentifier(initializerPath, {</span><span class="s3">\n              </span><span class="s1">t,</span><span class="s3">\n              </span><span class="s1">seen,</span><span class="s3">\n              </span><span class="s1">path,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">initializerPath.traverse(enumSelfReferenceVisitor, {</span><span class="s3">\n              </span><span class="s1">t,</span><span class="s3">\n              </span><span class="s1">seen,</span><span class="s3">\n              </span><span class="s1">path,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">value = initializerPath.node;</span><span class="s3">\n          </span><span class="s1">seen.set(name, undefined);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (typeof constValue === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">constValue += 1;</span><span class="s3">\n        </span><span class="s1">value = t.numericLiteral(constValue);</span><span class="s3">\n        </span><span class="s1">seen.set(name, constValue);</span><span class="s3">\n      </span><span class="s1">} else if (typeof constValue === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\&quot;</span><span class="s1">Enum member must have initializer.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// create dynamic initializer: 1 + ENUM[</span><span class="s3">\&quot;</span><span class="s1">PREVIOUS</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">const lastRef = t.memberExpression(</span><span class="s3">\n          </span><span class="s1">t.cloneNode(path.node.id),</span><span class="s3">\n          </span><span class="s1">t.stringLiteral(lastName),</span><span class="s3">\n          </span><span class="s1">true,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">value = t.binaryExpression(</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">, t.numericLiteral(1), lastRef);</span><span class="s3">\n        </span><span class="s1">seen.set(name, undefined);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">lastName = name;</span><span class="s3">\n      </span><span class="s1">return [name, value];</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">isPure,</span><span class="s3">\n    </span><span class="s1">data: seen,</span><span class="s3">\n    </span><span class="s1">enumValues,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Based on the TypeScript repository's `computeConstantValue` in `checker.ts`.</span><span class="s3">\n</span><span class="s1">function computeConstantValue(</span><span class="s3">\n  </span><span class="s1">path: NodePath,</span><span class="s3">\n  </span><span class="s1">prevMembers?: PreviousEnumMembers,</span><span class="s3">\n  </span><span class="s1">seen: Set&lt;t.Identifier&gt; = new Set(),</span><span class="s3">\n</span><span class="s1">): number | string | undefined {</span><span class="s3">\n  </span><span class="s1">return evaluate(path);</span><span class="s3">\n\n  </span><span class="s1">function evaluate(path: NodePath): number | string | undefined {</span><span class="s3">\n    </span><span class="s1">const expr = path.node;</span><span class="s3">\n    </span><span class="s1">switch (expr.type) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">MemberExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return evaluateRef(path, prevMembers, seen);</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">StringLiteral</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return expr.value;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">UnaryExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return evalUnaryExpression(path as NodePath&lt;t.UnaryExpression&gt;);</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">BinaryExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return evalBinaryExpression(path as NodePath&lt;t.BinaryExpression&gt;);</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">NumericLiteral</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return expr.value;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return evaluate(path.get(</span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return evaluateRef(path, prevMembers, seen);</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TemplateLiteral</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">if (expr.quasis.length === 1) {</span><span class="s3">\n          </span><span class="s1">return expr.quasis[0].value.cooked;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const paths = (path as NodePath&lt;t.TemplateLiteral&gt;).get(</span><span class="s3">\&quot;</span><span class="s1">expressions</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const quasis = expr.quasis;</span><span class="s3">\n        </span><span class="s1">let str = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\n        </span><span class="s1">for (let i = 0; i &lt; quasis.length; i++) {</span><span class="s3">\n          </span><span class="s1">str += quasis[i].value.cooked;</span><span class="s3">\n\n          </span><span class="s1">if (i + 1 &lt; quasis.length) {</span><span class="s3">\n            </span><span class="s1">const value = evaluateRef(paths[i], prevMembers, seen);</span><span class="s3">\n            </span><span class="s1">if (value === undefined) return undefined;</span><span class="s3">\n            </span><span class="s1">str += value;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return str;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function evaluateRef(</span><span class="s3">\n    </span><span class="s1">path: NodePath,</span><span class="s3">\n    </span><span class="s1">prevMembers: PreviousEnumMembers,</span><span class="s3">\n    </span><span class="s1">seen: Set&lt;t.Identifier&gt;,</span><span class="s3">\n  </span><span class="s1">): number | string | undefined {</span><span class="s3">\n    </span><span class="s1">if (path.isMemberExpression()) {</span><span class="s3">\n      </span><span class="s1">const expr = path.node;</span><span class="s3">\n\n      </span><span class="s1">const obj = expr.object;</span><span class="s3">\n      </span><span class="s1">const prop = expr.property;</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!t.isIdentifier(obj) ||</span><span class="s3">\n        </span><span class="s1">(expr.computed ? !t.isStringLiteral(prop) : !t.isIdentifier(prop))</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const bindingIdentifier = path.scope.getBindingIdentifier(obj.name);</span><span class="s3">\n      </span><span class="s1">const data = ENUMS.get(bindingIdentifier);</span><span class="s3">\n      </span><span class="s1">if (!data) return;</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error checked above</span><span class="s3">\n      </span><span class="s1">return data.get(prop.computed ? prop.value : prop.name);</span><span class="s3">\n    </span><span class="s1">} else if (path.isIdentifier()) {</span><span class="s3">\n      </span><span class="s1">const name = path.node.name;</span><span class="s3">\n\n      </span><span class="s1">if ([</span><span class="s3">\&quot;</span><span class="s1">Infinity</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">NaN</span><span class="s3">\&quot;</span><span class="s1">].includes(name)) {</span><span class="s3">\n        </span><span class="s1">return Number(name);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let value = prevMembers?.get(name);</span><span class="s3">\n      </span><span class="s1">if (value !== undefined) {</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (seen.has(path.node)) return;</span><span class="s3">\n\n      </span><span class="s1">const bindingInitPath = path.resolve(); // It only resolves constant bindings</span><span class="s3">\n      </span><span class="s1">if (bindingInitPath) {</span><span class="s3">\n        </span><span class="s1">seen.add(path.node);</span><span class="s3">\n\n        </span><span class="s1">value = computeConstantValue(bindingInitPath, undefined, seen);</span><span class="s3">\n        </span><span class="s1">prevMembers?.set(name, value);</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function evalUnaryExpression(</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;t.UnaryExpression&gt;,</span><span class="s3">\n  </span><span class="s1">): number | string | undefined {</span><span class="s3">\n    </span><span class="s1">const value = evaluate(path.get(</span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">if (value === undefined) {</span><span class="s3">\n      </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">switch (path.node.operator) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return -value;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">~</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return ~value;</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function evalBinaryExpression(</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;t.BinaryExpression&gt;,</span><span class="s3">\n  </span><span class="s1">): number | string | undefined {</span><span class="s3">\n    </span><span class="s1">const left = evaluate(path.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">)) as any;</span><span class="s3">\n    </span><span class="s1">if (left === undefined) {</span><span class="s3">\n      </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const right = evaluate(path.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">)) as any;</span><span class="s3">\n    </span><span class="s1">if (right === undefined) {</span><span class="s3">\n      </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">switch (path.node.operator) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left | right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left &amp; right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&gt;&gt;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left &gt;&gt; right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&gt;&gt;&gt;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left &gt;&gt;&gt; right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&lt;&lt;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left &lt;&lt; right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left ^ right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left * right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left / right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left + right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left - right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left % right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">**</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left ** right;</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;}</span></pre>
</body>
</html>
<html>
<head>
<title>ReactRootView.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #629755; font-weight: bold; font-style: italic;}
.s5 { color: #6a8759;}
.s6 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ReactRootView.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react</span><span class="s2">;</span>

<span class="s2">import static </span><span class="s1">com.facebook.infer.annotation.ThreadConfined.UI</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.uimanager.common.UIManagerType.DEFAULT</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.uimanager.common.UIManagerType.FABRIC</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.systrace.Systrace.TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.app.Activity</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.content.Context</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.content.ContextWrapper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Canvas</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Insets</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Point</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Rect</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.os.Build</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.os.Bundle</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.util.AttributeSet</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.util.DisplayMetrics</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.DisplayCutout</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.KeyEvent</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.MotionEvent</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.Surface</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.View</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.ViewGroup</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.ViewTreeObserver</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.WindowInsets</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.WindowManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.widget.FrameLayout</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.RequiresApi</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.logging.FLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.infer.annotation.Assertions</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.infer.annotation.ThreadConfined</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.Arguments</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.CatalystInstance</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactContext</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactMarker</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactNoCrashSoftException</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactSoftExceptionLogger</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.UIManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.UiThreadUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.WritableMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.WritableNativeMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.annotations.VisibleForTesting</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.config.ReactFeatureFlags</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.modules.appregistry.AppRegistry</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.modules.deviceinfo.DeviceInfoModule</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.surface.ReactStage</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.DisplayMetricsHolder</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.IllegalViewOperationException</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.JSPointerDispatcher</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.JSTouchDispatcher</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.PixelUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactClippingProhibitedView</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactRoot</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactRootViewTagGenerator</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.RootView</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.RootViewUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.UIManagerHelper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.common.UIManagerType</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.events.EventDispatcher</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.systrace.Systrace</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.concurrent.atomic.AtomicInteger</span><span class="s2">;</span>

<span class="s3">/**</span>
 <span class="s3">* Default root view for catalyst apps. Provides the ability to listen for size changes so that a UI</span>
 <span class="s3">* manager can re-layout its elements. It delegates handling touch events for itself and child views</span>
 <span class="s3">* and sending those events to JS by using JSTouchDispatcher. This view is overriding {</span><span class="s4">@link</span>
 <span class="s3">* ViewGroup#onInterceptTouchEvent} method in order to be notified about the events for all of its</span>
 <span class="s3">* children and it's also overriding {</span><span class="s4">@link </span><span class="s3">ViewGroup#requestDisallowInterceptTouchEvent} to make</span>
 <span class="s3">* sure that {</span><span class="s4">@link </span><span class="s3">ViewGroup#onInterceptTouchEvent} will get events even when some child view start</span>
 <span class="s3">* intercepting it. In case when no child view is interested in handling some particular touch</span>
 <span class="s3">* event, this view's {</span><span class="s4">@link </span><span class="s3">View#onTouchEvent} will still return true in order to be notified about</span>
 <span class="s3">* all subsequent touch events related to that gesture (in case when JS code wants to handle that</span>
 <span class="s3">* gesture).</span>
 <span class="s3">*/</span>
<span class="s2">public class </span><span class="s1">ReactRootView </span><span class="s2">extends </span><span class="s1">FrameLayout </span><span class="s2">implements </span><span class="s1">RootView</span><span class="s2">, </span><span class="s1">ReactRoot {</span>

  <span class="s3">/** Listener interface for react root view events */</span>
  <span class="s2">public interface </span><span class="s1">ReactRootViewEventListener {</span>
    <span class="s3">/** Called when the react context is attached to a ReactRootView. */</span>
    <span class="s2">void </span><span class="s1">onAttachedToReactInstance(ReactRootView rootView)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private static final </span><span class="s1">String TAG = </span><span class="s5">&quot;ReactRootView&quot;</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable ReactInstanceManager mReactInstanceManager</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable String mJSModuleName</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Bundle mAppProperties</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable String mInitialUITemplate</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable CustomGlobalLayoutListener mCustomGlobalLayoutListener</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable ReactRootViewEventListener mRootViewEventListener</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mRootViewTag =</span>
      <span class="s6">0</span><span class="s2">; </span><span class="s0">/* This should be View.NO_ID, but for legacy reasons we haven't migrated yet */</span>
  <span class="s2">private boolean </span><span class="s1">mIsAttachedToInstance</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mShouldLogContentAppeared</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable JSTouchDispatcher mJSTouchDispatcher</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable JSPointerDispatcher mJSPointerDispatcher</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">ReactAndroidHWInputDeviceHelper mAndroidHWInputDeviceHelper =</span>
      <span class="s2">new </span><span class="s1">ReactAndroidHWInputDeviceHelper(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mWasMeasured = </span><span class="s2">false;</span>
  <span class="s2">private int </span><span class="s1">mWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">MeasureSpec.UNSPECIFIED)</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">MeasureSpec.UNSPECIFIED)</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mLastWidth = </span><span class="s6">0</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mLastHeight = </span><span class="s6">0</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mLastOffsetX = Integer.MIN_VALUE</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mLastOffsetY = Integer.MIN_VALUE</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@UIManagerType </span><span class="s2">int </span><span class="s1">mUIManagerType = DEFAULT</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">AtomicInteger mState = </span><span class="s2">new </span><span class="s1">AtomicInteger(STATE_STOPPED)</span><span class="s2">;</span>

  <span class="s2">public </span><span class="s1">ReactRootView(Context context) {</span>
    <span class="s2">super</span><span class="s1">(context)</span><span class="s2">;</span>
    <span class="s1">init()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">ReactRootView(Context context</span><span class="s2">, </span><span class="s1">AttributeSet attrs) {</span>
    <span class="s2">super</span><span class="s1">(context</span><span class="s2">, </span><span class="s1">attrs)</span><span class="s2">;</span>
    <span class="s1">init()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">ReactRootView(Context context</span><span class="s2">, </span><span class="s1">AttributeSet attrs</span><span class="s2">, int </span><span class="s1">defStyle) {</span>
    <span class="s2">super</span><span class="s1">(context</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">defStyle)</span><span class="s2">;</span>
    <span class="s1">init()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">init() {</span>
    <span class="s1">setRootViewTag(ReactRootViewTagGenerator.getNextRootViewTag())</span><span class="s2">;</span>
    <span class="s1">setClipChildren(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onMeasure(</span><span class="s2">int </span><span class="s1">widthMeasureSpec</span><span class="s2">, int </span><span class="s1">heightMeasureSpec) {</span>
    <span class="s1">Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s5">&quot;ReactRootView.onMeasure&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">ReactMarker.logMarker(ReactMarkerConstants.ROOT_VIEW_ON_MEASURE_START)</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">boolean </span><span class="s1">measureSpecsUpdated =</span>
          <span class="s1">widthMeasureSpec != mWidthMeasureSpec || heightMeasureSpec != mHeightMeasureSpec</span><span class="s2">;</span>
      <span class="s1">mWidthMeasureSpec = widthMeasureSpec</span><span class="s2">;</span>
      <span class="s1">mHeightMeasureSpec = heightMeasureSpec</span><span class="s2">;</span>

      <span class="s2">int </span><span class="s1">width = </span><span class="s6">0</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">height = </span><span class="s6">0</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">widthMode = MeasureSpec.getMode(widthMeasureSpec)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.UNSPECIFIED) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i &lt; getChildCount()</span><span class="s2">; </span><span class="s1">i++) {</span>
          <span class="s1">View child = getChildAt(i)</span><span class="s2">;</span>
          <span class="s2">int </span><span class="s1">childSize =</span>
              <span class="s1">child.getLeft()</span>
                  <span class="s1">+ child.getMeasuredWidth()</span>
                  <span class="s1">+ child.getPaddingLeft()</span>
                  <span class="s1">+ child.getPaddingRight()</span><span class="s2">;</span>
          <span class="s1">width = Math.max(width</span><span class="s2">, </span><span class="s1">childSize)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">width = MeasureSpec.getSize(widthMeasureSpec)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">int </span><span class="s1">heightMode = MeasureSpec.getMode(heightMeasureSpec)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i &lt; getChildCount()</span><span class="s2">; </span><span class="s1">i++) {</span>
          <span class="s1">View child = getChildAt(i)</span><span class="s2">;</span>
          <span class="s2">int </span><span class="s1">childSize =</span>
              <span class="s1">child.getTop()</span>
                  <span class="s1">+ child.getMeasuredHeight()</span>
                  <span class="s1">+ child.getPaddingTop()</span>
                  <span class="s1">+ child.getPaddingBottom()</span><span class="s2">;</span>
          <span class="s1">height = Math.max(height</span><span class="s2">, </span><span class="s1">childSize)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">height = MeasureSpec.getSize(heightMeasureSpec)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">setMeasuredDimension(width</span><span class="s2">, </span><span class="s1">height)</span><span class="s2">;</span>
      <span class="s1">mWasMeasured = </span><span class="s2">true;</span>

      <span class="s0">// Check if we were waiting for onMeasure to attach the root view.</span>
      <span class="s2">if </span><span class="s1">(hasActiveReactInstance() &amp;&amp; !isViewAttachedToReactInstance()) {</span>
        <span class="s1">attachToReactInstanceManager()</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(measureSpecsUpdated || mLastWidth != width || mLastHeight != height) {</span>
        <span class="s1">updateRootLayoutSpecs(</span><span class="s2">true, </span><span class="s1">mWidthMeasureSpec</span><span class="s2">, </span><span class="s1">mHeightMeasureSpec)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">mLastWidth = width</span><span class="s2">;</span>
      <span class="s1">mLastHeight = height</span><span class="s2">;</span>

    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">ReactMarker.logMarker(ReactMarkerConstants.ROOT_VIEW_ON_MEASURE_END)</span><span class="s2">;</span>
      <span class="s1">Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onChildStartedNativeGesture(MotionEvent ev) {</span>
    <span class="s1">onChildStartedNativeGesture(</span><span class="s2">null, </span><span class="s1">ev)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onChildStartedNativeGesture(View childView</span><span class="s2">, </span><span class="s1">MotionEvent ev) {</span>
    <span class="s2">if </span><span class="s1">(!isDispatcherReady()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">ReactContext reactContext = getCurrentReactContext()</span><span class="s2">;</span>
    <span class="s1">UIManager uiManager = UIManagerHelper.getUIManager(reactContext</span><span class="s2">, </span><span class="s1">getUIManagerType())</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(uiManager != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">EventDispatcher eventDispatcher = uiManager.getEventDispatcher()</span><span class="s2">;</span>
      <span class="s1">mJSTouchDispatcher.onChildStartedNativeGesture(ev</span><span class="s2">, </span><span class="s1">eventDispatcher)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(childView != </span><span class="s2">null </span><span class="s1">&amp;&amp; mJSPointerDispatcher != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">mJSPointerDispatcher.onChildStartedNativeGesture(childView</span><span class="s2">, </span><span class="s1">ev</span><span class="s2">, </span><span class="s1">eventDispatcher)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onChildEndedNativeGesture(View childView</span><span class="s2">, </span><span class="s1">MotionEvent ev) {</span>
    <span class="s2">if </span><span class="s1">(!isDispatcherReady()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">ReactContext reactContext = getCurrentReactContext()</span><span class="s2">;</span>
    <span class="s1">UIManager uiManager = UIManagerHelper.getUIManager(reactContext</span><span class="s2">, </span><span class="s1">getUIManagerType())</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(uiManager != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">EventDispatcher eventDispatcher = uiManager.getEventDispatcher()</span><span class="s2">;</span>
      <span class="s1">mJSTouchDispatcher.onChildEndedNativeGesture(ev</span><span class="s2">, </span><span class="s1">eventDispatcher)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(mJSPointerDispatcher != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">mJSPointerDispatcher.onChildEndedNativeGesture()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private boolean </span><span class="s1">isDispatcherReady() {</span>
    <span class="s2">if </span><span class="s1">(!hasActiveReactContext() || !isViewAttachedToReactInstance()) {</span>
      <span class="s1">FLog.w(TAG</span><span class="s2">, </span><span class="s5">&quot;Unable to dispatch touch to JS as the catalyst instance has not been attached&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(mJSTouchDispatcher == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">FLog.w(TAG</span><span class="s2">, </span><span class="s5">&quot;Unable to dispatch touch to JS before the dispatcher is available&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(ReactFeatureFlags.dispatchPointerEvents &amp;&amp; mJSPointerDispatcher == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">FLog.w(TAG</span><span class="s2">, </span><span class="s5">&quot;Unable to dispatch pointer events to JS before the dispatcher is available&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>

    <span class="s2">return true;</span>
  <span class="s1">}</span>

  <span class="s0">// By default the JS touch events are dispatched at the root view. This can be overridden in</span>
  <span class="s0">// subclasses as needed.</span>
  <span class="s2">public boolean </span><span class="s1">shouldDispatchJSTouchEvent(MotionEvent ev) {</span>
    <span class="s2">return true;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">onInterceptTouchEvent(MotionEvent ev) {</span>
    <span class="s2">if </span><span class="s1">(shouldDispatchJSTouchEvent(ev)) {</span>
      <span class="s1">dispatchJSTouchEvent(ev)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">dispatchJSPointerEvent(ev</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return super</span><span class="s1">.onInterceptTouchEvent(ev)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">onTouchEvent(MotionEvent ev) {</span>
    <span class="s2">if </span><span class="s1">(shouldDispatchJSTouchEvent(ev)) {</span>
      <span class="s1">dispatchJSTouchEvent(ev)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">dispatchJSPointerEvent(ev</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">super</span><span class="s1">.onTouchEvent(ev)</span><span class="s2">;</span>
    <span class="s0">// In case when there is no children interested in handling touch event, we return true from</span>
    <span class="s0">// the root view in order to receive subsequent events related to that gesture</span>
    <span class="s2">return true;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">onInterceptHoverEvent(MotionEvent ev) {</span>
    <span class="s1">dispatchJSPointerEvent(ev</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return super</span><span class="s1">.onInterceptHoverEvent(ev)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">onHoverEvent(MotionEvent ev) {</span>
    <span class="s1">dispatchJSPointerEvent(ev</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return super</span><span class="s1">.onHoverEvent(ev)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">dispatchDraw(Canvas canvas) {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">super</span><span class="s1">.dispatchDraw(canvas)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(StackOverflowError e) {</span>
      <span class="s0">// Adding special exception management for StackOverflowError for logging purposes.</span>
      <span class="s0">// This will be removed in the future.</span>
      <span class="s1">handleException(e)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">dispatchKeyEvent(KeyEvent ev) {</span>
    <span class="s2">if </span><span class="s1">(!hasActiveReactContext() || !isViewAttachedToReactInstance()) {</span>
      <span class="s1">FLog.w(TAG</span><span class="s2">, </span><span class="s5">&quot;Unable to handle key event as the catalyst instance has not been attached&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return super</span><span class="s1">.dispatchKeyEvent(ev)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mAndroidHWInputDeviceHelper.handleKeyEvent(ev)</span><span class="s2">;</span>
    <span class="s2">return super</span><span class="s1">.dispatchKeyEvent(ev)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onFocusChanged(</span><span class="s2">boolean </span><span class="s1">gainFocus</span><span class="s2">, int </span><span class="s1">direction</span><span class="s2">, </span><span class="s1">Rect previouslyFocusedRect) {</span>
    <span class="s2">if </span><span class="s1">(!hasActiveReactContext() || !isViewAttachedToReactInstance()) {</span>
      <span class="s1">FLog.w(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s5">&quot;Unable to handle focus changed event as the catalyst instance has not been attached&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">super</span><span class="s1">.onFocusChanged(gainFocus</span><span class="s2">, </span><span class="s1">direction</span><span class="s2">, </span><span class="s1">previouslyFocusedRect)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">mAndroidHWInputDeviceHelper.clearFocus()</span><span class="s2">;</span>
    <span class="s2">super</span><span class="s1">.onFocusChanged(gainFocus</span><span class="s2">, </span><span class="s1">direction</span><span class="s2">, </span><span class="s1">previouslyFocusedRect)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">requestChildFocus(View child</span><span class="s2">, </span><span class="s1">View focused) {</span>
    <span class="s2">if </span><span class="s1">(!hasActiveReactContext() || !isViewAttachedToReactInstance()) {</span>
      <span class="s1">FLog.w(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s5">&quot;Unable to handle child focus changed event as the catalyst instance has not been attached&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">super</span><span class="s1">.requestChildFocus(child</span><span class="s2">, </span><span class="s1">focused)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">mAndroidHWInputDeviceHelper.onFocusChanged(focused)</span><span class="s2">;</span>
    <span class="s2">super</span><span class="s1">.requestChildFocus(child</span><span class="s2">, </span><span class="s1">focused)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">protected void </span><span class="s1">dispatchJSPointerEvent(MotionEvent event</span><span class="s2">, boolean </span><span class="s1">isCapture) {</span>
    <span class="s2">if </span><span class="s1">(!hasActiveReactContext() || !isViewAttachedToReactInstance()) {</span>
      <span class="s1">FLog.w(TAG</span><span class="s2">, </span><span class="s5">&quot;Unable to dispatch touch to JS as the catalyst instance has not been attached&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(mJSPointerDispatcher == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(!ReactFeatureFlags.dispatchPointerEvents) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s1">FLog.w(TAG</span><span class="s2">, </span><span class="s5">&quot;Unable to dispatch pointer events to JS before the dispatcher is available&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">ReactContext reactContext = getCurrentReactContext()</span><span class="s2">;</span>
    <span class="s1">UIManager uiManager = UIManagerHelper.getUIManager(reactContext</span><span class="s2">, </span><span class="s1">getUIManagerType())</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(uiManager != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">EventDispatcher eventDispatcher = uiManager.getEventDispatcher()</span><span class="s2">;</span>
      <span class="s1">mJSPointerDispatcher.handleMotionEvent(event</span><span class="s2">, </span><span class="s1">eventDispatcher</span><span class="s2">, </span><span class="s1">isCapture)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">protected void </span><span class="s1">dispatchJSTouchEvent(MotionEvent event) {</span>
    <span class="s2">if </span><span class="s1">(!hasActiveReactContext() || !isViewAttachedToReactInstance()) {</span>
      <span class="s1">FLog.w(TAG</span><span class="s2">, </span><span class="s5">&quot;Unable to dispatch touch to JS as the catalyst instance has not been attached&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(mJSTouchDispatcher == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">FLog.w(TAG</span><span class="s2">, </span><span class="s5">&quot;Unable to dispatch touch to JS before the dispatcher is available&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">ReactContext reactContext = getCurrentReactContext()</span><span class="s2">;</span>
    <span class="s1">UIManager uiManager = UIManagerHelper.getUIManager(reactContext</span><span class="s2">, </span><span class="s1">getUIManagerType())</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(uiManager != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">EventDispatcher eventDispatcher = uiManager.getEventDispatcher()</span><span class="s2">;</span>
      <span class="s1">mJSTouchDispatcher.handleTouchEvent(event</span><span class="s2">, </span><span class="s1">eventDispatcher)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">requestDisallowInterceptTouchEvent(</span><span class="s2">boolean </span><span class="s1">disallowIntercept) {</span>
    <span class="s0">// Override in order to still receive events to onInterceptTouchEvent even when some other</span>
    <span class="s0">// views disallow that, but propagate it up the tree if possible.</span>
    <span class="s2">if </span><span class="s1">(getParent() != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">getParent().requestDisallowInterceptTouchEvent(disallowIntercept)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onLayout(</span><span class="s2">boolean </span><span class="s1">changed</span><span class="s2">, int </span><span class="s1">left</span><span class="s2">, int </span><span class="s1">top</span><span class="s2">, int </span><span class="s1">right</span><span class="s2">, int </span><span class="s1">bottom) {</span>
    <span class="s0">// No-op in non-Fabric since UIManagerModule handles actually laying out children.</span>

    <span class="s0">// In Fabric, update LayoutSpecs just so we update the offsetX and offsetY.</span>
    <span class="s2">if </span><span class="s1">(mWasMeasured &amp;&amp; isFabric()) {</span>
      <span class="s1">updateRootLayoutSpecs(</span><span class="s2">false, </span><span class="s1">mWidthMeasureSpec</span><span class="s2">, </span><span class="s1">mHeightMeasureSpec)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private boolean </span><span class="s1">isFabric() {</span>
    <span class="s2">return </span><span class="s1">getUIManagerType() == FABRIC</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onAttachedToWindow() {</span>
    <span class="s2">super</span><span class="s1">.onAttachedToWindow()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isViewAttachedToReactInstance()) {</span>
      <span class="s1">removeOnGlobalLayoutListener()</span><span class="s2">;</span>
      <span class="s1">getViewTreeObserver().addOnGlobalLayoutListener(getCustomGlobalLayoutListener())</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onDetachedFromWindow() {</span>
    <span class="s2">super</span><span class="s1">.onDetachedFromWindow()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isViewAttachedToReactInstance()) {</span>
      <span class="s1">removeOnGlobalLayoutListener()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">removeOnGlobalLayoutListener() {</span>
    <span class="s1">getViewTreeObserver().removeOnGlobalLayoutListener(getCustomGlobalLayoutListener())</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onViewAdded(</span><span class="s2">final </span><span class="s1">View child) {</span>
    <span class="s2">super</span><span class="s1">.onViewAdded(child)</span><span class="s2">;</span>

    <span class="s0">// See comments in {@code ReactRootViewProhibitedChildView} for why we want this mechanism.</span>
    <span class="s2">if </span><span class="s1">(child </span><span class="s2">instanceof </span><span class="s1">ReactClippingProhibitedView) {</span>
      <span class="s1">UiThreadUtil.runOnUiThread(</span>
          <span class="s2">new </span><span class="s1">Runnable() {</span>
            <span class="s1">@Override</span>
            <span class="s2">public void </span><span class="s1">run() {</span>
              <span class="s2">if </span><span class="s1">(!child.isShown()) {</span>
                <span class="s1">ReactSoftExceptionLogger.logSoftException(</span>
                    <span class="s1">TAG</span><span class="s2">,</span>
                    <span class="s2">new </span><span class="s1">ReactNoCrashSoftException(</span>
                        <span class="s5">&quot;A view was illegally added as a child of a ReactRootView. &quot;</span>
                            <span class="s1">+ </span><span class="s5">&quot;This View should not be a direct child of a ReactRootView, because it is not visible and will never be reachable. Child: &quot;</span>
                            <span class="s1">+ child.getClass().getCanonicalName().toString()</span>
                            <span class="s1">+ </span><span class="s5">&quot; child ID: &quot;</span>
                            <span class="s1">+ child.getId()))</span><span class="s2">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mShouldLogContentAppeared) {</span>
      <span class="s1">mShouldLogContentAppeared = </span><span class="s2">false;</span>

      <span class="s2">if </span><span class="s1">(mJSModuleName != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">ReactMarker.logMarker(ReactMarkerConstants.CONTENT_APPEARED</span><span class="s2">, </span><span class="s1">mJSModuleName</span><span class="s2">, </span><span class="s1">mRootViewTag)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">ViewGroup getRootViewGroup() {</span>
    <span class="s2">return this;</span>
  <span class="s1">}</span>

  <span class="s3">/** {</span><span class="s4">@see </span><span class="s3">#startReactApplication(ReactInstanceManager, String, android.os.Bundle)} */</span>
  <span class="s2">public void </span><span class="s1">startReactApplication(ReactInstanceManager reactInstanceManager</span><span class="s2">, </span><span class="s1">String moduleName) {</span>
    <span class="s1">startReactApplication(reactInstanceManager</span><span class="s2">, </span><span class="s1">moduleName</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** {</span><span class="s4">@see </span><span class="s3">#startReactApplication(ReactInstanceManager, String, android.os.Bundle, String)} */</span>
  <span class="s2">public void </span><span class="s1">startReactApplication(</span>
      <span class="s1">ReactInstanceManager reactInstanceManager</span><span class="s2">,</span>
      <span class="s1">String moduleName</span><span class="s2">,</span>
      <span class="s1">@Nullable Bundle initialProperties) {</span>
    <span class="s1">startReactApplication(reactInstanceManager</span><span class="s2">, </span><span class="s1">moduleName</span><span class="s2">, </span><span class="s1">initialProperties</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Schedule rendering of the react component rendered by the JS application from the given JS</span>
   <span class="s3">* module (@{param moduleName}) using provided {</span><span class="s4">@param </span><span class="s3">reactInstanceManager} to attach to the JS</span>
   <span class="s3">* context of that manager. Extra parameter {</span><span class="s4">@param </span><span class="s3">launchOptions} can be used to pass initial</span>
   <span class="s3">* properties for the react component.</span>
   <span class="s3">*/</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">startReactApplication(</span>
      <span class="s1">ReactInstanceManager reactInstanceManager</span><span class="s2">,</span>
      <span class="s1">String moduleName</span><span class="s2">,</span>
      <span class="s1">@Nullable Bundle initialProperties</span><span class="s2">,</span>
      <span class="s1">@Nullable String initialUITemplate) {</span>
    <span class="s1">Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s5">&quot;startReactApplication&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

      <span class="s0">// TODO(6788889): Use POJO instead of bundle here, apparently we can't just use WritableMap</span>
      <span class="s0">// here as it may be deallocated in native after passing via JNI bridge, but we want to reuse</span>
      <span class="s0">// it in the case of re-creating the catalyst instance</span>
      <span class="s1">Assertions.assertCondition(</span>
          <span class="s1">mReactInstanceManager == </span><span class="s2">null,</span>
          <span class="s5">&quot;This root view has already been attached to a catalyst instance manager&quot;</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s1">mReactInstanceManager = reactInstanceManager</span><span class="s2">;</span>
      <span class="s1">mJSModuleName = moduleName</span><span class="s2">;</span>
      <span class="s1">mAppProperties = initialProperties</span><span class="s2">;</span>
      <span class="s1">mInitialUITemplate = initialUITemplate</span><span class="s2">;</span>

      <span class="s1">mReactInstanceManager.createReactContextInBackground()</span><span class="s2">;</span>
      <span class="s0">// if in this experiment, we initialize the root earlier in startReactApplication</span>
      <span class="s0">// instead of waiting for the initial measure</span>
      <span class="s2">if </span><span class="s1">(ReactFeatureFlags.enableEagerRootViewAttachment) {</span>
        <span class="s2">if </span><span class="s1">(!mWasMeasured) {</span>
          <span class="s0">// Ideally, those values will be used by default, but we only update them here to scope</span>
          <span class="s0">// this change to `enableEagerRootViewAttachment` experiment.</span>
          <span class="s1">setSurfaceConstraintsToScreenSize()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">attachToReactInstanceManager()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">setSurfaceConstraintsToScreenSize() {</span>
    <span class="s1">DisplayMetrics displayMetrics = getContext().getResources().getDisplayMetrics()</span><span class="s2">;</span>
    <span class="s1">mWidthMeasureSpec =</span>
        <span class="s1">MeasureSpec.makeMeasureSpec(displayMetrics.widthPixels</span><span class="s2">, </span><span class="s1">MeasureSpec.AT_MOST)</span><span class="s2">;</span>
    <span class="s1">mHeightMeasureSpec =</span>
        <span class="s1">MeasureSpec.makeMeasureSpec(displayMetrics.heightPixels</span><span class="s2">, </span><span class="s1">MeasureSpec.AT_MOST)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public int </span><span class="s1">getWidthMeasureSpec() {</span>
    <span class="s2">return </span><span class="s1">mWidthMeasureSpec</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public int </span><span class="s1">getHeightMeasureSpec() {</span>
    <span class="s2">return </span><span class="s1">mHeightMeasureSpec</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setShouldLogContentAppeared(</span><span class="s2">boolean </span><span class="s1">shouldLogContentAppeared) {</span>
    <span class="s1">mShouldLogContentAppeared = shouldLogContentAppeared</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Nullable</span>
  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">String getSurfaceID() {</span>
    <span class="s1">Bundle appProperties = getAppProperties()</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">appProperties != </span><span class="s2">null </span><span class="s1">? appProperties.getString(</span><span class="s5">&quot;surfaceID&quot;</span><span class="s1">) : </span><span class="s2">null;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">AtomicInteger getState() {</span>
    <span class="s2">return </span><span class="s1">mState</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Call whenever measure specs change, or if you want to force an update of offsetX/offsetY. If</span>
   <span class="s3">* measureSpecsChanged is false and the offsetX/offsetY don't change, updateRootLayoutSpecs will</span>
   <span class="s3">* not be called on the UIManager as a perf optimization.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">measureSpecsChanged</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">widthMeasureSpec</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">heightMeasureSpec</span>
   <span class="s3">*/</span>
  <span class="s2">private void </span><span class="s1">updateRootLayoutSpecs(</span>
      <span class="s2">boolean </span><span class="s1">measureSpecsChanged</span><span class="s2">, final int </span><span class="s1">widthMeasureSpec</span><span class="s2">, final int </span><span class="s1">heightMeasureSpec) {</span>
    <span class="s1">ReactMarker.logMarker(ReactMarkerConstants.ROOT_VIEW_UPDATE_LAYOUT_SPECS_START)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!hasActiveReactInstance()) {</span>
      <span class="s1">ReactMarker.logMarker(ReactMarkerConstants.ROOT_VIEW_UPDATE_LAYOUT_SPECS_END)</span><span class="s2">;</span>
      <span class="s1">FLog.w(TAG</span><span class="s2">, </span><span class="s5">&quot;Unable to update root layout specs for uninitialized ReactInstanceManager&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s0">// In Fabric we cannot call `updateRootLayoutSpecs` until a SurfaceId has been set.</span>
    <span class="s0">// Sometimes,</span>
    <span class="s2">boolean </span><span class="s1">isFabricEnabled = isFabric()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isFabricEnabled &amp;&amp; !isRootViewTagSet()) {</span>
      <span class="s1">ReactMarker.logMarker(ReactMarkerConstants.ROOT_VIEW_UPDATE_LAYOUT_SPECS_END)</span><span class="s2">;</span>
      <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s5">&quot;Unable to update root layout specs for ReactRootView: no rootViewTag set yet&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">final </span><span class="s1">ReactContext reactApplicationContext = getCurrentReactContext()</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(reactApplicationContext != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">@Nullable</span>
      <span class="s1">UIManager uiManager =</span>
          <span class="s1">UIManagerHelper.getUIManager(reactApplicationContext</span><span class="s2">, </span><span class="s1">getUIManagerType())</span><span class="s2">;</span>
      <span class="s0">// Ignore calling updateRootLayoutSpecs if UIManager is not properly initialized.</span>
      <span class="s2">if </span><span class="s1">(uiManager != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// In Fabric only, get position of view within screen</span>
        <span class="s2">int </span><span class="s1">offsetX = </span><span class="s6">0</span><span class="s2">;</span>
        <span class="s2">int </span><span class="s1">offsetY = </span><span class="s6">0</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isFabricEnabled) {</span>
          <span class="s1">Point viewportOffset = RootViewUtil.getViewportOffset(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">offsetX = viewportOffset.x</span><span class="s2">;</span>
          <span class="s1">offsetY = viewportOffset.y</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(measureSpecsChanged || offsetX != mLastOffsetX || offsetY != mLastOffsetY) {</span>
          <span class="s1">uiManager.updateRootLayoutSpecs(</span>
              <span class="s1">getRootViewTag()</span><span class="s2">, </span><span class="s1">widthMeasureSpec</span><span class="s2">, </span><span class="s1">heightMeasureSpec</span><span class="s2">, </span><span class="s1">offsetX</span><span class="s2">, </span><span class="s1">offsetY)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">mLastOffsetX = offsetX</span><span class="s2">;</span>
        <span class="s1">mLastOffsetY = offsetY</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">ReactMarker.logMarker(ReactMarkerConstants.ROOT_VIEW_UPDATE_LAYOUT_SPECS_END)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Unmount the react application at this root view, reclaiming any JS memory associated with that</span>
   <span class="s3">* application. If {</span><span class="s4">@link </span><span class="s3">#startReactApplication} is called, this method must be called before the</span>
   <span class="s3">* ReactRootView is garbage collected (typically in your Activity's onDestroy, or in your</span>
   <span class="s3">* Fragment's onDestroyView).</span>
   <span class="s3">*/</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">unmountReactApplication() {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s0">// Stop surface in Fabric.</span>
    <span class="s0">// Calling FabricUIManager.stopSurface causes the C++ Binding.stopSurface</span>
    <span class="s0">// to be called synchronously over the JNI, which causes an empty tree</span>
    <span class="s0">// to be committed via the Scheduler, which will cause mounting instructions</span>
    <span class="s0">// to be queued up and synchronously executed to delete and remove</span>
    <span class="s0">// all the views in the hierarchy.</span>
    <span class="s2">if </span><span class="s1">(hasActiveReactInstance()) {</span>
      <span class="s2">final </span><span class="s1">ReactContext reactApplicationContext = getCurrentReactContext()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(reactApplicationContext != </span><span class="s2">null </span><span class="s1">&amp;&amp; isFabric()) {</span>
        <span class="s1">@Nullable</span>
        <span class="s1">UIManager uiManager =</span>
            <span class="s1">UIManagerHelper.getUIManager(reactApplicationContext</span><span class="s2">, </span><span class="s1">getUIManagerType())</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(uiManager != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">final int </span><span class="s1">surfaceId = </span><span class="s2">this</span><span class="s1">.getId()</span><span class="s2">;</span>

          <span class="s0">// In case of &quot;retry&quot; or error dialogues being shown, this ReactRootView could be</span>
          <span class="s0">// reused (with the same surfaceId, or a different one). Ensure the ReactRootView</span>
          <span class="s0">// is marked as unused in case of that.</span>
          <span class="s1">setId(NO_ID)</span><span class="s2">;</span>

          <span class="s0">// Remove all children from ReactRootView</span>
          <span class="s1">removeAllViews()</span><span class="s2">;</span>

          <span class="s2">if </span><span class="s1">(surfaceId == NO_ID) {</span>
            <span class="s1">ReactSoftExceptionLogger.logSoftException(</span>
                <span class="s1">TAG</span><span class="s2">,</span>
                <span class="s2">new </span><span class="s1">RuntimeException(</span>
                    <span class="s5">&quot;unmountReactApplication called on ReactRootView with invalid id&quot;</span><span class="s1">))</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">uiManager.stopSurface(surfaceId)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mReactInstanceManager != </span><span class="s2">null </span><span class="s1">&amp;&amp; mIsAttachedToInstance) {</span>
      <span class="s1">mReactInstanceManager.detachRootView(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">mIsAttachedToInstance = </span><span class="s2">false;</span>
    <span class="s1">}</span>
    <span class="s1">mReactInstanceManager = </span><span class="s2">null;</span>
    <span class="s1">mShouldLogContentAppeared = </span><span class="s2">false;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onStage(</span><span class="s2">int </span><span class="s1">stage) {</span>
    <span class="s2">switch </span><span class="s1">(stage) {</span>
      <span class="s2">case </span><span class="s1">ReactStage.ON_ATTACH_TO_INSTANCE:</span>
        <span class="s1">onAttachedToReactInstance()</span><span class="s2">;</span>
        <span class="s2">break;</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">break;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">onAttachedToReactInstance() {</span>
    <span class="s0">// Create the touch dispatcher here instead of having it always available, to make sure</span>
    <span class="s0">// that all touch events are only passed to JS after React/JS side is ready to consume</span>
    <span class="s0">// them. Otherwise, these events might break the states expected by JS.</span>
    <span class="s0">// Note that this callback was invoked from within the UI thread.</span>
    <span class="s1">mJSTouchDispatcher = </span><span class="s2">new </span><span class="s1">JSTouchDispatcher(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(ReactFeatureFlags.dispatchPointerEvents) {</span>
      <span class="s1">mJSPointerDispatcher = </span><span class="s2">new </span><span class="s1">JSPointerDispatcher(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mRootViewEventListener != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mRootViewEventListener.onAttachedToReactInstance(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setEventListener(@Nullable ReactRootViewEventListener eventListener) {</span>
    <span class="s1">mRootViewEventListener = eventListener</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">String getJSModuleName() {</span>
    <span class="s2">return </span><span class="s1">Assertions.assertNotNull(mJSModuleName)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">@Nullable Bundle getAppProperties() {</span>
    <span class="s2">return </span><span class="s1">mAppProperties</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">@Nullable String getInitialUITemplate() {</span>
    <span class="s2">return </span><span class="s1">mInitialUITemplate</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">setAppProperties(@Nullable Bundle appProperties) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">mAppProperties = appProperties</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isRootViewTagSet()) {</span>
      <span class="s1">runApplication()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Calls into JS to start the React application. Can be called multiple times with the same</span>
   <span class="s3">* rootTag, which will re-render the application from the root.</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">runApplication() {</span>
    <span class="s1">Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s5">&quot;ReactRootView.runApplication&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(!hasActiveReactInstance() || !isViewAttachedToReactInstance()) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>

      <span class="s1">ReactContext reactContext = getCurrentReactContext()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(reactContext == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>

      <span class="s1">CatalystInstance catalystInstance = reactContext.getCatalystInstance()</span><span class="s2">;</span>
      <span class="s1">String jsAppModuleName = getJSModuleName()</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(mWasMeasured) {</span>
        <span class="s1">updateRootLayoutSpecs(</span><span class="s2">true, </span><span class="s1">mWidthMeasureSpec</span><span class="s2">, </span><span class="s1">mHeightMeasureSpec)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">WritableNativeMap appParams = </span><span class="s2">new </span><span class="s1">WritableNativeMap()</span><span class="s2">;</span>
      <span class="s1">appParams.putDouble(</span><span class="s5">&quot;rootTag&quot;</span><span class="s2">, </span><span class="s1">getRootViewTag())</span><span class="s2">;</span>
      <span class="s1">@Nullable Bundle appProperties = getAppProperties()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(appProperties != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">appParams.putMap(</span><span class="s5">&quot;initialProps&quot;</span><span class="s2">, </span><span class="s1">Arguments.fromBundle(appProperties))</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">mShouldLogContentAppeared = </span><span class="s2">true;</span>

      <span class="s1">catalystInstance.getJSModule(AppRegistry.</span><span class="s2">class</span><span class="s1">).runApplication(jsAppModuleName</span><span class="s2">, </span><span class="s1">appParams)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Is used by unit test to setup mIsAttachedToWindow flags, that will let this view to be properly</span>
   <span class="s3">* attached to catalyst instance by startReactApplication call</span>
   <span class="s3">*/</span>
  <span class="s1">@VisibleForTesting</span>
  <span class="s0">/* package */ </span><span class="s2">void </span><span class="s1">simulateAttachForTesting() {</span>
    <span class="s1">mIsAttachedToInstance = </span><span class="s2">true;</span>
    <span class="s1">mJSTouchDispatcher = </span><span class="s2">new </span><span class="s1">JSTouchDispatcher(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ReactFeatureFlags.dispatchPointerEvents) {</span>
      <span class="s1">mJSPointerDispatcher = </span><span class="s2">new </span><span class="s1">JSPointerDispatcher(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@VisibleForTesting</span>
  <span class="s0">/* package */ </span><span class="s2">void </span><span class="s1">simulateCheckForKeyboardForTesting() {</span>
    <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) {</span>
      <span class="s1">getCustomGlobalLayoutListener().checkForKeyboardEvents()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">getCustomGlobalLayoutListener().checkForKeyboardEventsLegacy()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private </span><span class="s1">CustomGlobalLayoutListener getCustomGlobalLayoutListener() {</span>
    <span class="s2">if </span><span class="s1">(mCustomGlobalLayoutListener == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mCustomGlobalLayoutListener = </span><span class="s2">new </span><span class="s1">CustomGlobalLayoutListener()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">mCustomGlobalLayoutListener</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">attachToReactInstanceManager() {</span>
    <span class="s1">Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s5">&quot;attachToReactInstanceManager&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">ReactMarker.logMarker(ReactMarkerConstants.ROOT_VIEW_ATTACH_TO_REACT_INSTANCE_MANAGER_START)</span><span class="s2">;</span>

    <span class="s0">// React Native requires that the RootView id be managed entirely by React Native, and will</span>
    <span class="s0">// crash in addRootView/startSurface if the native View id isn't set to NO_ID.</span>

    <span class="s0">// This behavior can not be guaranteed in hybrid apps that have a native android layer over</span>
    <span class="s0">// which reactRootViews are added and the native views need to have ids on them in order to</span>
    <span class="s0">// work.</span>
    <span class="s0">// Hence this can cause unnecessary crashes at runtime for hybrid apps.</span>
    <span class="s0">// So converting this to a soft exception such that pure react-native devs can still see the</span>
    <span class="s0">// warning while hybrid apps continue to run without crashes</span>

    <span class="s2">if </span><span class="s1">(getId() != View.NO_ID) {</span>
      <span class="s1">ReactSoftExceptionLogger.logSoftException(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s2">new </span><span class="s1">IllegalViewOperationException(</span>
              <span class="s5">&quot;Trying to attach a ReactRootView with an explicit id already set to [&quot;</span>
                  <span class="s1">+ getId()</span>
                  <span class="s1">+ </span><span class="s5">&quot;]. React Native uses the id field to track react tags and will overwrite this&quot;</span>
                  <span class="s1">+ </span><span class="s5">&quot; field. If that is fine, explicitly overwrite the id field to View.NO_ID.&quot;</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(mIsAttachedToInstance) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>

      <span class="s1">mIsAttachedToInstance = </span><span class="s2">true;</span>
      <span class="s1">Assertions.assertNotNull(mReactInstanceManager).attachRootView(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">getViewTreeObserver().addOnGlobalLayoutListener(getCustomGlobalLayoutListener())</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">ReactMarker.logMarker(ReactMarkerConstants.ROOT_VIEW_ATTACH_TO_REACT_INSTANCE_MANAGER_END)</span><span class="s2">;</span>
      <span class="s1">Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">finalize() </span><span class="s2">throws </span><span class="s1">Throwable {</span>
    <span class="s2">super</span><span class="s1">.finalize()</span><span class="s2">;</span>
    <span class="s1">Assertions.assertCondition(</span>
        <span class="s1">!mIsAttachedToInstance</span><span class="s2">,</span>
        <span class="s5">&quot;The application this ReactRootView was rendering was not unmounted before the &quot;</span>
            <span class="s1">+ </span><span class="s5">&quot;ReactRootView was garbage collected. This usually means that your application is &quot;</span>
            <span class="s1">+ </span><span class="s5">&quot;leaking large amounts of memory. To solve this, make sure to call &quot;</span>
            <span class="s1">+ </span><span class="s5">&quot;ReactRootView#unmountReactApplication in the onDestroy() of your hosting Activity or in &quot;</span>
            <span class="s1">+ </span><span class="s5">&quot;the onDestroyView() of your hosting Fragment.&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public int </span><span class="s1">getRootViewTag() {</span>
    <span class="s2">return </span><span class="s1">mRootViewTag</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private boolean </span><span class="s1">isRootViewTagSet() {</span>
    <span class="s2">return </span><span class="s1">mRootViewTag != </span><span class="s6">0 </span><span class="s1">&amp;&amp; mRootViewTag != NO_ID</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setRootViewTag(</span><span class="s2">int </span><span class="s1">rootViewTag) {</span>
    <span class="s1">mRootViewTag = rootViewTag</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">handleException(</span><span class="s2">final </span><span class="s1">Throwable t) {</span>
    <span class="s2">if </span><span class="s1">(!hasActiveReactContext()) {</span>
      <span class="s2">throw new </span><span class="s1">RuntimeException(t)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">Exception e = </span><span class="s2">new </span><span class="s1">IllegalViewOperationException(t.getMessage()</span><span class="s2">, this, </span><span class="s1">t)</span><span class="s2">;</span>
    <span class="s1">getCurrentReactContext().handleException(e)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setIsFabric(</span><span class="s2">boolean </span><span class="s1">isFabric) {</span>
    <span class="s1">mUIManagerType = isFabric ? FABRIC : DEFAULT</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">@UIManagerType </span><span class="s2">int </span><span class="s1">getUIManagerType() {</span>
    <span class="s2">return </span><span class="s1">mUIManagerType</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Nullable</span>
  <span class="s2">public </span><span class="s1">ReactInstanceManager getReactInstanceManager() {</span>
    <span class="s2">return </span><span class="s1">mReactInstanceManager</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/* package */ </span><span class="s2">void </span><span class="s1">sendEvent(String eventName</span><span class="s2">, </span><span class="s1">@Nullable WritableMap params) {</span>
    <span class="s2">if </span><span class="s1">(hasActiveReactInstance()) {</span>
      <span class="s1">getCurrentReactContext().emitDeviceEvent(eventName</span><span class="s2">, </span><span class="s1">params)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public boolean </span><span class="s1">hasActiveReactInstance() {</span>
    <span class="s2">return </span><span class="s1">mReactInstanceManager != </span><span class="s2">null;</span>
  <span class="s1">}</span>

  <span class="s2">public boolean </span><span class="s1">hasActiveReactContext() {</span>
    <span class="s2">return </span><span class="s1">mReactInstanceManager != </span><span class="s2">null </span><span class="s1">&amp;&amp; mReactInstanceManager.getCurrentReactContext() != </span><span class="s2">null;</span>
  <span class="s1">}</span>

  <span class="s1">@Nullable</span>
  <span class="s2">public </span><span class="s1">ReactContext getCurrentReactContext() {</span>
    <span class="s2">return </span><span class="s1">mReactInstanceManager.getCurrentReactContext()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public boolean </span><span class="s1">isViewAttachedToReactInstance() {</span>
    <span class="s2">return </span><span class="s1">mIsAttachedToInstance</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private class </span><span class="s1">CustomGlobalLayoutListener </span><span class="s2">implements </span><span class="s1">ViewTreeObserver.OnGlobalLayoutListener {</span>
    <span class="s2">private final </span><span class="s1">Rect mVisibleViewArea</span><span class="s2">;</span>
    <span class="s2">private final int </span><span class="s1">mMinKeyboardHeightDetected</span><span class="s2">;</span>

    <span class="s2">private boolean </span><span class="s1">mKeyboardIsVisible = </span><span class="s2">false;</span>
    <span class="s2">private int </span><span class="s1">mKeyboardHeight = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">// Only used in checkForKeyboardEventsLegacy path</span>
    <span class="s2">private int </span><span class="s1">mDeviceRotation = </span><span class="s6">0</span><span class="s2">;</span>

    <span class="s0">/* package */ </span><span class="s1">CustomGlobalLayoutListener() {</span>
      <span class="s1">DisplayMetricsHolder.initDisplayMetricsIfNotInitialized(getContext().getApplicationContext())</span><span class="s2">;</span>
      <span class="s1">mVisibleViewArea = </span><span class="s2">new </span><span class="s1">Rect()</span><span class="s2">;</span>
      <span class="s1">mMinKeyboardHeightDetected = (</span><span class="s2">int</span><span class="s1">) PixelUtil.toPixelFromDIP(</span><span class="s6">60</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s2">public void </span><span class="s1">onGlobalLayout() {</span>
      <span class="s2">if </span><span class="s1">(!hasActiveReactContext() || !isViewAttachedToReactInstance()) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) {</span>
        <span class="s1">checkForKeyboardEvents()</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">checkForKeyboardEventsLegacy()</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">checkForDeviceOrientationChanges()</span><span class="s2">;</span>
      <span class="s1">checkForDeviceDimensionsChanges()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">private </span><span class="s1">Activity getActivity() {</span>
      <span class="s1">Context context = getContext()</span><span class="s2">;</span>
      <span class="s2">while </span><span class="s1">(!(context </span><span class="s2">instanceof </span><span class="s1">Activity) &amp;&amp; context </span><span class="s2">instanceof </span><span class="s1">ContextWrapper) {</span>
        <span class="s1">context = ((ContextWrapper) context).getBaseContext()</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">(Activity) context</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">@RequiresApi(api = Build.VERSION_CODES.R)</span>
    <span class="s2">private void </span><span class="s1">checkForKeyboardEvents() {</span>
      <span class="s1">getRootView().getWindowVisibleDisplayFrame(mVisibleViewArea)</span><span class="s2">;</span>
      <span class="s1">WindowInsets rootInsets = getRootView().getRootWindowInsets()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(rootInsets == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>

      <span class="s2">boolean </span><span class="s1">keyboardIsVisible = rootInsets.isVisible(WindowInsets.Type.ime())</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(keyboardIsVisible != mKeyboardIsVisible) {</span>
        <span class="s1">mKeyboardIsVisible = keyboardIsVisible</span><span class="s2">;</span>

        <span class="s2">if </span><span class="s1">(keyboardIsVisible) {</span>
          <span class="s1">Insets imeInsets = rootInsets.getInsets(WindowInsets.Type.ime())</span><span class="s2">;</span>
          <span class="s1">Insets barInsets = rootInsets.getInsets(WindowInsets.Type.systemBars())</span><span class="s2">;</span>
          <span class="s2">int </span><span class="s1">height = imeInsets.bottom - barInsets.bottom</span><span class="s2">;</span>

          <span class="s2">int </span><span class="s1">softInputMode = getActivity().getWindow().getAttributes().softInputMode</span><span class="s2">;</span>
          <span class="s2">int </span><span class="s1">screenY =</span>
              <span class="s1">softInputMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING</span>
                  <span class="s1">? mVisibleViewArea.bottom - height</span>
                  <span class="s1">: mVisibleViewArea.bottom</span><span class="s2">;</span>

          <span class="s1">sendEvent(</span>
              <span class="s5">&quot;keyboardDidShow&quot;</span><span class="s2">,</span>
              <span class="s1">createKeyboardEventPayload(</span>
                  <span class="s1">PixelUtil.toDIPFromPixel(screenY)</span><span class="s2">,</span>
                  <span class="s1">PixelUtil.toDIPFromPixel(mVisibleViewArea.left)</span><span class="s2">,</span>
                  <span class="s1">PixelUtil.toDIPFromPixel(mVisibleViewArea.width())</span><span class="s2">,</span>
                  <span class="s1">PixelUtil.toDIPFromPixel(height)))</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">sendEvent(</span>
              <span class="s5">&quot;keyboardDidHide&quot;</span><span class="s2">,</span>
              <span class="s1">createKeyboardEventPayload(</span>
                  <span class="s1">PixelUtil.toDIPFromPixel(mLastHeight)</span><span class="s2">,</span>
                  <span class="s6">0</span><span class="s2">,</span>
                  <span class="s1">PixelUtil.toDIPFromPixel(mVisibleViewArea.width())</span><span class="s2">,</span>
                  <span class="s6">0</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">private void </span><span class="s1">checkForKeyboardEventsLegacy() {</span>
      <span class="s1">getRootView().getWindowVisibleDisplayFrame(mVisibleViewArea)</span><span class="s2">;</span>

      <span class="s2">int </span><span class="s1">notchHeight = </span><span class="s6">0</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) {</span>
        <span class="s1">WindowInsets insets = getRootView().getRootWindowInsets()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(insets != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">DisplayCutout displayCutout = insets.getDisplayCutout()</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(displayCutout != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">notchHeight = displayCutout.getSafeInsetTop()</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">final int </span><span class="s1">heightDiff =</span>
          <span class="s1">DisplayMetricsHolder.getWindowDisplayMetrics().heightPixels</span>
              <span class="s1">- mVisibleViewArea.bottom</span>
              <span class="s1">+ notchHeight</span><span class="s2">;</span>

      <span class="s2">boolean </span><span class="s1">isKeyboardShowingOrKeyboardHeightChanged =</span>
          <span class="s1">mKeyboardHeight != heightDiff &amp;&amp; heightDiff &gt; mMinKeyboardHeightDetected</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(isKeyboardShowingOrKeyboardHeightChanged) {</span>
        <span class="s1">mKeyboardHeight = heightDiff</span><span class="s2">;</span>
        <span class="s1">mKeyboardIsVisible = </span><span class="s2">true;</span>
        <span class="s1">sendEvent(</span>
            <span class="s5">&quot;keyboardDidShow&quot;</span><span class="s2">,</span>
            <span class="s1">createKeyboardEventPayload(</span>
                <span class="s1">PixelUtil.toDIPFromPixel(mVisibleViewArea.bottom)</span><span class="s2">,</span>
                <span class="s1">PixelUtil.toDIPFromPixel(mVisibleViewArea.left)</span><span class="s2">,</span>
                <span class="s1">PixelUtil.toDIPFromPixel(mVisibleViewArea.width())</span><span class="s2">,</span>
                <span class="s1">PixelUtil.toDIPFromPixel(mKeyboardHeight)))</span><span class="s2">;</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>

      <span class="s2">boolean </span><span class="s1">isKeyboardHidden = mKeyboardHeight != </span><span class="s6">0 </span><span class="s1">&amp;&amp; heightDiff &lt;= mMinKeyboardHeightDetected</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(isKeyboardHidden) {</span>
        <span class="s1">mKeyboardHeight = </span><span class="s6">0</span><span class="s2">;</span>
        <span class="s1">mKeyboardIsVisible = </span><span class="s2">false;</span>
        <span class="s1">sendEvent(</span>
            <span class="s5">&quot;keyboardDidHide&quot;</span><span class="s2">,</span>
            <span class="s1">createKeyboardEventPayload(</span>
                <span class="s1">PixelUtil.toDIPFromPixel(mLastHeight)</span><span class="s2">,</span>
                <span class="s6">0</span><span class="s2">,</span>
                <span class="s1">PixelUtil.toDIPFromPixel(mVisibleViewArea.width())</span><span class="s2">,</span>
                <span class="s6">0</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">private void </span><span class="s1">checkForDeviceOrientationChanges() {</span>
      <span class="s2">final int </span><span class="s1">rotation =</span>
          <span class="s1">((WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE))</span>
              <span class="s1">.getDefaultDisplay()</span>
              <span class="s1">.getRotation()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(mDeviceRotation == rotation) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s1">mDeviceRotation = rotation</span><span class="s2">;</span>
      <span class="s1">DisplayMetricsHolder.initDisplayMetrics(getContext().getApplicationContext())</span><span class="s2">;</span>
      <span class="s1">emitOrientationChanged(rotation)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">private void </span><span class="s1">checkForDeviceDimensionsChanges() {</span>
      <span class="s0">// DeviceInfoModule caches the last dimensions emitted to JS, so we don't need to check here.</span>
      <span class="s1">emitUpdateDimensionsEvent()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">private void </span><span class="s1">emitOrientationChanged(</span><span class="s2">final int </span><span class="s1">newRotation) {</span>
      <span class="s1">String name</span><span class="s2">;</span>
      <span class="s2">double </span><span class="s1">rotationDegrees</span><span class="s2">;</span>
      <span class="s2">boolean </span><span class="s1">isLandscape = </span><span class="s2">false;</span>

      <span class="s2">switch </span><span class="s1">(newRotation) {</span>
        <span class="s2">case </span><span class="s1">Surface.ROTATION_0:</span>
          <span class="s1">name = </span><span class="s5">&quot;portrait-primary&quot;</span><span class="s2">;</span>
          <span class="s1">rotationDegrees = </span><span class="s6">0.0</span><span class="s2">;</span>
          <span class="s2">break;</span>
        <span class="s2">case </span><span class="s1">Surface.ROTATION_90:</span>
          <span class="s1">name = </span><span class="s5">&quot;landscape-primary&quot;</span><span class="s2">;</span>
          <span class="s1">rotationDegrees = -</span><span class="s6">90.0</span><span class="s2">;</span>
          <span class="s1">isLandscape = </span><span class="s2">true;</span>
          <span class="s2">break;</span>
        <span class="s2">case </span><span class="s1">Surface.ROTATION_180:</span>
          <span class="s1">name = </span><span class="s5">&quot;portrait-secondary&quot;</span><span class="s2">;</span>
          <span class="s1">rotationDegrees = </span><span class="s6">180.0</span><span class="s2">;</span>
          <span class="s2">break;</span>
        <span class="s2">case </span><span class="s1">Surface.ROTATION_270:</span>
          <span class="s1">name = </span><span class="s5">&quot;landscape-secondary&quot;</span><span class="s2">;</span>
          <span class="s1">rotationDegrees = </span><span class="s6">90.0</span><span class="s2">;</span>
          <span class="s1">isLandscape = </span><span class="s2">true;</span>
          <span class="s2">break;</span>
        <span class="s2">default</span><span class="s1">:</span>
          <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s1">WritableMap map = Arguments.createMap()</span><span class="s2">;</span>
      <span class="s1">map.putString(</span><span class="s5">&quot;name&quot;</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">;</span>
      <span class="s1">map.putDouble(</span><span class="s5">&quot;rotationDegrees&quot;</span><span class="s2">, </span><span class="s1">rotationDegrees)</span><span class="s2">;</span>
      <span class="s1">map.putBoolean(</span><span class="s5">&quot;isLandscape&quot;</span><span class="s2">, </span><span class="s1">isLandscape)</span><span class="s2">;</span>

      <span class="s1">sendEvent(</span><span class="s5">&quot;namedOrientationDidChange&quot;</span><span class="s2">, </span><span class="s1">map)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">private void </span><span class="s1">emitUpdateDimensionsEvent() {</span>
      <span class="s1">DeviceInfoModule deviceInfo =</span>
          <span class="s1">getCurrentReactContext().getNativeModule(DeviceInfoModule.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(deviceInfo != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">deviceInfo.emitUpdateDimensionsEvent()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">private </span><span class="s1">WritableMap createKeyboardEventPayload(</span>
        <span class="s2">double </span><span class="s1">screenY</span><span class="s2">, double </span><span class="s1">screenX</span><span class="s2">, double </span><span class="s1">width</span><span class="s2">, double </span><span class="s1">height) {</span>
      <span class="s1">WritableMap keyboardEventParams = Arguments.createMap()</span><span class="s2">;</span>
      <span class="s1">WritableMap endCoordinates = Arguments.createMap()</span><span class="s2">;</span>

      <span class="s1">endCoordinates.putDouble(</span><span class="s5">&quot;height&quot;</span><span class="s2">, </span><span class="s1">height)</span><span class="s2">;</span>
      <span class="s1">endCoordinates.putDouble(</span><span class="s5">&quot;screenX&quot;</span><span class="s2">, </span><span class="s1">screenX)</span><span class="s2">;</span>
      <span class="s1">endCoordinates.putDouble(</span><span class="s5">&quot;width&quot;</span><span class="s2">, </span><span class="s1">width)</span><span class="s2">;</span>
      <span class="s1">endCoordinates.putDouble(</span><span class="s5">&quot;screenY&quot;</span><span class="s2">, </span><span class="s1">screenY)</span><span class="s2">;</span>

      <span class="s1">keyboardEventParams.putMap(</span><span class="s5">&quot;endCoordinates&quot;</span><span class="s2">, </span><span class="s1">endCoordinates)</span><span class="s2">;</span>
      <span class="s1">keyboardEventParams.putString(</span><span class="s5">&quot;easing&quot;</span><span class="s2">, </span><span class="s5">&quot;keyboard&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">keyboardEventParams.putDouble(</span><span class="s5">&quot;duration&quot;</span><span class="s2">, </span><span class="s6">0</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">keyboardEventParams</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>